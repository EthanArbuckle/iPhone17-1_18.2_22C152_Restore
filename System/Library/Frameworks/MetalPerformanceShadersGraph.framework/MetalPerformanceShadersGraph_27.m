void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ModuloOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  char **v4;
  uint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unsigned char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t DefiningOp;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  _OWORD *v26;
  char *v27;
  uint64_t v28;
  long long v29;
  uint64_t v30;
  uint64_t v31;

  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (v20 = DefiningOp,
          v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      v10 = v7 - *v4;
      v11 = v10 >> 3;
      v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      v23 = (v22 >> 3) + 1;
      v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::MultiplyOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::NandOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::NegativeOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::NorOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::NotOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::NotEqualToOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::OneHotOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::OrOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::PadOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::PadGradientOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::PermuteOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::PoolAvgOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::PoolAvgGradientOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::PoolL2NormOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::PoolL2NormGradientOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::PoolMaxOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::PoolMaxGradientOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::PowerOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::PruneOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::PruneGradientOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::QuantizedGatherOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::RandomUniformOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::RandomTruncatedNormalOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::RandomNormalOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::RankOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::RealPartOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ReadDataFromFileOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ReadVariableOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ReciprocalOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ReductionAndOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ReductionArgMaxOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ReductionArgMinOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ReductionMaxOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ReductionMinOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ReductionProdOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ReductionOrOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ReductionSumOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::RegionCallOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::RegionReturnOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ReinterpretCastOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ReshapeOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ResizeOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ResizeGradientOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ReturnOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ReturnStitchedOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ReverseOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ReciprocalSquareRootOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::RintOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::RMSNormOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::RoundOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::SampleGridOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::SampleGridDataGradientOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ScaledDotProductAttentionOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ScatterOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ScatterAlongAxisOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ScatterNDOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::SelectOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ShapeOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::SignOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::SignbitOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::SinOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::SingleGateRNNOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::SingleGateRNNGradientOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::SinhOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::SizeOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::SliceOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::SoftmaxOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::SortOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::SpaceToBatchOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::SpaceToDepth2DOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::SparseDenseMatMulOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::SplitOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::SquareOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::SquareRootOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::SqueezeOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::StencilOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::StitchedOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::StridedSliceOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::StridedSliceGradientOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::StridedSliceUpdateOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::SubtractOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::TanOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::TanhOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::FromElementsOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ListPopBackOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::ListPushBackOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::TensorToMemrefOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::TileOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::TileGradientOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::TopKOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::TopKGradientOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::TransposeOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::TypeConstraintOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::UpdateRandomStateOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::VarHandleOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::VariableFromTensorOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::WhileOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::XorOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::XnorOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::YieldOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::BaseOpHandler * GPURegionRuntime::createOp<GPU::QuantizedMatMulOpHandler>(mlir::Operation *,GPU::MPSGraphKernelDAG *)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 36))
  {
    if (**(unsigned char **)a1
      || (v31 = a2 - 16, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31)) == 0)
      || (uint64_t v20 = DefiningOp,
          uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          ((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21) & 1) == 0))
    {
      v4 = *(char ***)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 24);
      v7 = v4[1];
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v7 < v6)
      {
        *(void *)v7 = v5;
        uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_28:
        v4[1] = (char *)v8;
        return;
      }
      v9 = *v4;
      uint64_t v10 = v7 - *v4;
      uint64_t v11 = v10 >> 3;
      unint64_t v12 = (v10 >> 3) + 1;
      if (v12 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v13 = v6 - (void)v9;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v15 = operator new(8 * v14);
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        *(void *)v16 = v5;
        uint64_t v8 = (uint64_t)(v16 + 8);
        v18 = (char *)(v7 - v9);
        if (v7 == v9) {
          goto LABEL_26;
        }
      }
      else
      {
        v15 = 0;
        v16 = (char *)(8 * v11);
        v17 = 0;
        *(void *)(8 * v11) = v5;
        uint64_t v8 = 8 * v11 + 8;
        v18 = (char *)(v7 - v9);
        if (v7 == v9)
        {
LABEL_26:
          *v4 = v16;
          v4[1] = (char *)v8;
          v4[2] = v17;
          if (v7) {
            operator delete(v7);
          }
          goto LABEL_28;
        }
      }
      unint64_t v22 = (unint64_t)(v18 - 8);
      if (v22 < 0x58) {
        goto LABEL_34;
      }
      if ((unint64_t)(v7 - v15 - v10) < 0x20) {
        goto LABEL_34;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v7[-v24];
      v16 -= v24;
      v26 = &v15[8 * v11 - 16];
      v27 = v7 - 16;
      uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v7 = v25;
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        do
        {
          uint64_t v30 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v16 - 1) = v30;
          v16 -= 8;
        }
        while (v7 != v9);
      }
      v7 = *v4;
      goto LABEL_26;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPURegionRuntime::evaluateOps(GPU::EncodeDescriptor *,NSArray<MPSGraphTensorData *> *,NSArray<MPSGraphTensorData *> *)::$_0>(uint64_t a1, uint64_t a2)
{
  v3 = *(mlir::Block **)(a2 + 16);
  if (!v3 || (uint64_t ParentOp = mlir::Block::getParentOp(v3)) == 0) {
    __assert_rtn("dyn_cast", "Casting.h", 662, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
  }
  if (!llvm::DefaultDoCastIfPossible<mlir::mpsx::StitchedOp,mlir::Operation *,llvm::CastInfo<mlir::mpsx::StitchedOp,mlir::Operation *,void>>::doCastIfPossible(ParentOp)
    && !llvm::DefaultDoCastIfPossible<mlir::mps::ConstantOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ConstantOp,mlir::Operation *,void>>::doCastIfPossible(a2))
  {
    unint64_t v58 = 0;
    MPSDataType v57 = MPSDataTypeInvalid;
    unint64_t v6 = computeProducedValues(a2, 0, 1, &v58, &v57);
    if (v6)
    {
      ++**(void **)a1;
      **(void **)(a1 + 8) += v58;
    }
    v7 = *(unint64_t **)(a1 + 16);
    if (v6 > *v7)
    {
      unint64_t *v7 = v6;
      **(_DWORD **)(a1 + 24) = v57;
      *(void *)(*(void *)(a1 + 32) + 8) = **(void **)(a1 + 32);
      if ((*(unsigned char *)(a2 + 46) & 0x80) != 0)
      {
        uint64_t v8 = *(unsigned int *)(a2 + 68);
        if (v8)
        {
          uint64_t v9 = 0;
          uint64_t v10 = *(void *)(a2 + 72);
          uint64_t v53 = v10;
          while (1)
          {
            uint64_t v12 = *(void *)(v10 + 32 * v9 + 24);
            unint64_t v13 = *(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8;
            if (!v13) {
              goto LABEL_13;
            }
            if (!*(void *)v13) {
              __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
            }
            unint64_t v14 = *(void **)(*(void *)v13 + 136);
            if (v14 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
              unint64_t v13 = 0;
            }
            unint64_t v56 = v13;
            if (v14 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
              goto LABEL_13;
            }
            uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v56);
            if (!v16)
            {
              uint64_t v25 = 1;
              goto LABEL_28;
            }
            uint64_t v17 = (v16 - 1) & 0x1FFFFFFFFFFFFFFFLL;
            if (!v17) {
              break;
            }
            uint64_t v18 = v17 + 1;
            uint64_t v19 = (v17 + 1) & 0x3FFFFFFFFFFFFFFELL;
            uint64_t v20 = (uint64_t *)(Value + 8 * v19);
            uint64_t v21 = (void *)(Value + 8);
            uint64_t v22 = v19;
            uint64_t v23 = 1;
            uint64_t v24 = 1;
            do
            {
              v23 *= *(v21 - 1);
              v24 *= *v21;
              v21 += 2;
              v22 -= 2;
            }
            while (v22);
            uint64_t v25 = v24 * v23;
            if (v18 != v19) {
              goto LABEL_27;
            }
LABEL_28:
            uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v12);
            if (mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf)
              || mlir::Type::isInteger((mlir::Type *)&ElementTypeOrSelf, 16))
            {
              uint64_t v27 = 2 * v25;
              uint64_t v28 = *(void *)(a1 + 32);
              uint64_t v30 = *(uint64_t **)(v28 + 8);
              unint64_t v29 = *(void *)(v28 + 16);
              if ((unint64_t)v30 >= v29) {
                goto LABEL_35;
              }
            }
            else
            {
              BOOL isInteger = mlir::Type::isInteger((mlir::Type *)&ElementTypeOrSelf, 8);
              uint64_t v32 = 4;
              if (isInteger) {
                uint64_t v32 = 1;
              }
              uint64_t v27 = v32 * v25;
              uint64_t v28 = *(void *)(a1 + 32);
              uint64_t v30 = *(uint64_t **)(v28 + 8);
              unint64_t v29 = *(void *)(v28 + 16);
              if ((unint64_t)v30 >= v29)
              {
LABEL_35:
                uint64_t v33 = v8;
                uint64_t v34 = a1;
                v35 = *(uint64_t **)v28;
                uint64_t v36 = (uint64_t)v30 - *(void *)v28;
                uint64_t v37 = v36 >> 3;
                unint64_t v38 = (v36 >> 3) + 1;
                if (v38 >> 61) {
                  std::vector<long>::__throw_length_error[abi:ne180100]();
                }
                uint64_t v39 = v29 - (void)v35;
                if (v39 >> 2 > v38) {
                  unint64_t v38 = v39 >> 2;
                }
                if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v38 = 0x1FFFFFFFFFFFFFFFLL;
                }
                unint64_t v54 = v38;
                if (v38)
                {
                  if (v38 >> 61) {
                    std::__throw_bad_array_new_length[abi:ne180100]();
                  }
                  v40 = operator new(8 * v38);
                  v41 = (uint64_t *)&v40[8 * v37];
                  uint64_t *v41 = v27;
                  uint64_t v11 = (uint64_t)(v41 + 1);
                  int64_t v42 = (char *)v30 - (char *)v35;
                  if (v30 != v35)
                  {
LABEL_43:
                    unint64_t v43 = v42 - 8;
                    if (v43 < 0x58)
                    {
                      a1 = v34;
                      uint64_t v8 = v33;
                      goto LABEL_51;
                    }
                    unint64_t v44 = (char *)v30 - v40 - v36;
                    a1 = v34;
                    uint64_t v8 = v33;
                    if (v44 < 0x20) {
                      goto LABEL_62;
                    }
                    uint64_t v45 = (v43 >> 3) + 1;
                    uint64_t v46 = 8 * (v45 & 0x3FFFFFFFFFFFFFFCLL);
                    v47 = &v30[v46 / 0xFFFFFFFFFFFFFFF8];
                    v41 = (uint64_t *)((char *)v41 - v46);
                    v48 = &v40[8 * v37 - 16];
                    v49 = v30 - 2;
                    uint64_t v50 = v45 & 0x3FFFFFFFFFFFFFFCLL;
                    do
                    {
                      long long v51 = *(_OWORD *)v49;
                      *(v48 - 1) = *((_OWORD *)v49 - 1);
                      _OWORD *v48 = v51;
                      v48 -= 2;
                      v49 -= 4;
                      v50 -= 4;
                    }
                    while (v50);
                    uint64_t v30 = v47;
                    if (v45 != (v45 & 0x3FFFFFFFFFFFFFFCLL))
                    {
LABEL_62:
                      do
                      {
LABEL_51:
                        uint64_t v52 = *--v30;
                        *--v41 = v52;
                      }
                      while (v30 != v35);
                    }
LABEL_52:
                    *(void *)uint64_t v28 = v41;
                    *(void *)(v28 + 8) = v11;
                    *(void *)(v28 + 16) = &v40[8 * v54];
                    if (v35) {
                      operator delete(v35);
                    }
                    uint64_t v10 = v53;
                    goto LABEL_12;
                  }
                }
                else
                {
                  v40 = 0;
                  v41 = (uint64_t *)(8 * v37);
                  *(void *)(8 * v37) = v27;
                  uint64_t v11 = 8 * v37 + 8;
                  int64_t v42 = (char *)v30 - (char *)v35;
                  if (v30 != v35) {
                    goto LABEL_43;
                  }
                }
                a1 = v34;
                uint64_t v8 = v33;
                goto LABEL_52;
              }
            }
            *uint64_t v30 = v27;
            uint64_t v11 = (uint64_t)(v30 + 1);
LABEL_12:
            *(void *)(v28 + 8) = v11;
LABEL_13:
            if (++v9 == v8) {
              return;
            }
          }
          uint64_t v25 = 1;
          uint64_t v20 = (uint64_t *)Value;
          do
          {
LABEL_27:
            uint64_t v26 = *v20++;
            v25 *= v26;
          }
          while (v20 != (uint64_t *)(Value + 8 * v16));
          goto LABEL_28;
        }
      }
    }
  }
}

void std::vector<std::pair<MPSGraphTensorData * {__strong},MPSGraphTensorData * {__strong}>>::__throw_out_of_range[abi:ne180100]()
{
}

void std::__hash_table<std::__hash_value_type<unsigned long,objc_object  {objcproto9MTLBuffer}* {__strong}>,std::__unordered_map_hasher<unsigned long,objc_object  {objcproto9MTLBuffer}* {__strong},std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,objc_object  {objcproto9MTLBuffer}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto9MTLBuffer}* {__strong}>>::__emplace_unique_key_args<unsigned long,unsigned long &,objc_object  {objcproto9MTLBuffer}*&>(uint64_t *a1, unint64_t a2, uint64_t a3, void *a4)
{
  unint64_t v9 = a1[1];
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (v9 <= a2) {
        unint64_t v4 = a2 % v9;
      }
    }
    else
    {
      unint64_t v4 = (v9 - 1) & a2;
    }
    uint64_t v11 = *(void **)(*a1 + 8 * v4);
    if (v11)
    {
      uint64_t v12 = (void *)*v11;
      if (v12)
      {
        if (v10.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v14 = v12[1];
            if (v14 == a2)
            {
              if (v12[2] == a2) {
                return;
              }
            }
            else if ((v14 & (v9 - 1)) != v4)
            {
              goto LABEL_22;
            }
            uint64_t v12 = (void *)*v12;
            if (!v12) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v13 = v12[1];
          if (v13 == a2)
          {
            if (v12[2] == a2) {
              return;
            }
          }
          else
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
            if (v13 != v4) {
              break;
            }
          }
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
    }
  }
LABEL_22:
  v15 = a1 + 2;
  uint64_t v16 = operator new(0x20uLL);
  void *v16 = 0;
  v16[1] = a2;
  v16[2] = a3;
  v16[3] = a4;
  float v17 = (float)(unint64_t)(a1[3] + 1);
  float v18 = *((float *)a1 + 8);
  if (!v9 || (float)(v18 * (float)v9) < v17)
  {
    BOOL v21 = 1;
    if (v9 >= 3) {
      BOOL v21 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v22 = v21 | (2 * v9);
    unint64_t v23 = vcvtps_u32_f32(v17 / v18);
    if (v22 <= v23) {
      size_t prime = v23;
    }
    else {
      size_t prime = v22;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    unint64_t v9 = a1[1];
    if (prime > v9)
    {
LABEL_36:
      if (prime >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v25 = operator new(8 * prime);
      uint64_t v26 = (void *)*a1;
      *a1 = (uint64_t)v25;
      if (v26) {
        operator delete(v26);
      }
      uint64_t v27 = 0;
      a1[1] = prime;
      do
        *(void *)(*a1 + 8 * v27++) = 0;
      while (prime != v27);
      uint64_t v28 = (void *)*v15;
      if (!*v15) {
        goto LABEL_68;
      }
      size_t v29 = v28[1];
      size_t v30 = prime - 1;
      if ((prime & (prime - 1)) == 0)
      {
        size_t v31 = v29 & v30;
        *(void *)(*a1 + 8 * v31) = v15;
        for (i = (void *)*v28; *v28; i = (void *)*v28)
        {
          size_t v33 = i[1] & v30;
          if (v33 == v31)
          {
            uint64_t v28 = i;
          }
          else if (*(void *)(*a1 + 8 * v33))
          {
            *uint64_t v28 = *i;
            uint64_t v34 = 8 * v33;
            void *i = **(void **)(*a1 + v34);
            **(void **)(*a1 + v34) = i;
          }
          else
          {
            *(void *)(*a1 + 8 * v33) = v28;
            uint64_t v28 = i;
            size_t v31 = v33;
          }
        }
        goto LABEL_68;
      }
      if (v29 >= prime) {
        v29 %= prime;
      }
      *(void *)(*a1 + 8 * v29) = v15;
      unint64_t v38 = (void *)*v28;
      if (!*v28)
      {
LABEL_68:
        unint64_t v9 = prime;
        uint64_t v41 = prime - 1;
        if ((prime & (prime - 1)) != 0) {
          goto LABEL_69;
        }
        goto LABEL_84;
      }
      while (1)
      {
        size_t v40 = v38[1];
        if (v40 >= prime) {
          v40 %= prime;
        }
        if (v40 == v29) {
          goto LABEL_62;
        }
        if (*(void *)(*a1 + 8 * v40))
        {
          *uint64_t v28 = *v38;
          uint64_t v39 = 8 * v40;
          *unint64_t v38 = **(void **)(*a1 + v39);
          **(void **)(*a1 + v39) = v38;
          unint64_t v38 = v28;
LABEL_62:
          uint64_t v28 = v38;
          unint64_t v38 = (void *)*v38;
          if (!v38) {
            goto LABEL_68;
          }
        }
        else
        {
          *(void *)(*a1 + 8 * v40) = v28;
          uint64_t v28 = v38;
          unint64_t v38 = (void *)*v38;
          size_t v29 = v40;
          if (!v38) {
            goto LABEL_68;
          }
        }
      }
    }
    if (prime < v9)
    {
      unint64_t v35 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v9 < 3 || (uint8x8_t v36 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v36.i16[0] = vaddlv_u8(v36), v36.u32[0] > 1uLL))
      {
        unint64_t v35 = std::__next_prime(v35);
      }
      else
      {
        uint64_t v37 = 1 << -(char)__clz(v35 - 1);
        if (v35 >= 2) {
          unint64_t v35 = v37;
        }
      }
      if (prime <= v35) {
        size_t prime = v35;
      }
      if (prime < v9)
      {
        if (!prime)
        {
          int64_t v42 = (void *)*a1;
          *a1 = 0;
          if (v42) {
            operator delete(v42);
          }
          unint64_t v9 = 0;
          a1[1] = 0;
          uint64_t v41 = -1;
          goto LABEL_84;
        }
        goto LABEL_36;
      }
      unint64_t v9 = a1[1];
    }
    uint64_t v41 = v9 - 1;
    if ((v9 & (v9 - 1)) != 0)
    {
LABEL_69:
      if (v9 <= a2)
      {
        unint64_t v4 = a2 % v9;
        uint64_t v19 = *a1;
        uint64_t v20 = *(void **)(*a1 + 8 * (a2 % v9));
        if (v20) {
          goto LABEL_25;
        }
      }
      else
      {
        unint64_t v4 = a2;
        uint64_t v19 = *a1;
        uint64_t v20 = *(void **)(*a1 + 8 * a2);
        if (v20) {
          goto LABEL_25;
        }
      }
      goto LABEL_85;
    }
LABEL_84:
    unint64_t v4 = v41 & a2;
    uint64_t v19 = *a1;
    uint64_t v20 = *(void **)(*a1 + 8 * (v41 & a2));
    if (v20) {
      goto LABEL_25;
    }
    goto LABEL_85;
  }
  uint64_t v19 = *a1;
  uint64_t v20 = *(void **)(*a1 + 8 * v4);
  if (v20)
  {
LABEL_25:
    void *v16 = *v20;
LABEL_91:
    *uint64_t v20 = v16;
    goto LABEL_92;
  }
LABEL_85:
  void *v16 = *v15;
  void *v15 = v16;
  *(void *)(v19 + 8 * v4) = v15;
  if (*v16)
  {
    unint64_t v43 = *(void *)(*v16 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v43 >= v9) {
        v43 %= v9;
      }
    }
    else
    {
      v43 &= v9 - 1;
    }
    uint64_t v20 = (void *)(*a1 + 8 * v43);
    goto LABEL_91;
  }
LABEL_92:
  ++a1[3];
}

void sub_180D300D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

unsigned __int8 *mlir::detail::unpackQuantizedData<std::complex<float>>(unsigned __int8 *result, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  if (a5 >= 8) {
    __assert_rtn("unpackQuantizedData", "MPSRawAttributeUtils.h", 81, "bitwith < 8");
  }
  unint64_t v5 = 8u / a5;
  if ((8u / a5 * a5) != 8) {
    __assert_rtn("unpackQuantizedData", "MPSRawAttributeUtils.h", 82, "8 % bitwith == 0");
  }
  if ((a4 + v5 - 1) / v5 != a2) {
    __assert_rtn("unpackQuantizedData", "MPSRawAttributeUtils.h", 85, "llvm::divideCeil(numElements, elemsPerByte) == inData.size()");
  }
  if (a2)
  {
    uint64_t v6 = 0;
    int v7 = ~(-1 << a5);
    unint64_t v8 = a4;
    do
    {
      unint64_t v9 = v6 * v5;
      unint64_t v10 = a4 - v6 * v5;
      if (v10 >= v5) {
        unint64_t v10 = 8u / a5;
      }
      if (v10)
      {
        if (v8 >= v5) {
          unint64_t v11 = 8u / a5;
        }
        else {
          unint64_t v11 = v8;
        }
        if (a4 <= v9) {
LABEL_30:
        }
          __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
        unsigned int v12 = *result;
        uint64_t v13 = a3 + 8 * v9;
        *(float *)uint64_t v13 = (float)(int)(v7 & v12);
        *(_DWORD *)(v13 + 4) = 0;
        if (v11 != 1)
        {
          if (a4 <= v9 + 1) {
            goto LABEL_30;
          }
          uint64_t v14 = a3 + 8 * (v9 + 1);
          *(float *)uint64_t v14 = (float)(int)((v12 >> a5) & v7);
          *(_DWORD *)(v14 + 4) = 0;
          if (v11 != 2)
          {
            if (a4 <= v9 + 2) {
              goto LABEL_30;
            }
            uint64_t v15 = a3 + 8 * (v9 + 2);
            *(float *)uint64_t v15 = (float)(int)((v12 >> (2 * a5)) & v7);
            *(_DWORD *)(v15 + 4) = 0;
            if (v11 != 3)
            {
              if (a4 <= v9 + 3) {
                goto LABEL_30;
              }
              uint64_t v16 = a3 + 8 * (v9 + 3);
              *(float *)uint64_t v16 = (float)(int)((v12 >> (3 * a5)) & v7);
              *(_DWORD *)(v16 + 4) = 0;
              if (v11 != 4)
              {
                if (a4 <= v9 + 4) {
                  goto LABEL_30;
                }
                uint64_t v17 = a3 + 8 * (v9 + 4);
                *(float *)uint64_t v17 = (float)(int)((v12 >> (4 * a5)) & v7);
                *(_DWORD *)(v17 + 4) = 0;
                if (v11 != 5)
                {
                  if (a4 <= v9 + 5) {
                    goto LABEL_30;
                  }
                  uint64_t v18 = a3 + 8 * (v9 + 5);
                  *(float *)uint64_t v18 = (float)(int)((v12 >> (5 * a5)) & v7);
                  *(_DWORD *)(v18 + 4) = 0;
                  if (v11 != 6)
                  {
                    if (a4 <= v9 + 6) {
                      goto LABEL_30;
                    }
                    uint64_t v19 = a3 + 8 * (v9 + 6);
                    *(float *)uint64_t v19 = (float)(int)((v12 >> (6 * a5)) & v7);
                    *(_DWORD *)(v19 + 4) = 0;
                    if (v11 != 7)
                    {
                      unint64_t v20 = v9 + 7;
                      if (a4 <= v20) {
                        goto LABEL_30;
                      }
                      uint64_t v21 = a3 + 8 * v20;
                      *(float *)uint64_t v21 = (float)(int)((v12 >> (7 * a5)) & v7);
                      *(_DWORD *)(v21 + 4) = 0;
                    }
                  }
                }
              }
            }
          }
        }
      }
      ++v6;
      v8 -= v5;
      ++result;
      --a2;
    }
    while (a2);
  }
  return result;
}

char *std::__hash_table<std::__hash_value_type<void *,mlir::ElementsAttr>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,mlir::ElementsAttr>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,mlir::ElementsAttr>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,mlir::ElementsAttr>>>::__emplace_unique_key_args<void *,void *,mlir::ElementsAttr&>(uint64_t a1, uint64_t *a2, void *a3, _OWORD *a4)
{
  uint64_t v8 = *a2;
  unint64_t v9 = HIDWORD(*a2);
  unint64_t v10 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ v9);
  unint64_t v11 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v9 ^ (v10 >> 47) ^ v10)) ^ ((0x9DDFEA08EB382D69 * (v9 ^ (v10 >> 47) ^ v10)) >> 47));
  unint64_t v12 = *(void *)(a1 + 8);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69 * (v9 ^ (v10 >> 47) ^ v10)) ^ ((0x9DDFEA08EB382D69 * (v9 ^ (v10 >> 47) ^ v10)) >> 47));
      if (v11 >= v12) {
        unint64_t v4 = v11 % v12;
      }
    }
    else
    {
      unint64_t v4 = v11 & (v12 - 1);
    }
    uint64_t v14 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      uint64_t v15 = (char *)*v14;
      if (*v14)
      {
        if (v13.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v17 = *((void *)v15 + 1);
            if (v17 == v11)
            {
              if (*((void *)v15 + 2) == v8) {
                return v15;
              }
            }
            else if ((v17 & (v12 - 1)) != v4)
            {
              goto LABEL_23;
            }
            uint64_t v15 = *(char **)v15;
            if (!v15) {
              goto LABEL_23;
            }
          }
        }
        do
        {
          unint64_t v16 = *((void *)v15 + 1);
          if (v16 == v11)
          {
            if (*((void *)v15 + 2) == v8) {
              return v15;
            }
          }
          else
          {
            if (v16 >= v12) {
              v16 %= v12;
            }
            if (v16 != v4) {
              break;
            }
          }
          uint64_t v15 = *(char **)v15;
        }
        while (v15);
      }
    }
  }
LABEL_23:
  uint64_t v15 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v15 = 0;
  *((void *)v15 + 1) = v11;
  *((void *)v15 + 2) = *a3;
  *(_OWORD *)(v15 + 24) = *a4;
  float v18 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v19 = *(float *)(a1 + 32);
  if (v12 && (float)(v19 * (float)v12) >= v18)
  {
    uint64_t v20 = *(void *)a1;
    uint64_t v21 = *(void **)(*(void *)a1 + 8 * v4);
    if (v21)
    {
LABEL_26:
      *(void *)uint64_t v15 = *v21;
LABEL_61:
      *uint64_t v21 = v15;
      goto LABEL_62;
    }
  }
  else
  {
    BOOL v22 = 1;
    if (v12 >= 3) {
      BOOL v22 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v12);
    unint64_t v24 = vcvtps_u32_f32(v18 / v19);
    if (v23 <= v24) {
      size_t prime = v24;
    }
    else {
      size_t prime = v23;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v12 = *(void *)(a1 + 8);
    }
    if (prime > v12) {
      goto LABEL_37;
    }
    if (prime < v12)
    {
      unint64_t v26 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v12 < 3 || (uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
      {
        unint64_t v26 = std::__next_prime(v26);
      }
      else
      {
        uint64_t v28 = 1 << -(char)__clz(v26 - 1);
        if (v26 >= 2) {
          unint64_t v26 = v28;
        }
      }
      if (prime <= v26) {
        size_t prime = v26;
      }
      if (prime < v12) {
LABEL_37:
      }
        std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v12 = *(void *)(a1 + 8);
    unint64_t v29 = v12 - 1;
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
      {
        unint64_t v4 = v11 % v12;
        uint64_t v20 = *(void *)a1;
        uint64_t v21 = *(void **)(*(void *)a1 + 8 * (v11 % v12));
        if (v21) {
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v4 = v11;
        uint64_t v20 = *(void *)a1;
        uint64_t v21 = *(void **)(*(void *)a1 + 8 * v11);
        if (v21) {
          goto LABEL_26;
        }
      }
    }
    else
    {
      unint64_t v4 = v29 & v11;
      uint64_t v20 = *(void *)a1;
      uint64_t v21 = *(void **)(*(void *)a1 + 8 * (v29 & v11));
      if (v21) {
        goto LABEL_26;
      }
    }
  }
  *(void *)uint64_t v15 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v15;
  *(void *)(v20 + 8 * v4) = a1 + 16;
  if (*(void *)v15)
  {
    unint64_t v30 = *(void *)(*(void *)v15 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v30 >= v12) {
        v30 %= v12;
      }
    }
    else
    {
      v30 &= v12 - 1;
    }
    uint64_t v21 = (void *)(*(void *)a1 + 8 * v30);
    goto LABEL_61;
  }
LABEL_62:
  ++*(void *)(a1 + 24);
  return v15;
}

void sub_180D306CC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<FullyPlacedOnANEMPSRuntime::initializeForExecution(void)::$_0>(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  uint64_t v38 = a2;
  if (!a2) {
    return result;
  }
  uint64_t v37 = llvm::DefaultDoCastIfPossible<mlir::placement::RegionCall,mlir::Operation *,llvm::CastInfo<mlir::placement::RegionCall,mlir::Operation *,void>>::doCastIfPossible(a2);
  if (!v37)
  {
    result = (uint64_t *)llvm::DefaultDoCastIfPossible<mlir::placement::TensorToMemref,mlir::Operation *,llvm::CastInfo<mlir::placement::TensorToMemref,mlir::Operation *,void>>::doCastIfPossible(a2);
    v43[0] = result;
    if (!result) {
      return result;
    }
    BOOL v22 = *(void **)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v43);
    if (!v22 || *v22) {
      __assert_rtn("operator()", "MPSRuntime.mm", 1534, "result.hasOneUse()");
    }
    unsigned int OperandNumber = mlir::OpOperand::getOperandNumber((unint64_t)v22);
    uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)v43);
    if (!Input) {
      __assert_rtn("doit", "Casting.h", 109, "Val && \"isa<> used on a null pointer\"");
    }
    uint64_t v25 = Input;
    if ((~*(_DWORD *)(Input + 8) & 7) != 0) {
      __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
    }
    unint64_t v26 = (void *)(v2 + 656);
    unsigned int v27 = *(_DWORD *)(v2 + 664);
    if (v27 > OperandNumber)
    {
LABEL_68:
      result = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v2 + 264), &v38);
      if (result)
      {
        if (*(_DWORD *)(v2 + 792) <= OperandNumber
          || (*(void *)(*(void *)(v2 + 784) + 8 * OperandNumber) = result[3],
              *(_DWORD *)(v2 + 664) <= OperandNumber))
        {
LABEL_76:
          __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
        }
        *(void *)(*v26 + 8 * OperandNumber) = *(unsigned int *)(v25 + 24);
        return result;
      }
LABEL_83:
      std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
    }
    uint64_t v28 = OperandNumber + 1;
    unsigned int v29 = *(_DWORD *)(v2 + 792);
    if (v29 == v28) {
      goto LABEL_60;
    }
    unsigned int v30 = *(_DWORD *)(v2 + 796);
    if (v29 > v28)
    {
      if (v30 < v28) {
        goto LABEL_63;
      }
      goto LABEL_59;
    }
    if (v30 < v28)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2 + 784, (void *)(v2 + 800), OperandNumber + 1, 8);
      unsigned int v29 = *(_DWORD *)(v2 + 792);
      if (v29 == v28)
      {
LABEL_54:
        if (*(_DWORD *)(v2 + 796) < v28) {
          goto LABEL_63;
        }
        goto LABEL_58;
      }
    }
    else if (v29 == v28)
    {
      goto LABEL_54;
    }
    bzero((void *)(*(void *)(v2 + 784) + 8 * v29), 8 * (v28 - v29));
    if (*(_DWORD *)(v2 + 796) < v28) {
      goto LABEL_63;
    }
LABEL_58:
    unsigned int v27 = *(_DWORD *)(v2 + 664);
LABEL_59:
    *(_DWORD *)(v2 + 792) = v28;
LABEL_60:
    if (v27 == v28) {
      goto LABEL_68;
    }
    unsigned int v31 = *(_DWORD *)(v2 + 668);
    if (v27 > v28)
    {
      if (v31 < v28) {
        goto LABEL_63;
      }
      goto LABEL_67;
    }
    if (v31 < v28)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2 + 656, (void *)(v2 + 672), OperandNumber + 1, 8);
      unsigned int v27 = *(_DWORD *)(v2 + 664);
      if (v27 == v28)
      {
LABEL_66:
        if (*(_DWORD *)(v2 + 668) < v28) {
          goto LABEL_63;
        }
        goto LABEL_67;
      }
    }
    else if (v27 == v28)
    {
      goto LABEL_66;
    }
    bzero((void *)(*v26 + 8 * v27), 8 * (v28 - v27));
    if (*(_DWORD *)(v2 + 668) >= v28)
    {
LABEL_67:
      *(_DWORD *)(v2 + 664) = v28;
      goto LABEL_68;
    }
LABEL_63:
    __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
  }
  if (*(void *)(v2 + 912)) {
    __assert_rtn("operator()", "MPSRuntime.mm", 1517, "!_aneRegionCallOpHandler");
  }
  unint64_t v4 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v2 + 264), &v38);
  if (!v4) {
    goto LABEL_83;
  }
  *(void *)(v2 + 912) = *(void *)(v4[3] + 120);
  result = (uint64_t *)mlir::pdl::ApplyNativeRewriteOp::getResults((mlir::pdl::ApplyNativeRewriteOp *)&v37);
  if (v5)
  {
    uint64_t v6 = (uint64_t)result;
    uint64_t v7 = v5;
    unint64_t v8 = 0;
    unint64_t v9 = (void *)(v2 + 720);
    unint64_t v10 = (void *)(v2 + 848);
    for (uint64_t i = 8; ; i += 8)
    {
      unint64_t v12 = *(void **)mlir::detail::OpResultImpl::getNextResultAtOffset(v6, v8);
      if (!v12 || *v12) {
        __assert_rtn("operator()", "MPSRuntime.mm", 1522, "result.hasOneUse()");
      }
      uint64_t v13 = v12[2];
      uint64_t v14 = *(void *)(v13 + 48);
      uint64_t v15 = *(void **)(v14 + 16);
      if (v15 == &mlir::detail::TypeIDResolver<void,void>::id)
      {
        v43[0] = *(void *)(v14 + 8);
        uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
        if (v33 == 26)
        {
          BOOL v34 = *(void *)AttrData == 0x6E656D6563616C70 && *(void *)(AttrData + 8) == 0x6665726D656D2E74;
          BOOL v35 = v34 && *(void *)(AttrData + 16) == 0x736E65745F6F745FLL;
          if (v35 && *(_WORD *)(AttrData + 24) == 29295)
          {
            __int16 v42 = 1283;
            v41[0] = (uint64_t)"classof on '";
            v41[2] = (uint64_t)"placement.memref_to_tensor";
            v41[3] = 26;
            uint64_t v39 = "' failed due to the operation not being registered";
            __int16 v40 = 259;
            llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)v43);
            llvm::report_fatal_error((llvm::Twine *)v43, 1);
          }
        }
LABEL_97:
        __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
      }
      if (v15 != &mlir::detail::TypeIDResolver<mlir::placement::MemrefToTensor,void>::id) {
        goto LABEL_97;
      }
      v41[0] = v13;
      v43[0] = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v41);
      if (!*(void *)v43[0] || **(void **)v43[0]) {
        __assert_rtn("operator()", "MPSRuntime.mm", 1524, "output.hasOneUse()");
      }
      unint64_t v16 = *(unsigned int *)(v2 + 728);
      if (v8 < v16) {
        goto LABEL_37;
      }
      unint64_t v17 = v8 + 1;
      unint64_t v18 = *(unsigned int *)(v2 + 856);
      if (v8 + 1 != v18) {
        break;
      }
LABEL_26:
      if (v17 != v16)
      {
        unint64_t v20 = *(unsigned int *)(v2 + 732);
        if (v17 < v16)
        {
          if (v8 >= v20) {
            goto LABEL_63;
          }
LABEL_36:
          *(_DWORD *)(v2 + 728) = v8 + 1;
          goto LABEL_37;
        }
        if (v8 >= v20)
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(v2 + 720, (void *)(v2 + 736), v8 + 1, 8);
          unint64_t v16 = *(unsigned int *)(v2 + 728);
          if (v17 == v16)
          {
LABEL_32:
            if (v8 >= *(unsigned int *)(v2 + 732)) {
              goto LABEL_63;
            }
            goto LABEL_36;
          }
        }
        else if (v17 == v16)
        {
          goto LABEL_32;
        }
        bzero((void *)(*v9 + 8 * v16), i - 8 * v16);
        if (v8 >= *(unsigned int *)(v2 + 732)) {
          goto LABEL_63;
        }
        goto LABEL_36;
      }
LABEL_37:
      unsigned int v21 = mlir::OpOperand::getOperandNumber(*(void *)v43[0]);
      if (v8 >= *(unsigned int *)(v2 + 728)) {
        goto LABEL_76;
      }
      *(void *)(*v9 + 8 * v8) = v21;
      v41[0] = mlir::Value::getDefiningOp((mlir::Value *)v43);
      result = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v2 + 264), v41);
      if (!result) {
        goto LABEL_83;
      }
      if (v8 >= *(unsigned int *)(v2 + 856)) {
        goto LABEL_76;
      }
      *(void *)(*v10 + 8 * v8++) = result[3];
      if (v7 == v8) {
        return result;
      }
    }
    unint64_t v19 = *(unsigned int *)(v2 + 860);
    if (v8 + 1 < v18)
    {
      if (v8 >= v19) {
        goto LABEL_63;
      }
      goto LABEL_25;
    }
    if (v8 >= v19)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2 + 848, (void *)(v2 + 864), v8 + 1, 8);
      unint64_t v18 = *(unsigned int *)(v2 + 856);
      if (v17 == v18)
      {
LABEL_20:
        if (v8 >= *(unsigned int *)(v2 + 860)) {
          goto LABEL_63;
        }
LABEL_24:
        unint64_t v16 = *(unsigned int *)(v2 + 728);
LABEL_25:
        *(_DWORD *)(v2 + 856) = v8 + 1;
        goto LABEL_26;
      }
    }
    else if (v17 == v18)
    {
      goto LABEL_20;
    }
    bzero((void *)(*v10 + 8 * v18), i - 8 * v18);
    if (v8 >= *(unsigned int *)(v2 + 860)) {
      goto LABEL_63;
    }
    goto LABEL_24;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::placement::TensorToMemref,mlir::Operation *,llvm::CastInfo<mlir::placement::TensorToMemref,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v12[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v12);
    if (v4 == 26
      && *(void *)AttrData == 0x6E656D6563616C70
      && *(void *)(AttrData + 8) == 0x726F736E65742E74
      && *(void *)(AttrData + 16) == 0x726D656D5F6F745FLL
      && *(_WORD *)(AttrData + 24) == 26213)
    {
      __int16 v11 = 1283;
      v10[0] = (uint64_t)"classof on '";
      v10[2] = (uint64_t)"placement.tensor_to_memref";
      v10[3] = 26;
      unint64_t v8 = "' failed due to the operation not being registered";
      __int16 v9 = 259;
      llvm::operator+(v10, (uint64_t *)&v8, (uint64_t)v12);
      llvm::report_fatal_error((llvm::Twine *)v12, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::placement::TensorToMemref,void>::id)
  {
    return 0;
  }
  return result;
}

void *FullyPlacedOnANEMPSRuntime::FullyPlacedOnANEMPSRuntime(void *a1, void *a2, void *a3, void *a4, void *a5, uint64_t a6, int a7)
{
  uint64_t v8 = MPSRuntime::MPSRuntime((uint64_t)a1, a2, a3, a4, a5, a6, a7);
  *(void *)uint64_t v8 = &unk_1EC995F90;
  *(void *)(v8 + 656) = v8 + 672;
  *(void *)(v8 + 664) = 0x600000000;
  *(void *)(v8 + 720) = v8 + 736;
  *(void *)(v8 + 728) = 0x600000000;
  *(void *)(v8 + 784) = v8 + 800;
  *(void *)(v8 + 792) = 0x600000000;
  *(void *)(v8 + 848) = v8 + 864;
  *(void *)(v8 + 856) = 0x600000000;
  *(void *)(v8 + 912) = 0;
  if (*(unsigned char *)(v8 + 216)) {
    FullyPlacedOnANEMPSRuntime::initializeForExecution(a1);
  }
  return a1;
}

void sub_180D30EE0(_Unwind_Exception *a1)
{
  uint64_t v6 = v2;
  uint64_t v8 = (void *)*((void *)v1 + 106);
  if (v8 == v6)
  {
    __int16 v9 = (void *)*((void *)v1 + 98);
    if (v9 == v5) {
      goto LABEL_3;
    }
  }
  else
  {
    free(v8);
    __int16 v9 = (void *)*((void *)v1 + 98);
    if (v9 == v5)
    {
LABEL_3:
      unint64_t v10 = (void *)*((void *)v1 + 90);
      if (v10 == v4) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  free(v9);
  unint64_t v10 = (void *)*((void *)v1 + 90);
  if (v10 == v4)
  {
LABEL_4:
    __int16 v11 = (void *)*((void *)v1 + 82);
    if (v11 == v3) {
      goto LABEL_5;
    }
    goto LABEL_9;
  }
LABEL_8:
  free(v10);
  __int16 v11 = (void *)*((void *)v1 + 82);
  if (v11 == v3)
  {
LABEL_5:
    GPURegionRuntime::~GPURegionRuntime(v1);
    _Unwind_Resume(a1);
  }
LABEL_9:
  free(v11);
  GPURegionRuntime::~GPURegionRuntime(v1);
  _Unwind_Resume(a1);
}

uint64_t MPSRuntime::MPSRuntime(uint64_t a1, void *a2, void *a3, void *a4, void *a5, uint64_t a6, int a7)
{
  id v13 = a2;
  id v14 = a3;
  id v15 = a4;
  id v16 = a5;
  uint64_t FuncOpInModule = getFuncOpInModule(a6);
  uint64_t v18 = FuncOpInModule;
  if (FuncOpInModule)
  {
    uint64_t InterfaceFor = mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor(FuncOpInModule);
    if (!InterfaceFor) {
      __assert_rtn("Interface", "InterfaceSupport.h", 110, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
    }
  }
  else
  {
    uint64_t InterfaceFor = 0;
  }
  GPURegionRuntime::GPURegionRuntime(a1, v13, v14, v15, v16, a6, v18, InterfaceFor, a7, 1);
  uint64_t v32 = v14;
  uint64_t v33 = v13;
  *(void *)a1 = &unk_1EC9953D8;
  if (*(unsigned char *)(a1 + 216))
  {
    uint64_t v20 = *(void *)(a1 + 248);
    if ((*(unsigned char *)(v20 + 46) & 0x80) != 0)
    {
      uint64_t v21 = *(unsigned int *)(v20 + 68);
      if (v21)
      {
        uint64_t v22 = 0;
        uint64_t v23 = *(void *)(v20 + 72);
        do
        {
          uint64_t v24 = *(void *)(v23 + 32 * v22 + 24);
          uint64_t v34 = 0;
          uint64_t v35 = v24;
          uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v35);
          uint64_t v34 = DefiningOp;
          if (DefiningOp)
          {
            uint64_t v26 = *(unsigned int *)(DefiningOp + 36);
            if (v26) {
              uint64_t v27 = DefiningOp - 16;
            }
            else {
              uint64_t v27 = 0;
            }
            uint64_t v28 = 0;
            if (v26)
            {
              while (1)
              {
                uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v27, v28);
                if (NextResultAtOffset == v35) {
                  break;
                }
                if (v26 == ++v28)
                {
                  uint64_t v28 = v26;
                  break;
                }
              }
            }
            unsigned int v30 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(a1 + 264), &v34);
            if (!v30) {
              std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
            }
            (*(void (**)(void, uint64_t))(*(void *)v30[3] + 56))(v30[3], v28);
          }
          ++v22;
        }
        while (v22 != v21);
      }
    }
  }

  return a1;
}

void sub_180D3117C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  GPURegionRuntime::~GPURegionRuntime(v13);

  _Unwind_Resume(a1);
}

void sub_180D311B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t GPURegionRuntime::GPURegionRuntime(uint64_t a1, void *a2, void *a3, void *a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, char a10)
{
  id v17 = a2;
  id v18 = a3;
  id v19 = a4;
  id v20 = a5;
  BaseRuntime::BaseRuntime(a1);
  *(void *)a1 = &unk_1EC9864E8;
  *(_DWORD *)(a1 + 220) = a9;
  *(void *)(a1 + 232) = a7;
  *(void *)(a1 + 240) = a8;
  *(unsigned char *)(a1 + 256) = a10;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_DWORD *)(a1 + 296) = 1065353216;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_DWORD *)(a1 + 336) = 1065353216;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_DWORD *)(a1 + 376) = 1065353216;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_DWORD *)(a1 + 416) = 1065353216;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(void *)(a1 + 456) = a1 + 472;
  *(void *)(a1 + 464) = 0x1000000000;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_OWORD *)(a1 + 616) = 0u;
  *(void *)(a1 + 632) = 0;
  *(_DWORD *)(a1 + 640) = 1065353216;
  if (!a7) {
    goto LABEL_21;
  }
  unint64_t v21 = *(unsigned int *)(a7 + 44);
  if ((v21 & 0x7FFFFF) == 0)
  {
    unsigned int v30 = "index < numRegions && \"invalid region index\"";
    int v31 = 666;
    uint64_t v32 = "Operation.h";
    uint64_t v33 = "getRegion";
    goto LABEL_25;
  }
  unint64_t v22 = a7 + 16 * ((v21 >> 23) & 1) + ((v21 >> 21) & 0x7F8) + 64;
  if (v22 >= 0xFFFFFFFFFFFFFFF9)
  {
    unsigned int v30 = "static_cast<uintptr_t>(ArithAddr + Alignment.value() - 1) >= ArithAddr && \"Overflow\"";
    int v31 = 191;
    uint64_t v32 = "Alignment.h";
    uint64_t v33 = "alignAddr";
LABEL_25:
    __assert_rtn(v33, v32, v31, v30);
  }
  uint64_t v23 = *(void *)(((v22 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a7 + 40) + 8);
  if (v23) {
    uint64_t v24 = (mlir::GenericProgramPoint **)(v23 - 8);
  }
  else {
    uint64_t v24 = 0;
  }
  mlir::Block::getTerminator(v24);
  *(void *)(a1 + 248) = v25;
  if (v25)
  {
    if (atomic_load_explicit((atomic_ullong *volatile)&GPURegionRuntime::GPURegionRuntime(MPSGraphDevice *,MPSGraph *,MPSGraphExecutable *,NSDictionary<NSString *,MPSGraphExecutable *> *,mlir::ModuleOp,mlir::FunctionOpInterface,unsigned int,BOOL)::evOnceFlag, memory_order_acquire) != -1)
    {
      uint8x8_t v36 = &v34;
      uint64_t v35 = &v36;
      std::__call_once(&GPURegionRuntime::GPURegionRuntime(MPSGraphDevice *,MPSGraph *,MPSGraphExecutable *,NSDictionary<NSString *,MPSGraphExecutable *> *,mlir::ModuleOp,mlir::FunctionOpInterface,unsigned int,BOOL)::evOnceFlag, &v35, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<GPURegionRuntime::GPURegionRuntime(MPSGraphDevice *,MPSGraph *,MPSGraphExecutable *,NSDictionary<NSString *,MPSGraphExecutable *> *,mlir::ModuleOp,mlir::FunctionOpInterface,unsigned int,BOOL)::{lambda(void)#1} &&>>);
    }
    int v26 = *(_DWORD *)(a1 + 220);
    if ((v26 & 0x400) != 0) {
      operator new();
    }
    if ((v26 & 0x20) != 0
      && GPURegionRuntime::GPURegionRuntime(MPSGraphDevice *,MPSGraph *,MPSGraphExecutable *,NSDictionary<NSString *,MPSGraphExecutable *> *,mlir::ModuleOp,mlir::FunctionOpInterface,unsigned int,BOOL)::evEnableParallelTI)
    {
      if (!*(unsigned char *)(a6 + 47)
        || (uint64_t InherentAttr = mlir::Operation::getInherentAttr(a6, (uint64_t)"mpsx.hasParallelEncoding", 24), !v28))
      {
        uint64_t InherentAttr = mlir::DictionaryAttr::get(a6 + 56, "mpsx.hasParallelEncoding", 0x18uLL);
      }
      if (InherentAttr)
      {
        if (!*(void *)InherentAttr) {
          __assert_rtn("getAbstractAttribute", "AttributeSupport.h", 165, "abstractAttribute && \"Malformed attribute storage object.\"");
        }
        if (*(_UNKNOWN **)(*(void *)InherentAttr + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
        {
          mlir::Attribute::getContext((mlir::Attribute *)(a6 + 24));
          operator new();
        }
      }
    }
    mlir::Attribute::getContext((mlir::Attribute *)(a6 + 24));
    operator new();
  }
LABEL_21:
  *(unsigned char *)(a1 + 216) = 0;

  return a1;
}

void sub_180D31764(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t *a11, void *a12, void *a13)
{
  MEMORY[0x1852FDE70](v14, 0x10A1C407E596F31);
  std::unordered_set<mlir::Operation *>::~unordered_set[abi:ne180100](v15 + 608);
  std::unique_ptr<GPU::ANECompilerHelper>::~unique_ptr[abi:ne180100](v20);
  unint64_t v22 = *(void **)(v15 + 456);
  if (v22 != a10) {
    free(v22);
  }
  uint64_t v23 = *(void *)(v15 + 448);
  *(void *)(v15 + 448) = 0;
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
  }
  std::unique_ptr<mlir::ShapeEquivalence>::reset[abi:ne180100](a11, 0);

  uint64_t v24 = *(void *)(v15 + 424);
  *(void *)(v15 + 424) = 0;
  if (v24) {
    std::default_delete<GPU::RuntimeExecutionReport>::operator()[abi:ne180100](v19, v24);
  }
  std::unordered_map<unsigned long,objc_object  {objcproto9MTLBuffer}* {__strong}>::~unordered_map[abi:ne180100](v15 + 384);
  std::unordered_map<mlir::Operation *,std::unordered_map<void *,mlir::ElementsAttr>>::~unordered_map[abi:ne180100](v18);
  std::unordered_map<mlir::Operation *,std::unordered_map<void *,mlir::ElementsAttr>>::~unordered_map[abi:ne180100](v15 + 304);
  std::unordered_map<mlir::Operation *,std::unique_ptr<GPU::BaseOpHandler>>::~unordered_map[abi:ne180100](v17);
  BaseRuntime::~BaseRuntime((BaseRuntime *)v15);

  _Unwind_Resume(a1);
}

void MPSRuntime::~MPSRuntime(MPSRuntime *this)
{
  GPURegionRuntime::~GPURegionRuntime(this);

  JUMPOUT(0x1852FDE70);
}

uint64_t BaseRuntime::BaseRuntime(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v3 = v2;
  uint64_t v5 = v4;
  uint64_t v7 = v6;
  __int16 v9 = v8;
  uint64_t v10 = v1;
  v545.__r_.__value_.__r.__words[0] = *MEMORY[0x1E4F143B8];
  id v12 = v11;
  id v13 = v7;
  id v14 = v5;
  *(void *)uint64_t v10 = &unk_1EC995440;
  *(_OWORD *)(v10 + 8) = 0u;
  *(_OWORD *)(v10 + 24) = 0u;
  *(_DWORD *)(v10 + 40) = 1065353216;
  id v22 = v12;
  *(void *)(v10 + 48) = v22;
  objc_initWeak((id *)(v10 + 56), v9);
  *(void *)(v10 + 64) = v3;
  uint64_t v23 = v13;
  objc_initWeak((id *)(v10 + 72), v13);
  id v15 = v14;
  *(void *)(v10 + 144) = 850045863;
  id v24 = v15;
  *(void *)(v10 + 80) = v15;
  *(_OWORD *)(v10 + 88) = 0u;
  *(_OWORD *)(v10 + 104) = 0u;
  *(_DWORD *)(v10 + 120) = 1065353216;
  *(void *)(v10 + 128) = 0;
  *(void *)(v10 + 136) = 0;
  *(_OWORD *)(v10 + 152) = 0u;
  *(_OWORD *)(v10 + 168) = 0u;
  *(_OWORD *)(v10 + 184) = 0u;
  *(_OWORD *)(v10 + 200) = 0u;
  *(unsigned char *)(v10 + 216) = 1;
  id v16 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  uint64_t v17 = *(void **)(v10 + 128);
  *(void *)(v10 + 128) = v16;

  id v18 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  uint64_t v19 = *(void **)(v10 + 136);
  *(void *)(v10 + 136) = v18;

  *((unsigned char *)&__str.__r_.__value_.__s + 23) = 12;
  strcpy((char *)&__str, "mps.absolute");
  int v26 = 1;
  v27[23] = 19;
  strcpy(v27, "mps.absolute_square");
  int v28 = 2;
  v29[23] = 8;
  strcpy(v29, "mps.acos");
  int v30 = 3;
  v31[23] = 9;
  strcpy(v31, "mps.acosh");
  v33[23] = 7;
  int v32 = 4;
  strcpy(v33, "mps.add");
  v35[23] = 7;
  int v34 = 5;
  strcpy(v35, "mps.and");
  int v36 = 6;
  v37[23] = 8;
  strcpy(v37, "mps.asin");
  int v38 = 7;
  v39[23] = 9;
  strcpy(v39, "mps.asinh");
  int v40 = 8;
  v41[23] = 8;
  strcpy(v41, "mps.atan");
  int v42 = 9;
  strcpy(v44, "\t\n");
  strcpy(v43, "mps.atan2");
  *(_WORD *)&v44[3] = 0;
  v45[23] = 9;
  strcpy(v45, "mps.atanh");
  int v46 = 11;
  v47[23] = 19;
  strcpy(v47, "mps.assign_variable");
  int v48 = 12;
  v49[23] = 13;
  strcpy(v49, "mps.band_part");
  int v50 = 13;
  v51[23] = 18;
  strcpy(v51, "mps.batch_to_space");
  int v52 = 14;
  v53[23] = 12;
  strcpy(v53, "mps.bias_add");
  int v54 = 15;
  v55[23] = 15;
  strcpy(v55, "mps.bitwise_and");
  int v56 = 16;
  v57[23] = 22;
  strcpy(v57, "mps.bitwise_left_shift");
  int v58 = 17;
  v59[23] = 15;
  strcpy(v59, "mps.bitwise_not");
  int v60 = 18;
  v61[23] = 14;
  strcpy(v61, "mps.bitwise_or");
  int v62 = 19;
  v63[23] = 20;
  strcpy(v63, "mps.bitwise_popcount");
  int v64 = 20;
  v65 = (char *)operator new(0x19uLL);
  unint64_t v67 = 0x8000000000000019;
  uint64_t v66 = 23;
  strcpy(v65, "mps.bitwise_right_shift");
  int v68 = 21;
  v69[23] = 15;
  strcpy(v69, "mps.bitwise_xor");
  int v70 = 22;
  v71 = (char *)operator new(0x20uLL);
  unint64_t v73 = 0x8000000000000020;
  uint64_t v72 = 27;
  strcpy(v71, "mps.broadcast_gradient_args");
  int v74 = 23;
  v75[23] = 16;
  strcpy(v75, "mps.broadcast_to");
  int v76 = 24;
  v77[23] = 8;
  strcpy(v77, "mps.call");
  int v78 = 25;
  v79[23] = 8;
  strcpy(v79, "mps.cast");
  int v80 = 26;
  v81[23] = 8;
  strcpy(v81, "mps.ceil");
  int v82 = 27;
  v83[23] = 9;
  strcpy(v83, "mps.clamp");
  int v84 = 28;
  v85[23] = 13;
  strcpy(v85, "mps.col_to_im");
  int v86 = 29;
  v87[23] = 10;
  strcpy(v87, "mps.concat");
  int v88 = 30;
  v89[23] = 13;
  strcpy(v89, "scf.condition");
  int v90 = 31;
  v91[23] = 13;
  strcpy(v91, "mps.conjugate");
  int v92 = 32;
  v93[23] = 11;
  strcpy(v93, "mps.conv_2d");
  int v94 = 33;
  v95 = (char *)operator new(0x20uLL);
  unint64_t v97 = 0x8000000000000020;
  uint64_t v96 = 25;
  strcpy(v95, "mps.conv_2d_data_gradient");
  int v98 = 34;
  v99 = (char *)operator new(0x20uLL);
  unint64_t v101 = 0x8000000000000020;
  uint64_t v100 = 28;
  strcpy(v99, "mps.conv_2d_weights_gradient");
  int v102 = 35;
  v103[23] = 11;
  strcpy(v103, "mps.conv_3d");
  int v104 = 36;
  v105 = (char *)operator new(0x20uLL);
  unint64_t v107 = 0x8000000000000020;
  uint64_t v106 = 25;
  strcpy(v105, "mps.conv_3d_data_gradient");
  int v108 = 37;
  v109 = (char *)operator new(0x20uLL);
  unint64_t v111 = 0x8000000000000020;
  uint64_t v110 = 28;
  strcpy(v109, "mps.conv_3d_weights_gradient");
  int v112 = 38;
  v113[23] = 12;
  strcpy(v113, "mps.constant");
  int v114 = 39;
  v115[23] = 7;
  strcpy(v115, "mps.cos");
  int v116 = 40;
  v117[23] = 8;
  strcpy(v117, "mps.cosh");
  int v118 = 41;
  v119[23] = 15;
  strcpy(v119, "mps.cost_volume");
  int v120 = 42;
  v121[23] = 18;
  strcpy(v121, "mps.create_complex");
  int v122 = 43;
  v123 = (char *)operator new(0x20uLL);
  unint64_t v125 = 0x8000000000000020;
  uint64_t v124 = 25;
  strcpy(v123, "mps.create_texture_tensor");
  int v126 = 44;
  v127[23] = 8;
  strcpy(v127, "mps.crop");
  int v128 = 45;
  v129[23] = 15;
  strcpy(v129, "mps.crop_resize");
  int v130 = 46;
  v131[23] = 18;
  strcpy(v131, "mps.cumulative_sum");
  int v132 = 47;
  strcpy(v133, "mps.cumulative_product");
  v133[23] = 22;
  int v134 = 48;
  v135[23] = 22;
  strcpy(v135, "mps.cumulative_maximum");
  int v136 = 49;
  strcpy(v137, "mps.cumulative_minimum");
  v137[23] = 22;
  int v138 = 50;
  v139[23] = 21;
  strcpy(v139, "mps.depth_to_space_2d");
  int v140 = 51;
  v141[23] = 21;
  strcpy(v141, "mps.depthwise_conv_2d");
  int v142 = 52;
  v143 = (char *)operator new(0x28uLL);
  unint64_t v145 = 0x8000000000000028;
  uint64_t v144 = 35;
  strcpy(v143, "mps.depthwise_conv_2d_data_gradient");
  int v146 = 53;
  v147 = (char *)operator new(0x28uLL);
  unint64_t v149 = 0x8000000000000028;
  uint64_t v148 = 38;
  strcpy(v147, "mps.depthwise_conv_2d_weights_gradient");
  int v150 = 54;
  v151[23] = 21;
  strcpy(v151, "mps.depthwise_conv_3d");
  int v152 = 55;
  v153 = (char *)operator new(0x28uLL);
  unint64_t v155 = 0x8000000000000028;
  uint64_t v154 = 35;
  strcpy(v153, "mps.depthwise_conv_3d_data_gradient");
  int v156 = 56;
  v157 = (char *)operator new(0x28uLL);
  unint64_t v159 = 0x8000000000000028;
  uint64_t v158 = 38;
  strcpy(v157, "mps.depthwise_conv_3d_weights_gradient");
  int v160 = 57;
  v161[23] = 18;
  strcpy(v161, "mps.dequantize_lut");
  int v162 = 58;
  v163[23] = 14;
  strcpy(v163, "mps.dequantize");
  int v164 = 59;
  v165[23] = 18;
  strcpy(v165, "mps.dimension_size");
  int v166 = 60;
  strcpy(v168, "\n=");
  strcpy(v167, "mps.divide");
  *(_WORD *)&v168[3] = 0;
  v169[23] = 22;
  strcpy(v169, "mps.dynamic_shape_cast");
  int v170 = 62;
  v171[23] = 7;
  strcpy(v171, "mps.elu");
  int v172 = 63;
  strcpy(v174, "\t@");
  strcpy(v173, "mps.equal");
  *(_WORD *)&v174[3] = 0;
  v175[23] = 7;
  strcpy(v175, "mps.erf");
  int v176 = 65;
  v177[23] = 15;
  strcpy(v177, "mps.expand_dims");
  int v178 = 66;
  v179[23] = 12;
  strcpy(v179, "mps.exponent");
  int v180 = 67;
  v181[23] = 19;
  strcpy(v181, "mps.exponent_base_2");
  int v182 = 68;
  v183[23] = 20;
  strcpy(v183, "mps.exponent_base_10");
  int v184 = 69;
  v185[23] = 14;
  strcpy(v185, "tensor.extract");
  int v186 = 70;
  v187 = (char *)operator new(0x20uLL);
  unint64_t v189 = 0x8000000000000020;
  uint64_t v188 = 26;
  strcpy(v187, "mps.fast_fourier_transform");
  int v190 = 71;
  v191 = (char *)operator new(0x20uLL);
  unint64_t v193 = 0x8000000000000020;
  uint64_t v192 = 25;
  strcpy(v191, "mps.real_to_hermitean_fft");
  int v194 = 72;
  v195 = (char *)operator new(0x20uLL);
  unint64_t v197 = 0x8000000000000020;
  uint64_t v196 = 25;
  strcpy(v195, "mps.hermitean_to_real_fft");
  int v198 = 73;
  v199[23] = 14;
  strcpy(v199, "mps.flatten_2d");
  int v200 = 74;
  strcpy(v202, "\tK");
  strcpy(v201, "mps.floor");
  *(_WORD *)&v202[3] = 0;
  v203[23] = 7;
  strcpy(v203, "scf.for");
  int v204 = 76;
  strcpy(v205, "mpsx.fp_to_int_clamped");
  v205[23] = 22;
  int v206 = 77;
  strcpy(v208, "\nN");
  strcpy(v207, "mps.gather");
  *(_WORD *)&v208[3] = 0;
  v209[23] = 21;
  strcpy(v209, "mps.gather_along_axis");
  int v210 = 79;
  v211[23] = 13;
  strcpy(v211, "mps.gather_nd");
  int v212 = 80;
  v213[23] = 19;
  strcpy(v213, "mps.get_coordinates");
  int v214 = 81;
  v215[23] = 11;
  strcpy(v215, "mps.greater");
  int v216 = 82;
  v217[23] = 17;
  strcpy(v217, "mps.greater_equal");
  int v218 = 83;
  v219[23] = 7;
  strcpy(v219, "mps.gru");
  int v220 = 84;
  v221[23] = 16;
  strcpy(v221, "mps.gru_gradient");
  int v222 = 85;
  v223[23] = 20;
  strcpy(v223, "mps.hamming_distance");
  int v224 = 86;
  v225[23] = 12;
  strcpy(v225, "mps.identity");
  int v226 = 87;
  char v228 = 6;
  strcpy((char *)v227, "scf.if");
  int v229 = 88;
  v230[23] = 13;
  strcpy(v230, "mps.im_to_col");
  int v231 = 89;
  v232[23] = 18;
  strcpy(v232, "mps.imaginary_part");
  int v233 = 90;
  v234[23] = 13;
  strcpy(v234, "mps.is_finite");
  int v235 = 91;
  v236[23] = 15;
  strcpy(v236, "mps.is_infinite");
  int v237 = 92;
  strcpy(v239, "\n]");
  strcpy(v238, "mps.is_nan");
  *(_WORD *)&v239[3] = 0;
  v240[23] = 14;
  strcpy(v240, "mps.leaky_relu");
  int v241 = 94;
  v242[23] = 8;
  strcpy(v242, "mps.less");
  int v243 = 95;
  v244[23] = 14;
  strcpy(v244, "mps.less_equal");
  int v245 = 96;
  v246[23] = 21;
  strcpy(v246, "mps.local_convolution");
  int v247 = 97;
  v248 = (char *)operator new(0x28uLL);
  unint64_t v250 = 0x8000000000000028;
  uint64_t v249 = 35;
  strcpy(v248, "mps.local_convolution_data_gradient");
  int v251 = 98;
  v252 = (char *)operator new(0x28uLL);
  unint64_t v254 = 0x8000000000000028;
  uint64_t v253 = 37;
  strcpy(v252, "mps.local_convolution_weight_gradient");
  int v255 = 99;
  v256[23] = 13;
  strcpy(v256, "mps.logarithm");
  int v257 = 100;
  v258[23] = 20;
  strcpy(v258, "mps.logarithm_base_2");
  int v259 = 101;
  v260[23] = 21;
  strcpy(v260, "mps.logarithm_base_10");
  int v261 = 102;
  v262[23] = 8;
  strcpy(v262, "mps.lstm");
  int v263 = 103;
  v264[23] = 17;
  strcpy(v264, "mps.lstm_gradient");
  int v265 = 104;
  v266[23] = 14;
  strcpy(v266, "mpsx.make_list");
  int v267 = 105;
  v268 = (char *)operator new(0x20uLL);
  unint64_t v270 = 0x8000000000000020;
  uint64_t v269 = 29;
  strcpy(v268, "mps.materialize_sparse_tensor");
  int v271 = 106;
  strcpy(v273, "\nk");
  strcpy(v272, "mps.matmul");
  *(_WORD *)&v273[3] = 0;
  v274 = (char *)operator new(0x20uLL);
  unint64_t v276 = 0x8000000000000020;
  uint64_t v275 = 27;
  strcpy(v274, "mps.matrix_decomposition_lu");
  int v277 = 108;
  v278[23] = 18;
  strcpy(v278, "mps.matrix_inverse");
  int v279 = 109;
  v280[23] = 20;
  strcpy(v280, "mps.matrix_solver_lu");
  int v281 = 110;
  v282[23] = 11;
  strcpy(v282, "mps.maximum");
  int v283 = 111;
  v284 = (char *)operator new(0x20uLL);
  unint64_t v286 = 0x8000000000000020;
  uint64_t v285 = 26;
  strcpy(v284, "placement.memref_to_tensor");
  int v287 = 112;
  v288[23] = 11;
  strcpy(v288, "mps.minimum");
  int v289 = 113;
  strcpy(v291, "\nr");
  strcpy(v290, "mps.modulo");
  *(_WORD *)&v291[3] = 0;
  v292[23] = 12;
  strcpy(v292, "mps.multiply");
  int v293 = 115;
  v294[23] = 8;
  strcpy(v294, "mps.nand");
  int v295 = 116;
  v296[23] = 12;
  strcpy(v296, "mps.negative");
  int v297 = 117;
  v298[23] = 7;
  strcpy(v298, "mps.nor");
  int v299 = 118;
  v300[23] = 17;
  strcpy(v300, "mps.normalization");
  int v301 = 119;
  v302[23] = 7;
  strcpy(v302, "mps.not");
  int v303 = 120;
  v304[23] = 13;
  strcpy(v304, "mps.not_equal");
  int v305 = 121;
  v306[23] = 11;
  strcpy(v306, "mps.one_hot");
  int v307 = 122;
  char v309 = 6;
  strcpy((char *)v308, "mps.or");
  int v310 = 123;
  v311[23] = 7;
  strcpy(v311, "mps.pad");
  int v312 = 124;
  v313[23] = 16;
  strcpy(v313, "mps.pad_gradient");
  int v314 = 125;
  v315[23] = 11;
  strcpy(v315, "mps.permute");
  int v316 = 126;
  v317[23] = 19;
  strcpy(v317, "mps.pooling_average");
  int v318 = 127;
  v319 = (char *)operator new(0x20uLL);
  unint64_t v321 = 0x8000000000000020;
  uint64_t v320 = 28;
  strcpy(v319, "mps.pooling_average_gradient");
  int v322 = 128;
  v323[23] = 19;
  strcpy(v323, "mps.pooling_l2_norm");
  int v324 = 129;
  v325 = (char *)operator new(0x20uLL);
  unint64_t v327 = 0x8000000000000020;
  uint64_t v326 = 28;
  strcpy(v325, "mps.pooling_l2_norm_gradient");
  int v328 = 130;
  v329[23] = 15;
  strcpy(v329, "mps.pooling_max");
  int v330 = 131;
  v331 = (char *)operator new(0x20uLL);
  unint64_t v333 = 0x8000000000000020;
  uint64_t v332 = 28;
  strcpy(v331, "mps.pooling_max_with_indices");
  int v334 = 132;
  v335 = (char *)operator new(0x20uLL);
  unint64_t v337 = 0x8000000000000020;
  uint64_t v336 = 24;
  strcpy(v335, "mps.pooling_max_gradient");
  int v338 = 133;
  v339[23] = 9;
  strcpy(v339, "mps.power");
  int v340 = 134;
  v341[23] = 9;
  strcpy(v341, "mps.prune");
  int v342 = 135;
  v343[23] = 18;
  strcpy(v343, "mps.prune_gradient");
  int v344 = 136;
  v345[23] = 12;
  strcpy(v345, "mps.quantize");
  int v346 = 137;
  v347[23] = 21;
  strcpy(v347, "mpsx.quantized_gather");
  int v348 = 138;
  v349[23] = 18;
  strcpy(v349, "mps.random_uniform");
  int v350 = 139;
  v351 = (char *)operator new(0x20uLL);
  unint64_t v353 = 0x8000000000000020;
  uint64_t v352 = 27;
  strcpy(v351, "mps.random_truncated_normal");
  int v354 = 140;
  v355[23] = 17;
  strcpy(v355, "mps.random_normal");
  int v356 = 141;
  v357[23] = 8;
  strcpy(v357, "mps.rank");
  int v358 = 142;
  v359 = (char *)operator new(0x19uLL);
  unint64_t v361 = 0x8000000000000019;
  uint64_t v360 = 23;
  strcpy(v359, "mps.read_data_from_file");
  int v362 = 143;
  v363[23] = 17;
  strcpy(v363, "mps.read_variable");
  int v364 = 144;
  v365[23] = 13;
  strcpy(v365, "mps.real_part");
  int v366 = 145;
  v367[23] = 14;
  strcpy(v367, "mps.reciprocal");
  int v368 = 146;
  v369[23] = 17;
  strcpy(v369, "mps.reduction_and");
  int v370 = 147;
  v371[23] = 20;
  strcpy(v371, "mps.reduction_argmax");
  int v372 = 148;
  v373[23] = 20;
  strcpy(v373, "mps.reduction_argmin");
  int v374 = 149;
  v375[23] = 17;
  strcpy(v375, "mps.reduction_max");
  int v376 = 150;
  v377[23] = 18;
  strcpy(v377, "mps.reduction_mean");
  int v378 = 151;
  v379[23] = 17;
  strcpy(v379, "mps.reduction_min");
  int v380 = 152;
  v381[23] = 16;
  strcpy(v381, "mps.reduction_or");
  int v382 = 153;
  v383[23] = 18;
  strcpy(v383, "mps.reduction_prod");
  int v384 = 154;
  v385[23] = 17;
  strcpy(v385, "mps.reduction_sum");
  int v386 = 155;
  v387[23] = 22;
  strcpy(v387, "mps.reduction_variance");
  int v388 = 156;
  v389[23] = 21;
  strcpy(v389, "placement.region_call");
  int v390 = 157;
  v391[23] = 18;
  strcpy(v391, "mpsx.region_return");
  int v392 = 158;
  v393[23] = 20;
  strcpy(v393, "mps.reinterpret_cast");
  int v394 = 159;
  v395[23] = 8;
  strcpy(v395, "mps.relu");
  int v396 = 160;
  v397[23] = 9;
  strcpy(v397, "mps.relu6");
  int v398 = 161;
  v399[23] = 11;
  strcpy(v399, "mps.reshape");
  int v400 = 162;
  v401[23] = 10;
  strcpy(v401, "mps.resize");
  int v402 = 163;
  v403[23] = 19;
  strcpy(v403, "mps.resize_gradient");
  int v404 = 164;
  v405[23] = 11;
  strcpy(v405, "func.return");
  int v406 = 165;
  v407[23] = 20;
  strcpy(v407, "mpsx.stitched_return");
  int v408 = 166;
  v409[23] = 11;
  strcpy(v409, "mps.reverse");
  int v410 = 167;
  v411 = (char *)operator new(0x20uLL);
  unint64_t v413 = 0x8000000000000020;
  uint64_t v412 = 26;
  strcpy(v411, "mps.reciprocal_square_root");
  int v414 = 168;
  v415[23] = 8;
  strcpy(v415, "mps.rint");
  int v416 = 169;
  v417[23] = 13;
  strcpy(v417, "mpsx.rms_norm");
  int v418 = 170;
  v419[23] = 9;
  strcpy(v419, "mps.round");
  int v420 = 171;
  v421[23] = 15;
  strcpy(v421, "mps.sample_grid");
  int v422 = 172;
  v423 = (char *)operator new(0x20uLL);
  unint64_t v425 = 0x8000000000000020;
  uint64_t v424 = 29;
  strcpy(v423, "mps.sample_grid_data_gradient");
  int v426 = 173;
  v427[23] = 11;
  strcpy(v427, "mps.scatter");
  int v428 = 174;
  v429[23] = 22;
  strcpy(v429, "mps.scatter_along_axis");
  int v430 = 175;
  v431[23] = 14;
  strcpy(v431, "mps.scatter_nd");
  int v432 = 176;
  v433[23] = 10;
  strcpy(v433, "mps.select");
  int v434 = 177;
  v435[23] = 9;
  strcpy(v435, "mps.shape");
  int v436 = 178;
  v437[23] = 11;
  strcpy(v437, "mps.sigmoid");
  int v438 = 179;
  v439[23] = 8;
  strcpy(v439, "mps.sign");
  int v440 = 180;
  v441[23] = 11;
  strcpy(v441, "mps.signbit");
  int v442 = 181;
  v443[23] = 7;
  strcpy(v443, "mps.sin");
  int v444 = 182;
  v445[23] = 18;
  strcpy(v445, "mps.singlegate_rnn");
  int v446 = 183;
  v447 = (char *)operator new(0x20uLL);
  unint64_t v449 = 0x8000000000000020;
  uint64_t v448 = 27;
  strcpy(v447, "mps.singlegate_rnn_gradient");
  int v450 = 184;
  v451[23] = 8;
  strcpy(v451, "mps.sinh");
  int v452 = 185;
  v453[23] = 8;
  strcpy(v453, "mps.size");
  int v454 = 186;
  v455[23] = 9;
  strcpy(v455, "mps.slice");
  int v456 = 187;
  v457[23] = 11;
  strcpy(v457, "mps.softmax");
  int v458 = 188;
  v459[23] = 8;
  strcpy(v459, "mps.sort");
  int v460 = 189;
  v461[23] = 11;
  strcpy(v461, "mps.argsort");
  int v462 = 190;
  v463[23] = 18;
  strcpy(v463, "mps.space_to_batch");
  int v464 = 191;
  v465[23] = 21;
  strcpy(v465, "mps.space_to_depth_2d");
  int v466 = 192;
  v467 = (char *)operator new(0x20uLL);
  unint64_t v469 = 0x8000000000000020;
  uint64_t v468 = 24;
  strcpy(v467, "mpsx.sparse_dense_matmul");
  int v470 = 193;
  v471[23] = 9;
  strcpy(v471, "mps.split");
  int v472 = 194;
  v473[23] = 10;
  strcpy(v473, "mps.square");
  int v474 = 195;
  v475[23] = 15;
  strcpy(v475, "mps.square_root");
  int v476 = 196;
  v477[23] = 11;
  strcpy(v477, "mps.squeeze");
  int v478 = 197;
  v479[23] = 11;
  strcpy(v479, "mps.stencil");
  int v480 = 198;
  v481[23] = 13;
  strcpy(v481, "mpsx.stitched");
  int v482 = 199;
  v483[23] = 17;
  strcpy(v483, "mps.strided_slice");
  int v484 = 200;
  v485 = (char *)operator new(0x20uLL);
  unint64_t v487 = 0x8000000000000020;
  uint64_t v486 = 26;
  strcpy(v485, "mps.strided_slice_gradient");
  int v488 = 201;
  v489 = (char *)operator new(0x20uLL);
  unint64_t v491 = 0x8000000000000020;
  uint64_t v490 = 24;
  strcpy(v489, "mps.strided_slice_update");
  int v492 = 202;
  v493[23] = 12;
  strcpy(v493, "mps.subtract");
  int v494 = 203;
  v495[23] = 9;
  strcpy(v495, "mps.swish");
  int v496 = 204;
  v497[23] = 7;
  strcpy(v497, "mps.tan");
  int v498 = 205;
  v499[23] = 8;
  strcpy(v499, "mps.tanh");
  int v500 = 206;
  v501[23] = 20;
  strcpy(v501, "tensor.from_elements");
  int v502 = 207;
  v503[23] = 18;
  strcpy(v503, "mpsx.list_pop_back");
  int v504 = 208;
  v505[23] = 19;
  strcpy(v505, "mpsx.list_push_back");
  int v506 = 209;
  v507[23] = 9;
  strcpy(v507, "mpsx.sdpa");
  int v508 = 210;
  v509 = (char *)operator new(0x20uLL);
  unint64_t v511 = 0x8000000000000020;
  uint64_t v510 = 26;
  strcpy(v509, "placement.tensor_to_memref");
  int v512 = 211;
  v513[23] = 8;
  strcpy(v513, "mps.tile");
  int v514 = 212;
  v515[23] = 17;
  strcpy(v515, "mps.tile_gradient");
  int v516 = 213;
  v517[23] = 9;
  strcpy(v517, "mps.top_k");
  int v518 = 214;
  v519[23] = 14;
  strcpy(v519, "mps.top_k_grad");
  int v520 = 215;
  v521[23] = 13;
  strcpy(v521, "mps.transpose");
  int v522 = 216;
  v523[23] = 19;
  strcpy(v523, "mps.type_constraint");
  int v524 = 217;
  v525 = (char *)operator new(0x19uLL);
  unint64_t v527 = 0x8000000000000019;
  uint64_t v526 = 23;
  strcpy(v525, "mps.update_random_state");
  int v528 = 218;
  v529[23] = 15;
  strcpy(v529, "mpsx.var_handle");
  int v530 = 219;
  v531 = (char *)operator new(0x20uLL);
  unint64_t v533 = 0x8000000000000020;
  uint64_t v532 = 24;
  strcpy(v531, "mps.variable_from_tensor");
  int v534 = 220;
  v535[23] = 9;
  strcpy(v535, "scf.while");
  int v536 = 221;
  v537[23] = 7;
  strcpy(v537, "mps.xor");
  int v538 = 222;
  v539[23] = 8;
  strcpy(v539, "mps.xnor");
  int v540 = 223;
  v541[23] = 9;
  strcpy(v541, "scf.yield");
  int v542 = 224;
  v543[23] = 21;
  strcpy(v543, "mpsx.quantized_matmul");
  int v544 = 225;
  std::__hash_table<std::__hash_value_type<std::string,MPSMLIROps>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MPSMLIROps>>>::__assign_unique<std::pair<std::string const,MPSMLIROps> const*>((void *)(v10 + 8), &__str, &v545);
  for (uint64_t i = 0; i != -7200; i -= 32)
  {
    if (v543[i + 23] < 0) {
      operator delete(*(void **)&v543[i]);
    }
  }

  return v10;
}

void sub_180D34640(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id *a10, id *location, uint64_t a12, void *a13, void *a14, void *a15, uint64_t a16, id *a17, uint64_t a18, char a19)
{
  id v22 = (char *)(v19 + 2671);
  uint64_t v23 = -7200;
  id v24 = (char *)(v19 + 2671);
  while (1)
  {
    int v25 = *v24;
    v24 -= 32;
    if (v25 < 0) {
      operator delete(*(void **)(v22 - 23));
    }
    id v22 = v24;
    v23 += 32;
    if (!v23)
    {

      std::mutex::~mutex(v20);
      std::unordered_map<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>::~unordered_map[abi:ne180100](a12);

      objc_destroyWeak(location);
      objc_destroyWeak(a10);

      std::unordered_map<std::string,MPSMLIROps>::~unordered_map[abi:ne180100](a16);
      _Unwind_Resume(a1);
    }
  }
}

const char *___ZN16GPURegionRuntimeC2EP14MPSGraphDeviceP8MPSGraphP18MPSGraphExecutableP12NSDictionaryIP8NSStringS5_EN4mlir8ModuleOpENSB_19FunctionOpInterfaceEjb_block_invoke()
{
  result = getenv("MPSGRAPH_INTERMEDIATES_ARE_TEMPORARY");
  if (result)
  {
    result = (const char *)atol(result);
    if (!result) {
      GPURegionRuntime::GPURegionRuntime(MPSGraphDevice *,MPSGraph *,MPSGraphExecutable *,NSDictionary<NSString *,MPSGraphExecutable *> *,mlir::ModuleOp,mlir::FunctionOpInterface,unsigned int,BOOL)::_intermediatesAreTemporaryEV = 0;
    }
  }
  return result;
}

void std::__hash_table<std::__hash_value_type<std::string,MPSMLIROps>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MPSMLIROps>>>::__assign_unique<std::pair<std::string const,MPSMLIROps> const*>(void *a1, std::string *__str, std::string *a3)
{
  uint64_t v4 = __str;
  uint64_t v6 = a1[1];
  if (!v6) {
    goto LABEL_19;
  }
  for (uint64_t i = 0; i != v6; ++i)
    *(void *)(*a1 + 8 * i) = 0;
  uint64_t v8 = a1[2];
  a1[2] = 0;
  a1[3] = 0;
  if (__str == a3 || !v8)
  {
    __int16 v9 = (void **)v8;
    if (!v8) {
      goto LABEL_19;
    }
  }
  else
  {
    do
    {
      std::string::operator=((std::string *)(v8 + 16), v4);
      *(_DWORD *)(v8 + 40) = v4[1].__r_.__value_.__l.__data_;
      __int16 v9 = *(void ***)v8;
      std::__hash_table<std::__hash_value_type<std::string,MPSMLIROps>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MPSMLIROps>>>::__node_insert_unique(a1, v8);
      uint64_t v4 = (std::string *)((char *)v4 + 32);
      if (v9) {
        BOOL v10 = v4 == a3;
      }
      else {
        BOOL v10 = 1;
      }
      uint64_t v8 = (uint64_t)v9;
    }
    while (!v10);
    if (!v9) {
      goto LABEL_19;
    }
  }
  do
  {
    id v11 = (void **)*v9;
    if (*((char *)v9 + 39) < 0) {
      operator delete(v9[2]);
    }
    operator delete(v9);
    __int16 v9 = v11;
  }
  while (v11);
LABEL_19:
  while (v4 != a3)
  {
    std::__hash_table<std::__hash_value_type<std::string,MPSMLIROps>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MPSMLIROps>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,MPSMLIROps> const&>((uint64_t)a1, (uint64_t)v4, (uint64_t)v4);
    uint64_t v4 = (std::string *)((char *)v4 + 32);
  }
}

void sub_180D348DC(void *a1)
{
  __cxa_begin_catch(a1);
  std::__hash_table<std::__hash_value_type<std::string,MPSMLIROps>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MPSMLIROps>>>::__deallocate_node(v1, v2);
  __cxa_rethrow();
}

void sub_180D348F8(_Unwind_Exception *a1)
{
}

uint64_t *std::__hash_table<std::__hash_value_type<std::string,MPSMLIROps>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MPSMLIROps>>>::__node_insert_unique(void *a1, uint64_t a2)
{
  uint64_t v4 = (unsigned __int8 **)(a2 + 16);
  unint64_t v5 = *(unsigned __int8 *)(a2 + 39);
  unint64_t v6 = *(void *)(a2 + 24);
  if ((v5 & 0x80u) == 0) {
    uint64_t v7 = (uint64_t *)(a2 + 16);
  }
  else {
    uint64_t v7 = *(uint64_t **)(a2 + 16);
  }
  if ((v5 & 0x80u) == 0) {
    unint64_t v8 = v5;
  }
  else {
    unint64_t v8 = v6;
  }
  unint64_t v9 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&v16, v7, v8);
  *(void *)(a2 + 8) = v9;
  result = std::__hash_table<std::__hash_value_type<std::string,MPSMLIROps>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MPSMLIROps>>>::__node_insert_unique_prepare[abi:ne180100]((uint64_t)a1, v9, v4);
  if (!result)
  {
    int8x8_t v11 = (int8x8_t)a1[1];
    unint64_t v12 = *(void *)(a2 + 8);
    uint8x8_t v13 = (uint8x8_t)vcnt_s8(v11);
    v13.i16[0] = vaddlv_u8(v13);
    if (v13.u32[0] > 1uLL)
    {
      if (v12 >= *(void *)&v11) {
        v12 %= *(void *)&v11;
      }
    }
    else
    {
      v12 &= *(void *)&v11 - 1;
    }
    id v14 = *(void **)(*a1 + 8 * v12);
    if (v14)
    {
      *(void *)a2 = *v14;
    }
    else
    {
      *(void *)a2 = a1[2];
      a1[2] = a2;
      *(void *)(*a1 + 8 * v12) = a1 + 2;
      if (!*(void *)a2)
      {
LABEL_21:
        ++a1[3];
        return (uint64_t *)a2;
      }
      unint64_t v15 = *(void *)(*(void *)a2 + 8);
      if (v13.u32[0] > 1uLL)
      {
        if (v15 >= *(void *)&v11) {
          v15 %= *(void *)&v11;
        }
      }
      else
      {
        v15 &= *(void *)&v11 - 1;
      }
      id v14 = (void *)(*a1 + 8 * v15);
    }
    *id v14 = a2;
    goto LABEL_21;
  }
  return result;
}

uint64_t *std::__hash_table<std::__hash_value_type<std::string,MPSMLIROps>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MPSMLIROps>>>::__node_insert_unique_prepare[abi:ne180100](uint64_t a1, unint64_t a2, unsigned __int8 **a3)
{
  unint64_t v4 = *(void *)(a1 + 8);
  if (!v4) {
    goto LABEL_50;
  }
  uint8x8_t v6 = (uint8x8_t)vcnt_s8((int8x8_t)v4);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    if (v4 <= a2) {
      unint64_t v7 = a2 % v4;
    }
    else {
      unint64_t v7 = a2;
    }
    unint64_t v8 = *(uint64_t ***)(*(void *)a1 + 8 * v7);
    if (!v8) {
      goto LABEL_50;
    }
  }
  else
  {
    unint64_t v7 = (v4 - 1) & a2;
    unint64_t v8 = *(uint64_t ***)(*(void *)a1 + 8 * v7);
    if (!v8) {
      goto LABEL_50;
    }
  }
  unint64_t v9 = *v8;
  if (*v8)
  {
    char v10 = *((unsigned char *)a3 + 23);
    if (v10 >= 0) {
      int8x8_t v11 = (unsigned __int8 *)*((unsigned __int8 *)a3 + 23);
    }
    else {
      int8x8_t v11 = a3[1];
    }
    if (v10 >= 0) {
      unint64_t v12 = (unsigned __int8 *)a3;
    }
    else {
      unint64_t v12 = *a3;
    }
    if (v6.u32[0] < 2uLL)
    {
      while (1)
      {
        uint64_t v17 = v9[1];
        if (v17 == a2)
        {
          uint64_t v18 = *((unsigned __int8 *)v9 + 39);
          if ((v18 & 0x80u) == 0) {
            uint64_t v19 = (unsigned __int8 *)*((unsigned __int8 *)v9 + 39);
          }
          else {
            uint64_t v19 = (unsigned __int8 *)v9[3];
          }
          if (v19 == v11)
          {
            if ((v18 & 0x80) != 0)
            {
              if (!memcmp((const void *)v9[2], v12, v9[3])) {
                return v9;
              }
            }
            else
            {
              if (!*((unsigned char *)v9 + 39)) {
                return v9;
              }
              uint64_t v20 = 0;
              while (*((unsigned __int8 *)v9 + v20 + 16) == v12[v20])
              {
                if (v18 == ++v20) {
                  return v9;
                }
              }
            }
          }
        }
        else if ((v17 & (v4 - 1)) != v7)
        {
          goto LABEL_50;
        }
        unint64_t v9 = (uint64_t *)*v9;
        if (!v9) {
          goto LABEL_50;
        }
      }
    }
    do
    {
      unint64_t v13 = v9[1];
      if (v13 == a2)
      {
        uint64_t v14 = *((unsigned __int8 *)v9 + 39);
        if ((v14 & 0x80u) == 0) {
          unint64_t v15 = (unsigned __int8 *)*((unsigned __int8 *)v9 + 39);
        }
        else {
          unint64_t v15 = (unsigned __int8 *)v9[3];
        }
        if (v15 == v11)
        {
          if ((v14 & 0x80) != 0)
          {
            if (!memcmp((const void *)v9[2], v12, v9[3])) {
              return v9;
            }
          }
          else
          {
            if (!*((unsigned char *)v9 + 39)) {
              return v9;
            }
            uint64_t v16 = 0;
            while (*((unsigned __int8 *)v9 + v16 + 16) == v12[v16])
            {
              if (v14 == ++v16) {
                return v9;
              }
            }
          }
        }
      }
      else
      {
        if (v13 >= v4) {
          v13 %= v4;
        }
        if (v13 != v7) {
          break;
        }
      }
      unint64_t v9 = (uint64_t *)*v9;
    }
    while (v9);
  }
LABEL_50:
  float v21 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v22 = *(float *)(a1 + 32);
  if (v4 && (float)(v22 * (float)v4) >= v21) {
    return 0;
  }
  BOOL v23 = 1;
  if (v4 >= 3) {
    BOOL v23 = (v4 & (v4 - 1)) != 0;
  }
  unint64_t v24 = v23 | (2 * v4);
  unint64_t v25 = vcvtps_u32_f32(v21 / v22);
  if (v24 <= v25) {
    size_t prime = v25;
  }
  else {
    size_t prime = v24;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    unint64_t v4 = *(void *)(a1 + 8);
  }
  if (prime > v4) {
    goto LABEL_74;
  }
  if (prime < v4)
  {
    size_t v27 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (v4 < 3 || (uint8x8_t v28 = (uint8x8_t)vcnt_s8((int8x8_t)v4), v28.i16[0] = vaddlv_u8(v28), v28.u32[0] > 1uLL))
    {
      size_t v30 = std::__next_prime(v27);
      if (prime <= v30) {
        size_t prime = v30;
      }
      if (prime >= v4) {
        return 0;
      }
    }
    else
    {
      uint64_t v29 = 1 << -(char)__clz(v27 - 1);
      if (v27 >= 2) {
        size_t v27 = v29;
      }
      if (prime <= v27) {
        size_t prime = v27;
      }
      if (prime >= v4) {
        return 0;
      }
    }
LABEL_74:
    std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__do_rehash<true>(a1, prime);
  }
  return 0;
}

uint64_t *std::__hash_table<std::__hash_value_type<std::string,MPSMLIROps>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MPSMLIROps>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MPSMLIROps>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,MPSMLIROps> const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = (unsigned char *)a2;
  unint64_t v7 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    unint64_t v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(void *)a2;
    unint64_t v8 = v7;
  }
  unint64_t v9 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)v42, (uint64_t *)a2, v8);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v3 = v9;
      if (v9 >= v11) {
        unint64_t v3 = v9 % v11;
      }
    }
    else
    {
      unint64_t v3 = (v11 - 1) & v9;
    }
    unint64_t v13 = *(uint64_t ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      uint64_t v14 = *v13;
      if (*v13)
      {
        char v15 = v5[23];
        if (v15 >= 0) {
          uint64_t v16 = v5[23];
        }
        else {
          uint64_t v16 = *((void *)v5 + 1);
        }
        if (v15 < 0) {
          unint64_t v5 = *(unsigned char **)v5;
        }
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v21 = v14[1];
            if (v21 == v10)
            {
              uint64_t v22 = *((unsigned __int8 *)v14 + 39);
              if ((v22 & 0x80u) == 0) {
                uint64_t v23 = *((unsigned __int8 *)v14 + 39);
              }
              else {
                uint64_t v23 = v14[3];
              }
              if (v23 == v16)
              {
                if ((v22 & 0x80) != 0)
                {
                  if (!memcmp((const void *)v14[2], v5, v14[3])) {
                    return v14;
                  }
                }
                else
                {
                  if (!*((unsigned char *)v14 + 39)) {
                    return v14;
                  }
                  uint64_t v24 = 0;
                  while (*((unsigned __int8 *)v14 + v24 + 16) == v5[v24])
                  {
                    if (v22 == ++v24) {
                      return v14;
                    }
                  }
                }
              }
            }
            else if ((v21 & (v11 - 1)) != v3)
            {
              goto LABEL_51;
            }
            uint64_t v14 = (uint64_t *)*v14;
            if (!v14) {
              goto LABEL_51;
            }
          }
        }
        do
        {
          unint64_t v17 = v14[1];
          if (v17 == v10)
          {
            uint64_t v18 = *((unsigned __int8 *)v14 + 39);
            if ((v18 & 0x80u) == 0) {
              uint64_t v19 = *((unsigned __int8 *)v14 + 39);
            }
            else {
              uint64_t v19 = v14[3];
            }
            if (v19 == v16)
            {
              if ((v18 & 0x80) != 0)
              {
                if (!memcmp((const void *)v14[2], v5, v14[3])) {
                  return v14;
                }
              }
              else
              {
                if (!*((unsigned char *)v14 + 39)) {
                  return v14;
                }
                uint64_t v20 = 0;
                while (*((unsigned __int8 *)v14 + v20 + 16) == v5[v20])
                {
                  if (v18 == ++v20) {
                    return v14;
                  }
                }
              }
            }
          }
          else
          {
            if (v17 >= v11) {
              v17 %= v11;
            }
            if (v17 != v3) {
              break;
            }
          }
          uint64_t v14 = (uint64_t *)*v14;
        }
        while (v14);
      }
    }
  }
LABEL_51:
  unint64_t v25 = (char *)operator new(0x30uLL);
  v42[0] = v25;
  v42[1] = a1 + 16;
  char v43 = 0;
  *(void *)unint64_t v25 = 0;
  *((void *)v25 + 1) = v10;
  int v26 = (std::string *)(v25 + 16);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v26, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v26->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    *((void *)v25 + 4) = *(void *)(a3 + 16);
  }
  *((_DWORD *)v25 + 10) = *(_DWORD *)(a3 + 24);
  char v43 = 1;
  float v27 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v28 = *(float *)(a1 + 32);
  if (!v11 || (float)(v28 * (float)v11) < v27)
  {
    BOOL v31 = 1;
    if (v11 >= 3) {
      BOOL v31 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v32 = v31 | (2 * v11);
    unint64_t v33 = vcvtps_u32_f32(v27 / v28);
    if (v32 <= v33) {
      size_t prime = v33;
    }
    else {
      size_t prime = v32;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    int8x8_t v35 = *(int8x8_t *)(a1 + 8);
    if (prime > *(void *)&v35) {
      goto LABEL_68;
    }
    if (prime < *(void *)&v35)
    {
      unint64_t v36 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (*(void *)&v35 < 3uLL || (uint8x8_t v37 = (uint8x8_t)vcnt_s8(v35), v37.i16[0] = vaddlv_u8(v37), v37.u32[0] > 1uLL))
      {
        unint64_t v36 = std::__next_prime(v36);
      }
      else
      {
        uint64_t v38 = 1 << -(char)__clz(v36 - 1);
        if (v36 >= 2) {
          unint64_t v36 = v38;
        }
      }
      if (prime <= v36) {
        size_t prime = v36;
      }
      if (prime < *(void *)&v35) {
LABEL_68:
      }
        std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v11 = *(void *)(a1 + 8);
    unint64_t v39 = v11 - 1;
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
      {
        unint64_t v3 = v10 % v11;
        uint64_t v29 = *(void **)(*(void *)a1 + 8 * (v10 % v11));
        size_t v30 = (void *)v42[0];
        if (v29) {
          goto LABEL_57;
        }
      }
      else
      {
        unint64_t v3 = v10;
        uint64_t v29 = *(void **)(*(void *)a1 + 8 * v10);
        size_t v30 = (void *)v42[0];
        if (v29) {
          goto LABEL_57;
        }
      }
    }
    else
    {
      unint64_t v3 = v39 & v10;
      uint64_t v29 = *(void **)(*(void *)a1 + 8 * (v39 & v10));
      size_t v30 = (void *)v42[0];
      if (v29) {
        goto LABEL_57;
      }
    }
LABEL_81:
    *size_t v30 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v42[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v42[0])
    {
      unint64_t v40 = *(void *)(*(void *)v42[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v40 >= v11) {
          v40 %= v11;
        }
      }
      else
      {
        v40 &= v11 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v40) = v42[0];
    }
    goto LABEL_92;
  }
  uint64_t v29 = *(void **)(*(void *)a1 + 8 * v3);
  size_t v30 = (void *)v42[0];
  if (!v29) {
    goto LABEL_81;
  }
LABEL_57:
  *size_t v30 = *v29;
  *uint64_t v29 = v42[0];
LABEL_92:
  uint64_t v14 = (uint64_t *)v42[0];
  ++*(void *)(a1 + 24);
  return v14;
}

void sub_180D35184(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,MPSMLIROps>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,MPSMLIROps>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_180D35198(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,MPSMLIROps>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,MPSMLIROps>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,MPSMLIROps>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,MPSMLIROps>,void *>>>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16) && *(char *)(v2 + 39) < 0) {
      operator delete(*(void **)(v2 + 16));
    }
    operator delete((void *)v2);
  }
  return a1;
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<GPURegionRuntime::GPURegionRuntime(MPSGraphDevice *,MPSGraph *,MPSGraphExecutable *,NSDictionary<NSString *,MPSGraphExecutable *> *,mlir::ModuleOp,mlir::FunctionOpInterface,unsigned int,BOOL)::{lambda(void)#1} &&>>()
{
  if (getenv("MPSGRAPH_DISABLE_PARALLEL_TI"))
  {
    GPURegionRuntime::GPURegionRuntime(MPSGraphDevice *,MPSGraph *,MPSGraphExecutable *,NSDictionary<NSString *,MPSGraphExecutable *> *,mlir::ModuleOp,mlir::FunctionOpInterface,unsigned int,BOOL)::evEnableParallelTI = 0;
    NSLog(&cfstr_MpsgraphDisabl_0.isa);
  }
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::func::ReturnOp,mlir::Operation *,llvm::CastInfo<mlir::func::ReturnOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x7465722E636E7566 && *(void *)((char *)AttrData + 3) == 0x6E72757465722E63)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"func.return";
      v8[3] = 11;
      uint8x8_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::func::ReturnOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::PlaceholderOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PlaceholderOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 15 && *AttrData == 0x63616C702E73706DLL && *(void *)((char *)AttrData + 7) == 0x7265646C6F686563)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.placeholder";
      v8[3] = 15;
      uint8x8_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::PlaceholderOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DenseMap<void *,mlir::Type,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::Type>>::shrink_and_clear(uint64_t result)
{
  uint64_t v1 = *(unsigned int *)(result + 16);
  int v2 = *(_DWORD *)(result + 8);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    int v4 = v3;
  }
  else {
    int v4 = 0;
  }
  if (v4 != v1) {
    llvm::deallocate_buffer(*(llvm **)result, (void *)(16 * v1));
  }
  *(void *)(result + 8) = 0;
  if ((v1 & (v1 - 1)) != 0) {
    __assert_rtn("initEmpty", "DenseMap.h", 405, "(getNumBuckets() & (getNumBuckets()-1)) == 0 && \"# initial buckets must be a power of two!\"");
  }
  if (v1)
  {
    unint64_t v5 = *(llvm **)result;
    uint64_t v6 = (v1 - 1) & 0xFFFFFFFFFFFFFFFLL;
    if (v6)
    {
      uint64_t v7 = v6 + 1;
      uint64_t v8 = (v6 + 1) & 0x1FFFFFFFFFFFFFFELL;
      __int16 v9 = (llvm *)((char *)v5 + 16 * v8);
      unint64_t v10 = (void *)((char *)v5 + 16);
      uint64_t v11 = v8;
      do
      {
        *(v10 - 2) = -4096;
        *unint64_t v10 = -4096;
        v10 += 4;
        v11 -= 2;
      }
      while (v11);
      if (v7 == v8) {
        return result;
      }
    }
    else
    {
      __int16 v9 = *(llvm **)result;
    }
    uint8x8_t v12 = (llvm *)((char *)v5 + 16 * v1);
    do
    {
      *(void *)__int16 v9 = -4096;
      __int16 v9 = (llvm *)((char *)v9 + 16);
    }
    while (v9 != v12);
  }
  return result;
}

uint64_t llvm::DenseMap<void *,mlir::ElementsAttr,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::ElementsAttr>>::shrink_and_clear(uint64_t result)
{
  uint64_t v1 = *(unsigned int *)(result + 16);
  int v2 = *(_DWORD *)(result + 8);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    int v4 = v3;
  }
  else {
    int v4 = 0;
  }
  if (v4 != v1) {
    llvm::deallocate_buffer(*(llvm **)result, (void *)(24 * v1));
  }
  *(void *)(result + 8) = 0;
  if ((v1 & (v1 - 1)) != 0) {
    __assert_rtn("initEmpty", "DenseMap.h", 405, "(getNumBuckets() & (getNumBuckets()-1)) == 0 && \"# initial buckets must be a power of two!\"");
  }
  if (v1)
  {
    unint64_t v5 = *(llvm **)result;
    unint64_t v6 = 24 * v1 - 24;
    if (v6 < 0x18)
    {
      uint64_t v7 = *(llvm **)result;
LABEL_15:
      uint64_t v11 = (llvm *)((char *)v5 + 24 * v1);
      do
      {
        *(void *)uint64_t v7 = -4096;
        uint64_t v7 = (llvm *)((char *)v7 + 24);
      }
      while (v7 != v11);
      return result;
    }
    unint64_t v8 = v6 / 0x18 + 1;
    uint64_t v7 = (llvm *)((char *)v5 + 24 * (v8 & 0x1FFFFFFFFFFFFFFELL));
    uint64_t v9 = v8 & 0x1FFFFFFFFFFFFFFELL;
    unint64_t v10 = *(llvm **)result;
    do
    {
      *(void *)unint64_t v10 = -4096;
      *((void *)v10 + 3) = -4096;
      unint64_t v10 = (llvm *)((char *)v10 + 48);
      v9 -= 2;
    }
    while (v9);
    if (v8 != (v8 & 0x1FFFFFFFFFFFFFFELL)) {
      goto LABEL_15;
    }
  }
  return result;
}

uint64_t *llvm::DenseMapBase<llvm::DenseMap<void *,mlir::Type,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::Type>>,void *,mlir::Type,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::Type>>::InsertIntoBucket<void *>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    if (a2)
    {
LABEL_4:
      uint64_t v7 = *a2;
      goto LABEL_5;
    }
LABEL_21:
    __assert_rtn("InsertIntoBucketImpl", "DenseMap.h", 616, "TheBucket");
  }
  llvm::DenseMap<void *,mlir::Type,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::Type>>::grow(a1, v6);
  int v9 = *(_DWORD *)(a1 + 16);
  if (!v9) {
    goto LABEL_21;
  }
  uint64_t v7 = *a3;
  if ((*a3 | 0x1000) == 0xFFFFFFFFFFFFF000) {
    __assert_rtn("LookupBucketFor", "DenseMap.h", 651, "!KeyInfoT::isEqual(Val, EmptyKey) && !KeyInfoT::isEqual(Val, TombstoneKey) && \"Empty/Tombstone value shouldn't be inserted into map!\"");
  }
  int v10 = v9 - 1;
  unsigned int v11 = ((v7 >> 4) ^ (v7 >> 9)) & v10;
  a2 = (uint64_t *)(*(void *)a1 + 16 * v11);
  uint64_t v12 = *a2;
  if (v7 != *a2)
  {
    unint64_t v13 = 0;
    int v14 = 1;
    while (v12 != -4096)
    {
      if (v13) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v12 == -8192;
      }
      if (v15) {
        unint64_t v13 = a2;
      }
      unsigned int v16 = v11 + v14++;
      unsigned int v11 = v16 & v10;
      a2 = (uint64_t *)(*(void *)a1 + 16 * v11);
      uint64_t v12 = *a2;
      if (v7 == *a2) {
        goto LABEL_5;
      }
    }
    if (v13) {
      a2 = v13;
    }
    goto LABEL_4;
  }
LABEL_5:
  ++*(_DWORD *)(a1 + 8);
  if (v7 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  *a2 = *a3;
  a2[1] = 0;
  return a2;
}

void *llvm::DenseMap<void *,mlir::Type,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::Type>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  result = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  int v10 = result;
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v11 = *(unsigned int *)(a1 + 16);
    if ((v11 & (v11 - 1)) == 0)
    {
      if (v11)
      {
        if (((v11 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0) {
          goto LABEL_47;
        }
        uint64_t v12 = ((v11 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
        int v10 = &result[2 * (v12 & 0x1FFFFFFFFFFFFFFELL)];
        unint64_t v13 = result + 2;
        uint64_t v14 = v12 & 0x1FFFFFFFFFFFFFFELL;
        do
        {
          *(v13 - 2) = -4096;
          *unint64_t v13 = -4096;
          v13 += 4;
          v14 -= 2;
        }
        while (v14);
        if (v12 != (v12 & 0x1FFFFFFFFFFFFFFELL))
        {
LABEL_47:
          do
          {
            *int v10 = -4096;
            v10 += 2;
          }
          while (v10 != &result[2 * v11]);
        }
      }
      if (v3)
      {
        int v15 = 0;
        int v16 = v11 - 1;
        unint64_t v17 = v4;
        uint64_t v18 = (llvm *)((char *)v4 + 16 * v3);
        do
        {
          while (1)
          {
            uint64_t v19 = *(void *)v17;
            if ((*(void *)v17 | 0x1000) != 0xFFFFFFFFFFFFF000) {
              break;
            }
            unint64_t v17 = (llvm *)((char *)v17 + 16);
            if (v17 == v18) {
              goto LABEL_31;
            }
          }
          unsigned int v20 = ((v19 >> 4) ^ (v19 >> 9)) & v16;
          uint64_t v21 = (void *)(*(void *)a1 + 16 * v20);
          uint64_t v22 = *v21;
          if (v19 == *v21) {
LABEL_43:
          }
            __assert_rtn("moveFromOldBuckets", "DenseMap.h", 435, "!FoundVal && \"Key already in new map?\"");
          uint64_t v23 = 0;
          int v24 = 1;
          while (v22 != -4096)
          {
            if (v23) {
              BOOL v25 = 0;
            }
            else {
              BOOL v25 = v22 == -8192;
            }
            if (v25) {
              uint64_t v23 = v21;
            }
            unsigned int v26 = v20 + v24++;
            unsigned int v20 = v26 & v16;
            uint64_t v21 = (void *)(*(void *)a1 + 16 * v20);
            uint64_t v22 = *v21;
            if (v19 == *v21) {
              goto LABEL_43;
            }
          }
          if (v23) {
            float v27 = v23;
          }
          else {
            float v27 = v21;
          }
          void *v27 = v19;
          v27[1] = *((void *)v17 + 1);
          *(_DWORD *)(a1 + 8) = ++v15;
          unint64_t v17 = (llvm *)((char *)v17 + 16);
        }
        while (v17 != v18);
      }
LABEL_31:
      llvm::deallocate_buffer(v4, (void *)(16 * v3));
    }
LABEL_44:
    __assert_rtn("initEmpty", "DenseMap.h", 405, "(getNumBuckets() & (getNumBuckets()-1)) == 0 && \"# initial buckets must be a power of two!\"");
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v28 = *(unsigned int *)(a1 + 16);
  if ((v28 & (v28 - 1)) != 0) {
    goto LABEL_44;
  }
  if (v28)
  {
    if (((v28 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0) {
      goto LABEL_40;
    }
    uint64_t v29 = ((v28 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
    int v10 = &result[2 * (v29 & 0x1FFFFFFFFFFFFFFELL)];
    size_t v30 = result + 2;
    uint64_t v31 = v29 & 0x1FFFFFFFFFFFFFFELL;
    do
    {
      *(v30 - 2) = -4096;
      *size_t v30 = -4096;
      v30 += 4;
      v31 -= 2;
    }
    while (v31);
    if (v29 != (v29 & 0x1FFFFFFFFFFFFFFELL))
    {
LABEL_40:
      unint64_t v32 = &result[2 * v28];
      do
      {
        *int v10 = -4096;
        v10 += 2;
      }
      while (v10 != v32);
    }
  }
  return result;
}

void *llvm::DenseMapBase<llvm::DenseMap<void *,mlir::ElementsAttr,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::ElementsAttr>>,void *,mlir::ElementsAttr,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::ElementsAttr>>::InsertIntoBucket<void *>(uint64_t a1, void *a2, uint64_t *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    if (a2)
    {
LABEL_4:
      uint64_t v7 = *a2;
      goto LABEL_5;
    }
LABEL_21:
    __assert_rtn("InsertIntoBucketImpl", "DenseMap.h", 616, "TheBucket");
  }
  llvm::DenseMap<void *,mlir::ElementsAttr,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::ElementsAttr>>::grow(a1, v6);
  int v10 = *(_DWORD *)(a1 + 16);
  if (!v10) {
    goto LABEL_21;
  }
  uint64_t v7 = *a3;
  if ((*a3 | 0x1000) == 0xFFFFFFFFFFFFF000) {
    __assert_rtn("LookupBucketFor", "DenseMap.h", 651, "!KeyInfoT::isEqual(Val, EmptyKey) && !KeyInfoT::isEqual(Val, TombstoneKey) && \"Empty/Tombstone value shouldn't be inserted into map!\"");
  }
  int v11 = v10 - 1;
  unsigned int v12 = ((v7 >> 4) ^ (v7 >> 9)) & v11;
  a2 = (void *)(*(void *)a1 + 24 * v12);
  uint64_t v13 = *a2;
  if (v7 != *a2)
  {
    uint64_t v14 = 0;
    int v15 = 1;
    while (v13 != -4096)
    {
      if (v14) {
        BOOL v16 = 0;
      }
      else {
        BOOL v16 = v13 == -8192;
      }
      if (v16) {
        uint64_t v14 = a2;
      }
      unsigned int v17 = v12 + v15++;
      unsigned int v12 = v17 & v11;
      a2 = (void *)(*(void *)a1 + 24 * v12);
      uint64_t v13 = *a2;
      if (v7 == *a2) {
        goto LABEL_5;
      }
    }
    if (v14) {
      a2 = v14;
    }
    goto LABEL_4;
  }
LABEL_5:
  ++*(_DWORD *)(a1 + 8);
  if (v7 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  uint64_t v8 = *a3;
  a2[1] = 0;
  a2[2] = 0;
  *a2 = v8;
  return a2;
}

void *llvm::DenseMap<void *,mlir::ElementsAttr,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::ElementsAttr>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  result = llvm::allocate_buffer(24 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    unsigned int v10 = *(_DWORD *)(a1 + 16);
    if ((v10 & (v10 - 1)) == 0)
    {
      if (!v10) {
        goto LABEL_18;
      }
      unint64_t v11 = 24 * v10 - 24;
      if (v11 >= 0x18)
      {
        unint64_t v16 = v11 / 0x18 + 1;
        unsigned int v12 = &result[3 * (v16 & 0x1FFFFFFFFFFFFFFELL)];
        uint64_t v17 = v16 & 0x1FFFFFFFFFFFFFFELL;
        uint64_t v18 = result;
        do
        {
          void *v18 = -4096;
          v18[3] = -4096;
          v18 += 6;
          v17 -= 2;
        }
        while (v17);
        if (v16 == (v16 & 0x1FFFFFFFFFFFFFFELL))
        {
LABEL_18:
          if (v3)
          {
            unsigned int v20 = v4;
            do
            {
              uint64_t v22 = *(void *)v20;
              if ((*(void *)v20 | 0x1000) != 0xFFFFFFFFFFFFF000)
              {
                int v23 = *(_DWORD *)(a1 + 16);
                if (v23)
                {
                  if (v22 == -4096) {
                    __assert_rtn("LookupBucketFor", "DenseMap.h", 651, "!KeyInfoT::isEqual(Val, EmptyKey) && !KeyInfoT::isEqual(Val, TombstoneKey) && \"Empty/Tombstone value shouldn't be inserted into map!\"");
                  }
                  int v24 = v23 - 1;
                  unsigned int v25 = v24 & ((v22 >> 4) ^ (v22 >> 9));
                  unsigned int v26 = (void *)(*(void *)a1 + 24 * v25);
                  uint64_t v27 = *v26;
                  if (v22 == *v26) {
LABEL_39:
                  }
                    __assert_rtn("moveFromOldBuckets", "DenseMap.h", 435, "!FoundVal && \"Key already in new map?\"");
                  uint64_t v28 = 0;
                  int v29 = 1;
                  while (v27 != -4096)
                  {
                    if (v28) {
                      BOOL v30 = 0;
                    }
                    else {
                      BOOL v30 = v27 == -8192;
                    }
                    if (v30) {
                      uint64_t v28 = v26;
                    }
                    unsigned int v31 = v25 + v29++;
                    unsigned int v25 = v31 & v24;
                    unsigned int v26 = (void *)(*(void *)a1 + 24 * v25);
                    uint64_t v27 = *v26;
                    if (v22 == *v26) {
                      goto LABEL_39;
                    }
                  }
                  if (v28) {
                    uint64_t v21 = v28;
                  }
                  else {
                    uint64_t v21 = v26;
                  }
                }
                else
                {
                  uint64_t v21 = 0;
                }
                *uint64_t v21 = v22;
                *(_OWORD *)(v21 + 1) = *(_OWORD *)((char *)v20 + 8);
                ++*(_DWORD *)(a1 + 8);
              }
              unsigned int v20 = (llvm *)((char *)v20 + 24);
            }
            while (v20 != (llvm *)((char *)v4 + 24 * v3));
          }
          llvm::deallocate_buffer(v4, (void *)(24 * v3));
        }
      }
      else
      {
        unsigned int v12 = result;
      }
      uint64_t v19 = &result[3 * v10];
      do
      {
        *unsigned int v12 = -4096;
        v12 += 3;
      }
      while (v12 != v19);
      goto LABEL_18;
    }
LABEL_49:
    __assert_rtn("initEmpty", "DenseMap.h", 405, "(getNumBuckets() & (getNumBuckets()-1)) == 0 && \"# initial buckets must be a power of two!\"");
  }
  *(void *)(a1 + 8) = 0;
  unsigned int v13 = *(_DWORD *)(a1 + 16);
  if ((v13 & (v13 - 1)) != 0) {
    goto LABEL_49;
  }
  if (v13)
  {
    unint64_t v14 = 24 * v13 - 24;
    if (v14 < 0x18)
    {
      int v15 = result;
LABEL_46:
      int8x8_t v35 = &result[3 * v13];
      do
      {
        void *v15 = -4096;
        v15 += 3;
      }
      while (v15 != v35);
      return result;
    }
    unint64_t v32 = v14 / 0x18 + 1;
    int v15 = &result[3 * (v32 & 0x1FFFFFFFFFFFFFFELL)];
    uint64_t v33 = v32 & 0x1FFFFFFFFFFFFFFELL;
    int v34 = result;
    do
    {
      *int v34 = -4096;
      v34[3] = -4096;
      v34 += 6;
      v33 -= 2;
    }
    while (v33);
    if (v32 != (v32 & 0x1FFFFFFFFFFFFFFELL)) {
      goto LABEL_46;
    }
  }
  return result;
}

void *std::function<void ()(void)>::~function(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
    return a1;
  }
  else
  {
    if (v2) {
      (*(void (**)(void *))(*v2 + 40))(v2);
    }
    return a1;
  }
}

void std::__throw_bad_function_call[abi:ne180100]()
{
  exception = __cxa_allocate_exception(8uLL);
}

void std::bad_function_call::~bad_function_call(std::bad_function_call *this)
{
  std::exception::~exception(this);

  JUMPOUT(0x1852FDE70);
}

void std::__function::__func<GPURegionRuntime::ParallelTIAndFoldHelper::runOnRegion(llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::ElementsAttr>,llvm::ArrayRef<mlir::Type>)::$_0,std::allocator<GPURegionRuntime::ParallelTIAndFoldHelper::runOnRegion(llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::ElementsAttr>,llvm::ArrayRef<mlir::Type>)::$_0>,void ()(void)>::~__func()
{
}

void *std::__function::__func<GPURegionRuntime::ParallelTIAndFoldHelper::runOnRegion(llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::ElementsAttr>,llvm::ArrayRef<mlir::Type>)::$_0,std::allocator<GPURegionRuntime::ParallelTIAndFoldHelper::runOnRegion(llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::ElementsAttr>,llvm::ArrayRef<mlir::Type>)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EC97F398;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<GPURegionRuntime::ParallelTIAndFoldHelper::runOnRegion(llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::ElementsAttr>,llvm::ArrayRef<mlir::Type>)::$_0,std::allocator<GPURegionRuntime::ParallelTIAndFoldHelper::runOnRegion(llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::ElementsAttr>,llvm::ArrayRef<mlir::Type>)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EC97F398;
  a2[1] = v2;
  return result;
}

void std::__function::__func<GPURegionRuntime::ParallelTIAndFoldHelper::runOnRegion(llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::ElementsAttr>,llvm::ArrayRef<mlir::Type>)::$_0,std::allocator<GPURegionRuntime::ParallelTIAndFoldHelper::runOnRegion(llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::ElementsAttr>,llvm::ArrayRef<mlir::Type>)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(unsigned int *)(v1 + 72);
  if (v2)
  {
    uint64_t v3 = *(GPU::BaseOpHandler ***)(v1 + 64);
    uint64_t v4 = 8 * v2;
    do
    {
      unint64_t v5 = *v3++;
      GPURegionRuntime::TIAndFoldHelper::runOnOp((GPURegionRuntime::TIAndFoldHelper *)v1, v5);
      std::mutex::lock((std::mutex *)(v1 + 312));
      ++*(void *)(v1 + 304);
      std::mutex::unlock((std::mutex *)(v1 + 312));
      std::condition_variable::notify_all((std::condition_variable *)(v1 + 376));
      v4 -= 8;
    }
    while (v4);
  }
}

uint64_t std::__function::__func<GPURegionRuntime::ParallelTIAndFoldHelper::runOnRegion(llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::ElementsAttr>,llvm::ArrayRef<mlir::Type>)::$_0,std::allocator<GPURegionRuntime::ParallelTIAndFoldHelper::runOnRegion(llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::ElementsAttr>,llvm::ArrayRef<mlir::Type>)::$_0>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN16GPURegionRuntime23ParallelTIAndFoldHelper11runOnRegionEN4llvm8ArrayRefIN4mlir4TypeEEENS2_INS3_1"
                     "2ElementsAttrEEES5_E3$_0")
    return a1 + 8;
  if (((v3 & (unint64_t)"ZN16GPURegionRuntime23ParallelTIAndFoldHelper11runOnRegionEN4llvm8ArrayRefIN4mlir4TypeEE"
                                "ENS2_INS3_12ElementsAttrEEES5_E3$_0" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN16GPURegionRuntime23ParallelTIAndFoldHelper11runOnRegionEN4llvm8ArrayRefIN4mlir4TypeEEENS2_INS3_12ElementsAttrEEES5_E3$_0"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN16GPURegionRuntime23ParallelTIAndFoldHelper11runOnRegionEN4llvm8ArrayRefIN4mlir4TypeEEENS2_INS3_12ElementsAttrEEES5_E3$_0" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8; {
  return 0;
  }
}

void *std::__function::__func<GPURegionRuntime::ParallelTIAndFoldHelper::runOnRegion(llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::ElementsAttr>,llvm::ArrayRef<mlir::Type>)::$_0,std::allocator<GPURegionRuntime::ParallelTIAndFoldHelper::runOnRegion(llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::ElementsAttr>,llvm::ArrayRef<mlir::Type>)::$_0>,void ()(void)>::target_type()
{
}

void *llvm::DenseMap<mlir::Operation *,unsigned long long,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,unsigned long long>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  result = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  unsigned int v10 = result;
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v11 = *(unsigned int *)(a1 + 16);
    if ((v11 & (v11 - 1)) == 0)
    {
      if (v11)
      {
        if (((v11 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0) {
          goto LABEL_47;
        }
        uint64_t v12 = ((v11 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
        unsigned int v10 = &result[2 * (v12 & 0x1FFFFFFFFFFFFFFELL)];
        unsigned int v13 = result + 2;
        uint64_t v14 = v12 & 0x1FFFFFFFFFFFFFFELL;
        do
        {
          *(v13 - 2) = -4096;
          *unsigned int v13 = -4096;
          v13 += 4;
          v14 -= 2;
        }
        while (v14);
        if (v12 != (v12 & 0x1FFFFFFFFFFFFFFELL))
        {
LABEL_47:
          do
          {
            *unsigned int v10 = -4096;
            v10 += 2;
          }
          while (v10 != &result[2 * v11]);
        }
      }
      if (v3)
      {
        int v15 = 0;
        int v16 = v11 - 1;
        uint64_t v17 = v4;
        uint64_t v18 = (llvm *)((char *)v4 + 16 * v3);
        do
        {
          while (1)
          {
            uint64_t v19 = *(void *)v17;
            if ((*(void *)v17 | 0x1000) != 0xFFFFFFFFFFFFF000) {
              break;
            }
            uint64_t v17 = (llvm *)((char *)v17 + 16);
            if (v17 == v18) {
              goto LABEL_31;
            }
          }
          unsigned int v20 = ((v19 >> 4) ^ (v19 >> 9)) & v16;
          uint64_t v21 = (void *)(*(void *)a1 + 16 * v20);
          uint64_t v22 = *v21;
          if (v19 == *v21) {
LABEL_43:
          }
            __assert_rtn("moveFromOldBuckets", "DenseMap.h", 435, "!FoundVal && \"Key already in new map?\"");
          int v23 = 0;
          int v24 = 1;
          while (v22 != -4096)
          {
            if (v23) {
              BOOL v25 = 0;
            }
            else {
              BOOL v25 = v22 == -8192;
            }
            if (v25) {
              int v23 = v21;
            }
            unsigned int v26 = v20 + v24++;
            unsigned int v20 = v26 & v16;
            uint64_t v21 = (void *)(*(void *)a1 + 16 * v20);
            uint64_t v22 = *v21;
            if (v19 == *v21) {
              goto LABEL_43;
            }
          }
          if (v23) {
            uint64_t v27 = v23;
          }
          else {
            uint64_t v27 = v21;
          }
          uint64_t v28 = *((void *)v17 + 1);
          void *v27 = v19;
          v27[1] = v28;
          *(_DWORD *)(a1 + 8) = ++v15;
          uint64_t v17 = (llvm *)((char *)v17 + 16);
        }
        while (v17 != v18);
      }
LABEL_31:
      llvm::deallocate_buffer(v4, (void *)(16 * v3));
    }
LABEL_44:
    __assert_rtn("initEmpty", "DenseMap.h", 405, "(getNumBuckets() & (getNumBuckets()-1)) == 0 && \"# initial buckets must be a power of two!\"");
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v29 = *(unsigned int *)(a1 + 16);
  if ((v29 & (v29 - 1)) != 0) {
    goto LABEL_44;
  }
  if (v29)
  {
    if (((v29 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0) {
      goto LABEL_40;
    }
    uint64_t v30 = ((v29 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
    unsigned int v10 = &result[2 * (v30 & 0x1FFFFFFFFFFFFFFELL)];
    unsigned int v31 = result + 2;
    uint64_t v32 = v30 & 0x1FFFFFFFFFFFFFFELL;
    do
    {
      *(v31 - 2) = -4096;
      *unsigned int v31 = -4096;
      v31 += 4;
      v32 -= 2;
    }
    while (v32);
    if (v30 != (v30 & 0x1FFFFFFFFFFFFFFELL))
    {
LABEL_40:
      uint64_t v33 = &result[2 * v29];
      do
      {
        *unsigned int v10 = -4096;
        v10 += 2;
      }
      while (v10 != v33);
    }
  }
  return result;
}

void sub_180D365B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D36620(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D36B00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,char a38)
{
  if (a15 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_180D36C7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D36DEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t MILToMLIR::ConvolutionPattern::matchAndRewrite(MILToMLIR::ConvolutionPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  return MILToMLIR::matchAndRewriteConv(a2, a3, (MILToMLIRRewriter *)a3);
}

uint64_t MILToMLIR::matchAndRewriteConv(MILToMLIR *this, mlir::StringAttr **a2, MILToMLIRRewriter *a3)
{
  uint64_t v457 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (*(uint64_t (**)(MILToMLIR *, mlir::StringAttr **, MILToMLIRRewriter *))(*(void *)this + 56))(this, a2, a3);
  if (*(char *)(v5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v430, *(const std::string::value_type **)v5, *(void *)(v5 + 8));
  }
  else
  {
    long long v6 = *(_OWORD *)v5;
    v430.__r_.__value_.__r.__words[2] = *(void *)(v5 + 16);
    *(_OWORD *)&v430.__r_.__value_.__l.__data_ = v6;
  }
  int64_t size = HIBYTE(v430.__r_.__value_.__r.__words[2]);
  if ((v430.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    unsigned int v8 = &v430;
  }
  else
  {
    int64_t size = v430.__r_.__value_.__l.__size_;
    unsigned int v8 = (std::string *)v430.__r_.__value_.__r.__words[0];
  }
  int v9 = (char *)v8 + size;
  if (size >= 14)
  {
    unsigned int v10 = v8;
    do
    {
      uint64_t v11 = (char *)memchr(v10, 99, size - 13);
      if (!v11) {
        break;
      }
      BOOL v12 = *(void *)v11 == 0x6172745F766E6F63 && *(void *)(v11 + 6) == 0x65736F70736E6172;
      if (v12) {
        goto LABEL_16;
      }
      unsigned int v10 = (std::string *)(v11 + 1);
      int64_t size = v9 - (char *)v10;
    }
    while (v9 - (char *)v10 > 13);
  }
  uint64_t v11 = v9;
LABEL_16:
  BOOL v14 = v11 == v9 || v11 - (char *)v8 == -1;
  BOOL v400 = v14;
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a2, this);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a2, this, "x");
  uint64_t v428 = MILToMLIRRewriter::getArgValue((int8x8_t *)a2, this, "weight");
  OptionalArguint64_t Value = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a2, this, "bias");
  unsigned int v426 = 0;
  unsigned int v425 = 2;
  int v16 = (const void ***)(*(uint64_t (**)(MILToMLIR *))(*(void *)this + 160))(this);
  v424[0] = 0;
  v424[1] = 0;
  v423 = v424;
  uint64_t v17 = v16 + 1;
  uint64_t v18 = *v16;
  if (*v16 == (const void **)(v16 + 1))
  {
    int v422 = 1;
  }
  else
  {
    do
    {
      std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&v423, (uint64_t *)v424, v18 + 4, (uint64_t)(v18 + 4));
      uint64_t v19 = (const void **)v18[1];
      if (v19)
      {
        do
        {
          unsigned int v20 = (const void ***)v19;
          uint64_t v19 = (const void **)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          unsigned int v20 = (const void ***)v18[2];
          BOOL v12 = *v20 == v18;
          uint64_t v18 = (const void **)v20;
        }
        while (!v12);
      }
      uint64_t v18 = (const void **)v20;
    }
    while (v20 != v17);
    uint64_t v21 = v424[0];
    int v422 = 1;
    char v456 = 6;
    strcpy((char *)&__s2, "groups");
    if (v424[0])
    {
      uint64_t v22 = v424;
      do
      {
        int v23 = v21;
        int v24 = v22;
        unsigned int v26 = v21 + 32;
        BOOL v25 = (char *)*((void *)v21 + 4);
        unint64_t v27 = v23[55];
        int v28 = (char)v27;
        if ((v27 & 0x80u) != 0) {
          unint64_t v27 = *((void *)v23 + 5);
        }
        if (v28 >= 0) {
          uint64_t v29 = v26;
        }
        else {
          uint64_t v29 = v25;
        }
        if (v27 >= 6) {
          size_t v30 = 6;
        }
        else {
          size_t v30 = v27;
        }
        BOOL v31 = v27 < 6;
        int v32 = memcmp(v29, &__s2, v30);
        if (v32) {
          BOOL v31 = v32 < 0;
        }
        uint64_t v33 = (char **)(v23 + 8);
        if (v31)
        {
          uint64_t v22 = v24;
        }
        else
        {
          uint64_t v33 = (char **)v23;
          uint64_t v22 = (char **)v23;
        }
        uint64_t v21 = *v33;
      }
      while (v21);
      if (v22 != v424)
      {
        int v34 = (char *)(v24 + 4);
        if (v31) {
          int8x8_t v35 = v24;
        }
        else {
          int8x8_t v35 = v23;
        }
        if (!v31) {
          int v34 = v26;
        }
        unint64_t v36 = *((unsigned __int8 *)v22 + 55);
        int v37 = (char)v36;
        unint64_t v39 = (char *)v35[4];
        unint64_t v38 = v35[5];
        if ((v36 & 0x80u) != 0) {
          unint64_t v36 = v38;
        }
        if (v37 >= 0) {
          unint64_t v40 = v34;
        }
        else {
          unint64_t v40 = v39;
        }
        if (v36 >= 6) {
          size_t v41 = 6;
        }
        else {
          size_t v41 = v36;
        }
        BOOL v42 = v36 > 6;
        int v43 = memcmp(&__s2, v40, v41);
        BOOL v44 = v43 < 0;
        if (!v43) {
          BOOL v44 = v42;
        }
        if (!v44)
        {
          uint64_t v45 = v31 ? v24 : (char **)v23;
          if (v45[8] - v45[7] == 16)
          {
            char v456 = 6;
            strcpy((char *)&__s2, "groups");
            Parameteruint64_t Value = MIL::IROperation::TryGetParameterValue();
            if (v456 < 0) {
              operator delete(__s2);
            }
            (*(void (**)(uint64_t))(*(void *)ParameterValue + 40))(ParameterValue);
            Data = (int *)MIL::IRTensorValue::GetDataView<int>();
            if (v48)
            {
              int v399 = *Data;
              int v422 = *Data;
              goto LABEL_73;
            }
          }
        }
      }
    }
  }
  int v399 = 1;
LABEL_73:
  unint64_t v49 = *(void *)(v428 + 8) & 0xFFFFFFFFFFFFFFF8;
  if (!v49)
  {
    int v314 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v315 = 650;
    int v316 = "Casting.h";
    v317 = "dyn_cast";
    goto LABEL_505;
  }
  if (!*(void *)v49)
  {
    int v314 = "abstractType && \"Malformed type storage object.\"";
    int v315 = 160;
    int v316 = "TypeSupport.h";
    v317 = "getAbstractType";
LABEL_505:
    __assert_rtn(v317, v316, v315, v314);
  }
  uint64_t v398 = LocationForOp;
  int v50 = *(void **)(*(void *)v49 + 136);
  if (v50 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    unint64_t v49 = 0;
  }
  unint64_t v421 = v49;
  __s2 = v455;
  memset_pattern16(v455, &unk_1810FE350, 0x20uLL);
  uint64_t v454 = 0x400000004;
  if (v50 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    LODWORD(v454) = 0;
    uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v421);
    if (v65)
    {
      uint64_t v66 = (uint64_t *)Value;
      unint64_t v67 = v454;
      unint64_t v68 = HIDWORD(v454);
      uint64_t v69 = 8 * v65;
      do
      {
        uint64_t v70 = *v66;
        if (v67 >= v68)
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__s2, v455, v67 + 1, 8);
          __s2[v454] = v70;
          uint64_t v71 = v454;
          unint64_t v68 = HIDWORD(v454);
          if (v454 >= (unint64_t)HIDWORD(v454)) {
LABEL_106:
          }
            __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
        }
        else
        {
          __s2[v67] = v70;
          uint64_t v71 = v454;
          unint64_t v68 = HIDWORD(v454);
          if (v454 >= (unint64_t)HIDWORD(v454)) {
            goto LABEL_106;
          }
        }
        unint64_t v67 = v71 + 1;
        LODWORD(v454) = v67;
        ++v66;
        v69 -= 8;
      }
      while (v69);
    }
  }
  long long v51 = (uint64_t *)(a2 + 18);
  if (!v421) {
    goto LABEL_116;
  }
  if (!v454) {
    goto LABEL_543;
  }
  if (*__s2 != 1 && v399 < 2) {
    goto LABEL_89;
  }
  if (v454 <= 1) {
LABEL_543:
  }
    __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
  BOOL v53 = v400;
  if (__s2[1] != 1) {
    BOOL v53 = 0;
  }
  if (!v53)
  {
LABEL_89:
    if (v400)
    {
      unint64_t v55 = *(void *)(v428 + 8) & 0xFFFFFFFFFFFFFFF8;
      if (v55)
      {
        if (*(void *)v55)
        {
          if (*(_UNKNOWN **)(*(void *)v55 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
            unint64_t v55 = 0;
          }
          *(void *)__p = v55;
          mlir::ArrayAttr::getValue((mlir::ArrayAttr *)__p);
          if (v56 == 4)
          {
            *(void *)__p = 4;
            uint64_t v57 = mlir::IntegerType::get(*v51, 0x20u, 1u);
            int v58 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)__p, 1, v57, 0);
            if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v58))
            {
              int v60 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
              int v61 = 566;
              int v62 = "Casting.h";
              v63 = "cast";
LABEL_613:
              __assert_rtn(v63, v62, v61, v60);
            }
            if (v58)
            {
              uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v58);
              if (!InterfaceFor)
              {
                int v60 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
                int v61 = 98;
                int v62 = "InterfaceSupport.h";
                v63 = "Interface";
                goto LABEL_613;
              }
            }
            else
            {
              uint64_t InterfaceFor = 0;
            }
            *(_OWORD *)__p = xmmword_181129D70;
            v81 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v58, InterfaceFor, __p, 16, 4, 1, 1);
            if ((mlir::DenseIntElementsAttr::classof((uint64_t)v81) & 1) == 0) {
              __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
            }
            int v418 = v81;
            *(void *)__p = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a2 + 18), LocationForOp, (uint64_t **)&v418);
            uint64_t v82 = mlir::OpBuilder::create<mlir::mps::PermuteOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(a2 + 18), LocationForOp, &v428, (uint64_t)__p);
            if (!*(_DWORD *)(v82 + 36)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
LABEL_124:
            int v54 = 0;
            uint64_t v428 = v82 - 16;
            unsigned int v425 = 3;
            goto LABEL_125;
          }
LABEL_116:
          int v54 = 0;
          goto LABEL_125;
        }
        v359 = "abstractType && \"Malformed type storage object.\"";
        int v360 = 160;
        unint64_t v361 = "TypeSupport.h";
        int v362 = "getAbstractType";
      }
      else
      {
        v359 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
        int v360 = 650;
        unint64_t v361 = "Casting.h";
        int v362 = "dyn_cast";
      }
      __assert_rtn(v362, v361, v360, v359);
    }
    unint64_t v72 = *(void *)(v428 + 8) & 0xFFFFFFFFFFFFFFF8;
    if (v72)
    {
      if (*(void *)v72)
      {
        if (*(_UNKNOWN **)(*(void *)v72 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
          unint64_t v72 = 0;
        }
        *(void *)__p = v72;
        mlir::ArrayAttr::getValue((mlir::ArrayAttr *)__p);
        if (v73 != 4) {
          goto LABEL_116;
        }
        *(void *)__p = 4;
        uint64_t v74 = mlir::IntegerType::get(*v51, 0x20u, 1u);
        v75 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)__p, 1, v74, 0);
        if (mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v75))
        {
          if (v75)
          {
            uint64_t v76 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v75);
            if (!v76)
            {
              v77 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
              int v78 = 98;
              v79 = "InterfaceSupport.h";
              int v80 = "Interface";
              goto LABEL_615;
            }
          }
          else
          {
            uint64_t v76 = 0;
          }
          *(_OWORD *)__p = xmmword_181129D70;
          v83 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v75, v76, __p, 16, 4, 1, 1);
          if ((mlir::DenseIntElementsAttr::classof((uint64_t)v83) & 1) == 0) {
            __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
          }
          int v418 = v83;
          *(void *)__p = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a2 + 18), LocationForOp, (uint64_t **)&v418);
          uint64_t v82 = mlir::OpBuilder::create<mlir::mps::PermuteOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(a2 + 18), LocationForOp, &v428, (uint64_t)__p);
          if (!*(_DWORD *)(v82 + 36)) {
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          }
          goto LABEL_124;
        }
        v77 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        int v78 = 566;
        v79 = "Casting.h";
        int v80 = "cast";
LABEL_615:
        __assert_rtn(v80, v79, v78, v77);
      }
      v363 = "abstractType && \"Malformed type storage object.\"";
      int v364 = 160;
      v365 = "TypeSupport.h";
      int v366 = "getAbstractType";
    }
    else
    {
      v363 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v364 = 650;
      v365 = "Casting.h";
      int v366 = "dyn_cast";
    }
    __assert_rtn(v366, v365, v364, v363);
  }
  int v54 = 1;
LABEL_125:
  __p[23] = 1;
  strcpy(__p, "x");
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  v85 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(ParameterType);
  uint64_t v86 = MIL::IRTensorValueType::Rank(v85);
  unint64_t v87 = v86;
  if (v86 <= 2)
  {
    *(void *)__p = operator new(0x20uLL);
    *(_OWORD *)&__p[8] = xmmword_181128710;
    strcpy(*(char **)__p, "Unexpectedly small rank for 'x'");
    MILToMLIRRewriter::notifyFailure((uint64_t)a2, (uint64_t)this, __p);
    goto LABEL_168;
  }
  int v396 = (mlir::Builder *)(a2 + 18);
  v397 = (const MIL::IROperation *)a2;
  BOOL v394 = v86 == 3;
  int v395 = v54;
  if (v86 == 3) {
    int v88 = 1;
  }
  else {
    int v88 = 2;
  }
  if ((unint64_t)v86 >= 5) {
    int v88 = 3;
  }
  int v393 = v88;
  __p[23] = 8;
  strcpy(__p, "pad_type");
  v89 = v424[0];
  if (!v424[0]) {
    goto LABEL_166;
  }
  int v90 = v424;
  do
  {
    v91 = v89;
    int v92 = v90;
    int v94 = v89 + 32;
    v93 = (char *)*((void *)v89 + 4);
    unint64_t v95 = v91[55];
    int v96 = (char)v95;
    if ((v95 & 0x80u) != 0) {
      unint64_t v95 = *((void *)v91 + 5);
    }
    if (v96 >= 0) {
      unint64_t v97 = v94;
    }
    else {
      unint64_t v97 = v93;
    }
    if (v95 >= 8) {
      size_t v98 = 8;
    }
    else {
      size_t v98 = v95;
    }
    BOOL v99 = v95 < 8;
    int v100 = memcmp(v97, __p, v98);
    if (v100) {
      BOOL v99 = v100 < 0;
    }
    unint64_t v101 = (char **)(v91 + 8);
    if (v99)
    {
      int v90 = v92;
    }
    else
    {
      unint64_t v101 = (char **)v91;
      int v90 = (char **)v91;
    }
    v89 = *v101;
  }
  while (v89);
  if (v90 == v424) {
    goto LABEL_166;
  }
  int v102 = (char *)(v92 + 4);
  if (v99) {
    v103 = v92;
  }
  else {
    v103 = v91;
  }
  if (!v99) {
    int v102 = v94;
  }
  unint64_t v104 = *((unsigned __int8 *)v90 + 55);
  int v105 = (char)v104;
  unint64_t v107 = (char *)v103[4];
  unint64_t v106 = v103[5];
  if ((v104 & 0x80u) != 0) {
    unint64_t v104 = v106;
  }
  if (v105 >= 0) {
    int v108 = v102;
  }
  else {
    int v108 = v107;
  }
  if (v104 >= 8) {
    size_t v109 = 8;
  }
  else {
    size_t v109 = v104;
  }
  BOOL v110 = v104 > 8;
  int v111 = memcmp(__p, v108, v109);
  BOOL v112 = v111 < 0;
  if (!v111) {
    BOOL v112 = v110;
  }
  if (v112)
  {
LABEL_166:
    *(void *)__p = operator new(0x30uLL);
    *(_OWORD *)&__p[8] = xmmword_181129DC0;
    strcpy(*(char **)__p, "Could not find parameter with name 'pad_type'.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a2, (uint64_t)this, __p);
LABEL_168:
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    uint64_t v113 = 0;
    goto LABEL_171;
  }
  if (v99) {
    v115 = v92;
  }
  else {
    v115 = v91;
  }
  if (v115[8] - v115[7] != 16)
  {
    *(void *)__p = operator new(0x28uLL);
    *(_OWORD *)&__p[8] = xmmword_1811286F0;
    strcpy(*(char **)__p, "Unexpected argument size for 'pad_type'");
    MILToMLIRRewriter::notifyFailure((uint64_t)a2, (uint64_t)this, __p);
    goto LABEL_168;
  }
  __p[23] = 8;
  strcpy(__p, "pad_type");
  MIL::IROperation::TryGetParameterValue();
  MIL::IRValue::GetScalar<std::string>();
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  unsigned int v417 = 0;
  if ((v420 & 0x80) == 0)
  {
    int v116 = (unsigned __int16 *)&v418;
    switch(v420)
    {
      case 4:
        int v117 = (int)v418;
        goto LABEL_188;
      case 5:
        if (v418 != 1768710518 || BYTE4(v418) != 100) {
          goto LABEL_683;
        }
        goto LABEL_254;
      case 6:
        goto LABEL_201;
      case 10:
        if (v418 != (void *)0x776F6C5F656D6173 || (unsigned __int16)v419 != 29285) {
          goto LABEL_683;
        }
        goto LABEL_248;
      default:
        goto LABEL_683;
    }
  }
  switch(v419)
  {
    case 4:
      int v117 = *(_DWORD *)v418;
LABEL_188:
      if (v117 != 1701667187) {
        goto LABEL_683;
      }
      unsigned int v118 = 2;
      int v119 = 2;
      goto LABEL_255;
    case 5:
      if (*(_DWORD *)v418 != 1768710518 || *((unsigned char *)v418 + 4) != 100) {
        goto LABEL_683;
      }
LABEL_254:
      unsigned int v118 = 1;
      int v119 = 1;
      goto LABEL_255;
    case 6:
      int v116 = (unsigned __int16 *)v418;
LABEL_201:
      int v122 = *(_DWORD *)v116;
      int v123 = v116[2];
      if (v122 != 1953723747 || v123 != 28015) {
        goto LABEL_683;
      }
      uint64_t v451 = 0;
      uint64_t v452 = 0;
      long long v449 = 0uLL;
      uint64_t v450 = 0;
      __p[23] = 3;
      strcpy(__p, "pad");
      unint64_t v125 = v424[0];
      if (!v424[0]) {
        goto LABEL_242;
      }
      int v126 = v424;
      do
      {
        v127 = v125;
        int v128 = v126;
        int v130 = v125 + 32;
        v129 = (char *)*((void *)v125 + 4);
        unint64_t v131 = v125[55];
        int v132 = (char)v131;
        if ((v131 & 0x80u) != 0) {
          unint64_t v131 = *((void *)v127 + 5);
        }
        if (v132 >= 0) {
          v133 = v130;
        }
        else {
          v133 = v129;
        }
        if (v131 >= 3) {
          size_t v134 = 3;
        }
        else {
          size_t v134 = v131;
        }
        BOOL v135 = v131 < 3;
        int v136 = memcmp(v133, __p, v134);
        if (v136) {
          BOOL v135 = v136 < 0;
        }
        if (v135) {
          v137 = (char **)(v127 + 8);
        }
        else {
          v137 = (char **)v127;
        }
        if (v135) {
          int v126 = v128;
        }
        else {
          int v126 = (char **)v127;
        }
        unint64_t v125 = *v137;
      }
      while (v125);
      if (v126 == v424) {
        goto LABEL_242;
      }
      int v138 = (char *)(v128 + 4);
      if (v135) {
        v139 = v128;
      }
      else {
        v139 = v127;
      }
      if (!v135) {
        int v138 = v130;
      }
      unint64_t v140 = *((unsigned __int8 *)v126 + 55);
      int v141 = (char)v140;
      v143 = (char *)v139[4];
      unint64_t v142 = v139[5];
      if ((v140 & 0x80u) != 0) {
        unint64_t v140 = v142;
      }
      if (v141 >= 0) {
        uint64_t v144 = v138;
      }
      else {
        uint64_t v144 = v143;
      }
      if (v140 >= 3) {
        size_t v145 = 3;
      }
      else {
        size_t v145 = v140;
      }
      BOOL v146 = v140 > 3;
      int v147 = memcmp(__p, v144, v145);
      BOOL v148 = v147 < 0;
      if (!v147) {
        BOOL v148 = v146;
      }
      if (v148)
      {
LABEL_242:
        *(void *)__p = operator new(0x30uLL);
        *(_OWORD *)&__p[8] = xmmword_181129D90;
        strcpy(*(char **)__p, "Could not find parameter with name 'pad'.");
        MILToMLIRRewriter::notifyFailure((uint64_t)a2, (uint64_t)this, __p);
        goto LABEL_357;
      }
      if (v135) {
        v244 = v128;
      }
      else {
        v244 = v127;
      }
      if (v244[8] - v244[7] != 16)
      {
        *(void *)__p = operator new(0x28uLL);
        *(_OWORD *)&__p[8] = xmmword_181129D80;
        strcpy(*(char **)__p, "Unexpected argument size for 'pad'");
        MILToMLIRRewriter::notifyFailure((uint64_t)a2, (uint64_t)this, __p);
        goto LABEL_357;
      }
      __p[23] = 3;
      strcpy(__p, "pad");
      uint64_t v245 = MIL::IROperation::TryGetParameterValue();
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
      (*(void (**)(uint64_t))(*(void *)v245 + 40))(v245);
      uint64_t v246 = MIL::IRTensorValue::GetDataView<int>();
      uint64_t v248 = v246;
      unint64_t v249 = v247;
      if (v247 >> 1 == 2)
      {
        LODWORD(v452) = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v246, v247, 0);
        LODWORD(v451) = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v248, v249, 1uLL);
        HIDWORD(v452) = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v248, v249, 2uLL);
        HIDWORD(v451) = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v248, v249, 3uLL);
        DWORD2(v449) = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v248, v249, 0);
        HIDWORD(v449) = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v248, v249, 1uLL);
        LODWORD(v450) = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v248, v249, 2uLL);
        unint64_t v250 = (_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v248, v249, 3uLL);
        goto LABEL_546;
      }
      if (v247 >> 1 == 1)
      {
        HIDWORD(v452) = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v246, v247, 0);
        HIDWORD(v451) = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v248, v249, 1uLL);
        LODWORD(v450) = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v248, v249, 0);
        unint64_t v250 = (_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v248, v249, 1uLL);
LABEL_546:
        int v390 = 0;
        HIDWORD(v450) = *v250;
        goto LABEL_256;
      }
      int v390 = 0;
      if (v247 >= 6)
      {
        long long v449 = *(_OWORD *)v246;
        uint64_t v450 = *(void *)(v246 + 16);
      }
LABEL_256:
      int v448 = 1;
      uint64_t v447 = 0x100000001;
      int v446 = 1;
      uint64_t v445 = 0x100000001;
      __p[23] = 7;
      strcpy(__p, "strides");
      v151 = v424[0];
      if (!v424[0]) {
        goto LABEL_301;
      }
      int v152 = v424;
      v153 = v424[0];
      do
      {
        uint64_t v154 = v153;
        unint64_t v155 = v152;
        v157 = v153 + 32;
        int v156 = (char *)*((void *)v153 + 4);
        unint64_t v158 = v153[55];
        int v159 = (char)v158;
        if ((v158 & 0x80u) != 0) {
          unint64_t v158 = *((void *)v154 + 5);
        }
        if (v159 >= 0) {
          int v160 = v157;
        }
        else {
          int v160 = v156;
        }
        if (v158 >= 7) {
          size_t v161 = 7;
        }
        else {
          size_t v161 = v158;
        }
        BOOL v162 = v158 < 7;
        int v163 = memcmp(v160, __p, v161);
        if (v163) {
          BOOL v162 = v163 < 0;
        }
        if (v162) {
          int v164 = (char **)(v154 + 8);
        }
        else {
          int v164 = (char **)v154;
        }
        if (v162) {
          int v152 = v155;
        }
        else {
          int v152 = (char **)v154;
        }
        v153 = *v164;
      }
      while (v153);
      if (v152 == v424) {
        goto LABEL_301;
      }
      v165 = (char *)(v155 + 4);
      if (v162) {
        int v166 = v155;
      }
      else {
        int v166 = v154;
      }
      if (!v162) {
        v165 = v157;
      }
      unint64_t v167 = *((unsigned __int8 *)v152 + 55);
      int v168 = (char)v167;
      int v170 = (char *)v166[4];
      unint64_t v169 = v166[5];
      if ((v167 & 0x80u) != 0) {
        unint64_t v167 = v169;
      }
      if (v168 >= 0) {
        v171 = v165;
      }
      else {
        v171 = v170;
      }
      if (v167 >= 7) {
        size_t v172 = 7;
      }
      else {
        size_t v172 = v167;
      }
      BOOL v173 = v167 > 7;
      int v174 = memcmp(__p, v171, v172);
      BOOL v175 = v174 < 0;
      if (!v174) {
        BOOL v175 = v173;
      }
      if (v175 || (!v162 ? (int v176 = v154) : (int v176 = v155), v176[8] - v176[7] != 16))
      {
LABEL_301:
        int v391 = 1;
        goto LABEL_302;
      }
      __p[23] = 7;
      strcpy(__p, "strides");
      uint64_t v177 = MIL::IROperation::TryGetParameterValue();
      int v178 = (char *)&v445 + 4;
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
      (*(void (**)(uint64_t))(*(void *)v177 + 40))(v177);
      uint64_t v179 = MIL::IRTensorValue::GetDataView<int>();
      uint64_t v181 = v179;
      unint64_t v182 = v180;
      if (v180 == 2)
      {
        int v391 = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v179, 2uLL, 0);
        LODWORD(v447) = v391;
        HIDWORD(v447) = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v181, 2uLL, 1uLL);
        v183 = (_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v181, 2uLL, 0);
        unint64_t v184 = 1;
        goto LABEL_440;
      }
      if (v180 == 1)
      {
        v183 = (_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v179, 1uLL, 0);
        unint64_t v184 = 0;
        int v391 = 1;
        int v178 = (char *)&v447 + 4;
LABEL_440:
        *(_DWORD *)int v178 = *v183;
        int v277 = (int *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v181, v182, v184);
        v278 = &v446;
LABEL_441:
        int *v278 = *v277;
        goto LABEL_442;
      }
      if (v180 >= 3)
      {
        int v391 = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v179, v180, 0);
        LODWORD(v447) = v391;
        HIDWORD(v447) = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v181, v182, 1uLL);
        int v277 = (int *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v181, v182, 2uLL);
        v278 = &v448;
        goto LABEL_441;
      }
      int v391 = 1;
LABEL_442:
      v151 = v424[0];
LABEL_302:
      int v444 = 1;
      uint64_t v443 = 0x100000001;
      int v442 = 1;
      uint64_t v441 = 0x100000001;
      __p[23] = 9;
      strcpy(__p, "dilations");
      if (!v151) {
        goto LABEL_348;
      }
      v185 = v424;
      do
      {
        int v186 = v151;
        v187 = v185;
        uint64_t v188 = v151 + 32;
        unint64_t v189 = v151[55];
        int v190 = (char)v189;
        if ((v189 & 0x80u) != 0) {
          unint64_t v189 = *((void *)v151 + 5);
        }
        if (v190 >= 0) {
          v191 = v151 + 32;
        }
        else {
          v191 = (const void *)*((void *)v151 + 4);
        }
        if (v189 >= 9) {
          size_t v192 = 9;
        }
        else {
          size_t v192 = v189;
        }
        BOOL v193 = v189 < 9;
        int v194 = memcmp(v191, __p, v192);
        if (v194) {
          BOOL v193 = v194 < 0;
        }
        if (v193) {
          v195 = v151 + 8;
        }
        else {
          v195 = v151;
        }
        if (v193) {
          v185 = v187;
        }
        else {
          v185 = (char **)v151;
        }
        v151 = *(char **)v195;
      }
      while (*(void *)v195);
      if (v185 == v424) {
        goto LABEL_348;
      }
      uint64_t v196 = (char *)(v187 + 4);
      if (v193) {
        unint64_t v197 = v187;
      }
      else {
        unint64_t v197 = v186;
      }
      if (!v193) {
        uint64_t v196 = v188;
      }
      unint64_t v198 = *((unsigned __int8 *)v185 + 55);
      int v199 = (char)v198;
      v201 = (char *)v197[4];
      unint64_t v200 = v197[5];
      if ((v198 & 0x80u) != 0) {
        unint64_t v198 = v200;
      }
      if (v199 >= 0) {
        v202 = v196;
      }
      else {
        v202 = v201;
      }
      if (v198 >= 9) {
        size_t v203 = 9;
      }
      else {
        size_t v203 = v198;
      }
      BOOL v204 = v198 > 9;
      int v205 = memcmp(__p, v202, v203);
      BOOL v206 = v205 < 0;
      if (!v205) {
        BOOL v206 = v204;
      }
      if (v206 || (!v193 ? (v207 = v186) : (v207 = v187), v207[8] - v207[7] != 16))
      {
LABEL_348:
        int v217 = 1;
        v208 = (mlir::Builder *)(a2 + 18);
        int v209 = v395;
        goto LABEL_349;
      }
      __p[23] = 9;
      strcpy(__p, "dilations");
      v208 = (mlir::Builder *)(a2 + 18);
      int v209 = v395;
      uint64_t v210 = MIL::IROperation::TryGetParameterValue();
      v211 = (char *)&v441 + 4;
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
      (*(void (**)(uint64_t))(*(void *)v210 + 40))(v210);
      uint64_t v212 = MIL::IRTensorValue::GetDataView<int>();
      switch(v213)
      {
        case 3uLL:
          uint64_t v313 = v212;
          int v217 = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v212, 3uLL, 0);
          LODWORD(v443) = v217;
          HIDWORD(v443) = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v313, 3uLL, 1uLL);
          v311 = (int *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v313, 3uLL, 2uLL);
          int v312 = &v444;
          goto LABEL_499;
        case 2uLL:
          unint64_t v392 = 2;
          uint64_t v214 = v212;
          int v217 = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v212, 2uLL, 0);
          LODWORD(v443) = v217;
          HIDWORD(v443) = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v214, 2uLL, 1uLL);
          v215 = (_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v214, 2uLL, 0);
          unint64_t v216 = 1;
          goto LABEL_497;
        case 1uLL:
          unint64_t v392 = 1;
          uint64_t v214 = v212;
          v215 = (_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v212, 1uLL, 0);
          unint64_t v216 = 0;
          int v217 = 1;
          v211 = (char *)&v443 + 4;
LABEL_497:
          *(_DWORD *)v211 = *v215;
          v311 = (int *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v214, v392, v216);
          int v312 = &v442;
LABEL_499:
          *int v312 = *v311;
          goto LABEL_349;
      }
      if (v213 >= 4)
      {
        std::string::basic_string[abi:ne180100]<0>(__p, "Only up to rank 2 convolutions supported currently.");
        MILToMLIRRewriter::notifyFailure((uint64_t)v397, (uint64_t)this, __p);
LABEL_357:
        if ((__p[23] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
        goto LABEL_359;
      }
      int v217 = 1;
LABEL_349:
      if ((*(uint64_t (**)(MILToMLIR *))(*(void *)this + 192))(this) != 1)
      {
        *(void *)__p = operator new(0x40uLL);
        *(_OWORD *)&__p[8] = xmmword_181129DA0;
        strcpy(*(char **)__p, "The number of outputs does not match the number of results.");
        MILToMLIRRewriter::notifyFailure((uint64_t)v397, (uint64_t)this, __p);
        goto LABEL_357;
      }
      int v416 = 0;
      int v415 = -4;
      if (v209)
      {
        if (v393 == 1)
        {
          LODWORD(v438) = 2;
          std::vector<int>::vector[abi:ne180100](__p, &v438, 1uLL);
          *(_DWORD *)int v436 = 0;
          std::vector<int>::vector[abi:ne180100](&v438, v436, 1uLL);
          uint64_t v218 = (uint64_t)v397;
          v401[0] = (void *)1;
          uint64_t IntegerType = mlir::Builder::getIntegerType(v208, 0x20u, 1);
          *(void *)int v436 = mlir::RankedTensorType::get((uint64_t)v401, 1, IntegerType, 0);
          v234 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)v436);
          *(void *)&long long v431 = mlir::DenseIntElementsAttr::get<std::vector<int> &>((uint64_t)v234, v235, v438, *((uint64_t *)&v438 + 1));
          v401[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v208, v398, (uint64_t **)&v431);
          v236 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)v436);
          *(void *)&long long v431 = mlir::DenseIntElementsAttr::get<std::vector<int> &>((uint64_t)v236, v237, *(uint64_t *)__p, *(uint64_t *)&__p[8]);
          int v416 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v208, v398, (uint64_t **)&v431);
          v238 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::mps::ConstantOp &>(v208, v398, &ArgValue, &v416);
          if (!*((_DWORD *)v238 + 9)) {
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          }
          Arguint64_t Value = (uint64_t)v238 - 16;
          v225 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::mps::ConstantOp &>(v208, v398, &v428, v401);
          if (!*((_DWORD *)v225 + 9)) {
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          }
          goto LABEL_378;
        }
        if (v393 == 2)
        {
          LODWORD(v438) = 1;
          std::vector<int>::vector[abi:ne180100](__p, &v438, 1uLL);
          *(_DWORD *)int v436 = 0;
          std::vector<int>::vector[abi:ne180100](&v438, v436, 1uLL);
          uint64_t v218 = (uint64_t)v397;
          v401[0] = (void *)1;
          uint64_t v219 = mlir::Builder::getIntegerType(v208, 0x20u, 1);
          *(void *)int v436 = mlir::RankedTensorType::get((uint64_t)v401, 1, v219, 0);
          int v220 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)v436);
          *(void *)&long long v431 = mlir::DenseIntElementsAttr::get<std::vector<int> &>((uint64_t)v220, v221, *(uint64_t *)__p, *(uint64_t *)&__p[8]);
          v401[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v208, v398, (uint64_t **)&v431);
          int v222 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)v436);
          uint64_t v414 = mlir::DenseIntElementsAttr::get<std::vector<int> &>((uint64_t)v222, v223, v438, *((uint64_t *)&v438 + 1));
          *(void *)&long long v431 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v208, v398, (uint64_t **)&v414);
          int v224 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::mps::ConstantOp &>(v208, v398, &v428, v401);
          if (!*((_DWORD *)v224 + 9)) {
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          }
          uint64_t v428 = (uint64_t)v224 - 16;
          v225 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::mps::ConstantOp &>(v208, v398, &v428, &v431);
          if (!*((_DWORD *)v225 + 9)) {
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          }
LABEL_378:
          uint64_t v428 = (uint64_t)v225 - 16;
          int v415 = -3;
          if ((void)v438)
          {
            *((void *)&v438 + 1) = v438;
            operator delete((void *)v438);
          }
          if (*(void *)__p)
          {
            *(void *)&__p[8] = *(void *)__p;
            operator delete(*(void **)__p);
          }
LABEL_382:
          if (v400)
          {
            *(void *)&long long v438 = 0;
            if (v209)
            {
              int v231 = v394;
              *(void *)__p = MILToMLIR::arrayToU64Attr(v208, (mlir::OpBuilder *)&v445, (int *)3);
              *(void *)int v436 = MILToMLIR::arrayToU64Attr(v208, (mlir::OpBuilder *)&v441, (int *)3);
              v401[0] = (void *)MILToMLIR::arrayToU64Attr(v208, (mlir::OpBuilder *)&v449, (int *)6);
              uint64_t v239 = mlir::OpBuilder::create<mlir::mps::DepthwiseConv3DOp,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle &,int &>(v208, v398, &ArgValue, &v428, (uint64_t *)__p, (uint64_t *)v436, (uint64_t *)v401, &v417, &v415);
              if (!*(_DWORD *)(v239 + 36)) {
                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
              }
LABEL_388:
              *(void *)&long long v438 = v239 - 16;
              if (OptionalArgValue)
              {
                *(void *)__p = mlir::getElementTypeOrSelf((void *)(*(void *)(v239 - 8) & 0xFFFFFFFFFFFFFFF8));
                uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf((void *)(*(void *)(OptionalArgValue + 8) & 0xFFFFFFFFFFFFFFF8));
                if (*(void *)__p != ElementTypeOrSelf)
                {
                  int v241 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)v208, v398, &OptionalArgValue, (uint64_t *)__p);
                  if (!*((_DWORD *)v241 + 9)) {
                    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                  }
                  OptionalArguint64_t Value = (uint64_t)v241 - 16;
                }
                *(_DWORD *)int v436 = 0;
                uint64_t v242 = mlir::OpBuilder::create<mlir::mps::BiasAddOp,mlir::Value &,mlir::Value &,mlir::mps::TensorDataLayout>((mlir::MLIRContext **)v208, v398, (uint64_t *)&v438, &OptionalArgValue, (int *)v436);
                if (!*(_DWORD *)(v242 + 36)) {
                  __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                }
                *(void *)&long long v438 = v242 - 16;
              }
              if (v231)
              {
                int v243 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::mps::ConstantOp &>(v208, v398, (uint64_t *)&v438, &v416);
                if (!*((_DWORD *)v243 + 9)) {
                  __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                }
                *(void *)&long long v438 = (char *)v243 - 16;
              }
              (*(void (**)(unsigned char *__return_ptr, MILToMLIR *))(*(void *)this + 200))(__p, this);
              MILToMLIRRewriter::setValue(v218, *(long long **)__p, v438);
              std::vector<std::string>::~vector[abi:ne180100]((void **)__p);
              uint64_t v113 = 1;
              goto LABEL_360;
            }
            int v231 = v394;
LABEL_387:
            uint64_t v239 = mlir::OpBuilder::create<mlir::mps::Conv2DOp,mlir::Value &,mlir::Value &,int &,int &,int &,int &,int &,int &,int &,int &,int &,mlir::mps::PaddingStyle &,mlir::mps::TensorDataLayout &,mlir::mps::TensorDataLayout &>(v208, v398, &ArgValue, &v428, &v422, (int *)&v447 + 1, (int *)&v447, (int *)&v443 + 1, (int *)&v443, (int *)&v452 + 1, (int *)&v451 + 1, (int *)&v452, (int *)&v451, &v417, &v426, &v425);
            if (!*(_DWORD *)(v239 + 36)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
            goto LABEL_388;
          }
          goto LABEL_408;
        }
LABEL_371:
        if (v87 <= 4)
        {
          BOOL v394 = 0;
          uint64_t v218 = (uint64_t)v397;
          goto LABEL_382;
        }
        if (v399 <= 1)
        {
          if (!v454) {
            __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
          }
          if (v454 != 5) {
            goto LABEL_432;
          }
          v232 = __s2;
          if (*__s2 != 1) {
            goto LABEL_432;
          }
        }
        else
        {
          if (v454 != 5) {
            goto LABEL_432;
          }
          v232 = __s2;
        }
        if (v232[1] == 1)
        {
          *(void *)__p = 1;
          uint64_t v262 = mlir::Builder::getIntegerType(v208, 0x20u, 1);
          v401[0] = (void *)mlir::RankedTensorType::get((uint64_t)__p, 1, v262, 0);
          *(_DWORD *)__p = 1;
          llvm::SmallVector<int,1u>::SmallVector(&v438, __p, 1);
          uint64_t v263 = (uint64_t)v397;
          v264 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)v401);
          *(void *)__p = mlir::DenseIntElementsAttr::get<llvm::SmallVector<int,4u> &>((uint64_t)v264, v265, v438, DWORD2(v438));
          *(void *)&long long v431 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v208, v398, (uint64_t **)__p);
          v266 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::mps::ConstantOp &>(v208, v398, &v428, &v431);
          if (!*((_DWORD *)v266 + 9)) {
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          }
          uint64_t v428 = (uint64_t)v266 - 16;
          uint64_t v414 = 0;
          if (v400)
          {
            *(void *)__p = MILToMLIR::arrayToU64Attr(v208, (mlir::OpBuilder *)&v447, (int *)3);
            *(void *)int v436 = MILToMLIR::arrayToU64Attr(v208, (mlir::OpBuilder *)&v443, (int *)3);
            uint64_t v413 = MILToMLIR::arrayToU64Attr(v208, (mlir::OpBuilder *)&v449, (int *)6);
            uint64_t v267 = mlir::OpBuilder::create<mlir::mps::DepthwiseConv3DOp,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle &>(v208, v398, &ArgValue, &v428, (uint64_t *)__p, (uint64_t *)v436, &v413, &v417);
            if (!*(_DWORD *)(v267 + 36)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
            uint64_t v414 = v267 - 16;
            goto LABEL_553;
          }
          *(void *)__p = 4;
          uint64_t v318 = mlir::Builder::getIntegerType(v208, 0x20u, 1);
          uint64_t v413 = mlir::RankedTensorType::get((uint64_t)__p, 1, v318, 0);
          *(_OWORD *)int v436 = xmmword_18112A260;
          *(_DWORD *)&v436[16] = 1;
          llvm::SmallVector<int,5u>::SmallVector(__p, v436, 5);
          *(void *)int v436 = mlir::Type::dyn_cast<mlir::RankedTensorType>(*(void *)(v428 + 8) & 0xFFFFFFFFFFFFFFF8);
          uint64_t v319 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v436);
          unint64_t v321 = v320;
          std::string::basic_string[abi:ne180100]<0>(v436, "output_shape");
          uint64_t v322 = std::map<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>::find[abi:ne180100]((uint64_t)&v423, (uint64_t)v436);
          if (v437 < 0) {
            operator delete(*(void **)v436);
          }
          if (v424 == (char **)v322 || *(void *)(v322 + 64) - *(void *)(v322 + 56) != 16) {
            goto LABEL_549;
          }
          std::string::basic_string[abi:ne180100]<0>(v436, "output_shape");
          uint64_t v323 = MIL::IROperation::TryGetParameterValue();
          if (v437 < 0) {
            operator delete(*(void **)v436);
          }
          if (!(*(uint64_t (**)(uint64_t))(*(void *)v323 + 40))(v323))
          {
LABEL_549:
            *(void *)int v436 = 0;
LABEL_550:
            uint64_t v412 = MILToMLIR::arrayToU64Attr(v208, (mlir::OpBuilder *)&v447, (int *)3);
            uint64_t v411 = MILToMLIR::arrayToU64Attr(v208, (mlir::OpBuilder *)&v443, (int *)3);
            uint64_t v410 = MILToMLIR::arrayToU64Attr(v208, (mlir::OpBuilder *)&v449, (int *)6);
            uint64_t v341 = mlir::OpBuilder::create<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle &>(v208, v398, &ArgValue, &v428, (uint64_t *)v436, &v412, &v411, &v410, &v417);
            if (!*(_DWORD *)(v341 + 36)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
            uint64_t v414 = v341 - 16;
            if (*(unsigned char **)__p != &__p[16]) {
              free(*(void **)__p);
            }
LABEL_553:
            if (OptionalArgValue)
            {
              *(void *)int v436 = 0x200000001;
              *(_DWORD *)&v436[8] = 3;
              std::vector<int>::vector[abi:ne180100](__p, v436, 3uLL);
              uint64_t v413 = 3;
              uint64_t v342 = mlir::Builder::getIntegerType(v208, 0x20u, 1);
              *(void *)int v436 = mlir::RankedTensorType::get((uint64_t)&v413, 1, v342, 0);
              v343 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)v436);
              uint64_t v412 = mlir::DenseIntElementsAttr::get<std::vector<int> &>((uint64_t)v343, v344, *(uint64_t *)__p, *(uint64_t *)&__p[8]);
              uint64_t v413 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v208, v398, (uint64_t **)&v412);
              v345 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::mps::ConstantOp &>(v208, v398, &OptionalArgValue, &v413);
              if (!*((_DWORD *)v345 + 9)) {
                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
              }
              uint64_t v412 = (uint64_t)v345 - 16;
              uint64_t v411 = mlir::getElementTypeOrSelf((void *)(*(void *)(v414 + 8) & 0xFFFFFFFFFFFFFFF8));
              int v346 = (uint64_t *)mlir::getElementTypeOrSelf((void *)(*(void *)(v412 + 8) & 0xFFFFFFFFFFFFFFF8));
              if ((uint64_t *)v411 != v346)
              {
                v347 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)v208, v398, &v412, &v411);
                if (!*((_DWORD *)v347 + 9)) {
                  __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                }
                uint64_t v412 = (uint64_t)v347 - 16;
              }
              int v348 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)v208, v398, &v414, &v412);
              if (!*((_DWORD *)v348 + 9)) {
                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
              }
              uint64_t v414 = (uint64_t)v348 - 16;
              if (*(void *)__p)
              {
                *(void *)&__p[8] = *(void *)__p;
                operator delete(*(void **)__p);
              }
            }
            (*(void (**)(unsigned char *__return_ptr, MILToMLIR *))(*(void *)this + 200))(__p, this);
            MILToMLIRRewriter::setValue(v263, *(long long **)__p, v414);
            std::vector<std::string>::~vector[abi:ne180100]((void **)__p);
            char v349 = 1;
            int v350 = (void *)v438;
            if ((unsigned char *)v438 != v439) {
LABEL_562:
            }
              free(v350);
LABEL_563:
            if (v349) {
              goto LABEL_611;
            }
LABEL_359:
            uint64_t v113 = 0;
            goto LABEL_360;
          }
          uint64_t v324 = MIL::IRTensorValue::GetDataView<int>();
          uint64_t v326 = v324;
          switch(v325)
          {
            case 1uLL:
              int v380 = (_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v324, 1uLL, 0);
              if (*(_DWORD *)&__p[8] >= 4u)
              {
                uint64_t v329 = *(void *)__p;
                *(_DWORD *)(*(void *)__p + 12) = *v380;
                if (v321 <= 1) {
                  goto LABEL_628;
                }
                goto LABEL_621;
              }
              break;
            case 3uLL:
              int v384 = (_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v324, 3uLL, 0);
              if (*(_DWORD *)&__p[8] >= 3u)
              {
                *(_DWORD *)(*(void *)__p + 8) = *v384;
                v385 = (_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v326, 3uLL, 1uLL);
                if (*(_DWORD *)&__p[8] >= 4u)
                {
                  *(_DWORD *)(*(void *)__p + 12) = *v385;
                  int v386 = (_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v326, 3uLL, 2uLL);
                  if (*(_DWORD *)&__p[8] >= 5u)
                  {
                    uint64_t v329 = *(void *)__p;
                    *(_DWORD *)(*(void *)__p + 16) = *v386;
                    if (v321 <= 1) {
                      goto LABEL_628;
                    }
                    goto LABEL_621;
                  }
                }
              }
              break;
            case 2uLL:
              unint64_t v327 = (_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v324, 2uLL, 0);
              if (*(_DWORD *)&__p[8] >= 3u)
              {
                *(_DWORD *)(*(void *)__p + 8) = *v327;
                int v328 = (_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v326, 2uLL, 1uLL);
                if (*(_DWORD *)&__p[8] >= 4u)
                {
                  uint64_t v329 = *(void *)__p;
                  *(_DWORD *)(*(void *)__p + 12) = *v328;
                  if (v425 == 3)
                  {
                    if (v321 > 2)
                    {
                      uint64_t v330 = 2;
LABEL_622:
                      *(_DWORD *)(v329 + 4) = *(void *)(v319 + 8 * v330);
                      v381 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v413);
                      v208 = v396;
                      uint64_t v412 = mlir::DenseIntElementsAttr::get<llvm::SmallVector<int,4u> &>((uint64_t)v381, v382, *(uint64_t *)__p, *(unsigned int *)&__p[8]);
                      v383 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v396, v398, (uint64_t **)&v412);
                      if (!*((_DWORD *)v383 + 9)) {
                        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                      }
                      *(void *)int v436 = (char *)v383 - 16;
                      uint64_t v263 = (uint64_t)v397;
                      goto LABEL_550;
                    }
                    goto LABEL_628;
                  }
                  if (v321 <= 1)
                  {
LABEL_628:
                    v387 = "Index < Length && \"Invalid index!\"";
                    int v388 = 257;
                    v389 = "ArrayRef.h";
                    goto LABEL_681;
                  }
LABEL_621:
                  uint64_t v330 = 1;
                  goto LABEL_622;
                }
              }
              break;
            default:
              if (v325 < 4) {
                std::string::basic_string[abi:ne180100]<0>(v436, "Invalid output shape.");
              }
              else {
                std::string::basic_string[abi:ne180100]<0>(v436, "1d, 2d convolutions supported currently.");
              }
              MILToMLIRRewriter::notifyFailure((uint64_t)v397, (uint64_t)this, v436);
              if (v437 < 0) {
                operator delete(*(void **)v436);
              }
              if (*(unsigned char **)__p != &__p[16]) {
                free(*(void **)__p);
              }
              char v349 = 0;
              int v350 = (void *)v438;
              if ((unsigned char *)v438 != v439) {
                goto LABEL_562;
              }
              goto LABEL_563;
          }
          v387 = "idx < size()";
          int v388 = 294;
          v389 = "SmallVector.h";
LABEL_681:
          __assert_rtn("operator[]", v389, v388, v387);
        }
LABEL_432:
        *(void *)__p = mlir::Type::dyn_cast<mlir::RankedTensorType>(*(void *)(v428 + 8) & 0xFFFFFFFFFFFFFFF8);
        v268 = (void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)__p);
        uint64_t v270 = v269;
        int v271 = v217;
        *(void *)__p = mlir::Type::dyn_cast<mlir::RankedTensorType>(*(void *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
        uint64_t v272 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)__p);
        uint64_t v414 = -1;
        if (v270 == 5 && v273 == 5)
        {
          uint64_t v274 = v272;
          unsigned int v275 = v390 - 1;
          if (v391 == 1 && v268[2] == 1 && (v275 < 2 || !(void)v449))
          {
            uint64_t v276 = 2;
          }
          else if (HIDWORD(v447) == 1 && v268[3] == 1 && (v275 < 2 || !*((void *)&v449 + 1)))
          {
            uint64_t v276 = 3;
          }
          else
          {
            if (v448 != 1 || v268[4] != 1 || v275 >= 2 && v450) {
              goto LABEL_461;
            }
            uint64_t v276 = 4;
          }
          uint64_t v414 = v276;
          if (v400)
          {
            *(void *)__p = 1;
            uint64_t v279 = mlir::Builder::getIntegerType(v208, 0x20u, 1);
            v401[0] = (void *)mlir::RankedTensorType::get((uint64_t)__p, 1, v279, 0);
            *(_DWORD *)__p = v276;
            llvm::SmallVector<int,1u>::SmallVector(&v438, __p, 1);
            v280 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)v401);
            *(void *)__p = mlir::DenseIntElementsAttr::get<llvm::SmallVector<int,4u> &>((uint64_t)v280, v281, v438, DWORD2(v438));
            *(void *)&long long v431 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v208, v398, (uint64_t **)__p);
            if (*(void *)v274 == 1)
            {
              *(_DWORD *)__p = 0;
              uint64_t v282 = mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int,long long &>(v208, v398, &ArgValue, (unsigned int *)__p, (unsigned int *)&v414);
              if (!*(_DWORD *)(v282 + 36)) {
                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
              }
              Arguint64_t Value = v282 - 16;
              int v283 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::mps::ConstantOp &>(v208, v398, &ArgValue, &v431);
              if (!*((_DWORD *)v283 + 9)) {
                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
              }
              Arguint64_t Value = (uint64_t)v283 - 16;
              goto LABEL_580;
            }
            *(_DWORD *)__p = v276 - 1;
            *(_DWORD *)int v436 = v276;
            uint64_t v351 = mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int &,int>(v208, v398, &ArgValue, (unsigned int *)__p, (unsigned int *)v436);
            if (*(_DWORD *)(v351 + 36))
            {
              Arguint64_t Value = v351 - 16;
              *(_DWORD *)__p = v276 - 2;
              if (v276 < 3) {
                goto LABEL_577;
              }
              *(_DWORD *)int v436 = v276 - 1;
              uint64_t v352 = mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int &,int>(v396, v398, &ArgValue, (unsigned int *)__p, (unsigned int *)v436);
              if (!*(_DWORD *)(v352 + 36)) {
                goto LABEL_674;
              }
              Arguint64_t Value = v352 - 16;
              *(_DWORD *)__p = v276 - 3;
              if (v276 < 4)
              {
LABEL_577:
                *(void *)__p = 4;
                v208 = v396;
                uint64_t v354 = mlir::Builder::getIntegerType(v396, 0x20u, 1);
                uint64_t v413 = mlir::RankedTensorType::get((uint64_t)__p, 1, v354, 0);
                *(_DWORD *)int v436 = *(void *)(v274 + 8 * v276) * *(_DWORD *)v274;
                *(int32x4_t *)&v436[4] = vuzp1q_s32(*(int32x4_t *)(v274 + 8), *(int32x4_t *)(v274 + 24));
                llvm::SmallVector<int,5u>::SmallVector(__p, v436, 5);
                llvm::SmallVectorImpl<int>::erase((uint64_t)__p, (char *)(*(void *)__p + 4 * v276));
                v355 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v413);
                uint64_t v412 = mlir::DenseIntElementsAttr::get<llvm::SmallVector<int,4u> &>((uint64_t)v355, v356, *(uint64_t *)__p, *(unsigned int *)&__p[8]);
                *(void *)int v436 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v396, v398, (uint64_t **)&v412);
                v357 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::UnitAttr **)v396, v398, &ArgValue, v436);
                if (!*((_DWORD *)v357 + 9)) {
                  __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                }
                Arguint64_t Value = (uint64_t)v357 - 16;
                if (*(unsigned char **)__p != &__p[16]) {
                  free(*(void **)__p);
                }
LABEL_580:
                int v358 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::mps::ConstantOp &>(v208, v398, &v428, &v431);
                if (!*((_DWORD *)v358 + 9)) {
                  __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                }
                uint64_t v428 = (uint64_t)v358 - 16;
                uint64_t v412 = SHIDWORD(v447);
                uint64_t v413 = v448;
                uint64_t v410 = SHIDWORD(v443);
                uint64_t v411 = v444;
                unint64_t v408 = SHIDWORD(v450);
                unint64_t v409 = (int)v450;
                unint64_t v406 = SHIDWORD(v449);
                unint64_t v407 = SDWORD2(v449);
                if (v276 == 4)
                {
                  uint64_t v412 = v391;
                  uint64_t v413 = SHIDWORD(v447);
                  uint64_t v410 = v271;
                  uint64_t v411 = SHIDWORD(v443);
                  unint64_t v408 = SHIDWORD(v449);
                  unint64_t v409 = SDWORD2(v449);
                }
                else
                {
                  if (v276 != 3)
                  {
LABEL_592:
                    uint64_t v367 = mlir::OpBuilder::create<mlir::mps::Conv2DOp,mlir::Value &,mlir::Value &,int &,unsigned long &,unsigned long &,unsigned long &,unsigned long &,unsigned long &,unsigned long &,unsigned long &,unsigned long &,mlir::mps::PaddingStyle &,mlir::mps::TensorDataLayout &,mlir::mps::TensorDataLayout &>(v208, v398, &ArgValue, &v428, &v422, (unint64_t *)&v413, (unint64_t *)&v412, &v411, &v410, &v409, &v408, &v407, &v406, &v417, &v426, &v425);
                    if (!*(_DWORD *)(v367 + 36)) {
                      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                    }
                    uint64_t v405 = v367 - 16;
                    if (OptionalArgValue)
                    {
                      *(void *)__p = mlir::getElementTypeOrSelf((void *)(*(void *)(v367 - 8) & 0xFFFFFFFFFFFFFFF8));
                      uint64_t v368 = mlir::getElementTypeOrSelf((void *)(*(void *)(OptionalArgValue + 8) & 0xFFFFFFFFFFFFFFF8));
                      if (*(void *)__p != v368)
                      {
                        v369 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)v208, v398, &OptionalArgValue, (uint64_t *)__p);
                        if (!*((_DWORD *)v369 + 9)) {
                          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                        }
                        OptionalArguint64_t Value = (uint64_t)v369 - 16;
                      }
                      *(_DWORD *)int v436 = 0;
                      uint64_t v367 = mlir::OpBuilder::create<mlir::mps::BiasAddOp,mlir::Value &,mlir::Value &,mlir::mps::TensorDataLayout>((mlir::MLIRContext **)v208, v398, &v405, &OptionalArgValue, (int *)v436);
                      if (!*(_DWORD *)(v367 + 36)) {
                        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                      }
                      uint64_t v405 = v367 - 16;
                    }
                    *(void *)__p = mlir::Type::dyn_cast_or_null<mlir::TensorType>(*(void *)(v367 - 8) & 0xFFFFFFFFFFFFFFF8);
                    uint64_t v370 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)__p);
                    if (v371 != 4 || (uint64_t v372 = *(void *)(v274 + 8 * v276), *(void *)v370 != v372 * *(void *)v274)) {
                      __assert_rtn("matchAndRewriteConv", "MILToMLIRCustomPatterns.mm", 652, "resultShape.size() == 4 && resultShape[0] == xShape[0] * xShape[batchLikeDimIndex]");
                    }
                    *(_DWORD *)int v436 = *(void *)v274;
                    *(_DWORD *)&v436[4] = v372;
                    *(int32x2_t *)&v436[8] = vmovn_s64(*(int64x2_t *)(v370 + 8));
                    *(_DWORD *)&v436[16] = *(void *)(v370 + 24);
                    llvm::SmallVector<int,5u>::SmallVector(__p, v436, 5);
                    *(void *)int v436 = 5;
                    uint64_t v373 = mlir::Builder::getIntegerType(v208, 0x20u, 1);
                    int v404 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v436, 1, v373, 0);
                    int v374 = mlir::Type::cast<mlir::ShapedType>(&v404);
                    *(void *)int v436 = mlir::DenseIntElementsAttr::get<llvm::SmallVector<int,4u> &>((uint64_t)v374, v375, *(uint64_t *)__p, *(unsigned int *)&__p[8]);
                    v403 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v208, v398, (uint64_t **)v436);
                    int v376 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::UnitAttr **)v208, v398, &v405, &v403);
                    if (!*((_DWORD *)v376 + 9)) {
                      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                    }
                    uint64_t v405 = (uint64_t)v376 - 16;
                    *(_DWORD *)int v436 = 1;
                    unsigned int v402 = 2;
                    uint64_t v377 = mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int &,int>(v208, v398, &v405, (unsigned int *)v436, &v402);
                    if (*(_DWORD *)(v377 + 36))
                    {
                      uint64_t v405 = v377 - 16;
                      *(_DWORD *)int v436 = 2;
                      if (v276 < 3) {
                        goto LABEL_608;
                      }
                      unsigned int v402 = 3;
                      uint64_t v378 = mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int &,int>(v208, v398, &v405, (unsigned int *)v436, &v402);
                      if (*(_DWORD *)(v378 + 36))
                      {
                        uint64_t v405 = v378 - 16;
                        *(_DWORD *)int v436 = 3;
                        if (v276 < 4) {
                          goto LABEL_608;
                        }
                        unsigned int v402 = 4;
                        uint64_t v379 = mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int &,int>(v208, v398, &v405, (unsigned int *)v436, &v402);
                        if (*(_DWORD *)(v379 + 36))
                        {
                          uint64_t v405 = v379 - 16;
                          *(_DWORD *)int v436 = 4;
LABEL_608:
                          (*(void (**)(unsigned char *__return_ptr, MILToMLIR *))(*(void *)this + 200))(v436, this);
                          MILToMLIRRewriter::setValue((uint64_t)v397, *(long long **)v436, v405);
                          std::vector<std::string>::~vector[abi:ne180100]((void **)v436);
                          if (*(unsigned char **)__p != &__p[16]) {
                            free(*(void **)__p);
                          }
                          int v340 = (void *)v438;
                          if ((unsigned char *)v438 != v439) {
                            goto LABEL_539;
                          }
                          goto LABEL_611;
                        }
                      }
                    }
                    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                  }
                  uint64_t v413 = v448;
                  uint64_t v411 = v444;
                  uint64_t v412 = v391;
                  unint64_t v409 = (int)v450;
                  uint64_t v410 = v271;
                  unint64_t v408 = SHIDWORD(v450);
                }
                unint64_t v406 = SDWORD1(v449);
                unint64_t v407 = (int)v449;
                goto LABEL_592;
              }
              *(_DWORD *)int v436 = v276 - 2;
              uint64_t v353 = mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int &,int>(v396, v398, &ArgValue, (unsigned int *)__p, (unsigned int *)v436);
              if (*(_DWORD *)(v353 + 36))
              {
                Arguint64_t Value = v353 - 16;
                *(_DWORD *)__p = v276 - 4;
                goto LABEL_577;
              }
            }
LABEL_674:
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          }
        }
LABEL_461:
        unsigned int v426 = 7;
        *(void *)__p = 5;
        uint64_t v284 = mlir::IntegerType::get(*(void *)v208, 0x20u, 1u);
        *(void *)&long long v438 = mlir::RankedTensorType::get((uint64_t)__p, 1, v284, 0);
        uint64_t v285 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v438);
        *(_DWORD *)&__p[16] = 0;
        *(_OWORD *)__p = xmmword_18112A24C;
        *(void *)int v436 = mlir::DenseIntElementsAttr::get<int>((uint64_t)v285, v286, (uint64_t)__p, 5);
        *(void *)__p = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v208, v398, (uint64_t **)v436);
        uint64_t v287 = mlir::OpBuilder::create<mlir::mps::PermuteOp,mlir::Value &,mlir::mps::ConstantOp &>(v208, v398, &v428, (uint64_t)__p);
        if (!*(_DWORD *)(v287 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        uint64_t v428 = v287 - 16;
        unsigned int v425 = 10;
        uint64_t v413 = 0;
        *(void *)&long long v288 = (int)v450;
        *((void *)&v288 + 1) = SHIDWORD(v450);
        long long v289 = v288;
        *(void *)&long long v288 = SDWORD2(v449);
        *((void *)&v288 + 1) = SHIDWORD(v449);
        *(_OWORD *)__p = v289;
        *(_OWORD *)&__p[16] = v288;
        *(void *)&long long v288 = (int)v449;
        *((void *)&v288 + 1) = SDWORD1(v449);
        long long v435 = v288;
        std::vector<unsigned long long>::vector[abi:ne180100](&v438, __p, 6uLL);
        *(void *)__p = v448;
        *(void *)&__p[8] = SHIDWORD(v447);
        *(void *)&__p[16] = v391;
        std::vector<unsigned long long>::vector[abi:ne180100](v436, __p, 3uLL);
        *(void *)__p = v444;
        *(void *)&__p[8] = SHIDWORD(v443);
        *(void *)&__p[16] = v271;
        std::vector<unsigned long long>::vector[abi:ne180100](v401, __p, 3uLL);
        if (v400)
        {
          uint64_t v290 = mlir::OpBuilder::create<mlir::mps::Conv3DOp,mlir::Value &,mlir::Value &,int &,std::vector<unsigned long long> &,std::vector<unsigned long long> &,std::vector<unsigned long long> &,mlir::mps::PaddingStyle &,mlir::mps::TensorDataLayout &,mlir::mps::TensorDataLayout &>(v208, v398, &ArgValue, &v428, &v422, (uint64_t)v436, (uint64_t)v401, (uint64_t)&v438, &v417, &v426, &v425);
          if (!*(_DWORD *)(v290 + 36)) {
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          }
          uint64_t v413 = v290 - 16;
        }
        else
        {
          *(void *)__p = 5;
          uint64_t v291 = mlir::Builder::getIntegerType(v208, 0x20u, 1);
          uint64_t v412 = mlir::RankedTensorType::get((uint64_t)__p, 1, v291, 0);
          long long v431 = xmmword_18112A260;
          int v432 = 1;
          llvm::SmallVector<int,4u>::SmallVector(__p, &v431, 5);
          std::string::basic_string[abi:ne180100]<0>(&v431, "output_shape");
          uint64_t v292 = std::map<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>::find[abi:ne180100]((uint64_t)&v423, (uint64_t)&v431);
          if (v433 < 0) {
            operator delete((void *)v431);
          }
          if (v424 == (char **)v292 || *(void *)(v292 + 64) - *(void *)(v292 + 56) != 16) {
            goto LABEL_478;
          }
          std::string::basic_string[abi:ne180100]<0>(&v431, "output_shape");
          uint64_t v293 = MIL::IROperation::TryGetParameterValue();
          if (v433 < 0) {
            operator delete((void *)v431);
          }
          if ((*(uint64_t (**)(uint64_t))(*(void *)v293 + 40))(v293))
          {
            uint64_t v294 = MIL::IRTensorValue::GetDataView<int>();
            unint64_t v296 = v295;
            if (v295)
            {
              uint64_t v297 = v294;
              unint64_t v298 = 0;
              do
              {
                int v299 = (_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v297, v296, v298);
                if (v298 >= *(unsigned int *)&__p[8]) {
                  __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
                }
                *(_DWORD *)(*(void *)__p + 4 * v298++) = *v299;
              }
              while (v296 != v298);
            }
            v300 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v412);
            uint64_t v411 = mlir::DenseIntElementsAttr::get<llvm::SmallVector<int,4u> &>((uint64_t)v300, v301, *(uint64_t *)__p, *(unsigned int *)&__p[8]);
            v302 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v208, v398, (uint64_t **)&v411);
            if (!*((_DWORD *)v302 + 9)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
            *(void *)&long long v431 = (char *)v302 - 16;
          }
          else
          {
LABEL_478:
            *(void *)&long long v431 = 0;
          }
          uint64_t v303 = mlir::OpBuilder::create<mlir::mps::Conv3DDataGradientOp,mlir::Value &,mlir::Value &,mlir::Value &,int &,std::vector<unsigned long long> &,std::vector<unsigned long long> &,std::vector<unsigned long long> &,mlir::mps::PaddingStyle &,mlir::mps::TensorDataLayout &,mlir::mps::TensorDataLayout &>(v208, v398, &ArgValue, &v428, (uint64_t *)&v431, &v422, (uint64_t)v436, (uint64_t)v401, (uint64_t)&v438, &v417, &v426, &v425);
          if (!*(_DWORD *)(v303 + 36)) {
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          }
          uint64_t v413 = v303 - 16;
          if (*(unsigned char **)__p != &__p[16]) {
            free(*(void **)__p);
          }
        }
        if (OptionalArgValue)
        {
          *(void *)&long long v431 = 0x200000001;
          DWORD2(v431) = 3;
          std::vector<int>::vector[abi:ne180100](__p, &v431, 3uLL);
          uint64_t v412 = 3;
          uint64_t v304 = mlir::Builder::getIntegerType(v208, 0x20u, 1);
          *(void *)&long long v431 = mlir::RankedTensorType::get((uint64_t)&v412, 1, v304, 0);
          int v305 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v431);
          uint64_t v411 = mlir::DenseIntElementsAttr::get<std::vector<int> &>((uint64_t)v305, v306, *(uint64_t *)__p, *(uint64_t *)&__p[8]);
          uint64_t v412 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v208, v398, (uint64_t **)&v411);
          int v307 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::mps::ConstantOp &>(v208, v398, &OptionalArgValue, &v412);
          if (!*((_DWORD *)v307 + 9)) {
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          }
          uint64_t v411 = (uint64_t)v307 - 16;
          uint64_t v410 = mlir::getElementTypeOrSelf((void *)(*(void *)(v413 + 8) & 0xFFFFFFFFFFFFFFF8));
          uint64_t v308 = mlir::getElementTypeOrSelf((void *)(*(void *)(v411 + 8) & 0xFFFFFFFFFFFFFFF8));
          if (v410 != v308)
          {
            char v309 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)v208, v398, &v411, &v410);
            if (!*((_DWORD *)v309 + 9)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
            uint64_t v411 = (uint64_t)v309 - 16;
          }
          int v310 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)v208, v398, &v413, &v411);
          if (!*((_DWORD *)v310 + 9)) {
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          }
          uint64_t v413 = (uint64_t)v310 - 16;
          if (*(void *)__p)
          {
            *(void *)&__p[8] = *(void *)__p;
            operator delete(*(void **)__p);
          }
        }
        (*(void (**)(unsigned char *__return_ptr, MILToMLIR *))(*(void *)this + 200))(__p, this);
        MILToMLIRRewriter::setValue((uint64_t)v397, *(long long **)__p, v413);
        std::vector<std::string>::~vector[abi:ne180100]((void **)__p);
        if (v401[0])
        {
          v401[1] = v401[0];
          operator delete(v401[0]);
        }
        if (*(void *)v436)
        {
          *(void *)&v436[8] = *(void *)v436;
          operator delete(*(void **)v436);
        }
        if ((void)v438)
        {
          *((void *)&v438 + 1) = v438;
          operator delete((void *)v438);
          uint64_t v113 = 1;
          goto LABEL_360;
        }
        goto LABEL_611;
      }
      if (v87 != 3) {
        goto LABEL_371;
      }
      LODWORD(v438) = 2;
      std::vector<int>::vector[abi:ne180100](__p, &v438, 1uLL);
      *(_DWORD *)int v436 = 2;
      std::vector<int>::vector[abi:ne180100](&v438, v436, 1uLL);
      uint64_t v218 = (uint64_t)v397;
      v401[0] = (void *)1;
      uint64_t v226 = mlir::Builder::getIntegerType(v208, 0x20u, 1);
      *(void *)int v436 = mlir::RankedTensorType::get((uint64_t)v401, 1, v226, 0);
      v227 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)v436);
      v401[0] = (void *)mlir::DenseIntElementsAttr::get<std::vector<int> &>((uint64_t)v227, v228, *(uint64_t *)__p, *(uint64_t *)&__p[8]);
      int v416 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v208, v398, (uint64_t **)v401);
      int v229 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::mps::ConstantOp &>(v208, v398, &ArgValue, &v416);
      if (!*((_DWORD *)v229 + 9)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
      Arguint64_t Value = (uint64_t)v229 - 16;
      v230 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::mps::ConstantOp &>(v208, v398, &v428, &v416);
      if (!*((_DWORD *)v230 + 9)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
      uint64_t v428 = (uint64_t)v230 - 16;
      if ((void)v438)
      {
        *((void *)&v438 + 1) = v438;
        operator delete((void *)v438);
      }
      if (*(void *)__p)
      {
        *(void *)&__p[8] = *(void *)__p;
        operator delete(*(void **)__p);
      }
      if (v400)
      {
        *(void *)&long long v438 = 0;
        int v231 = 1;
        goto LABEL_387;
      }
      BOOL v394 = 1;
LABEL_408:
      *(void *)__p = 4;
      uint64_t v251 = mlir::Builder::getIntegerType(v208, 0x20u, 1);
      *(void *)int v436 = mlir::RankedTensorType::get((uint64_t)__p, 1, v251, 0);
      long long v438 = xmmword_181129DB0;
      llvm::SmallVector<int,4u>::SmallVector(__p, &v438, 4);
      std::string::basic_string[abi:ne180100]<0>(&v438, "output_shape");
      uint64_t v252 = std::map<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>::find[abi:ne180100]((uint64_t)&v423, (uint64_t)&v438);
      if (v440 < 0) {
        operator delete((void *)v438);
      }
      if (v424 != (char **)v252 && *(void *)(v252 + 64) - *(void *)(v252 + 56) == 16)
      {
        std::string::basic_string[abi:ne180100]<0>(&v438, "output_shape");
        uint64_t v253 = MIL::IROperation::TryGetParameterValue();
        if (v440 < 0) {
          operator delete((void *)v438);
        }
        if ((*(uint64_t (**)(uint64_t))(*(void *)v253 + 40))(v253))
        {
          uint64_t v254 = MIL::IRTensorValue::GetDataView<int>();
          uint64_t v256 = v254;
          if (v255 == 3)
          {
            v331 = (_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v254, 3uLL, 2uLL);
            if (*(_DWORD *)&__p[8] < 4u) {
              goto LABEL_649;
            }
            *(_DWORD *)(*(void *)__p + 12) = *v331;
            uint64_t v332 = (_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v256, 3uLL, 1uLL);
            if (*(_DWORD *)&__p[8] < 2u) {
              goto LABEL_649;
            }
            *(_DWORD *)(*(void *)__p + 4) = *v332;
            v260 = (_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v256, 3uLL, 0);
LABEL_524:
            if (*(_DWORD *)&__p[8])
            {
              **(_DWORD **)__p = *v260;
              goto LABEL_526;
            }
LABEL_649:
            __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
          }
          if (v255 == 4)
          {
            int v257 = (_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v254, 4uLL, 2uLL);
            if (*(_DWORD *)&__p[8] < 3u) {
              goto LABEL_649;
            }
            *(_DWORD *)(*(void *)__p + 8) = *v257;
            v258 = (_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v256, 4uLL, 3uLL);
            if (*(_DWORD *)&__p[8] < 4u) {
              goto LABEL_649;
            }
            *(_DWORD *)(*(void *)__p + 12) = *v258;
            int v259 = (_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v256, 4uLL, 1uLL);
            if (*(_DWORD *)&__p[8] < 2u) {
              goto LABEL_649;
            }
            *(_DWORD *)(*(void *)__p + 4) = *v259;
            v260 = (_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v256, 4uLL, 0);
            goto LABEL_524;
          }
          if (v255 < 5)
          {
            if (v255)
            {
LABEL_526:
              unint64_t v333 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)v436);
              *(void *)&long long v438 = mlir::DenseIntElementsAttr::get<llvm::SmallVector<int,4u> &>((uint64_t)v333, v334, *(uint64_t *)__p, *(unsigned int *)&__p[8]);
              v335 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v208, v398, (uint64_t **)&v438);
              if (!*((_DWORD *)v335 + 9)) {
                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
              }
              v401[0] = (char *)v335 - 16;
              *(void *)&long long v431 = 0;
              if (!v209) {
                goto LABEL_528;
              }
              goto LABEL_422;
            }
            std::string::basic_string[abi:ne180100]<0>(&v438, "Invalid output shape.");
            MILToMLIRRewriter::notifyFailure(v218, (uint64_t)this, (const std::string::value_type *)&v438);
            if ((v440 & 0x80000000) == 0) {
              goto LABEL_568;
            }
          }
          else
          {
            std::string::basic_string[abi:ne180100]<0>(&v438, "1d, 2d convolutions supported currently.");
            MILToMLIRRewriter::notifyFailure(v218, (uint64_t)this, (const std::string::value_type *)&v438);
            if ((v440 & 0x80000000) == 0) {
              goto LABEL_568;
            }
          }
          operator delete((void *)v438);
LABEL_568:
          if (*(unsigned char **)__p != &__p[16]) {
            free(*(void **)__p);
          }
          goto LABEL_359;
        }
      }
      v401[0] = 0;
      *(void *)&long long v431 = 0;
      if (!v209)
      {
LABEL_528:
        uint64_t v261 = mlir::OpBuilder::create<mlir::mps::Conv2DDataGradientOp,mlir::Value &,mlir::Value &,mlir::Value &,int &,int &,int &,int &,int &,int &,int &,int &,int &,mlir::mps::PaddingStyle &,mlir::mps::TensorDataLayout &,mlir::mps::TensorDataLayout &>(v208, v398, &ArgValue, &v428, (uint64_t *)v401, &v422, (int *)&v447 + 1, (int *)&v447, (int *)&v443 + 1, (int *)&v443, (int *)&v452 + 1, (int *)&v451 + 1, (int *)&v452, (int *)&v451, &v417, &v426, &v425);
        if (!*(_DWORD *)(v261 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        goto LABEL_529;
      }
LABEL_422:
      *(void *)&long long v438 = MILToMLIR::arrayToU64Attr(v208, (mlir::OpBuilder *)&v445, (int *)3);
      uint64_t v414 = MILToMLIR::arrayToU64Attr(v208, (mlir::OpBuilder *)&v441, (int *)3);
      uint64_t v413 = MILToMLIR::arrayToU64Attr(v208, (mlir::OpBuilder *)&v449, (int *)6);
      uint64_t v261 = mlir::OpBuilder::create<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle &,int &>(v208, v398, &ArgValue, &v428, (uint64_t *)v401, (uint64_t *)&v438, &v414, &v413, &v417, &v415);
      if (!*(_DWORD *)(v261 + 36)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
LABEL_529:
      *(void *)&long long v431 = v261 - 16;
      if (OptionalArgValue)
      {
        *(void *)&long long v438 = mlir::getElementTypeOrSelf((void *)(*(void *)(v261 - 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v336 = mlir::getElementTypeOrSelf((void *)(*(void *)(OptionalArgValue + 8) & 0xFFFFFFFFFFFFFFF8));
        if ((void)v438 != v336)
        {
          unint64_t v337 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)v208, v398, &OptionalArgValue, (uint64_t *)&v438);
          if (!*((_DWORD *)v337 + 9)) {
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          }
          OptionalArguint64_t Value = (uint64_t)v337 - 16;
        }
        LODWORD(v414) = 0;
        uint64_t v338 = mlir::OpBuilder::create<mlir::mps::BiasAddOp,mlir::Value &,mlir::Value &,mlir::mps::TensorDataLayout>((mlir::MLIRContext **)v208, v398, (uint64_t *)&v431, &OptionalArgValue, (int *)&v414);
        if (!*(_DWORD *)(v338 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        *(void *)&long long v431 = v338 - 16;
      }
      if (v394)
      {
        v339 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::mps::ConstantOp &>(v208, v398, (uint64_t *)&v431, &v416);
        if (!*((_DWORD *)v339 + 9)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        *(void *)&long long v431 = (char *)v339 - 16;
      }
      (*(void (**)(long long *__return_ptr, MILToMLIR *))(*(void *)this + 200))(&v438, this);
      MILToMLIRRewriter::setValue(v218, (long long *)v438, v431);
      std::vector<std::string>::~vector[abi:ne180100]((void **)&v438);
      int v340 = *(void **)__p;
      if (*(unsigned char **)__p != &__p[16])
      {
LABEL_539:
        free(v340);
        uint64_t v113 = 1;
        goto LABEL_360;
      }
LABEL_611:
      uint64_t v113 = 1;
LABEL_360:
      if (v420 < 0) {
        operator delete(v418);
      }
LABEL_171:
      if (__s2 != (void *)v455) {
        free(__s2);
      }
      std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v423, v424[0]);
      if (SHIBYTE(v430.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v430.__r_.__value_.__l.__data_);
      }
      return v113;
    case 10:
      if (*(void *)v418 != 0x776F6C5F656D6173 || *((_WORD *)v418 + 4) != 29285) {
        goto LABEL_683;
      }
LABEL_248:
      unsigned int v118 = 4;
      int v119 = 4;
LABEL_255:
      int v390 = v119;
      unsigned int v417 = v118;
      uint64_t v451 = 0;
      uint64_t v452 = 0;
      long long v449 = 0uLL;
      uint64_t v450 = 0;
      goto LABEL_256;
    default:
LABEL_683:
      __assert_rtn("matchAndRewriteConv", "MILToMLIRCustomPatterns.mm", 142, "0 && \"Unknown padding style\"");
  }
}

void sub_180D3A9B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,int a57,__int16 a58,char a59,char a60,uint64_t a61,uint64_t a62,char a63)
{
  if (SLOBYTE(STACK[0x257]) < 0) {
    operator delete((void *)STACK[0x240]);
  }
  if ((unint64_t *)STACK[0x210] != &STACK[0x220]) {
    free((void *)STACK[0x210]);
  }
  if ((unint64_t *)STACK[0x260] != &STACK[0x270]) {
    free((void *)STACK[0x260]);
  }
  if (a60 < 0) {
    operator delete(a55);
  }
  uint64_t v74 = *(void **)(v72 - 152);
  if (v74 != (void *)a33) {
    free(v74);
  }
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a63, (char *)a64);
  if (a72 < 0) {
    operator delete(a70);
  }
  _Unwind_Resume(a1);
}

void *std::string::basic_string[abi:ne180100]<0>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    long long v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    long long v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

uint64_t MILToMLIR::PadPattern::matchAndRewrite(MILToMLIR::PadPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v134 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v128 = 0;
  OptionalArguint64_t Value = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "constant_val");
  long long v6 = (void *)(*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 160))(a2);
  int v126 = 0;
  uint64_t v127 = 0;
  unint64_t v125 = &v126;
  uint64_t v8 = v6 + 1;
  uint64_t v7 = (void *)*v6;
  if ((void *)*v6 == v6 + 1) {
    goto LABEL_54;
  }
  v121 = (mlir::OpBuilder *)(a3 + 18);
  do
  {
    int v9 = std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__find_equal<std::string>((uint64_t **)&v125, (uint64_t *)&v126, (uint64_t **)&__s2, (uint64_t **)&__src, (const void **)v7 + 4);
    if (*v9)
    {
      unsigned int v10 = (void *)v7[1];
      if (!v10) {
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v11 = (char *)operator new(0x50uLL);
      BOOL v12 = (uint64_t *)v11;
      if (*((char *)v7 + 55) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)(v11 + 32), (const std::string::value_type *)v7[4], v7[5]);
      }
      else
      {
        long long v13 = *((_OWORD *)v7 + 2);
        *((void *)v11 + 6) = v7[6];
        *((_OWORD *)v11 + 2) = v13;
      }
      std::vector<std::shared_ptr<MIL::IRArgument>>::vector(v12 + 7, v7 + 7);
      uint64_t v14 = __s2;
      *BOOL v12 = 0;
      v12[1] = 0;
      v12[2] = v14;
      uint64_t *v9 = (uint64_t)v12;
      if (*v125)
      {
        unint64_t v125 = (uint64_t **)*v125;
        BOOL v12 = (uint64_t *)*v9;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v126, v12);
      ++v127;
      unsigned int v10 = (void *)v7[1];
      if (!v10)
      {
        do
        {
LABEL_15:
          int v15 = (void *)v7[2];
          BOOL v105 = *v15 == (void)v7;
          uint64_t v7 = v15;
        }
        while (!v105);
        goto LABEL_3;
      }
    }
    do
    {
      int v15 = v10;
      unsigned int v10 = (void *)*v10;
    }
    while (v10);
LABEL_3:
    uint64_t v7 = v15;
  }
  while (v15 != v8);
  int v16 = v126;
  HIBYTE(v133) = 3;
  LODWORD(__s2) = 6578544;
  if (v126)
  {
    uint64_t v17 = &v126;
    do
    {
      uint64_t v18 = v16;
      uint64_t v19 = v17;
      uint64_t v21 = v16 + 4;
      unsigned int v20 = (uint64_t *)v16[4];
      unint64_t v22 = *((unsigned __int8 *)v16 + 55);
      int v23 = (char)v22;
      if ((v22 & 0x80u) != 0) {
        unint64_t v22 = v18[5];
      }
      if (v23 >= 0) {
        int v24 = v21;
      }
      else {
        int v24 = v20;
      }
      if (v22 >= 3) {
        size_t v25 = 3;
      }
      else {
        size_t v25 = v22;
      }
      BOOL v26 = v22 < 3;
      int v27 = memcmp(v24, &__s2, v25);
      if (v27) {
        BOOL v26 = v27 < 0;
      }
      if (v26) {
        int v28 = (uint64_t **)(v18 + 1);
      }
      else {
        int v28 = (uint64_t **)v18;
      }
      if (v26) {
        uint64_t v17 = v19;
      }
      else {
        uint64_t v17 = (uint64_t **)v18;
      }
      int v16 = *v28;
    }
    while (v16);
    if (v17 != &v126)
    {
      uint64_t v29 = (uint64_t *)(v19 + 4);
      if (v26) {
        size_t v30 = v19;
      }
      else {
        size_t v30 = v18;
      }
      if (!v26) {
        uint64_t v29 = v21;
      }
      unint64_t v31 = *((unsigned __int8 *)v17 + 55);
      int v32 = (char)v31;
      int v34 = (uint64_t *)v30[4];
      unint64_t v33 = v30[5];
      if ((v31 & 0x80u) != 0) {
        unint64_t v31 = v33;
      }
      if (v32 >= 0) {
        int8x8_t v35 = v29;
      }
      else {
        int8x8_t v35 = v34;
      }
      if (v31 >= 3) {
        size_t v36 = 3;
      }
      else {
        size_t v36 = v31;
      }
      BOOL v37 = v31 > 3;
      int v38 = memcmp(&__s2, v35, v36);
      BOOL v39 = v38 < 0;
      if (!v38) {
        BOOL v39 = v37;
      }
      if (!v39)
      {
        if (v26) {
          int v43 = v19;
        }
        else {
          int v43 = v18;
        }
        if (v43[8] - v43[7] != 16)
        {
          uint64_t __s2 = (uint64_t)operator new(0x28uLL);
          long long v133 = xmmword_181129D80;
          strcpy((char *)__s2, "Unexpected argument size for 'pad'");
          uint64_t v40 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
          goto LABEL_55;
        }
        HIBYTE(v133) = 3;
        LODWORD(__s2) = 6578544;
        Parameteruint64_t Value = MIL::IROperation::TryGetParameterValue();
        if (SHIBYTE(v133) < 0) {
          operator delete((void *)__s2);
        }
        if (!ParameterValue)
        {
          uint64_t __s2 = (uint64_t)operator new(0x28uLL);
          long long v133 = xmmword_1811286F0;
          strcpy((char *)__s2, "Couldn't get value for parameter: \"pad\"");
          uint64_t v40 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
          goto LABEL_55;
        }
        (*(void (**)(uint64_t))(*(void *)ParameterValue + 40))(ParameterValue);
        uint64_t Data = MIL::IRTensorValue::GetDataView<int>();
        unint64_t v47 = v46;
        HIBYTE(v133) = 1;
        LOWORD(__s2) = 120;
        ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
        unint64_t v49 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(ParameterType);
        uint64_t v50 = MIL::IRTensorValueType::Rank(v49);
        if (SHIBYTE(v133) < 0) {
          operator delete((void *)__s2);
        }
        __src.__begin_ = (std::vector<int>::pointer)v50;
        __src.__end_ = (std::vector<int>::pointer)2;
        uint64_t __s2 = (uint64_t)&v133 + 8;
        *(void *)&long long v133 = 0x200000000;
        llvm::SmallVectorImpl<long long>::append<long long const*,void>((uint64_t)&__s2, &__src, &__src.__end_cap_);
        long long v51 = (uint64_t *)__s2;
        uint64_t v52 = v133;
        uint64_t v120 = ArgValue;
        __src.__begin_ = (std::vector<int>::pointer)(*(void *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
        uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&__src);
        uint64_t v54 = mlir::IntegerType::get(Context, 0x20u, 1u);
        unint64_t v55 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)v51, v52, v54, 0);
        if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v55))
        {
          uint64_t v57 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
          int v58 = 566;
          v59 = "Casting.h";
          int v60 = "cast";
LABEL_193:
          __assert_rtn(v60, v59, v58, v57);
        }
        if (v55)
        {
          uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v55);
          if (!InterfaceFor)
          {
            uint64_t v57 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            int v58 = 98;
            v59 = "InterfaceSupport.h";
            int v60 = "Interface";
            goto LABEL_193;
          }
        }
        else
        {
          uint64_t InterfaceFor = 0;
        }
        int v123 = v55;
        uint64_t v124 = InterfaceFor;
        memset(&__src, 0, sizeof(__src));
        std::vector<int>::__append(&__src, 0x20uLL);
        std::vector<int>::pointer begin = __src.__begin_;
        if (v50 <= 0) {
          uint64_t v62 = 0;
        }
        else {
          uint64_t v62 = 2 * (v50 - (v47 >> 1));
        }
        if (v62)
        {
          bzero(__src.__begin_, 4 * v62);
          std::vector<int>::pointer begin = __src.__begin_;
        }
        unint64_t v63 = v47 & 0xFFFFFFFFFFFFFFFELL;
        if ((v47 & 0xFFFFFFFFFFFFFFFELL) != 0)
        {
          unint64_t v64 = v63 - 1;
          if (v47 < v63 - 1) {
            unint64_t v64 = v47;
          }
          unint64_t v65 = v64 + 1;
          if (v65 > 8 && (uint64_t v66 = &begin[v62], (unint64_t)v66 - Data >= 0x20))
          {
            uint64_t v68 = v65 & 7;
            if ((v65 & 7) == 0) {
              uint64_t v68 = 8;
            }
            unint64_t v67 = v65 - v68;
            uint64_t v69 = (long long *)(Data + 16);
            uint64_t v70 = v66 + 4;
            unint64_t v71 = v67;
            do
            {
              long long v72 = *v69;
              *(v70 - 1) = *(v69 - 1);
              *uint64_t v70 = v72;
              v69 += 2;
              v70 += 2;
              v71 -= 8;
            }
            while (v71);
          }
          else
          {
            unint64_t v67 = 0;
          }
          uint64_t v73 = (int *)(Data + 4 * v67);
          uint64_t v74 = &begin[v62 + v67];
          unint64_t v75 = v67 - v63;
          unint64_t v76 = v47 - v67;
          do
          {
            if (!v76)
            {
              exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(exception, "index out of bounds");
              exception->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x1E4FBA4B8] + 16);
              __cxa_throw(exception, (struct type_info *)off_1E4FBE4C0, MEMORY[0x1E4FBA1B8]);
            }
            int v77 = *v73++;
            *v74++ = v77;
            --v76;
          }
          while (!__CFADD__(v75++, 1));
        }
        int v122 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v123, v124, begin, 8 * v50, 4, 1, 1);
        uint64_t v79 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ShapedType &,mlir::DenseElementsAttr &>(v121, LocationForOp, (uint64_t *)&v123, &v122);
        if (!*(_DWORD *)(v79 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        uint64_t v128 = v79 - 16;
        if (__src.__begin_)
        {
          __src.__end_ = __src.__begin_;
          operator delete(__src.__begin_);
        }
        if ((long long *)__s2 != (long long *)((char *)&v133 + 8)) {
          free((void *)__s2);
        }
        HIBYTE(v133) = 4;
        strcpy((char *)&__s2, "mode");
        int v80 = v126;
        if (!v126) {
          goto LABEL_160;
        }
        v81 = &v126;
        do
        {
          uint64_t v82 = v80;
          v83 = v81;
          v85 = v80 + 4;
          int v84 = (uint64_t *)v80[4];
          unint64_t v86 = *((unsigned __int8 *)v80 + 55);
          int v87 = (char)v86;
          if ((v86 & 0x80u) != 0) {
            unint64_t v86 = v82[5];
          }
          if (v87 >= 0) {
            int v88 = v85;
          }
          else {
            int v88 = v84;
          }
          if (v86 >= 4) {
            size_t v89 = 4;
          }
          else {
            size_t v89 = v86;
          }
          BOOL v90 = v86 < 4;
          int v91 = memcmp(v88, &__s2, v89);
          if (v91) {
            BOOL v90 = v91 < 0;
          }
          if (v90) {
            int v92 = (uint64_t **)(v82 + 1);
          }
          else {
            int v92 = (uint64_t **)v82;
          }
          if (v90) {
            v81 = v83;
          }
          else {
            v81 = (uint64_t **)v82;
          }
          int v80 = *v92;
        }
        while (v80);
        if (v81 == &v126) {
          goto LABEL_160;
        }
        v93 = (uint64_t *)(v83 + 4);
        if (v90) {
          int v94 = v83;
        }
        else {
          int v94 = v82;
        }
        if (!v90) {
          v93 = v85;
        }
        unint64_t v95 = *((unsigned __int8 *)v81 + 55);
        int v96 = (char)v95;
        size_t v98 = (uint64_t *)v94[4];
        unint64_t v97 = v94[5];
        if ((v95 & 0x80u) != 0) {
          unint64_t v95 = v97;
        }
        if (v96 >= 0) {
          BOOL v99 = v93;
        }
        else {
          BOOL v99 = v98;
        }
        if (v95 >= 4) {
          size_t v100 = 4;
        }
        else {
          size_t v100 = v95;
        }
        BOOL v101 = v95 > 4;
        int v102 = memcmp(&__s2, v99, v100);
        BOOL v103 = v102 < 0;
        if (!v102) {
          BOOL v103 = v101;
        }
        if (v103) {
          goto LABEL_160;
        }
        unint64_t v104 = v90 ? v83 : (uint64_t **)v82;
        if ((char *)v104[8] - (char *)v104[7] != 16) {
          goto LABEL_160;
        }
        HIBYTE(v133) = 4;
        strcpy((char *)&__s2, "mode");
        MIL::IROperation::TryGetParameterValue();
        if (SHIBYTE(v133) < 0) {
          operator delete((void *)__s2);
        }
        MIL::IRValue::GetScalar<std::string>();
        if (SHIBYTE(v133) < 0)
        {
          if ((void)v133 == 7)
          {
            if (*(_DWORD *)__s2 == 1818649970 && *(_DWORD *)(__s2 + 3) == 1952671084)
            {
              int v106 = 1;
              operator delete((void *)__s2);
              goto LABEL_161;
            }
          }
          else
          {
            if ((void)v133 == 8)
            {
              if (*(void *)__s2 != 0x746E6174736E6F63) {
                goto LABEL_198;
              }
              int v106 = 0;
              operator delete((void *)__s2);
              goto LABEL_161;
            }
            if ((void)v133 == 9 && *(void *)__s2 == 0x746163696C706572 && *(unsigned char *)(__s2 + 8) == 101)
            {
              int v106 = 3;
              operator delete((void *)__s2);
              goto LABEL_161;
            }
          }
        }
        else
        {
          if (HIBYTE(v133) != 7)
          {
            if (HIBYTE(v133) != 8)
            {
              if (HIBYTE(v133) != 9) {
                goto LABEL_198;
              }
              BOOL v105 = __s2 == 0x746163696C706572 && v133 == 101;
              if (!v105) {
                goto LABEL_198;
              }
              int v106 = 3;
LABEL_161:
              if (!OptionalArgValue)
              {
                uint64_t __s2 = *(void *)(v120 + 8) & 0xFFFFFFFFFFFFFFF8;
                int v108 = (mlir::Float32Type *)mlir::Attribute::getContext((mlir::Attribute *)&__s2);
                uint64_t v110 = mlir::Float32Type::get(v108, v109);
                uint64_t __s2 = 1;
                int v111 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&__s2, 1, v110, 0);
                uint64_t __s2 = mlir::mps::getConstantAttr<int>(v111, 0);
                BOOL v112 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v121, LocationForOp, (uint64_t **)&__s2);
                if (!*((_DWORD *)v112 + 9)) {
                  __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                }
                OptionalArguint64_t Value = (uint64_t)v112 - 16;
              }
              if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
              {
                LODWORD(__s2) = v106;
                uint64_t v113 = mlir::OpBuilder::create<mlir::mps::PadOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::mps::PaddingMode>((mlir::MLIRContext **)v121, LocationForOp, &ArgValue, &v128, &OptionalArgValue, (unsigned int *)&__s2);
                if (!*(_DWORD *)(v113 + 36)) {
                  __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                }
                (*(void (**)(uint64_t *__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__s2, a2);
                MILToMLIRRewriter::setValue((uint64_t)a3, (long long *)__s2, v113 - 16);
                uint64_t v114 = __s2;
                if (__s2)
                {
                  uint64_t v115 = v133;
                  int v116 = (uint64_t *)__s2;
                  if ((void)v133 != __s2)
                  {
                    do
                    {
                      if (*(char *)(v115 - 1) < 0) {
                        operator delete(*(void **)(v115 - 24));
                      }
                      v115 -= 24;
                    }
                    while (v115 != v114);
                    int v116 = (uint64_t *)__s2;
                  }
                  *(void *)&long long v133 = v114;
                  operator delete(v116);
                }
                uint64_t v41 = 1;
              }
              else
              {
                uint64_t __s2 = (uint64_t)operator new(0x40uLL);
                long long v133 = xmmword_181129DA0;
                strcpy((char *)__s2, "The number of outputs does not match the number of results.");
                MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
                if (SHIBYTE(v133) < 0) {
                  operator delete((void *)__s2);
                }
                uint64_t v41 = 0;
              }
              goto LABEL_57;
            }
            if (__s2 != 0x746E6174736E6F63) {
              goto LABEL_198;
            }
LABEL_160:
            int v106 = 0;
            goto LABEL_161;
          }
          if (__s2 == 1818649970 && *(_DWORD *)((char *)&__s2 + 3) == 1952671084)
          {
            int v106 = 1;
            goto LABEL_161;
          }
        }
LABEL_198:
        __assert_rtn("matchAndRewrite", "MILToMLIRCustomPatterns.mm", 827, "0 && \"Unknown padding mode\"");
      }
    }
  }
LABEL_54:
  uint64_t __s2 = (uint64_t)operator new(0x30uLL);
  long long v133 = xmmword_181129D90;
  strcpy((char *)__s2, "Could not find parameter with name 'pad'.");
  uint64_t v40 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
LABEL_55:
  uint64_t v41 = v40;
  if (SHIBYTE(v133) < 0) {
    operator delete((void *)__s2);
  }
LABEL_57:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v125, (char *)v126);
  return v41;
}

void sub_180D3BC3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, char *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
}

uint64_t std::map<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>::find[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  int v4 = *(char *)(a2 + 23);
  size_t v5 = v4 >= 0 ? *(unsigned __int8 *)(a2 + 23) : *(void *)(a2 + 8);
  long long v6 = v4 >= 0 ? (const void *)a2 : *(const void **)a2;
  uint64_t v7 = a1 + 8;
  do
  {
    int v8 = *(char *)(v3 + 55);
    if (v8 >= 0) {
      size_t v9 = *(unsigned __int8 *)(v3 + 55);
    }
    else {
      size_t v9 = *(void *)(v3 + 40);
    }
    if (v8 >= 0) {
      unsigned int v10 = (const void *)(v3 + 32);
    }
    else {
      unsigned int v10 = *(const void **)(v3 + 32);
    }
    if (v5 >= v9) {
      size_t v11 = v9;
    }
    else {
      size_t v11 = v5;
    }
    int v12 = memcmp(v10, v6, v11);
    BOOL v13 = v9 < v5;
    if (v12) {
      BOOL v13 = v12 < 0;
    }
    BOOL v14 = !v13;
    if (v13) {
      int v15 = (uint64_t *)(v3 + 8);
    }
    else {
      int v15 = (uint64_t *)v3;
    }
    if (v14) {
      uint64_t v7 = v3;
    }
    uint64_t v3 = *v15;
  }
  while (*v15);
  if (v7 == v2) {
    return v2;
  }
  int v16 = *(char *)(v7 + 55);
  size_t v17 = v16 >= 0 ? *(unsigned __int8 *)(v7 + 55) : *(void *)(v7 + 40);
  uint64_t v18 = v16 >= 0 ? (const void *)(v7 + 32) : *(const void **)(v7 + 32);
  size_t v19 = v17 >= v5 ? v5 : v17;
  int v20 = memcmp(v6, v18, v19);
  BOOL v21 = v5 < v17;
  if (v20) {
    BOOL v21 = v20 < 0;
  }
  if (v21) {
    return v2;
  }
  return v7;
}

void std::vector<int>::resize(std::vector<int> *this, std::vector<int>::size_type __sz)
{
  std::vector<int>::size_type v2 = this->__end_ - this->__begin_;
  BOOL v3 = __sz >= v2;
  std::vector<int>::size_type v4 = __sz - v2;
  if (v4 != 0 && v3)
  {
    std::vector<int>::__append(this, v4);
  }
  else if (!v3)
  {
    this->__end_ = &this->__begin_[__sz];
  }
}

uint64_t MIL::Util::Span<int const,18446744073709551615ul>::operator[](uint64_t a1, unint64_t a2, unint64_t a3)
{
  if (a2 <= a3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::range_error::range_error[abi:ne180100](exception);
    __cxa_throw(exception, (struct type_info *)off_1E4FBE4C0, MEMORY[0x1E4FBA1B8]);
  }
  return a1 + 4 * a3;
}

void sub_180D3BF38(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ShapedType &,mlir::DenseElementsAttr &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t **a4)
{
  v26[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.constant", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v24 = 1283;
    v23[2] = (uint64_t)"mps.constant";
    v23[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v9);
  uint64_t v11 = *a3;
  int v12 = mlir::Attribute::cast<mlir::ElementsAttr>(a4);
  mlir::mps::ConstantOp::build((uint64_t)a1, (uint64_t)v26, v11, v12);
  BOOL v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v26);
  if (!v13)
  {
    int v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v17 = 662;
    uint64_t v18 = "Casting.h";
    size_t v19 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v14 = llvm::DefaultDoCastIfPossible<mlir::mps::ConstantOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ConstantOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    int v16 = "result && \"builder didn't return the right type\"";
    int v17 = 497;
    uint64_t v18 = "Builders.h";
    size_t v19 = "create";
LABEL_8:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v14;
}

void sub_180D3C0D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D3C0F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

BOOL std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if ((*((char *)a1 + 23) & 0x80000000) == 0)
  {
    if (v4 != *((unsigned __int8 *)a1 + 23)) {
      return 0;
    }
    return memcmp(a1, __s, v4) == 0;
  }
  if (v4 == a1[1])
  {
    if (v4 == -1) {
      std::string::__throw_out_of_range[abi:ne180100]();
    }
    a1 = (void *)*a1;
    return memcmp(a1, __s, v4) == 0;
  }
  return 0;
}

uint64_t mlir::OpBuilder::create<mlir::mps::PadOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::mps::PaddingMode>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, unsigned int *a6)
{
  v28[38] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pad", (const unsigned __int8 *)7, Context);
  if (!v14)
  {
    __int16 v26 = 1283;
    v25[2] = (uint64_t)"mps.pad";
    v25[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v28, a2, v13);
  mlir::mps::PadOp::build(a1, (uint64_t)v28, *a3, *a4, *a5, *a6);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v28);
  if (!v15)
  {
    uint64_t v18 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v19 = 662;
    uint64_t v20 = "Casting.h";
    BOOL v21 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v16 = llvm::DefaultDoCastIfPossible<mlir::mps::PadOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PadOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
  if (!v16)
  {
    uint64_t v18 = "result && \"builder didn't return the right type\"";
    int v19 = 497;
    uint64_t v20 = "Builders.h";
    BOOL v21 = "create";
LABEL_8:
    __assert_rtn(v21, v20, v19, v18);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v28);
  return v16;
}

void sub_180D3C32C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D3C344(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void **std::vector<std::string>::~vector[abi:ne180100](void **a1)
{
  std::vector<int>::size_type v2 = (void **)*a1;
  if (*a1)
  {
    BOOL v3 = (void **)a1[1];
    size_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        if (*((char *)v3 - 1) < 0) {
          operator delete(*(v3 - 3));
        }
        v3 -= 3;
      }
      while (v3 != v2);
      size_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t MILToMLIR::CropPattern::matchAndRewrite(MILToMLIR::CropPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  v112[1] = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v111 = 0;
  v112[0] = 0;
  long long v6 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 160))(a2);
  v109[0] = 0;
  v109[1] = 0;
  int v108 = v109;
  int v8 = v6 + 1;
  uint64_t v7 = *v6;
  if (*v6 == (const void **)(v6 + 1)) {
    goto LABEL_46;
  }
  int v102 = (mlir::OpBuilder *)(a3 + 18);
  do
  {
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&v108, (uint64_t *)v109, v7 + 4, (uint64_t)(v7 + 4));
    uint64_t v9 = (const void **)v7[1];
    if (v9)
    {
      do
      {
        char v10 = (const void ***)v9;
        uint64_t v9 = (const void **)*v9;
      }
      while (v9);
    }
    else
    {
      do
      {
        char v10 = (const void ***)v7[2];
        BOOL v11 = *v10 == v7;
        uint64_t v7 = (const void **)v10;
      }
      while (!v11);
    }
    uint64_t v7 = (const void **)v10;
  }
  while (v10 != v8);
  uint64_t v103 = LocationForOp;
  int v12 = v109[0];
  __s2[23] = 11;
  strcpy(__s2, "crop_height");
  if (!v109[0]) {
    goto LABEL_46;
  }
  uint64_t v13 = v109;
  char v14 = v109[0];
  do
  {
    int v15 = v14;
    uint64_t v16 = v13;
    uint64_t v18 = v14 + 32;
    int v17 = (char *)*((void *)v14 + 4);
    unint64_t v19 = v14[55];
    int v20 = (char)v19;
    if ((v19 & 0x80u) != 0) {
      unint64_t v19 = *((void *)v15 + 5);
    }
    if (v20 >= 0) {
      BOOL v21 = v18;
    }
    else {
      BOOL v21 = v17;
    }
    if (v19 >= 0xB) {
      size_t v22 = 11;
    }
    else {
      size_t v22 = v19;
    }
    BOOL v23 = v19 < 0xB;
    int v24 = memcmp(v21, __s2, v22);
    if (v24) {
      BOOL v23 = v24 < 0;
    }
    if (v23) {
      size_t v25 = (char **)(v15 + 8);
    }
    else {
      size_t v25 = (char **)v15;
    }
    if (v23) {
      uint64_t v13 = v16;
    }
    else {
      uint64_t v13 = (char **)v15;
    }
    char v14 = *v25;
  }
  while (v14);
  if (v13 == v109) {
    goto LABEL_46;
  }
  __int16 v26 = (char *)(v16 + 4);
  if (v23) {
    int v27 = v16;
  }
  else {
    int v27 = v15;
  }
  if (!v23) {
    __int16 v26 = v18;
  }
  unint64_t v28 = *((unsigned __int8 *)v13 + 55);
  int v29 = (char)v28;
  unint64_t v31 = (char *)v27[4];
  unint64_t v30 = v27[5];
  if ((v28 & 0x80u) != 0) {
    unint64_t v28 = v30;
  }
  if (v29 >= 0) {
    int v32 = v26;
  }
  else {
    int v32 = v31;
  }
  if (v28 >= 0xB) {
    size_t v33 = 11;
  }
  else {
    size_t v33 = v28;
  }
  BOOL v34 = v28 > 0xB;
  int v35 = memcmp(__s2, v32, v33);
  BOOL v36 = v35 < 0;
  if (!v35) {
    BOOL v36 = v34;
  }
  if (v36)
  {
LABEL_46:
    *(void *)uint64_t __s2 = operator new(0x38uLL);
    *(_OWORD *)&__s2[8] = xmmword_181129E00;
    strcpy(*(char **)__s2, "Could not find parameter with name 'crop_height'.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
LABEL_47:
    if ((__s2[23] & 0x80000000) != 0) {
      operator delete(*(void **)__s2);
    }
    uint64_t v37 = 0;
    goto LABEL_50;
  }
  if (v23) {
    BOOL v39 = v16;
  }
  else {
    BOOL v39 = v15;
  }
  if (v39[8] - v39[7] != 16)
  {
    *(void *)uint64_t __s2 = operator new(0x30uLL);
    *(_OWORD *)&__s2[8] = xmmword_181129DD0;
    strcpy(*(char **)__s2, "Unexpected argument size for 'crop_height'");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
    goto LABEL_47;
  }
  __s2[23] = 10;
  strcpy(__s2, "crop_width");
  uint64_t v40 = v109;
  do
  {
    uint64_t v41 = v12;
    BOOL v42 = v40;
    int v43 = v12 + 32;
    unint64_t v44 = v12[55];
    int v45 = (char)v44;
    if ((v44 & 0x80u) != 0) {
      unint64_t v44 = *((void *)v12 + 5);
    }
    if (v45 >= 0) {
      unint64_t v46 = v12 + 32;
    }
    else {
      unint64_t v46 = (const void *)*((void *)v12 + 4);
    }
    if (v44 >= 0xA) {
      size_t v47 = 10;
    }
    else {
      size_t v47 = v44;
    }
    BOOL v48 = v44 < 0xA;
    int v49 = memcmp(v46, __s2, v47);
    if (v49) {
      BOOL v50 = v49 < 0;
    }
    else {
      BOOL v50 = v48;
    }
    if (v50) {
      long long v51 = (char **)(v41 + 8);
    }
    else {
      long long v51 = (char **)v41;
    }
    if (v50) {
      uint64_t v40 = v42;
    }
    else {
      uint64_t v40 = (char **)v41;
    }
    int v12 = *v51;
  }
  while (*v51);
  if (v40 == v109) {
    goto LABEL_91;
  }
  uint64_t v52 = (char *)(v42 + 4);
  if (v50) {
    BOOL v53 = v42;
  }
  else {
    BOOL v53 = v41;
  }
  if (!v50) {
    uint64_t v52 = v43;
  }
  unint64_t v54 = *((unsigned __int8 *)v40 + 55);
  int v55 = (char)v54;
  uint64_t v57 = (char *)v53[4];
  unint64_t v56 = v53[5];
  if ((v54 & 0x80u) != 0) {
    unint64_t v54 = v56;
  }
  if (v55 >= 0) {
    int v58 = v52;
  }
  else {
    int v58 = v57;
  }
  if (v54 >= 0xA) {
    size_t v59 = 10;
  }
  else {
    size_t v59 = v54;
  }
  BOOL v60 = v54 > 0xA;
  int v61 = memcmp(__s2, v58, v59);
  BOOL v62 = v61 < 0;
  if (!v61) {
    BOOL v62 = v60;
  }
  if (v62)
  {
LABEL_91:
    *(void *)uint64_t __s2 = operator new(0x38uLL);
    *(_OWORD *)&__s2[8] = xmmword_181129DF0;
    strcpy(*(char **)__s2, "Could not find parameter with name 'crop_width'.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
    goto LABEL_47;
  }
  if (v50) {
    unint64_t v63 = v42;
  }
  else {
    unint64_t v63 = v41;
  }
  if (v63[8] - v63[7] != 16)
  {
    *(void *)uint64_t __s2 = operator new(0x30uLL);
    *(_OWORD *)&__s2[8] = xmmword_181129D90;
    strcpy(*(char **)__s2, "Unexpected argument size for 'crop_width'");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
    goto LABEL_47;
  }
  __s2[23] = 11;
  strcpy(__s2, "crop_height");
  Parameteruint64_t Value = MIL::IROperation::TryGetParameterValue();
  if ((__s2[23] & 0x80000000) != 0) {
    operator delete(*(void **)__s2);
  }
  (*(void (**)(uint64_t))(*(void *)ParameterValue + 40))(ParameterValue);
  uint64_t Data = MIL::IRTensorValue::GetDataView<int>();
  if (v66 != 2)
  {
    *(void *)uint64_t __s2 = operator new(0x28uLL);
    *(_OWORD *)&__s2[8] = xmmword_181129DE0;
    strcpy(*(char **)__s2, "Unexpected length for 'crop_height'");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
    goto LABEL_47;
  }
  uint64_t v67 = Data;
  __s2[23] = 10;
  strcpy(__s2, "crop_width");
  uint64_t v68 = MIL::IROperation::TryGetParameterValue();
  if ((__s2[23] & 0x80000000) != 0) {
    operator delete(*(void **)__s2);
  }
  (*(void (**)(uint64_t))(*(void *)v68 + 40))(v68);
  uint64_t v69 = MIL::IRTensorValue::GetDataView<int>();
  if (v70 != 2)
  {
    std::string::basic_string[abi:ne180100]<0>(__s2, "Unexpected length for 'crop_width'");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
    goto LABEL_47;
  }
  uint64_t v71 = v69;
  LODWORD(v112[0]) = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v69, 2uLL, 0);
  HIDWORD(v112[0]) = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v67, 2uLL, 0);
  LODWORD(v111) = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v71, 2uLL, 1uLL);
  HIDWORD(v111) = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v67, 2uLL, 1uLL);
  *(void *)uint64_t __s2 = *(void *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8;
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)__s2);
  uint64_t v73 = mlir::IntegerType::get(Context, 0x20u, 1u);
  uint64_t v74 = (uint64_t **)mlir::RankedTensorType::get(0, 0, v73, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v74))
  {
    unint64_t v76 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v77 = 566;
    int v78 = "Casting.h";
    uint64_t v79 = "cast";
LABEL_132:
    __assert_rtn(v79, v78, v77, v76);
  }
  if (v74)
  {
    uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v74);
    if (!InterfaceFor)
    {
      unint64_t v76 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v77 = 98;
      int v78 = "InterfaceSupport.h";
      uint64_t v79 = "Interface";
      goto LABEL_132;
    }
  }
  else
  {
    uint64_t InterfaceFor = 0;
  }
  LODWORD(v105) = -1;
  uint64_t v80 = mlir::DenseElementsAttr::getFromRawBuffer(v74, InterfaceFor, &v105, 4, 4, 1, 1);
  if (!mlir::DenseIntElementsAttr::classof(v80))
  {
    int v94 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v95 = 566;
    int v96 = "Casting.h";
    unint64_t v97 = "cast";
    goto LABEL_135;
  }
  *(void *)uint64_t __s2 = v80;
  v81 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v102, v103, (uint64_t **)__s2);
  if (!*((_DWORD *)v81 + 9))
  {
    int v94 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    int v95 = 984;
    int v96 = "Operation.h";
    unint64_t v97 = "getOpResultImpl";
LABEL_135:
    __assert_rtn(v97, v96, v95, v94);
  }
  uint64_t v106 = (uint64_t)v81 - 16;
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v74))
  {
    v83 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v84 = 566;
    v85 = "Casting.h";
    unint64_t v86 = "cast";
LABEL_137:
    __assert_rtn(v86, v85, v84, v83);
  }
  if (v74)
  {
    uint64_t v82 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v74);
    if (!v82)
    {
      v83 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v84 = 98;
      v85 = "InterfaceSupport.h";
      unint64_t v86 = "Interface";
      goto LABEL_137;
    }
  }
  else
  {
    uint64_t v82 = 0;
  }
  LODWORD(v104) = -2;
  uint64_t v87 = mlir::DenseElementsAttr::getFromRawBuffer(v74, v82, &v104, 4, 4, 1, 1);
  if (!mlir::DenseIntElementsAttr::classof(v87))
  {
    size_t v98 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v99 = 566;
    size_t v100 = "Casting.h";
    BOOL v101 = "cast";
    goto LABEL_140;
  }
  *(void *)uint64_t __s2 = v87;
  int v88 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v102, v103, (uint64_t **)__s2);
  if (!*((_DWORD *)v88 + 9))
  {
    size_t v98 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    int v99 = 984;
    size_t v100 = "Operation.h";
    BOOL v101 = "getOpResultImpl";
LABEL_140:
    __assert_rtn(v101, v100, v99, v98);
  }
  uint64_t v105 = (uint64_t)v88 - 16;
  uint64_t v89 = mlir::OpBuilder::create<mlir::mps::CropOp,mlir::Value &,mlir::Value &,int &,int &>(v102, v103, &ArgValue, &v106, (unsigned int *)v112, (unsigned int *)&v111);
  if (!*(_DWORD *)(v89 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v104 = v89 - 16;
  uint64_t v90 = mlir::OpBuilder::create<mlir::mps::CropOp,mlir::Value &,mlir::Value &,int &,int &>(v102, v103, &v104, &v105, (unsigned int *)v112 + 1, (unsigned int *)&v111 + 1);
  if (!*(_DWORD *)(v90 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  (*(void (**)(unsigned char *__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(__s2, a2);
  MILToMLIRRewriter::setValue((uint64_t)a3, *(long long **)__s2, v90 - 16);
  uint64_t v91 = *(void *)__s2;
  if (*(void *)__s2)
  {
    uint64_t v92 = *(void *)&__s2[8];
    v93 = *(void **)__s2;
    if (*(void *)&__s2[8] != *(void *)__s2)
    {
      do
      {
        if (*(char *)(v92 - 1) < 0) {
          operator delete(*(void **)(v92 - 24));
        }
        v92 -= 24;
      }
      while (v92 != v91);
      v93 = *(void **)__s2;
    }
    *(void *)&__s2[8] = v91;
    operator delete(v93);
  }
  uint64_t v37 = 1;
LABEL_50:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v108, v109[0]);
  return v37;
}

void sub_180D3CD8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, char a18, char *a19)
{
}

void sub_180D3CDAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,char *a22)
{
}

uint64_t mlir::DenseIntElementsAttr::get<int>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = mlir::DenseElementsAttr::getFromRawBuffer(a1, a2, a3, 4, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof(v3) & 1) == 0) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  return v3;
}

uint64_t mlir::OpBuilder::create<mlir::mps::CropOp,mlir::Value &,mlir::Value &,int &,int &>(mlir::mps::ConstantOp *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned int *a5, unsigned int *a6)
{
  v28[38] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.crop", (const unsigned __int8 *)8, Context);
  if (!v14)
  {
    __int16 v26 = 1283;
    v25[2] = (uint64_t)"mps.crop";
    v25[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v28, a2, v13);
  mlir::mps::CropOp::build(a1, v28, *a3, *a4, *a5, *a6);
  int v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v28);
  if (!v15)
  {
    uint64_t v18 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v19 = 662;
    int v20 = "Casting.h";
    BOOL v21 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v16 = llvm::DefaultDoCastIfPossible<mlir::mps::CropOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CropOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
  if (!v16)
  {
    uint64_t v18 = "result && \"builder didn't return the right type\"";
    int v19 = 497;
    int v20 = "Builders.h";
    BOOL v21 = "create";
LABEL_8:
    __assert_rtn(v21, v20, v19, v18);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v28);
  return v16;
}

void sub_180D3D044(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D3D05C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t MILToMLIR::UpsampleBilinearPattern::matchAndRewrite(MILToMLIR::UpsampleBilinearPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v110 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  long long v6 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 160))(a2);
  v105[1] = 0;
  v105[0] = 0;
  uint64_t v104 = v105;
  int v8 = v6 + 1;
  uint64_t v7 = *v6;
  if (*v6 == (const void **)(v6 + 1)) {
    goto LABEL_43;
  }
  char v106 = 0;
  do
  {
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&v104, (uint64_t *)v105, v7 + 4, (uint64_t)(v7 + 4));
    uint64_t v9 = (const void **)v7[1];
    if (v9)
    {
      do
      {
        char v10 = (const void ***)v9;
        uint64_t v9 = (const void **)*v9;
      }
      while (v9);
    }
    else
    {
      do
      {
        char v10 = (const void ***)v7[2];
        BOOL v11 = *v10 == v7;
        uint64_t v7 = (const void **)v10;
      }
      while (!v11);
    }
    uint64_t v7 = (const void **)v10;
  }
  while (v10 != v8);
  uint64_t v80 = (mlir::OpBuilder *)(a3 + 18);
  uint64_t v81 = LocationForOp;
  int v12 = v105[0];
  __s2[23] = 13;
  strcpy(__s2, "align_corners");
  if (!v105[0]) {
    goto LABEL_43;
  }
  uint64_t v13 = v105;
  do
  {
    char v14 = v12;
    int v15 = v13;
    int v17 = v12 + 32;
    uint64_t v16 = (char *)*((void *)v12 + 4);
    unint64_t v18 = v14[55];
    int v19 = (char)v18;
    if ((v18 & 0x80u) != 0) {
      unint64_t v18 = *((void *)v14 + 5);
    }
    if (v19 >= 0) {
      int v20 = v17;
    }
    else {
      int v20 = v16;
    }
    if (v18 >= 0xD) {
      size_t v21 = 13;
    }
    else {
      size_t v21 = v18;
    }
    BOOL v22 = v18 < 0xD;
    int v23 = memcmp(v20, __s2, v21);
    if (v23) {
      BOOL v22 = v23 < 0;
    }
    __int16 v24 = (char **)(v14 + 8);
    if (v22)
    {
      uint64_t v13 = v15;
    }
    else
    {
      __int16 v24 = (char **)v14;
      uint64_t v13 = (char **)v14;
    }
    int v12 = *v24;
  }
  while (v12);
  if (v13 == v105) {
    goto LABEL_43;
  }
  size_t v25 = (char *)(v15 + 4);
  if (v22) {
    __int16 v26 = v15;
  }
  else {
    __int16 v26 = v14;
  }
  if (!v22) {
    size_t v25 = v17;
  }
  unint64_t v27 = *((unsigned __int8 *)v13 + 55);
  int v28 = (char)v27;
  unint64_t v30 = (char *)v26[4];
  unint64_t v29 = v26[5];
  if ((v27 & 0x80u) != 0) {
    unint64_t v27 = v29;
  }
  if (v28 >= 0) {
    unint64_t v31 = v25;
  }
  else {
    unint64_t v31 = v30;
  }
  if (v27 >= 0xD) {
    size_t v32 = 13;
  }
  else {
    size_t v32 = v27;
  }
  BOOL v33 = v27 > 0xD;
  int v34 = memcmp(__s2, v31, v32);
  BOOL v35 = v34 < 0;
  if (!v34) {
    BOOL v35 = v33;
  }
  if (v35)
  {
LABEL_43:
    *(void *)uint64_t __s2 = operator new(0x38uLL);
    *(_OWORD *)&__s2[8] = xmmword_181129E20;
    strcpy(*(char **)__s2, "Could not find parameter with name 'align_corners'.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
LABEL_44:
    if ((__s2[23] & 0x80000000) != 0) {
      operator delete(*(void **)__s2);
    }
    uint64_t v36 = 0;
    goto LABEL_47;
  }
  if (v22) {
    int v38 = v15;
  }
  else {
    int v38 = v14;
  }
  if (v38[8] - v38[7] != 16)
  {
    *(void *)uint64_t __s2 = operator new(0x30uLL);
    *(_OWORD *)&__s2[8] = xmmword_181129E10;
    strcpy(*(char **)__s2, "Unexpected argument size for 'align_corners'");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
    goto LABEL_44;
  }
  __s2[23] = 13;
  strcpy(__s2, "align_corners");
  MIL::IROperation::GetParameterValue();
  if ((__s2[23] & 0x80000000) != 0) {
    operator delete(*(void **)__s2);
  }
  char v106 = MIL::IRValue::GetScalar<BOOL>();
  __s2[23] = 1;
  strcpy(__s2, "x");
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  if ((__s2[23] & 0x80000000) != 0) {
    operator delete(*(void **)__s2);
  }
  uint64_t v40 = MIL::IRValueType::AsTensorType(ParameterType);
  uint64_t v41 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v40 + 96))(v40);
  unint64_t v42 = v41[1] - *v41;
  if (v42 <= 0xF)
  {
    *(void *)uint64_t __s2 = operator new(0x30uLL);
    *(_OWORD *)&__s2[8] = xmmword_181129D90;
    strcpy(*(char **)__s2, "upsample_bilinear rank < 2 not supported.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
    goto LABEL_44;
  }
  if (v42 >= 0x21)
  {
    *(void *)uint64_t __s2 = operator new(0x30uLL);
    *(_OWORD *)&__s2[8] = xmmword_181129D90;
    strcpy(*(char **)__s2, "upsample_bilinear rank > 4 not supported.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
    goto LABEL_44;
  }
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) != 1)
  {
    *(void *)uint64_t __s2 = operator new(0x40uLL);
    *(_OWORD *)&__s2[8] = xmmword_181129DA0;
    strcpy(*(char **)__s2, "The number of outputs does not match the number of results.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
    goto LABEL_44;
  }
  int v43 = mlir::OpBuilder::create<mlir::mps::ShapeOp,mlir::Value>(v80, v81, &ArgValue);
  if (!*((_DWORD *)v43 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v102 = (uint64_t)v43 - 16;
  unsigned int v101 = -1;
  unsigned int v100 = 1;
  *(_DWORD *)uint64_t __s2 = -1;
  uint64_t v44 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int &,int,int &>(v80, v81, &v102, &v101, (unsigned int *)__s2, &v100);
  if (!*(_DWORD *)(v44 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v99 = v44 - 16;
  *(_DWORD *)uint64_t __s2 = -2;
  uint64_t v45 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int &,int,int &>(v80, v81, &v102, &v101, (unsigned int *)__s2, &v100);
  if (!*(_DWORD *)(v45 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v98 = v45 - 16;
  *(void *)uint64_t __s2 = *(void *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8;
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)__s2);
  uint64_t v47 = mlir::IntegerType::get(Context, 0x20u, 1u);
  BOOL v48 = (uint64_t **)mlir::RankedTensorType::get(0, 0, v47, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v48))
  {
    BOOL v50 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v51 = 566;
    uint64_t v52 = "Casting.h";
    BOOL v53 = "cast";
LABEL_107:
    __assert_rtn(v53, v52, v51, v50);
  }
  if (v48)
  {
    uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v48);
    if (!InterfaceFor)
    {
      BOOL v50 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v51 = 98;
      uint64_t v52 = "InterfaceSupport.h";
      BOOL v53 = "Interface";
      goto LABEL_107;
    }
  }
  else
  {
    uint64_t InterfaceFor = 0;
  }
  LODWORD(v108[0]) = -1;
  uint64_t v54 = mlir::DenseElementsAttr::getFromRawBuffer(v48, InterfaceFor, v108, 4, 4, 1, 1);
  if (!mlir::DenseIntElementsAttr::classof(v54))
  {
    unint64_t v76 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v77 = 566;
    int v78 = "Casting.h";
    uint64_t v79 = "cast";
    goto LABEL_110;
  }
  *(void *)uint64_t __s2 = v54;
  int v55 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v80, v81, (uint64_t **)__s2);
  if (!*((_DWORD *)v55 + 9))
  {
    unint64_t v76 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    int v77 = 984;
    int v78 = "Operation.h";
    uint64_t v79 = "getOpResultImpl";
LABEL_110:
    __assert_rtn(v79, v78, v77, v76);
  }
  uint64_t v97 = (uint64_t)v55 - 16;
  unsigned int v95 = 2;
  unsigned int v96 = 0;
  uint64_t v56 = mlir::OpBuilder::create<mlir::mps::CropOp,mlir::Value &,mlir::Value &,unsigned int &,unsigned int &>(v80, v81, &v102, &v97, &v96, &v95);
  if (!*(_DWORD *)(v56 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  __s2[23] = 19;
  strcpy(__s2, "scale_factor_height");
  Parameteruint64_t Value = MIL::IROperation::GetParameterValue();
  if ((__s2[23] & 0x80000000) != 0) {
    operator delete(*(void **)__s2);
  }
  int v58 = (float *)MEMORY[0x1852FD7D0](ParameterValue);
  if (v58)
  {
    float v59 = *v58;
  }
  else
  {
    BOOL v60 = (int *)MEMORY[0x1852FD7E0](ParameterValue);
    if (v60)
    {
      float v59 = (float)*v60;
    }
    else
    {
      int v61 = (MIL::Fp16 *)MEMORY[0x1852FD7C0](ParameterValue);
      if (!v61)
      {
        std::string::basic_string[abi:ne180100]<0>(__s2, "unexpected type for scale_factor_height");
        MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
        goto LABEL_44;
      }
      MIL::Fp16::GetFloat(v61);
      float v59 = v62;
    }
  }
  __s2[23] = 18;
  strcpy(__s2, "scale_factor_width");
  uint64_t v63 = MIL::IROperation::GetParameterValue();
  if ((__s2[23] & 0x80000000) != 0) {
    operator delete(*(void **)__s2);
  }
  unint64_t v64 = (float *)MEMORY[0x1852FD7D0](v63);
  if (v64)
  {
    float v65 = *v64;
  }
  else
  {
    uint64_t v66 = (int *)MEMORY[0x1852FD7E0](v63);
    if (v66)
    {
      float v65 = (float)*v66;
    }
    else
    {
      uint64_t v67 = (MIL::Fp16 *)MEMORY[0x1852FD7C0](v63);
      if (!v67)
      {
        std::string::basic_string[abi:ne180100]<0>(__s2, "unexpected type for scale_factor_width");
        MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
        goto LABEL_44;
      }
      MIL::Fp16::GetFloat(v67);
      float v65 = v68;
    }
  }
  *(void *)uint64_t __s2 = *(void *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8;
  uint64_t v69 = (mlir::Float32Type *)mlir::Attribute::getContext((mlir::Attribute *)__s2);
  uint64_t v94 = mlir::Float32Type::get(v69, v70);
  *(void *)uint64_t __s2 = 1;
  uint64_t v71 = (void *)mlir::RankedTensorType::get((uint64_t)__s2, 1, v94, 0);
  uint64_t ConstantOpFromScalar = createConstantOpFromScalar(v80, v81, v71, v65);
  uint64_t v92 = createConstantOpFromScalar(v80, v81, v71, v59);
  uint64_t v91 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::FloatType &>((mlir::UnknownLoc **)v80, v81, &v99, &v94);
  uint64_t v90 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::FloatType &>((mlir::UnknownLoc **)v80, v81, &v98, &v94);
  uint64_t v89 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::CastOp &,mlir::Value &>((mlir::Float32Type **)v80, v81, (uint64_t)&v91, &ConstantOpFromScalar);
  uint64_t v88 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::CastOp &,mlir::Value &>((mlir::Float32Type **)v80, v81, (uint64_t)&v90, &v92);
  uint64_t v87 = mlir::IntegerType::get(*(void *)v80, 0x20u, 1u);
  uint64_t v86 = mlir::OpBuilder::create<mlir::mps::FloorOp,mlir::mps::MultiplyOp &>(v80, v81, (uint64_t)&v89);
  uint64_t v85 = mlir::OpBuilder::create<mlir::mps::FloorOp,mlir::mps::MultiplyOp &>(v80, v81, (uint64_t)&v88);
  uint64_t v72 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::mps::FloorOp &,mlir::IntegerType &>((mlir::UnknownLoc **)v80, v81, (uint64_t)&v86, &v87);
  uint64_t v73 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::mps::FloorOp &,mlir::IntegerType &>((mlir::UnknownLoc **)v80, v81, (uint64_t)&v85, &v87);
  v108[0] = (void *)(v56 - 16);
  if (!*(_DWORD *)(v73 + 36) || (v108[1] = (void *)(v73 - 16), !*(_DWORD *)(v72 + 36))) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v109 = v72 - 16;
  std::vector<mlir::Value>::vector[abi:ne180100](__s2, v108, 3uLL);
  LOBYTE(v108[0]) = 0;
  uint64_t v84 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>((mlir::UnitAttr **)v80, v81, (uint64_t *)__s2, &v97, (unsigned __int8 *)v108);
  unsigned int v83 = 1;
  unsigned __int8 v82 = 1;
  std::string::basic_string[abi:ne180100]<0>(v108, "half_pixel_centers");
  uint64_t v74 = MIL::IROperation::TryGetParameterValue();
  if (SHIBYTE(v109) < 0) {
    operator delete(v108[0]);
  }
  if (v74) {
    unsigned __int8 v82 = MIL::IRValue::GetScalar<BOOL>();
  }
  uint64_t v75 = mlir::OpBuilder::create<mlir::mps::ResizeOp,mlir::Value &,mlir::mps::ConcatOp &,decltype(nullptr),decltype(nullptr),mlir::mps::SamplingMode &,BOOL &,BOOL &,decltype(nullptr)>((mlir::UnitAttr **)v80, v81, &ArgValue, (uint64_t)&v84, &v83, &v82, &v106);
  if (!*(_DWORD *)(v75 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(v108, a2);
  MILToMLIRRewriter::setValue((uint64_t)a3, (long long *)v108[0], v75 - 16);
  std::vector<std::string>::~vector[abi:ne180100](v108);
  if (*(void *)__s2)
  {
    *(void *)&__s2[8] = *(void *)__s2;
    operator delete(*(void **)__s2);
  }
  uint64_t v36 = 1;
LABEL_47:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v104, v105[0]);
  return v36;
}

void sub_180D3DBF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35,char *a36)
{
  if (a34 < 0) {
    operator delete(a29);
  }
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a35, a36);
  _Unwind_Resume(a1);
}

void sub_180D3DD3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a32, *(char **)(v32 + 44));
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int &,int,int &>(mlir::mps::ConstantOp *a1, uint64_t a2, uint64_t *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6)
{
  v28[38] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.slice", (const unsigned __int8 *)9, Context);
  if (!v14)
  {
    __int16 v26 = 1283;
    v25[2] = (uint64_t)"mps.slice";
    v25[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v28, a2, v13);
  mlir::mps::SliceOp::build(a1, v28, *a3, *a4, *a5, *a6);
  int v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v28);
  if (!v15)
  {
    unint64_t v18 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v19 = 662;
    int v20 = "Casting.h";
    size_t v21 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v16 = llvm::DefaultDoCastIfPossible<mlir::mps::SliceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SliceOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
  if (!v16)
  {
    unint64_t v18 = "result && \"builder didn't return the right type\"";
    int v19 = 497;
    int v20 = "Builders.h";
    size_t v21 = "create";
LABEL_8:
    __assert_rtn(v21, v20, v19, v18);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v28);
  return v16;
}

void sub_180D3DEE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D3DF00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::CropOp,mlir::Value &,mlir::Value &,unsigned int &,unsigned int &>(mlir::mps::ConstantOp *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned int *a5, unsigned int *a6)
{
  v28[38] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.crop", (const unsigned __int8 *)8, Context);
  if (!v14)
  {
    __int16 v26 = 1283;
    v25[2] = (uint64_t)"mps.crop";
    v25[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v28, a2, v13);
  mlir::mps::CropOp::build(a1, v28, *a3, *a4, *a5, *a6);
  int v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v28);
  if (!v15)
  {
    unint64_t v18 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v19 = 662;
    int v20 = "Casting.h";
    size_t v21 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v16 = llvm::DefaultDoCastIfPossible<mlir::mps::CropOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CropOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
  if (!v16)
  {
    unint64_t v18 = "result && \"builder didn't return the right type\"";
    int v19 = 497;
    int v20 = "Builders.h";
    size_t v21 = "create";
LABEL_8:
    __assert_rtn(v21, v20, v19, v18);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v28);
  return v16;
}

void sub_180D3E0A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D3E0C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::FloatType &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v24[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.cast";
    v21[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  mlir::mps::CastOp::build(a1, (uint64_t)v24, *a3, *a4);
  BOOL v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    char v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v15 = 662;
    uint64_t v16 = "Casting.h";
    int v17 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::CastOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CastOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    char v14 = "result && \"builder didn't return the right type\"";
    int v15 = 497;
    uint64_t v16 = "Builders.h";
    int v17 = "create";
LABEL_8:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180D3E250(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D3E268(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::CastOp &,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  v24[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.multiply";
    v21[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(void *)a3 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *(void *)a3 - 16, *a4);
  BOOL v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    char v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v15 = 662;
    uint64_t v16 = "Casting.h";
    int v17 = "dyn_cast";
    goto LABEL_10;
  }
  uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    char v14 = "result && \"builder didn't return the right type\"";
    int v15 = 497;
    uint64_t v16 = "Builders.h";
    int v17 = "create";
LABEL_10:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180D3E428(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D3E440(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::FloorOp,mlir::mps::MultiplyOp &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.floor", (const unsigned __int8 *)9, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.floor";
    v19[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  if (!*(_DWORD *)(*(void *)a3 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *(void *)a3 - 16);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    char v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_10;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::FloorOp,mlir::Operation *,llvm::CastInfo<mlir::mps::FloorOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    char v14 = "Builders.h";
    int v15 = "create";
LABEL_10:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180D3E5F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D3E610(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::CastOp,mlir::mps::FloorOp &,mlir::IntegerType &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  v24[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.cast";
    v21[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(void *)a3 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::CastOp::build(a1, (uint64_t)v24, *(void *)a3 - 16, *a4);
  BOOL v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    char v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v15 = 662;
    uint64_t v16 = "Casting.h";
    int v17 = "dyn_cast";
    goto LABEL_10;
  }
  uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::CastOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CastOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    char v14 = "result && \"builder didn't return the right type\"";
    int v15 = 497;
    uint64_t v16 = "Builders.h";
    int v17 = "create";
LABEL_10:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180D3E7D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D3E7E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void *std::vector<mlir::Value>::vector[abi:ne180100](void *a1, const void *a2, unint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3)
  {
    if (a3 >> 61) {
      std::vector<long>::__throw_length_error[abi:ne180100]();
    }
    size_t v5 = 8 * a3;
    long long v6 = (char *)operator new(8 * a3);
    *a1 = v6;
    a1[1] = v6;
    uint64_t v7 = &v6[v5];
    a1[2] = &v6[v5];
    memmove(v6, a2, v5);
    a1[1] = v7;
  }
  return a1;
}

void sub_180D3E874(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned __int8 *a5)
{
  v27[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.concat", (const unsigned __int8 *)0xA, Context);
  if (!v12)
  {
    __int16 v24 = 1283;
    v23[2] = (uint64_t)"mps.concat";
    v23[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v27, a2, v11);
  mlir::ValueRange::ValueRange(v26, *a3, (a3[1] - *a3) >> 3);
  mlir::mps::ConcatOp::build(a1, (uint64_t)v27, v26[0], v26[1], *a4, *a5);
  int v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v27);
  if (!v13)
  {
    uint64_t v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v17 = 662;
    uint64_t v18 = "Casting.h";
    int v19 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v14 = llvm::DefaultDoCastIfPossible<mlir::mps::ConcatOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ConcatOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    uint64_t v16 = "result && \"builder didn't return the right type\"";
    int v17 = 497;
    uint64_t v18 = "Builders.h";
    int v19 = "create";
LABEL_8:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v27);
  return v14;
}

void sub_180D3EA30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
}

void sub_180D3EA48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::ResizeOp,mlir::Value &,mlir::mps::ConcatOp &,decltype(nullptr),decltype(nullptr),mlir::mps::SamplingMode &,BOOL &,BOOL &,decltype(nullptr)>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t a4, unsigned int *a5, unsigned __int8 *a6, char *a7)
{
  v30[38] = *MEMORY[0x1E4F143B8];
  uint64_t v24 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  uint64_t v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.resize", (const unsigned __int8 *)0xA, Context);
  if (!v16)
  {
    __int16 v28 = 1283;
    v27[2] = (uint64_t)"mps.resize";
    v27[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v15);
  if (!*(_DWORD *)(*(void *)a4 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ResizeOp::build(a1, (uint64_t)v30, *a3, *(void *)a4 - 16, 0, 0, *a5, *a6, *a7, 0);
  int v17 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v30);
  if (!v17)
  {
    uint64_t v20 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v21 = 662;
    __int16 v22 = "Casting.h";
    int v23 = "dyn_cast";
    goto LABEL_10;
  }
  uint64_t v18 = llvm::DefaultDoCastIfPossible<mlir::mps::ResizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ResizeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v17);
  if (!v18)
  {
    uint64_t v20 = "result && \"builder didn't return the right type\"";
    int v21 = 497;
    __int16 v22 = "Builders.h";
    int v23 = "create";
LABEL_10:
    __assert_rtn(v23, v22, v21, v20);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v18;
}

void sub_180D3EC40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
}

void sub_180D3EC58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
}

uint64_t MILToMLIR::ResizePattern::matchAndRewrite(MILToMLIR::ResizePattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v7 = (void *)((char *)this + 8);
  int v8 = *((char *)this + 31);
  if (v8 < 0)
  {
    if (*((void *)this + 2) != 15)
    {
LABEL_12:
      unsigned int v12 = 0;
      goto LABEL_13;
    }
    uint64_t v7 = (void *)*v7;
  }
  else if (v8 != 15)
  {
    goto LABEL_12;
  }
  uint64_t v9 = (void *)*v7;
  uint64_t v10 = *(void *)((char *)v7 + 7);
  BOOL v11 = v9 == (void *)0x625F657A69736572 && v10 == 0x7261656E696C6962;
  unsigned int v12 = v11;
LABEL_13:
  __int16 v109 = 1;
  int v13 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 160))(a2);
  v108[0] = 0;
  v108[1] = 0;
  unint64_t v107 = v108;
  uint64_t v15 = v13 + 1;
  uint64_t v14 = *v13;
  if (*v13 != (const void **)(v13 + 1))
  {
    do
    {
      std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&v107, (uint64_t *)v108, v14 + 4, (uint64_t)(v14 + 4));
      uint64_t v41 = (const void **)v14[1];
      if (v41)
      {
        do
        {
          unint64_t v42 = (const void ***)v41;
          uint64_t v41 = (const void **)*v41;
        }
        while (v41);
      }
      else
      {
        do
        {
          unint64_t v42 = (const void ***)v14[2];
          BOOL v11 = *v42 == v14;
          uint64_t v14 = (const void **)v42;
        }
        while (!v11);
      }
      uint64_t v14 = (const void **)v42;
    }
    while (v42 != v15);
  }
  if (!v12) {
    goto LABEL_131;
  }
  unsigned int v96 = v12;
  HIBYTE(__s2[2]) = 13;
  strcpy((char *)__s2, "sampling_mode");
  char v16 = v108[0];
  if (!v108[0]) {
    goto LABEL_51;
  }
  int v17 = v108;
  do
  {
    uint64_t v18 = v16;
    int v19 = v17;
    int v21 = v16 + 32;
    uint64_t v20 = (char *)*((void *)v16 + 4);
    unint64_t v22 = v16[55];
    int v23 = (char)v22;
    if ((v22 & 0x80u) != 0) {
      unint64_t v22 = *((void *)v18 + 5);
    }
    if (v23 >= 0) {
      uint64_t v24 = v21;
    }
    else {
      uint64_t v24 = v20;
    }
    if (v22 >= 0xD) {
      size_t v25 = 13;
    }
    else {
      size_t v25 = v22;
    }
    BOOL v26 = v22 < 0xD;
    int v27 = memcmp(v24, __s2, v25);
    if (v27) {
      BOOL v26 = v27 < 0;
    }
    if (v26) {
      __int16 v28 = (char **)(v18 + 8);
    }
    else {
      __int16 v28 = (char **)v18;
    }
    if (v26) {
      int v17 = v19;
    }
    else {
      int v17 = (char **)v18;
    }
    char v16 = *v28;
  }
  while (v16);
  if (v17 == v108) {
    goto LABEL_51;
  }
  unint64_t v29 = (char *)(v19 + 4);
  if (v26) {
    unint64_t v30 = v19;
  }
  else {
    unint64_t v30 = v18;
  }
  if (!v26) {
    unint64_t v29 = v21;
  }
  unint64_t v31 = *((unsigned __int8 *)v17 + 55);
  int v32 = (char)v31;
  int v34 = (char *)v30[4];
  unint64_t v33 = v30[5];
  if ((v31 & 0x80u) != 0) {
    unint64_t v31 = v33;
  }
  if (v32 >= 0) {
    BOOL v35 = v29;
  }
  else {
    BOOL v35 = v34;
  }
  if (v31 >= 0xD) {
    size_t v36 = 13;
  }
  else {
    size_t v36 = v31;
  }
  BOOL v37 = v31 > 0xD;
  int v38 = memcmp(__s2, v35, v36);
  BOOL v39 = v38 < 0;
  if (!v38) {
    BOOL v39 = v37;
  }
  if (v39)
  {
LABEL_51:
    __s2[0] = (char *)operator new(0x38uLL);
    *(_OWORD *)&__s2[1] = xmmword_181129E20;
    strcpy(__s2[0], "Could not find parameter with name 'sampling_mode'.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__s2);
    goto LABEL_52;
  }
  if (v26) {
    int v43 = v19;
  }
  else {
    int v43 = v18;
  }
  if (v43[8] - v43[7] != 16)
  {
    __s2[0] = (char *)operator new(0x30uLL);
    *(_OWORD *)&__s2[1] = xmmword_181129E10;
    strcpy(__s2[0], "Unexpected argument size for 'sampling_mode'");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__s2);
LABEL_52:
    if (SHIBYTE(__s2[2]) < 0) {
      operator delete(__s2[0]);
    }
LABEL_54:
    uint64_t v40 = 0;
    goto LABEL_153;
  }
  __p[23] = 13;
  strcpy(__p, "sampling_mode");
  MIL::IROperation::GetParameterValue();
  MIL::IRValue::GetScalar<std::string>();
  unsigned int v12 = v96;
  int v44 = HIBYTE(__s2[2]);
  if ((HIBYTE(__s2[2]) & 0x80) != 0)
  {
    if (__s2[1] != (char *)7)
    {
      if (__s2[1] == (char *)13)
      {
        if (*(void *)__s2[0] != 0x4F435F4E47494C41 || *(void *)(__s2[0] + 5) != 0x5352454E524F435FLL) {
          goto LABEL_110;
        }
      }
      else
      {
        if (__s2[1] != (char *)20) {
          goto LABEL_110;
        }
        BOOL v47 = *(void *)__s2[0] == 0x415F544349525453 && *((void *)__s2[0] + 1) == 0x524F435F4E47494CLL;
        if (!v47 || *((_DWORD *)__s2[0] + 4) != 1397900622) {
          goto LABEL_110;
        }
      }
      goto LABEL_104;
    }
    BOOL v50 = (char **)__s2[0];
LABEL_106:
    int v52 = *(_DWORD *)v50;
    int v53 = *(_DWORD *)((char *)v50 + 3);
    if (v52 == 1095124292 && v53 == 1414288705)
    {
      __int16 v109 = 0;
      goto LABEL_114;
    }
    goto LABEL_110;
  }
  switch(HIBYTE(__s2[2]))
  {
    case 7u:
      BOOL v50 = __s2;
      goto LABEL_106;
    case 0xDu:
      if (__s2[0] != (char *)0x4F435F4E47494C41 || *(char **)((char *)__s2 + 5) != (char *)0x5352454E524F435FLL) {
        break;
      }
LABEL_104:
      __int16 v109 = 257;
      goto LABEL_114;
    case 0x14u:
      BOOL v45 = __s2[0] == (char *)0x415F544349525453 && __s2[1] == (char *)0x524F435F4E47494CLL;
      if (v45 && LODWORD(__s2[2]) == 1397900622) {
        goto LABEL_104;
      }
      break;
  }
LABEL_110:
  if (!std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(__s2, "OFFSET_CORNERS"))
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "Unexpected value for 'sampling_mode'");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __p);
    goto LABEL_125;
  }
  __int16 v109 = 1;
  int v44 = HIBYTE(__s2[2]);
LABEL_114:
  if ((v44 & 0x80) != 0)
  {
    if (__s2[1] != (char *)14)
    {
LABEL_123:
      char v59 = 1;
      goto LABEL_128;
    }
    int v55 = (char **)__s2[0];
  }
  else
  {
    if (v44 != 14) {
      goto LABEL_131;
    }
    int v55 = __s2;
  }
  uint64_t v56 = *v55;
  uint64_t v57 = *(uint64_t *)((char *)v55 + 6);
  if (v56 != (char *)0x435F54455346464FLL || v57 != 0x5352454E524F435FLL) {
    goto LABEL_123;
  }
  *(void *)__p = operator new(0x38uLL);
  *(_OWORD *)&__p[8] = xmmword_181129E20;
  strcpy(*(char **)__p, "OFFSET_CORNERS not yet supported in resize_bilinear");
  MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __p);
LABEL_125:
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  char v59 = 0;
LABEL_128:
  if (SHIBYTE(__s2[2]) < 0) {
    operator delete(__s2[0]);
  }
  if ((v59 & 1) == 0) {
    goto LABEL_54;
  }
LABEL_131:
  HIBYTE(__s2[2]) = 1;
  strcpy((char *)__s2, "x");
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  if (SHIBYTE(__s2[2]) < 0) {
    operator delete(__s2[0]);
  }
  uint64_t v61 = MIL::IRValueType::AsTensorType(ParameterType);
  uint64_t v62 = (*(uint64_t (**)(uint64_t))(*(void *)v61 + 96))(v61);
  memset(__s2, 0, sizeof(__s2));
  unint64_t v64 = *(const void **)v62;
  uint64_t v63 = *(void *)(v62 + 8);
  int64_t v65 = v63 - *(void *)v62;
  if (v63 == *(void *)v62)
  {
    uint64_t v66 = 0;
LABEL_136:
    *(void *)__p = operator new(0x28uLL);
    *(_OWORD *)&__p[8] = xmmword_1811286F0;
    strcpy(*(char **)__p, "resize_bilinear rank < 2 not supported.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __p);
    goto LABEL_149;
  }
  if (v65 < 0) {
    std::vector<int>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v66 = (char *)operator new(v63 - *(void *)v62);
  __s2[0] = v66;
  __s2[2] = &v66[8 * (v65 >> 3)];
  memcpy(v66, v64, v65);
  __s2[1] = &v66[8 * (v65 >> 3)];
  uint64_t v67 = 8 * (v65 >> 3);
  if ((unint64_t)v67 <= 0x17) {
    goto LABEL_136;
  }
  if ((unint64_t)v67 >= 0x21)
  {
    *(void *)__p = operator new(0x28uLL);
    *(_OWORD *)&__p[8] = xmmword_1811286F0;
    strcpy(*(char **)__p, "resize_bilinear rank > 4 not supported.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __p);
    goto LABEL_149;
  }
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    if ((unint64_t)((v67 >> 3) - 3) < 2)
    {
      uint64_t v68 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "target_size_width");
      uint64_t v69 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "target_size_height");
      uint64_t v70 = mlir::OpBuilder::create<mlir::mps::ShapeOp,mlir::Value>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
      if (!*((_DWORD *)v70 + 9)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
      unint64_t v71 = *(void *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8;
      uint64_t v104 = (uint64_t)v70 - 16;
      *(void *)__p = v71;
      uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)__p);
      uint64_t v73 = mlir::IntegerType::get(Context, 0x20u, 1u);
      uint64_t v74 = (uint64_t **)mlir::RankedTensorType::get(0, 0, v73, 0);
      if (mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v74))
      {
        if (v74)
        {
          uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v74);
          if (!InterfaceFor)
          {
            unint64_t v76 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            int v77 = 98;
            int v78 = "InterfaceSupport.h";
            uint64_t v79 = "Interface";
            goto LABEL_173;
          }
        }
        else
        {
          uint64_t InterfaceFor = 0;
        }
        LODWORD(v97) = -1;
        uint64_t v81 = mlir::DenseElementsAttr::getFromRawBuffer(v74, InterfaceFor, &v97, 4, 4, 1, 1);
        if (mlir::DenseIntElementsAttr::classof(v81))
        {
          *(void *)__p = v81;
          unsigned __int8 v82 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)__p);
          if (*((_DWORD *)v82 + 9))
          {
            uint64_t v103 = (uint64_t)v82 - 16;
            unsigned int v101 = 2;
            unsigned int v102 = 0;
            uint64_t v83 = mlir::OpBuilder::create<mlir::mps::CropOp,mlir::Value &,mlir::Value &,unsigned int &,unsigned int &>((mlir::mps::ConstantOp *)(a3 + 18), LocationForOp, &v104, &v103, &v102, &v101);
            if (!*(_DWORD *)(v83 + 36)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
            uint64_t v84 = operator new(0x18uLL);
            *(void *)&__p[8] = v84 + 3;
            *(void *)&__p[16] = v84 + 3;
            *uint64_t v84 = v83 - 16;
            v84[1] = v69;
            v84[2] = v68;
            *(void *)__p = v84;
            LOBYTE(v97) = 0;
            uint64_t v100 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>(a3 + 18, LocationForOp, (uint64_t *)__p, &v103, (unsigned __int8 *)&v97);
            unsigned int v99 = v12;
            uint64_t v85 = mlir::OpBuilder::create<mlir::mps::ResizeOp,mlir::Value &,mlir::mps::ConcatOp &,decltype(nullptr),decltype(nullptr),mlir::mps::SamplingMode &,BOOL &,BOOL &,decltype(nullptr)>(a3 + 18, LocationForOp, &ArgValue, (uint64_t)&v100, &v99, (unsigned __int8 *)&v109, (char *)&v109 + 1);
            if (!*(_DWORD *)(v85 + 36)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
            (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&v97, a2);
            uint64_t v86 = (long long *)v97;
            uint64_t v87 = (char *)operator new(8uLL);
            *(void *)uint64_t v87 = v85 - 16;
            uint64_t v111 = v86;
            uint64_t v88 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v86, (uint64_t)&std::piecewise_construct, &v111);
            std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v88 + 5, v87, v87 + 8, 1uLL);
            operator delete(v87);
            uint64_t v89 = (void **)v97;
            if (v97)
            {
              uint64_t v90 = v98;
              uint64_t v91 = v97;
              if (v98 != v97)
              {
                do
                {
                  if (*((char *)v90 - 1) < 0) {
                    operator delete(*(v90 - 3));
                  }
                  v90 -= 3;
                }
                while (v90 != v89);
                uint64_t v91 = v97;
              }
              uint64_t v98 = v89;
              operator delete(v91);
            }
            if (*(void *)__p)
            {
              *(void *)&__p[8] = *(void *)__p;
              operator delete(*(void **)__p);
            }
            uint64_t v40 = 1;
            if (v66) {
              goto LABEL_152;
            }
            goto LABEL_153;
          }
          uint64_t v92 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
          int v93 = 984;
          uint64_t v94 = "Operation.h";
          unsigned int v95 = "getOpResultImpl";
        }
        else
        {
          uint64_t v92 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
          int v93 = 566;
          uint64_t v94 = "Casting.h";
          unsigned int v95 = "cast";
        }
        __assert_rtn(v95, v94, v93, v92);
      }
      unint64_t v76 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      int v77 = 566;
      int v78 = "Casting.h";
      uint64_t v79 = "cast";
LABEL_173:
      __assert_rtn(v79, v78, v77, v76);
    }
    *(void *)__p = operator new(0x28uLL);
    *(_OWORD *)&__p[8] = xmmword_181129D80;
    strcpy(*(char **)__p, "Unsupported rank for input tensor.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __p);
  }
  else
  {
    *(void *)__p = operator new(0x40uLL);
    *(_OWORD *)&__p[8] = xmmword_181129DA0;
    strcpy(*(char **)__p, "The number of outputs does not match the number of results.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __p);
  }
LABEL_149:
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  uint64_t v40 = 0;
  if (v66) {
LABEL_152:
  }
    operator delete(v66);
LABEL_153:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v107, v108[0]);
  return v40;
}

void sub_180D3F874(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,char a31,char *a32)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a30 < 0)
  {
    operator delete(a25);
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a31, a32);
    _Unwind_Resume(a1);
  }
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a31, a32);
  _Unwind_Resume(a1);
}

uint64_t MILToMLIR::UpsampleNearestNeighborPattern::matchAndRewrite(MILToMLIR::UpsampleNearestNeighborPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  __p[39] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  long long v6 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 160))(a2);
  v100[0] = 0;
  v100[1] = 0;
  unsigned int v99 = v100;
  uint64_t v7 = v6 + 1;
  int v8 = *v6;
  if (*v6 != (const void **)(v6 + 1))
  {
    do
    {
      std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&v99, (uint64_t *)v100, v8 + 4, (uint64_t)(v8 + 4));
      int v13 = (const void **)v8[1];
      if (v13)
      {
        do
        {
          uint64_t v14 = (const void ***)v13;
          int v13 = (const void **)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          uint64_t v14 = (const void ***)v8[2];
          BOOL v15 = *v14 == v8;
          int v8 = (const void **)v14;
        }
        while (!v15);
      }
      int v8 = (const void **)v14;
    }
    while (v14 != v7);
  }
  HIBYTE(__p[2]) = 1;
  LOWORD(__p[0]) = 120;
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v10 = MIL::IRValueType::AsTensorType(ParameterType);
  BOOL v11 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v10 + 96))(v10);
  unint64_t v12 = v11[1] - *v11;
  if (v12 <= 0xF)
  {
    __p[0] = operator new(0x30uLL);
    *(_OWORD *)&__p[1] = xmmword_181129D90;
    strcpy((char *)__p[0], "upsample_bilinear rank < 2 not supported.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
LABEL_24:
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v27 = 0;
    goto LABEL_27;
  }
  if (v12 >= 0x21)
  {
    __p[0] = operator new(0x30uLL);
    *(_OWORD *)&__p[1] = xmmword_181129D90;
    strcpy((char *)__p[0], "upsample_bilinear rank > 4 not supported.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
    goto LABEL_24;
  }
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) != 1)
  {
    __p[0] = operator new(0x40uLL);
    *(_OWORD *)&__p[1] = xmmword_181129DA0;
    strcpy((char *)__p[0], "The number of outputs does not match the number of results.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
    goto LABEL_24;
  }
  char v16 = mlir::OpBuilder::create<mlir::mps::ShapeOp,mlir::Value>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
  if (!*((_DWORD *)v16 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v98 = (uint64_t)v16 - 16;
  unsigned int v96 = 1;
  unsigned int v97 = -1;
  LODWORD(__p[0]) = -1;
  uint64_t v17 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int &,int,int &>((mlir::mps::ConstantOp *)(a3 + 18), LocationForOp, &v98, &v97, (unsigned int *)__p, &v96);
  if (!*(_DWORD *)(v17 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v95 = v17 - 16;
  LODWORD(__p[0]) = -2;
  uint64_t v18 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int &,int,int &>((mlir::mps::ConstantOp *)(a3 + 18), LocationForOp, &v98, &v97, (unsigned int *)__p, &v96);
  if (!*(_DWORD *)(v18 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v94 = v18 - 16;
  __p[0] = (void *)(*(void *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)__p);
  uint64_t v20 = mlir::IntegerType::get(Context, 0x20u, 1u);
  int v21 = (uint64_t **)mlir::RankedTensorType::get(0, 0, v20, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v21))
  {
    int v23 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v24 = 566;
    size_t v25 = "Casting.h";
    BOOL v26 = "cast";
LABEL_75:
    __assert_rtn(v26, v25, v24, v23);
  }
  if (v21)
  {
    uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v21);
    if (!InterfaceFor)
    {
      int v23 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v24 = 98;
      size_t v25 = "InterfaceSupport.h";
      BOOL v26 = "Interface";
      goto LABEL_75;
    }
  }
  else
  {
    uint64_t InterfaceFor = 0;
  }
  LODWORD(v107[0]) = -1;
  unint64_t v29 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v21, InterfaceFor, v107, 4, 4, 1, 1);
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)v29))
  {
    uint64_t v70 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v71 = 566;
    uint64_t v72 = "Casting.h";
    uint64_t v73 = "cast";
    goto LABEL_78;
  }
  __p[0] = v29;
  unint64_t v30 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)__p);
  if (!*((_DWORD *)v30 + 9))
  {
    uint64_t v70 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    int v71 = 984;
    uint64_t v72 = "Operation.h";
    uint64_t v73 = "getOpResultImpl";
LABEL_78:
    __assert_rtn(v73, v72, v71, v70);
  }
  uint64_t v93 = (uint64_t)v30 - 16;
  unsigned int v91 = 2;
  unsigned int v92 = 0;
  uint64_t v31 = mlir::OpBuilder::create<mlir::mps::CropOp,mlir::Value &,mlir::Value &,unsigned int &,unsigned int &>((mlir::mps::ConstantOp *)(a3 + 18), LocationForOp, &v98, &v93, &v92, &v91);
  if (!*(_DWORD *)(v31 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  HIBYTE(__p[2]) = 19;
  strcpy((char *)__p, "scale_factor_height");
  Parameteruint64_t Value = MIL::IROperation::GetParameterValue();
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  unint64_t v33 = (int *)MEMORY[0x1852FD7E0](ParameterValue);
  if (v33)
  {
    double v34 = (double)*v33;
  }
  else
  {
    BOOL v35 = (float *)MEMORY[0x1852FD7D0](ParameterValue);
    if (v35)
    {
      float v36 = *v35;
    }
    else
    {
      BOOL v37 = (MIL::Fp16 *)MEMORY[0x1852FD7C0](ParameterValue);
      if (!v37)
      {
        std::string::basic_string[abi:ne180100]<0>(__p, "unexpected type for scale_factor_height");
        MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
        goto LABEL_24;
      }
      MIL::Fp16::GetFloat(v37);
    }
    double v34 = v36;
  }
  HIBYTE(__p[2]) = 18;
  strcpy((char *)__p, "scale_factor_width");
  uint64_t v38 = MIL::IROperation::GetParameterValue();
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  BOOL v39 = (int *)MEMORY[0x1852FD7E0](v38);
  if (v39)
  {
    double v40 = (double)*v39;
  }
  else
  {
    uint64_t v41 = (float *)MEMORY[0x1852FD7D0](v38);
    if (v41)
    {
      float v42 = *v41;
    }
    else
    {
      int v43 = (MIL::Fp16 *)MEMORY[0x1852FD7C0](v38);
      if (!v43)
      {
        std::string::basic_string[abi:ne180100]<0>(__p, "unexpected type for scale_factor_width");
        MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
        goto LABEL_24;
      }
      MIL::Fp16::GetFloat(v43);
    }
    double v40 = v42;
  }
  __p[0] = (void *)(*(void *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
  int v44 = (mlir::Float32Type *)mlir::Attribute::getContext((mlir::Attribute *)__p);
  uint64_t v90 = mlir::Float32Type::get(v44, v45);
  __p[0] = (void *)1;
  unint64_t v46 = (void *)mlir::RankedTensorType::get((uint64_t)__p, 1, v90, 0);
  int MPSDataType = getMPSDataType(v46);
  float v48 = v40;
  int v49 = getConstantDataForScalar(MPSDataType, v48);
  uint64_t ConstantOp = createConstantOp((mlir::OpBuilder *)(a3 + 18), LocationForOp, v49, v46, 1);

  uint64_t v89 = ConstantOp;
  int v51 = getMPSDataType(v46);
  float v52 = v34;
  int v53 = getConstantDataForScalar(v51, v52);
  uint64_t v54 = createConstantOp((mlir::OpBuilder *)(a3 + 18), LocationForOp, v53, v46, 1);

  uint64_t v88 = v54;
  uint64_t v87 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::FloatType &>(a3 + 18, LocationForOp, &v95, &v90);
  uint64_t v86 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::FloatType &>(a3 + 18, LocationForOp, &v94, &v90);
  uint64_t v85 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::CastOp &,mlir::Value &>(a3 + 18, LocationForOp, (uint64_t)&v87, &v89);
  uint64_t v84 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::CastOp &,mlir::Value &>(a3 + 18, LocationForOp, (uint64_t)&v86, &v88);
  uint64_t v83 = mlir::IntegerType::get((uint64_t)a3[18], 0x20u, 1u);
  uint64_t v82 = mlir::OpBuilder::create<mlir::mps::FloorOp,mlir::mps::MultiplyOp &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t)&v85);
  uint64_t v81 = mlir::OpBuilder::create<mlir::mps::FloorOp,mlir::mps::MultiplyOp &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t)&v84);
  uint64_t v55 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::mps::FloorOp &,mlir::IntegerType &>(a3 + 18, LocationForOp, (uint64_t)&v82, &v83);
  uint64_t v56 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::mps::FloorOp &,mlir::IntegerType &>(a3 + 18, LocationForOp, (uint64_t)&v81, &v83);
  if (!*(_DWORD *)(v56 + 36) || !*(_DWORD *)(v55 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v57 = operator new(0x18uLL);
  uint64_t v79 = v57 + 3;
  uint64_t v80 = v57 + 3;
  *uint64_t v57 = v31 - 16;
  v57[1] = v56 - 16;
  v57[2] = v55 - 16;
  int v78 = v57;
  LOBYTE(__p[0]) = 0;
  uint64_t v58 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>(a3 + 18, LocationForOp, (uint64_t *)&v78, &v93, (unsigned __int8 *)__p);
  uint64_t v102 = LocationForOp;
  char v59 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v102);
  uint64_t v60 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.resize", (const unsigned __int8 *)0xA, v59);
  if (!v61)
  {
    __int16 v106 = 1283;
    v105[2] = (uint64_t)"mps.resize";
    v105[3] = 10;
           "y the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-"
           "dialects-management";
    __int16 v104 = 259;
    llvm::operator+(v105, (uint64_t *)&v103, (uint64_t)v107);
    llvm::report_fatal_error((llvm::Twine *)v107, 1);
  }
  mlir::OperationState::OperationState(__p, LocationForOp, v60);
  if (!*(_DWORD *)(v58 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ResizeOp::build(a3 + 18, (uint64_t)__p, ArgValue, v58 - 16, 0, 0, 0, 1, 0, 0);
  uint64_t v62 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)__p);
  if (!v62)
  {
    uint64_t v74 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v75 = 662;
    unint64_t v76 = "Casting.h";
    int v77 = "dyn_cast";
    goto LABEL_84;
  }
  uint64_t v63 = llvm::DefaultDoCastIfPossible<mlir::mps::ResizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ResizeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v62);
  if (!v63)
  {
    uint64_t v74 = "result && \"builder didn't return the right type\"";
    int v75 = 497;
    unint64_t v76 = "Builders.h";
    int v77 = "create";
LABEL_84:
    __assert_rtn(v77, v76, v75, v74);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)__p);
  if (!*(_DWORD *)(v63 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(__p, a2);
  unint64_t v64 = (long long *)__p[0];
  int64_t v65 = (char *)operator new(8uLL);
  *(void *)int64_t v65 = v63 - 16;
  v107[0] = v64;
  uint64_t v66 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v64, (uint64_t)&std::piecewise_construct, v107);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v66 + 5, v65, v65 + 8, 1uLL);
  operator delete(v65);
  uint64_t v67 = (void **)__p[0];
  if (__p[0])
  {
    uint64_t v68 = (void **)__p[1];
    uint64_t v69 = __p[0];
    if (__p[1] != __p[0])
    {
      do
      {
        if (*((char *)v68 - 1) < 0) {
          operator delete(*(v68 - 3));
        }
        v68 -= 3;
      }
      while (v68 != v67);
      uint64_t v69 = __p[0];
    }
    __p[1] = v67;
    operator delete(v69);
  }
  if (v78)
  {
    uint64_t v79 = v78;
    operator delete(v78);
  }
  uint64_t v27 = 1;
LABEL_27:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v99, v100[0]);
  return v27;
}

void sub_180D40564(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,char *a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *__p,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a56 < 0)
  {
    operator delete(__p);
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a31, a32);
    _Unwind_Resume(a1);
  }
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a31, a32);
  _Unwind_Resume(a1);
}

uint64_t MILToMLIR::SplitPattern::matchAndRewrite(MILToMLIR::SplitPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  __p[38] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  HIBYTE(__p[2]) = 4;
  strcpy((char *)__p, "axis");
  Parameteruint64_t Value = (MIL::IRValue *)MIL::IROperation::GetParameterValue();
  int v8 = (MIL::IRValueType *)(*(uint64_t (**)(MIL::IRValue *))(*(void *)ParameterValue + 32))(ParameterValue);
  uint64_t v9 = MIL::IRValueType::AsTensorType(v8);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v9 + 88))(v9) == 11)
  {
    MIL::IRValue::AsTensor(ParameterValue);
    int v10 = *(_DWORD *)MIL::IRTensorValue::GetDataView<int>();
    strcpy((char *)__p, "num_splits");
    uint64_t v11 = MIL::IROperation::TryGetParameterValue();
    uint64_t v125 = LocationForOp;
    int v126 = v10;
    uint64_t v129 = ArgValue;
    HIBYTE(__p[2]) = 11;
    strcpy((char *)__p, "split_sizes");
    uint64_t v12 = MIL::IROperation::TryGetParameterValue();
    memset(&v136, 0, sizeof(v136));
    int v122 = (MILToMLIRRewriter *)a3;
    int v123 = a2;
    if (v12)
    {
      (*(void (**)(uint64_t))(*(void *)v12 + 40))(v12);
      uint64_t Data = MIL::IRTensorValue::GetDataView<int>();
      if (v14)
      {
        BOOL v15 = (int *)Data;
        uint64_t v124 = v14;
        char v16 = (int *)(Data + 4 * v14);
        end = v136.__end_;
        while (1)
        {
          int v19 = *v15;
          if (end >= v136.__end_cap_.__value_) {
            break;
          }
          int *end = v19;
          uint64_t v18 = end + 1;
LABEL_6:
          v136.__end_ = v18;
          ++v15;
          end = v18;
          if (v15 == v16)
          {
            double v40 = v122;
            long long v133 = 0;
            uint64_t v134 = 0;
            BOOL v135 = 0;
            uint64_t v41 = v125;
            LODWORD(v42) = v126;
            uint64_t v43 = v124;
            goto LABEL_38;
          }
        }
        std::vector<int>::pointer begin = v136.__begin_;
        int64_t v21 = (char *)end - (char *)v136.__begin_;
        uint64_t v22 = end - v136.__begin_;
        unint64_t v23 = v22 + 1;
        if ((unint64_t)(v22 + 1) >> 62) {
          std::vector<int>::__throw_length_error[abi:ne180100]();
        }
        int64_t v24 = (char *)v136.__end_cap_.__value_ - (char *)v136.__begin_;
        if (((char *)v136.__end_cap_.__value_ - (char *)v136.__begin_) >> 1 > v23) {
          unint64_t v23 = v24 >> 1;
        }
        if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v25 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v25 = v23;
        }
        if (v25)
        {
          if (v25 >> 62) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          BOOL v26 = operator new(4 * v25);
          uint64_t v27 = (int *)&v26[4 * v22];
          int *v27 = v19;
          uint64_t v18 = v27 + 1;
          int64_t v28 = (char *)end - (char *)begin;
          if (end == begin) {
            goto LABEL_22;
          }
        }
        else
        {
          BOOL v26 = 0;
          uint64_t v27 = (int *)(4 * v22);
          *(_DWORD *)(4 * v22) = v19;
          uint64_t v18 = (int *)(4 * v22 + 4);
          int64_t v28 = (char *)end - (char *)begin;
          if (end == begin) {
            goto LABEL_22;
          }
        }
        unint64_t v29 = v28 - 4;
        if (v29 >= 0xBC)
        {
          unint64_t v32 = ((char *)(end - 1) - (char *)begin) & 0xFFFFFFFFFFFFFFFCLL;
          if (&v26[v21 - 4 - v32] > &v26[v21 - 4])
          {
            unint64_t v30 = end;
          }
          else if ((int *)((char *)end - v32 - 4) > end - 1)
          {
            unint64_t v30 = end;
          }
          else if ((unint64_t)((char *)end - v26 - v21) >= 0x20)
          {
            uint64_t v33 = (v29 >> 2) + 1;
            uint64_t v34 = 4 * (v33 & 0x7FFFFFFFFFFFFFF8);
            unint64_t v30 = &end[v34 / 0xFFFFFFFFFFFFFFFCLL];
            uint64_t v27 = (int *)((char *)v27 - v34);
            BOOL v35 = &v26[4 * v22 - 16];
            float v36 = end - 4;
            uint64_t v37 = v33 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v38 = *(_OWORD *)v36;
              *(v35 - 1) = *((_OWORD *)v36 - 1);
              _OWORD *v35 = v38;
              v35 -= 2;
              v36 -= 8;
              v37 -= 8;
            }
            while (v37);
            if (v33 == (v33 & 0x7FFFFFFFFFFFFFF8))
            {
LABEL_22:
              v136.__begin_ = v27;
              v136.__end_ = v18;
              v136.__end_cap_.__value_ = (int *)&v26[4 * v25];
              if (begin) {
                operator delete(begin);
              }
              goto LABEL_6;
            }
          }
          else
          {
            unint64_t v30 = end;
          }
        }
        else
        {
          unint64_t v30 = end;
        }
        do
        {
          int v31 = *--v30;
          *--uint64_t v27 = v31;
        }
        while (v30 != begin);
        goto LABEL_22;
      }
      uint64_t v43 = 0;
      unsigned int v91 = 0;
      long long v133 = 0;
      uint64_t v134 = 0;
      char v92 = 1;
      BOOL v135 = 0;
LABEL_98:
      if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)v123 + 192))(v123) == v43)
      {
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)v123 + 200))(__p, v123);
        if (v92)
        {
LABEL_103:
          BOOL v100 = 0;
        }
        else
        {
          uint64_t v98 = 0;
          unint64_t v99 = 0;
          BOOL v100 = 1;
          while (1)
          {
            unint64_t v101 = v43;
            uint64_t OutputType = MIL::IROperation::GetOutputType(v123);
            if (!(*(uint64_t (**)(uint64_t))(*(void *)OutputType + 24))(OutputType)) {
              break;
            }
            uint64_t v103 = (char *)__p[0];
            uint64_t v104 = *((void *)v133 + v99);
            uint64_t v105 = (char *)operator new(8uLL);
            *(void *)uint64_t v105 = v104;
            *(void *)__u = &v103[v98];
            __int16 v106 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v122 + 64, (uint64_t)&v103[v98], (uint64_t)&std::piecewise_construct, (long long **)__u);
            std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v106 + 5, v105, v105 + 8, 1uLL);
            operator delete(v105);
            ++v99;
            uint64_t v43 = v101;
            BOOL v100 = v99 < v101;
            v98 += 24;
            if (v101 == v99) {
              goto LABEL_103;
            }
          }
          *(void *)__u = operator new(0x28uLL);
          *(_OWORD *)&__u[2] = xmmword_181129DE0;
          strcpy(*(char **)__u, "Expected num_splits tensor outputs.");
          MILToMLIRRewriter::notifyFailure((uint64_t)v122, (uint64_t)v123, (const std::string::value_type *)__u);
          if (SHIBYTE(__u[5]) < 0) {
            operator delete(*(void **)__u);
          }
        }
        unint64_t v107 = (void **)__p[0];
        if (__p[0])
        {
          int v108 = (void **)__p[1];
          __int16 v109 = __p[0];
          if (__p[1] != __p[0])
          {
            do
            {
              if (*((char *)v108 - 1) < 0) {
                operator delete(*(v108 - 3));
              }
              v108 -= 3;
            }
            while (v108 != v107);
            __int16 v109 = __p[0];
          }
          __p[1] = v107;
          operator delete(v109);
        }
        if (!v100) {
          goto LABEL_130;
        }
      }
      else
      {
        if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)v123 + 192))(v123) == 1)
        {
          uint64_t v110 = MIL::IROperation::GetOutputType(v123);
          uint64_t v111 = v122;
          uint64_t v112 = (*(uint64_t (**)(uint64_t))(*(void *)v110 + 40))(v110);
          if (v112)
          {
            if ((*(uint64_t (**)(uint64_t))(*(void *)v112 + 16))(v112) == v43)
            {
              (*(void (**)(void **__return_ptr))(*(void *)v123 + 200))(__p);
              uint64_t v113 = __p[0];
              unint64_t v131 = 0;
              int v132 = 0;
              int v130 = 0;
              int64_t v114 = v91 - (unsigned char *)v133;
              if (v114)
              {
                if (v114 < 0) {
                  std::vector<long>::__throw_length_error[abi:ne180100]();
                }
                int v130 = operator new(v114);
                int v132 = (char *)v130 + 8 * (v114 >> 3);
                memcpy(v130, v133, v114);
                unint64_t v131 = v132;
                uint64_t v111 = v122;
              }
              *(void *)__u = v113;
              uint64_t v115 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v111 + 64, (uint64_t)v113, (uint64_t)&std::piecewise_construct, (long long **)__u)+ 5;
              if (v115 != (uint64_t *)&v130) {
                std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v115, (char *)v130, v131, (v131 - (unsigned char *)v130) >> 3);
              }
              if (v130)
              {
                unint64_t v131 = (char *)v130;
                operator delete(v130);
              }
              int v116 = (void **)__p[0];
              if (__p[0])
              {
                int v117 = (void **)__p[1];
                unsigned int v118 = __p[0];
                if (__p[1] != __p[0])
                {
                  do
                  {
                    if (*((char *)v117 - 1) < 0) {
                      operator delete(*(v117 - 3));
                    }
                    v117 -= 3;
                  }
                  while (v117 != v116);
                  unsigned int v118 = __p[0];
                }
                __p[1] = v116;
                operator delete(v118);
                uint64_t v39 = 1;
                int v119 = v133;
                if (!v133) {
                  goto LABEL_140;
                }
                goto LABEL_139;
              }
LABEL_130:
              uint64_t v39 = 1;
              int v119 = v133;
              if (!v133)
              {
LABEL_140:
                if (v136.__begin_)
                {
                  v136.__end_ = v136.__begin_;
                  operator delete(v136.__begin_);
                }
                return v39;
              }
LABEL_139:
              operator delete(v119);
              goto LABEL_140;
            }
            __p[0] = operator new(0x28uLL);
            *(_OWORD *)&__p[1] = xmmword_181129D80;
            strcpy((char *)__p[0], "Unexpected number of tuple values.");
            MILToMLIRRewriter::notifyFailure((uint64_t)v122, (uint64_t)v123, (const std::string::value_type *)__p);
          }
          else
          {
            __p[0] = operator new(0x30uLL);
            *(_OWORD *)&__p[1] = xmmword_181129E50;
            strcpy((char *)__p[0], "Expected tuple with num_splits tensor values.");
            MILToMLIRRewriter::notifyFailure((uint64_t)v122, (uint64_t)v123, (const std::string::value_type *)__p);
          }
        }
        else
        {
          __p[0] = operator new(0x78uLL);
          *(_OWORD *)&__p[1] = xmmword_181129E40;
          strcpy((char *)__p[0], "Return types of split must be either a tuple with num_splits tensor values, or num_splits distinct tensor values.");
          MILToMLIRRewriter::notifyFailure((uint64_t)v122, (uint64_t)v123, (const std::string::value_type *)__p);
        }
        if (SHIBYTE(__p[2]) < 0) {
          operator delete(__p[0]);
        }
      }
      uint64_t v39 = 0;
      int v119 = v133;
      if (!v133) {
        goto LABEL_140;
      }
      goto LABEL_139;
    }
    if (!v11)
    {
      __p[0] = operator new(0x40uLL);
      *(_OWORD *)&__p[1] = xmmword_181129E60;
      strcpy((char *)__p[0], "Either 'num_splits' or a 'split_sizes' tensor must be provided.");
      MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
      if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
      {
LABEL_95:
        uint64_t v39 = 0;
        goto LABEL_140;
      }
      uint64_t v93 = __p[0];
LABEL_94:
      operator delete(v93);
      goto LABEL_95;
    }
    int v82 = MIL::IRValue::GetScalar<int>();
    HIBYTE(__p[2]) = 1;
    LOWORD(__p[0]) = 120;
    ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
    uint64_t v84 = MIL::IRValueType::AsTensorType(ParameterType);
    uint64_t v85 = (*(uint64_t (**)(uint64_t))(*(void *)v84 + 96))(v84);
    memset(__p, 0, 24);
    uint64_t v87 = *(const void **)v85;
    uint64_t v86 = *(void *)(v85 + 8);
    int64_t v88 = v86 - *(void *)v85;
    if (v86 == *(void *)v85)
    {
      uint64_t v89 = 0;
      uint64_t v90 = 0;
    }
    else
    {
      if (v88 < 0) {
        std::vector<int>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v89 = (char *)operator new(v86 - *(void *)v85);
      uint64_t v90 = &v89[8 * (v88 >> 3)];
      __p[0] = v89;
      __p[2] = v90;
      memcpy(v89, v87, v88);
    }
    unint64_t v94 = (v90 - v89) >> 3;
    int v95 = v94 & (v10 >> 31);
    unint64_t v42 = (v95 + v10);
    double v40 = v122;
    if (v95 + v10 < 0 || v94 <= v42)
    {
      HIBYTE(__u[5]) = 12;
      strcpy((char *)__u, "Invalid axis");
      MILToMLIRRewriter::notifyFailure((uint64_t)v122, (uint64_t)a2, (const std::string::value_type *)__u);
      if (SHIBYTE(__u[5]) < 0) {
        operator delete(*(void **)__u);
      }
    }
    int v126 = v42;
    uint64_t v96 = (*(uint64_t (**)(void))(**(void **)&v89[8 * (int)v42] + 16))(*(void *)&v89[8 * (int)v42]);
    if (!v96)
    {
      *(void *)__u = operator new(0x30uLL);
      *(_OWORD *)&__u[2] = xmmword_181129DD0;
      strcpy(*(char **)__u, "Input shape must be constant along 'axis'.");
      MILToMLIRRewriter::notifyFailure((uint64_t)v122, (uint64_t)a2, (const std::string::value_type *)__u);
      goto LABEL_91;
    }
    int v97 = (*(uint64_t (**)(uint64_t))(*(void *)v96 + 48))(v96);
    if (v97 % (unint64_t)v82)
    {
      *(void *)__u = operator new(0x40uLL);
      *(_OWORD *)&__u[2] = xmmword_181129DA0;
      strcpy(*(char **)__u, "Input shape must be divisible by 'num_splits' along 'axis'.");
      MILToMLIRRewriter::notifyFailure((uint64_t)v122, (uint64_t)a2, (const std::string::value_type *)__u);
LABEL_91:
      if (SHIBYTE(__u[5]) < 0) {
        operator delete(*(void **)__u);
      }
      uint64_t v93 = v89;
      goto LABEL_94;
    }
    __u[0] = v97 / (unint64_t)v82;
    uint64_t v124 = v82;
    std::vector<int>::assign(&v136, v82, __u);
    operator delete(v89);
    long long v133 = 0;
    uint64_t v134 = 0;
    BOOL v135 = 0;
    uint64_t v41 = v125;
    uint64_t v43 = v124;
    if (!v124)
    {
      unsigned int v91 = 0;
      char v92 = 1;
      goto LABEL_98;
    }
LABEL_38:
    unsigned int v44 = 0;
    BOOL v45 = 0;
    uint64_t v46 = 0;
    BOOL v47 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    float v48 = "Casting.h";
    int v49 = "dyn_cast";
    uint64_t v128 = (MILToMLIRRewriter *)((char *)v40 + 144);
    while (1)
    {
      while (1)
      {
        BOOL v50 = v45;
        std::vector<int>::pointer v51 = v136.__begin_;
        uint64_t v137 = v41;
        uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v137);
        uint64_t v53 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.slice", (const unsigned __int8 *)9, Context);
        if (!v54)
        {
          __int16 v141 = 1283;
          v140[2] = (uint64_t)"mps.slice";
          v140[3] = 9;
                 "dded by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-wh"
                 "ats-up-with-dialects-management";
          __int16 v139 = 259;
          llvm::operator+(v140, (uint64_t *)&v138, (uint64_t)__u);
          llvm::report_fatal_error((llvm::Twine *)__u, 1);
        }
        mlir::OperationState::OperationState(__p, v41, v53);
        mlir::mps::SliceOp::build(v128, (uint64_t *)__p, v129, v42, v44, v51[v46]);
        uint64_t v55 = mlir::OpBuilder::create(v128, (const mlir::OperationState *)__p);
        if (!v55)
        {
          int v121 = 662;
          goto LABEL_149;
        }
        uint64_t v56 = llvm::DefaultDoCastIfPossible<mlir::mps::SliceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SliceOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v55);
        if (!v56)
        {
          int v121 = 497;
          int v49 = "create";
          float v48 = "Builders.h";
          BOOL v47 = "result && \"builder didn't return the right type\"";
LABEL_149:
          __assert_rtn(v49, v48, v121, v47);
        }
        mlir::OperationState::~OperationState((mlir::OperationState *)__p);
        if (!*(_DWORD *)(v56 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        uint64_t v57 = v48;
        uint64_t v58 = v47;
        int v59 = v136.__begin_[v46];
        uint64_t v60 = v56 - 16;
        char v61 = v50;
        if (v50 >= (uint64_t *)v135) {
          break;
        }
        *BOOL v50 = v60;
        BOOL v45 = v50 + 1;
        BOOL v47 = v58;
        float v48 = v57;
        int v49 = "dyn_cast";
        v44 += v59;
        uint64_t v134 = v50 + 1;
        if (++v46 == v43) {
          goto LABEL_78;
        }
      }
      uint64_t v62 = (char *)v133;
      int64_t v63 = (char *)v50 - (unsigned char *)v133;
      uint64_t v64 = ((char *)v50 - (unsigned char *)v133) >> 3;
      unint64_t v65 = v64 + 1;
      if ((unint64_t)(v64 + 1) >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v66 = v135 - (unsigned char *)v133;
      if ((v135 - (unsigned char *)v133) >> 2 > v65) {
        unint64_t v65 = v66 >> 2;
      }
      if ((unint64_t)v66 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v67 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v67 = v65;
      }
      int v127 = v136.__begin_[v46];
      if (v67)
      {
        if (v67 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v68 = operator new(8 * v67);
        char v61 = v50;
        uint64_t v69 = (uint64_t *)&v68[8 * v64];
        *uint64_t v69 = v60;
        uint64_t v70 = (uint64_t)(v69 + 1);
        int64_t v71 = v61 - v62;
        if (v61 == v62)
        {
LABEL_62:
          BOOL v47 = v58;
          float v48 = v57;
          int v49 = "dyn_cast";
          long long v133 = v69;
          uint64_t v134 = (void *)v70;
          BOOL v135 = &v68[8 * v67];
          if (!v61) {
            goto LABEL_59;
          }
LABEL_58:
          operator delete(v61);
          goto LABEL_59;
        }
      }
      else
      {
        uint64_t v68 = 0;
        uint64_t v69 = (uint64_t *)(8 * v64);
        *(void *)(8 * v64) = v60;
        uint64_t v70 = 8 * v64 + 8;
        int64_t v71 = v61 - v62;
        if (v61 == v62) {
          goto LABEL_62;
        }
      }
      unint64_t v72 = v71 - 8;
      BOOL v47 = v58;
      if (v72 < 0x168)
      {
        uint64_t v73 = v61;
        float v48 = v57;
        int v49 = "dyn_cast";
        goto LABEL_56;
      }
      unint64_t v75 = (v61 - 8 - v62) & 0xFFFFFFFFFFFFFFF8;
      float v48 = v57;
      if (&v68[v63 - 8 - v75] > &v68[v63 - 8]) {
        break;
      }
      int v49 = "dyn_cast";
      if (&v61[-v75 - 8] > v61 - 8)
      {
        uint64_t v73 = v61;
        goto LABEL_56;
      }
      if ((unint64_t)(v61 - v68 - v63) < 0x20)
      {
        uint64_t v73 = v61;
        goto LABEL_56;
      }
      uint64_t v76 = (v72 >> 3) + 1;
      uint64_t v77 = 8 * (v76 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v73 = &v61[-v77];
      uint64_t v69 = (uint64_t *)((char *)v69 - v77);
      int v78 = &v68[8 * v64 - 16];
      uint64_t v79 = (long long *)(v61 - 16);
      uint64_t v80 = v76 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v81 = *v79;
        *(v78 - 1) = *(v79 - 1);
        *int v78 = v81;
        v78 -= 2;
        v79 -= 2;
        v80 -= 4;
      }
      while (v80);
      if (v76 != (v76 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_56;
      }
LABEL_57:
      char v61 = v133;
      long long v133 = v69;
      uint64_t v134 = (void *)v70;
      BOOL v135 = &v68[8 * v67];
      if (v61) {
        goto LABEL_58;
      }
LABEL_59:
      BOOL v45 = (uint64_t *)v70;
      uint64_t v41 = v125;
      LODWORD(v42) = v126;
      uint64_t v43 = v124;
      v44 += v127;
      uint64_t v134 = (void *)v70;
      if (++v46 == v124)
      {
LABEL_78:
        unsigned int v91 = (char *)v45;
        char v92 = 0;
        goto LABEL_98;
      }
    }
    uint64_t v73 = v61;
    int v49 = "dyn_cast";
    do
    {
LABEL_56:
      uint64_t v74 = *((void *)v73 - 1);
      v73 -= 8;
      *--uint64_t v69 = v74;
    }
    while (v73 != v62);
    goto LABEL_57;
  }
  __p[0] = operator new(0x20uLL);
  *(_OWORD *)&__p[1] = xmmword_181129E30;
  strcpy((char *)__p[0], "unexpected type for axis");
  MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  return 0;
}

void sub_180D41698(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,uint64_t a44,uint64_t a45,void *__p,uint64_t a47,int a48,__int16 a49,char a50,char a51)
{
  if (a51 < 0) {
    operator delete(__p);
  }
  if (a21) {
    operator delete(a21);
  }
  if (!a24) {
    _Unwind_Resume(exception_object);
  }
  operator delete(a24);
  _Unwind_Resume(exception_object);
}

void std::vector<int>::assign(std::vector<int> *this, std::vector<int>::size_type __n, std::vector<int>::const_reference __u)
{
  uint64_t value = (uint64_t)this->__end_cap_.__value_;
  std::vector<int>::pointer begin = this->__begin_;
  int v8 = begin;
  if (__n > (value - (uint64_t)begin) >> 2)
  {
    if (begin)
    {
      this->__end_ = begin;
      operator delete(begin);
      uint64_t value = 0;
      this->__begin_ = 0;
      this->__end_ = 0;
      this->__end_cap_.__value_ = 0;
    }
    if (__n >> 62) {
      goto LABEL_38;
    }
    std::vector<int>::size_type v9 = value >> 1;
    if (value >> 1 <= __n) {
      std::vector<int>::size_type v9 = __n;
    }
    BOOL v10 = (unint64_t)value >= 0x7FFFFFFFFFFFFFFCLL;
    unint64_t v11 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v10) {
      unint64_t v11 = v9;
    }
    if (v11 >> 62) {
LABEL_38:
    }
      std::vector<int>::__throw_length_error[abi:ne180100]();
    uint64_t v12 = v11;
    int v13 = (int *)operator new(4 * v11);
    this->__begin_ = v13;
    this->__end_cap_.__value_ = &v13[v12];
    uint64_t v14 = &v13[__n];
    std::vector<int>::value_type v15 = *__u;
    std::vector<int>::size_type v16 = (__n - 1) & 0x3FFFFFFFFFFFFFFFLL;
    uint64_t v17 = v13;
    if (v16 < 7) {
      goto LABEL_41;
    }
    std::vector<int>::size_type v18 = v16 + 1;
    uint64_t v17 = &v13[v18 & 0x7FFFFFFFFFFFFFF8];
    int32x4_t v19 = vdupq_n_s32(v15);
    uint64_t v20 = (int32x4_t *)(v13 + 4);
    uint64_t v21 = v18 & 0x7FFFFFFFFFFFFFF8;
    do
    {
      v20[-1] = v19;
      *uint64_t v20 = v19;
      v20 += 2;
      v21 -= 8;
    }
    while (v21);
    if (v18 != (v18 & 0x7FFFFFFFFFFFFFF8))
    {
LABEL_41:
      do
        *v17++ = v15;
      while (v17 != v14);
    }
    goto LABEL_37;
  }
  std::vector<int>::pointer end = this->__end_;
  int64_t v23 = (char *)end - (char *)begin;
  unint64_t v24 = end - begin;
  if (v24 >= __n) {
    std::vector<int>::size_type v25 = __n;
  }
  else {
    std::vector<int>::size_type v25 = end - begin;
  }
  if (v25)
  {
    if (v25 < 8 || begin < __u + 1 && &begin[v25] > __u) {
      goto LABEL_42;
    }
    int v8 = &begin[v25 & 0xFFFFFFFFFFFFFFF8];
    float32x4_t v26 = vld1q_dup_f32((const float *)__u);
    uint64_t v27 = (float32x4_t *)(begin + 4);
    unint64_t v28 = v25 & 0xFFFFFFFFFFFFFFF8;
    do
    {
      v27[-1] = v26;
      float32x4_t *v27 = v26;
      v27 += 2;
      v28 -= 8;
    }
    while (v28);
    BOOL v29 = v25 == (v25 & 0xFFFFFFFFFFFFFFF8);
    v25 &= 7u;
    if (!v29)
    {
LABEL_42:
      do
      {
        *v8++ = *__u;
        --v25;
      }
      while (v25);
    }
  }
  BOOL v10 = __n >= v24;
  std::vector<int>::size_type v30 = __n - v24;
  if (v30 == 0 || !v10)
  {
    uint64_t v14 = &begin[__n];
LABEL_37:
    this->__end_ = v14;
    return;
  }
  int v31 = &end[v30];
  unint64_t v32 = v23 & 0xFFFFFFFFFFFFFFFCLL;
  std::vector<int>::size_type v33 = 4 * __n - (v23 & 0xFFFFFFFFFFFFFFFCLL) - 4;
  if (v33 < 0x4C || end < __u + 1 && (int *)((char *)&end[__n] - v32) > __u) {
    goto LABEL_43;
  }
  uint64_t v34 = (v33 >> 2) + 1;
  BOOL v35 = &end[v34 & 0x7FFFFFFFFFFFFFF8];
  float32x4_t v36 = vld1q_dup_f32((const float *)__u);
  uint64_t v37 = (float32x4_t *)(end + 4);
  uint64_t v38 = v34 & 0x7FFFFFFFFFFFFFF8;
  do
  {
    v37[-1] = v36;
    *uint64_t v37 = v36;
    v37 += 2;
    v38 -= 8;
  }
  while (v38);
  std::vector<int>::pointer end = v35;
  if (v34 != (v34 & 0x7FFFFFFFFFFFFFF8))
  {
LABEL_43:
    do
      *end++ = *__u;
    while (end != v31);
  }
  this->__end_ = v31;
}

uint64_t MILToMLIR::StackPattern::matchAndRewrite(MILToMLIR::StackPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  MILToMLIRRewriter::getArgValues((int8x8_t *)a3, a2, "values", &v60);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "axis");
  HIBYTE(v58) = 4;
  strcpy((char *)&__p, "axis");
  Parameteruint64_t Value = (MIL::IRValue *)MIL::IROperation::GetParameterValue();
  uint64_t v7 = (MIL::IRValueType *)(*(uint64_t (**)(MIL::IRValue *))(*(void *)ParameterValue + 32))(ParameterValue);
  uint64_t v8 = MIL::IRValueType::AsTensorType(v7);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v8 + 88))(v8) == 11)
  {
    MIL::IRValue::AsTensor(ParameterValue);
    std::vector<int>::size_type v9 = a3 + 18;
    int v10 = *(_DWORD *)MIL::IRTensorValue::GetDataView<int>();
    uint64_t v11 = mlir::IntegerType::get((uint64_t)a3[18], 0x20u, 1u);
    uint64_t v12 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v11, 0);
    __p = (void *)mlir::mps::getConstantAttr<int>(v12, v10);
    int v13 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)&__p);
    if (!*((_DWORD *)v13 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    float v52 = a2;
    uint64_t v53 = (MILToMLIRRewriter *)a3;
    uint64_t v56 = (uint64_t)v13 - 16;
    __p = 0;
    long long v58 = 0uLL;
    uint64_t v14 = (void **)v60;
    std::vector<int>::value_type v15 = v61;
    while (1)
    {
      if (v14 == v15)
      {
        LOBYTE(v54) = 0;
        uint64_t v45 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>(v9, LocationForOp, (uint64_t *)&__p, &v56, (unsigned __int8 *)&v54);
        (*(void (**)(void **__return_ptr))(*(void *)v52 + 200))(&v54);
        if (!*(_DWORD *)(v45 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        uint64_t v46 = (long long *)v54;
        BOOL v47 = (char *)operator new(8uLL);
        *(void *)BOOL v47 = v45 - 16;
        uint64_t v62 = v46;
        float v48 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v53 + 64, (uint64_t)v46, (uint64_t)&std::piecewise_construct, &v62);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v48 + 5, v47, v47 + 8, 1uLL);
        operator delete(v47);
        int v49 = (void **)v54;
        if (v54)
        {
          BOOL v50 = v55;
          std::vector<int>::pointer v51 = v54;
          if (v55 != v54)
          {
            do
            {
              if (*((char *)v50 - 1) < 0) {
                operator delete(*(v50 - 3));
              }
              v50 -= 3;
            }
            while (v50 != v49);
            std::vector<int>::pointer v51 = v54;
          }
          uint64_t v55 = v49;
          operator delete(v51);
        }
        if (__p)
        {
          *(void *)&long long v58 = __p;
          operator delete(__p);
        }
        uint64_t v42 = 1;
        uint64_t v43 = (void **)v60;
        if (!v60) {
          return v42;
        }
LABEL_33:
        char v61 = v43;
        operator delete(v43);
        return v42;
      }
      char v54 = *v14;
      uint64_t v17 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)v9, LocationForOp, (uint64_t *)&v54, &ArgValue);
      if (!*((_DWORD *)v17 + 9)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
      std::vector<int>::size_type v18 = (char *)v17 - 16;
      int32x4_t v19 = (unsigned char *)v58;
      if ((unint64_t)v58 < *((void *)&v58 + 1))
      {
        *(void *)long long v58 = v18;
        uint64_t v16 = (uint64_t)(v19 + 8);
        goto LABEL_5;
      }
      uint64_t v20 = v9;
      uint64_t v21 = LocationForOp;
      uint64_t v22 = __p;
      uint64_t v23 = v58 - (void)__p;
      uint64_t v24 = (uint64_t)(v58 - (void)__p) >> 3;
      unint64_t v25 = v24 + 1;
      if ((unint64_t)(v24 + 1) >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v26 = *((void *)&v58 + 1) - (void)__p;
      if ((uint64_t)(*((void *)&v58 + 1) - (void)__p) >> 2 > v25) {
        unint64_t v25 = v26 >> 2;
      }
      if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v27 = v25;
      }
      if (v27)
      {
        if (v27 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        unint64_t v28 = v27;
        BOOL v29 = operator new(8 * v27);
        unint64_t v27 = v28;
        std::vector<int>::size_type v30 = &v29[8 * v24];
        *std::vector<int>::size_type v30 = v18;
        uint64_t v16 = (uint64_t)(v30 + 1);
        int64_t v31 = v19 - v22;
        if (v19 != v22)
        {
LABEL_18:
          unint64_t v32 = v31 - 8;
          if (v32 < 0x58)
          {
            uint64_t LocationForOp = v21;
            std::vector<int>::size_type v9 = v20;
            goto LABEL_27;
          }
          unint64_t v33 = v19 - &v29[v23];
          uint64_t LocationForOp = v21;
          std::vector<int>::size_type v9 = v20;
          if (v33 < 0x20) {
            goto LABEL_55;
          }
          uint64_t v34 = (v32 >> 3) + 1;
          uint64_t v35 = 8 * (v34 & 0x3FFFFFFFFFFFFFFCLL);
          float32x4_t v36 = &v19[-v35];
          std::vector<int>::size_type v30 = (void *)((char *)v30 - v35);
          uint64_t v37 = &v29[8 * v24 - 16];
          uint64_t v38 = (long long *)(v19 - 16);
          uint64_t v39 = v34 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v40 = *v38;
            *(v37 - 1) = *(v38 - 1);
            *uint64_t v37 = v40;
            v37 -= 2;
            v38 -= 2;
            v39 -= 4;
          }
          while (v39);
          int32x4_t v19 = v36;
          if (v34 != (v34 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_55:
            do
            {
LABEL_27:
              uint64_t v41 = *((void *)v19 - 1);
              v19 -= 8;
              *--std::vector<int>::size_type v30 = v41;
            }
            while (v19 != v22);
          }
          int32x4_t v19 = __p;
          __p = v30;
          *(void *)&long long v58 = v16;
          *((void *)&v58 + 1) = &v29[8 * v27];
          if (!v19) {
            goto LABEL_5;
          }
LABEL_29:
          operator delete(v19);
          goto LABEL_5;
        }
      }
      else
      {
        BOOL v29 = 0;
        std::vector<int>::size_type v30 = (void *)(8 * v24);
        *(void *)(8 * v24) = v18;
        uint64_t v16 = 8 * v24 + 8;
        int64_t v31 = v19 - v22;
        if (v19 != v22) {
          goto LABEL_18;
        }
      }
      uint64_t LocationForOp = v21;
      std::vector<int>::size_type v9 = v20;
      __p = v30;
      *(void *)&long long v58 = v16;
      *((void *)&v58 + 1) = &v29[8 * v27];
      if (v19) {
        goto LABEL_29;
      }
LABEL_5:
      *(void *)&long long v58 = v16;
      ++v14;
    }
  }
  __p = operator new(0x20uLL);
  long long v58 = xmmword_181129E30;
  strcpy((char *)__p, "unexpected type for axis");
  MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v58) < 0) {
    operator delete(__p);
  }
  uint64_t v42 = 0;
  uint64_t v43 = (void **)v60;
  if (v60) {
    goto LABEL_33;
  }
  return v42;
}

void sub_180D41FA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24)
{
  if (__p) {
    operator delete(__p);
  }
  if (a23) {
    operator delete(a23);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MILToMLIR::InversePattern::matchAndRewrite(MILToMLIR::InversePattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v25 = ArgValue;
  OptionalArguint64_t Value = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "epsilon");
  if (!OptionalArgValue)
  {
    uint64_t v8 = mlir::Float32Type::get(a3[18], v7);
    __p = (void *)1;
    std::vector<int>::size_type v9 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&__p, 1, v8, 0);
    __p = (void *)mlir::mps::getConstantAttr<double>(v9, 0.0001);
    int v10 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)&__p);
    if (!*((_DWORD *)v10 + 9)) {
      goto LABEL_19;
    }
    OptionalArguint64_t Value = (uint64_t)v10 - 16;
  }
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
  __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
  uint64_t v12 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, &OptionalArgValue, (uint64_t *)&__p);
  if (!*((_DWORD *)v12 + 9)) {
LABEL_19:
  }
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  OptionalArguint64_t Value = (uint64_t)v12 - 16;
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v21 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(a3 + 18, LocationForOp, &v25, &OptionalArgValue);
    int v13 = mlir::OpBuilder::create<mlir::mps::ReciprocalOp,mlir::mps::AddOp &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &v21);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v13 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v14 = (long long *)__p;
    std::vector<int>::value_type v15 = (char *)operator new(8uLL);
    *(void *)std::vector<int>::value_type v15 = (char *)v13 - 16;
    uint64_t v26 = v14;
    uint64_t v16 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v14, (uint64_t)&std::piecewise_construct, &v26);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v16 + 5, v15, v15 + 8, 1uLL);
    operator delete(v15);
    uint64_t v17 = (void **)__p;
    if (__p)
    {
      std::vector<int>::size_type v18 = (void **)v23;
      int32x4_t v19 = __p;
      if ((void *)v23 != __p)
      {
        do
        {
          if (*((char *)v18 - 1) < 0) {
            operator delete(*(v18 - 3));
          }
          v18 -= 3;
        }
        while (v18 != v17);
        int32x4_t v19 = __p;
      }
      *(void *)&long long v23 = v17;
      operator delete(v19);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v23 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    if (SHIBYTE(v23) < 0) {
      operator delete(__p);
    }
    return 0;
  }
}

void sub_180D42328(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

mlir::GenericProgramPoint *mlir::mps::getConstant<int,double>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, double a4)
{
  uint64_t Constant = 1;
  uint64_t v7 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&Constant, 1, a3, 0);
  uint64_t Constant = mlir::mps::getConstantAttr<double>(v7, a4);
  return mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(a1, a2, (uint64_t **)&Constant);
}

uint64_t MILToMLIR::LogarithmPattern::matchAndRewrite(MILToMLIR::LogarithmPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v25 = ArgValue;
  OptionalArguint64_t Value = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "epsilon");
  if (!OptionalArgValue)
  {
    uint64_t v8 = mlir::Float32Type::get(a3[18], v7);
    __p = (void *)1;
    std::vector<int>::size_type v9 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&__p, 1, v8, 0);
    __p = (void *)mlir::mps::getConstantAttr<double>(v9, 1.0e-45);
    int v10 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)&__p);
    if (!*((_DWORD *)v10 + 9)) {
      goto LABEL_19;
    }
    OptionalArguint64_t Value = (uint64_t)v10 - 16;
  }
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
  __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
  uint64_t v12 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, &OptionalArgValue, (uint64_t *)&__p);
  if (!*((_DWORD *)v12 + 9)) {
LABEL_19:
  }
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  OptionalArguint64_t Value = (uint64_t)v12 - 16;
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v21 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(a3 + 18, LocationForOp, &v25, &OptionalArgValue);
    int v13 = mlir::OpBuilder::create<mlir::mps::LogarithmOp,mlir::mps::AddOp &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &v21);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v13 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v14 = (long long *)__p;
    std::vector<int>::value_type v15 = (char *)operator new(8uLL);
    *(void *)std::vector<int>::value_type v15 = (char *)v13 - 16;
    uint64_t v26 = v14;
    uint64_t v16 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v14, (uint64_t)&std::piecewise_construct, &v26);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v16 + 5, v15, v15 + 8, 1uLL);
    operator delete(v15);
    uint64_t v17 = (void **)__p;
    if (__p)
    {
      std::vector<int>::size_type v18 = (void **)v23;
      int32x4_t v19 = __p;
      if ((void *)v23 != __p)
      {
        do
        {
          if (*((char *)v18 - 1) < 0) {
            operator delete(*(v18 - 3));
          }
          v18 -= 3;
        }
        while (v18 != v17);
        int32x4_t v19 = __p;
      }
      *(void *)&long long v23 = v17;
      operator delete(v19);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v23 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    if (SHIBYTE(v23) < 0) {
      operator delete(__p);
    }
    return 0;
  }
}

void sub_180D426CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MILToMLIR::RsqrtPattern::matchAndRewrite(MILToMLIR::RsqrtPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v25 = ArgValue;
  OptionalArguint64_t Value = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "epsilon");
  if (!OptionalArgValue)
  {
    uint64_t v8 = mlir::Float32Type::get(a3[18], v7);
    __p = (void *)1;
    std::vector<int>::size_type v9 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&__p, 1, v8, 0);
    __p = (void *)mlir::mps::getConstantAttr<double>(v9, 1.0e-12);
    int v10 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)&__p);
    if (!*((_DWORD *)v10 + 9)) {
      goto LABEL_19;
    }
    OptionalArguint64_t Value = (uint64_t)v10 - 16;
  }
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
  __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
  uint64_t v12 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, &OptionalArgValue, (uint64_t *)&__p);
  if (!*((_DWORD *)v12 + 9)) {
LABEL_19:
  }
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  OptionalArguint64_t Value = (uint64_t)v12 - 16;
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v21 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(a3 + 18, LocationForOp, &v25, &OptionalArgValue);
    int v13 = mlir::OpBuilder::create<mlir::mps::ReciprocalSquareRootOp,mlir::mps::AddOp &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &v21);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v13 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v14 = (long long *)__p;
    std::vector<int>::value_type v15 = (char *)operator new(8uLL);
    *(void *)std::vector<int>::value_type v15 = (char *)v13 - 16;
    uint64_t v26 = v14;
    uint64_t v16 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v14, (uint64_t)&std::piecewise_construct, &v26);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v16 + 5, v15, v15 + 8, 1uLL);
    operator delete(v15);
    uint64_t v17 = (void **)__p;
    if (__p)
    {
      std::vector<int>::size_type v18 = (void **)v23;
      int32x4_t v19 = __p;
      if ((void *)v23 != __p)
      {
        do
        {
          if (*((char *)v18 - 1) < 0) {
            operator delete(*(v18 - 3));
          }
          v18 -= 3;
        }
        while (v18 != v17);
        int32x4_t v19 = __p;
      }
      *(void *)&long long v23 = v17;
      operator delete(v19);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v23 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    if (SHIBYTE(v23) < 0) {
      operator delete(__p);
    }
    return 0;
  }
}

void sub_180D42A04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MILToMLIR::Range1dPattern::matchAndRewrite(MILToMLIR::Range1dPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "start");
  uint64_t v44 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "end");
  uint64_t v43 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "step");
  long long v6 = mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::Value &>(a3 + 18, LocationForOp, &v44, &ArgValue);
  if (!*((_DWORD *)v6 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v42 = (uint64_t)v6 - 16;
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf((uint64_t)v6 - 16);
  if (mlir::Type::isIntOrIndex((mlir::Type *)&ElementTypeOrSelf))
  {
    __p = (void *)1;
    uint64_t v7 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&__p, 1, ElementTypeOrSelf, 0);
    __p = (void *)mlir::mps::getConstantAttr<int>(v7, 1);
    uint64_t v8 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)&__p);
    std::vector<int>::size_type v9 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(a3 + 18, LocationForOp, &v42, &v43);
    if (!*((_DWORD *)v9 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v46 = LocationForOp;
    uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v46);
    uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.subtract", (const unsigned __int8 *)0xC, Context);
    if (!v12)
    {
      __int16 v50 = 1283;
      v49[2] = (uint64_t)"mps.subtract";
      v49[3] = 12;
                        " been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loade"
                        "d-dependent-whats-up-with-dialects-management";
      __int16 v48 = 259;
      llvm::operator+(v49, v47, (uint64_t)v51);
      llvm::report_fatal_error((llvm::Twine *)v51, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v11);
    if (!*((_DWORD *)v8 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    mlir::mps::ATan2Op::build(a3 + 18, (uint64_t)&__p, (uint64_t)v9 - 16, (uint64_t)v8 - 16);
    int v13 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    if (v13)
    {
      uint64_t v14 = llvm::DefaultDoCastIfPossible<mlir::mps::SubtractOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SubtractOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
      if (v14)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        if (!*(_DWORD *)(v14 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        __p = (void *)(v14 - 16);
        std::vector<int>::value_type v15 = mlir::OpBuilder::create<mlir::mps::DivideOp,mlir::Value &,mlir::Value &>(a3 + 18, LocationForOp, (uint64_t *)&__p, &v43);
        if (!*((_DWORD *)v15 + 9)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        goto LABEL_14;
      }
      float32x4_t v36 = "result && \"builder didn't return the right type\"";
      int v37 = 497;
      uint64_t v38 = "Builders.h";
      uint64_t v39 = "create";
    }
    else
    {
      float32x4_t v36 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v37 = 662;
      uint64_t v38 = "Casting.h";
      uint64_t v39 = "dyn_cast";
    }
    __assert_rtn(v39, v38, v37, v36);
  }
  uint64_t v16 = mlir::OpBuilder::create<mlir::mps::DivideOp,mlir::Value &,mlir::Value &>(a3 + 18, LocationForOp, &v42, &v43);
  if (!*((_DWORD *)v16 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  __p = (char *)v16 - 16;
  uint64_t v17 = mlir::OpBuilder::create<mlir::mps::CeilOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t *)&__p);
  if (!*(_DWORD *)(v17 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  v51[0] = (long long *)(v17 - 16);
  uint64_t v18 = mlir::IntegerType::get((uint64_t)a3[18], 0x20u, 1u);
  v49[0] = mlir::TypeAttr::get(v18);
  std::vector<int>::value_type v15 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, (uint64_t *)v51, v49);
  if (!*((_DWORD *)v15 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
LABEL_14:
  uint64_t v40 = (uint64_t)v15 - 16;
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 18), 0x20u, 1);
  uint64_t v20 = (uint64_t **)mlir::RankedTensorType::get(0, 0, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v20)) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v20)
  {
    uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v20);
    if (!InterfaceFor) {
      __assert_rtn("Interface", "InterfaceSupport.h", 98, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
    }
  }
  else
  {
    uint64_t InterfaceFor = 0;
  }
  LODWORD(v51[0]) = 0;
  uint64_t v22 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v20, InterfaceFor, v51, 4, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v22) & 1) == 0) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  __p = v22;
  long long v23 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)&__p);
  if (!*((_DWORD *)v23 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  v49[0] = (uint64_t)v23 - 16;
  uint64_t v24 = mlir::OpBuilder::create<mlir::mps::GetCoordOp,mlir::Value &,mlir::Value &>((uint64_t *)a3 + 18, LocationForOp, &v40, v49);
  if (!*((_DWORD *)v24 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  v47[0] = (uint64_t)v24 - 16;
  uint64_t v25 = mlir::getElementTypeOrSelf((uint64_t)v24 - 16);
  if (ElementTypeOrSelf != v25)
  {
    uint64_t v26 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a3 + 18, LocationForOp, v47, &ElementTypeOrSelf);
    if (!*((_DWORD *)v26 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    v47[0] = (uint64_t)v26 - 16;
  }
  unint64_t v27 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>(a3 + 18, LocationForOp, &v43, v47);
  if (!*((_DWORD *)v27 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v46 = (uint64_t)v27 - 16;
  unint64_t v28 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(a3 + 18, LocationForOp, &v46, &ArgValue);
  if (!*((_DWORD *)v28 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
  BOOL v29 = (long long *)__p;
  std::vector<int>::size_type v30 = (char *)operator new(8uLL);
  *(void *)std::vector<int>::size_type v30 = (char *)v28 - 16;
  v51[0] = v29;
  int64_t v31 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v29, (uint64_t)&std::piecewise_construct, v51);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v31 + 5, v30, v30 + 8, 1uLL);
  operator delete(v30);
  unint64_t v32 = (void **)__p;
  if (__p)
  {
    unint64_t v33 = v53;
    uint64_t v34 = __p;
    if (v53 != __p)
    {
      do
      {
        if (*((char *)v33 - 1) < 0) {
          operator delete(*(v33 - 3));
        }
        v33 -= 3;
      }
      while (v33 != v32);
      uint64_t v34 = __p;
    }
    uint64_t v53 = v32;
    operator delete(v34);
  }
  return 1;
}

void sub_180D4319C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32)
{
}

void sub_180D431B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32)
{
  operator delete(v32);
  std::vector<std::string>::~vector[abi:ne180100](&a32);
  _Unwind_Resume(a1);
}

void sub_180D431CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
}

void sub_180D431E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::CeilOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.ceil", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.ceil";
    v19[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  std::vector<int>::size_type v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    char v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    uint64_t v14 = "Casting.h";
    std::vector<int>::value_type v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::CeilOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CeilOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    char v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    uint64_t v14 = "Builders.h";
    std::vector<int>::value_type v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180D4336C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D43384(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t MILToMLIR::RandomPattern::matchAndRewrite(MILToMLIR::RandomPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  v141[3] = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "shape");
  char v133 = 4;
  strcpy((char *)&__p, "seed");
  MIL::IROperation::TryGetParameterValue();
  int v6 = MIL::IRValue::GetScalar<int>();
  uint64_t v112 = (MILToMLIRRewriter *)a3;
  srand48(v6);
  uint64_t v7 = mrand48();
  unsigned int v8 = mrand48();
  uint64_t v9 = mrand48();
  unsigned int v10 = mrand48();
  uint64_t v11 = mrand48();
  unsigned int v12 = mrand48();
  int v13 = (mlir::OpBuilder *)(a3 + 18);
  uint64_t v139 = 1;
  uint64_t IntegerType = mlir::Builder::getIntegerType((MILToMLIRRewriter *)((char *)v112 + 144), 0x40u, 1);
  std::vector<int>::value_type v15 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&v139, 1, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v15)) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v15)
  {
    uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v15);
    if (!InterfaceFor) {
      __assert_rtn("Interface", "InterfaceSupport.h", 98, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
    }
  }
  else
  {
    uint64_t InterfaceFor = 0;
  }
  uint64_t v134 = (const char *)(v8 | (unint64_t)(v7 << 32));
  uint64_t v17 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v15, InterfaceFor, &v134, 8, 8, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v17) & 1) == 0) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  __p = v17;
  __int16 v18 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v13, LocationForOp, (uint64_t **)&__p);
  if (!*((_DWORD *)v18 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v120 = (uint64_t)v18 - 16;
  uint64_t v139 = 1;
  uint64_t v19 = mlir::Builder::getIntegerType(v13, 0x40u, 1);
  __int16 v20 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&v139, 1, v19, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v20)) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v20)
  {
    uint64_t v21 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v20);
    if (!v21) {
      __assert_rtn("Interface", "InterfaceSupport.h", 98, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
    }
  }
  else
  {
    uint64_t v21 = 0;
  }
  uint64_t v134 = (const char *)(v10 | (unint64_t)(v9 << 32));
  uint64_t v22 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v20, v21, &v134, 8, 8, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v22) & 1) == 0) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  __p = v22;
  long long v23 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v13, LocationForOp, (uint64_t **)&__p);
  if (!*((_DWORD *)v23 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v119 = (uint64_t)v23 - 16;
  uint64_t v139 = 1;
  uint64_t v24 = mlir::Builder::getIntegerType(v13, 0x40u, 1);
  uint64_t v25 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&v139, 1, v24, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v25)) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v25)
  {
    uint64_t v26 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v25);
    if (!v26) {
      __assert_rtn("Interface", "InterfaceSupport.h", 98, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
    }
  }
  else
  {
    uint64_t v26 = 0;
  }
  uint64_t v134 = (const char *)(v12 | (unint64_t)(v11 << 32));
  unint64_t v27 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v25, v26, &v134, 8, 8, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v27) & 1) == 0) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  __p = v27;
  unint64_t v28 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v13, LocationForOp, (uint64_t **)&__p);
  if (!*((_DWORD *)v28 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v118 = (uint64_t)v28 - 16;
  uint64_t v29 = mlir::OpBuilder::create<mlir::mps::InitRandomPhiloxStateOp,mlir::Value &,mlir::Value &,mlir::Value &>((uint64_t *)v13, LocationForOp, &v120, &v119, &v118);
  if (!*(_DWORD *)(v29 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v117 = v29 - 16;
  uint64_t v30 = (*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 56))(a2);
  if (*(char *)(v30 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v116, *(const std::string::value_type **)v30, *(void *)(v30 + 8));
  }
  else
  {
    long long v31 = *(_OWORD *)v30;
    v116.__r_.__value_.__r.__words[2] = *(void *)(v30 + 16);
    *(_OWORD *)&v116.__r_.__value_.__l.__data_ = v31;
  }
  uint64_t v115 = 0;
  if ((v116.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int64_t size = HIBYTE(v116.__r_.__value_.__r.__words[2]);
  }
  else {
    int64_t size = v116.__r_.__value_.__l.__size_;
  }
  if ((v116.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v33 = &v116;
  }
  else {
    unint64_t v33 = (std::string *)v116.__r_.__value_.__r.__words[0];
  }
  uint64_t v34 = (char *)v33 + size;
  if (size <= 13) {
    goto LABEL_69;
  }
  int64_t v35 = size;
  float32x4_t v36 = v33;
  while (1)
  {
    int v37 = (char *)memchr(v36, 114, v35 - 13);
    if (!v37) {
      goto LABEL_44;
    }
    if (*(void *)v37 == 0x755F6D6F646E6172 && *(void *)(v37 + 6) == 0x6D726F66696E755FLL) {
      break;
    }
    float32x4_t v36 = (std::string *)(v37 + 1);
    int64_t v35 = v34 - (char *)v36;
    if (v34 - (char *)v36 < 14) {
      goto LABEL_44;
    }
  }
  if (v37 != v34 && v37 - (char *)v33 != -1)
  {
    uint64_t v125 = 0;
    uint64_t v122 = 0;
    uint64_t v113 = 0;
    uint64_t v114 = 0;
    uint64_t v125 = MILToMLIRRewriter::getArgValue((int8x8_t *)v112, a2, "low");
    uint64_t v122 = MILToMLIRRewriter::getArgValue((int8x8_t *)v112, a2, "high");
    uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v125);
    int v40 = 0;
    goto LABEL_58;
  }
LABEL_44:
  if (size < 16) {
    goto LABEL_69;
  }
  int64_t v41 = size;
  uint64_t v42 = v33;
  while (1)
  {
    uint64_t v43 = (char *)memchr(v42, 114, v41 - 15);
    if (!v43) {
      goto LABEL_69;
    }
    if (*(void *)v43 == 0x625F6D6F646E6172 && *((void *)v43 + 1) == 0x696C6C756F6E7265) {
      break;
    }
    uint64_t v42 = (std::string *)(v43 + 1);
    int64_t v41 = v34 - (char *)v42;
    if (v34 - (char *)v42 < 16) {
      goto LABEL_69;
    }
  }
  if (v43 == v34 || v43 - (char *)v33 == -1)
  {
LABEL_69:
    if (size < 13) {
      goto LABEL_116;
    }
    unint64_t v65 = v33;
    while (1)
    {
      uint64_t v66 = (char *)memchr(v65, 114, size - 12);
      if (!v66) {
        goto LABEL_116;
      }
      if (*(void *)v66 == 0x6E5F6D6F646E6172 && *(void *)(v66 + 5) == 0x6C616D726F6E5F6DLL) {
        break;
      }
      unint64_t v65 = (std::string *)(v66 + 1);
      int64_t size = v34 - (char *)v65;
      if (v34 - (char *)v65 < 13) {
        goto LABEL_116;
      }
    }
    if (v66 == v34 || v66 - (char *)v33 == -1) {
      goto LABEL_116;
    }
    char v133 = 4;
    strcpy((char *)&__p, "mean");
    Parameteruint64_t Value = MIL::IROperation::GetParameterValue();
    if (v133 < 0) {
      operator delete(__p);
    }
    uint64_t v69 = (float *)MEMORY[0x1852FD7D0](ParameterValue);
    if (v69)
    {
      float v70 = *v69;
    }
    else
    {
      int64_t v71 = (int *)MEMORY[0x1852FD7E0](ParameterValue);
      if (v71)
      {
        float v70 = (float)*v71;
      }
      else
      {
        unint64_t v72 = (MIL::Fp16 *)MEMORY[0x1852FD7C0](ParameterValue);
        if (!v72)
        {
          std::string::basic_string[abi:ne180100]<0>(&__p, "unexpected type for mean");
          MILToMLIRRewriter::notifyFailure((uint64_t)v112, (uint64_t)a2, (const std::string::value_type *)&__p);
          goto LABEL_129;
        }
        MIL::Fp16::GetFloat(v72);
        float v70 = v73;
      }
    }
    char v133 = 6;
    strcpy((char *)&__p, "stddev");
    uint64_t v74 = MIL::IROperation::GetParameterValue();
    if (v133 < 0) {
      operator delete(__p);
    }
    unint64_t v75 = (float *)MEMORY[0x1852FD7D0](v74);
    if (v75)
    {
      float v76 = *v75;
      goto LABEL_96;
    }
    uint64_t v77 = (int *)MEMORY[0x1852FD7E0](v74);
    if (v77)
    {
      float v76 = (float)*v77;
      goto LABEL_96;
    }
    int v78 = (MIL::Fp16 *)MEMORY[0x1852FD7C0](v74);
    if (v78)
    {
      MIL::Fp16::GetFloat(v78);
      float v76 = v79;
LABEL_96:
      uint64_t v80 = MILToMLIRRewriter::getArgValue((int8x8_t *)v112, a2, "mean");
      uint64_t v81 = mlir::getElementTypeOrSelf(v80);
      int v82 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)&__p, v70);
      uint64_t v83 = llvm::APFloatBase::IEEEsingle(v82);
      llvm::APFloat::Storage::Storage(&v129, &__p, v83);
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&__p);
      llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)&__p, v76);
      llvm::APFloat::Storage::Storage(&v126, &__p, v83);
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&__p);
      uint64_t v122 = LocationForOp;
      uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v122);
      uint64_t v85 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.random_normal", (const unsigned __int8 *)0x11, Context);
      if (!v86)
      {
        __int16 v138 = 1283;
        std::vector<int> v136 = "mps.random_normal";
        uint64_t v137 = 17;
                           "n't been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered"
                           "-loaded-dependent-whats-up-with-dialects-management";
        __int16 v124 = 259;
        llvm::operator+((uint64_t *)&v134, v123, (uint64_t)&v139);
        llvm::report_fatal_error((llvm::Twine *)&v139, 1);
      }
      mlir::OperationState::OperationState(&__p, LocationForOp, v85);
      uint64_t v87 = v117;
      uint64_t v88 = ArgValue;
      uint64_t v89 = v129;
      unsigned int v91 = llvm::APFloatBase::PPCDoubleDouble(v90);
      if (v91 == v89)
      {
        uint64_t v92 = v81;
        llvm::detail::DoubleAPFloat::DoubleAPFloat(&v140, &v129);
      }
      else
      {
        uint64_t v92 = v81;
        llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v140, (uint64_t)&v129);
      }
      if (v91 == v126) {
        llvm::detail::DoubleAPFloat::DoubleAPFloat(&v135, &v126);
      }
      else {
        llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v135, (uint64_t)&v126);
      }
      mlir::mps::RandomNormalOp::build((mlir::Float32Type **)v13, (uint64_t)&__p, v87, v88, v92, (uint64_t)&v139, (uint64_t)&v134, 0);
      if (v91 == v135)
      {
        std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)&v136);
        if (v91 != v140) {
          goto LABEL_105;
        }
      }
      else
      {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v135);
        if (v91 != v140)
        {
LABEL_105:
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v140);
          goto LABEL_108;
        }
      }
      std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v141);
LABEL_108:
      uint64_t v93 = mlir::OpBuilder::create(v13, (const mlir::OperationState *)&__p);
      if (v93)
      {
        uint64_t v94 = llvm::DefaultDoCastIfPossible<mlir::mps::RandomNormalOp,mlir::Operation *,llvm::CastInfo<mlir::mps::RandomNormalOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v93);
        if (v94)
        {
          mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
          if (!*(_DWORD *)(v94 + 36)) {
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          }
          uint64_t v115 = v94 - 16;
          if (v91 == v126)
          {
            std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)&v127);
            if (v91 != v129) {
              goto LABEL_113;
            }
          }
          else
          {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v126);
            if (v91 != v129)
            {
LABEL_113:
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v129);
              goto LABEL_116;
            }
          }
          std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)&v130);
          goto LABEL_116;
        }
        uint64_t v104 = "result && \"builder didn't return the right type\"";
        int v105 = 497;
        __int16 v106 = "Builders.h";
        unint64_t v107 = "create";
      }
      else
      {
        uint64_t v104 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
        int v105 = 662;
        __int16 v106 = "Casting.h";
        unint64_t v107 = "dyn_cast";
      }
      __assert_rtn(v107, v106, v105, v104);
    }
    std::string::basic_string[abi:ne180100]<0>(&__p, "unexpected type for stddev");
    MILToMLIRRewriter::notifyFailure((uint64_t)v112, (uint64_t)a2, (const std::string::value_type *)&__p);
LABEL_129:
    if (v133 < 0) {
      operator delete(__p);
    }
    uint64_t v102 = 0;
    if (SHIBYTE(v116.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_125;
    }
    return v102;
  }
  uint64_t v125 = 0;
  uint64_t v122 = 0;
  uint64_t v113 = 0;
  uint64_t v114 = 0;
  uint64_t v46 = mlir::Float16Type::get(*(mlir::Float16Type **)v13, v44);
  __p = (void *)1;
  BOOL v47 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&__p, 1, v46, 0);
  __p = (void *)mlir::mps::getConstantAttr<float>(v47, 0.0);
  __int16 v48 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v13, LocationForOp, (uint64_t **)&__p);
  if (!*((_DWORD *)v48 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v125 = (uint64_t)v48 - 16;
  uint64_t v50 = mlir::Float16Type::get(*(mlir::Float16Type **)v13, v49);
  __p = (void *)1;
  std::vector<int>::pointer v51 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&__p, 1, v50, 0);
  __p = (void *)mlir::mps::getConstantAttr<float>(v51, 1.0);
  float v52 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v13, LocationForOp, (uint64_t **)&__p);
  if (!*((_DWORD *)v52 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v122 = (uint64_t)v52 - 16;
  uint64_t v114 = MILToMLIRRewriter::getArgValue((int8x8_t *)v112, a2, "prob");
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v114);
  int v40 = 1;
LABEL_58:
  uint64_t v113 = ElementTypeOrSelf;
  uint64_t v53 = mlir::OpBuilder::create<mlir::mps::RandomUniformOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Type &>(v13, LocationForOp, &v117, &ArgValue, &v125, &v122, &v113);
  if (!*(_DWORD *)(v53 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v115 = v53 - 16;
  if (v40)
  {
    __p = (void *)1;
    uint64_t v54 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&__p, 1, v113, 0);
    __p = (void *)mlir::mps::getConstantAttr<float>(v54, 0.0);
    uint64_t v55 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v13, LocationForOp, (uint64_t **)&__p);
    __p = (void *)1;
    uint64_t v56 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&__p, 1, v113, 0);
    __p = (void *)mlir::mps::getConstantAttr<float>(v56, 1.0);
    uint64_t v57 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v13, LocationForOp, (uint64_t **)&__p);
    long long v58 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)v13, LocationForOp, &v115, &v113);
    if (!*((_DWORD *)v58 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v115 = (uint64_t)v58 - 16;
    int v59 = mlir::OpBuilder::create<mlir::mps::LessThanOp,mlir::Value &,mlir::Value &>(v13, LocationForOp, &v115, &v114);
    uint64_t v128 = LocationForOp;
    uint64_t v60 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v128);
    uint64_t v61 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.select", (const unsigned __int8 *)0xA, v60);
    if (!v62)
    {
      __int16 v138 = 1283;
      std::vector<int> v136 = "mps.select";
      uint64_t v137 = 10;
                         "t been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loa"
                         "ded-dependent-whats-up-with-dialects-management";
      __int16 v124 = 259;
      llvm::operator+((uint64_t *)&v134, v123, (uint64_t)&v139);
      llvm::report_fatal_error((llvm::Twine *)&v139, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v61);
    if (!*((_DWORD *)v59 + 9) || !*((_DWORD *)v57 + 9) || !*((_DWORD *)v55 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    mlir::mps::SelectOp::build((uint64_t)v13, (uint64_t)&__p, (uint64_t)v59 - 16, (uint64_t)v57 - 16, (uint64_t)v55 - 16);
    int64_t v63 = mlir::OpBuilder::create(v13, (const mlir::OperationState *)&__p);
    if (v63)
    {
      uint64_t v64 = llvm::DefaultDoCastIfPossible<mlir::mps::SelectOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SelectOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v63);
      if (v64)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        if (!*(_DWORD *)(v64 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        uint64_t v115 = v64 - 16;
        goto LABEL_116;
      }
      int v108 = "result && \"builder didn't return the right type\"";
      int v109 = 497;
      uint64_t v110 = "Builders.h";
      uint64_t v111 = "create";
    }
    else
    {
      int v108 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v109 = 662;
      uint64_t v110 = "Casting.h";
      uint64_t v111 = "dyn_cast";
    }
    __assert_rtn(v111, v110, v109, v108);
  }
LABEL_116:
  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
  int v95 = (long long *)__p;
  uint64_t v96 = v115;
  int v97 = (char *)operator new(8uLL);
  *(void *)int v97 = v96;
  uint64_t v139 = (uint64_t)v95;
  uint64_t v98 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v112 + 64, (uint64_t)v95, (uint64_t)&std::piecewise_construct, (long long **)&v139);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v98 + 5, v97, v97 + 8, 1uLL);
  operator delete(v97);
  unint64_t v99 = (void **)__p;
  if (__p)
  {
    BOOL v100 = v132;
    unint64_t v101 = __p;
    if (v132 != __p)
    {
      do
      {
        if (*((char *)v100 - 1) < 0) {
          operator delete(*(v100 - 3));
        }
        v100 -= 3;
      }
      while (v100 != v99);
      unint64_t v101 = __p;
    }
    int v132 = v99;
    operator delete(v101);
  }
  uint64_t v102 = 1;
  if (SHIBYTE(v116.__r_.__value_.__r.__words[2]) < 0) {
LABEL_125:
  }
    operator delete(v116.__r_.__value_.__l.__data_);
  return v102;
}

void sub_180D443F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,void *__p,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  if (a43 < 0) {
    operator delete(__p);
  }
  if (a18 < 0)
  {
    operator delete(a13);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::InitRandomPhiloxStateOp,mlir::Value &,mlir::Value &,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  v26[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.init_random_philox_state", (const unsigned __int8 *)0x1C, Context);
  if (!v12)
  {
    __int16 v24 = 1283;
    v23[2] = (uint64_t)"mps.init_random_philox_state";
    v23[3] = 28;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v11);
  mlir::mps::InitRandomPhiloxStateOp::build(a1, (uint64_t)v26, *a3, *a4, *a5);
  int v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v26);
  if (!v13)
  {
    uint64_t v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v17 = 662;
    __int16 v18 = "Casting.h";
    uint64_t v19 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v14 = llvm::DefaultDoCastIfPossible<mlir::mps::InitRandomPhiloxStateOp,mlir::Operation *,llvm::CastInfo<mlir::mps::InitRandomPhiloxStateOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    uint64_t v16 = "result && \"builder didn't return the right type\"";
    int v17 = 497;
    __int16 v18 = "Builders.h";
    uint64_t v19 = "create";
LABEL_8:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v14;
}

void sub_180D446F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D4470C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

mlir::GenericProgramPoint *mlir::mps::getConstant<int,float>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3)
{
  uint64_t Constant = 1;
  size_t v5 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&Constant, 1, a3, 0);
  uint64_t Constant = mlir::mps::getConstantAttr<float>(v5, -3.4028e38);
  return mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(a1, a2, (uint64_t **)&Constant);
}

uint64_t mlir::OpBuilder::create<mlir::mps::RandomUniformOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Type &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  v30[38] = *MEMORY[0x1E4F143B8];
  uint64_t v24 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  uint64_t v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.random_uniform", (const unsigned __int8 *)0x12, Context);
  if (!v16)
  {
    __int16 v28 = 1283;
    v27[2] = (uint64_t)"mps.random_uniform";
    v27[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v15);
  mlir::mps::RandomUniformOp::build((uint64_t)a1, (uint64_t)v30, *a3, *a4, *a5, *a6, *a7);
  int v17 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v30);
  if (!v17)
  {
    uint64_t v20 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v21 = 662;
    __int16 v22 = "Casting.h";
    long long v23 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v18 = llvm::DefaultDoCastIfPossible<mlir::mps::RandomUniformOp,mlir::Operation *,llvm::CastInfo<mlir::mps::RandomUniformOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v17);
  if (!v18)
  {
    uint64_t v20 = "result && \"builder didn't return the right type\"";
    int v21 = 497;
    __int16 v22 = "Builders.h";
    long long v23 = "create";
LABEL_8:
    __assert_rtn(v23, v22, v21, v20);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v18;
}

void sub_180D44928(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D44940(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t MILToMLIR::ReversePattern::matchAndRewrite(MILToMLIR::ReversePattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  OptionalArguint64_t Value = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "axes");
  if (OptionalArgValue)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue, &OptionalArgValue);
    if (*(_DWORD *)(v6 + 36)) {
      goto LABEL_3;
    }
LABEL_13:
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v6 = mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t)&ArgValue);
  if (!*(_DWORD *)(v6 + 36)) {
    goto LABEL_13;
  }
LABEL_3:
  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
  uint64_t v7 = (long long *)__p;
  unsigned int v8 = (char *)operator new(8uLL);
  *(void *)unsigned int v8 = v6 - 16;
  uint64_t v18 = v7;
  uint64_t v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
  operator delete(v8);
  unsigned int v10 = (void **)__p;
  if (__p)
  {
    uint64_t v11 = v15;
    char v12 = __p;
    if (v15 != __p)
    {
      do
      {
        if (*((char *)v11 - 1) < 0) {
          operator delete(*(v11 - 3));
        }
        v11 -= 3;
      }
      while (v11 != v10);
      char v12 = __p;
    }
    uint64_t v15 = v10;
    operator delete(v12);
  }
  return 1;
}

void sub_180D44AF0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<std::string>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_180D44B04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  operator delete(v10);
  std::vector<std::string>::~vector[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v24[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reverse", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.reverse";
    v21[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  mlir::mps::ReverseOp::build((uint64_t)a1, (uint64_t)v24, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    uint64_t v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v15 = 662;
    char v16 = "Casting.h";
    int v17 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::ReverseOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReverseOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    uint64_t v14 = "result && \"builder didn't return the right type\"";
    int v15 = 497;
    char v16 = "Builders.h";
    int v17 = "create";
LABEL_8:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180D44C9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D44CB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reverse", (const unsigned __int8 *)0xB, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.reverse";
    v19[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ReverseOp::build((uint64_t)a1, (uint64_t)v22, a3, 1, 0, 0);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    uint64_t v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::ReverseOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReverseOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    uint64_t v14 = "Builders.h";
    int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180D44E48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D44E60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t MILToMLIR::Flatten2DPattern::matchAndRewrite(MILToMLIR::Flatten2DPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  int v24 = 1;
  char v23 = 4;
  strcpy((char *)&__p, "axis");
  if (MIL::IROperation::TryGetParameterValue()) {
    int v24 = MIL::IRValue::GetScalar<int>();
  }
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 18), 0x20u, 1);
  uint64_t v7 = (uint64_t **)mlir::RankedTensorType::get(0, 0, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v7)) {
    goto LABEL_20;
  }
  if (v7)
  {
    uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v7);
    if (!InterfaceFor) {
      __assert_rtn("Interface", "InterfaceSupport.h", 98, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
    }
  }
  else
  {
    uint64_t InterfaceFor = 0;
  }
  uint64_t v9 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v7, InterfaceFor, &v24, 4, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v9) & 1) == 0) {
LABEL_20:
  }
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  __p = v9;
  uint64_t v10 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)&__p);
  if (!*((_DWORD *)v10 + 9)
    || (uint64_t v20 = (uint64_t)v10 - 16,
        uint64_t v11 = mlir::OpBuilder::create<mlir::mps::Flatten2DOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue, &v20), !*((_DWORD *)v11 + 9)))
  {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v12 = v11;
  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
  int v13 = (long long *)__p;
  uint64_t v14 = (char *)operator new(8uLL);
  *(void *)uint64_t v14 = (char *)v12 - 16;
  __int16 v26 = v13;
  int v15 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v13, (uint64_t)&std::piecewise_construct, &v26);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v15 + 5, v14, v14 + 8, 1uLL);
  operator delete(v14);
  uint64_t v16 = (void **)__p;
  if (__p)
  {
    int v17 = v22;
    __int16 v18 = __p;
    if (v22 != __p)
    {
      do
      {
        if (*((char *)v17 - 1) < 0) {
          operator delete(*(v17 - 3));
        }
        v17 -= 3;
      }
      while (v17 != v16);
      __int16 v18 = __p;
    }
    __int16 v22 = v16;
    operator delete(v18);
  }
  return 1;
}

void sub_180D4510C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

BOOL MILToMLIR::TopKPattern::matchAndRewrite(MILToMLIR::TopKPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v115 = *MEMORY[0x1E4F143B8];
  std::string::size_type LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v101 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "k");
  strcpy((char *)__p, "axis");
  MIL::IROperation::GetParameterValue();
  unsigned int v7 = MIL::IRValue::GetScalar<int>();
  unsigned int v100 = v7;
  strcpy((char *)__p, "ascending");
  MIL::IROperation::GetParameterValue();
  int v8 = MIL::IRValue::GetScalar<BOOL>();
  HIBYTE(__p[2]) = 1;
  LOWORD(__p[0]) = 120;
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  uint64_t v10 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(ParameterType);
  uint64_t v98 = 0;
  uint64_t v99 = ArgValue;
  uint64_t v11 = MIL::IRTensorValueType::Rank(v10) - 1;
  _ZF = v7 == -1 || v11 == v7;
  char v13 = _ZF;
  if (!_ZF)
  {
    LODWORD(__p[0]) = -1;
    uint64_t v14 = mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int &,int>((mlir::mps::ConstantOp *)(a3 + 18), LocationForOp, &v99, &v100, (unsigned int *)__p);
    if (!*(_DWORD *)(v14 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v99 = v14 - 16;
  }
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
  if (v8)
  {
    if (mlir::Type::isSignedInteger((mlir::Type *)&ElementTypeOrSelf))
    {
      __p[0] = (void *)1;
      int v15 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, ElementTypeOrSelf, 0);
      __p[0] = (void *)mlir::mps::getConstantAttr<int>(v15, -1);
      uint64_t v16 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)__p);
      if (!*((_DWORD *)v16 + 9)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
      uint64_t v98 = (uint64_t)v16 - 16;
      uint64_t v17 = (uint64_t)mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::Value &>(a3 + 18, LocationForOp, &v98, &v99);
      if (!*(_DWORD *)(v17 + 36)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
LABEL_69:
      uint64_t v99 = v17 - 16;
      goto LABEL_70;
    }
    if (!mlir::Type::isUnsignedInteger((mlir::Type *)&ElementTypeOrSelf))
    {
      uint64_t v17 = mlir::OpBuilder::create<mlir::mps::NegativeOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &v99);
      if (!*(_DWORD *)(v17 + 36)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
      goto LABEL_69;
    }
    char IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf);
    __p[0] = (void *)1;
    uint64_t v19 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)__p, 1, ElementTypeOrSelf, 0);
    if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v19)) {
      __assert_rtn("cast", "Casting.h", 572, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
    }
    if (v19)
    {
      uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v19);
      if (!InterfaceFor) {
        __assert_rtn("Interface", "InterfaceSupport.h", 98, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
      }
    }
    else
    {
      uint64_t InterfaceFor = 0;
    }
    int v21 = (const char *)mlir::getElementTypeOrSelf(v19);
    if (!v21) {
      __assert_rtn("dyn_cast", "Casting.h", 650, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
    }
    if (!*(void *)v21) {
      __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
    }
    unint64_t v22 = 0xFFFFFFFFFFFFFFFFLL >> -IntOrFloatBitWidth;
    char v23 = *(void **)(*(void *)v21 + 136);
    if (v23 != &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
      && v23 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
      && v23 != &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
      && v23 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
      && v23 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
      && v23 != &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
      && v23 != &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
      && v23 != &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
      && v23 != &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
      && v23 != &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
      && v23 != &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
      && v23 != &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
    {
      if (v23 == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
      {
        v114.__r_.__value_.__r.__words[0] = (std::string::size_type)v21;
        if (mlir::Type::isInteger((mlir::Type *)&v114, 1))
        {
          LOBYTE(__p[0]) = 1;
          uint64_t v34 = (llvm::APFloatBase *)mlir::DenseElementsAttr::get((uint64_t)v19, InterfaceFor, __p, 1);
          if ((mlir::DenseIntElementsAttr::classof((uint64_t)v34) & 1) == 0) {
            __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
          }
        }
        else
        {
          unsigned int v94 = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&v114);
          BOOL isSignedInteger = mlir::Type::isSignedInteger((mlir::Type *)&v114);
          LODWORD(__p[1]) = v94;
          if (v94 > 0x40)
          {
            llvm::APInt::initSlowCase((llvm::APInt *)__p, v22, isSignedInteger);
          }
          else
          {
            unint64_t v96 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v94;
            if (!v94) {
              unint64_t v96 = 0;
            }
            __p[0] = (void *)(v96 & v22);
          }
          uint64_t v34 = (llvm::APFloatBase *)mlir::DenseElementsAttr::get((uint64_t)v19, InterfaceFor, (llvm::APInt *)__p, 1);
          if ((mlir::DenseIntElementsAttr::classof((uint64_t)v34) & 1) == 0) {
            __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
          }
          if (LODWORD(__p[1]) >= 0x41 && __p[0]) {
            MEMORY[0x1852FDE40](__p[0], 0x1000C8000313F17);
          }
        }
        goto LABEL_67;
      }
      if (v23 != &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id) {
        llvm::llvm_unreachable_internal((llvm *)"unexpected element type kind", "../mlir-mps/third_party/mlir-apple/include/Dialect/MPS/IR/MPSOps.h", (const char *)0x157);
      }
      uint64_t v104 = (uint64_t)v21;
      uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v104);
      if (!mlir::Type::isF32((mlir::Type *)&Value))
      {
        BOOL isF16 = mlir::Type::isF16((mlir::Type *)&Value);
        if (!isF16) {
          llvm::llvm_unreachable_internal((llvm *)"unexpected complex element float type kind", "../mlir-mps/third_party/mlir-apple/include/Dialect/MPS/IR/MPSOps.h", (const char *)0x154);
        }
        _S0 = (float)v22;
        __asm { FCVT            H8, S0 }
        int v82 = llvm::APFloatBase::IEEEhalf((llvm::APFloatBase *)isF16);
        __asm { FCVT            S0, H8; __val }
        std::to_string(&v105, _S0);
        if ((v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v84 = &v105;
        }
        else {
          uint64_t v84 = (std::string *)v105.__r_.__value_.__r.__words[0];
        }
        if ((v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(v105.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = v105.__r_.__value_.__l.__size_;
        }
        llvm::APFloat::APFloat((llvm::APFloatBase *)&v114, v82, (unsigned __int8 *)v84, size);
        std::to_string(&v102, 0.0);
        if ((v102.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          char v86 = &v102;
        }
        else {
          char v86 = (std::string *)v102.__r_.__value_.__r.__words[0];
        }
        if ((v102.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v87 = HIBYTE(v102.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v87 = v102.__r_.__value_.__l.__size_;
        }
        llvm::APFloat::APFloat((llvm::APFloatBase *)&v110, v82, (unsigned __int8 *)v86, v87);
        std::complex<llvm::APFloat>::complex[abi:ne180100]((llvm::APFloatBase *)__p, (uint64_t)&v114, (uint64_t)&v110);
        uint64_t v34 = (llvm::APFloatBase *)mlir::DenseElementsAttr::get((llvm::APFloatBase *)v19, InterfaceFor, (uint64_t)__p, 1);
        uint64_t v88 = v108;
        uint64_t v89 = llvm::APFloatBase::PPCDoubleDouble(v34);
        if (v89 == v88) {
          std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)&v109);
        }
        else {
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v108);
        }
        if (v89 == __p[1]) {
          std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)&__p[2]);
        }
        else {
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&__p[1]);
        }
        if (v89 == v111) {
          std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v112);
        }
        else {
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v111);
        }
        if (SHIBYTE(v102.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v102.__r_.__value_.__l.__data_);
        }
        if (v89 == (void *)v114.__r_.__value_.__l.__size_) {
          std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)&v114.__r_.__value_.__r.__words[2]);
        }
        else {
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v114.__r_.__value_.__r.__words[1]);
        }
        if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v105.__r_.__value_.__l.__data_);
        }
        goto LABEL_67;
      }
      *(float *)&v114.__r_.__value_.__l.__data_ = (float)v22;
      HIDWORD(v114.__r_.__value_.__r.__words[0]) = 0;
      uint64_t v24 = mlir::DenseElementsAttr::getFromRawBuffer(v19, InterfaceFor, &v114, 8, 8, 0, 1);
      goto LABEL_66;
    }
    uint64_t v110 = v21;
    if (mlir::Type::isF16((mlir::Type *)&v110))
    {
      uint64_t v25 = std::to_string(&v114, v22);
      if ((v114.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        __int16 v26 = &v114;
      }
      else {
        __int16 v26 = (std::string *)v114.__r_.__value_.__r.__words[0];
      }
      if ((v114.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v27 = HIBYTE(v114.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v27 = v114.__r_.__value_.__l.__size_;
      }
      __int16 v28 = llvm::APFloatBase::IEEEhalf((llvm::APFloatBase *)v25);
      llvm::APFloat::APFloat((llvm::APFloatBase *)__p, v28, (unsigned __int8 *)v26, v27);
      uint64_t v29 = (llvm::APFloatBase *)mlir::DenseElementsAttr::get((llvm::APFloatBase *)v19, InterfaceFor, (uint64_t)__p, 1);
    }
    else
    {
      if (!mlir::Type::isBF16((mlir::Type *)&v110))
      {
        if (mlir::Type::isF32((mlir::Type *)&v110))
        {
          *(float *)__p = (float)v22;
          uint64_t v24 = mlir::DenseElementsAttr::getFromRawBuffer(v19, InterfaceFor, __p, 4, 4, 0, 1);
        }
        else
        {
          if (!mlir::Type::isF64((mlir::Type *)&v110)) {
            llvm::llvm_unreachable_internal((llvm *)"unexpected element float type kind", "../mlir-mps/third_party/mlir-apple/include/Dialect/MPS/IR/MPSOps.h", (const char *)0x13A);
          }
          *(double *)__p = (double)v22;
          uint64_t v24 = mlir::DenseElementsAttr::getFromRawBuffer(v19, InterfaceFor, __p, 8, 8, 0, 1);
        }
LABEL_66:
        uint64_t v34 = (llvm::APFloatBase *)v24;
        goto LABEL_67;
      }
      uint64_t v30 = std::to_string(&v114, v22);
      if ((v114.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        long long v31 = &v114;
      }
      else {
        long long v31 = (std::string *)v114.__r_.__value_.__r.__words[0];
      }
      if ((v114.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v32 = HIBYTE(v114.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v32 = v114.__r_.__value_.__l.__size_;
      }
      unint64_t v33 = llvm::APFloatBase::BFloat((llvm::APFloatBase *)v30);
      llvm::APFloat::APFloat((llvm::APFloatBase *)__p, v33, (unsigned __int8 *)v31, v32);
      uint64_t v29 = (llvm::APFloatBase *)mlir::DenseElementsAttr::get((llvm::APFloatBase *)v19, InterfaceFor, (uint64_t)__p, 1);
    }
    uint64_t v34 = v29;
    int64_t v35 = __p[1];
    if (llvm::APFloatBase::PPCDoubleDouble(v29) == v35)
    {
      std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)&__p[2]);
      if (SHIBYTE(v114.__r_.__value_.__r.__words[2]) < 0) {
LABEL_61:
      }
        operator delete(v114.__r_.__value_.__l.__data_);
    }
    else
    {
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&__p[1]);
      if (SHIBYTE(v114.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_61;
      }
    }
LABEL_67:
    __p[0] = v34;
    float32x4_t v36 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)__p);
    if (!*((_DWORD *)v36 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v98 = (uint64_t)v36 - 16;
    uint64_t v17 = (uint64_t)mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::Value &>(a3 + 18, LocationForOp, &v98, &v99);
    if (!*(_DWORD *)(v17 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    goto LABEL_69;
  }
LABEL_70:
  __p[0] = (void *)mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 18), 0x20u, 1);
  int v37 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a3 + 18, LocationForOp, &v101, (uint64_t *)__p);
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 18), 0x20u, 1);
  uint64_t v39 = (uint64_t *)mlir::RankedTensorType::get(0, 0, IntegerType, 0);
  __p[0] = (void *)mlir::mps::getConstantAttr<int>(v39, -1);
  int v40 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)__p);
  v102.__r_.__value_.__r.__words[0] = LocationForOp;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v102);
  uint64_t v42 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.top_k", (const unsigned __int8 *)9, Context);
  if (!v43)
  {
    __int16 v113 = 1283;
    v112[0] = "mps.top_k";
    v112[1] = 9;
                                                                "y not be loaded or this operation hasn't been added by t"
                                                                "he dialect. See also https://mlir.llvm.org/getting_start"
                                                                "ed/Faq/#registered-loaded-dependent-whats-up-with-dialects-management";
    __int16 v106 = 259;
    llvm::operator+((uint64_t *)&v110, (uint64_t *)&v105, (uint64_t)&v114);
    llvm::report_fatal_error((llvm::Twine *)&v114, 1);
  }
  mlir::OperationState::OperationState(__p, LocationForOp, v42);
  if (!*((_DWORD *)v40 + 9) || !*((_DWORD *)v37 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::TopKOp::build(a3 + 18, (uint64_t)__p, v99, (uint64_t)v40 - 16, (uint64_t)v37 - 16, 0);
  uint64_t v44 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)__p);
  if (!v44)
  {
    uint64_t v90 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v91 = 662;
    uint64_t v92 = "Casting.h";
    uint64_t v93 = "dyn_cast";
    goto LABEL_149;
  }
  uint64_t v45 = llvm::DefaultDoCastIfPossible<mlir::mps::TopKOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TopKOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v44);
  if (!v45)
  {
    uint64_t v90 = "result && \"builder didn't return the right type\"";
    int v91 = 497;
    uint64_t v92 = "Builders.h";
    uint64_t v93 = "create";
LABEL_149:
    __assert_rtn(v93, v92, v91, v90);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)__p);
  uint64_t v104 = v45;
  uint64_t v110 = (const char *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v104);
  v105.__r_.__value_.__r.__words[0] = mlir::mpsx::ListPopBackOp::getElement((mlir::mpsx::ListPopBackOp *)&v104);
  if ((v13 & 1) == 0)
  {
    LODWORD(__p[0]) = -1;
    uint64_t v46 = mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int &,int>((mlir::mps::ConstantOp *)(a3 + 18), LocationForOp, (uint64_t *)&v110, &v100, (unsigned int *)__p);
    LODWORD(__p[0]) = -1;
    uint64_t v47 = mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int &,int>((mlir::mps::ConstantOp *)(a3 + 18), LocationForOp, (uint64_t *)&v105, &v100, (unsigned int *)__p);
    if (!*(_DWORD *)(v46 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v110 = (const char *)(v46 - 16);
    if (!*(_DWORD *)(v47 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    v105.__r_.__value_.__r.__words[0] = v47 - 16;
  }
  if (v8)
  {
    if (v98)
    {
      uint64_t v48 = (uint64_t)mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::Value &>(a3 + 18, LocationForOp, &v98, (uint64_t *)&v110);
      if (!*(_DWORD *)(v48 + 36)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
    }
    else
    {
      uint64_t v48 = mlir::OpBuilder::create<mlir::mps::NegativeOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t *)&v110);
      if (!*(_DWORD *)(v48 + 36)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
    }
    uint64_t v110 = (const char *)(v48 - 16);
  }
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) != 2)
  {
    HIBYTE(__p[2]) = 14;
    strcpy((char *)__p, "return_indices");
    Parameteruint64_t Value = MIL::IROperation::TryGetParameterValue();
    uint64_t v54 = ParameterValue;
    if (SHIBYTE(__p[2]) < 0)
    {
      operator delete(__p[0]);
      if (!v54) {
        goto LABEL_103;
      }
    }
    else if (!ParameterValue)
    {
LABEL_103:
      __p[0] = operator new(0x38uLL);
      *(_OWORD *)&__p[1] = xmmword_181129E70;
      strcpy((char *)__p[0], "Return types of topk must be 2 distinct tensor values.");
      MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
      if (SHIBYTE(__p[2]) < 0) {
        operator delete(__p[0]);
      }
      return 0;
    }
    if ((MIL::IRValue::GetScalar<BOOL>() & 1) == 0
      && (*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
    {
      (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(__p, a2);
      uint64_t v55 = __p[0];
      uint64_t v56 = v110;
      uint64_t v57 = (char *)operator new(8uLL);
      *(void *)uint64_t v57 = v56;
      v114.__r_.__value_.__r.__words[0] = (std::string::size_type)v55;
      long long v58 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v55, (uint64_t)&std::piecewise_construct, (long long **)&v114);
      std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v58 + 5, v57, v57 + 8, 1uLL);
      operator delete(v57);
      int v59 = (void **)__p[0];
      if (__p[0])
      {
        uint64_t v60 = (void **)__p[1];
        uint64_t v61 = __p[0];
        if (__p[1] != __p[0])
        {
          do
          {
            if (*((char *)v60 - 1) < 0) {
              operator delete(*(v60 - 3));
            }
            v60 -= 3;
          }
          while (v60 != v59);
          uint64_t v61 = __p[0];
        }
        __p[1] = v59;
        operator delete(v61);
      }
      return 1;
    }
    goto LABEL_103;
  }
  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(__p, a2);
  uint64_t OutputType = MIL::IROperation::GetOutputType(a2);
  if ((*(uint64_t (**)(uint64_t))(*(void *)OutputType + 24))(OutputType))
  {
    uint64_t v50 = MIL::IROperation::GetOutputType(a2);
    if ((*(uint64_t (**)(uint64_t))(*(void *)v50 + 24))(v50))
    {
      *((unsigned char *)&v114.__r_.__value_.__s + 23) = 20;
      strcpy((char *)&v114, "output_indices_dtype");
      uint64_t v51 = MIL::IROperation::TryGetParameterValue();
      uint64_t v52 = v51;
      if (SHIBYTE(v114.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v114.__r_.__value_.__l.__data_);
        if (!v52) {
          goto LABEL_115;
        }
      }
      else if (!v51)
      {
        goto LABEL_115;
      }
      MIL::IRValue::GetScalar<std::string>();
      v102.__r_.__value_.__r.__words[0] = MILToMLIRRewriter::getMLIRElemType((uint64_t)a3, (uint64_t)&v114);
      if (SHIBYTE(v114.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v114.__r_.__value_.__l.__data_);
      }
      uint64_t v64 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, (uint64_t *)&v105, (uint64_t *)&v102);
      if (!*((_DWORD *)v64 + 9)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
      v105.__r_.__value_.__r.__words[0] = (std::string::size_type)v64 - 16;
LABEL_115:
      unint64_t v65 = __p[0];
      uint64_t v66 = v110;
      unint64_t v67 = (char *)operator new(8uLL);
      *(void *)unint64_t v67 = v66;
      uint64_t v68 = (char *)(a3 + 8);
      v114.__r_.__value_.__r.__words[0] = (std::string::size_type)v65;
      uint64_t v69 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v68, (uint64_t)v65, (uint64_t)&std::piecewise_construct, (long long **)&v114);
      std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v69 + 5, v67, v67 + 8, 1uLL);
      operator delete(v67);
      float v70 = __p[0];
      std::string::size_type v71 = v105.__r_.__value_.__r.__words[0];
      unint64_t v72 = (char *)operator new(8uLL);
      *(void *)unint64_t v72 = v71;
      v114.__r_.__value_.__r.__words[0] = (std::string::size_type)v70 + 24;
      float v73 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v68, (uint64_t)v70 + 24, (uint64_t)&std::piecewise_construct, (long long **)&v114);
      std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v73 + 5, v72, v72 + 8, 1uLL);
      operator delete(v72);
      char v62 = 1;
      int64_t v63 = (void **)__p[0];
      if (__p[0]) {
        goto LABEL_116;
      }
      return (v62 & 1) != 0;
    }
  }
  v114.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x20uLL);
  *(_OWORD *)&v114.__r_.__value_.__r.__words[1] = xmmword_181129E80;
  strcpy(v114.__r_.__value_.__l.__data_, "Expected values tensor output.");
  MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&v114);
  if (SHIBYTE(v114.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v114.__r_.__value_.__l.__data_);
  }
  char v62 = 0;
  int64_t v63 = (void **)__p[0];
  if (__p[0])
  {
LABEL_116:
    uint64_t v74 = (void **)__p[1];
    if (__p[1] == v63)
    {
      __p[1] = v63;
      operator delete(v63);
      if (v62) {
        return 1;
      }
    }
    else
    {
      do
      {
        if (*((char *)v74 - 1) < 0) {
          operator delete(*(v74 - 3));
        }
        v74 -= 3;
      }
      while (v74 != v63);
      __p[1] = v63;
      operator delete(__p[0]);
      if (v62) {
        return 1;
      }
    }
    return 0;
  }
  return (v62 & 1) != 0;
}

void sub_180D463C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,void *a30,int a31,int a32,int a33,__int16 a34,char a35,char a36)
{
  std::complex<llvm::APFloat>::~complex(&a30);
  llvm::APFloat::~APFloat((llvm::APFloat *)(v36 - 200));
  if (a19 < 0)
  {
    operator delete(__p);
    llvm::APFloat::~APFloat((llvm::APFloat *)(v36 - 160));
    if ((a27 & 0x80000000) == 0) {
LABEL_6:
    }
      _Unwind_Resume(a1);
  }
  else
  {
    llvm::APFloat::~APFloat((llvm::APFloat *)(v36 - 160));
    if ((a27 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  operator delete(a22);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int &,int>(mlir::mps::ConstantOp *a1, uint64_t a2, uint64_t *a3, unsigned int *a4, unsigned int *a5)
{
  v26[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.transpose", (const unsigned __int8 *)0xD, Context);
  if (!v12)
  {
    __int16 v24 = 1283;
    v23[2] = (uint64_t)"mps.transpose";
    v23[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v11);
  mlir::mps::TransposeOp::build(a1, v26, *a3, *a4, *a5);
  char v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v26);
  if (!v13)
  {
    uint64_t v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v17 = 662;
    __int16 v18 = "Casting.h";
    uint64_t v19 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v14 = llvm::DefaultDoCastIfPossible<mlir::mps::TransposeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TransposeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    uint64_t v16 = "result && \"builder didn't return the right type\"";
    int v17 = 497;
    __int16 v18 = "Builders.h";
    uint64_t v19 = "create";
LABEL_8:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v14;
}

void sub_180D46718(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D46730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::NegativeOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.negative", (const unsigned __int8 *)0xC, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.negative";
    v19[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    char v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    uint64_t v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::NegativeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::NegativeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    char v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    uint64_t v14 = "Builders.h";
    int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180D468B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D468D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t MILToMLIR::CropResizePattern::matchAndRewrite(MILToMLIR::CropResizePattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  v93[3] = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v82 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "roi");
  strcpy((char *)__p, "target_height");
  if (MIL::IROperation::TryGetParameterValue()) {
    unsigned int v81 = MIL::IRValue::GetScalar<int>();
  }
  else {
    unsigned int v81 = 1;
  }
  strcpy((char *)__p, "target_width");
  if (MIL::IROperation::TryGetParameterValue()) {
    unsigned int v80 = MIL::IRValue::GetScalar<int>();
  }
  else {
    unsigned int v80 = 1;
  }
  strcpy((char *)__p, "normalized_coordinates");
  if (MIL::IROperation::TryGetParameterValue()) {
    int v79 = MIL::IRValue::GetScalar<BOOL>();
  }
  else {
    int v79 = 0;
  }
  HIBYTE(__p[2]) = 13;
  strcpy((char *)__p, "spatial_scale");
  Parameteruint64_t Value = MIL::IROperation::TryGetParameterValue();
  if (!ParameterValue)
  {
    float v12 = 1.0;
    goto LABEL_19;
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)ParameterValue + 40))(ParameterValue);
  if (v8)
  {
    uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 32))(v8);
    int v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 88))(v9);
    if (v10 == 4)
    {
      LOWORD(__p[0]) = MIL::IRValue::GetScalar<MIL::Fp16>();
      MIL::Fp16::GetFloat((MIL::Fp16 *)__p);
      goto LABEL_18;
    }
    if (v10 == 5)
    {
      MIL::IRValue::GetScalar<float>();
LABEL_18:
      float v12 = v11;
LABEL_19:
      HIBYTE(__p[2]) = 19;
      strcpy((char *)__p, "box_coordinate_mode");
      uint64_t v13 = MIL::IROperation::TryGetParameterValue();
      uint64_t v14 = v13;
      if (SHIBYTE(__p[2]) < 0)
      {
        operator delete(__p[0]);
        if (!v14)
        {
LABEL_74:
          int v17 = 0;
          goto LABEL_75;
        }
      }
      else if (!v13)
      {
        goto LABEL_74;
      }
      MIL::IRValue::GetScalar<std::string>();
      if (SHIBYTE(__p[2]) < 0)
      {
        switch((unint64_t)__p[1])
        {
          case 0x13uLL:
            if (*(void *)__p[0] != 0x5F5352454E524F43
              || *((void *)__p[0] + 1) != 0x49465F4854444957
              || *(void *)((char *)__p[0] + 11) != 0x54535249465F4854)
            {
              goto LABEL_198;
            }
            int v17 = 1;
            operator delete(__p[0]);
            break;
          case 0x14uLL:
            if (*(void *)__p[0] != 0x5F5352454E524F43
              || *((void *)__p[0] + 1) != 0x465F544847494548
              || *((_DWORD *)__p[0] + 4) != 1414746697)
            {
              goto LABEL_198;
            }
            int v17 = 0;
            operator delete(__p[0]);
            break;
          case 0x17uLL:
            if (*(void *)__p[0] != 0x535F5245544E4543
              || *((void *)__p[0] + 1) != 0x544449575F455A49
              || *(void *)((char *)__p[0] + 15) != 0x54535249465F4854)
            {
              goto LABEL_198;
            }
            int v17 = 3;
            operator delete(__p[0]);
            break;
          case 0x18uLL:
            if (*(void *)__p[0] != 0x535F5245544E4543
              || *((void *)__p[0] + 1) != 0x474945485F455A49
              || *((void *)__p[0] + 2) != 0x54535249465F5448)
            {
              goto LABEL_198;
            }
            int v17 = 2;
            operator delete(__p[0]);
            break;
          default:
LABEL_198:
            __assert_rtn("matchAndRewrite", "MILToMLIRCustomPatterns.mm", 1951, "0 && \"Unknown coordinate mode\"");
        }
      }
      else
      {
        switch(HIBYTE(__p[2]))
        {
          case 0x13:
            if (__p[0] != (void *)0x5F5352454E524F43
              || __p[1] != (void *)0x49465F4854444957
              || *(void **)((char *)&__p[1] + 3) != (void *)0x54535249465F4854)
            {
              goto LABEL_198;
            }
            int v17 = 1;
            break;
          case 0x14:
            if (__p[0] != (void *)0x5F5352454E524F43
              || __p[1] != (void *)0x465F544847494548
              || LODWORD(__p[2]) != 1414746697)
            {
              goto LABEL_198;
            }
            goto LABEL_74;
          case 0x17:
            if (__p[0] != (void *)0x535F5245544E4543
              || __p[1] != (void *)0x544449575F455A49
              || *(void **)((char *)&__p[1] + 7) != (void *)0x54535249465F4854)
            {
              goto LABEL_198;
            }
            int v17 = 3;
            break;
          case 0x18:
            if (__p[0] != (void *)0x535F5245544E4543
              || __p[1] != (void *)0x474945485F455A49
              || __p[2] != (void *)0x54535249465F5448)
            {
              goto LABEL_198;
            }
            int v17 = 2;
            break;
          default:
            goto LABEL_198;
        }
      }
LABEL_75:
      HIBYTE(__p[2]) = 13;
      strcpy((char *)__p, "sampling_mode");
      uint64_t v27 = MIL::IROperation::TryGetParameterValue();
      uint64_t v28 = v27;
      if (SHIBYTE(__p[2]) < 0)
      {
        operator delete(__p[0]);
        unsigned int v78 = v17;
        if (!v28)
        {
LABEL_86:
          unsigned int v30 = 0;
LABEL_156:
          uint64_t v46 = operator new(0xCuLL);
          *(void *)uint64_t v46 = 0x300000001;
          v46[2] = 4;
          __p[0] = (void *)3;
          uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 18), 0x20u, 1);
          uint64_t v48 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)__p, 1, IntegerType, 0);
          if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v48)) {
            goto LABEL_190;
          }
          if (v48)
          {
            uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v48);
            if (!InterfaceFor)
            {
              uint64_t v50 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
              int v51 = 98;
              uint64_t v52 = "InterfaceSupport.h";
              uint64_t v53 = "Interface";
              goto LABEL_191;
            }
          }
          else
          {
            uint64_t InterfaceFor = 0;
          }
          uint64_t v54 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v48, InterfaceFor, v46, 12, 4, 1, 1);
          if ((mlir::DenseIntElementsAttr::classof((uint64_t)v54) & 1) == 0)
          {
LABEL_190:
            uint64_t v50 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
            int v51 = 566;
            uint64_t v52 = "Casting.h";
            uint64_t v53 = "cast";
LABEL_191:
            __assert_rtn(v53, v52, v51, v50);
          }
          int v91 = v54;
          __p[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &v91);
          uint64_t v55 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &v82, __p);
          if (!*((_DWORD *)v55 + 9)) {
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          }
          operator delete(v46);
          uint64_t v56 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)__p, v12);
          uint64_t v57 = llvm::APFloatBase::IEEEsingle(v56);
          llvm::APFloat::Storage::Storage(&v88, __p, v57);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)__p);
          uint64_t v83 = LocationForOp;
          uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v83);
          uint64_t v59 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.crop_resize", (const unsigned __int8 *)0xF, Context);
          if (!v60)
          {
            __int16 v87 = 1283;
            v86[2] = (uint64_t)"mps.crop_resize";
            v86[3] = 15;
                  "added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-"
                  "whats-up-with-dialects-management";
            __int16 v85 = 259;
            llvm::operator+(v86, (uint64_t *)&v84, (uint64_t)&v91);
            llvm::report_fatal_error((llvm::Twine *)&v91, 1);
          }
          mlir::OperationState::OperationState(__p, LocationForOp, v59);
          uint64_t v61 = ArgValue;
          char v62 = v88;
          uint64_t v64 = llvm::APFloatBase::PPCDoubleDouble(v63);
          if (v64 == v62) {
            llvm::detail::DoubleAPFloat::DoubleAPFloat(&v92, &v88);
          }
          else {
            llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v92, (uint64_t)&v88);
          }
          mlir::mps::CropResizeOp::build((mlir::Builder *)(a3 + 18), (uint64_t)__p, v61, (uint64_t)v55 - 16, v81, v80, v79, (uint64_t)&v91, 1u, v30, v78);
          if (v64 == v92) {
            std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v93);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v92);
          }
          unint64_t v65 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)__p);
          if (v65)
          {
            uint64_t v66 = llvm::DefaultDoCastIfPossible<mlir::mps::CropResizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CropResizeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v65);
            if (v66)
            {
              mlir::OperationState::~OperationState((mlir::OperationState *)__p);
              if (!*(_DWORD *)(v66 + 36)) {
                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
              }
              if (v64 == v88) {
                std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)&v89);
              }
              else {
                llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v88);
              }
              (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(__p, a2);
              unint64_t v67 = (uint64_t *)__p[0];
              uint64_t v68 = (char *)operator new(8uLL);
              *(void *)uint64_t v68 = v66 - 16;
              int v91 = v67;
              uint64_t v69 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v67, (uint64_t)&std::piecewise_construct, (long long **)&v91);
              std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v69 + 5, v68, v68 + 8, 1uLL);
              operator delete(v68);
              float v70 = (void **)__p[0];
              if (__p[0])
              {
                std::string::size_type v71 = (void **)__p[1];
                unint64_t v72 = __p[0];
                if (__p[1] != __p[0])
                {
                  do
                  {
                    if (*((char *)v71 - 1) < 0) {
                      operator delete(*(v71 - 3));
                    }
                    v71 -= 3;
                  }
                  while (v71 != v70);
                  unint64_t v72 = __p[0];
                }
                __p[1] = v70;
                operator delete(v72);
              }
              return 1;
            }
            uint64_t v74 = "result && \"builder didn't return the right type\"";
            int v75 = 497;
            float v76 = "Builders.h";
            uint64_t v77 = "create";
          }
          else
          {
            uint64_t v74 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
            int v75 = 662;
            float v76 = "Casting.h";
            uint64_t v77 = "dyn_cast";
          }
          __assert_rtn(v77, v76, v75, v74);
        }
      }
      else
      {
        unsigned int v78 = v17;
        if (!v27) {
          goto LABEL_86;
        }
      }
      MIL::IRValue::GetScalar<std::string>();
      if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
      {
        switch(HIBYTE(__p[2]))
        {
          case 7:
            if (LODWORD(__p[0]) != 1095124292 || *(_DWORD *)((char *)__p + 3) != 1414288705) {
              goto LABEL_189;
            }
            goto LABEL_86;
          case 0xD:
            if (__p[0] != (void *)0x4F435F4E47494C41 || *(void **)((char *)__p + 5) != (void *)0x5352454E524F435FLL) {
              goto LABEL_189;
            }
            goto LABEL_113;
          case 0xE:
            if (__p[0] != (void *)0x435F54455346464FLL || *(void **)((char *)__p + 6) != (void *)0x5352454E524F435FLL) {
              goto LABEL_189;
            }
            unsigned int v30 = 2;
            goto LABEL_156;
          case 0x14:
            if (__p[0] != (void *)0x415F544349525453
              || __p[1] != (void *)0x524F435F4E47494CLL
              || LODWORD(__p[2]) != 1397900622)
            {
              goto LABEL_189;
            }
LABEL_113:
            unsigned int v30 = 1;
            goto LABEL_156;
          default:
            goto LABEL_189;
        }
      }
      switch((unint64_t)__p[1])
      {
        case 7uLL:
          if (*(_DWORD *)__p[0] != 1095124292 || *(_DWORD *)((char *)__p[0] + 3) != 1414288705) {
            goto LABEL_189;
          }
          unsigned int v30 = 0;
          operator delete(__p[0]);
          break;
        case 0xDuLL:
          char v43 = __p[0];
          if (*(void *)__p[0] != 0x4F435F4E47494C41 || *(void *)((char *)__p[0] + 5) != 0x5352454E524F435FLL) {
            goto LABEL_189;
          }
          goto LABEL_155;
        case 0xEuLL:
          if (*(void *)__p[0] != 0x435F54455346464FLL || *(void *)((char *)__p[0] + 6) != 0x5352454E524F435FLL) {
            goto LABEL_189;
          }
          unsigned int v30 = 2;
          operator delete(__p[0]);
          break;
        case 0x14uLL:
          char v43 = __p[0];
          if (*(void *)__p[0] != 0x415F544349525453
            || *((void *)__p[0] + 1) != 0x524F435F4E47494CLL
            || *((_DWORD *)__p[0] + 4) != 1397900622)
          {
            goto LABEL_189;
          }
LABEL_155:
          unsigned int v30 = 1;
          operator delete(v43);
          break;
        default:
LABEL_189:
          __assert_rtn("matchAndRewrite", "MILToMLIRCustomPatterns.mm", 1964, "0 && \"Unknown coordinate mode\"");
      }
      goto LABEL_156;
    }
    __p[0] = operator new(0x20uLL);
    *(_OWORD *)&__p[1] = xmmword_181129E90;
    strcpy((char *)__p[0], "Unexpected MIL element type.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t *)__p);
  }
  else
  {
    __p[0] = operator new(0x38uLL);
    *(_OWORD *)&__p[1] = xmmword_181129E70;
    strcpy((char *)__p[0], "Failed to materialize constant: value is not a tensor.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t *)__p);
  }
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  return 0;
}

void sub_180D476F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a34 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180D477BC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180D477EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  llvm::APFloat::~APFloat((llvm::APFloat *)va);
  _Unwind_Resume(a1);
}

void sub_180D47800(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::vector<int>::vector[abi:ne180100](void *a1, const void *a2, unint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3)
  {
    if (a3 >> 62) {
      std::vector<int>::__throw_length_error[abi:ne180100]();
    }
    size_t v5 = 4 * a3;
    uint64_t v6 = (char *)operator new(4 * a3);
    *a1 = v6;
    a1[1] = v6;
    uint64_t v7 = &v6[v5];
    a1[2] = &v6[v5];
    memmove(v6, a2, v5);
    a1[1] = v7;
  }
  return a1;
}

void sub_180D4792C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::DenseIntElementsAttr::get<std::vector<int> &>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = mlir::DenseElementsAttr::getFromRawBuffer(a1, a2, a3, a4 - a3, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof(v4) & 1) == 0) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  return v4;
}

uint64_t MILToMLIR::ConstExpressionPattern::matchAndRewrite(MILToMLIR::ConstExpressionPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v236 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 56))(a2);
  if (*(char *)(v5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v225, *(const std::string::value_type **)v5, *(void *)(v5 + 8));
  }
  else
  {
    long long v6 = *(_OWORD *)v5;
    v225.__r_.__value_.__r.__words[2] = *(void *)(v5 + 16);
    *(_OWORD *)&v225.__r_.__value_.__l.__data_ = v6;
  }
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  v215 = a3 + 18;
  unint64_t v216 = a2;
  uint64_t v7 = HIBYTE(v225.__r_.__value_.__r.__words[2]);
  int64_t size = v225.__r_.__value_.__l.__size_;
  uint64_t v8 = (std::string *)v225.__r_.__value_.__r.__words[0];
  if ((v225.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int64_t v10 = HIBYTE(v225.__r_.__value_.__r.__words[2]);
  }
  else {
    int64_t v10 = v225.__r_.__value_.__l.__size_;
  }
  if ((v225.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    float v11 = &v225;
  }
  else {
    float v11 = (std::string *)v225.__r_.__value_.__r.__words[0];
  }
  int v217 = a3;
  if (v10 >= 14)
  {
    float v12 = (char *)v11 + v10;
    int64_t v13 = v10;
    uint64_t v14 = v11;
    while (1)
    {
      int v15 = (char *)memchr(v14, 99, v13 - 13);
      if (!v15) {
        goto LABEL_32;
      }
      if (*(void *)v15 == 0x70786574736E6F63 && *(void *)(v15 + 6) == 0x747361635F727078) {
        break;
      }
      uint64_t v14 = (std::string *)(v15 + 1);
      int64_t v13 = v12 - (char *)v14;
      if (v12 - (char *)v14 < 14) {
        goto LABEL_32;
      }
    }
    if (v15 != v12 && v15 - (char *)v11 != -1)
    {
      HIBYTE(__p[2]) = 10;
      strcpy((char *)__p, "source_val");
      Attribute = (MIL::IRValue *)MIL::IRObject::GetAttribute();
      v227 = (const char *)MILToMLIRRewriter::materializeConstant((uint64_t)a3, Attribute, &LocationForOp);
      if (SHIBYTE(__p[2]) < 0) {
        operator delete(__p[0]);
      }
      HIBYTE(v235.__end_cap_.__value_) = 12;
      strcpy((char *)&v235, "output_dtype");
      MIL::IRObject::GetAttribute();
      MIL::IRValue::GetScalar<std::string>();
      if (SHIBYTE(v235.__end_cap_.__value_) < 0) {
        operator delete(v235.__begin_);
      }
      uint64_t MLIRElemType = MILToMLIRRewriter::getMLIRElemType((uint64_t)a3, (uint64_t)__p);
      __int16 v18 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(v215, LocationForOp, (uint64_t *)&v227, &MLIRElemType);
      (*(void (**)(std::vector<int> *__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&v235, a2);
      if (!*((_DWORD *)v18 + 9)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
      std::vector<int>::pointer begin = v235.__begin_;
      __int16 v20 = (char *)operator new(8uLL);
      *(void *)__int16 v20 = (char *)v18 - 16;
      v230[0] = begin;
      int v21 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(v217 + 8), (uint64_t)begin, (uint64_t)&std::piecewise_construct, (long long **)v230);
      std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v21 + 5, v20, v20 + 8, 1uLL);
      operator delete(v20);
      __int16 v22 = v235.__begin_;
      if (v235.__begin_)
      {
        std::vector<int>::pointer end = v235.__end_;
        std::vector<int>::pointer v24 = v235.__begin_;
        if (v235.__end_ != v235.__begin_)
        {
          do
          {
            if (*((char *)end - 1) < 0) {
              operator delete(*((void **)end - 3));
            }
            end -= 6;
          }
          while (end != v22);
          std::vector<int>::pointer v24 = v235.__begin_;
        }
        v235.__end_ = v22;
        operator delete(v24);
      }
      if ((SHIBYTE(__p[2]) & 0x80000000) == 0) {
        goto LABEL_315;
      }
      __int16 v85 = __p[0];
      goto LABEL_314;
    }
LABEL_32:
    if (v10 >= 27)
    {
      uint64_t v25 = v11;
      while (1)
      {
        __int16 v26 = (char *)memchr(v25, 99, v10 - 26);
        if (!v26) {
          goto LABEL_46;
        }
        BOOL v27 = *(void *)v26 == 0x70786574736E6F63 && *((void *)v26 + 1) == 0x656E696666615F72;
        BOOL v28 = v27 && *((void *)v26 + 2) == 0x746E61757165645FLL;
        if (v28 && *(void *)(v26 + 19) == 0x657A69746E617571) {
          break;
        }
        uint64_t v25 = (std::string *)(v26 + 1);
        int64_t v10 = v12 - (char *)v25;
        if (v12 - (char *)v25 < 27) {
          goto LABEL_46;
        }
      }
      if (v26 != v12 && v26 - (char *)v11 != -1)
      {
        HIBYTE(__p[2]) = 14;
        strcpy((char *)__p, "quantized_data");
        char v62 = (MIL::IRValue *)MIL::IRObject::GetAttribute();
        uint64_t v63 = MILToMLIRRewriter::materializeConstant((uint64_t)a3, v62, &LocationForOp);
        if (SHIBYTE(__p[2]) < 0) {
          operator delete(__p[0]);
        }
        HIBYTE(__p[2]) = 10;
        strcpy((char *)__p, "zero_point");
        uint64_t v64 = (MIL::IRValue *)MIL::IRObject::GetAttribute();
        uint64_t v65 = MILToMLIRRewriter::materializeConstant((uint64_t)a3, v64, &LocationForOp);
        if (SHIBYTE(__p[2]) < 0) {
          operator delete(__p[0]);
        }
        HIBYTE(__p[2]) = 5;
        strcpy((char *)__p, "scale");
        uint64_t v66 = (MIL::IRValue *)MIL::IRObject::GetAttribute();
        uint64_t v67 = MILToMLIRRewriter::materializeConstant((uint64_t)a3, v66, &LocationForOp);
        if (SHIBYTE(__p[2]) < 0) {
          operator delete(__p[0]);
        }
        uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v67);
        Arguint64_t Value = mlir::getElementTypeOrSelf(v65);
        if (mlir::Type::isInteger((mlir::Type *)&ArgValue, 8) || mlir::Type::isInteger((mlir::Type *)&ArgValue, 4))
        {
          HIBYTE(__p[2]) = 4;
          strcpy((char *)__p, "axis");
          uint64_t v69 = (MIL::IRValue *)MIL::IRObject::GetAttribute();
          if (SHIBYTE(__p[2]) < 0) {
            operator delete(__p[0]);
          }
          MIL::IRValue::AsTensor(v69);
          uint64_t v70 = *(int *)MIL::IRTensorValue::GetDataView<int>();
          uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)v215, 0x20u, 1);
          uint64_t v72 = LocationForOp;
          uint64_t v73 = mlir::TypeAttr::get(ElementTypeOrSelf);
          uint64_t v74 = mlir::IntegerAttr::get(IntegerType, v70);
          uint64_t MLIRElemType = v72;
          uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&MLIRElemType);
          uint64_t v76 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dequantize", (const unsigned __int8 *)0xE, Context);
          if (!v77)
          {
            __int16 v233 = 1283;
            int v231 = "mps.dequantize";
            uint64_t v232 = 14;
                   " added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependen"
                   "t-whats-up-with-dialects-management";
            __int16 v229 = 259;
            llvm::operator+((uint64_t *)v230, (uint64_t *)&v227, (uint64_t)&v235);
            llvm::report_fatal_error((llvm::Twine *)&v235, 1);
          }
          mlir::OperationState::OperationState(__p, v72, v76);
          mlir::mps::DequantizeOp::build(v215, (uint64_t *)__p, v63, v67, v65, v73, v74);
          unsigned int v78 = mlir::OpBuilder::create((mlir::OpBuilder *)v215, (const mlir::OperationState *)__p);
          if (v78)
          {
            uint64_t v79 = llvm::DefaultDoCastIfPossible<mlir::mps::DequantizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DequantizeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v78);
            if (v79)
            {
              mlir::OperationState::~OperationState((mlir::OperationState *)__p);
              (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(__p, a2);
              if (!*(_DWORD *)(v79 + 36)) {
                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
              }
              unsigned int v80 = (int *)__p[0];
              unsigned int v81 = (char *)operator new(8uLL);
              *(void *)unsigned int v81 = v79 - 16;
              v235.__begin_ = v80;
              uint64_t v82 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(v217 + 8), (uint64_t)v80, (uint64_t)&std::piecewise_construct, (long long **)&v235);
              std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v82 + 5, v81, v81 + 8, 1uLL);
              operator delete(v81);
              uint64_t v83 = (void **)__p[0];
              if (!__p[0]) {
                goto LABEL_315;
              }
              uint64_t v84 = (void **)__p[1];
              __int16 v85 = __p[0];
              if (__p[1] == __p[0]) {
                goto LABEL_313;
              }
              do
              {
                if (*((char *)v84 - 1) < 0) {
                  operator delete(*(v84 - 3));
                }
                v84 -= 3;
              }
              while (v84 != v83);
LABEL_312:
              __int16 v85 = __p[0];
LABEL_313:
              __p[1] = v83;
LABEL_314:
              operator delete(v85);
              goto LABEL_315;
            }
            uint64_t v210 = "result && \"builder didn't return the right type\"";
            int v211 = 497;
            uint64_t v212 = "Builders.h";
            unint64_t v213 = "create";
          }
          else
          {
            uint64_t v210 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
            int v211 = 662;
            uint64_t v212 = "Casting.h";
            unint64_t v213 = "dyn_cast";
          }
          __assert_rtn(v213, v212, v211, v210);
        }
        uint64_t v7 = HIBYTE(v225.__r_.__value_.__r.__words[2]);
        int64_t size = v225.__r_.__value_.__l.__size_;
        uint64_t v8 = (std::string *)v225.__r_.__value_.__r.__words[0];
      }
    }
  }
LABEL_46:
  if ((v7 & 0x80u) == 0) {
    uint64_t v30 = v7;
  }
  else {
    uint64_t v30 = size;
  }
  if ((v7 & 0x80u) == 0) {
    long long v31 = &v225;
  }
  else {
    long long v31 = v8;
  }
  if (v30 >= 31)
  {
    std::string::size_type v32 = (char *)v31 + v30;
    unint64_t v33 = v31;
    while (1)
    {
      uint64_t v34 = (char *)memchr(v33, 99, v30 - 30);
      if (!v34) {
        goto LABEL_66;
      }
      BOOL v35 = *(void *)v34 == 0x70786574736E6F63 && *((void *)v34 + 1) == 0x776B636F6C625F72;
      BOOL v36 = v35 && *((void *)v34 + 2) == 0x666968735F657369;
      if (v36 && *(void *)(v34 + 23) == 0x656C6163735F7466) {
        break;
      }
      unint64_t v33 = (std::string *)(v34 + 1);
      uint64_t v30 = v32 - (char *)v33;
      if (v32 - (char *)v33 < 31) {
        goto LABEL_66;
      }
    }
    if (v34 != v32 && v34 - (char *)v31 != -1)
    {
      Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "data");
      OptionalArguint64_t Value = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "offset");
      uint64_t v221 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "scale");
      uint64_t v52 = mlir::getElementTypeOrSelf(ArgValue);
      uint64_t v53 = mlir::getElementTypeOrSelf(v221);
      unint64_t v220 = 0;
      if (OptionalArgValue)
      {
        uint64_t v54 = mlir::getElementTypeOrSelf(OptionalArgValue);
      }
      else
      {
        uint64_t v97 = LocationForOp;
        __p[0] = (void *)1;
        uint64_t v98 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, v52, 0);
        __p[0] = (void *)mlir::mps::getConstantAttr<float>(v98, 0.0);
        uint64_t v99 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v215, v97, (uint64_t **)__p);
        if (!*((_DWORD *)v99 + 9)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        OptionalArguint64_t Value = (uint64_t)v99 - 16;
        uint64_t v54 = mlir::getElementTypeOrSelf((uint64_t)v99 - 16);
      }
      unint64_t v220 = v54;
      if (mlir::Type::isInteger((mlir::Type *)&v220, 8) || mlir::Type::isInteger((mlir::Type *)&v220, 4))
      {
        uint64_t v100 = LocationForOp;
        uint64_t v101 = mlir::TypeAttr::get(v53);
        uint64_t MLIRElemType = v100;
        std::string v102 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&MLIRElemType);
        uint64_t v103 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dequantize", (const unsigned __int8 *)0xE, v102);
        if (!v104)
        {
          __int16 v233 = 1283;
          int v231 = "mps.dequantize";
          uint64_t v232 = 14;
                 "dded by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-wh"
                 "ats-up-with-dialects-management";
          __int16 v229 = 259;
          llvm::operator+((uint64_t *)v230, (uint64_t *)&v227, (uint64_t)&v235);
          llvm::report_fatal_error((llvm::Twine *)&v235, 1);
        }
        mlir::OperationState::OperationState(__p, v100, v103);
        mlir::mps::DequantizeOp::build(v215, (uint64_t *)__p, ArgValue, v221, OptionalArgValue, v101, 0);
        std::string v105 = mlir::OpBuilder::create((mlir::OpBuilder *)v215, (const mlir::OperationState *)__p);
        if (v105)
        {
          uint64_t v106 = llvm::DefaultDoCastIfPossible<mlir::mps::DequantizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DequantizeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v105);
          if (v106)
          {
            mlir::OperationState::~OperationState((mlir::OperationState *)__p);
            (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(__p, a2);
            if (!*(_DWORD *)(v106 + 36)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
            unint64_t v107 = (int *)__p[0];
            int v108 = (char *)operator new(8uLL);
            *(void *)int v108 = v106 - 16;
            v235.__begin_ = v107;
            uint64_t v109 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(v217 + 8), (uint64_t)v107, (uint64_t)&std::piecewise_construct, (long long **)&v235);
            std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v109 + 5, v108, v108 + 8, 1uLL);
            operator delete(v108);
            uint64_t v83 = (void **)__p[0];
            if (!__p[0]) {
              goto LABEL_315;
            }
            uint64_t v110 = (void **)__p[1];
            __int16 v85 = __p[0];
            if (__p[1] == __p[0]) {
              goto LABEL_313;
            }
            do
            {
              if (*((char *)v110 - 1) < 0) {
                operator delete(*(v110 - 3));
              }
              v110 -= 3;
            }
            while (v110 != v83);
            goto LABEL_312;
          }
          size_t v203 = "result && \"builder didn't return the right type\"";
          int v204 = 497;
          int v205 = "Builders.h";
          BOOL v206 = "create";
        }
        else
        {
          size_t v203 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
          int v204 = 662;
          int v205 = "Casting.h";
          BOOL v206 = "dyn_cast";
        }
        __assert_rtn(v206, v205, v204, v203);
      }
      if (v220 == v53)
      {
        v187 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>(v215, LocationForOp, &OptionalArgValue, &v221);
        if (!*((_DWORD *)v187 + 9)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        v235.__begin_ = (std::vector<int>::pointer)((char *)v187 - 16);
        uint64_t v188 = mlir::OpBuilder::create<mlir::mps::NegativeOp,mlir::Value &>((mlir::OpBuilder *)v215, LocationForOp, (uint64_t *)&v235);
        if (!*(_DWORD *)(v188 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        v230[0] = (void *)(v188 - 16);
        uint64_t v189 = LocationForOp;
        __p[0] = (void *)1;
        int v190 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, v52, 0);
        __p[0] = (void *)mlir::mps::getConstantAttr<float>(v190, 0.0);
        v191 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v215, v189, (uint64_t **)__p);
        if (!*((_DWORD *)v191 + 9)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        v227 = (char *)v191 - 16;
        uint64_t v192 = LocationForOp;
        __p[0] = (void *)mlir::TypeAttr::get(v53);
        uint64_t MLIRElemType = 0;
        BOOL v193 = mlir::OpBuilder::create<mlir::mps::DequantizeOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,mlir::TypeAttr,decltype(nullptr)>(v215, v192, &ArgValue, &v221, (uint64_t *)&v227, (uint64_t *)v230, (uint64_t *)__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(__p, a2);
        if (!*((_DWORD *)v193 + 9)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        MILToMLIRRewriter::setValue((uint64_t)a3, (long long *)__p[0], (uint64_t)v193 - 16);
        uint64_t v83 = (void **)__p[0];
        if (!__p[0]) {
          goto LABEL_315;
        }
        int v194 = (void **)__p[1];
        __int16 v85 = __p[0];
        if (__p[1] == __p[0]) {
          goto LABEL_313;
        }
        do
        {
          if (*((char *)v194 - 1) < 0) {
            operator delete(*(v194 - 3));
          }
          v194 -= 3;
        }
        while (v194 != v83);
        goto LABEL_312;
      }
      uint64_t v7 = HIBYTE(v225.__r_.__value_.__r.__words[2]);
      int64_t size = v225.__r_.__value_.__l.__size_;
      uint64_t v8 = (std::string *)v225.__r_.__value_.__r.__words[0];
    }
  }
LABEL_66:
  if ((v7 & 0x80u) == 0) {
    uint64_t v38 = v7;
  }
  else {
    uint64_t v38 = size;
  }
  if ((v7 & 0x80u) == 0) {
    uint64_t v39 = &v225;
  }
  else {
    uint64_t v39 = v8;
  }
  if (v38 < 22)
  {
LABEL_73:
    if ((v7 & 0x80u) != 0)
    {
      int v40 = v8;
    }
    else
    {
      int64_t size = v7;
      int v40 = &v225;
    }
    if (size > 22) {
      goto LABEL_92;
    }
LABEL_262:
    uint64_t v168 = (*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 64))(a2);
    (*(void (**)(std::vector<int> *__return_ptr))(*(void *)v168 + 112))(&v235);
    if (v235.__begin_)
    {
      uint64_t v169 = MILToMLIRRewriter::materializeConstant((uint64_t)a3, (MIL::IRValue *)v235.__begin_, &LocationForOp);
      if (v169)
      {
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(__p, a2);
        int v170 = __p[0];
        v171 = (char *)operator new(8uLL);
        *(void *)v171 = v169;
        v230[0] = v170;
        size_t v172 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(v217 + 8), (uint64_t)v170, (uint64_t)&std::piecewise_construct, (long long **)v230);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v172 + 5, v171, v171 + 8, 1uLL);
        operator delete(v171);
        BOOL v173 = (void **)__p[0];
        if (__p[0])
        {
          int v174 = (void **)__p[1];
          BOOL v175 = __p[0];
          if (__p[1] != __p[0])
          {
            do
            {
              if (*((char *)v174 - 1) < 0) {
                operator delete(*(v174 - 3));
              }
              v174 -= 3;
            }
            while (v174 != v173);
            BOOL v175 = __p[0];
          }
          __p[1] = v173;
          operator delete(v175);
        }
        uint64_t v96 = 1;
      }
      else
      {
        uint64_t v96 = 0;
      }
    }
    else
    {
      __p[0] = operator new(0x30uLL);
      *(_OWORD *)&__p[1] = xmmword_181129E10;
      strcpy((char *)__p[0], "Couldn't get constant value for constExpr op");
      uint64_t v96 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
      if (SHIBYTE(__p[2]) < 0) {
        operator delete(__p[0]);
      }
    }
    int v176 = (std::__shared_weak_count *)v235.__end_;
    if (v235.__end_ && !atomic_fetch_add((atomic_ullong *volatile)v235.__end_ + 1, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v176->__on_zero_shared)(v176);
      std::__shared_weak_count::__release_weak(v176);
    }
    goto LABEL_316;
  }
  int64_t v41 = (char *)v39 + v38;
  uint64_t v42 = v39;
  while (1)
  {
    char v43 = (char *)memchr(v42, 99, v38 - 21);
    if (!v43)
    {
LABEL_88:
      if ((v7 & 0x80u) != 0)
      {
        int v40 = v8;
      }
      else
      {
        int64_t size = v7;
        int v40 = &v225;
      }
      if (size <= 22) {
        goto LABEL_262;
      }
LABEL_92:
      uint64_t v46 = (char *)v40 + size;
      int64_t v47 = size;
      uint64_t v48 = v40;
      do
      {
        int v49 = (char *)memchr(v48, 99, v47 - 22);
        if (!v49) {
          break;
        }
        if (*(void *)v49 == 0x70786574736E6F63
          && *((void *)v49 + 1) == 0x6F745F74756C5F72
          && *(void *)(v49 + 15) == 0x6573726170735F6FLL)
        {
          if (v49 != v46 && v49 - (char *)v40 != -1)
          {
LABEL_156:
            uint64_t v86 = (*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 64))(a2);
            (*(void (**)(void **__return_ptr))(*(void *)v86 + 248))(__p);
            if ((void *)((char *)__p[1] - (char *)__p[0]) == (void *)32)
            {
              uint64_t v87 = MILToMLIRRewriter::materializeConstant((uint64_t)a3, *(MIL::IRValue **)__p[0], &LocationForOp);
              uint64_t v88 = MILToMLIRRewriter::materializeConstant((uint64_t)a3, *((MIL::IRValue **)__p[0] + 2), &LocationForOp);
              (*(void (**)(std::vector<int> *__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&v235, a2);
              std::vector<int>::pointer v89 = v235.__begin_;
              uint64_t v90 = (char *)operator new(8uLL);
              *(void *)uint64_t v90 = v87;
              int v91 = (char *)(a3 + 8);
              v230[0] = v89;
              uint64_t v92 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v89, (uint64_t)&std::piecewise_construct, (long long **)v230);
              std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v92 + 5, v90, v90 + 8, 1uLL);
              operator delete(v90);
              uint64_t v93 = v235.__begin_;
              if (v235.__begin_)
              {
                std::vector<int>::pointer v94 = v235.__end_;
                std::vector<int>::pointer v95 = v235.__begin_;
                if (v235.__end_ != v235.__begin_)
                {
                  do
                  {
                    if (*((char *)v94 - 1) < 0) {
                      operator delete(*((void **)v94 - 3));
                    }
                    v94 -= 6;
                  }
                  while (v94 != v93);
                  std::vector<int>::pointer v95 = v235.__begin_;
                }
                v235.__end_ = v93;
                operator delete(v95);
              }
              (*(void (**)(std::vector<int> *__return_ptr))(*(void *)v216 + 200))(&v235);
              std::vector<int>::pointer v177 = v235.__begin_;
              int v178 = (char *)operator new(8uLL);
              *(void *)int v178 = v88;
              v230[0] = v177 + 6;
              uint64_t v179 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v91, (uint64_t)(v177 + 6), (uint64_t)&std::piecewise_construct, (long long **)v230);
              std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v179 + 5, v178, v178 + 8, 1uLL);
              operator delete(v178);
              unint64_t v180 = v235.__begin_;
              if (v235.__begin_)
              {
                std::vector<int>::pointer v181 = v235.__end_;
                std::vector<int>::pointer v182 = v235.__begin_;
                if (v235.__end_ != v235.__begin_)
                {
                  do
                  {
                    if (*((char *)v181 - 1) < 0) {
                      operator delete(*((void **)v181 - 3));
                    }
                    v181 -= 6;
                  }
                  while (v181 != v180);
                  std::vector<int>::pointer v182 = v235.__begin_;
                }
                v235.__end_ = v180;
                operator delete(v182);
              }
              uint64_t v96 = 1;
            }
            else
            {
              v235.__begin_ = (std::vector<int>::pointer)operator new(0x30uLL);
              *(_OWORD *)&v235.__end_ = xmmword_181129E50;
              strcpy((char *)v235.__begin_, "Couldn't get constant values for constExpr op");
              uint64_t v96 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&v235);
              if (SHIBYTE(v235.__end_cap_.__value_) < 0) {
                operator delete(v235.__begin_);
              }
            }
            v183 = (char *)__p[0];
            if (__p[0])
            {
              unint64_t v184 = (char *)__p[1];
              v185 = __p[0];
              if (__p[1] != __p[0])
              {
                do
                {
                  int v186 = (std::__shared_weak_count *)*((void *)v184 - 1);
                  if (v186 && !atomic_fetch_add(&v186->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v186->__on_zero_shared)(v186);
                    std::__shared_weak_count::__release_weak(v186);
                  }
                  v184 -= 16;
                }
                while (v184 != v183);
                v185 = __p[0];
              }
              __p[1] = v183;
              operator delete(v185);
            }
            goto LABEL_316;
          }
          break;
        }
        uint64_t v48 = (std::string *)(v49 + 1);
        int64_t v47 = v46 - (char *)v48;
      }
      while (v46 - (char *)v48 >= 23);
      if (size >= 38)
      {
        uint64_t v56 = v40;
        while (1)
        {
          uint64_t v57 = (char *)memchr(v56, 99, size - 37);
          if (!v57) {
            break;
          }
          if (*(void *)v57 == 0x70786574736E6F63
            && *((void *)v57 + 1) == 0x6573726170735F72
            && *((void *)v57 + 2) == 0x69776B636F6C625FLL
            && *((void *)v57 + 3) == 0x74666968735F6573
            && *(void *)(v57 + 30) == 0x656C6163735F7466)
          {
            if (v57 == v46 || v57 - (char *)v40 == -1) {
              goto LABEL_262;
            }
            goto LABEL_156;
          }
          uint64_t v56 = (std::string *)(v57 + 1);
          int64_t size = v46 - (char *)v56;
          if (v46 - (char *)v56 < 38) {
            goto LABEL_262;
          }
        }
      }
      goto LABEL_262;
    }
    BOOL v44 = *(void *)v43 == 0x70786574736E6F63 && *((void *)v43 + 1) == 0x6F745F74756C5F72;
    if (v44 && *(void *)(v43 + 14) == 0x65736E65645F6F74) {
      break;
    }
    uint64_t v42 = (std::string *)(v43 + 1);
    uint64_t v38 = v41 - (char *)v42;
    if (v41 - (char *)v42 < 22) {
      goto LABEL_88;
    }
  }
  if (v43 == v41 || v43 - (char *)v39 == -1) {
    goto LABEL_73;
  }
  if ((v7 & 0x80) == 0)
  {
    uint64_t v55 = a3 + 18;
    if (v7 == 28)
    {
      uint64_t v8 = &v225;
      goto LABEL_185;
    }
LABEL_204:
    uint64_t MLIRElemType = 0;
    OptionalArguint64_t Value = 0;
    Arguint64_t Value = 0;
    uint64_t v221 = 0;
    goto LABEL_205;
  }
  uint64_t v55 = a3 + 18;
  if (size != 28) {
    goto LABEL_204;
  }
LABEL_185:
  BOOL v113 = v8->__r_.__value_.__r.__words[0] == 0x6F632E3831736F69
      && v8->__r_.__value_.__l.__size_ == 0x5F7270786574736ELL
      && v8->__r_.__value_.__r.__words[2] == 0x645F6F745F74756CLL
      && LODWORD(v8[1].__r_.__value_.__l.__data_) == 1702063717;
  uint64_t MLIRElemType = 0;
  OptionalArguint64_t Value = 0;
  Arguint64_t Value = 0;
  uint64_t v221 = 0;
  if (!v113)
  {
LABEL_205:
    HIBYTE(__p[2]) = 7;
    strcpy((char *)__p, "indices");
    int v123 = (MIL::IRValue *)MIL::IRObject::GetAttribute();
    Arguint64_t Value = MILToMLIRRewriter::materializeConstant((uint64_t)a3, v123, &LocationForOp);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
    HIBYTE(__p[2]) = 3;
    LODWORD(__p[0]) = 7632236;
    __int16 v124 = (MIL::IRValue *)MIL::IRObject::GetAttribute();
    OptionalArguint64_t Value = MILToMLIRRewriter::materializeConstant((uint64_t)a3, v124, &LocationForOp);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
    int v117 = 0;
    int v116 = 0;
    unint64_t v118 = *(void *)(OptionalArgValue + 8) & 0xFFFFFFFFFFFFFFF8;
    if (v118) {
      goto LABEL_210;
    }
LABEL_203:
    uint64_t v119 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v120 = 650;
    int v121 = "Casting.h";
    uint64_t v122 = "dyn_cast";
LABEL_332:
    __assert_rtn(v122, v121, v120, v119);
  }
  HIBYTE(__p[2]) = 7;
  strcpy((char *)__p, "indices");
  std::string v114 = (const MIL::IRValue *)(*(uint64_t (**)(const MIL::IROperation *, void **, void))(*(void *)a2 + 128))(a2, __p, 0);
  MLIRElemTypeFromMILuint64_t Value = getMLIRElemTypeFromMILValue(v114, *v55);
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  if (MLIRElemTypeFromMILValue) {
    Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "indices");
  }
  OptionalArguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "lut");
  uint64_t v221 = mlir::getElementTypeOrSelf(OptionalArgValue);
  if (mlir::Type::isF16((mlir::Type *)&v221) || mlir::Type::isF32((mlir::Type *)&v221))
  {
    int v116 = 0;
    int v117 = 1;
    unint64_t v118 = *(void *)(OptionalArgValue + 8) & 0xFFFFFFFFFFFFFFF8;
    if (v118) {
      goto LABEL_210;
    }
    goto LABEL_203;
  }
  BOOL isInteger = mlir::Type::isInteger((mlir::Type *)&v221, 8);
  uint64_t v197 = LocationForOp;
  if (isInteger)
  {
    __p[0] = (void *)(*(void *)(OptionalArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
    unint64_t v198 = (mlir::Float16Type *)mlir::Attribute::getContext((mlir::Attribute *)__p);
    v235.__begin_ = (std::vector<int>::pointer)mlir::Float16Type::get(v198, v199);
    uint64_t v200 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::FloatType>(v55, v197, &OptionalArgValue, (uint64_t *)&v235);
    if (!*(_DWORD *)(v200 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
  }
  else
  {
    __p[0] = (void *)(*(void *)(OptionalArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
    v201 = (mlir::Float32Type *)mlir::Attribute::getContext((mlir::Attribute *)__p);
    v235.__begin_ = (std::vector<int>::pointer)mlir::Float32Type::get(v201, v202);
    uint64_t v200 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::FloatType>(v55, v197, &OptionalArgValue, (uint64_t *)&v235);
    if (!*(_DWORD *)(v200 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
  }
  OptionalArguint64_t Value = v200 - 16;
  int v117 = 1;
  int v116 = 1;
  unint64_t v118 = *(void *)(v200 - 8) & 0xFFFFFFFFFFFFFFF8;
  if (!v118) {
    goto LABEL_203;
  }
LABEL_210:
  if (!*(void *)v118)
  {
    uint64_t v119 = "abstractType && \"Malformed type storage object.\"";
    int v120 = 160;
    int v121 = "TypeSupport.h";
    uint64_t v122 = "getAbstractType";
    goto LABEL_332;
  }
  if (*(_UNKNOWN **)(*(void *)v118 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    unint64_t v118 = 0;
  }
  unint64_t v220 = v118;
  uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v220);
  if (!v117)
  {
    if (v126)
    {
      if (*(void *)(Value + 8 * v126 - 8) == 256)
      {
        HIBYTE(__p[2]) = 5;
        strcpy((char *)__p, "shape");
        uint64_t v141 = MIL::IRObject::TryGetAttribute();
        if (SHIBYTE(__p[2]) < 0) {
          operator delete(__p[0]);
        }
        if (!v141)
        {
          std::string::basic_string[abi:ne180100]<0>(__p, "Couldn't get value for parameter: \"shape\"");
          uint64_t v96 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
          if (SHIBYTE(__p[2]) < 0) {
            operator delete(__p[0]);
          }
          goto LABEL_316;
        }
        (*(void (**)(uint64_t))(*(void *)v141 + 40))(v141);
        uint64_t Data = MIL::IRTensorValue::GetDataView<unsigned int>();
        std::vector<int>::size_type v144 = (std::vector<int>::size_type)v143;
        v235.__begin_ = v143;
        llvm::SmallVector<long long,4u>::SmallVector(__p, &v235, 1);
        size_t v145 = __p[0];
        uint64_t v146 = LODWORD(__p[1]);
        v235.__begin_ = (std::vector<int>::pointer)(*(void *)(OptionalArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
        uint64_t v147 = mlir::Attribute::getContext((mlir::Attribute *)&v235);
        uint64_t v148 = mlir::IntegerType::get(v147, 0x20u, 1u);
        v230[0] = (void *)mlir::RankedTensorType::get((uint64_t)v145, v146, v148, 0);
        v227 = (const char *)mlir::Type::cast<mlir::ShapedType>((uint64_t **)v230);
        uint64_t v228 = v149;
        memset(&v235, 0, sizeof(v235));
        std::vector<int>::resize(&v235, v144);
        if (v144 != 1)
        {
          unint64_t v150 = 0;
          std::vector<int>::pointer v151 = v235.__begin_;
          std::vector<int>::size_type v152 = v144 - 2;
          if (v144 < v144 - 2) {
            std::vector<int>::size_type v152 = v144;
          }
          unint64_t v153 = v152 + 1;
          if (v153 >= 9 && (unint64_t)v235.__begin_ - Data > 0x1F)
          {
            uint64_t v154 = v153 & 7;
            if ((v153 & 7) == 0) {
              uint64_t v154 = 8;
            }
            unint64_t v150 = v153 - v154;
            unint64_t v155 = (long long *)(Data + 16);
            std::vector<int>::pointer v156 = v235.__begin_ + 4;
            unint64_t v157 = v150;
            do
            {
              long long v158 = *v155;
              *((_OWORD *)v156 - 1) = *(v155 - 1);
              *(_OWORD *)std::vector<int>::pointer v156 = v158;
              v155 += 2;
              v156 += 8;
              v157 -= 8;
            }
            while (v157);
          }
          int v159 = (int *)(Data + 4 * v150);
          int v160 = &v151[v150];
          std::vector<int>::size_type v161 = v144 - v150;
          do
          {
            if (!v161)
            {
              exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(exception, "index out of bounds");
              exception->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x1E4FBA4B8] + 16);
              __cxa_throw(exception, (struct type_info *)off_1E4FBE4C0, MEMORY[0x1E4FBA1B8]);
            }
            int v162 = *v159++;
            *v160++ = v162;
            --v161;
          }
          while (v161 != 1);
        }
        int v163 = (int *)MIL::Util::Span<unsigned int const,18446744073709551615ul>::operator[](Data, v144, v144 - 1);
        int v164 = *v163;
        v235.__begin_[v144 - 1] = *v163;
        int v165 = *(_DWORD *)MIL::Util::Span<unsigned int const,18446744073709551615ul>::operator[](Data, v144, v144 - 1);
        if (v164 == v165)
        {
          uint64_t v219 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v227, v228, v235.__begin_, 4 * v144, 4, 1, 1);
          uint64_t v218 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ShapedType &,mlir::DenseElementsAttr &>((mlir::OpBuilder *)v215, LocationForOp, (uint64_t *)&v227, &v219);
          int v166 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>(v215, LocationForOp, &ArgValue, &v218);
          if (!*((_DWORD *)v166 + 9)) {
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          }
          Arguint64_t Value = (uint64_t)v166 - 16;
          uint64_t v167 = mlir::OpBuilder::create<mlir::mps::DequantizeLUTOp,mlir::Value &,mlir::Value &,mlir::IntegerAttr &>(v215, LocationForOp, &ArgValue, &OptionalArgValue, &MLIRElemType);
          if (!*(_DWORD *)(v167 + 36)) {
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          }
          (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(v230, a2);
          MILToMLIRRewriter::setValue((uint64_t)a3, (long long *)v230[0], v167 - 16);
          std::vector<std::string>::~vector[abi:ne180100](v230);
        }
        if (v235.__begin_)
        {
          v235.__end_ = v235.__begin_;
          operator delete(v235.__begin_);
        }
        if (__p[0] != &__p[2]) {
          free(__p[0]);
        }
        if (v164 == v165)
        {
LABEL_315:
          uint64_t v96 = 1;
          goto LABEL_316;
        }
      }
LABEL_258:
      int64_t size = v225.__r_.__value_.__l.__size_;
      if ((v225.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      {
        int v40 = (std::string *)v225.__r_.__value_.__r.__words[0];
      }
      else
      {
        int64_t size = HIBYTE(v225.__r_.__value_.__r.__words[2]);
        int v40 = &v225;
      }
      if (size <= 22) {
        goto LABEL_262;
      }
      goto LABEL_92;
    }
    v207 = "!empty()";
    int v208 = 175;
    int v209 = "back";
LABEL_340:
    __assert_rtn(v209, "ArrayRef.h", v208, v207);
  }
  if (v126 <= 1)
  {
    v207 = "Index < Length && \"Invalid index!\"";
    int v208 = 257;
    int v209 = "operator[]";
    goto LABEL_340;
  }
  unint64_t v127 = Value + 8 * v126;
  if (*(void *)(v127 - 8) != 1) {
    goto LABEL_258;
  }
  uint64_t v128 = *(void *)(v127 - 16);
  if (v128 != 4 && v128 != 256 && v128 != 16) {
    goto LABEL_258;
  }
  HIBYTE(__p[2]) = 11;
  strcpy((char *)__p, "vector_axis");
  Parameteruint64_t Value = (MIL::IRValue *)MIL::IROperation::TryGetParameterValue();
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  if (!ParameterValue)
  {
LABEL_224:
    LODWORD(v235.__begin_) = -1;
    std::vector<int>::vector[abi:ne180100](__p, &v235, 1uLL);
    v230[0] = (void *)1;
    uint64_t v134 = mlir::Builder::getIntegerType((mlir::Builder *)v215, 0x20u, 1);
    v235.__begin_ = (std::vector<int>::pointer)mlir::RankedTensorType::get((uint64_t)v230, 1, v134, 0);
    uint64_t v135 = LocationForOp;
    std::vector<int> v136 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v235);
    v227 = (const char *)mlir::DenseIntElementsAttr::get<std::vector<int> &>((uint64_t)v136, v137, (uint64_t)__p[0], (uint64_t)__p[1]);
    v230[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v215, v135, (uint64_t **)&v227);
    __int16 v138 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::mps::ConstantOp &>((mlir::OpBuilder *)v215, LocationForOp, &OptionalArgValue, v230);
    if (!*((_DWORD *)v138 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    OptionalArguint64_t Value = (uint64_t)v138 - 16;
    uint64_t MLIRElemType = 0;
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    uint64_t v139 = mlir::OpBuilder::create<mlir::mps::DequantizeLUTOp,mlir::Value &,mlir::Value &,mlir::IntegerAttr &>(v215, LocationForOp, &ArgValue, &OptionalArgValue, &MLIRElemType);
    if (!*(_DWORD *)(v139 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    v235.__begin_ = (std::vector<int>::pointer)(v139 - 16);
    if (v116)
    {
      unint64_t v140 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(v215, LocationForOp, (uint64_t *)&v235, &v221);
      if (!*((_DWORD *)v140 + 9)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
      v235.__begin_ = (std::vector<int>::pointer)((char *)v140 - 16);
    }
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(__p, a2);
    MILToMLIRRewriter::setValue((uint64_t)a3, (long long *)__p[0], (uint64_t)v235.__begin_);
    std::vector<std::string>::~vector[abi:ne180100](__p);
    goto LABEL_315;
  }
  uint64_t v130 = (MIL::IRValueType *)(*(uint64_t (**)(MIL::IRValue *))(*(void *)ParameterValue + 32))(ParameterValue);
  uint64_t v131 = MIL::IRValueType::AsTensorType(v130);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v131 + 88))(v131) == 11)
  {
    MIL::IRValue::AsTensor(ParameterValue);
    uint64_t v132 = *(int *)MIL::IRTensorValue::GetDataView<int>();
    uint64_t v133 = mlir::Builder::getIntegerType((mlir::Builder *)v215, 0x20u, 1);
    uint64_t MLIRElemType = mlir::IntegerAttr::get(v133, v132);
    goto LABEL_224;
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "unexpected type for axis");
  MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v96 = 0;
LABEL_316:
  if (SHIBYTE(v225.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v225.__r_.__value_.__l.__data_);
  }
  return v96;
}

void sub_180D49898(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  if (a41 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::FloatType>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v24[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.cast";
    v21[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  mlir::mps::CastOp::build(a1, (uint64_t)v24, *a3, *a4);
  float v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    uint64_t v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v15 = 662;
    uint64_t v16 = "Casting.h";
    int v17 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::CastOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CastOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    uint64_t v14 = "result && \"builder didn't return the right type\"";
    int v15 = 497;
    uint64_t v16 = "Builders.h";
    int v17 = "create";
LABEL_8:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180D49D14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D49D2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::Type::dyn_cast<mlir::RankedTensorType>(uint64_t result)
{
  if (!result) {
    __assert_rtn("dyn_cast", "Casting.h", 650, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
  }
  if (!*(void *)result) {
    __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
  }
  if (*(_UNKNOWN **)(*(void *)result + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    return 0;
  }
  return result;
}

uint64_t mlir::OpBuilder::create<mlir::mps::DequantizeLUTOp,mlir::Value &,mlir::Value &,mlir::IntegerAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  v26[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dequantize_lut", (const unsigned __int8 *)0x12, Context);
  if (!v12)
  {
    __int16 v24 = 1283;
    v23[2] = (uint64_t)"mps.dequantize_lut";
    v23[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v11);
  mlir::mps::DequantizeLUTOp::build(a1, (uint64_t)v26, *a3, *a4, *a5);
  int64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v26);
  if (!v13)
  {
    uint64_t v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v17 = 662;
    uint64_t v18 = "Casting.h";
    uint64_t v19 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v14 = llvm::DefaultDoCastIfPossible<mlir::mps::DequantizeLUTOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DequantizeLUTOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    uint64_t v16 = "result && \"builder didn't return the right type\"";
    int v17 = 497;
    uint64_t v18 = "Builders.h";
    uint64_t v19 = "create";
LABEL_8:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v14;
}

void sub_180D49F40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D49F58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void *llvm::SmallVector<long long,4u>::SmallVector(void *a1, unsigned char *a2, uint64_t a3)
{
  *a1 = a1 + 2;
  a1[1] = 0x400000000;
  llvm::SmallVectorImpl<long long>::append<long long const*,void>((uint64_t)a1, a2, &a2[8 * a3]);
  return a1;
}

void sub_180D49FAC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v2;
  if (*v1 != v3) {
    free(*v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Util::Span<unsigned int const,18446744073709551615ul>::operator[](uint64_t a1, unint64_t a2, unint64_t a3)
{
  if (a2 <= a3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::range_error::range_error[abi:ne180100](exception);
    __cxa_throw(exception, (struct type_info *)off_1E4FBE4C0, MEMORY[0x1E4FBA1B8]);
  }
  return a1 + 4 * a3;
}

void sub_180D4A024(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void **std::vector<std::shared_ptr<MIL::IRValue const>>::~vector[abi:ne180100](void **a1)
{
  std::vector<int>::size_type v2 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = (std::__shared_weak_count *)*((void *)v3 - 1);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t MILToMLIR::ReshapeLikePattern::matchAndRewrite(MILToMLIR::ReshapeLikePattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  unint64_t v107 = (MILToMLIRRewriter *)a3;
  MILToMLIRRewriter::getArgValues((int8x8_t *)a3, a2, "ref_tensors", &v123);
  char v121 = 6;
  strcpy((char *)__p, "begins");
  uint64_t v111 = a2;
  MILToMLIR::getVariadicConstants<int>((char **)v122, (uint64_t)a2, (uint64_t)__p);
  if (v121 < 0) {
    operator delete(__p[0]);
  }
  HIBYTE(v119) = 4;
  strcpy((char *)v118, "ends");
  MILToMLIR::getVariadicConstants<int>((char **)__p, (uint64_t)a2, (uint64_t)v118);
  if (SHIBYTE(v119) < 0) {
    operator delete(v118[0]);
  }
  uint64_t v106 = LocationForOp;
  HIBYTE(v119) = 9;
  strcpy((char *)v118, "end_masks");
  uint64_t v6 = (*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 160))(a2);
  uint64_t v7 = v6 + 8;
  uint64_t v8 = *(void *)(v6 + 8);
  if (!v8) {
    goto LABEL_44;
  }
  uint64_t v9 = SHIBYTE(v119) >= 0 ? (void *)HIBYTE(v119) : v118[1];
  char v10 = SHIBYTE(v119) >= 0 ? v118 : (void **)v118[0];
  uint64_t v11 = v6 + 8;
  do
  {
    int v12 = *(char *)(v8 + 55);
    if (v12 >= 0) {
      size_t v13 = *(unsigned __int8 *)(v8 + 55);
    }
    else {
      size_t v13 = *(void *)(v8 + 40);
    }
    if (v12 >= 0) {
      uint64_t v14 = (const void *)(v8 + 32);
    }
    else {
      uint64_t v14 = *(const void **)(v8 + 32);
    }
    if ((unint64_t)v9 >= v13) {
      size_t v15 = v13;
    }
    else {
      size_t v15 = (size_t)v9;
    }
    int v16 = memcmp(v14, v10, v15);
    BOOL v17 = v13 < (unint64_t)v9;
    if (v16) {
      BOOL v17 = v16 < 0;
    }
    BOOL v18 = !v17;
    if (v17) {
      uint64_t v19 = (uint64_t *)(v8 + 8);
    }
    else {
      uint64_t v19 = (uint64_t *)v8;
    }
    if (v18) {
      uint64_t v11 = v8;
    }
    uint64_t v8 = *v19;
  }
  while (*v19);
  if (v11 == v7) {
    goto LABEL_44;
  }
  int v20 = *(char *)(v11 + 55);
  if (v20 >= 0) {
    size_t v21 = *(unsigned __int8 *)(v11 + 55);
  }
  else {
    size_t v21 = *(void *)(v11 + 40);
  }
  if (v20 >= 0) {
    __int16 v22 = (const void *)(v11 + 32);
  }
  else {
    __int16 v22 = *(const void **)(v11 + 32);
  }
  if (v21 >= (unint64_t)v9) {
    size_t v23 = (size_t)v9;
  }
  else {
    size_t v23 = v21;
  }
  int v24 = memcmp(v10, v22, v23);
  BOOL v25 = (unint64_t)v9 < v21;
  if (v24) {
    BOOL v25 = v24 < 0;
  }
  if (v25) {
LABEL_44:
  }
    uint64_t v11 = v7;
  if (v11 != (*(uint64_t (**)(const MIL::IROperation *))(*(void *)v111 + 160))(v111) + 8)
  {
    int v26 = (*(uint64_t (**)(const MIL::IROperation *, void **))(*(void *)v111 + 152))(v111, v118);
    if (v26)
    {
      BOOL v27 = 0;
      unint64_t v28 = 0;
      unint64_t v29 = 0;
      int v30 = 0;
      int v112 = v26;
      while (1)
      {
        Parameteruint64_t Value = MIL::IROperation::TryGetParameterValue();
        (*(void (**)(uint64_t))(*(void *)ParameterValue + 40))(ParameterValue);
        uint64_t Data = MIL::IRTensorValue::GetDataView<BOOL>();
        int v114 = v30;
        if (v34) {
          break;
        }
        unint64_t v31 = v29;
LABEL_49:
        int v30 = v114 + 1;
        unint64_t v29 = v31;
        if (v114 + 1 == v112) {
          goto LABEL_85;
        }
      }
      BOOL v35 = (unsigned __int8 *)Data;
      BOOL v36 = (unsigned __int8 *)(Data + v34);
      while (1)
      {
        int v37 = *v35;
        unint64_t v31 = v29 + 1;
        unint64_t v38 = v29 >> 6;
        if (v29 == v28 << 6)
        {
          if ((v31 & 0x8000000000000000) != 0) {
            goto LABEL_177;
          }
          if (v29 <= 0x3FFFFFFFFFFFFFFELL)
          {
            unint64_t v39 = v28 << 7;
            if (v28 << 7 <= (v29 & 0xFFFFFFFFFFFFFFC0) + 64) {
              unint64_t v39 = (v29 & 0xFFFFFFFFFFFFFFC0) + 64;
            }
            if (v29 >= v39) {
              goto LABEL_81;
            }
            if ((v39 & 0x8000000000000000) != 0) {
LABEL_177:
            }
              std::vector<int>::__throw_length_error[abi:ne180100]();
LABEL_62:
            unint64_t v28 = ((v39 - 1) >> 6) + 1;
            int v40 = operator new(8 * v28);
            int64_t v41 = v40;
            unint64_t v42 = (v29 - 1) >> 6;
            if (v29 < 0x41) {
              unint64_t v42 = 0;
            }
            v40[v42] = 0;
            if (v29 > 0x3F || (v29 & 0x3F) != 0)
            {
              int v43 = 0;
              int v44 = 0;
              uint64_t v45 = v40;
              uint64_t v46 = v27;
              do
              {
                uint64_t v47 = 1 << v43;
                if ((*v46 >> v44)) {
                  uint64_t v48 = *v45 | v47;
                }
                else {
                  uint64_t v48 = *v45 & ~v47;
                }
                *uint64_t v45 = v48;
                v46 += v44 == 63;
                if (v44 == 63) {
                  int v44 = 0;
                }
                else {
                  ++v44;
                }
                v45 += v43 == 63;
                if (v43 == 63) {
                  int v43 = 0;
                }
                else {
                  ++v43;
                }
              }
              while (v44 != (v29 & 0x3F) || v46 != &v27[v38]);
            }
            if (v27) {
              operator delete(v27);
            }
            BOOL v27 = v41;
            goto LABEL_81;
          }
          unint64_t v39 = 0x7FFFFFFFFFFFFFFFLL;
          if (v29 < 0x7FFFFFFFFFFFFFFFLL) {
            goto LABEL_62;
          }
        }
LABEL_81:
        uint64_t v49 = 1 << v29;
        if (v37)
        {
          v27[v38] |= v49;
          ++v35;
          ++v29;
          if (v35 == v36) {
            goto LABEL_49;
          }
        }
        else
        {
          v27[v38] &= ~v49;
          ++v35;
          ++v29;
          if (v35 == v36) {
            goto LABEL_49;
          }
        }
      }
    }
  }
  BOOL v27 = 0;
  unint64_t v31 = 0;
LABEL_85:
  if (SHIBYTE(v119) < 0)
  {
    operator delete(v118[0]);
    v118[0] = 0;
    v118[1] = 0;
    uint64_t v119 = 0;
    uint64_t v50 = v123;
    uint64_t v109 = v27;
    if (v124 != (unsigned char *)v123) {
      goto LABEL_87;
    }
LABEL_137:
    uint64_t v82 = 0;
    uint64_t v53 = 0;
    goto LABEL_143;
  }
  v118[0] = 0;
  v118[1] = 0;
  uint64_t v119 = 0;
  uint64_t v50 = v123;
  uint64_t v109 = v27;
  if (v124 == (unsigned char *)v123) {
    goto LABEL_137;
  }
LABEL_87:
  int v51 = 0;
  uint64_t v52 = 0;
  uint64_t v53 = 0;
  unint64_t v54 = 0;
  unint64_t v108 = v31;
  do
  {
    uint64_t v55 = (uint64_t *)(*(void *)(v50[v54] + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v55)
    {
      int v102 = 650;
      uint64_t v103 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      char v104 = "Casting.h";
      std::string v105 = "dyn_cast";
      goto LABEL_173;
    }
    if (!*v55)
    {
      int v102 = 160;
      std::string v105 = "getAbstractType";
      char v104 = "TypeSupport.h";
      uint64_t v103 = "abstractType && \"Malformed type storage object.\"";
LABEL_173:
      __assert_rtn(v105, v104, v102, v103);
    }
    if (*(_UNKNOWN **)(*v55 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
      uint64_t v55 = 0;
    }
    v117[0] = v55;
    uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v117);
    int v58 = *((_DWORD *)__p[0] + v54);
    if (v31 && ((*(void *)((char *)v27 + ((v54 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v54) & 1) != 0) {
      int v58 = v57;
    }
    int v59 = *((_DWORD *)v122[0] + v54);
    int v60 = v57 & (v59 >> 31);
    unint64_t v61 = (v60 + v59);
    if (v60 + v59 < 0 || v57 <= v61)
    {
      v117[0] = (uint64_t *)operator new(0x19uLL);
      *(_OWORD *)&v117[1] = xmmword_1810FDFC0;
      uint64_t v83 = MILToMLIRRewriter::notifyFailure((uint64_t)v107, (uint64_t *)v117);
LABEL_140:
      uint64_t v84 = v83;
      if (SHIBYTE(v117[2]) < 0) {
        operator delete(v117[0]);
      }
      goto LABEL_159;
    }
    unint64_t v62 = (v57 & (v58 >> 31)) + v58;
    if ((v62 & 0x80000000) != 0 || v57 < v62)
    {
      HIBYTE(v117[2]) = 21;
      uint64_t v83 = MILToMLIRRewriter::notifyFailure((uint64_t)v107, (uint64_t *)v117);
      goto LABEL_140;
    }
    unint64_t v110 = v54;
    if (v61 < v62)
    {
      if (v57 <= v61) {
        unint64_t v63 = (v60 + v59);
      }
      else {
        unint64_t v63 = v57;
      }
      uint64_t v64 = v53;
      unint64_t v113 = v63;
      uint64_t v115 = Value;
      do
      {
        while (1)
        {
          if (v61 == v63) {
            __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
          }
          uint64_t v65 = *(void *)(Value + 8 * v61);
          if (v64 >= v52) {
            break;
          }
          *(_DWORD *)uint64_t v64 = v65;
          v64 += 4;
          uint64_t v53 = v64;
          v118[1] = v64;
          if ((int)v62 <= (int)++v61) {
            goto LABEL_88;
          }
        }
        uint64_t v66 = (v64 - v51) >> 2;
        unint64_t v67 = v66 + 1;
        if ((unint64_t)(v66 + 1) >> 62) {
          std::vector<int>::__throw_length_error[abi:ne180100]();
        }
        if ((v52 - v51) >> 1 > v67) {
          unint64_t v67 = (v52 - v51) >> 1;
        }
        if ((unint64_t)(v52 - v51) >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v68 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v68 = v67;
        }
        if (v68)
        {
          if (v68 >> 62) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v69 = operator new(4 * v68);
          uint64_t v70 = &v69[4 * v66];
          *(_DWORD *)uint64_t v70 = v65;
          uint64_t v53 = v70 + 4;
          int64_t v71 = v64 - v51;
          if (v64 == v51) {
            goto LABEL_122;
          }
        }
        else
        {
          uint64_t v69 = 0;
          uint64_t v70 = (char *)(4 * v66);
          *(_DWORD *)(4 * v66) = v65;
          uint64_t v53 = (char *)(4 * v66 + 4);
          int64_t v71 = v64 - v51;
          if (v64 == v51) {
            goto LABEL_122;
          }
        }
        unint64_t v72 = v71 - 4;
        if (v72 >= 0xBC)
        {
          unint64_t v75 = (v64 - 4 - v51) & 0xFFFFFFFFFFFFFFFCLL;
          if (&v69[v64 - v51 - 4 - v75] > &v69[v64 - v51 - 4])
          {
            uint64_t v73 = v64;
          }
          else if (&v64[-v75 - 4] > v64 - 4)
          {
            uint64_t v73 = v64;
          }
          else if ((unint64_t)(v51 - v69) >= 0x20)
          {
            uint64_t v76 = (v72 >> 2) + 1;
            uint64_t v77 = 4 * (v76 & 0x7FFFFFFFFFFFFFF8);
            uint64_t v73 = &v64[-v77];
            v70 -= v77;
            unsigned int v78 = &v69[4 * v66 - 16];
            uint64_t v79 = (long long *)(v64 - 16);
            uint64_t v80 = v76 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v81 = *v79;
              *(v78 - 1) = *(v79 - 1);
              *unsigned int v78 = v81;
              v78 -= 2;
              v79 -= 2;
              v80 -= 8;
            }
            while (v80);
            if (v76 == (v76 & 0x7FFFFFFFFFFFFFF8)) {
              goto LABEL_122;
            }
          }
          else
          {
            uint64_t v73 = v64;
          }
        }
        else
        {
          uint64_t v73 = v64;
        }
        do
        {
          int v74 = *((_DWORD *)v73 - 1);
          v73 -= 4;
          *((_DWORD *)v70 - 1) = v74;
          v70 -= 4;
        }
        while (v73 != v51);
LABEL_122:
        uint64_t v52 = &v69[4 * v68];
        v118[0] = v70;
        v118[1] = v53;
        uint64_t v119 = v52;
        if (v51) {
          operator delete(v51);
        }
        int v51 = v70;
        unint64_t v63 = v113;
        uint64_t Value = v115;
        v118[1] = v53;
        ++v61;
        uint64_t v64 = v53;
      }
      while ((int)v62 > (int)v61);
    }
LABEL_88:
    BOOL v27 = v109;
    unint64_t v54 = v110 + 1;
    uint64_t v50 = v123;
    unint64_t v31 = v108;
  }
  while (v110 + 1 < (v124 - (unsigned char *)v123) >> 3);
  uint64_t v82 = v118[0];
LABEL_143:
  __int16 v85 = (MILToMLIRRewriter *)((char *)v107 + 144);
  v117[0] = (uint64_t *)((v53 - v82) >> 2);
  uint64_t IntegerType = mlir::Builder::getIntegerType((MILToMLIRRewriter *)((char *)v107 + 144), 0x20u, 1);
  uint64_t v87 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)v117, 1, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v87)) {
    goto LABEL_174;
  }
  if (v87)
  {
    uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v87);
    if (!InterfaceFor)
    {
      std::vector<int>::pointer v89 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v90 = 98;
      int v91 = "InterfaceSupport.h";
      uint64_t v92 = "Interface";
      goto LABEL_175;
    }
  }
  else
  {
    uint64_t InterfaceFor = 0;
  }
  uint64_t v93 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v87, InterfaceFor, v82, v53 - v82, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v93) & 1) == 0)
  {
LABEL_174:
    std::vector<int>::pointer v89 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v90 = 566;
    int v91 = "Casting.h";
    uint64_t v92 = "cast";
LABEL_175:
    __assert_rtn(v92, v91, v90, v89);
  }
  v117[0] = v93;
  int v116 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v85, v106, v117);
  std::vector<int>::pointer v94 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::UnitAttr **)v85, v106, &ArgValue, &v116);
  (*(void (**)(uint64_t **__return_ptr))(*(void *)v111 + 200))(v117);
  if (!*((_DWORD *)v94 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  std::vector<int>::pointer v95 = (long long *)v117[0];
  uint64_t v96 = (char *)operator new(8uLL);
  *(void *)uint64_t v96 = (char *)v94 - 16;
  unint64_t v126 = v95;
  uint64_t v97 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v107 + 64, (uint64_t)v95, (uint64_t)&std::piecewise_construct, &v126);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v97 + 5, v96, v96 + 8, 1uLL);
  operator delete(v96);
  uint64_t v98 = v117[0];
  if (v117[0])
  {
    uint64_t v99 = v117[1];
    uint64_t v100 = v117[0];
    if (v117[1] != v117[0])
    {
      do
      {
        if (*((char *)v99 - 1) < 0) {
          operator delete((void *)*(v99 - 3));
        }
        v99 -= 3;
      }
      while (v99 != v98);
      uint64_t v100 = v117[0];
    }
    v117[1] = v98;
    operator delete(v100);
  }
  uint64_t v84 = 1;
  BOOL v27 = v109;
LABEL_159:
  if (v118[0]) {
    operator delete(v118[0]);
  }
  if (v27) {
    operator delete(v27);
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v122[0])
  {
    v122[1] = v122[0];
    operator delete(v122[0]);
  }
  if (v123)
  {
    __int16 v124 = v123;
    operator delete(v123);
  }
  return v84;
}

void sub_180D4AB90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,void *a38,uint64_t a39)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a26) {
    operator delete(a26);
  }
  if (a13) {
    operator delete(a13);
  }
  if (a32) {
    operator delete(a32);
  }
  if (a38) {
    operator delete(a38);
  }
  int64_t v41 = *(void **)(v39 - 136);
  if (v41)
  {
    *(void *)(v39 - 128) = v41;
    operator delete(v41);
  }
  _Unwind_Resume(exception_object);
}

void MILToMLIR::getVariadicConstants<int>(char **a1, uint64_t a2, uint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 160))(a2);
  uint64_t v5 = v4 + 8;
  uint64_t v6 = *(void *)(v4 + 8);
  if (!v6) {
    goto LABEL_40;
  }
  int v7 = *(char *)(a3 + 23);
  size_t v8 = v7 >= 0 ? *(unsigned __int8 *)(a3 + 23) : *(void *)(a3 + 8);
  uint64_t v9 = v7 >= 0 ? (const void *)a3 : *(const void **)a3;
  uint64_t v10 = v4 + 8;
  do
  {
    int v11 = *(char *)(v6 + 55);
    if (v11 >= 0) {
      size_t v12 = *(unsigned __int8 *)(v6 + 55);
    }
    else {
      size_t v12 = *(void *)(v6 + 40);
    }
    if (v11 >= 0) {
      size_t v13 = (const void *)(v6 + 32);
    }
    else {
      size_t v13 = *(const void **)(v6 + 32);
    }
    if (v8 >= v12) {
      size_t v14 = v12;
    }
    else {
      size_t v14 = v8;
    }
    int v15 = memcmp(v13, v9, v14);
    BOOL v16 = v12 < v8;
    if (v15) {
      BOOL v16 = v15 < 0;
    }
    BOOL v17 = !v16;
    if (v16) {
      BOOL v18 = (uint64_t *)(v6 + 8);
    }
    else {
      BOOL v18 = (uint64_t *)v6;
    }
    if (v17) {
      uint64_t v10 = v6;
    }
    uint64_t v6 = *v18;
  }
  while (*v18);
  if (v10 == v5) {
    goto LABEL_40;
  }
  int v19 = *(char *)(v10 + 55);
  if (v19 >= 0) {
    size_t v20 = *(unsigned __int8 *)(v10 + 55);
  }
  else {
    size_t v20 = *(void *)(v10 + 40);
  }
  if (v19 >= 0) {
    size_t v21 = (const void *)(v10 + 32);
  }
  else {
    size_t v21 = *(const void **)(v10 + 32);
  }
  if (v20 >= v8) {
    size_t v22 = v8;
  }
  else {
    size_t v22 = v20;
  }
  int v23 = memcmp(v9, v21, v22);
  BOOL v24 = v8 < v20;
  if (v23) {
    BOOL v24 = v23 < 0;
  }
  if (v24) {
LABEL_40:
  }
    uint64_t v10 = v5;
  if (v10 != (*(uint64_t (**)(uint64_t))(*(void *)a2 + 160))(a2) + 8)
  {
    int v25 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 152))(a2, a3);
    if (v25)
    {
      int v26 = 0;
      BOOL v27 = 0;
      unint64_t v28 = 0;
      int v29 = 0;
      int v53 = v25;
      while (1)
      {
        Parameteruint64_t Value = MIL::IROperation::TryGetParameterValue();
        (*(void (**)(uint64_t))(*(void *)ParameterValue + 40))(ParameterValue);
        uint64_t Data = MIL::IRTensorValue::GetDataView<int>();
        if (v33) {
          break;
        }
        uint64_t v30 = (uint64_t)v28;
LABEL_45:
        ++v29;
        unint64_t v28 = (char *)v30;
        if (v29 == v53) {
          return;
        }
      }
      uint64_t v34 = (int *)Data;
      BOOL v35 = (int *)(Data + 4 * v33);
      int v57 = v29;
      uint64_t v56 = v35;
      while (1)
      {
        while (1)
        {
          int v36 = *v34;
          if (v28 >= v27) {
            break;
          }
          *(_DWORD *)unint64_t v28 = v36;
          v28 += 4;
          uint64_t v30 = (uint64_t)v28;
          a1[1] = v28;
          if (++v34 == v35) {
            goto LABEL_45;
          }
        }
        uint64_t v37 = (v28 - v26) >> 2;
        unint64_t v38 = v37 + 1;
        if ((unint64_t)(v37 + 1) >> 62) {
          std::vector<int>::__throw_length_error[abi:ne180100]();
        }
        if ((v27 - v26) >> 1 > v38) {
          unint64_t v38 = (v27 - v26) >> 1;
        }
        if ((unint64_t)(v27 - v26) >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v39 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v39 = v38;
        }
        if (v39)
        {
          if (v39 >> 62) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          int v40 = operator new(4 * v39);
          int64_t v41 = &v40[4 * v37];
          *(_DWORD *)int64_t v41 = v36;
          uint64_t v30 = (uint64_t)(v41 + 4);
          int64_t v42 = v28 - v26;
          if (v28 == v26) {
            goto LABEL_64;
          }
        }
        else
        {
          int v40 = 0;
          int64_t v41 = (char *)(4 * v37);
          *(_DWORD *)(4 * v37) = v36;
          uint64_t v30 = 4 * v37 + 4;
          int64_t v42 = v28 - v26;
          if (v28 == v26) {
            goto LABEL_64;
          }
        }
        unint64_t v43 = v42 - 4;
        if (v43 < 0xBC)
        {
          int v44 = v28;
          goto LABEL_63;
        }
        unint64_t v46 = (v28 - 4 - v26) & 0xFFFFFFFFFFFFFFFCLL;
        if (&v40[v28 - v26 - 4 - v46] > &v40[v28 - v26 - 4]) {
          break;
        }
        if (&v28[-v46 - 4] > v28 - 4)
        {
          int v44 = v28;
          goto LABEL_63;
        }
        if ((unint64_t)(v26 - v40) < 0x20)
        {
          int v44 = v28;
          goto LABEL_63;
        }
        uint64_t v47 = (v43 >> 2) + 1;
        uint64_t v48 = 4 * (v47 & 0x7FFFFFFFFFFFFFF8);
        int v44 = &v28[-v48];
        v41 -= v48;
        uint64_t v49 = &v40[4 * v37 - 16];
        uint64_t v50 = v28 - 16;
        uint64_t v51 = v47 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v52 = *(_OWORD *)v50;
          *(v49 - 1) = *((_OWORD *)v50 - 1);
          _OWORD *v49 = v52;
          v49 -= 2;
          v50 -= 32;
          v51 -= 8;
        }
        while (v51);
        if (v47 != (v47 & 0x7FFFFFFFFFFFFFF8)) {
          goto LABEL_63;
        }
LABEL_64:
        BOOL v27 = &v40[4 * v39];
        *a1 = v41;
        a1[1] = (char *)v30;
        a1[2] = v27;
        if (v26) {
          operator delete(v26);
        }
        int v26 = v41;
        int v29 = v57;
        BOOL v35 = v56;
        a1[1] = (char *)v30;
        ++v34;
        unint64_t v28 = (char *)v30;
        if (v34 == v56) {
          goto LABEL_45;
        }
      }
      int v44 = v28;
      do
      {
LABEL_63:
        int v45 = *((_DWORD *)v44 - 1);
        v44 -= 4;
        *((_DWORD *)v41 - 1) = v45;
        v41 -= 4;
      }
      while (v44 != v26);
      goto LABEL_64;
    }
  }
}

void sub_180D4B0A8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MILToMLIR::QuantizePattern::matchAndRewrite(MILToMLIR::QuantizePattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v4 = a2;
  v289[5] = *(uint64_t **)MEMORY[0x1E4F143B8];
  uint64_t v5 = (*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 56))(a2);
  if (*(char *)(v5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v280, *(const std::string::value_type **)v5, *(void *)(v5 + 8));
  }
  else
  {
    long long v6 = *(_OWORD *)v5;
    v280.__r_.__value_.__r.__words[2] = *(void *)(v5 + 16);
    *(_OWORD *)&v280.__r_.__value_.__l.__data_ = v6;
  }
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, v4);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, v4, "input");
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
  uint64_t v270 = (MILToMLIRRewriter *)a3;
  uint64_t MLIRElemType = 0;
  uint64_t Value = ElementTypeOrSelf;
  BOOL v8 = 0;
  if ((SHIBYTE(v280.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    HIDWORD(v9) = SHIBYTE(v280.__r_.__value_.__r.__words[2]);
    LODWORD(v9) = (SHIBYTE(v280.__r_.__value_.__r.__words[2]) << 24) - 234881024;
    uint64_t v10 = &v280;
    BOOL v11 = 0;
    BOOL v12 = 0;
    switch((v9 >> 25))
    {
      case 0u:
        BOOL v11 = 0;
        BOOL v12 = 0;
        BOOL v8 = v280.__r_.__value_.__r.__words[0] == 0x75712E3731736F69
          && *(std::string::size_type *)((char *)v280.__r_.__value_.__r.__words + 6) == 0x657A69746E617571;
        if (v8) {
          goto LABEL_50;
        }
        goto LABEL_49;
      case 1u:
        BOOL v8 = 0;
        BOOL v12 = 0;
        BOOL v11 = v280.__r_.__value_.__r.__words[0] == 0x65642E3731736F69
           && v280.__r_.__value_.__l.__size_ == 0x657A69746E617571;
        goto LABEL_49;
      case 2u:
      case 3u:
        goto LABEL_49;
      case 4u:
        goto LABEL_40;
      case 5u:
        BOOL v8 = 0;
        BOOL v12 = 0;
        BOOL v11 = v280.__r_.__value_.__r.__words[0] == 0x79642E3731736F69
           && v280.__r_.__value_.__l.__size_ == 0x65645F63696D616ELL
           && v280.__r_.__value_.__r.__words[2] == 0x657A69746E617571;
        goto LABEL_49;
      default:
        goto LABEL_38;
    }
  }
  *((void *)&v14 + 1) = v280.__r_.__value_.__l.__size_;
  *(void *)&long long v14 = v280.__r_.__value_.__l.__size_ - 14;
  BOOL v11 = 0;
  BOOL v12 = 0;
  switch((unint64_t)(v14 >> 1))
  {
    case 0uLL:
      BOOL v11 = 0;
      BOOL v12 = 0;
      BOOL v8 = *(void *)v280.__r_.__value_.__l.__data_ == 0x75712E3731736F69
        && *(void *)(v280.__r_.__value_.__r.__words[0] + 6) == 0x657A69746E617571;
      if (v8) {
        goto LABEL_50;
      }
      goto LABEL_49;
    case 1uLL:
      if (*(void *)v280.__r_.__value_.__l.__data_ == 0x65642E3731736F69
        && *(void *)(v280.__r_.__value_.__r.__words[0] + 8) == 0x657A69746E617571)
      {
        BOOL v11 = 1;
        BOOL v8 = 0;
      }
      else
      {
        BOOL v8 = 0;
        BOOL v11 = 0;
      }
      BOOL v12 = 0;
      goto LABEL_49;
    case 2uLL:
    case 3uLL:
      goto LABEL_49;
    case 4uLL:
      uint64_t v10 = (std::string *)v280.__r_.__value_.__r.__words[0];
LABEL_40:
      BOOL v8 = 0;
      BOOL v11 = 0;
      std::string::size_type v19 = v10->__r_.__value_.__r.__words[0];
      std::string::size_type size = v10->__r_.__value_.__l.__size_;
      uint64_t v21 = *(std::string::size_type *)((char *)&v10->__r_.__value_.__r.__words[1] + 6);
      BOOL v12 = v19 == 0x79642E3731736F69 && size == 0x75715F63696D616ELL && v21 == 0x657A69746E617571;
      goto LABEL_49;
    case 5uLL:
      BOOL v11 = *(void *)v280.__r_.__value_.__l.__data_ == 0x79642E3731736F69
         && *(void *)(v280.__r_.__value_.__r.__words[0] + 8) == 0x65645F63696D616ELL
         && *(void *)(v280.__r_.__value_.__r.__words[0] + 16) == 0x657A69746E617571;
      BOOL v8 = 0;
      BOOL v12 = 0;
      goto LABEL_49;
    default:
LABEL_38:
      BOOL v11 = 0;
      BOOL v12 = 0;
LABEL_49:
      if (!v12) {
        goto LABEL_53;
      }
LABEL_50:
      HIBYTE(__p[2]) = 12;
      strcpy((char *)__p, "output_dtype");
      MIL::IROperation::TryGetParameterValue();
      if (SHIBYTE(__p[2]) < 0) {
        operator delete(__p[0]);
      }
      MIL::IRValue::GetScalar<std::string>();
      uint64_t MLIRElemType = MILToMLIRRewriter::getMLIRElemType((uint64_t)a3, (uint64_t)__p);
      uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&MLIRElemType);
      if (SHIBYTE(__p[2]) < 0)
      {
        operator delete(__p[0]);
        BOOL v24 = (mlir::OpBuilder *)(a3 + 18);
        if (v8 || v11)
        {
LABEL_54:
          int v25 = a3;
          v284[0] = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, v4, "scale");
          v282[0] = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, v4, "zero_point");
          if (!v282[0])
          {
            __p[0] = (void *)1;
            int v26 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, Value, 0);
            __p[0] = (void *)mlir::mps::getConstantAttr<int>(v26, 0);
            BOOL v27 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v24, LocationForOp, (uint64_t **)__p);
            if (!*((_DWORD *)v27 + 9)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
            v282[0] = (uint64_t)v27 - 16;
          }
          if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor((uint64_t **)(*(void *)(v284[0] + 8) & 0xFFFFFFFFFFFFFFF8))) {
            goto LABEL_233;
          }
          unint64_t v28 = (uint64_t **)(*(void *)(v284[0] + 8) & 0xFFFFFFFFFFFFFFF8);
          if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v28))
          {
            uint64_t v30 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
            int v31 = 566;
            std::string::size_type v32 = "Casting.h";
            uint64_t v33 = "cast";
LABEL_287:
            __assert_rtn(v33, v32, v31, v30);
          }
          if (v28)
          {
            uint64_t InterfaceFor = (void *)mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v28);
            if (!InterfaceFor)
            {
              uint64_t v30 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
              int v31 = 98;
              std::string::size_type v32 = "InterfaceSupport.h";
              uint64_t v33 = "Interface";
              goto LABEL_287;
            }
          }
          else
          {
            uint64_t InterfaceFor = 0;
          }
          __p[0] = v28;
          __p[1] = InterfaceFor;
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)__p)) {
            goto LABEL_233;
          }
          unint64_t v39 = (uint64_t **)(*(void *)(v284[0] + 8) & 0xFFFFFFFFFFFFFFF8);
          if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v39))
          {
            int64_t v41 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
            int v42 = 566;
            unint64_t v43 = "Casting.h";
            int v44 = "cast";
LABEL_299:
            __assert_rtn(v44, v43, v42, v41);
          }
          if (v39)
          {
            int v40 = (void *)mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v39);
            if (!v40)
            {
              int64_t v41 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
              int v42 = 98;
              unint64_t v43 = "InterfaceSupport.h";
              int v44 = "Interface";
              goto LABEL_299;
            }
          }
          else
          {
            int v40 = 0;
          }
          __p[0] = v39;
          __p[1] = v40;
          ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)__p);
          if (v191)
          {
            uint64_t v192 = *ArgAttrsAttr;
            uint64_t v281 = 0;
            if (v192 <= 1)
            {
              int v194 = 0;
            }
            else
            {
              HIBYTE(__p[2]) = 4;
              strcpy((char *)__p, "axis");
              Parameteruint64_t Value = (MIL::IRValue *)MIL::IROperation::GetParameterValue();
              if (SHIBYTE(__p[2]) < 0) {
                operator delete(__p[0]);
              }
              MIL::IRValue::AsTensor(ParameterValue);
              int v194 = *(_DWORD *)MIL::IRTensorValue::GetDataView<int>();
            }
          }
          else
          {
LABEL_233:
            int v194 = 0;
            uint64_t v281 = 0;
          }
          uint64_t IntegerType = mlir::Builder::getIntegerType(v24, 0x20u, 1);
          uint64_t v281 = mlir::IntegerAttr::get(IntegerType, v194);
          if (SHIBYTE(v280.__r_.__value_.__r.__words[2]) < 0)
          {
            if (v280.__r_.__value_.__l.__size_ != 14) {
              goto LABEL_243;
            }
            uint64_t v196 = (std::string *)v280.__r_.__value_.__r.__words[0];
          }
          else
          {
            if (SHIBYTE(v280.__r_.__value_.__r.__words[2]) != 14) {
              goto LABEL_243;
            }
            uint64_t v196 = &v280;
          }
          std::string::size_type v197 = v196->__r_.__value_.__r.__words[0];
          uint64_t v198 = *(std::string::size_type *)((char *)v196->__r_.__value_.__r.__words + 6);
          if (v197 == 0x75712E3731736F69 && v198 == 0x657A69746E617571)
          {
            uint64_t v201 = mlir::OpBuilder::create<mlir::mps::QuantizeOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::TypeAttr &,mlir::IntegerAttr &>((mlir::UnknownLoc **)v24, LocationForOp, &ArgValue, v284, v282, &MLIRElemType, &v281);
            if (!*(_DWORD *)(v201 + 36)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
            goto LABEL_244;
          }
LABEL_243:
          uint64_t v200 = mlir::getElementTypeOrSelf(v284[0]);
          uint64_t MLIRElemType = mlir::TypeAttr::get(v200);
          uint64_t v201 = mlir::OpBuilder::create<mlir::mps::DequantizeOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::TypeAttr &,mlir::IntegerAttr &>((mlir::Float32Type **)v24, LocationForOp, &ArgValue, v284, v282, &MLIRElemType, &v281);
          if (!*(_DWORD *)(v201 + 36)) {
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          }
LABEL_244:
          (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)v4 + 200))(__p, v4);
          v202 = (uint64_t *)__p[0];
          size_t v203 = (char *)operator new(8uLL);
          *(void *)size_t v203 = v201 - 16;
          v289[0] = v202;
          int v204 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(v25 + 8), (uint64_t)v202, (uint64_t)&std::piecewise_construct, (long long **)v289);
          std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v204 + 5, v203, v203 + 8, 1uLL);
          operator delete(v203);
          int v205 = (void **)__p[0];
          if (!__p[0])
          {
LABEL_280:
            uint64_t v38 = 1;
            goto LABEL_281;
          }
          BOOL v206 = (void **)__p[1];
          v207 = __p[0];
          if (__p[1] == __p[0])
          {
LABEL_279:
            __p[1] = v205;
            operator delete(v207);
            goto LABEL_280;
          }
          do
          {
            if (*((char *)v206 - 1) < 0) {
              operator delete(*(v206 - 3));
            }
            v206 -= 3;
          }
          while (v206 != v205);
LABEL_278:
          v207 = __p[0];
          goto LABEL_279;
        }
      }
      else
      {
LABEL_53:
        BOOL v24 = (mlir::OpBuilder *)(a3 + 18);
        if (v8 || v11) {
          goto LABEL_54;
        }
      }
      if (v12)
      {
        HIBYTE(__p[2]) = 14;
        strcpy((char *)__p, "has_zero_point");
        MIL::IROperation::TryGetParameterValue();
        char v34 = MIL::IRValue::GetScalar<BOOL>();
        uint64_t v35 = ElementTypeOrSelf;
        if (SHIBYTE(__p[2]) < 0) {
          operator delete(__p[0]);
        }
        HIBYTE(__p[2]) = 4;
        strcpy((char *)__p, "axis");
        uint64_t v36 = MIL::IROperation::TryGetParameterValue();
        uint64_t v37 = (MIL::IRValue *)v36;
        if (SHIBYTE(__p[2]) < 0)
        {
          operator delete(__p[0]);
          uint64_t v275 = 0;
          uint64_t v276 = 0;
          if (!v37) {
            goto LABEL_141;
          }
        }
        else
        {
          uint64_t v275 = 0;
          uint64_t v276 = 0;
          if (!v36) {
            goto LABEL_141;
          }
        }
        memset(__p, 0, 24);
        MIL::IRValue::AsTensor(v37);
        int v45 = *(_DWORD *)MIL::IRTensorValue::GetDataView<int>();
        unint64_t v46 = (uint64_t **)(*(void *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v46))
        {
          uint64_t v48 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
          int v49 = 566;
          uint64_t v50 = "Casting.h";
          uint64_t v51 = "cast";
LABEL_297:
          __assert_rtn(v51, v50, v49, v48);
        }
        if (v46)
        {
          uint64_t v47 = (uint64_t *)mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v46);
          if (!v47)
          {
            uint64_t v48 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            int v49 = 98;
            uint64_t v50 = "InterfaceSupport.h";
            uint64_t v51 = "Interface";
            goto LABEL_297;
          }
        }
        else
        {
          uint64_t v47 = 0;
        }
        v289[0] = (uint64_t *)v46;
        v289[1] = v47;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v289);
        uint64_t v56 = v55;
        char v265 = v34;
        uint64_t v266 = LocationForOp;
        int v57 = v55 & (v45 >> 31);
        uint64_t v58 = (v57 + v45);
        if (v55)
        {
          int v59 = 0;
          int v60 = 0;
          unint64_t v61 = 0;
          uint64_t v62 = 0;
          uint64_t v267 = (v57 + v45);
          while (1)
          {
            if (v62 == v58) {
              goto LABEL_103;
            }
            if (v61 >= v60) {
              break;
            }
            *(_DWORD *)unint64_t v61 = v62;
            unint64_t v63 = v61 + 4;
LABEL_102:
            __p[1] = v63;
            unint64_t v61 = (char *)v63;
LABEL_103:
            if (++v62 == v56) {
              goto LABEL_132;
            }
          }
          uint64_t v64 = v4;
          uint64_t v65 = v24;
          int64_t v66 = v61 - v59;
          uint64_t v67 = (v61 - v59) >> 2;
          unint64_t v68 = v67 + 1;
          if ((unint64_t)(v67 + 1) >> 62) {
            std::vector<int>::__throw_length_error[abi:ne180100]();
          }
          if ((v60 - v59) >> 1 > v68) {
            unint64_t v68 = (v60 - v59) >> 1;
          }
          if ((unint64_t)(v60 - v59) >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v69 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v69 = v68;
          }
          if (v69)
          {
            if (v69 >> 62) {
              std::__throw_bad_array_new_length[abi:ne180100]();
            }
            uint64_t v70 = operator new(4 * v69);
            int64_t v71 = &v70[4 * v67];
            _DWORD *v71 = v62;
            unint64_t v63 = v71 + 1;
            int64_t v72 = v61 - v59;
            if (v61 != v59)
            {
LABEL_115:
              unint64_t v73 = v72 - 4;
              if (v73 < 0xBC
                || (unint64_t v77 = (v61 - 4 - v59) & 0xFFFFFFFFFFFFFFFCLL, &v70[v66 - 4 - v77] > &v70[v66 - 4])
                || &v61[-v77 - 4] > v61 - 4
                || (unint64_t)(v59 - v70) < 0x20)
              {
                int v74 = v61;
                BOOL v24 = v65;
              }
              else
              {
                uint64_t v78 = (v73 >> 2) + 1;
                uint64_t v79 = 4 * (v78 & 0x7FFFFFFFFFFFFFF8);
                int v74 = &v61[-v79];
                int64_t v71 = (_DWORD *)((char *)v71 - v79);
                uint64_t v80 = &v70[v66 - 16];
                long long v81 = v61 - 16;
                uint64_t v82 = v78 & 0x7FFFFFFFFFFFFFF8;
                do
                {
                  long long v83 = *(_OWORD *)v81;
                  *(v80 - 1) = *((_OWORD *)v81 - 1);
                  *uint64_t v80 = v83;
                  v80 -= 2;
                  v81 -= 32;
                  v82 -= 8;
                }
                while (v82);
                BOOL v24 = v65;
                if (v78 == (v78 & 0x7FFFFFFFFFFFFFF8))
                {
LABEL_118:
                  int v60 = &v70[4 * v69];
                  __p[0] = v71;
                  __p[1] = v63;
                  __p[2] = v60;
                  uint64_t v4 = v64;
                  if (!v59)
                  {
LABEL_120:
                    int v59 = (char *)v71;
                    uint64_t v58 = v267;
                    goto LABEL_102;
                  }
LABEL_119:
                  operator delete(v59);
                  goto LABEL_120;
                }
              }
              do
              {
                int v75 = *((_DWORD *)v74 - 1);
                v74 -= 4;
                *--int64_t v71 = v75;
              }
              while (v74 != v59);
              goto LABEL_118;
            }
          }
          else
          {
            uint64_t v70 = 0;
            int64_t v71 = (_DWORD *)(4 * v67);
            uint64_t v76 = (_DWORD *)(4 * v67);
            *uint64_t v76 = v62;
            unint64_t v63 = v76 + 1;
            int64_t v72 = v61 - v59;
            if (v61 != v59) {
              goto LABEL_115;
            }
          }
          BOOL v24 = v65;
          int v60 = &v70[4 * v69];
          __p[0] = v71;
          __p[1] = v63;
          __p[2] = v60;
          uint64_t v4 = v64;
          if (!v59) {
            goto LABEL_120;
          }
          goto LABEL_119;
        }
        unint64_t v61 = 0;
LABEL_132:
        uint64_t v84 = mlir::Builder::getIntegerType(v24, 0x20u, 1);
        uint64_t LocationForOp = v266;
        uint64_t v35 = ElementTypeOrSelf;
        uint64_t v275 = mlir::IntegerAttr::get(v84, (int)v58);
        __int16 v85 = __p[0];
        int64_t v86 = v61 - (char *)__p[0];
        v289[0] = (uint64_t *)((v61 - (char *)__p[0]) >> 2);
        uint64_t v87 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)v289, 1, v84, 0);
        char v34 = v265;
        if (mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v87))
        {
          if (v87)
          {
            uint64_t v88 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v87);
            if (!v88)
            {
              std::vector<int>::pointer v89 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
              int v90 = 98;
              int v91 = "InterfaceSupport.h";
              uint64_t v92 = "Interface";
              goto LABEL_289;
            }
          }
          else
          {
            uint64_t v88 = 0;
          }
          uint64_t v93 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v87, v88, v85, v86, 4, 1, 1);
          if (mlir::DenseIntElementsAttr::classof((uint64_t)v93))
          {
            v289[0] = v93;
            std::vector<int>::pointer v94 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v24, v266, v289);
            if (!*((_DWORD *)v94 + 9)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
            uint64_t v276 = (uint64_t)v94 - 16;
            if (v85) {
              operator delete(v85);
            }
LABEL_141:
            LOBYTE(__p[0]) = 0;
            LOBYTE(v289[0]) = 0;
            std::vector<int>::pointer v95 = mlir::OpBuilder::create<mlir::mps::ReductionMinOp,mlir::Value &,mlir::Value &,BOOL,BOOL>((mlir::UnitAttr **)v24, LocationForOp, &ArgValue, &v276, (unsigned __int8 *)__p, (unsigned __int8 *)v289);
            if (!*((_DWORD *)v95 + 9)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
            uint64_t v274 = (uint64_t)v95 - 16;
            LOBYTE(__p[0]) = 0;
            LOBYTE(v289[0]) = 0;
            uint64_t v96 = mlir::OpBuilder::create<mlir::mps::ReductionMaxOp,mlir::Value &,mlir::Value &,BOOL,BOOL>((mlir::UnitAttr **)v24, LocationForOp, &ArgValue, &v276, (unsigned __int8 *)__p, (unsigned __int8 *)v289);
            if (!*((_DWORD *)v96 + 9)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
            uint64_t v273 = (uint64_t)v96 - 16;
            __p[0] = (void *)1;
            uint64_t v97 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, v35, 0);
            __p[0] = (void *)mlir::mps::getConstantAttr<double>(v97, 0.00392156863);
            uint64_t v98 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v24, LocationForOp, (uint64_t **)__p);
            __p[0] = (void *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&MLIRElemType);
            BOOL isSignedInteger = mlir::Type::isSignedInteger((mlir::Type *)__p);
            BOOL v100 = isSignedInteger;
            if (v34)
            {
              __p[0] = (void *)1;
              uint64_t v101 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, v35, 0);
              __p[0] = (void *)mlir::mps::getConstantAttr<double>(v101, 0.0);
              int v102 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v24, LocationForOp, (uint64_t **)__p);
              uint64_t v272 = v102;
              uint64_t v103 = mlir::OpBuilder::create<mlir::mps::MaximumOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::Float32Type **)v24, LocationForOp, &v273, (uint64_t)&v272);
              if (!*(_DWORD *)(v103 + 36)) {
                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
              }
              uint64_t v273 = v103 - 16;
              uint64_t v281 = LocationForOp;
              uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v281);
              uint64_t v105 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.minimum", (const unsigned __int8 *)0xB, Context);
              if (!v106)
              {
                __int16 v287 = 1283;
                uint64_t v285 = "mps.minimum";
                uint64_t v286 = 11;
                                   "tion hasn't been added by the dialect. See also https://mlir.llvm.org/getting_started"
                                   "/Faq/#registered-loaded-dependent-whats-up-with-dialects-management";
                __int16 v283 = 259;
                llvm::operator+(v284, v282, (uint64_t)v289);
                llvm::report_fatal_error((llvm::Twine *)v289, 1);
              }
              mlir::OperationState::OperationState(__p, LocationForOp, v105);
              if (!*((_DWORD *)v102 + 9)) {
                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
              }
              mlir::mps::ATan2Op::build((mlir::Float32Type **)v24, (uint64_t)__p, v274, (uint64_t)v102 - 16);
              unint64_t v107 = mlir::OpBuilder::create(v24, (const mlir::OperationState *)__p);
              if (v107)
              {
                uint64_t v108 = llvm::DefaultDoCastIfPossible<mlir::mps::MinimumOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MinimumOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v107);
                if (v108)
                {
                  mlir::OperationState::~OperationState((mlir::OperationState *)__p);
                  if (!*(_DWORD *)(v108 + 36)) {
                    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                  }
                  uint64_t v274 = v108 - 16;
                  if (v100) {
                    float v109 = 127.0;
                  }
                  else {
                    float v109 = 255.0;
                  }
                  if (v100) {
                    float v110 = -128.0;
                  }
                  else {
                    float v110 = 0.0;
                  }
                  uint64_t v111 = mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::Value &>((mlir::Float32Type **)v24, LocationForOp, &v273, &v274);
                  uint64_t v281 = LocationForOp;
                  int v112 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v281);
                  uint64_t v113 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, v112);
                  if (!v114)
                  {
                    __int16 v287 = 1283;
                    uint64_t v285 = "mps.multiply";
                    uint64_t v286 = 12;
                                       "peration hasn't been added by the dialect. See also https://mlir.llvm.org/getting"
                                       "_started/Faq/#registered-loaded-dependent-whats-up-with-dialects-management";
                    __int16 v283 = 259;
                    llvm::operator+(v284, v282, (uint64_t)v289);
                    llvm::report_fatal_error((llvm::Twine *)v289, 1);
                  }
                  mlir::OperationState::OperationState(__p, LocationForOp, v113);
                  if (!*((_DWORD *)v98 + 9) || !*((_DWORD *)v111 + 9)) {
                    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                  }
                  mlir::mps::ATan2Op::build((mlir::Float32Type **)v24, (uint64_t)__p, (uint64_t)v98 - 16, (uint64_t)v111 - 16);
                  uint64_t v115 = mlir::OpBuilder::create(v24, (const mlir::OperationState *)__p);
                  if (v115)
                  {
                    uint64_t v116 = llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v115);
                    if (v116)
                    {
                      mlir::OperationState::~OperationState((mlir::OperationState *)__p);
                      __p[0] = (void *)1;
                      int v117 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, v35, 0);
                      __p[0] = (void *)mlir::mps::getConstantAttr<float>(v117, v110);
                      unint64_t v118 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v24, LocationForOp, (uint64_t **)__p);
                      __p[0] = (void *)1;
                      uint64_t v119 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, v35, 0);
                      __p[0] = (void *)mlir::mps::getConstantAttr<float>(v119, v109);
                      int v120 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v24, LocationForOp, (uint64_t **)__p);
                      uint64_t v281 = LocationForOp;
                      char v121 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v281);
                      uint64_t v122 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.divide", (const unsigned __int8 *)0xA, v121);
                      if (!v123)
                      {
                        __int16 v287 = 1283;
                        uint64_t v285 = "mps.divide";
                        uint64_t v286 = 10;
                                           "is operation hasn't been added by the dialect. See also https://mlir.llvm.org"
                                           "/getting_started/Faq/#registered-loaded-dependent-whats-up-with-dialects-management";
                        __int16 v283 = 259;
                        llvm::operator+(v284, v282, (uint64_t)v289);
                        llvm::report_fatal_error((llvm::Twine *)v289, 1);
                      }
                      mlir::OperationState::OperationState(__p, LocationForOp, v122);
                      if (!*(_DWORD *)(v116 + 36)) {
                        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                      }
                      uint64_t v269 = v116 - 16;
                      mlir::mps::ATan2Op::build((mlir::Float32Type **)v24, (uint64_t)__p, v274, v116 - 16);
                      __int16 v124 = mlir::OpBuilder::create(v24, (const mlir::OperationState *)__p);
                      if (v124)
                      {
                        uint64_t v125 = llvm::DefaultDoCastIfPossible<mlir::mps::DivideOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DivideOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v124);
                        if (v125)
                        {
                          mlir::OperationState::~OperationState((mlir::OperationState *)__p);
                          if (!*(_DWORD *)(v125 + 36)) {
                            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                          }
                          int v271 = (mlir::GenericProgramPoint *)(v125 - 16);
                          if (v100)
                          {
                            __p[0] = (void *)1;
                            unint64_t v126 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, v35, 0);
                            __p[0] = (void *)mlir::mps::getConstantAttr<double>(v126, 128.0);
                            unint64_t v127 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v24, LocationForOp, (uint64_t **)__p);
                            uint64_t v281 = LocationForOp;
                            uint64_t v128 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v281);
                            uint64_t v129 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, v128);
                            if (!v130)
                            {
                              __int16 v287 = 1283;
                              uint64_t v285 = "mps.add";
                              uint64_t v286 = 7;
                                                 " or this operation hasn't been added by the dialect. See also https://m"
                                                 "lir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-"
                                                 "with-dialects-management";
                              __int16 v283 = 259;
                              llvm::operator+(v284, v282, (uint64_t)v289);
                              llvm::report_fatal_error((llvm::Twine *)v289, 1);
                            }
                            mlir::OperationState::OperationState(__p, LocationForOp, v129);
                            if (!*((_DWORD *)v127 + 9)) {
                              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                            }
                            mlir::mps::ATan2Op::build((mlir::Float32Type **)v24, (uint64_t)__p, (uint64_t)v271, (uint64_t)v127 - 16);
                            uint64_t v131 = mlir::OpBuilder::create(v24, (const mlir::OperationState *)__p);
                            if (v131)
                            {
                              uint64_t v132 = llvm::DefaultDoCastIfPossible<mlir::mps::AddOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AddOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v131);
                              if (v132)
                              {
                                mlir::OperationState::~OperationState((mlir::OperationState *)__p);
                                if (!*(_DWORD *)(v132 + 36)) {
                                  __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                                }
                                int v271 = (mlir::GenericProgramPoint *)(v132 - 16);
                                goto LABEL_173;
                              }
                              uint64_t v261 = "result && \"builder didn't return the right type\"";
                              int v262 = 497;
                              uint64_t v263 = "Builders.h";
                              v264 = "create";
                            }
                            else
                            {
                              uint64_t v261 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
                              int v262 = 662;
                              uint64_t v263 = "Casting.h";
                              v264 = "dyn_cast";
                            }
                            __assert_rtn(v264, v263, v262, v261);
                          }
LABEL_173:
                          uint64_t v133 = mlir::OpBuilder::create<mlir::mps::RoundOp,mlir::Value &>(v24, LocationForOp, (uint64_t *)&v271);
                          if (!*(_DWORD *)(v133 + 36)) {
                            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                          }
                          int v271 = (mlir::GenericProgramPoint *)(v133 - 16);
                          uint64_t v134 = mlir::OpBuilder::create<mlir::mps::NegativeOp,mlir::Value &>(v24, LocationForOp, (uint64_t *)&v271);
                          if (!*(_DWORD *)(v134 + 36)) {
                            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                          }
                          int v271 = (mlir::GenericProgramPoint *)(v134 - 16);
                          uint64_t v281 = LocationForOp;
                          uint64_t v135 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v281);
                          uint64_t v136 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.clamp", (const unsigned __int8 *)9, v135);
                          if (!v137)
                          {
                            __int16 v287 = 1283;
                            uint64_t v285 = "mps.clamp";
                            uint64_t v286 = 9;
                                               "r this operation hasn't been added by the dialect. See also https://mlir."
                                               "llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-d"
                                               "ialects-management";
                            __int16 v283 = 259;
                            llvm::operator+(v284, v282, (uint64_t)v289);
                            llvm::report_fatal_error((llvm::Twine *)v289, 1);
                          }
                          mlir::OperationState::OperationState(__p, LocationForOp, v136);
                          if (!*((_DWORD *)v118 + 9) || !*((_DWORD *)v120 + 9)) {
                            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                          }
                          mlir::mps::ClampOp::build((uint64_t)v24, (uint64_t)__p, (uint64_t)v271, (uint64_t)v118 - 16, (uint64_t)v120 - 16);
                          __int16 v138 = mlir::OpBuilder::create(v24, (const mlir::OperationState *)__p);
                          if (v138)
                          {
                            uint64_t v139 = llvm::DefaultDoCastIfPossible<mlir::mps::ClampOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ClampOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v138);
                            if (v139)
                            {
                              mlir::OperationState::~OperationState((mlir::OperationState *)__p);
                              if (!*(_DWORD *)(v139 + 36)) {
                                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                              }
                              int v271 = (mlir::GenericProgramPoint *)(v139 - 16);
                              unint64_t v140 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)v24, LocationForOp, (uint64_t *)&v271, &Value);
                              if (!*((_DWORD *)v140 + 9)) {
                                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                              }
                              int v271 = (mlir::GenericProgramPoint *)((char *)v140 - 16);
                              uint64_t v281 = LocationForOp;
                              uint64_t v141 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v281);
                              uint64_t v142 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.quantize", (const unsigned __int8 *)0xC, v141);
                              if (!v143)
                              {
                                __int16 v287 = 1283;
                                uint64_t v285 = "mps.quantize";
                                uint64_t v286 = 12;
                                                   "ed or this operation hasn't been added by the dialect. See also https"
                                                   "://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-wha"
                                                   "ts-up-with-dialects-management";
                                __int16 v283 = 259;
                                llvm::operator+(v284, v282, (uint64_t)v289);
                                llvm::report_fatal_error((llvm::Twine *)v289, 1);
                              }
                              mlir::OperationState::OperationState(__p, LocationForOp, v142);
                              if (!*(_DWORD *)(v116 + 36)) {
                                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                              }
                              mlir::mps::QuantizeOp::build((mlir::UnknownLoc **)v24, (uint64_t)__p, ArgValue, v269, (uint64_t)v271, MLIRElemType, v275);
                              std::vector<int>::size_type v144 = mlir::OpBuilder::create(v24, (const mlir::OperationState *)__p);
                              if (v144)
                              {
                                uint64_t v145 = llvm::DefaultDoCastIfPossible<mlir::mps::QuantizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::QuantizeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v144);
                                if (v145)
                                {
                                  mlir::OperationState::~OperationState((mlir::OperationState *)__p);
                                  if (!*(_DWORD *)(v145 + 36)) {
                                    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                                  }
                                  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)v4 + 200))(__p, v4);
                                  uint64_t v146 = (uint64_t *)__p[0];
                                  uint64_t v147 = (char *)operator new(8uLL);
                                  *(void *)uint64_t v147 = v145 - 16;
                                  uint64_t v148 = (uint64_t)v270 + 64;
                                  v289[0] = v146;
                                  uint64_t v149 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v270 + 64, (uint64_t)v146, (uint64_t)&std::piecewise_construct, (long long **)v289);
                                  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v149 + 5, v147, v147 + 8, 1uLL);
                                  operator delete(v147);
                                  unint64_t v150 = (void **)__p[0];
                                  if (__p[0])
                                  {
                                    std::vector<int>::pointer v151 = (void **)__p[1];
                                    std::vector<int>::size_type v152 = __p[0];
                                    if (__p[1] != __p[0])
                                    {
                                      do
                                      {
                                        if (*((char *)v151 - 1) < 0) {
                                          operator delete(*(v151 - 3));
                                        }
                                        v151 -= 3;
                                      }
                                      while (v151 != v150);
                                      std::vector<int>::size_type v152 = __p[0];
                                    }
                                    __p[1] = v150;
                                    operator delete(v152);
                                  }
                                  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)v4 + 200))(__p, v4);
                                  if (!*(_DWORD *)(v116 + 36)) {
                                    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                                  }
                                  unint64_t v213 = (char *)__p[0];
                                  uint64_t v214 = (char *)operator new(8uLL);
                                  *(void *)uint64_t v214 = v269;
                                  v289[0] = (uint64_t *)(v213 + 24);
                                  v215 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v148, (uint64_t)(v213 + 24), (uint64_t)&std::piecewise_construct, (long long **)v289);
                                  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v215 + 5, v214, v214 + 8, 1uLL);
                                  operator delete(v214);
                                  unint64_t v216 = (void **)__p[0];
                                  if (__p[0])
                                  {
                                    int v217 = (void **)__p[1];
                                    uint64_t v218 = __p[0];
                                    if (__p[1] != __p[0])
                                    {
                                      do
                                      {
                                        if (*((char *)v217 - 1) < 0) {
                                          operator delete(*(v217 - 3));
                                        }
                                        v217 -= 3;
                                      }
                                      while (v217 != v216);
                                      uint64_t v218 = __p[0];
                                    }
                                    __p[1] = v216;
                                    operator delete(v218);
                                  }
                                  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)v4 + 200))(__p, v4);
                                  uint64_t v219 = (char *)__p[0];
                                  uint64_t v220 = (uint64_t)v271;
                                  uint64_t v221 = (char *)operator new(8uLL);
                                  *(void *)uint64_t v221 = v220;
                                  v289[0] = (uint64_t *)(v219 + 48);
                                  int v222 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v148, (uint64_t)(v219 + 48), (uint64_t)&std::piecewise_construct, (long long **)v289);
                                  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v222 + 5, v221, v221 + 8, 1uLL);
                                  operator delete(v221);
                                  int v205 = (void **)__p[0];
                                  if (!__p[0]) {
                                    goto LABEL_280;
                                  }
                                  uint64_t v223 = (void **)__p[1];
                                  v207 = __p[0];
                                  if (__p[1] == __p[0]) {
                                    goto LABEL_279;
                                  }
                                  do
                                  {
                                    if (*((char *)v223 - 1) < 0) {
                                      operator delete(*(v223 - 3));
                                    }
                                    v223 -= 3;
                                  }
                                  while (v223 != v205);
                                  goto LABEL_278;
                                }
                                int v241 = "result && \"builder didn't return the right type\"";
                                int v242 = 497;
                                int v243 = "Builders.h";
                                v244 = "create";
                              }
                              else
                              {
                                int v241 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
                                int v242 = 662;
                                int v243 = "Casting.h";
                                v244 = "dyn_cast";
                              }
                              __assert_rtn(v244, v243, v242, v241);
                            }
                            uint64_t v237 = "result && \"builder didn't return the right type\"";
                            int v238 = 497;
                            uint64_t v239 = "Builders.h";
                            v240 = "create";
                          }
                          else
                          {
                            uint64_t v237 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
                            int v238 = 662;
                            uint64_t v239 = "Casting.h";
                            v240 = "dyn_cast";
                          }
                          __assert_rtn(v240, v239, v238, v237);
                        }
                        __int16 v233 = "result && \"builder didn't return the right type\"";
                        int v234 = 497;
                        std::vector<int> v235 = "Builders.h";
                        uint64_t v236 = "create";
                      }
                      else
                      {
                        __int16 v233 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
                        int v234 = 662;
                        std::vector<int> v235 = "Casting.h";
                        uint64_t v236 = "dyn_cast";
                      }
                      __assert_rtn(v236, v235, v234, v233);
                    }
                    __int16 v229 = "result && \"builder didn't return the right type\"";
                    int v230 = 497;
                    int v231 = "Builders.h";
                    uint64_t v232 = "create";
                  }
                  else
                  {
                    __int16 v229 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
                    int v230 = 662;
                    int v231 = "Casting.h";
                    uint64_t v232 = "dyn_cast";
                  }
                  __assert_rtn(v232, v231, v230, v229);
                }
                std::string v225 = "result && \"builder didn't return the right type\"";
                int v226 = 497;
                v227 = "Builders.h";
                uint64_t v228 = "create";
              }
              else
              {
                std::string v225 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
                int v226 = 662;
                v227 = "Casting.h";
                uint64_t v228 = "dyn_cast";
              }
              __assert_rtn(v228, v227, v226, v225);
            }
            uint64_t v272 = 0;
            if (isSignedInteger)
            {
              uint64_t v153 = mlir::OpBuilder::create<mlir::mps::AbsoluteOp,mlir::Value &>(v24, LocationForOp, &v274);
              uint64_t v154 = mlir::OpBuilder::create<mlir::mps::AbsoluteOp,mlir::Value &>(v24, LocationForOp, &v273);
              uint64_t v281 = LocationForOp;
              unint64_t v155 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v281);
              uint64_t v156 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.greater", (const unsigned __int8 *)0xB, v155);
              if (!v157)
              {
                __int16 v287 = 1283;
                uint64_t v285 = "mps.greater";
                uint64_t v286 = 11;
                                   "tion hasn't been added by the dialect. See also https://mlir.llvm.org/getting_started"
                                   "/Faq/#registered-loaded-dependent-whats-up-with-dialects-management";
                __int16 v283 = 259;
                llvm::operator+(v284, v282, (uint64_t)v289);
                llvm::report_fatal_error((llvm::Twine *)v289, 1);
              }
              mlir::OperationState::OperationState(__p, LocationForOp, v156);
              if (!*(_DWORD *)(v154 + 36) || !*(_DWORD *)(v153 + 36)) {
                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
              }
              mlir::mps::EqualToOp::build((uint64_t)v24, (uint64_t)__p, v154 - 16, v153 - 16);
              long long v158 = mlir::OpBuilder::create(v24, (const mlir::OperationState *)__p);
              if (v158)
              {
                uint64_t v159 = llvm::DefaultDoCastIfPossible<mlir::mps::GreaterThanOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GreaterThanOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v158);
                if (v159)
                {
                  mlir::OperationState::~OperationState((mlir::OperationState *)__p);
                  uint64_t v281 = LocationForOp;
                  int v160 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v281);
                  uint64_t v161 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.select", (const unsigned __int8 *)0xA, v160);
                  if (!v162)
                  {
                    __int16 v287 = 1283;
                    uint64_t v285 = "mps.select";
                    uint64_t v286 = 10;
                                       "peration hasn't been added by the dialect. See also https://mlir.llvm.org/getting"
                                       "_started/Faq/#registered-loaded-dependent-whats-up-with-dialects-management";
                    __int16 v283 = 259;
                    llvm::operator+(v284, v282, (uint64_t)v289);
                    llvm::report_fatal_error((llvm::Twine *)v289, 1);
                  }
                  mlir::OperationState::OperationState(__p, LocationForOp, v161);
                  if (!*(_DWORD *)(v159 + 36) || !*(_DWORD *)(v154 + 36) || !*(_DWORD *)(v153 + 36)) {
                    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                  }
                  mlir::mps::SelectOp::build((uint64_t)v24, (uint64_t)__p, v159 - 16, v154 - 16, v153 - 16);
                  int v163 = mlir::OpBuilder::create(v24, (const mlir::OperationState *)__p);
                  int v164 = v270;
                  if (v163)
                  {
                    uint64_t v165 = llvm::DefaultDoCastIfPossible<mlir::mps::SelectOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SelectOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v163);
                    if (v165)
                    {
                      mlir::OperationState::~OperationState((mlir::OperationState *)__p);
                      __p[0] = (void *)1;
                      int v166 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, v35, 0);
                      __p[0] = (void *)mlir::mps::getConstantAttr<double>(v166, 0.00787401575);
                      uint64_t v167 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v24, LocationForOp, (uint64_t **)__p);
                      uint64_t v281 = LocationForOp;
                      uint64_t v168 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v281);
                      uint64_t v169 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, v168);
                      if (!v170)
                      {
                        __int16 v287 = 1283;
                        uint64_t v285 = "mps.multiply";
                        uint64_t v286 = 12;
                                           "is operation hasn't been added by the dialect. See also https://mlir.llvm.org"
                                           "/getting_started/Faq/#registered-loaded-dependent-whats-up-with-dialects-management";
                        __int16 v283 = 259;
                        llvm::operator+(v284, v282, (uint64_t)v289);
                        llvm::report_fatal_error((llvm::Twine *)v289, 1);
                      }
                      mlir::OperationState::OperationState(__p, LocationForOp, v169);
                      if (!*((_DWORD *)v167 + 9) || !*(_DWORD *)(v165 + 36)) {
                        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                      }
                      mlir::mps::ATan2Op::build((mlir::Float32Type **)v24, (uint64_t)__p, (uint64_t)v167 - 16, v165 - 16);
                      v171 = mlir::OpBuilder::create(v24, (const mlir::OperationState *)__p);
                      if (v171)
                      {
                        uint64_t v172 = llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v171);
                        if (v172)
                        {
                          mlir::OperationState::~OperationState((mlir::OperationState *)__p);
                          if (!*(_DWORD *)(v172 + 36)) {
                            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                          }
LABEL_219:
                          uint64_t v272 = (mlir::GenericProgramPoint *)(v172 - 16);
                          __p[0] = (void *)1;
                          unint64_t v180 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, Value, 0);
                          __p[0] = (void *)mlir::mps::getConstantAttr<int>(v180, 0);
                          std::vector<int>::pointer v181 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v24, LocationForOp, (uint64_t **)__p);
                          if (!*((_DWORD *)v181 + 9)) {
                            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                          }
                          v284[0] = (uint64_t)v181 - 16;
                          uint64_t v182 = mlir::OpBuilder::create<mlir::mps::QuantizeOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::TypeAttr &,mlir::IntegerAttr &>((mlir::UnknownLoc **)v24, LocationForOp, &ArgValue, (uint64_t *)&v272, v284, &MLIRElemType, &v275);
                          if (!*(_DWORD *)(v182 + 36)) {
                            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                          }
                          (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)v4 + 200))(__p, v4);
                          v183 = (uint64_t *)__p[0];
                          unint64_t v184 = (char *)operator new(8uLL);
                          *(void *)unint64_t v184 = v182 - 16;
                          uint64_t v185 = (uint64_t)v164 + 64;
                          v289[0] = v183;
                          int v186 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v185, (uint64_t)v183, (uint64_t)&std::piecewise_construct, (long long **)v289);
                          std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v186 + 5, v184, v184 + 8, 1uLL);
                          operator delete(v184);
                          v187 = (void **)__p[0];
                          if (__p[0])
                          {
                            uint64_t v188 = (void **)__p[1];
                            uint64_t v189 = __p[0];
                            if (__p[1] != __p[0])
                            {
                              do
                              {
                                if (*((char *)v188 - 1) < 0) {
                                  operator delete(*(v188 - 3));
                                }
                                v188 -= 3;
                              }
                              while (v188 != v187);
                              uint64_t v189 = __p[0];
                            }
                            __p[1] = v187;
                            operator delete(v189);
                          }
                          (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)v4 + 200))(__p, v4);
                          int v208 = (char *)__p[0];
                          uint64_t v209 = (uint64_t)v272;
                          uint64_t v210 = (char *)operator new(8uLL);
                          *(void *)uint64_t v210 = v209;
                          v289[0] = (uint64_t *)(v208 + 24);
                          int v211 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v185, (uint64_t)(v208 + 24), (uint64_t)&std::piecewise_construct, (long long **)v289);
                          std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v211 + 5, v210, v210 + 8, 1uLL);
                          operator delete(v210);
                          int v205 = (void **)__p[0];
                          if (!__p[0]) {
                            goto LABEL_280;
                          }
                          uint64_t v212 = (void **)__p[1];
                          v207 = __p[0];
                          if (__p[1] == __p[0]) {
                            goto LABEL_279;
                          }
                          do
                          {
                            if (*((char *)v212 - 1) < 0) {
                              operator delete(*(v212 - 3));
                            }
                            v212 -= 3;
                          }
                          while (v212 != v205);
                          goto LABEL_278;
                        }
                        int v257 = "result && \"builder didn't return the right type\"";
                        int v258 = 497;
                        int v259 = "Builders.h";
                        v260 = "create";
                      }
                      else
                      {
                        int v257 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
                        int v258 = 662;
                        int v259 = "Casting.h";
                        v260 = "dyn_cast";
                      }
                      __assert_rtn(v260, v259, v258, v257);
                    }
                    uint64_t v253 = "result && \"builder didn't return the right type\"";
                    int v254 = 497;
                    unint64_t v255 = "Builders.h";
                    uint64_t v256 = "create";
                  }
                  else
                  {
                    uint64_t v253 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
                    int v254 = 662;
                    unint64_t v255 = "Casting.h";
                    uint64_t v256 = "dyn_cast";
                  }
                  __assert_rtn(v256, v255, v254, v253);
                }
                uint64_t v245 = "result && \"builder didn't return the right type\"";
                int v246 = 497;
                unint64_t v247 = "Builders.h";
                uint64_t v248 = "create";
              }
              else
              {
                uint64_t v245 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
                int v246 = 662;
                unint64_t v247 = "Casting.h";
                uint64_t v248 = "dyn_cast";
              }
              __assert_rtn(v248, v247, v246, v245);
            }
            __p[0] = (void *)1;
            BOOL v173 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, v35, 0);
            __p[0] = (void *)mlir::mps::getConstantAttr<double>(v173, 0.0);
            int v174 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v24, LocationForOp, (uint64_t **)__p);
            int v271 = v174;
            int v164 = v270;
            if (!*((_DWORD *)v174 + 9)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
            uint64_t v274 = (uint64_t)v174 - 16;
            uint64_t v175 = mlir::OpBuilder::create<mlir::mps::MaximumOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::Float32Type **)v24, LocationForOp, &v273, (uint64_t)&v271);
            if (!*(_DWORD *)(v175 + 36)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
            uint64_t v273 = v175 - 16;
            uint64_t v281 = LocationForOp;
            int v176 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v281);
            uint64_t v177 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, v176);
            if (!v178)
            {
              __int16 v287 = 1283;
              uint64_t v285 = "mps.multiply";
              uint64_t v286 = 12;
                                 "on hasn't been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq"
                                 "/#registered-loaded-dependent-whats-up-with-dialects-management";
              __int16 v283 = 259;
              llvm::operator+(v284, v282, (uint64_t)v289);
              llvm::report_fatal_error((llvm::Twine *)v289, 1);
            }
            mlir::OperationState::OperationState(__p, LocationForOp, v177);
            if (!*((_DWORD *)v98 + 9)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
            mlir::mps::ATan2Op::build((mlir::Float32Type **)v24, (uint64_t)__p, (uint64_t)v98 - 16, v273);
            uint64_t v179 = mlir::OpBuilder::create(v24, (const mlir::OperationState *)__p);
            if (v179)
            {
              uint64_t v172 = llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v179);
              if (v172)
              {
                mlir::OperationState::~OperationState((mlir::OperationState *)__p);
                if (!*(_DWORD *)(v172 + 36)) {
                  __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                }
                goto LABEL_219;
              }
              unint64_t v249 = "result && \"builder didn't return the right type\"";
              int v250 = 497;
              uint64_t v251 = "Builders.h";
              uint64_t v252 = "create";
            }
            else
            {
              unint64_t v249 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
              int v250 = 662;
              uint64_t v251 = "Casting.h";
              uint64_t v252 = "dyn_cast";
            }
            __assert_rtn(v252, v251, v250, v249);
          }
        }
        std::vector<int>::pointer v89 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        int v90 = 566;
        int v91 = "Casting.h";
        uint64_t v92 = "cast";
LABEL_289:
        __assert_rtn(v92, v91, v90, v89);
      }
      __p[0] = operator new(0x20uLL);
      *(_OWORD *)&__p[1] = xmmword_181129EA0;
      strcpy((char *)__p[0], "Unknown quantization variant.");
      uint64_t v38 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t *)__p);
      if (SHIBYTE(__p[2]) < 0) {
        operator delete(__p[0]);
      }
LABEL_281:
      if (SHIBYTE(v280.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v280.__r_.__value_.__l.__data_);
      }
      return v38;
  }
}

void sub_180D4D4D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *__p,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if (a45 < 0) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::QuantizeOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::TypeAttr &,mlir::IntegerAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  v30[38] = *MEMORY[0x1E4F143B8];
  uint64_t v24 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  uint64_t v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.quantize", (const unsigned __int8 *)0xC, Context);
  if (!v16)
  {
    __int16 v28 = 1283;
    v27[2] = (uint64_t)"mps.quantize";
    v27[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v15);
  mlir::mps::QuantizeOp::build(a1, (uint64_t)v30, *a3, *a4, *a5, *a6, *a7);
  BOOL v17 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v30);
  if (!v17)
  {
    size_t v20 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v21 = 662;
    size_t v22 = "Casting.h";
    int v23 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v18 = llvm::DefaultDoCastIfPossible<mlir::mps::QuantizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::QuantizeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v17);
  if (!v18)
  {
    size_t v20 = "result && \"builder didn't return the right type\"";
    int v21 = 497;
    size_t v22 = "Builders.h";
    int v23 = "create";
LABEL_8:
    __assert_rtn(v23, v22, v21, v20);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v18;
}

void sub_180D4D8B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D4D8CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::DequantizeOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::TypeAttr &,mlir::IntegerAttr &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  v30[38] = *MEMORY[0x1E4F143B8];
  uint64_t v24 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  uint64_t v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dequantize", (const unsigned __int8 *)0xE, Context);
  if (!v16)
  {
    __int16 v28 = 1283;
    v27[2] = (uint64_t)"mps.dequantize";
    v27[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v15);
  mlir::mps::DequantizeOp::build(a1, v30, *a3, *a4, *a5, *a6, *a7);
  BOOL v17 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v30);
  if (!v17)
  {
    size_t v20 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v21 = 662;
    size_t v22 = "Casting.h";
    int v23 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v18 = llvm::DefaultDoCastIfPossible<mlir::mps::DequantizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DequantizeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v17);
  if (!v18)
  {
    size_t v20 = "result && \"builder didn't return the right type\"";
    int v21 = 497;
    size_t v22 = "Builders.h";
    int v23 = "create";
LABEL_8:
    __assert_rtn(v23, v22, v21, v20);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v18;
}

void sub_180D4DA84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D4DA9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::AbsoluteOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.absolute", (const unsigned __int8 *)0xC, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.absolute";
    v19[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  unint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    BOOL v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    long long v14 = "Casting.h";
    uint64_t v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::AbsoluteOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AbsoluteOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    BOOL v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    long long v14 = "Builders.h";
    uint64_t v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180D4DC24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D4DC3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::MaximumOp,mlir::Value &,mlir::mps::ConstantOp &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v24[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.maximum", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.maximum";
    v21[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(void *)a4 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *a3, *(void *)a4 - 16);
  BOOL v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    long long v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v15 = 662;
    uint64_t v16 = "Casting.h";
    BOOL v17 = "dyn_cast";
    goto LABEL_10;
  }
  uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::MaximumOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MaximumOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    long long v14 = "result && \"builder didn't return the right type\"";
    int v15 = 497;
    uint64_t v16 = "Builders.h";
    BOOL v17 = "create";
LABEL_10:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180D4DDFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D4DE14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::RoundOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.round", (const unsigned __int8 *)9, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.round";
    v19[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    long long v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::RoundOp,mlir::Operation *,llvm::CastInfo<mlir::mps::RoundOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    long long v14 = "Builders.h";
    int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180D4DF9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D4DFB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t MILToMLIR::TensorBufferPattern::matchAndRewrite(MILToMLIR::TensorBufferPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v4 = a2;
  uint64_t v236 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 56))(a2);
  if (*(char *)(v6 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v233, *(const std::string::value_type **)v6, *(void *)(v6 + 8));
  }
  else
  {
    long long v7 = *(_OWORD *)v6;
    v233.__r_.__value_.__r.__words[2] = *(void *)(v6 + 16);
    *(_OWORD *)&v233.__r_.__value_.__l.__data_ = v7;
  }
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, v4);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, v4, "input");
  uint64_t v9 = (void *)((char *)this + 8);
  int v10 = *((char *)this + 31);
  if (v10 < 0)
  {
    if (*((void *)this + 2) != 23) {
      goto LABEL_23;
    }
    uint64_t v9 = (void *)*v9;
  }
  else if (v10 != 23)
  {
    goto LABEL_23;
  }
  if (*v9 == 0x625F726F736E6574
    && v9[1] == 0x6F745F7265666675
    && *(void *)((char *)v9 + 15) == 0x726F736E65745F6FLL)
  {
    strcpy((char *)&v229, "input");
    ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
    int v18 = 1;
    goto LABEL_26;
  }
  int v13 = (void *)*v9;
  uint64_t v14 = v9[1];
  uint64_t v15 = *(void *)((char *)v9 + 15);
  if (v13 == (void *)0x745F726F736E6574 && v14 == 0x726F736E65745F6FLL && v15 == 0x7265666675625F72)
  {
    ParameterType = (MIL::IRValueType *)MIL::IROperation::GetOutputType(v4);
    int v18 = 0;
    goto LABEL_26;
  }
LABEL_23:
  int v18 = 0;
  ParameterType = 0;
LABEL_26:
  int v230 = 0;
  int v231 = 0;
  int v226 = 0;
  v227 = 0;
  unint64_t v228 = 0;
  __int16 v229 = 0;
  uint64_t v223 = 0;
  int v224 = 0;
  std::string v225 = 0;
  __int16 v20 = (MIL::IRMemoryLayoutValueType *)MIL::IRValueType::TryCastAsMemoryLayoutType(ParameterType);
  if (v20)
  {
    int v21 = (MIL::IRTensorBufferValueType *)MIL::IRMemoryLayoutValueType::TryAsTensorBufferType(v20);
    __int16 v22 = v21;
    if (v21)
    {
      uint64_t InterleaveFactors = MIL::IRTensorBufferValueType::GetInterleaveFactors(v21);
      uint64_t v221 = 0;
      long long v222 = 0uLL;
      int v25 = *(const void **)InterleaveFactors;
      uint64_t v24 = *(void *)(InterleaveFactors + 8);
      int64_t v26 = v24 - *(void *)InterleaveFactors;
      if (v24 == *(void *)InterleaveFactors)
      {
        uint64_t v27 = 0;
        uint64_t v209 = 0;
      }
      else
      {
        if (v26 < 0) {
          std::vector<int>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v27 = (uint64_t)operator new(v24 - *(void *)InterleaveFactors);
        uint64_t v221 = (void *)v27;
        *((void *)&v222 + 1) = v27 + 8 * (v26 >> 3);
        memcpy((void *)v27, v25, v26);
        uint64_t v209 = *((void *)&v222 + 1);
        *(void *)&long long v222 = *((void *)&v222 + 1);
      }
      uint64_t Shape = MIL::IRTensorBufferValueType::GetShape(v22);
      __p = 0;
      uint64_t v219 = 0;
      uint64_t v220 = 0;
      int v31 = *(const void **)Shape;
      uint64_t v30 = *(void *)(Shape + 8);
      int64_t v32 = v30 - *(void *)Shape;
      uint64_t v207 = LocationForOp;
      if (v30 == *(void *)Shape)
      {
        uint64_t v33 = 0;
        char v34 = 0;
      }
      else
      {
        if (v32 < 0) {
          std::vector<int>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v33 = (char *)operator new(v32);
        char v34 = &v33[8 * (v32 >> 3)];
        __p = v33;
        uint64_t v220 = v34;
        memcpy(v33, v31, v32);
        uint64_t v219 = v34;
      }
      Strides = (void *)MIL::IRTensorBufferValueType::TryGetStrides(v22);
      uint64_t v36 = (v34 - v33) >> 3;
      if (v36 != (v209 - v27) >> 3)
      {
        v235.__begin_ = (std::vector<int>::pointer)operator new(0x40uLL);
        *(_OWORD *)&v235.__end_ = xmmword_181129EB0;
        strcpy((char *)v235.__begin_, "Invalid op - bufShapeVals.size() != interleaveVals.size()");
        uint64_t v43 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)v4, (const std::string::value_type *)&v235);
        goto LABEL_146;
      }
      if (Strides && v36 != (uint64_t)(Strides[1] - *Strides) >> 3)
      {
        v235.__begin_ = (std::vector<int>::pointer)operator new(0x38uLL);
        *(_OWORD *)&v235.__end_ = xmmword_181129EC0;
        strcpy((char *)v235.__begin_, "Invalid op - bufShapeVals.size() != strideVals.size()");
        uint64_t v43 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)v4, (const std::string::value_type *)&v235);
        goto LABEL_146;
      }
      if (v209 == v27)
      {
        uint64_t v121 = ArgValue;
        goto LABEL_132;
      }
      uint64_t v37 = 0;
      uint64_t v38 = 0;
      unint64_t v39 = a3;
      int v40 = 0;
      unint64_t v41 = 0;
      unsigned int v42 = 0;
      int v204 = (MILToMLIRRewriter *)v39;
      int v205 = v4;
      uint64_t v200 = (uint64_t *)(v39 + 18);
      uint64_t v201 = (uint64_t)Strides;
      char v203 = 1;
      uint64_t v208 = 1;
      int v199 = v18;
      while (1)
      {
        int v45 = (MIL::IRConstantProperty *)MIL::IRProperty::TryAsConstant(*(MIL::IRProperty **)(v27 + 8 * v41));
        if (!v45)
        {
          while (1)
          {
            unint64_t v41 = ++v42;
            if ((v209 - v27) >> 3 <= (unint64_t)v42) {
              goto LABEL_145;
            }
            int v45 = (MIL::IRConstantProperty *)MIL::IRProperty::TryAsConstant(*(MIL::IRProperty **)(v27 + 8 * v42));
            if (v45)
            {
              char v203 = 0;
              break;
            }
          }
        }
        int ScalarDataType = MIL::IRConstantProperty::GetScalarDataType(v45);
        if (ScalarDataType == 14)
        {
          UInt8Scalaruint64_t Value = MIL::IRConstantProperty::GetUInt8ScalarValue(v45);
          if (v40 < v38) {
            goto LABEL_67;
          }
        }
        else if (ScalarDataType == 12)
        {
          UInt8Scalaruint64_t Value = MIL::IRConstantProperty::GetInt64ScalarValue(v45);
          if (v40 < v38) {
            goto LABEL_67;
          }
        }
        else
        {
          UInt8Scalaruint64_t Value = -1;
          if (v40 < v38)
          {
LABEL_67:
            *v40++ = UInt8ScalarValue;
            goto LABEL_75;
          }
        }
        int64_t v48 = (char *)v40 - (char *)v37;
        uint64_t v49 = v40 - v37;
        unint64_t v50 = v49 + 1;
        if ((unint64_t)(v49 + 1) >> 61) {
          std::vector<long>::__throw_length_error[abi:ne180100]();
        }
        if (((char *)v38 - (char *)v37) >> 2 > v50) {
          unint64_t v50 = ((char *)v38 - (char *)v37) >> 2;
        }
        if ((unint64_t)((char *)v38 - (char *)v37) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v51 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v51 = v50;
        }
        if (v51)
        {
          if (v51 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v52 = UInt8ScalarValue;
          int v53 = operator new(8 * v51);
          UInt8Scalaruint64_t Value = v52;
          unint64_t v54 = (uint64_t *)&v53[8 * v49];
          *unint64_t v54 = UInt8ScalarValue;
          uint64_t v55 = v54 + 1;
          int64_t v56 = (char *)v40 - (char *)v37;
          if (v40 == v37) {
            goto LABEL_72;
          }
        }
        else
        {
          int v53 = 0;
          unint64_t v54 = (uint64_t *)(8 * v49);
          int v57 = (uint64_t *)(8 * v49);
          *int v57 = UInt8ScalarValue;
          uint64_t v55 = v57 + 1;
          int64_t v56 = (char *)v40 - (char *)v37;
          if (v40 == v37) {
            goto LABEL_72;
          }
        }
        unint64_t v58 = v56 - 8;
        if (v58 >= 0x168)
        {
          unint64_t v78 = ((char *)(v40 - 1) - (char *)v37) & 0xFFFFFFFFFFFFFFF8;
          if (&v53[v48 - 8 - v78] > &v53[v48 - 8])
          {
            int v59 = v40;
          }
          else if ((uint64_t *)((char *)v40 - v78 - 8) > v40 - 1)
          {
            int v59 = v40;
          }
          else if ((unint64_t)((char *)v37 - v53) >= 0x20)
          {
            uint64_t v115 = (v58 >> 3) + 1;
            uint64_t v116 = 8 * (v115 & 0x3FFFFFFFFFFFFFFCLL);
            int v59 = &v40[v116 / 0xFFFFFFFFFFFFFFF8];
            unint64_t v54 = (uint64_t *)((char *)v54 - v116);
            int v117 = &v53[v48 - 16];
            unint64_t v118 = v40 - 2;
            uint64_t v119 = v115 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v120 = *(_OWORD *)v118;
              *(v117 - 1) = *((_OWORD *)v118 - 1);
              *int v117 = v120;
              v117 -= 2;
              v118 -= 4;
              v119 -= 4;
            }
            while (v119);
            if (v115 == (v115 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_72;
            }
          }
          else
          {
            int v59 = v40;
          }
        }
        else
        {
          int v59 = v40;
        }
        do
        {
          uint64_t v60 = *--v59;
          *--unint64_t v54 = v60;
        }
        while (v59 != v37);
LABEL_72:
        uint64_t v38 = (uint64_t *)&v53[8 * v51];
        __int16 v229 = v54;
        int v230 = v55;
        int v231 = v38;
        if (v37)
        {
          uint64_t v61 = UInt8ScalarValue;
          operator delete(v37);
          UInt8Scalaruint64_t Value = v61;
          uint64_t v27 = (uint64_t)v221;
          uint64_t v209 = v222;
        }
        uint64_t v37 = v54;
        int v40 = v55;
LABEL_75:
        int v230 = v40;
        unint64_t v62 = (v209 - v27) >> 3;
        if (UInt8ScalarValue == 1 || v62 - 1 <= v41) {
          goto LABEL_46;
        }
        BOOL v206 = v38;
        unint64_t v63 = v227;
        if ((unint64_t)v227 < v228)
        {
          _DWORD *v227 = UInt8ScalarValue;
          v227 = v63 + 1;
          uint64_t v65 = (char *)v224;
          uint64_t v64 = v225;
          if (v224 >= v225) {
            goto LABEL_104;
          }
          goto LABEL_44;
        }
        int64_t v66 = v226;
        int64_t v67 = (char *)v227 - v226;
        uint64_t v68 = ((char *)v227 - v226) >> 2;
        unint64_t v69 = v68 + 1;
        if ((unint64_t)(v68 + 1) >> 62) {
          std::vector<int>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v70 = v228 - (void)v226;
        if ((uint64_t)(v228 - (void)v226) >> 1 > v69) {
          unint64_t v69 = v70 >> 1;
        }
        if ((unint64_t)v70 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v71 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v71 = v69;
        }
        if (!v71)
        {
          int v74 = 0;
          int v75 = (_DWORD *)(4 * v68);
          uint64_t v79 = (_DWORD *)(4 * v68);
          _DWORD *v79 = UInt8ScalarValue;
          uint64_t v76 = v79 + 1;
          int64_t v77 = (char *)v63 - v66;
          if (v63 == (_DWORD *)v66) {
            goto LABEL_101;
          }
LABEL_95:
          unint64_t v80 = v77 - 4;
          if (v80 < 0x2C) {
            goto LABEL_258;
          }
          if ((unint64_t)((char *)v63 - v74 - v67) < 0x20) {
            goto LABEL_258;
          }
          uint64_t v81 = (v80 >> 2) + 1;
          uint64_t v82 = 4 * (v81 & 0x7FFFFFFFFFFFFFF8);
          long long v83 = &v63[v82 / 0xFFFFFFFFFFFFFFFCLL];
          int v75 = (_DWORD *)((char *)v75 - v82);
          uint64_t v84 = &v74[v67 - 16];
          __int16 v85 = (long long *)(v63 - 4);
          uint64_t v86 = v81 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            long long v87 = *v85;
            *(v84 - 1) = *(v85 - 1);
            *uint64_t v84 = v87;
            v84 -= 2;
            v85 -= 2;
            v86 -= 8;
          }
          while (v86);
          unint64_t v63 = v83;
          if (v81 != (v81 & 0x7FFFFFFFFFFFFFF8))
          {
LABEL_258:
            do
            {
              int v88 = *--v63;
              *--int v75 = v88;
            }
            while (v63 != (_DWORD *)v66);
          }
          goto LABEL_101;
        }
        if (v71 >> 62) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v72 = UInt8ScalarValue;
        unint64_t v73 = v71;
        int v74 = operator new(4 * v71);
        UInt8Scalaruint64_t Value = v72;
        unint64_t v62 = (v209 - v27) >> 3;
        uint64_t v4 = v205;
        unint64_t v71 = v73;
        int64_t v67 = (char *)v227 - v226;
        int v75 = &v74[4 * v68];
        *int v75 = UInt8ScalarValue;
        uint64_t v76 = v75 + 1;
        int64_t v77 = (char *)v63 - v66;
        if (v63 != (_DWORD *)v66) {
          goto LABEL_95;
        }
LABEL_101:
        int v226 = v75;
        unint64_t v228 = (unint64_t)&v74[4 * v71];
        if (v66)
        {
          uint64_t v89 = UInt8ScalarValue;
          operator delete(v66);
          UInt8Scalaruint64_t Value = v89;
        }
        v227 = v76;
        uint64_t v65 = (char *)v224;
        uint64_t v64 = v225;
        if (v224 >= v225)
        {
LABEL_104:
          v202 = v40;
          unint64_t v90 = v62;
          int v91 = (char *)v223;
          int64_t v92 = v65 - (unsigned char *)v223;
          uint64_t v93 = (v65 - (unsigned char *)v223) >> 2;
          unint64_t v94 = v93 + 1;
          if ((unint64_t)(v93 + 1) >> 62) {
            std::vector<int>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v95 = (char *)v64 - (unsigned char *)v223;
          if (v95 >> 1 > v94) {
            unint64_t v94 = v95 >> 1;
          }
          if ((unint64_t)v95 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v96 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v96 = v94;
          }
          if (v96)
          {
            if (v96 >> 62) {
              std::__throw_bad_array_new_length[abi:ne180100]();
            }
            uint64_t v97 = UInt8ScalarValue;
            unint64_t v98 = v96;
            uint64_t v99 = operator new(4 * v96);
            UInt8Scalaruint64_t Value = v97;
            unint64_t v96 = v98;
            BOOL v100 = (int *)&v99[4 * v93];
            *BOOL v100 = v42;
            int v44 = v100 + 1;
            int64_t v101 = v65 - v91;
            if (v65 != v91)
            {
LABEL_113:
              unint64_t v102 = v101 - 4;
              if (v102 < 0x2C)
              {
                unint64_t v62 = v90;
                int v40 = v202;
                uint64_t v4 = v205;
                goto LABEL_121;
              }
              char v104 = &v99[v92];
              unint64_t v105 = v65 - &v99[v92];
              unint64_t v62 = v90;
              int v40 = v202;
              uint64_t v4 = v205;
              if (v105 < 0x20) {
                goto LABEL_259;
              }
              uint64_t v106 = (v102 >> 2) + 1;
              uint64_t v107 = 4 * (v106 & 0x7FFFFFFFFFFFFFF8);
              uint64_t v108 = &v65[-v107];
              BOOL v100 = (int *)((char *)v100 - v107);
              float v109 = v104 - 16;
              float v110 = v65 - 16;
              uint64_t v111 = v106 & 0x7FFFFFFFFFFFFFF8;
              do
              {
                long long v112 = *(_OWORD *)v110;
                *((_OWORD *)v109 - 1) = *((_OWORD *)v110 - 1);
                *(_OWORD *)float v109 = v112;
                v109 -= 32;
                v110 -= 32;
                v111 -= 8;
              }
              while (v111);
              uint64_t v65 = v108;
              if (v106 != (v106 & 0x7FFFFFFFFFFFFFF8))
              {
LABEL_259:
                do
                {
LABEL_121:
                  int v113 = *((_DWORD *)v65 - 1);
                  v65 -= 4;
                  *--BOOL v100 = v113;
                }
                while (v65 != v91);
              }
LABEL_122:
              uint64_t v223 = v100;
              std::string v225 = (int *)&v99[4 * v96];
              if (v91)
              {
                uint64_t v114 = UInt8ScalarValue;
                operator delete(v91);
                UInt8Scalaruint64_t Value = v114;
              }
              goto LABEL_45;
            }
          }
          else
          {
            uint64_t v99 = 0;
            BOOL v100 = (int *)(4 * v93);
            uint64_t v103 = (unsigned int *)(4 * v93);
            unsigned int *v103 = v42;
            int v44 = (int *)(v103 + 1);
            int64_t v101 = v65 - v91;
            if (v65 != v91) {
              goto LABEL_113;
            }
          }
          unint64_t v62 = v90;
          int v40 = v202;
          uint64_t v4 = v205;
          goto LABEL_122;
        }
LABEL_44:
        *(_DWORD *)uint64_t v65 = v42;
        int v44 = (int *)(v65 + 4);
LABEL_45:
        int v224 = v44;
        v208 *= UInt8ScalarValue;
        uint64_t v38 = v206;
LABEL_46:
        unint64_t v41 = ++v42;
        if (v62 <= v42)
        {
          if (v203)
          {
            if (v208 < 2)
            {
              uint64_t v121 = ArgValue;
              a3 = (mlir::StringAttr **)v204;
            }
            else
            {
              uint64_t v128 = __p;
              uint64_t v129 = (const float *)v223;
              uint64_t v130 = *((void *)__p + *(int *)v223);
              uint64_t v131 = (*(uint64_t (**)(uint64_t))(*(void *)v130 + 16))(v130);
              uint64_t v210 = v219;
              if (v131) {
                uint64_t v132 = (*(uint64_t (**)(uint64_t))(*(void *)v131 + 48))(v131);
              }
              else {
                uint64_t v132 = -1;
              }
              uint64_t v134 = (uint64_t)v224;
              if (v223 != v224)
              {
                uint64_t v135 = (int *)v223;
                while (1)
                {
                  uint64_t v137 = *v135;
                  uint64_t v138 = (*(uint64_t (**)(void))(**((void **)__p + v137) + 16))(*((void *)__p + v137));
                  uint64_t v139 = MIL::IRProperty::TryAsConstant(*(MIL::IRProperty **)(v27 + 8 * v137));
                  unint64_t v140 = (MIL::IRConstantProperty *)v139;
                  if (v138 && v139 != 0)
                  {
                    uint64_t v142 = (*(uint64_t (**)(uint64_t))(*(void *)v138 + 48))(v138);
                    int v143 = MIL::IRConstantProperty::GetScalarDataType(v140);
                    if (v143 == 14) {
                      uint64_t v136 = MIL::IRConstantProperty::GetUInt8ScalarValue(v140);
                    }
                    else {
                      uint64_t v136 = v143 == 12 ? MIL::IRConstantProperty::GetInt64ScalarValue(v140) : -1;
                    }
                    if (v142 % v136) {
                      break;
                    }
                  }
                  if (++v135 == v224) {
                    goto LABEL_176;
                  }
                }
                v235.__begin_ = (std::vector<int>::pointer)operator new(0x28uLL);
                *(_OWORD *)&v235.__end_ = xmmword_181129ED0;
                strcpy((char *)v235.__begin_, "shape[dim] % interleave[dim] != 0");
                uint64_t v43 = MILToMLIRRewriter::notifyFailure((uint64_t)v204, (uint64_t)v4, (const std::string::value_type *)&v235);
LABEL_146:
                uint64_t v27 = v43;
                if (SHIBYTE(v235.__end_cap_.__value_) < 0) {
                  operator delete(v235.__begin_);
                }
LABEL_148:
                if (__p) {
                  operator delete(__p);
                }
                __int16 v28 = v221;
                if (v221) {
LABEL_151:
                }
                  operator delete(v28);
                goto LABEL_152;
              }
LABEL_176:
              if (v201)
              {
                std::vector<MIL::IRProperty const*>::vector(&v235, v201);
                std::vector<int>::pointer begin = v235.__begin_;
                if ((std::vector<int>::pointer)((char *)v235.__end_ - (char *)v235.__begin_) == (std::vector<int>::pointer)16)
                {
                  char v145 = 0;
                }
                else
                {
                  unint64_t v146 = 0;
                  while (1)
                  {
                    uint64_t v148 = (MIL::IRConstantProperty *)MIL::IRProperty::TryAsConstant(*(MIL::IRProperty **)&begin[2 * v146]);
                    uint64_t v149 = MIL::IRProperty::TryAsConstant(*(MIL::IRProperty **)&v235.__begin_[2 * v146 + 2]);
                    uint64_t v27 = v149;
                    if (v148 && v149 != 0)
                    {
                      int v151 = MIL::IRConstantProperty::GetScalarDataType(v148);
                      if (v151 == 14) {
                        uint64_t v152 = MIL::IRConstantProperty::GetUInt8ScalarValue(v148);
                      }
                      else {
                        uint64_t v152 = v151 == 12 ? MIL::IRConstantProperty::GetInt64ScalarValue(v148) : -1;
                      }
                      int v153 = MIL::IRConstantProperty::GetScalarDataType((MIL::IRConstantProperty *)v27);
                      if (v153 == 14) {
                        uint64_t v147 = MIL::IRConstantProperty::GetUInt8ScalarValue((MIL::IRConstantProperty *)v27);
                      }
                      else {
                        uint64_t v147 = v153 == 12
                      }
                             ? MIL::IRConstantProperty::GetInt64ScalarValue((MIL::IRConstantProperty *)v27)
                             : -1;
                      if (v152 % v147) {
                        break;
                      }
                    }
                    ++v146;
                    std::vector<int>::pointer begin = v235.__begin_;
                    if (v146 >= (((char *)v235.__end_ - (char *)v235.__begin_) >> 3) - 2)
                    {
                      char v145 = 0;
                      goto LABEL_201;
                    }
                  }
                  unint64_t v216 = operator new(0x20uLL);
                  long long v217 = xmmword_181129E80;
                  strcpy((char *)v216, "strides[i] % strides[i+1] != 0");
                  uint64_t v27 = MILToMLIRRewriter::notifyFailure((uint64_t)v204, (uint64_t)v4, (const std::string::value_type *)&v216);
                  if (SHIBYTE(v217) < 0) {
                    operator delete(v216);
                  }
                  char v145 = 1;
                  std::vector<int>::pointer begin = v235.__begin_;
                }
LABEL_201:
                if (begin)
                {
                  v235.__end_ = begin;
                  operator delete(begin);
                }
                if (v145) {
                  goto LABEL_148;
                }
              }
              if (v134 - (void)v129 == 4 && v132 == v208)
              {
                unint64_t v154 = v210 - v128;
                uint64_t v155 = (v210 - v128) >> 3;
                v235.__begin_ = (std::vector<int>::pointer)v155;
                uint64_t i = (mlir::OpBuilder *)v200;
                uint64_t v157 = mlir::IntegerType::get(*v200, 0x20u, 1u);
                a3 = (mlir::StringAttr **)v204;
                unint64_t v216 = (void *)mlir::RankedTensorType::get((uint64_t)&v235, 1, v157, 0);
                std::vector<int>::vector(&v235, v155);
                if (v210 - v128 >= 1)
                {
                  std::vector<int>::pointer v158 = v235.__begin_;
                  if (v155 <= 1) {
                    unint64_t v159 = 1;
                  }
                  else {
                    unint64_t v159 = (v210 - v128) >> 3;
                  }
                  if (v199)
                  {
                    if (v159 < 8)
                    {
                      uint64_t v160 = 0;
                      goto LABEL_233;
                    }
                    if (v235.__begin_ < (std::vector<int>::pointer)v129 + 1
                      && (std::vector<int>::pointer)v129 < &v235.__begin_[v159])
                    {
                      uint64_t v160 = 0;
                      goto LABEL_233;
                    }
                    uint64_t v160 = v159 & 0x7FFFFFFFFFFFFFF8;
                    int8x16_t v177 = (int8x16_t)vdupq_n_s32((v154 >> 3) - 1);
                    float32x2_t v178 = vld1_dup_f32(v129);
                    v179.i64[0] = v178.u32[0];
                    v179.i64[1] = v178.u32[1];
                    int64x2_t v180 = v179;
                    v179.i64[0] = v178.i32[0];
                    v179.i64[1] = v178.i32[1];
                    int64x2_t v181 = v179;
                    int64x2_t v182 = (int64x2_t)xmmword_1810FE510;
                    int64x2_t v183 = (int64x2_t)xmmword_1810FE2E0;
                    int32x4_t v184 = (int32x4_t)xmmword_1810FFF10;
                    uint64_t v185 = (int8x16_t *)(v235.__begin_ + 4);
                    int64x2_t v186 = vdupq_n_s64(4uLL);
                    v187.i64[0] = 0x400000004;
                    v187.i64[1] = 0x400000004;
                    int64x2_t v188 = vdupq_n_s64(8uLL);
                    v189.i64[0] = 0x800000008;
                    v189.i64[1] = 0x800000008;
                    uint64_t v190 = v159 & 0x7FFFFFFFFFFFFFF8;
                    do
                    {
                      int64x2_t v191 = vaddq_s64(v183, v186);
                      int64x2_t v192 = vaddq_s64(v182, v186);
                      v185[-1] = vbslq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_s64(v183, v180), (int32x4_t)vceqq_s64(v182, v180)), v177, (int8x16_t)vaddq_s32(v184, vuzp1q_s32((int32x4_t)vcgtq_s64(v183, v181), (int32x4_t)vcgtq_s64(v182, v181))));
                      int8x16_t *v185 = vbslq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_s64(v191, v180), (int32x4_t)vceqq_s64(v192, v180)), v177, (int8x16_t)vaddq_s32(vaddq_s32(v184, v187), vuzp1q_s32((int32x4_t)vcgtq_s64(v191, v181), (int32x4_t)vcgtq_s64(v192, v181))));
                      int64x2_t v182 = vaddq_s64(v182, v188);
                      int64x2_t v183 = vaddq_s64(v183, v188);
                      int32x4_t v184 = vaddq_s32(v184, v189);
                      v185 += 2;
                      v190 -= 8;
                    }
                    while (v190);
                    a3 = (mlir::StringAttr **)v204;
                    for (uint64_t i = (mlir::OpBuilder *)v200; v159 != v160; ++v160)
                    {
LABEL_233:
                      uint64_t v193 = *(int *)v129;
                      if (v160 <= v193) {
                        int v194 = 0;
                      }
                      else {
                        int v194 = -1;
                      }
                      int v195 = v160 + v194;
                      if (v160 == v193) {
                        int v196 = (v154 >> 3) - 1;
                      }
                      else {
                        int v196 = v195;
                      }
                      v158[v160] = v196;
                    }
                  }
                  else
                  {
                    uint64_t v174 = 0;
                    do
                    {
                      uint64_t v175 = *(int *)v129;
                      if (v174 == v175) {
                        int v176 = (v154 >> 3) - 1;
                      }
                      else {
                        int v176 = v174 - (v174 > v175);
                      }
                      v158[v176] = v174++;
                    }
                    while (v159 != v174);
                  }
                }
                std::string::size_type v197 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v216);
                uint64_t v234 = mlir::DenseIntElementsAttr::get<std::vector<int> &>((uint64_t)v197, v198, (uint64_t)v235.__begin_, (uint64_t)v235.__end_);
                v215 = (uint64_t *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(i, v207, (uint64_t **)&v234);
                uint64_t v173 = mlir::OpBuilder::create<mlir::mps::PermuteOp,mlir::Value &,mlir::mps::ConstantOp &>(i, v207, &ArgValue, (uint64_t)&v215);
                if (!*(_DWORD *)(v173 + 36)) {
                  __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                }
                if (v235.__begin_)
                {
                  v235.__end_ = v235.__begin_;
                  operator delete(v235.__begin_);
                }
              }
              else
              {
                v235.__begin_ = (std::vector<int>::pointer)(*(void *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
                uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v235);
                a3 = (mlir::StringAttr **)v204;
                uint64_t v162 = mlir::IntegerType::get(Context, 0x20u, 1u);
                int v163 = (int *)mlir::RankedTensorType::get(0, 0, v162, 0);
                uint64_t v234 = (v134 - (uint64_t)v129) >> 2;
                v235.__begin_ = v163;
                unint64_t v216 = (void *)mlir::RankedTensorType::get((uint64_t)&v234, 1, v162, 0);
                int v164 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v216);
                uint64_t v234 = mlir::DenseIntElementsAttr::get<std::vector<int> &>((uint64_t)v164, v165, (uint64_t)v129, v134);
                int v166 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v216);
                v215 = (uint64_t *)mlir::DenseIntElementsAttr::get<std::vector<int> &>((uint64_t)v166, v167, (uint64_t)v226, (uint64_t)v227);
                uint64_t v168 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::RankedTensorType &,mlir::DenseIntElementsAttr &>((mlir::OpBuilder *)v200, v207, (uint64_t *)&v216, (uint64_t **)&v234);
                if (!*(_DWORD *)(v168 + 36)) {
                  __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                }
                uint64_t v214 = v168 - 16;
                uint64_t v169 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v235);
                int v211 = -1;
                uint64_t v212 = (uint64_t *)mlir::DenseIntElementsAttr::get<int>((uint64_t)v169, v170, (uint64_t)&v211);
                v171 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v200, v207, &v212);
                if (!*((_DWORD *)v171 + 9)) {
                  __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                }
                uint64_t v213 = (uint64_t)v171 - 16;
                uint64_t v172 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::RankedTensorType &,mlir::DenseIntElementsAttr &>((mlir::OpBuilder *)v200, v207, (uint64_t *)&v216, &v215);
                if (!*(_DWORD *)(v172 + 36)) {
                  __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                }
                uint64_t v212 = (uint64_t *)(v172 - 16);
                if (v199)
                {
                  LOBYTE(v211) = 1;
                  uint64_t v173 = (uint64_t)mlir::OpBuilder::create<mlir::mps::BatchToSpaceOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,BOOL>((mlir::UnitAttr **)v200, v207, &ArgValue, &v214, &v213, (uint64_t *)&v212, (unsigned __int8 *)&v211);
                  if (!*(_DWORD *)(v173 + 36)) {
                    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                  }
                }
                else
                {
                  LOBYTE(v211) = 1;
                  uint64_t v173 = (uint64_t)mlir::OpBuilder::create<mlir::mps::SpaceToBatchOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,BOOL>((mlir::UnitAttr **)v200, v207, &ArgValue, &v214, &v213, (uint64_t *)&v212, (unsigned __int8 *)&v211);
                  if (!*(_DWORD *)(v173 + 36)) {
                    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                  }
                }
              }
              uint64_t v121 = v173 - 16;
            }
LABEL_132:
            (*(void (**)(std::vector<int> *__return_ptr, const MIL::IROperation *))(*(void *)v4 + 200))(&v235, v4);
            std::vector<int>::pointer v122 = v235.__begin_;
            char v123 = (char *)operator new(8uLL);
            *(void *)char v123 = v121;
            unint64_t v216 = v122;
            __int16 v124 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v122, (uint64_t)&std::piecewise_construct, (long long **)&v216);
            std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v124 + 5, v123, v123 + 8, 1uLL);
            operator delete(v123);
            uint64_t v125 = v235.__begin_;
            if (v235.__begin_)
            {
              std::vector<int>::pointer end = v235.__end_;
              std::vector<int>::pointer v127 = v235.__begin_;
              if (v235.__end_ != v235.__begin_)
              {
                do
                {
                  if (*((char *)end - 1) < 0) {
                    operator delete(*((void **)end - 3));
                  }
                  end -= 6;
                }
                while (end != v125);
                std::vector<int>::pointer v127 = v235.__begin_;
              }
              v235.__end_ = v125;
              operator delete(v127);
            }
            uint64_t v27 = 1;
            goto LABEL_148;
          }
LABEL_145:
          v235.__begin_ = (std::vector<int>::pointer)operator new(0x30uLL);
          *(_OWORD *)&v235.__end_ = xmmword_181129EE0;
          strcpy((char *)v235.__begin_, "Non-constant interleave factor detected!");
          uint64_t v43 = MILToMLIRRewriter::notifyFailure((uint64_t)v204, (uint64_t)v4, (const std::string::value_type *)&v235);
          goto LABEL_146;
        }
      }
    }
  }
  uint64_t v221 = operator new(0x28uLL);
  long long v222 = xmmword_1811286F0;
  strcpy((char *)v221, "Expected \"input\" to be a tensor_buffer.");
  uint64_t v27 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)v4, (const std::string::value_type *)&v221);
  if (SHIBYTE(v222) < 0)
  {
    __int16 v28 = v221;
    goto LABEL_151;
  }
LABEL_152:
  if (v223) {
    operator delete(v223);
  }
  if (v226) {
    operator delete(v226);
  }
  if (v229) {
    operator delete(v229);
  }
  if (SHIBYTE(v233.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v233.__r_.__value_.__l.__data_);
  }
  return v27;
}

void sub_180D4F314(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,void *a41,uint64_t a42)
{
  if (a31 < 0) {
    operator delete(__p);
  }
  int v44 = *(void **)(v42 - 128);
  if (v44)
  {
    *(void *)(v42 - 120) = v44;
    operator delete(v44);
  }
  if (a32) {
    operator delete(a32);
  }
  if (a35) {
    operator delete(a35);
  }
  if (a41)
  {
    operator delete(a41);
    uint64_t v45 = v42 - 216;
    unint64_t v46 = *(void **)(v42 - 216);
    if (!v46)
    {
LABEL_11:
      uint64_t v47 = v42 - 216;
      int64_t v48 = *(void **)(v42 - 192);
      if (!v48)
      {
LABEL_16:
        if (*(char *)(v42 - 137) < 0) {
          operator delete(*(void **)(v42 - 160));
        }
        _Unwind_Resume(exception_object);
      }
LABEL_15:
      *(void *)(v47 + 32) = v48;
      operator delete(v48);
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v45 = v42 - 216;
    unint64_t v46 = *(void **)(v42 - 216);
    if (!v46) {
      goto LABEL_11;
    }
  }
  *(void *)(v45 + 8) = v46;
  operator delete(v46);
  uint64_t v47 = v42 - 216;
  int64_t v48 = *(void **)(v42 - 192);
  if (!v48) {
    goto LABEL_16;
  }
  goto LABEL_15;
}

void *std::vector<MIL::IRProperty const*>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(const void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  int64_t v5 = v3 - *(void *)a2;
  if (v3 != *(void *)a2)
  {
    if (v5 < 0) {
      std::vector<int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v6 = (char *)operator new(v3 - *(void *)a2);
    *a1 = v6;
    a1[1] = v6;
    long long v7 = &v6[8 * (v5 >> 3)];
    a1[2] = v7;
    memcpy(v6, v4, v5);
    a1[1] = v7;
  }
  return a1;
}

void sub_180D4F5B0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

std::vector<int> *__cdecl std::vector<int>::vector(std::vector<int> *this, std::vector<int>::size_type __n)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    if (__n >> 62) {
      std::vector<int>::__throw_length_error[abi:ne180100]();
    }
    std::vector<int>::size_type v4 = __n;
    int64_t v5 = (int *)operator new(4 * __n);
    this->__begin_ = v5;
    this->__end_cap_.__value_ = &v5[__n];
    bzero(v5, 4 * __n);
    this->__end_ = &v5[v4];
  }
  return this;
}

void sub_180D4F648(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::PermuteOp,mlir::Value &,mlir::mps::ConstantOp &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v24[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.permute", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.permute";
    v21[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(void *)a4 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::PermuteOp::build((uint64_t)a1, (uint64_t)v24, *a3, *(void *)a4 - 16);
  BOOL v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    uint64_t v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v15 = 662;
    uint64_t v16 = "Casting.h";
    BOOL v17 = "dyn_cast";
    goto LABEL_10;
  }
  uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::PermuteOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PermuteOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    uint64_t v14 = "result && \"builder didn't return the right type\"";
    int v15 = 497;
    uint64_t v16 = "Builders.h";
    BOOL v17 = "create";
LABEL_10:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180D4F810(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D4F828(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::RankedTensorType &,mlir::DenseIntElementsAttr &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t **a4)
{
  v26[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.constant", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v24 = 1283;
    v23[2] = (uint64_t)"mps.constant";
    v23[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v9);
  uint64_t v11 = *a3;
  uint64_t v12 = mlir::Attribute::cast<mlir::ElementsAttr>(a4);
  mlir::mps::ConstantOp::build((uint64_t)a1, (uint64_t)v26, v11, v12);
  int v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v26);
  if (!v13)
  {
    uint64_t v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v17 = 662;
    uint64_t v18 = "Casting.h";
    std::string::size_type v19 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v14 = llvm::DefaultDoCastIfPossible<mlir::mps::ConstantOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ConstantOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    uint64_t v16 = "result && \"builder didn't return the right type\"";
    int v17 = 497;
    uint64_t v18 = "Builders.h";
    std::string::size_type v19 = "create";
LABEL_8:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v14;
}

void sub_180D4F9C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D4F9E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t MILToMLIR::ResamplePattern::matchAndRewrite(MILToMLIR::ResamplePattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  v88[5] = *(uint64_t **)MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v80 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "coordinates");
  char v87 = 18;
  strcpy(__p, "coordinates_format");
  uint64_t v78 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "padding_value");
  uint64_t v6 = (mlir::OpBuilder *)(a3 + 18);
  if (MIL::IROperation::TryGetParameterValue())
  {
    MIL::IRValue::GetScalar<std::string>();
    if (v87 < 0)
    {
      long long v7 = *(void **)__p;
      if (*(void *)&__p[8] != 2)
      {
LABEL_14:
        operator delete(v7);
        goto LABEL_15;
      }
      if (**(_WORD **)__p == 30841)
      {
        char v8 = operator new(4uLL);
        *char v8 = -1;
        v88[0] = (uint64_t *)(*(void *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
        uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)v88);
        uint64_t v10 = mlir::IntegerType::get(Context, 0x20u, 1u);
        v88[0] = (uint64_t *)1;
        uint64_t v11 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)v88, 1, v10, 0);
        if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v11))
        {
          int v13 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
          int v14 = 566;
          int v15 = "Casting.h";
          uint64_t v16 = "cast";
LABEL_166:
          __assert_rtn(v16, v15, v14, v13);
        }
        if (v11)
        {
          uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v11);
          if (!InterfaceFor)
          {
            int v13 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            int v14 = 98;
            int v15 = "InterfaceSupport.h";
            uint64_t v16 = "Interface";
            goto LABEL_166;
          }
        }
        else
        {
          uint64_t InterfaceFor = 0;
        }
        int v17 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v11, InterfaceFor, v8, 4, 4, 1, 1);
        if ((mlir::DenseIntElementsAttr::classof((uint64_t)v17) & 1) == 0) {
          __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
        }
        v88[0] = v17;
        v84[0] = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v6, LocationForOp, v88);
        uint64_t v18 = mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &,mlir::mps::ConstantOp &>(v6, LocationForOp, &v80, (uint64_t)v84);
        if (!*(_DWORD *)(v18 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        uint64_t v80 = v18 - 16;
        operator delete(v8);
        if (v87 < 0)
        {
          long long v7 = *(void **)__p;
          goto LABEL_14;
        }
      }
    }
  }
LABEL_15:
  char v87 = 16;
  strcpy(__p, "coordinates_type");
  Parameteruint64_t Value = MIL::IROperation::TryGetParameterValue();
  uint64_t v20 = ParameterValue;
  if (v87 < 0)
  {
    operator delete(*(void **)__p);
    if (!v20)
    {
LABEL_22:
      BOOL v21 = 0;
      goto LABEL_27;
    }
  }
  else if (!ParameterValue)
  {
    goto LABEL_22;
  }
  MIL::IRValue::GetScalar<std::string>();
  if ((v87 & 0x80000000) == 0)
  {
    if (v87 == 8)
    {
      BOOL v21 = *(void *)__p == 0x65766974616C6572;
      goto LABEL_27;
    }
    goto LABEL_22;
  }
  BOOL v21 = *(void *)&__p[8] == 8 && **(void **)__p == 0x65766974616C6572;
  operator delete(*(void **)__p);
LABEL_27:
  char v87 = 13;
  strcpy(__p, "sampling_mode");
  uint64_t v22 = MIL::IROperation::TryGetParameterValue();
  uint64_t v23 = v22;
  if (v87 < 0)
  {
    operator delete(*(void **)__p);
    int v77 = v21;
    if (!v23) {
      goto LABEL_39;
    }
  }
  else
  {
    int v77 = v21;
    if (!v22) {
      goto LABEL_39;
    }
  }
  MIL::IRValue::GetScalar<std::string>();
  if ((v87 & 0x80000000) == 0)
  {
    if (v87 == 7)
    {
      unsigned int v25 = *(_DWORD *)__p != 1918985582 || *(_DWORD *)&__p[3] != 1953719666;
      goto LABEL_49;
    }
LABEL_39:
    unsigned int v25 = 1;
    goto LABEL_49;
  }
  unsigned int v25 = *(void *)&__p[8] != 7 || **(_DWORD **)__p != 1918985582 || *(_DWORD *)(*(void *)__p + 3) != 1953719666;
  operator delete(*(void **)__p);
LABEL_49:
  char v87 = 12;
  strcpy(__p, "padding_mode");
  uint64_t v27 = MIL::IROperation::TryGetParameterValue();
  uint64_t v28 = v27;
  if (v87 < 0)
  {
    operator delete(*(void **)__p);
    if (!v28)
    {
LABEL_81:
      unsigned int v30 = 0;
      goto LABEL_82;
    }
  }
  else if (!v27)
  {
    goto LABEL_81;
  }
  MIL::IRValue::GetScalar<std::string>();
  if (v87 < 0)
  {
    switch(*(void *)&__p[8])
    {
      case 6:
        if (**(_DWORD **)__p != 1685221218 || *(_WORD *)(*(void *)__p + 4) != 29285) {
          goto LABEL_173;
        }
        unsigned int v30 = 3;
        operator delete(*(void **)__p);
        break;
      case 8:
        if (**(void **)__p != 0x746E6174736E6F63) {
          goto LABEL_173;
        }
        unsigned int v30 = 0;
        operator delete(*(void **)__p);
        break;
      case 9:
        if (**(void **)__p != 0x697274656D6D7973 || *(unsigned char *)(*(void *)__p + 8) != 99) {
          goto LABEL_173;
        }
        unsigned int v30 = 2;
        operator delete(*(void **)__p);
        break;
      case 0xALL:
        if (**(void **)__p != 0x697463656C666572 || *(_WORD *)(*(void *)__p + 8) != 28271) {
          goto LABEL_173;
        }
        unsigned int v30 = 1;
        operator delete(*(void **)__p);
        break;
      default:
LABEL_173:
        __assert_rtn("matchAndRewrite", "MILToMLIRCustomPatterns.mm", 2615, "0 && \"Unknown padding mode\"");
    }
  }
  else
  {
    switch(v87)
    {
      case 6:
        if (*(_DWORD *)__p != 1685221218 || *(unsigned __int16 *)&__p[4] != 29285) {
          goto LABEL_173;
        }
        unsigned int v30 = 3;
        break;
      case 8:
        if (*(void *)__p == 0x746E6174736E6F63) {
          goto LABEL_81;
        }
        goto LABEL_173;
      case 9:
        if (*(void *)__p != 0x697274656D6D7973 || __p[8] != 99) {
          goto LABEL_173;
        }
        unsigned int v30 = 2;
        break;
      case 10:
        if (*(void *)__p != 0x697463656C666572 || *(unsigned __int16 *)&__p[8] != 28271) {
          goto LABEL_173;
        }
        unsigned int v30 = 1;
        break;
      default:
        goto LABEL_173;
    }
  }
LABEL_82:
  char v87 = 16;
  strcpy(__p, "coordinates_mode");
  uint64_t v34 = MIL::IROperation::TryGetParameterValue();
  uint64_t v35 = v34;
  if (v87 < 0)
  {
    operator delete(*(void **)__p);
    if (!v35) {
      goto LABEL_130;
    }
  }
  else if (!v34)
  {
    goto LABEL_130;
  }
  MIL::IRValue::GetScalar<std::string>();
  if ((v87 & 0x80000000) == 0)
  {
    if (v87 != 12)
    {
      if (v87 != 22) {
        goto LABEL_130;
      }
      BOOL v36 = *(void *)__p == 0x7A696C616D726F6ELL && *(void *)&__p[8] == 0x5F6F72657A5F6465;
      if (!v36 || *(void *)&__p[14] != 0x656E6F5F6F745F6FLL) {
        goto LABEL_130;
      }
LABEL_110:
      *(void *)__p = *(void *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8;
      unint64_t v41 = (mlir::Float32Type *)mlir::Attribute::getContext((mlir::Attribute *)__p);
      uint64_t v43 = mlir::Float32Type::get(v41, v42);
      *(void *)__p = 1;
      int v44 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, v43, 0);
      *(void *)__p = mlir::mps::getConstantAttr<float>(v44, 1.0);
      uint64_t v45 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v6, LocationForOp, (uint64_t **)__p);
      if (!*((_DWORD *)v45 + 9)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
      v88[0] = (uint64_t *)((char *)v45 - 16);
      *(void *)__p = *(void *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8;
      unint64_t v46 = (mlir::Float32Type *)mlir::Attribute::getContext((mlir::Attribute *)__p);
      uint64_t v48 = mlir::Float32Type::get(v46, v47);
      *(void *)__p = 1;
      uint64_t v49 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, v48, 0);
      *(void *)__p = mlir::mps::getConstantAttr<float>(v49, 2.0);
      unint64_t v50 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v6, LocationForOp, (uint64_t **)__p);
      if (!*((_DWORD *)v50 + 9)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
      *(void *)__p = (char *)v50 - 16;
      unint64_t v51 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)v6, LocationForOp, &v80, (uint64_t *)__p);
      if (!*((_DWORD *)v51 + 9)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
      uint64_t v80 = (uint64_t)v51 - 16;
      uint64_t v52 = mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::Value &>((mlir::Float32Type **)v6, LocationForOp, &v80, (uint64_t *)v88);
      if (!*((_DWORD *)v52 + 9)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
      uint64_t v80 = (uint64_t)v52 - 16;
      goto LABEL_130;
    }
    if (*(void *)__p != 0x6C616D726F6E6E75 || *(_DWORD *)&__p[8] != 1684372073) {
      goto LABEL_130;
    }
LABEL_127:
    int v56 = 0;
    goto LABEL_131;
  }
  if (*(void *)&__p[8] == 12)
  {
    unint64_t v54 = *(void **)__p;
    if (**(void **)__p == 0x6C616D726F6E6E75 && *(_DWORD *)(*(void *)__p + 8) == 1684372073)
    {
      operator delete(*(void **)__p);
      goto LABEL_127;
    }
  }
  else
  {
    if (*(void *)&__p[8] == 22)
    {
      BOOL v40 = **(void **)__p != 0x7A696C616D726F6ELL
         || *(void *)(*(void *)__p + 8) != 0x5F6F72657A5F6465
         || *(void *)(*(void *)__p + 14) != 0x656E6F5F6F745F6FLL;
      operator delete(*(void **)__p);
      if (v40) {
        goto LABEL_130;
      }
      goto LABEL_110;
    }
    unint64_t v54 = *(void **)__p;
  }
  operator delete(v54);
LABEL_130:
  int v56 = 1;
LABEL_131:
  char v87 = 13;
  strcpy(__p, "align_corners");
  MIL::IROperation::GetParameterValue();
  if (v87 < 0) {
    operator delete(*(void **)__p);
  }
  int v57 = MIL::IRValue::GetScalar<BOOL>();
  uint64_t v58 = mlir::mps::NearestRoundingModeAttr::get(*(mlir::MLIRContext **)v6, 0);
  uint64_t v81 = LocationForOp;
  int v59 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v81);
  uint64_t v60 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sample_grid", (const unsigned __int8 *)0xF, v59);
  if (!v61)
  {
    __int16 v85 = 1283;
    v84[2] = (uint64_t)"mps.sample_grid";
    v84[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v83 = 259;
    llvm::operator+(v84, (uint64_t *)&v82, (uint64_t)v88);
    llvm::report_fatal_error((llvm::Twine *)v88, 1);
  }
  mlir::OperationState::OperationState(__p, LocationForOp, v60);
  mlir::mps::SampleGridOp::build((mlir::UnitAttr **)v6, (uint64_t)__p, ArgValue, v80, v78, v56, v77, v57, v30, v25, 0, v58);
  unint64_t v62 = mlir::OpBuilder::create(v6, (const mlir::OperationState *)__p);
  if (!v62)
  {
    unint64_t v73 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v74 = 662;
    int v75 = "Casting.h";
    uint64_t v76 = "dyn_cast";
    goto LABEL_163;
  }
  uint64_t v63 = llvm::DefaultDoCastIfPossible<mlir::mps::SampleGridOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SampleGridOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v62);
  if (!v63)
  {
    unint64_t v73 = "result && \"builder didn't return the right type\"";
    int v74 = 497;
    int v75 = "Builders.h";
    uint64_t v76 = "create";
LABEL_163:
    __assert_rtn(v76, v75, v74, v73);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)__p);
  if (!*(_DWORD *)(v63 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  (*(void (**)(unsigned char *__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(__p, a2);
  uint64_t v64 = *(uint64_t **)__p;
  uint64_t v65 = (char *)operator new(8uLL);
  *(void *)uint64_t v65 = v63 - 16;
  v88[0] = v64;
  int64_t v66 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v64, (uint64_t)&std::piecewise_construct, (long long **)v88);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v66 + 5, v65, v65 + 8, 1uLL);
  operator delete(v65);
  uint64_t v67 = *(void *)__p;
  if (*(void *)__p)
  {
    uint64_t v68 = *(void *)&__p[8];
    unint64_t v69 = *(void **)__p;
    if (*(void *)&__p[8] != *(void *)__p)
    {
      do
      {
        if (*(char *)(v68 - 1) < 0) {
          operator delete(*(void **)(v68 - 24));
        }
        v68 -= 24;
      }
      while (v68 != v67);
      unint64_t v69 = *(void **)__p;
    }
    *(void *)&__p[8] = v67;
    operator delete(v69);
  }
  return 1;
}

void sub_180D506B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  operator delete(v32);
  if (a32 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &,mlir::mps::ConstantOp &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v24[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reverse", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.reverse";
    v21[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(void *)a4 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ReverseOp::build((uint64_t)a1, (uint64_t)v24, *a3, *(void *)a4 - 16);
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    int v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v15 = 662;
    uint64_t v16 = "Casting.h";
    int v17 = "dyn_cast";
    goto LABEL_10;
  }
  uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::ReverseOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReverseOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    int v14 = "result && \"builder didn't return the right type\"";
    int v15 = 497;
    uint64_t v16 = "Builders.h";
    int v17 = "create";
LABEL_10:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180D50954(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D5096C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t MILToMLIR::ArgSortPattern::matchAndRewrite(MILToMLIR::ArgSortPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v7 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "axis");
  char v33 = 9;
  strcpy((char *)__p, "ascending");
  MIL::IROperation::GetParameterValue();
  int v8 = MIL::IRValue::GetScalar<BOOL>();
  uint64_t v26 = LocationForOp;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v26);
  uint64_t v10 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sort", (const unsigned __int8 *)8, Context);
  if (!v11)
  {
    __int16 v30 = 1283;
    v29[2] = (uint64_t)"mps.sort";
    v29[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v28 = 259;
    llvm::operator+(v29, (uint64_t *)&v27, (uint64_t)v31);
    llvm::report_fatal_error((llvm::Twine *)v31, 1);
  }
  mlir::OperationState::OperationState(__p, LocationForOp, v10);
  mlir::mps::SortOp::build(a3 + 18, (uint64_t)__p, ArgValue, v7, v8 ^ 1);
  uint64_t v12 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)__p);
  if (!v12)
  {
    __int16 v22 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v23 = 662;
    __int16 v24 = "Casting.h";
    unsigned int v25 = "dyn_cast";
    goto LABEL_17;
  }
  uint64_t v13 = llvm::DefaultDoCastIfPossible<mlir::mps::SortOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SortOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v12);
  if (!v13)
  {
    __int16 v22 = "result && \"builder didn't return the right type\"";
    int v23 = 497;
    __int16 v24 = "Builders.h";
    unsigned int v25 = "create";
LABEL_17:
    __assert_rtn(v25, v24, v23, v22);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)__p);
  if (*(_DWORD *)(v13 + 36) <= 1u) {
    __assert_rtn("operator[]", "STLExtras.h", 1281, "Index < size() && \"invalid index for value range\"");
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v13 - 16, 1);
  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(__p, a2);
  int v15 = (long long *)__p[0];
  uint64_t v16 = (char *)operator new(8uLL);
  *(void *)uint64_t v16 = NextResultAtOffset;
  v31[0] = v15;
  int v17 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v15, (uint64_t)&std::piecewise_construct, v31);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v17 + 5, v16, v16 + 8, 1uLL);
  operator delete(v16);
  uint64_t v18 = (void **)__p[0];
  if (__p[0])
  {
    std::string::size_type v19 = (void **)__p[1];
    __int16 v20 = __p[0];
    if (__p[1] != __p[0])
    {
      do
      {
        if (*((char *)v19 - 1) < 0) {
          operator delete(*(v19 - 3));
        }
        v19 -= 3;
      }
      while (v19 != v18);
      __int16 v20 = __p[0];
    }
    __p[1] = v18;
    operator delete(v20);
  }
  return 1;
}

void sub_180D50C94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
}

void sub_180D50CA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D50CBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MILToMLIR::ReadStatePattern::matchAndRewrite(MILToMLIR::ReadStatePattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "input");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::VariableFromTensorOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    uint64_t v7 = v6;
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    unint64_t v8 = *(void *)(v6 - 8) & 0xFFFFFFFFFFFFFFF8;
    if (!*(void *)v8) {
      __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
    }
    uint64_t v9 = *(void **)(*(void *)v8 + 136);
    if (v9 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v9 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
    }
    uint64_t v40 = LocationForOp;
    uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v40);
    uint64_t v12 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.read_variable", (const unsigned __int8 *)0x11, Context);
    if (!v13)
    {
      __int16 v44 = 1283;
      v43[2] = (uint64_t)"mps.read_variable";
      v43[3] = 17;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)v45);
      llvm::report_fatal_error((llvm::Twine *)v45, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v12);
    if (*(_DWORD *)(v7 + 36))
    {
      uint64_t v14 = *(void *)(*(void *)(v7 - 8) & 0xFFFFFFFFFFFFFFF8);
      if (v14)
      {
        int v15 = *(void **)(v14 + 136);
        if (v15 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
          || v15 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
        {
          mlir::anec::Broadcast::build((uint64_t)(a3 + 18), (uint64_t)&__p, v8, v7 - 16);
          uint64_t v16 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
          if (v16)
          {
            uint64_t v17 = llvm::DefaultDoCastIfPossible<mlir::mps::ReadVariableOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReadVariableOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v16);
            if (v17)
            {
              mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
              (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
              if (*(_DWORD *)(v17 + 36))
              {
                uint64_t v18 = *(void *)(*(void *)(v17 - 8) & 0xFFFFFFFFFFFFFFF8);
                if (v18)
                {
                  std::string::size_type v19 = (long long *)__p;
                  __int16 v20 = *(void **)(v18 + 136);
                  if (v20 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
                    || v20 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
                  {
                    BOOL v21 = (char *)operator new(8uLL);
                    *(void *)BOOL v21 = v17 - 16;
                    v45[0] = v19;
                    __int16 v22 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v19, (uint64_t)&std::piecewise_construct, v45);
                    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v22 + 5, v21, v21 + 8, 1uLL);
                    operator delete(v21);
                    int v23 = (void **)__p;
                    if (__p)
                    {
                      __int16 v24 = (void **)v47;
                      unsigned int v25 = __p;
                      if ((void *)v47 != __p)
                      {
                        do
                        {
                          if (*((char *)v24 - 1) < 0) {
                            operator delete(*(v24 - 3));
                          }
                          v24 -= 3;
                        }
                        while (v24 != v23);
                        unsigned int v25 = __p;
                      }
                      *(void *)&long long v47 = v23;
                      operator delete(v25);
                    }
                    return 1;
                  }
                  uint64_t v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
                  int v36 = 566;
                  uint64_t v37 = "Casting.h";
                  uint64_t v38 = "cast";
                }
                else
                {
                  uint64_t v35 = "abstractType && \"Malformed type storage object.\"";
                  int v36 = 160;
                  uint64_t v37 = "TypeSupport.h";
                  uint64_t v38 = "getAbstractType";
                }
              }
              else
              {
                uint64_t v35 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
                int v36 = 984;
                uint64_t v37 = "Operation.h";
                uint64_t v38 = "getOpResultImpl";
              }
              __assert_rtn(v38, v37, v36, v35);
            }
            int v31 = "result && \"builder didn't return the right type\"";
            int v32 = 497;
            char v33 = "Builders.h";
            uint64_t v34 = "create";
          }
          else
          {
            int v31 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
            int v32 = 662;
            char v33 = "Casting.h";
            uint64_t v34 = "dyn_cast";
          }
          __assert_rtn(v34, v33, v32, v31);
        }
        uint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        int v28 = 566;
        int v29 = "Casting.h";
        __int16 v30 = "cast";
      }
      else
      {
        uint64_t v27 = "abstractType && \"Malformed type storage object.\"";
        int v28 = 160;
        int v29 = "TypeSupport.h";
        __int16 v30 = "getAbstractType";
      }
    }
    else
    {
      uint64_t v27 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
      int v28 = 984;
      int v29 = "Operation.h";
      __int16 v30 = "getOpResultImpl";
    }
    __assert_rtn(v30, v29, v28, v27);
  }
  __p = operator new(0x40uLL);
  long long v47 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v47) < 0) {
    operator delete(__p);
  }
  return 0;
}

void sub_180D511F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::VariableFromTensorOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.variable_from_tensor", (const unsigned __int8 *)0x18, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.variable_from_tensor";
    v19[3] = 24;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    uint64_t v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::VariableFromTensorOp,mlir::Operation *,llvm::CastInfo<mlir::mps::VariableFromTensorOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    uint64_t v14 = "Builders.h";
    int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180D513E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D51400(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t MILToMLIR::WriteStatePattern::matchAndRewrite(MILToMLIR::WriteStatePattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "input");
  uint64_t v6 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "data");
  if (!(*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2))
  {
    char v8 = (mlir::OpBuilder *)(a3 + 18);
    uint64_t v9 = mlir::OpBuilder::create<mlir::mps::VariableFromTensorOp,mlir::Value &>(v8, LocationForOp, &ArgValue);
    uint64_t v26 = LocationForOp;
    uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v26);
    uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.assign_variable", (const unsigned __int8 *)0x13, Context);
    if (!v12)
    {
      __int16 v30 = 1283;
      v29[2] = (uint64_t)"mps.assign_variable";
      v29[3] = 19;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v28 = 259;
      llvm::operator+(v29, (uint64_t *)&v27, (uint64_t)v31);
      llvm::report_fatal_error((llvm::Twine *)v31, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v11);
    if (*(_DWORD *)(v9 + 36))
    {
      uint64_t v13 = *(void *)(*(void *)(v9 - 8) & 0xFFFFFFFFFFFFFFF8);
      if (v13)
      {
        uint64_t v14 = *(void **)(v13 + 136);
        if (v14 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
          || v14 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
        {
          mlir::mps::AssignVariableOp::build((uint64_t)v8, (uint64_t)&__p, v9 - 16, v6);
          uint64_t v16 = mlir::OpBuilder::create(v8, (const mlir::OperationState *)&__p);
          if (v16)
          {
            if (llvm::DefaultDoCastIfPossible<mlir::mps::AssignVariableOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AssignVariableOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v16))
            {
              mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
              return 1;
            }
            BOOL v21 = "result && \"builder didn't return the right type\"";
            int v22 = 497;
            int v23 = "Builders.h";
            __int16 v24 = "create";
          }
          else
          {
            BOOL v21 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
            int v22 = 662;
            int v23 = "Casting.h";
            __int16 v24 = "dyn_cast";
          }
          __assert_rtn(v24, v23, v22, v21);
        }
        uint64_t v17 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        int v18 = 566;
        std::string::size_type v19 = "Casting.h";
        __int16 v20 = "cast";
      }
      else
      {
        uint64_t v17 = "abstractType && \"Malformed type storage object.\"";
        int v18 = 160;
        std::string::size_type v19 = "TypeSupport.h";
        __int16 v20 = "getAbstractType";
      }
    }
    else
    {
      uint64_t v17 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
      int v18 = 984;
      std::string::size_type v19 = "Operation.h";
      __int16 v20 = "getOpResultImpl";
    }
    __assert_rtn(v20, v19, v18, v17);
  }
  __p = operator new(0x40uLL);
  long long v33 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v33) < 0) {
    operator delete(__p);
  }
  return 0;
}

void sub_180D51718(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180D51740(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D51754(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t MILToMLIR::SDPAPattern::matchAndRewrite(MILToMLIR::SDPAPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v106 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "query");
  uint64_t v94 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "key");
  uint64_t v6 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "value");
  OptionalArguint64_t Value = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "attn_mask");
  uint64_t v7 = *(void *)(ArgValue + 8);
  char v8 = (uint64_t **)(v7 & 0xFFFFFFFFFFFFFFF8);
  if ((v7 & 0xFFFFFFFFFFFFFFF8) == 0) {
    __assert_rtn("dyn_cast", "Casting.h", 650, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
  }
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor((uint64_t **)(v7 & 0xFFFFFFFFFFFFFFF8)))
  {
    int v91 = 0;
    uint64_t v92 = 0;
LABEL_16:
    __p = operator new(0x20uLL);
    long long v105 = xmmword_181128710;
    strcpy((char *)__p, "Query did not have a ShapedType");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    goto LABEL_31;
  }
  uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v8);
  if (!InterfaceFor) {
    __assert_rtn("Interface", "InterfaceSupport.h", 98, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
  }
  int v91 = v8;
  uint64_t v92 = InterfaceFor;
  if (!v8) {
    goto LABEL_16;
  }
  LODWORD(__p) = -1;
  uint64_t v10 = mlir::OpBuilder::create<mlir::mps::ConstantOp,int>((mlir::mps::ConstantOp *)(a3 + 18), LocationForOp, (unsigned int *)&__p);
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf((void *)(*(void *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8));
  uint64_t v11 = *(void *)(*(void *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v11) {
    __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
  }
  if (*(_UNKNOWN **)(v11 + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v91);
    if (!v20) {
      __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
    }
    uint64_t v21 = *(void *)(ArgAttrsAttr + 8 * v20 - 8);
    __p = (void *)1;
    int v22 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&__p, 1, ElementTypeOrSelf, 0);
    __p = (void *)mlir::mps::getConstantAttr<float>(v22, 1.0 / sqrtf((float)v21));
    uint64_t v18 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)&__p);
    if (!*(_DWORD *)(v18 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    goto LABEL_19;
  }
  uint64_t v96 = LocationForOp;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v96);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dimension_size", (const unsigned __int8 *)0x12, Context);
  if (!v14)
  {
    __int16 v102 = 1283;
    BOOL v100 = "mps.dimension_size";
    uint64_t v101 = 18;
                      "een added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-de"
                      "pendent-whats-up-with-dialects-management";
    __int16 v98 = 259;
    llvm::operator+(v99, v97, (uint64_t)v103);
    llvm::report_fatal_error((llvm::Twine *)v103, 1);
  }
  mlir::OperationState::OperationState(&__p, LocationForOp, v13);
  if (!*((_DWORD *)v10 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::DimensionSizeOp::build((uint64_t)(a3 + 18), (uint64_t)&__p, ArgValue, (uint64_t)v10 - 16);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
  if (!v15)
  {
    uint64_t v64 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v65 = 662;
    int64_t v66 = "Casting.h";
    uint64_t v67 = "dyn_cast";
    goto LABEL_84;
  }
  uint64_t v16 = llvm::DefaultDoCastIfPossible<mlir::mps::DimensionSizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DimensionSizeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
  if (!v16)
  {
    uint64_t v64 = "result && \"builder didn't return the right type\"";
    int v65 = 497;
    int64_t v66 = "Builders.h";
    uint64_t v67 = "create";
LABEL_84:
    __assert_rtn(v67, v66, v65, v64);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
  if (!*(_DWORD *)(v16 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  __p = (void *)(v16 - 16);
  uint64_t v17 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a3 + 18, LocationForOp, (uint64_t *)&__p, &ElementTypeOrSelf);
  if (!*((_DWORD *)v17 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  __p = (char *)v17 - 16;
  uint64_t v18 = mlir::OpBuilder::create<mlir::mps::ReciprocalSquareRootOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t *)&__p);
  if (!*(_DWORD *)(v18 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
LABEL_19:
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    LOBYTE(__p) = 0;
    LOBYTE(v103[0]) = 1;
    uint64_t v23 = mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value &,mlir::Value &,BOOL,BOOL>(a3 + 18, LocationForOp, &ArgValue, &v94, (unsigned __int8 *)&__p, (unsigned __int8 *)v103);
    uint64_t v96 = LocationForOp;
    __int16 v24 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v96);
    uint64_t v25 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, v24);
    if (!v26)
    {
      __int16 v102 = 1283;
      BOOL v100 = "mps.multiply";
      uint64_t v101 = 12;
                        " been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loade"
                        "d-dependent-whats-up-with-dialects-management";
      __int16 v98 = 259;
      llvm::operator+(v99, v97, (uint64_t)v103);
      llvm::report_fatal_error((llvm::Twine *)v103, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v25);
    if (!*(_DWORD *)(v23 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    mlir::mps::ATan2Op::build(a3 + 18, (uint64_t)&__p, v23 - 16, v18 - 16);
    uint64_t v27 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    if (v27)
    {
      uint64_t v28 = llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v27);
      if (v28)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        uint64_t v89 = v28;
        if (!OptionalArgValue)
        {
          __p = (void *)1;
          int v32 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&__p, 1, ElementTypeOrSelf, 0);
          __p = (void *)mlir::mps::getConstantAttr<float>(v32, 0.0);
          long long v33 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)&__p);
          uint64_t v96 = LocationForOp;
          uint64_t v34 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v96);
          uint64_t v35 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, v34);
          if (!v36)
          {
            __int16 v102 = 1283;
            BOOL v100 = "mps.add";
            uint64_t v101 = 7;
                              "hasn't been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#regi"
                              "stered-loaded-dependent-whats-up-with-dialects-management";
            __int16 v98 = 259;
            llvm::operator+(v99, v97, (uint64_t)v103);
            llvm::report_fatal_error((llvm::Twine *)v103, 1);
          }
          mlir::OperationState::OperationState(&__p, LocationForOp, v35);
          if (!*(_DWORD *)(v89 + 36) || !*((_DWORD *)v33 + 9)) {
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          }
          mlir::mps::ATan2Op::build(a3 + 18, (uint64_t)&__p, v89 - 16, (uint64_t)v33 - 16);
          uint64_t v37 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
          if (v37)
          {
            uint64_t v38 = llvm::DefaultDoCastIfPossible<mlir::mps::AddOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AddOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v37);
            if (v38)
            {
              mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
              if (!*(_DWORD *)(v38 + 36)) {
                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
              }
LABEL_59:
              uint64_t v96 = LocationForOp;
              uint64_t v48 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v96);
              uint64_t v49 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.softmax", (const unsigned __int8 *)0xB, v48);
              if (!v50)
              {
                __int16 v102 = 1283;
                BOOL v100 = "mps.softmax";
                uint64_t v101 = 11;
                                  "ion hasn't been added by the dialect. See also https://mlir.llvm.org/getting_started/F"
                                  "aq/#registered-loaded-dependent-whats-up-with-dialects-management";
                __int16 v98 = 259;
                llvm::operator+(v99, v97, (uint64_t)v103);
                llvm::report_fatal_error((llvm::Twine *)v103, 1);
              }
              mlir::OperationState::OperationState(&__p, LocationForOp, v49);
              if (!*((_DWORD *)v10 + 9)) {
                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
              }
              mlir::mps::SoftmaxOp::build((uint64_t)(a3 + 18), (uint64_t)&__p, v38 - 16, (uint64_t)v10 - 16);
              unint64_t v51 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
              if (v51)
              {
                uint64_t v52 = llvm::DefaultDoCastIfPossible<mlir::mps::SoftmaxOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SoftmaxOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v51);
                if (v52)
                {
                  mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
                  uint64_t v96 = LocationForOp;
                  int v53 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v96);
                  uint64_t v54 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.matmul", (const unsigned __int8 *)0xA, v53);
                  if (!v55)
                  {
                    __int16 v102 = 1283;
                    BOOL v100 = "mps.matmul";
                    uint64_t v101 = 10;
                                      "eration hasn't been added by the dialect. See also https://mlir.llvm.org/getting_s"
                                      "tarted/Faq/#registered-loaded-dependent-whats-up-with-dialects-management";
                    __int16 v98 = 259;
                    llvm::operator+(v99, v97, (uint64_t)v103);
                    llvm::report_fatal_error((llvm::Twine *)v103, 1);
                  }
                  mlir::OperationState::OperationState(&__p, LocationForOp, v54);
                  if (!*(_DWORD *)(v52 + 36)) {
                    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                  }
                  mlir::mps::MatMulOp::build(a3 + 18, (uint64_t)&__p, v52 - 16, v6, 0, 0);
                  int v56 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
                  if (v56)
                  {
                    uint64_t v57 = llvm::DefaultDoCastIfPossible<mlir::mps::MatMulOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MatMulOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v56);
                    if (v57)
                    {
                      mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
                      (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
                      if (!*(_DWORD *)(v57 + 36)) {
                        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                      }
                      uint64_t v58 = (long long *)__p;
                      int v59 = (char *)operator new(8uLL);
                      *(void *)int v59 = v57 - 16;
                      v103[0] = v58;
                      uint64_t v60 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v58, (uint64_t)&std::piecewise_construct, v103);
                      std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v60 + 5, v59, v59 + 8, 1uLL);
                      operator delete(v59);
                      char v61 = (void **)__p;
                      if (__p)
                      {
                        unint64_t v62 = (void **)v105;
                        uint64_t v63 = __p;
                        if ((void *)v105 != __p)
                        {
                          do
                          {
                            if (*((char *)v62 - 1) < 0) {
                              operator delete(*(v62 - 3));
                            }
                            v62 -= 3;
                          }
                          while (v62 != v61);
                          uint64_t v63 = __p;
                        }
                        *(void *)&long long v105 = v61;
                        operator delete(v63);
                      }
                      return 1;
                    }
                    uint64_t v76 = "result && \"builder didn't return the right type\"";
                    int v77 = 497;
                    uint64_t v78 = "Builders.h";
                    uint64_t v79 = "create";
                  }
                  else
                  {
                    uint64_t v76 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
                    int v77 = 662;
                    uint64_t v78 = "Casting.h";
                    uint64_t v79 = "dyn_cast";
                  }
                  __assert_rtn(v79, v78, v77, v76);
                }
                uint64_t v72 = "result && \"builder didn't return the right type\"";
                int v73 = 497;
                int v74 = "Builders.h";
                int v75 = "create";
              }
              else
              {
                uint64_t v72 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
                int v73 = 662;
                int v74 = "Casting.h";
                int v75 = "dyn_cast";
              }
              __assert_rtn(v75, v74, v73, v72);
            }
            uint64_t v80 = "result && \"builder didn't return the right type\"";
            int v81 = 497;
            uint64_t v82 = "Builders.h";
            __int16 v83 = "create";
          }
          else
          {
            uint64_t v80 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
            int v81 = 662;
            uint64_t v82 = "Casting.h";
            __int16 v83 = "dyn_cast";
          }
          __assert_rtn(v83, v82, v81, v80);
        }
        uint64_t v88 = mlir::getElementTypeOrSelf((void *)(*(void *)(OptionalArgValue + 8) & 0xFFFFFFFFFFFFFFF8));
        if (ElementTypeOrSelf == v88)
        {
LABEL_58:
          uint64_t v38 = (uint64_t)mlir::OpBuilder::create<mlir::mps::AddOp,mlir::mps::MultiplyOp &,mlir::Value>(a3 + 18, LocationForOp, &v89, &OptionalArgValue);
          if (!*(_DWORD *)(v38 + 36)) {
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          }
          goto LABEL_59;
        }
        if (mlir::Type::isInteger((mlir::Type *)&v88, 1))
        {
          if (mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf))
          {
            __p = (void *)1;
            int v29 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&__p, 1, ElementTypeOrSelf, 0);
            __p = (void *)mlir::mps::getConstantAttr<double>(v29, -40000.0);
            __int16 v30 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)&__p);
            if (!*((_DWORD *)v30 + 9)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
          }
          else if (mlir::Type::isF32((mlir::Type *)&ElementTypeOrSelf))
          {
            __int16 v30 = mlir::mps::getConstant<int,float>((mlir::OpBuilder *)(a3 + 18), LocationForOp, ElementTypeOrSelf);
            if (!*((_DWORD *)v30 + 9)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
          }
          else if (mlir::Type::isBF16((mlir::Type *)&ElementTypeOrSelf))
          {
            __int16 v30 = mlir::mps::getConstant<int,double>((mlir::OpBuilder *)(a3 + 18), LocationForOp, ElementTypeOrSelf, -3.4e38);
            if (!*((_DWORD *)v30 + 9)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
          }
          else
          {
            __int16 v30 = mlir::mps::getConstant<int,double>((mlir::OpBuilder *)(a3 + 18), LocationForOp, ElementTypeOrSelf, -40000.0);
            if (!*((_DWORD *)v30 + 9)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
          }
          __p = (void *)1;
          unint64_t v41 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&__p, 1, ElementTypeOrSelf, 0);
          __p = (void *)mlir::mps::getConstantAttr<float>(v41, 0.0);
          __int16 v42 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)&__p);
          uint64_t v96 = LocationForOp;
          uint64_t v43 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v96);
          uint64_t v44 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.select", (const unsigned __int8 *)0xA, v43);
          if (!v45)
          {
            __int16 v102 = 1283;
            BOOL v100 = "mps.select";
            uint64_t v101 = 10;
                              "hasn't been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#regi"
                              "stered-loaded-dependent-whats-up-with-dialects-management";
            __int16 v98 = 259;
            llvm::operator+(v99, v97, (uint64_t)v103);
            llvm::report_fatal_error((llvm::Twine *)v103, 1);
          }
          mlir::OperationState::OperationState(&__p, LocationForOp, v44);
          if (!*((_DWORD *)v42 + 9)) {
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          }
          mlir::mps::SelectOp::build((uint64_t)(a3 + 18), (uint64_t)&__p, OptionalArgValue, (uint64_t)v42 - 16, (uint64_t)v30 - 16);
          unint64_t v46 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
          if (v46)
          {
            uint64_t v47 = llvm::DefaultDoCastIfPossible<mlir::mps::SelectOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SelectOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v46);
            if (v47)
            {
              mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
              if (!*(_DWORD *)(v47 + 36)) {
                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
              }
              uint64_t v40 = v47 - 16;
LABEL_57:
              OptionalArguint64_t Value = v40;
              goto LABEL_58;
            }
            uint64_t v84 = "result && \"builder didn't return the right type\"";
            int v85 = 497;
            uint64_t v86 = "Builders.h";
            char v87 = "create";
          }
          else
          {
            uint64_t v84 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
            int v85 = 662;
            uint64_t v86 = "Casting.h";
            char v87 = "dyn_cast";
          }
          __assert_rtn(v87, v86, v85, v84);
        }
        unint64_t v39 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a3 + 18, LocationForOp, &OptionalArgValue, &ElementTypeOrSelf);
        if (!*((_DWORD *)v39 + 9)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        uint64_t v40 = (uint64_t)v39 - 16;
        goto LABEL_57;
      }
      uint64_t v68 = "result && \"builder didn't return the right type\"";
      int v69 = 497;
      uint64_t v70 = "Builders.h";
      unint64_t v71 = "create";
    }
    else
    {
      uint64_t v68 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v69 = 662;
      uint64_t v70 = "Casting.h";
      unint64_t v71 = "dyn_cast";
    }
    __assert_rtn(v71, v70, v69, v68);
  }
  __p = operator new(0x40uLL);
  long long v105 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
LABEL_31:
  if (SHIBYTE(v105) < 0) {
    operator delete(__p);
  }
  return 0;
}

void sub_180D5271C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a39 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ReciprocalSquareRootOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reciprocal_square_root", (const unsigned __int8 *)0x1A, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.reciprocal_square_root";
    v19[3] = 26;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    char v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    char v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::ReciprocalSquareRootOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReciprocalSquareRootOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    char v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    char v14 = "Builders.h";
    int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180D529DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D529F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value &,mlir::Value &,BOOL,BOOL>(mlir::BoolAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned __int8 *a5, unsigned __int8 *a6)
{
  v28[38] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.matmul", (const unsigned __int8 *)0xA, Context);
  if (!v14)
  {
    __int16 v26 = 1283;
    v25[2] = (uint64_t)"mps.matmul";
    v25[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v28, a2, v13);
  mlir::mps::MatMulOp::build(a1, (uint64_t)v28, *a3, *a4, (mlir::MLIRContext *)*a5, (mlir::MLIRContext *)*a6);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v28);
  if (!v15)
  {
    __int16 v18 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v19 = 662;
    __int16 v20 = "Casting.h";
    uint64_t v21 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v16 = llvm::DefaultDoCastIfPossible<mlir::mps::MatMulOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MatMulOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
  if (!v16)
  {
    __int16 v18 = "result && \"builder didn't return the right type\"";
    int v19 = 497;
    __int16 v20 = "Builders.h";
    uint64_t v21 = "create";
LABEL_8:
    __assert_rtn(v21, v20, v19, v18);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v28);
  return v16;
}

void sub_180D52B9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D52BB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void MILToMLIR::ConvolutionPattern::~ConvolutionPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::PadPattern::~PadPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::CropPattern::~CropPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::UpsampleBilinearPattern::~UpsampleBilinearPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::ResizePattern::~ResizePattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::UpsampleNearestNeighborPattern::~UpsampleNearestNeighborPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::SplitPattern::~SplitPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::StackPattern::~StackPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::InversePattern::~InversePattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::LogarithmPattern::~LogarithmPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::RsqrtPattern::~RsqrtPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::Range1dPattern::~Range1dPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::RandomPattern::~RandomPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::ReversePattern::~ReversePattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::Flatten2DPattern::~Flatten2DPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::TopKPattern::~TopKPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::CropResizePattern::~CropResizePattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::ConstExpressionPattern::~ConstExpressionPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::ReshapeLikePattern::~ReshapeLikePattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::QuantizePattern::~QuantizePattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::TensorBufferPattern::~TensorBufferPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::ResamplePattern::~ResamplePattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::ArgSortPattern::~ArgSortPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::ReadStatePattern::~ReadStatePattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::WriteStatePattern::~WriteStatePattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::SDPAPattern::~SDPAPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t mlir::DenseIntElementsAttr::get<int>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a4) {
    a3 = 0;
  }
  uint64_t v4 = mlir::DenseElementsAttr::getFromRawBuffer(a1, a2, a3, 4 * a4, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof(v4) & 1) == 0) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  return v4;
}

uint64_t mlir::OpBuilder::create<mlir::mps::DepthwiseConv3DOp,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle &,int &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, unsigned int *a8, int *a9)
{
  v33[38] = *MEMORY[0x1E4F143B8];
  uint64_t v27 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v27);
  uint64_t v18 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_3d", (const unsigned __int8 *)0x15, Context);
  if (!v19)
  {
    __int16 v31 = 1283;
    v30[2] = (uint64_t)"mps.depthwise_conv_3d";
    v30[3] = 21;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v29 = 259;
    llvm::operator+(v30, (uint64_t *)&v28, (uint64_t)v32);
    llvm::report_fatal_error((llvm::Twine *)v32, 1);
  }
  mlir::OperationState::OperationState(v33, a2, v18);
  mlir::mps::DepthwiseConv3DOp::build(a1, (uint64_t)v33, *a3, *a4, *a5, *a6, *a7, *a8, *a9);
  __int16 v20 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v33);
  if (!v20)
  {
    uint64_t v23 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v24 = 662;
    uint64_t v25 = "Casting.h";
    __int16 v26 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v21 = llvm::DefaultDoCastIfPossible<mlir::mps::DepthwiseConv3DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DepthwiseConv3DOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v20);
  if (!v21)
  {
    uint64_t v23 = "result && \"builder didn't return the right type\"";
    int v24 = 497;
    uint64_t v25 = "Builders.h";
    __int16 v26 = "create";
LABEL_8:
    __assert_rtn(v26, v25, v24, v23);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v33);
  return v21;
}

void sub_180D54310(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D54328(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t MILToMLIR::arrayToU64Attr(MILToMLIR *this, mlir::OpBuilder *a2, int *a3)
{
  v22[6] = *MEMORY[0x1E4F143B8];
  uint64_t IntegerType = mlir::Builder::getIntegerType(this, 0x40u, 0);
  uint64_t v6 = operator new(8uLL);
  *uint64_t v6 = a3;
  uint64_t v7 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)v6, 1, IntegerType, 0);
  unint64_t v8 = 0;
  __int16 v20 = v22;
  uint64_t v21 = 0x600000000;
  unint64_t v9 = 6;
  do
  {
    uint64_t v11 = *(int *)a2;
    a2 = (mlir::OpBuilder *)((char *)a2 + 4);
    uint64_t v10 = v11;
    if (v8 >= v9)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v20, v22, v8 + 1, 8);
      *((void *)v20 + v21) = v10;
      uint64_t v12 = v21;
      unint64_t v9 = HIDWORD(v21);
      if (v21 >= (unint64_t)HIDWORD(v21)) {
LABEL_7:
      }
        __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
    }
    else
    {
      *((void *)v20 + v8) = v10;
      uint64_t v12 = v21;
      unint64_t v9 = HIDWORD(v21);
      if (v21 >= (unint64_t)HIDWORD(v21)) {
        goto LABEL_7;
      }
    }
    unint64_t v8 = v12 + 1;
    LODWORD(v21) = v8;
    a3 = (int *)((char *)a3 - 1);
  }
  while (a3);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v7)) {
    goto LABEL_17;
  }
  if (v7)
  {
    uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v7);
    if (!InterfaceFor)
    {
      char v14 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v15 = 98;
      uint64_t v16 = "InterfaceSupport.h";
      uint64_t v17 = "Interface";
      goto LABEL_18;
    }
  }
  else
  {
    uint64_t InterfaceFor = 0;
  }
  uint64_t v18 = mlir::DenseElementsAttr::getFromRawBuffer(v7, InterfaceFor, v20, 8 * v21, 8, 1, 0);
  if ((mlir::DenseIntElementsAttr::classof(v18) & 1) == 0)
  {
LABEL_17:
    char v14 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v15 = 566;
    uint64_t v16 = "Casting.h";
    uint64_t v17 = "cast";
LABEL_18:
    __assert_rtn(v17, v16, v15, v14);
  }
  if (v20 != v22) {
    free(v20);
  }
  operator delete(v6);
  return v18;
}

void sub_180D5452C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  if (a10 != v11) {
    free(a10);
  }
  operator delete(v10);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::Conv2DOp,mlir::Value &,mlir::Value &,int &,int &,int &,int &,int &,int &,int &,int &,int &,mlir::mps::PaddingStyle &,mlir::mps::TensorDataLayout &,mlir::mps::TensorDataLayout &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, int *a5, int *a6, int *a7, int *a8, int *a9, int *a10, int *a11, int *a12, int *a13, unsigned int *a14, unsigned int *a15, unsigned int *a16)
{
  v40[38] = *MEMORY[0x1E4F143B8];
  uint64_t v34 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v34);
  uint64_t v25 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_2d", (const unsigned __int8 *)0xB, Context);
  if (!v26)
  {
    __int16 v38 = 1283;
    v37[2] = (uint64_t)"mps.conv_2d";
    v37[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v36 = 259;
    llvm::operator+(v37, (uint64_t *)&v35, (uint64_t)v39);
    llvm::report_fatal_error((llvm::Twine *)v39, 1);
  }
  mlir::OperationState::OperationState(v40, a2, v25);
  mlir::mps::Conv2DOp::build(a1, (uint64_t)v40, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, *a11, *a12, *a13, *a14, *a15, *a16);
  uint64_t v27 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v40);
  if (!v27)
  {
    __int16 v30 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v31 = 662;
    int v32 = "Casting.h";
    long long v33 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v28 = llvm::DefaultDoCastIfPossible<mlir::mps::Conv2DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::Conv2DOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v27);
  if (!v28)
  {
    __int16 v30 = "result && \"builder didn't return the right type\"";
    int v31 = 497;
    int v32 = "Builders.h";
    long long v33 = "create";
LABEL_8:
    __assert_rtn(v33, v32, v31, v30);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v40);
  return v28;
}

void sub_180D5475C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
}

void sub_180D54774(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::BiasAddOp,mlir::Value &,mlir::Value &,mlir::mps::TensorDataLayout>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, int *a5)
{
  v26[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.bias_add", (const unsigned __int8 *)0xC, Context);
  if (!v12)
  {
    __int16 v24 = 1283;
    v23[2] = (uint64_t)"mps.bias_add";
    v23[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v11);
  mlir::mps::BiasAddOp::build(a1, (uint64_t)v26, *a3, *a4, *a5);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v26);
  if (!v13)
  {
    uint64_t v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v17 = 662;
    uint64_t v18 = "Casting.h";
    char v19 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v14 = llvm::DefaultDoCastIfPossible<mlir::mps::BiasAddOp,mlir::Operation *,llvm::CastInfo<mlir::mps::BiasAddOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    uint64_t v16 = "result && \"builder didn't return the right type\"";
    int v17 = 497;
    uint64_t v18 = "Builders.h";
    char v19 = "create";
LABEL_8:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v14;
}

void sub_180D54914(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D5492C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void *llvm::SmallVector<int,4u>::SmallVector(void *a1, unsigned char *a2, uint64_t a3)
{
  *a1 = a1 + 2;
  a1[1] = 0x400000000;
  llvm::SmallVectorImpl<int>::append<int const*,void>((uint64_t)a1, a2, &a2[4 * a3]);
  return a1;
}

void sub_180D54980(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v2;
  if (*v1 != v3) {
    free(*v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::DenseIntElementsAttr::get<llvm::SmallVector<int,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v4 = mlir::DenseElementsAttr::getFromRawBuffer(a1, a2, a3, 4 * a4, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof(v4) & 1) == 0) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  return v4;
}

uint64_t mlir::OpBuilder::create<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle &,int &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, unsigned int *a9, int *a10)
{
  v34[38] = *MEMORY[0x1E4F143B8];
  uint64_t v28 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v28);
  uint64_t v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_3d_data_gradient", (const unsigned __int8 *)0x23, Context);
  if (!v20)
  {
    __int16 v32 = 1283;
    v31[2] = (uint64_t)"mps.depthwise_conv_3d_data_gradient";
    v31[3] = 35;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v30 = 259;
    llvm::operator+(v31, (uint64_t *)&v29, (uint64_t)v33);
    llvm::report_fatal_error((llvm::Twine *)v33, 1);
  }
  mlir::OperationState::OperationState(v34, a2, v19);
  mlir::mps::DepthwiseConv3DDataGradientOp::build(a1, (uint64_t)v34, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10);
  uint64_t v21 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v34);
  if (!v21)
  {
    __int16 v24 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v25 = 662;
    char v26 = "Casting.h";
    uint64_t v27 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v22 = llvm::DefaultDoCastIfPossible<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v21);
  if (!v22)
  {
    __int16 v24 = "result && \"builder didn't return the right type\"";
    int v25 = 497;
    char v26 = "Builders.h";
    uint64_t v27 = "create";
LABEL_8:
    __assert_rtn(v27, v26, v25, v24);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v34);
  return v22;
}

void sub_180D54BBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D54BD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::Conv2DDataGradientOp,mlir::Value &,mlir::Value &,mlir::Value &,int &,int &,int &,int &,int &,int &,int &,int &,int &,mlir::mps::PaddingStyle &,mlir::mps::TensorDataLayout &,mlir::mps::TensorDataLayout &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, int *a6, int *a7, int *a8, int *a9, int *a10, int *a11, int *a12, int *a13, int *a14, unsigned int *a15, unsigned int *a16, unsigned int *a17)
{
  v41[38] = *MEMORY[0x1E4F143B8];
  uint64_t v35 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v35);
  uint64_t v26 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_2d_data_gradient", (const unsigned __int8 *)0x19, Context);
  if (!v27)
  {
    __int16 v39 = 1283;
    v38[2] = (uint64_t)"mps.conv_2d_data_gradient";
    v38[3] = 25;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v37 = 259;
    llvm::operator+(v38, (uint64_t *)&v36, (uint64_t)v40);
    llvm::report_fatal_error((llvm::Twine *)v40, 1);
  }
  mlir::OperationState::OperationState(v41, a2, v26);
  mlir::mps::Conv2DDataGradientOp::build(a1, (uint64_t)v41, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, *a11, *a12, *a13, *a14, *a15, *a16, *a17);
  uint64_t v28 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v41);
  if (!v28)
  {
    int v31 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v32 = 662;
    long long v33 = "Casting.h";
    uint64_t v34 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v29 = llvm::DefaultDoCastIfPossible<mlir::mps::Conv2DDataGradientOp,mlir::Operation *,llvm::CastInfo<mlir::mps::Conv2DDataGradientOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v28);
  if (!v29)
  {
    int v31 = "result && \"builder didn't return the right type\"";
    int v32 = 497;
    long long v33 = "Builders.h";
    uint64_t v34 = "create";
LABEL_8:
    __assert_rtn(v34, v33, v32, v31);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v41);
  return v29;
}

void sub_180D54DE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
}

void sub_180D54DF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
}

void *llvm::SmallVector<int,1u>::SmallVector(void *a1, unsigned char *a2, uint64_t a3)
{
  *a1 = a1 + 2;
  a1[1] = 0x100000000;
  llvm::SmallVectorImpl<int>::append<int const*,void>((uint64_t)a1, a2, &a2[4 * a3]);
  return a1;
}

void sub_180D54E4C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v2;
  if (*v1 != v3) {
    free(*v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::DepthwiseConv3DOp,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, unsigned int *a8)
{
  v32[38] = *MEMORY[0x1E4F143B8];
  uint64_t v26 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v26);
  uint64_t v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_3d", (const unsigned __int8 *)0x15, Context);
  if (!v18)
  {
    __int16 v30 = 1283;
    v29[2] = (uint64_t)"mps.depthwise_conv_3d";
    v29[3] = 21;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v28 = 259;
    llvm::operator+(v29, (uint64_t *)&v27, (uint64_t)v31);
    llvm::report_fatal_error((llvm::Twine *)v31, 1);
  }
  mlir::OperationState::OperationState(v32, a2, v17);
  mlir::mps::DepthwiseConv3DOp::build(a1, (uint64_t)v32, *a3, *a4, *a5, *a6, *a7, *a8, -4);
  uint64_t v19 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v32);
  if (!v19)
  {
    uint64_t v22 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v23 = 662;
    __int16 v24 = "Casting.h";
    int v25 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v20 = llvm::DefaultDoCastIfPossible<mlir::mps::DepthwiseConv3DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DepthwiseConv3DOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v19);
  if (!v20)
  {
    uint64_t v22 = "result && \"builder didn't return the right type\"";
    int v23 = 497;
    __int16 v24 = "Builders.h";
    int v25 = "create";
LABEL_8:
    __assert_rtn(v25, v24, v23, v22);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v32);
  return v20;
}

void sub_180D55020(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D55038(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void *llvm::SmallVector<int,5u>::SmallVector(void *a1, unsigned char *a2, uint64_t a3)
{
  *a1 = a1 + 2;
  a1[1] = 0x500000000;
  llvm::SmallVectorImpl<int>::append<int const*,void>((uint64_t)a1, a2, &a2[4 * a3]);
  return a1;
}

void sub_180D5508C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v2;
  if (*v1 != v3) {
    free(*v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, unsigned int *a9)
{
  v33[38] = *MEMORY[0x1E4F143B8];
  uint64_t v27 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v27);
  uint64_t v18 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_3d_data_gradient", (const unsigned __int8 *)0x23, Context);
  if (!v19)
  {
    __int16 v31 = 1283;
    v30[2] = (uint64_t)"mps.depthwise_conv_3d_data_gradient";
    v30[3] = 35;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v29 = 259;
    llvm::operator+(v30, (uint64_t *)&v28, (uint64_t)v32);
    llvm::report_fatal_error((llvm::Twine *)v32, 1);
  }
  mlir::OperationState::OperationState(v33, a2, v18);
  mlir::mps::DepthwiseConv3DDataGradientOp::build(a1, (uint64_t)v33, *a3, *a4, *a5, *a6, *a7, *a8, *a9, -4);
  uint64_t v20 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v33);
  if (!v20)
  {
    int v23 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v24 = 662;
    int v25 = "Casting.h";
    uint64_t v26 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v21 = llvm::DefaultDoCastIfPossible<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v20);
  if (!v21)
  {
    int v23 = "result && \"builder didn't return the right type\"";
    int v24 = 497;
    int v25 = "Builders.h";
    uint64_t v26 = "create";
LABEL_8:
    __assert_rtn(v26, v25, v24, v23);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v33);
  return v21;
}

void sub_180D55268(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D55280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int,long long &>(mlir::mps::ConstantOp *a1, uint64_t a2, uint64_t *a3, unsigned int *a4, unsigned int *a5)
{
  v26[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.transpose", (const unsigned __int8 *)0xD, Context);
  if (!v12)
  {
    __int16 v24 = 1283;
    v23[2] = (uint64_t)"mps.transpose";
    v23[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v11);
  mlir::mps::TransposeOp::build(a1, v26, *a3, *a4, *a5);
  uint64_t v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v26);
  if (!v13)
  {
    uint64_t v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v17 = 662;
    uint64_t v18 = "Casting.h";
    char v19 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v14 = llvm::DefaultDoCastIfPossible<mlir::mps::TransposeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TransposeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    uint64_t v16 = "result && \"builder didn't return the right type\"";
    int v17 = 497;
    uint64_t v18 = "Builders.h";
    char v19 = "create";
LABEL_8:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v14;
}

void sub_180D55420(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D55438(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

char *llvm::SmallVectorImpl<int>::erase(uint64_t a1, char *__dst)
{
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  unint64_t v3 = *(void *)a1 + 4 * v2;
  if (*(void *)a1 > (unint64_t)__dst || v3 <= (unint64_t)__dst) {
    __assert_rtn("erase", "SmallVector.h", 745, "this->isReferenceToStorage(CI) && \"Iterator to erase is out of bounds.\"");
  }
  uint64_t v7 = __dst + 4;
  if ((char *)v3 != v7)
  {
    memmove(__dst, v7, v3 - (void)v7);
    uint64_t v2 = *(unsigned int *)(a1 + 8);
  }
  unint64_t v8 = v2 - 1;
  if (v8 > *(unsigned int *)(a1 + 12)) {
    __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
  }
  *(_DWORD *)(a1 + 8) = v8;
  return __dst;
}

uint64_t mlir::OpBuilder::create<mlir::mps::Conv2DOp,mlir::Value &,mlir::Value &,int &,unsigned long &,unsigned long &,unsigned long &,unsigned long &,unsigned long &,unsigned long &,unsigned long &,unsigned long &,mlir::mps::PaddingStyle &,mlir::mps::TensorDataLayout &,mlir::mps::TensorDataLayout &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, int *a5, unint64_t *a6, unint64_t *a7, uint64_t *a8, uint64_t *a9, unint64_t *a10, unint64_t *a11, unint64_t *a12, unint64_t *a13, unsigned int *a14, unsigned int *a15, unsigned int *a16)
{
  v40[38] = *MEMORY[0x1E4F143B8];
  uint64_t v34 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v34);
  uint64_t v25 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_2d", (const unsigned __int8 *)0xB, Context);
  if (!v26)
  {
    __int16 v38 = 1283;
    v37[2] = (uint64_t)"mps.conv_2d";
    v37[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v36 = 259;
    llvm::operator+(v37, (uint64_t *)&v35, (uint64_t)v39);
    llvm::report_fatal_error((llvm::Twine *)v39, 1);
  }
  mlir::OperationState::OperationState(v40, a2, v25);
  mlir::mps::Conv2DOp::build(a1, (uint64_t)v40, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, *a11, *a12, *a13, *a14, *a15, *a16);
  uint64_t v27 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v40);
  if (!v27)
  {
    __int16 v30 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v31 = 662;
    int v32 = "Casting.h";
    long long v33 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v28 = llvm::DefaultDoCastIfPossible<mlir::mps::Conv2DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::Conv2DOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v27);
  if (!v28)
  {
    __int16 v30 = "result && \"builder didn't return the right type\"";
    int v31 = 497;
    int v32 = "Builders.h";
    long long v33 = "create";
LABEL_8:
    __assert_rtn(v33, v32, v31, v30);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v40);
  return v28;
}

void sub_180D556E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
}

void sub_180D55700(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
}

uint64_t mlir::Type::dyn_cast_or_null<mlir::TensorType>(uint64_t result)
{
  if (result)
  {
    if (!*(void *)result) {
      __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
    }
    uint64_t v1 = *(void **)(*(void *)result + 136);
    if (v1 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id
      && v1 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
      return 0;
    }
  }
  return result;
}

void *std::vector<unsigned long long>::vector[abi:ne180100](void *a1, const void *a2, unint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3)
  {
    if (a3 >> 61) {
      std::vector<long>::__throw_length_error[abi:ne180100]();
    }
    size_t v5 = 8 * a3;
    uint64_t v6 = (char *)operator new(8 * a3);
    *a1 = v6;
    a1[1] = v6;
    uint64_t v7 = &v6[v5];
    a1[2] = &v6[v5];
    memmove(v6, a2, v5);
    a1[1] = v7;
  }
  return a1;
}

void sub_180D557EC(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::Conv3DOp,mlir::Value &,mlir::Value &,int &,std::vector<unsigned long long> &,std::vector<unsigned long long> &,std::vector<unsigned long long> &,mlir::mps::PaddingStyle &,mlir::mps::TensorDataLayout &,mlir::mps::TensorDataLayout &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int *a9, unsigned int *a10, unsigned int *a11)
{
  v36[38] = *MEMORY[0x1E4F143B8];
  uint64_t v30 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v30);
  uint64_t v20 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_3d", (const unsigned __int8 *)0xB, Context);
  if (!v21)
  {
    __int16 v34 = 1283;
    v33[2] = (uint64_t)"mps.conv_3d";
    v33[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v32 = 259;
    llvm::operator+(v33, (uint64_t *)&v31, (uint64_t)v35);
    llvm::report_fatal_error((llvm::Twine *)v35, 1);
  }
  mlir::OperationState::OperationState(v36, a2, v20);
  mlir::mps::Conv3DOp::build(a1, (uint64_t)v36, *a3, *a4, *a5, *(uint64_t **)a6, (uint64_t)(*(void *)(a6 + 8) - *(void *)a6) >> 3, v22, *(uint64_t **)a7, (uint64_t)(*(void *)(a7 + 8) - *(void *)a7) >> 3, *(uint64_t **)a8, (uint64_t)(*(void *)(a8 + 8) - *(void *)a8) >> 3, *a9, *a10, *a11);
  int v23 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v36);
  if (!v23)
  {
    char v26 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v27 = 662;
    uint64_t v28 = "Casting.h";
    __int16 v29 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v24 = llvm::DefaultDoCastIfPossible<mlir::mps::Conv3DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::Conv3DOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v23);
  if (!v24)
  {
    char v26 = "result && \"builder didn't return the right type\"";
    int v27 = 497;
    uint64_t v28 = "Builders.h";
    __int16 v29 = "create";
LABEL_8:
    __assert_rtn(v29, v28, v27, v26);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v36);
  return v24;
}

void sub_180D559F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
}

void sub_180D55A08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::Conv3DDataGradientOp,mlir::Value &,mlir::Value &,mlir::Value &,int &,std::vector<unsigned long long> &,std::vector<unsigned long long> &,std::vector<unsigned long long> &,mlir::mps::PaddingStyle &,mlir::mps::TensorDataLayout &,mlir::mps::TensorDataLayout &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, int *a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int *a10, unsigned int *a11, unsigned int *a12)
{
  v36[38] = *MEMORY[0x1E4F143B8];
  uint64_t v30 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v30);
  uint64_t v21 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_3d_data_gradient", (const unsigned __int8 *)0x19, Context);
  if (!v22)
  {
    __int16 v34 = 1283;
    v33[2] = (uint64_t)"mps.conv_3d_data_gradient";
    v33[3] = 25;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v32 = 259;
    llvm::operator+(v33, (uint64_t *)&v31, (uint64_t)v35);
    llvm::report_fatal_error((llvm::Twine *)v35, 1);
  }
  mlir::OperationState::OperationState(v36, a2, v21);
  mlir::mps::Conv3DDataGradientOp::build(a1, (uint64_t)v36, *a3, *a4, *a5, *a6, *(uint64_t **)a7, (uint64_t)(*(void *)(a7 + 8) - *(void *)a7) >> 3, *(uint64_t **)a8, (uint64_t)(*(void *)(a8 + 8) - *(void *)a8) >> 3, *(uint64_t **)a9, (uint64_t)(*(void *)(a9 + 8) - *(void *)a9) >> 3, *a10, *a11, *a12);
  int v23 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v36);
  if (!v23)
  {
    char v26 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v27 = 662;
    uint64_t v28 = "Casting.h";
    __int16 v29 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v24 = llvm::DefaultDoCastIfPossible<mlir::mps::Conv3DDataGradientOp,mlir::Operation *,llvm::CastInfo<mlir::mps::Conv3DDataGradientOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v23);
  if (!v24)
  {
    char v26 = "result && \"builder didn't return the right type\"";
    int v27 = 497;
    uint64_t v28 = "Builders.h";
    __int16 v29 = "create";
LABEL_8:
    __assert_rtn(v29, v28, v27, v26);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v36);
  return v24;
}

void sub_180D55C08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
}

void sub_180D55C20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::DepthwiseConv3DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DepthwiseConv3DOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 21
      && *AttrData == 0x747065642E73706DLL
      && AttrData[1] == 0x6F635F6573697768
      && *(void *)((char *)AttrData + 13) == 0x64335F766E6F635FLL)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.depthwise_conv_3d";
      v9[3] = 21;
      uint64_t v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::Conv2DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::Conv2DOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x766E6F632E73706DLL && *(void *)((char *)AttrData + 3) == 0x64325F766E6F632ELL)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.conv_2d";
      v8[3] = 11;
      uint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::BiasAddOp,mlir::Operation *,llvm::CastInfo<mlir::mps::BiasAddOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 12 && *(void *)AttrData == 0x736169622E73706DLL && *(_DWORD *)(AttrData + 8) == 1684300127)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.bias_add";
      v8[3] = 12;
      uint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::BiasAddOp,void>::id)
  {
    return 0;
  }
  return result;
}

void llvm::SmallVectorImpl<int>::append<int const*,void>(uint64_t a1, unsigned char *__src, unsigned char *a3)
{
  if (__src == a3)
  {
    uint64_t v7 = 0;
    size_t v6 = 0;
    unint64_t v9 = *(unsigned int *)(a1 + 8);
    LODWORD(v8) = *(_DWORD *)(a1 + 8);
    goto LABEL_12;
  }
  size_t v6 = a3 - __src;
  uint64_t v7 = (a3 - __src) >> 2;
  unint64_t v8 = *(unsigned int *)(a1 + 8);
  unint64_t v9 = v7 + v8;
  unint64_t v10 = *(void *)a1;
  unint64_t v11 = *(void *)a1 + 4 * v8;
  if (*(void *)a1 <= (unint64_t)__src && v11 > (unint64_t)__src)
  {
    if (v9 <= v8)
    {
      if (v10 + 4 * v9 <= (unint64_t)__src) {
        goto LABEL_25;
      }
    }
    else if (v9 > *(unsigned int *)(a1 + 12))
    {
      goto LABEL_25;
    }
  }
  unint64_t v13 = (unint64_t)(a3 - 4);
  if (v10 <= (unint64_t)(a3 - 4) && v11 > v13)
  {
    if (v9 > v8)
    {
      if (v9 <= *(unsigned int *)(a1 + 12)) {
        goto LABEL_12;
      }
LABEL_25:
      __assert_rtn("assertSafeToReferenceAfterResize", "SmallVector.h", 194, "isSafeToReferenceAfterResize(Elt, NewSize) && \"Attempting to reference an element of the vector in an operation \" \"that invalidates it\"");
    }
    if (v10 + 4 * v9 <= v13) {
      goto LABEL_25;
    }
  }
LABEL_12:
  if (v9 > *(unsigned int *)(a1 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v9, 4);
    LODWORD(v8) = *(_DWORD *)(a1 + 8);
  }
  if (__src != a3)
  {
    memcpy((void *)(*(void *)a1 + 4 * v8), __src, v6);
    LODWORD(v8) = *(_DWORD *)(a1 + 8);
  }
  unint64_t v14 = v7 + v8;
  if (v14 > *(unsigned int *)(a1 + 12)) {
    __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
  }
  *(_DWORD *)(a1 + 8) = v14;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v13[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v13);
    if (v4 == 35
      && *AttrData == 0x747065642E73706DLL
      && AttrData[1] == 0x6F635F6573697768
      && AttrData[2] == 0x61645F64335F766ELL
      && AttrData[3] == 0x69646172675F6174
      && *(void *)((char *)AttrData + 27) == 0x746E656964617267)
    {
      __int16 v12 = 1283;
      v11[0] = (uint64_t)"classof on '";
      v11[2] = (uint64_t)"mps.depthwise_conv_3d_data_gradient";
      v11[3] = 35;
      unint64_t v9 = "' failed due to the operation not being registered";
      __int16 v10 = 259;
      llvm::operator+(v11, (uint64_t *)&v9, (uint64_t)v13);
      llvm::report_fatal_error((llvm::Twine *)v13, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::Conv2DDataGradientOp,mlir::Operation *,llvm::CastInfo<mlir::mps::Conv2DDataGradientOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v12[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v12);
    if (v4 == 25
      && *(void *)AttrData == 0x766E6F632E73706DLL
      && *(void *)(AttrData + 8) == 0x617461645F64325FLL
      && *(void *)(AttrData + 16) == 0x6E6569646172675FLL
      && *(unsigned char *)(AttrData + 24) == 116)
    {
      __int16 v11 = 1283;
      v10[0] = (uint64_t)"classof on '";
      v10[2] = (uint64_t)"mps.conv_2d_data_gradient";
      v10[3] = 25;
      unint64_t v8 = "' failed due to the operation not being registered";
      __int16 v9 = 259;
      llvm::operator+(v10, (uint64_t *)&v8, (uint64_t)v12);
      llvm::report_fatal_error((llvm::Twine *)v12, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::Conv3DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::Conv3DOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x766E6F632E73706DLL && *(void *)((char *)AttrData + 3) == 0x64335F766E6F632ELL)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.conv_3d";
      v8[3] = 11;
      size_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::Conv3DDataGradientOp,mlir::Operation *,llvm::CastInfo<mlir::mps::Conv3DDataGradientOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v12[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v12);
    if (v4 == 25
      && *(void *)AttrData == 0x766E6F632E73706DLL
      && *(void *)(AttrData + 8) == 0x617461645F64335FLL
      && *(void *)(AttrData + 16) == 0x6E6569646172675FLL
      && *(unsigned char *)(AttrData + 24) == 116)
    {
      __int16 v11 = 1283;
      v10[0] = (uint64_t)"classof on '";
      v10[2] = (uint64_t)"mps.conv_3d_data_gradient";
      v10[3] = 25;
      unint64_t v8 = "' failed due to the operation not being registered";
      __int16 v9 = 259;
      llvm::operator+(v10, (uint64_t *)&v8, (uint64_t)v12);
      llvm::report_fatal_error((llvm::Twine *)v12, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id)
  {
    return 0;
  }
  return result;
}

llvm::APFloatBase *std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100](llvm::APFloatBase *result)
{
  uint64_t v1 = *(void *)result;
  *(void *)result = 0;
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      unint64_t v3 = llvm::APFloatBase::PPCDoubleDouble(result);
      uint64_t v4 = 32 * v2;
      do
      {
        while (v3 == *(void **)(v1 + v4 - 24))
        {
          std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100](v1 + v4 - 16, 0);
          v4 -= 32;
          if (!v4) {
            goto LABEL_7;
          }
        }
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)(v1 + v4 - 24));
        v4 -= 32;
      }
      while (v4);
    }
LABEL_7:
    JUMPOUT(0x1852FDE40);
  }
  return result;
}

void llvm::SmallVectorImpl<long long>::append<long long const*,void>(uint64_t a1, unsigned char *__src, unsigned char *a3)
{
  if (__src == a3)
  {
    uint64_t v7 = 0;
    size_t v6 = 0;
    unint64_t v9 = *(unsigned int *)(a1 + 8);
    LODWORD(v8) = *(_DWORD *)(a1 + 8);
    goto LABEL_12;
  }
  size_t v6 = a3 - __src;
  uint64_t v7 = (a3 - __src) >> 3;
  unint64_t v8 = *(unsigned int *)(a1 + 8);
  unint64_t v9 = v7 + v8;
  unint64_t v10 = *(void *)a1;
  unint64_t v11 = *(void *)a1 + 8 * v8;
  if (*(void *)a1 <= (unint64_t)__src && v11 > (unint64_t)__src)
  {
    if (v9 <= v8)
    {
      if (v10 + 8 * v9 <= (unint64_t)__src) {
        goto LABEL_25;
      }
    }
    else if (v9 > *(unsigned int *)(a1 + 12))
    {
      goto LABEL_25;
    }
  }
  unint64_t v13 = (unint64_t)(a3 - 8);
  if (v10 <= (unint64_t)(a3 - 8) && v11 > v13)
  {
    if (v9 > v8)
    {
      if (v9 <= *(unsigned int *)(a1 + 12)) {
        goto LABEL_12;
      }
LABEL_25:
      __assert_rtn("assertSafeToReferenceAfterResize", "SmallVector.h", 194, "isSafeToReferenceAfterResize(Elt, NewSize) && \"Attempting to reference an element of the vector in an operation \" \"that invalidates it\"");
    }
    if (v10 + 8 * v9 <= v13) {
      goto LABEL_25;
    }
  }
LABEL_12:
  if (v9 > *(unsigned int *)(a1 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v9, 8);
    LODWORD(v8) = *(_DWORD *)(a1 + 8);
  }
  if (__src != a3)
  {
    memcpy((void *)(*(void *)a1 + 8 * v8), __src, v6);
    LODWORD(v8) = *(_DWORD *)(a1 + 8);
  }
  unint64_t v14 = v7 + v8;
  if (v14 > *(unsigned int *)(a1 + 12)) {
    __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
  }
  *(_DWORD *)(a1 + 8) = v14;
}

uint64_t *std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>(uint64_t **a1, uint64_t *a2, const void **a3, uint64_t a4)
{
  size_t v6 = std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__find_equal<std::string>(a1, a2, &v15, &v14, a3);
  uint64_t v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    unint64_t v8 = v6;
    unint64_t v9 = (char *)operator new(0x50uLL);
    uint64_t v7 = (uint64_t *)v9;
    if (*(char *)(a4 + 23) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)(v9 + 32), *(const std::string::value_type **)a4, *(void *)(a4 + 8));
    }
    else
    {
      *((_OWORD *)v9 + 2) = *(_OWORD *)a4;
      *((void *)v9 + 6) = *(void *)(a4 + 16);
    }
    std::vector<std::shared_ptr<MIL::IRArgument>>::vector(v7 + 7, (uint64_t *)(a4 + 24));
    unint64_t v10 = v15;
    uint64_t *v7 = 0;
    v7[1] = 0;
    v7[2] = (uint64_t)v10;
    *unint64_t v8 = (uint64_t)v7;
    unint64_t v11 = (uint64_t *)**a1;
    __int16 v12 = v7;
    if (v11)
    {
      *a1 = v11;
      __int16 v12 = (uint64_t *)*v8;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v12);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void sub_180D567D8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180D567EC(_Unwind_Exception *a1)
{
  if (v1[55] < 0) {
    operator delete(*v2);
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__find_equal<std::string>(uint64_t **a1, uint64_t *a2, uint64_t **a3, uint64_t **a4, const void **a5)
{
  unint64_t v8 = a1 + 1;
  if (a1 + 1 == (uint64_t **)a2) {
    goto LABEL_20;
  }
  int v10 = *((char *)a2 + 55);
  int v11 = *((char *)a5 + 23);
  if (v11 >= 0) {
    size_t v12 = *((unsigned __int8 *)a5 + 23);
  }
  else {
    size_t v12 = (size_t)a5[1];
  }
  if (v11 >= 0) {
    unint64_t v13 = a5;
  }
  else {
    unint64_t v13 = *a5;
  }
  if (v10 >= 0) {
    size_t v14 = *((unsigned __int8 *)a2 + 55);
  }
  else {
    size_t v14 = a2[5];
  }
  if (v10 >= 0) {
    int v15 = a2 + 4;
  }
  else {
    int v15 = (const void *)a2[4];
  }
  if (v14 >= v12) {
    size_t v16 = v12;
  }
  else {
    size_t v16 = v14;
  }
  int v17 = memcmp(v13, v15, v16);
  BOOL v18 = v12 < v14;
  if (v17) {
    BOOL v18 = v17 < 0;
  }
  if (v18)
  {
LABEL_20:
    char v19 = (uint64_t *)*a2;
    if (*a1 == a2)
    {
      uint64_t v21 = a2;
LABEL_53:
      if (v19)
      {
        *a3 = v21;
        return v21 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v19)
    {
      uint64_t v20 = (uint64_t *)*a2;
      do
      {
        uint64_t v21 = v20;
        uint64_t v20 = (uint64_t *)v20[1];
      }
      while (v20);
    }
    else
    {
      char v26 = a2;
      do
      {
        uint64_t v21 = (uint64_t *)v26[2];
        BOOL v27 = *v21 == (void)v26;
        char v26 = v21;
      }
      while (v27);
    }
    int v28 = *((char *)a5 + 23);
    int v29 = *((char *)v21 + 55);
    if (v29 >= 0) {
      size_t v30 = *((unsigned __int8 *)v21 + 55);
    }
    else {
      size_t v30 = v21[5];
    }
    if (v29 >= 0) {
      int v31 = v21 + 4;
    }
    else {
      int v31 = (const void *)v21[4];
    }
    if (v28 >= 0) {
      size_t v32 = *((unsigned __int8 *)a5 + 23);
    }
    else {
      size_t v32 = (size_t)a5[1];
    }
    if (v28 >= 0) {
      long long v33 = a5;
    }
    else {
      long long v33 = *a5;
    }
    if (v32 >= v30) {
      size_t v34 = v30;
    }
    else {
      size_t v34 = v32;
    }
    int v35 = memcmp(v31, v33, v34);
    BOOL v36 = v30 < v32;
    if (v35) {
      BOOL v36 = v35 < 0;
    }
    if (v36) {
      goto LABEL_53;
    }
    __int16 v37 = *v8;
    if (*v8)
    {
      do
      {
        while (1)
        {
          __int16 v38 = (uint64_t **)v37;
          unint64_t v41 = (const void *)v37[4];
          __int16 v39 = v37 + 4;
          uint64_t v40 = v41;
          int v42 = *((char *)v39 + 23);
          if (v42 >= 0) {
            size_t v43 = *((unsigned __int8 *)v39 + 23);
          }
          else {
            size_t v43 = v39[1];
          }
          if (v42 >= 0) {
            uint64_t v44 = v39;
          }
          else {
            uint64_t v44 = v40;
          }
          if (v43 >= v32) {
            size_t v45 = v32;
          }
          else {
            size_t v45 = v43;
          }
          int v46 = memcmp(v33, v44, v45);
          BOOL v47 = v32 < v43;
          if (v46) {
            BOOL v47 = v46 < 0;
          }
          if (!v47) {
            break;
          }
          __int16 v37 = *v38;
          unint64_t v8 = v38;
          if (!*v38) {
            goto LABEL_74;
          }
        }
        int v48 = memcmp(v44, v33, v45);
        BOOL v49 = v43 < v32;
        if (v48) {
          BOOL v49 = v48 < 0;
        }
        if (!v49) {
          break;
        }
        unint64_t v8 = v38 + 1;
        __int16 v37 = v38[1];
      }
      while (v37);
    }
    else
    {
      __int16 v38 = v8;
    }
LABEL_74:
    *a3 = (uint64_t *)v38;
    return (uint64_t *)v8;
  }
  int v22 = memcmp(v15, v13, v16);
  BOOL v23 = v14 < v12;
  if (v22) {
    BOOL v23 = v22 < 0;
  }
  if (!v23)
  {
    *a3 = a2;
    *a4 = a2;
    return (uint64_t *)a4;
  }
  uint64_t v24 = a2[1];
  if (v24)
  {
    uint64_t v25 = (uint64_t *)a2[1];
    do
    {
      a4 = (uint64_t **)v25;
      uint64_t v25 = (uint64_t *)*v25;
    }
    while (v25);
  }
  else
  {
    char v50 = a2;
    do
    {
      a4 = (uint64_t **)v50[2];
      BOOL v27 = *a4 == v50;
      char v50 = (uint64_t *)a4;
    }
    while (!v27);
  }
  if (a4 != v8)
  {
    int v51 = *((char *)a4 + 55);
    if (v51 >= 0) {
      size_t v52 = *((unsigned __int8 *)a4 + 55);
    }
    else {
      size_t v52 = (size_t)a4[5];
    }
    if (v51 >= 0) {
      int v53 = (uint64_t *)(a4 + 4);
    }
    else {
      int v53 = a4[4];
    }
    if (v52 >= v12) {
      size_t v54 = v12;
    }
    else {
      size_t v54 = v52;
    }
    int v55 = memcmp(v13, v53, v54);
    BOOL v56 = v12 < v52;
    if (v55) {
      BOOL v56 = v55 < 0;
    }
    if (!v56)
    {
      uint64_t v57 = *v8;
      if (*v8)
      {
        uint64_t v58 = a3;
        do
        {
          while (1)
          {
            int v59 = (uint64_t **)v57;
            unint64_t v62 = (const void *)v57[4];
            uint64_t v60 = v57 + 4;
            char v61 = v62;
            int v63 = *((char *)v60 + 23);
            if (v63 >= 0) {
              size_t v64 = *((unsigned __int8 *)v60 + 23);
            }
            else {
              size_t v64 = v60[1];
            }
            if (v63 >= 0) {
              int v65 = v60;
            }
            else {
              int v65 = v61;
            }
            if (v64 >= v12) {
              size_t v66 = v12;
            }
            else {
              size_t v66 = v64;
            }
            int v67 = memcmp(v13, v65, v66);
            BOOL v68 = v12 < v64;
            if (v67) {
              BOOL v68 = v67 < 0;
            }
            if (!v68) {
              break;
            }
            uint64_t v57 = *v59;
            unint64_t v8 = v59;
            if (!*v59) {
              goto LABEL_119;
            }
          }
          int v69 = memcmp(v65, v13, v66);
          BOOL v70 = v64 < v12;
          if (v69) {
            BOOL v70 = v69 < 0;
          }
          if (!v70) {
            break;
          }
          unint64_t v8 = v59 + 1;
          uint64_t v57 = v59[1];
        }
        while (v57);
      }
      else
      {
        int v59 = v8;
        uint64_t v58 = a3;
      }
LABEL_119:
      *uint64_t v58 = (uint64_t *)v59;
      return (uint64_t *)v8;
    }
  }
  if (v24)
  {
    *a3 = (uint64_t *)a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return (uint64_t *)a4;
}

void *std::vector<std::shared_ptr<MIL::IRArgument>>::vector(void *a1, uint64_t *a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  uint64_t v5 = v4 - *a2;
  if (v4 != *a2)
  {
    if (v5 < 0) {
      std::vector<int>::__throw_length_error[abi:ne180100]();
    }
    size_t v6 = (char *)operator new(v4 - *a2);
    uint64_t v7 = 0;
    *a1 = v6;
    a1[1] = v6;
    a1[2] = &v6[16 * (v5 >> 4)];
    do
    {
      uint64_t v8 = v3 + v7;
      unint64_t v9 = &v6[v7];
      uint64_t v10 = *(void *)(v3 + v7 + 8);
      *(void *)unint64_t v9 = *(void *)(v3 + v7);
      *((void *)v9 + 1) = v10;
      if (v10) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
      }
      v7 += 16;
    }
    while (v8 + 16 != v4);
    a1[1] = &v6[v7];
  }
  return a1;
}

void sub_180D56CC0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = (char *)*v1;
  if (*v1)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = *v1;
    if (v4 != v3)
    {
      do
      {
        size_t v6 = (std::__shared_weak_count *)*((void *)v4 - 1);
        if (v6)
        {
          if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
            std::__shared_weak_count::__release_weak(v6);
          }
        }
        v4 -= 16;
      }
      while (v4 != v3);
      uint64_t v5 = *v1;
    }
    v1[1] = v3;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

void std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy(uint64_t a1, char *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy(a1, *(void *)a2);
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy(a1, *((void *)a2 + 1));
    uint64_t v4 = *((void *)a2 + 7);
    if (v4)
    {
      uint64_t v5 = *((void *)a2 + 8);
      size_t v6 = (void *)*((void *)a2 + 7);
      if (v5 != v4)
      {
        do
        {
          uint64_t v7 = *(std::__shared_weak_count **)(v5 - 8);
          if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
            std::__shared_weak_count::__release_weak(v7);
          }
          v5 -= 16;
        }
        while (v5 != v4);
        size_t v6 = (void *)*((void *)a2 + 7);
      }
      *((void *)a2 + 8) = v4;
      operator delete(v6);
    }
    if (a2[55] < 0) {
      operator delete(*((void **)a2 + 4));
    }
    operator delete(a2);
  }
}

std::runtime_error *std::range_error::range_error[abi:ne180100](std::runtime_error *a1)
{
  result = std::runtime_error::runtime_error(a1, "index out of bounds");
  result->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x1E4FBA4B8] + 16);
  return result;
}

void std::string::__throw_out_of_range[abi:ne180100]()
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::CastOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CastOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x747361632E73706DLL)
    {
      __int16 v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.cast";
      v7[3] = 8;
      uint64_t v5 = "' failed due to the operation not being registered";
      __int16 v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::CastOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::AddOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AddOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1684300078)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.add";
      v8[3] = 7;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id)
  {
    return 0;
  }
  return result;
}

llvm::APFloatBase *std::complex<llvm::APFloat>::complex[abi:ne180100](llvm::APFloatBase *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (llvm::APFloatBase *)((char *)a1 + 8);
  __int16 v6 = (const llvm::detail::DoubleAPFloat *)(a2 + 8);
  __int16 v7 = *(void **)(a2 + 8);
  __int16 v8 = llvm::APFloatBase::PPCDoubleDouble(a1);
  if (v8 == v7)
  {
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v5, v6);
    __int16 v9 = (llvm::APFloatBase *)((char *)a1 + 40);
    size_t v12 = *(void **)(a3 + 8);
    uint64_t v10 = (const llvm::detail::DoubleAPFloat *)(a3 + 8);
    if (v8 != v12) {
      goto LABEL_3;
    }
LABEL_5:
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v9, v10);
    return a1;
  }
  llvm::detail::IEEEFloat::IEEEFloat(v5, v6);
  __int16 v9 = (llvm::APFloatBase *)((char *)a1 + 40);
  int v11 = *(void **)(a3 + 8);
  uint64_t v10 = (const llvm::detail::DoubleAPFloat *)(a3 + 8);
  if (v8 == v11) {
    goto LABEL_5;
  }
LABEL_3:
  llvm::detail::IEEEFloat::IEEEFloat(v9, v10);
  return a1;
}

void sub_180D570F4(_Unwind_Exception *a1)
{
  if (v3 == *(void *)v2)
  {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)(v1 + 16));
    _Unwind_Resume(a1);
  }
  llvm::detail::IEEEFloat::~IEEEFloat(v2);
  _Unwind_Resume(a1);
}

void *std::complex<llvm::APFloat>::~complex(void *a1)
{
  uint64_t v2 = (llvm::detail::IEEEFloat *)(a1 + 5);
  uint64_t v3 = (void *)a1[5];
  uint64_t v4 = llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1);
  if (v4 == v3)
  {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)(a1 + 6));
    uint64_t v5 = (llvm::detail::IEEEFloat *)(a1 + 1);
    if (v4 != (void *)a1[1]) {
      goto LABEL_3;
    }
  }
  else
  {
    llvm::detail::IEEEFloat::~IEEEFloat(v2);
    uint64_t v5 = (llvm::detail::IEEEFloat *)(a1 + 1);
    if (v4 != (void *)a1[1])
    {
LABEL_3:
      llvm::detail::IEEEFloat::~IEEEFloat(v5);
      return a1;
    }
  }
  std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)(a1 + 2));
  return a1;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::PadOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PadOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1684107310)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.pad";
      v8[3] = 7;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::PadOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 12 && *(void *)AttrData == 0x746C756D2E73706DLL && *(_DWORD *)(AttrData + 8) == 2037149801)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.multiply";
      v8[3] = 12;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::FloorOp,mlir::Operation *,llvm::CastInfo<mlir::mps::FloorOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 9 && *(void *)AttrData == 0x6F6F6C662E73706DLL && *(unsigned char *)(AttrData + 8) == 114)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.floor";
      v8[3] = 9;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::FloorOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ResizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ResizeOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 10 && *(void *)AttrData == 0x697365722E73706DLL && *(_WORD *)(AttrData + 8) == 25978)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.resize";
      v8[3] = 10;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ResizeOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReciprocalOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReciprocalOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 14 && *AttrData == 0x696365722E73706DLL && *(void *)((char *)AttrData + 6) == 0x6C61636F72706963)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.reciprocal";
      v8[3] = 14;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReciprocalOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::LogarithmOp,mlir::Operation *,llvm::CastInfo<mlir::mps::LogarithmOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 13 && *AttrData == 0x61676F6C2E73706DLL && *(void *)((char *)AttrData + 5) == 0x6D6874697261676FLL)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.logarithm";
      v8[3] = 13;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::LogarithmOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReciprocalSquareRootOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReciprocalSquareRootOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v12[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v12);
    if (v4 == 26
      && *(void *)AttrData == 0x696365722E73706DLL
      && *(void *)(AttrData + 8) == 0x735F6C61636F7270
      && *(void *)(AttrData + 16) == 0x6F725F6572617571
      && *(_WORD *)(AttrData + 24) == 29807)
    {
      __int16 v11 = 1283;
      v10[0] = (uint64_t)"classof on '";
      v10[2] = (uint64_t)"mps.reciprocal_square_root";
      v10[3] = 26;
      __int16 v8 = "' failed due to the operation not being registered";
      __int16 v9 = 259;
      llvm::operator+(v10, (uint64_t *)&v8, (uint64_t)v12);
      llvm::report_fatal_error((llvm::Twine *)v12, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReciprocalSquareRootOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SubtractOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SubtractOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 12 && *(void *)AttrData == 0x746275732E73706DLL && *(_DWORD *)(AttrData + 8) == 1952670066)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.subtract";
      v8[3] = 12;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SubtractOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::DivideOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DivideOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 10 && *(void *)AttrData == 0x697669642E73706DLL && *(_WORD *)(AttrData + 8) == 25956)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.divide";
      v8[3] = 10;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::DivideOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::CeilOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CeilOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x6C6965632E73706DLL)
    {
      __int16 v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.ceil";
      v7[3] = 8;
      uint64_t v5 = "' failed due to the operation not being registered";
      __int16 v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::CeilOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::InitRandomPhiloxStateOp,mlir::Operation *,llvm::CastInfo<mlir::mps::InitRandomPhiloxStateOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v12[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v12);
    if (v4 == 28
      && *(void *)AttrData == 0x74696E692E73706DLL
      && *(void *)(AttrData + 8) == 0x5F6D6F646E61725FLL
      && *(void *)(AttrData + 16) == 0x735F786F6C696870
      && *(_DWORD *)(AttrData + 24) == 1702125940)
    {
      __int16 v11 = 1283;
      v10[0] = (uint64_t)"classof on '";
      v10[2] = (uint64_t)"mps.init_random_philox_state";
      v10[3] = 28;
      __int16 v8 = "' failed due to the operation not being registered";
      __int16 v9 = 259;
      llvm::operator+(v10, (uint64_t *)&v8, (uint64_t)v12);
      llvm::report_fatal_error((llvm::Twine *)v12, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::InitRandomPhiloxStateOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::RandomUniformOp,mlir::Operation *,llvm::CastInfo<mlir::mps::RandomUniformOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 18
      && *(void *)AttrData == 0x646E61722E73706DLL
      && *(void *)(AttrData + 8) == 0x6F66696E755F6D6FLL
      && *(_WORD *)(AttrData + 16) == 28018)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.random_uniform";
      v9[3] = 18;
      __int16 v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::RandomUniformOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SelectOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SelectOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 10 && *(void *)AttrData == 0x656C65732E73706DLL && *(_WORD *)(AttrData + 8) == 29795)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.select";
      v8[3] = 10;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SelectOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::RandomNormalOp,mlir::Operation *,llvm::CastInfo<mlir::mps::RandomNormalOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 17
      && *(void *)AttrData == 0x646E61722E73706DLL
      && *(void *)(AttrData + 8) == 0x616D726F6E5F6D6FLL
      && *(unsigned char *)(AttrData + 16) == 108)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.random_normal";
      v9[3] = 17;
      __int16 v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::RandomNormalOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReverseOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReverseOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x657665722E73706DLL && *(void *)((char *)AttrData + 3) == 0x657372657665722ELL)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.reverse";
      v8[3] = 11;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReverseOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::NegativeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::NegativeOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 12 && *(void *)AttrData == 0x6167656E2E73706DLL && *(_DWORD *)(AttrData + 8) == 1702259060)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.negative";
      v8[3] = 12;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::NegativeOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::TopKOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TopKOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 9 && *(void *)AttrData == 0x5F706F742E73706DLL && *(unsigned char *)(AttrData + 8) == 107)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.top_k";
      v8[3] = 9;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::TopKOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::CropResizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CropResizeOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 15 && *AttrData == 0x706F72632E73706DLL && *(void *)((char *)AttrData + 7) == 0x657A697365725F70)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.crop_resize";
      v8[3] = 15;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::CropResizeOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::DequantizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DequantizeOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 14 && *AttrData == 0x757165642E73706DLL && *(void *)((char *)AttrData + 6) == 0x657A69746E617571)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.dequantize";
      v8[3] = 14;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::DequantizeLUTOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DequantizeLUTOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 18
      && *(void *)AttrData == 0x757165642E73706DLL
      && *(void *)(AttrData + 8) == 0x6C5F657A69746E61
      && *(_WORD *)(AttrData + 16) == 29813)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.dequantize_lut";
      v9[3] = 18;
      __int16 v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::DequantizeLUTOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::QuantizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::QuantizeOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 12 && *(void *)AttrData == 0x6E6175712E73706DLL && *(_DWORD *)(AttrData + 8) == 1702521204)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.quantize";
      v8[3] = 12;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::QuantizeOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReductionMinOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionMinOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 17
      && *(void *)AttrData == 0x756465722E73706DLL
      && *(void *)(AttrData + 8) == 0x696D5F6E6F697463
      && *(unsigned char *)(AttrData + 16) == 110)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.reduction_min";
      v9[3] = 17;
      __int16 v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionMinOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReductionMaxOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionMaxOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 17
      && *(void *)AttrData == 0x756465722E73706DLL
      && *(void *)(AttrData + 8) == 0x616D5F6E6F697463
      && *(unsigned char *)(AttrData + 16) == 120)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.reduction_max";
      v9[3] = 17;
      __int16 v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionMaxOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::AbsoluteOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AbsoluteOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 12 && *(void *)AttrData == 0x6F7362612E73706DLL && *(_DWORD *)(AttrData + 8) == 1702131052)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.absolute";
      v8[3] = 12;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::AbsoluteOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::GreaterThanOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GreaterThanOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x616572672E73706DLL && *(void *)((char *)AttrData + 3) == 0x726574616572672ELL)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.greater";
      v8[3] = 11;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::GreaterThanOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::MaximumOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MaximumOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x6978616D2E73706DLL && *(void *)((char *)AttrData + 3) == 0x6D756D6978616D2ELL)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.maximum";
      v8[3] = 11;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::MaximumOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::MinimumOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MinimumOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x696E696D2E73706DLL && *(void *)((char *)AttrData + 3) == 0x6D756D696E696D2ELL)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.minimum";
      v8[3] = 11;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::MinimumOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::RoundOp,mlir::Operation *,llvm::CastInfo<mlir::mps::RoundOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 9 && *(void *)AttrData == 0x6E756F722E73706DLL && *(unsigned char *)(AttrData + 8) == 100)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.round";
      v8[3] = 9;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::RoundOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ClampOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ClampOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 9 && *(void *)AttrData == 0x6D616C632E73706DLL && *(unsigned char *)(AttrData + 8) == 112)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.clamp";
      v8[3] = 9;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ClampOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::BatchToSpaceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::BatchToSpaceOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 18
      && *(void *)AttrData == 0x637461622E73706DLL
      && *(void *)(AttrData + 8) == 0x6170735F6F745F68
      && *(_WORD *)(AttrData + 16) == 25955)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.batch_to_space";
      v9[3] = 18;
      __int16 v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::BatchToSpaceOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SpaceToBatchOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SpaceToBatchOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 18
      && *(void *)AttrData == 0x636170732E73706DLL
      && *(void *)(AttrData + 8) == 0x7461625F6F745F65
      && *(_WORD *)(AttrData + 16) == 26723)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.space_to_batch";
      v9[3] = 18;
      __int16 v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SpaceToBatchOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SampleGridOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SampleGridOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 15 && *AttrData == 0x706D61732E73706DLL && *(void *)((char *)AttrData + 7) == 0x646972675F656C70)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.sample_grid";
      v8[3] = 15;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SampleGridOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SortOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SortOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x74726F732E73706DLL)
    {
      __int16 v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.sort";
      v7[3] = 8;
      uint64_t v5 = "' failed due to the operation not being registered";
      __int16 v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SortOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::DimensionSizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DimensionSizeOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 18
      && *(void *)AttrData == 0x656D69642E73706DLL
      && *(void *)(AttrData + 8) == 0x69735F6E6F69736ELL
      && *(_WORD *)(AttrData + 16) == 25978)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.dimension_size";
      v9[3] = 18;
      __int16 v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::DimensionSizeOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SoftmaxOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SoftmaxOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x74666F732E73706DLL && *(void *)((char *)AttrData + 3) == 0x78616D74666F732ELL)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.softmax";
      v8[3] = 11;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SoftmaxOp,void>::id)
  {
    return 0;
  }
  return result;
}

void ___ZN3GPU19EncodeCPUWorkHelper6encodeEPNS_16EncodeDescriptorENSt3__18functionIFvvEEE_block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void *)(a1 + 56);
  id v5 = v3;
  if (!v4) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(uint64_t))(*(void *)v4 + 48))(v4);
  [v5 setSignaledValue:*(void *)(a1 + 64)];
}

void sub_180D59370(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c27_ZTSNSt3__18functionIFvvEEE(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a2 + 56);
  if (result)
  {
    if (result == a2 + 32)
    {
      *(void *)(a1 + 56) = a1 + 32;
      uint64_t v4 = *(uint64_t (**)(void))(**(void **)(a2 + 56) + 24);
      return v4();
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
      *(void *)(a1 + 56) = result;
    }
  }
  else
  {
    *(void *)(a1 + 56) = 0;
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_32c27_ZTSNSt3__18functionIFvvEEE(uint64_t a1)
{
  uint64_t v1 = a1 + 32;
  uint64_t result = *(void *)(a1 + 56);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

id **std::unique_ptr<GPU::EncodeCPUWorkHelper>::~unique_ptr[abi:ne180100](id **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {

    MEMORY[0x1852FDE70](v2, 0x1080C40CC6EE3FDLL);
  }
  return a1;
}

void GPU::BaseOpHandler::encodeOp(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2)
{
  GPU::BaseOpHandler::_inferJITOutputTypes((uint64_t)this, a2);
  uint64_t v4 = *((void *)this + 3);
  uint64_t v5 = *(unsigned int *)(v4 + 36);
  uint64_t v6 = v4 - 16;
  if (v5) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  id v11 = [MEMORY[0x1E4F1CA48] arrayWithCapacity:v5];
  if (v5)
  {
    for (uint64_t i = 0; i != v5; ++i)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, i);
      __int16 v10 = (*(void (**)(void, uint64_t, void, void, void, uint64_t))(**((void **)this + 2) + 80))(*((void *)this + 2), NextResultAtOffset, *((void *)a2 + 1), 0, 0, 1);
      [v11 addObject:v10];
    }
  }
  (*(void (**)(GPU::BaseOpHandler *, GPU::EncodeDescriptor *, id))(*(void *)this + 16))(this, a2, v11);
}

void sub_180D59620(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_180D59634(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_180D5964C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_180D59660(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t GPU::BaseOpHandler::_inferJITOutputTypes(uint64_t this, GPU::EncodeDescriptor *a2)
{
  if (!*(unsigned char *)(this + 40))
  {
    uint64_t v2 = (void *)this;
    uint64_t v3 = *(void *)(this + 24);
    uint64_t v4 = *(unsigned int *)(v3 + 36);
    if (v4)
    {
      uint64_t v6 = 0;
      uint64_t v7 = v3 - 16;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, v6);
        this = (*(uint64_t (**)(void, uint64_t))(**(void **)(v2[2] + 448) + 24))(*(void *)(v2[2] + 448), NextResultAtOffset);
        if ((this & 1) == 0)
        {
          this = isStaticMPSType((uint64_t **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
          if (!this) {
            break;
          }
        }
        if (v4 == ++v6) {
          return this;
        }
      }
      __int16 v9 = (void *)v2[3];
      uint64_t v56 = 0;
      uint64_t v57 = 0;
      v55[0] = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)(v9 + 3));
      v55[1] = 0;
      uint64_t v10 = v9[2];
      mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)v9);
      uint64_t v56 = v10;
      uint64_t v57 = v11;
      v47[0] = 0;
      v47[1] = 0;
      int v48 = 0;
      BOOL v49 = 0;
      uint64_t v50 = 0;
      int v51 = 0;
      size_t v52 = 0;
      uint64_t v53 = 0;
      int v54 = 0;
      uint64_t v44 = 0;
      uint64_t v45 = 0;
      int v46 = 0;
      uint64_t v12 = v2[3];
      if ((*(unsigned char *)(v12 + 46) & 0x80) == 0)
      {
LABEL_47:
        unint64_t v41 = mlir::OpBuilder::clone(v55, (mlir::Operation *)v12, (mlir::IRMapping *)v47);
        if (mlir::mps::inferTypes(v41, v42)) {
          mlir::verify(v41, (mlir::Operation *)1);
        }
        __assert_rtn("_inferJITOutputTypes", "GPUBaseOps.mm", 331, "0 && \"failed to infer output types\"");
      }
      unint64_t v13 = 0;
      unint64_t v14 = 0;
      while (1)
      {
        if (v14 >= *(unsigned int *)(v12 + 68)) {
          goto LABEL_47;
        }
        unint64_t v16 = *(void *)(*(void *)(v12 + 72) + 32 * v14 + 24);
        unint64_t v58 = v16;
        v59[0] = 0;
        if ((llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)v47, &v58, v59) & 1) == 0)
        {
          uint64_t v17 = (*(uint64_t (**)(void *, GPU::EncodeDescriptor *, uint64_t **, unint64_t))(*v2 + 48))(v2, a2, v55, v14);
          uint64_t v43 = v17;
          unint64_t v58 = v16;
          v59[0] = 0;
          char v18 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)v47, &v58, v59);
          char v19 = v59[0];
          if ((v18 & 1) == 0)
          {
            char v19 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)v47, (uint64_t)&v58, &v58, v59[0]);
            *char v19 = v58;
            v19[1] = 0;
          }
          v19[1] = v17;
          if (v16 != v43)
          {
            if (mlir::Value::getDefiningOp((mlir::Value *)&v43)) {
              break;
            }
          }
        }
LABEL_12:
        ++v14;
        uint64_t v12 = v2[3];
        if ((*(unsigned char *)(v12 + 46) & 0x80) == 0) {
          goto LABEL_47;
        }
      }
      uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v43);
      uint64_t v21 = DefiningOp;
      if (v13 < v46)
      {
        *(void *)unint64_t v13 = DefiningOp;
        uint64_t v15 = (uint64_t)(v13 + 8);
        goto LABEL_11;
      }
      int v22 = (char *)v44;
      BOOL v23 = (char *)(v13 - (char *)v44);
      uint64_t v24 = (v13 - (char *)v44) >> 3;
      unint64_t v25 = v24 + 1;
      if ((unint64_t)(v24 + 1) >> 61) {
        std::vector<int>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v26 = v46 - (char *)v44;
      if ((v46 - (char *)v44) >> 2 > v25) {
        unint64_t v25 = v26 >> 2;
      }
      if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v27 = v25;
      }
      if (v27)
      {
        if (v27 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        int v28 = operator new(8 * v27);
        int v29 = (uint64_t *)&v28[8 * v24];
        *int v29 = v21;
        uint64_t v15 = (uint64_t)(v29 + 1);
        size_t v30 = (char *)(v13 - v22);
        if (v13 == v22)
        {
LABEL_29:
          uint64_t v44 = v29;
          uint64_t v45 = v15;
          int v46 = &v28[8 * v27];
          if (!v13) {
            goto LABEL_11;
          }
          goto LABEL_36;
        }
      }
      else
      {
        int v28 = 0;
        int v29 = (uint64_t *)(8 * v24);
        *(void *)(8 * v24) = v21;
        uint64_t v15 = 8 * v24 + 8;
        size_t v30 = (char *)(v13 - v22);
        if (v13 == v22) {
          goto LABEL_29;
        }
      }
      unint64_t v31 = (unint64_t)(v30 - 8);
      if (v31 >= 0x168)
      {
        unint64_t v34 = (v13 - 8 - v22) & 0xFFFFFFFFFFFFFFF8;
        if (&v23[(void)v28 - 8 - v34] > &v23[(void)v28 - 8])
        {
          size_t v32 = v13;
        }
        else if (&v13[-v34 - 8] > v13 - 8)
        {
          size_t v32 = v13;
        }
        else if ((unint64_t)(v13 - v28 - (void)v23) >= 0x20)
        {
          uint64_t v35 = (v31 >> 3) + 1;
          uint64_t v36 = 8 * (v35 & 0x3FFFFFFFFFFFFFFCLL);
          size_t v32 = &v13[-v36];
          int v29 = (uint64_t *)((char *)v29 - v36);
          __int16 v37 = &v28[8 * v24 - 16];
          __int16 v38 = v13 - 16;
          uint64_t v39 = v35 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v40 = *(_OWORD *)v38;
            *(v37 - 1) = *((_OWORD *)v38 - 1);
            *__int16 v37 = v40;
            v37 -= 2;
            v38 -= 32;
            v39 -= 4;
          }
          while (v39);
          if (v35 == (v35 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_35:
            unint64_t v13 = (char *)v44;
            uint64_t v44 = v29;
            uint64_t v45 = v15;
            int v46 = &v28[8 * v27];
            if (v13) {
LABEL_36:
            }
              operator delete(v13);
LABEL_11:
            uint64_t v45 = v15;
            unint64_t v13 = (char *)v15;
            goto LABEL_12;
          }
        }
        else
        {
          size_t v32 = v13;
        }
      }
      else
      {
        size_t v32 = v13;
      }
      do
      {
        uint64_t v33 = *((void *)v32 - 1);
        v32 -= 8;
        *--int v29 = v33;
      }
      while (v32 != v22);
      goto LABEL_35;
    }
  }
  return this;
}

void sub_180D59D94(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, llvm *a13)
{
  if (__p) {
    operator delete(__p);
  }
  mlir::IRMapping::~IRMapping(&a13);
}

void sub_180D59DE8()
{
  _Unwind_Resume(v0);
}

void GPU::BaseOpHandler::encodeConstantOp(GPU::BaseOpHandler *this, id *a2, const mlir::mps::CPUNDArray *a3, int a4)
{
  uint64_t v97 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *((void *)this + 3);
  if (!*(_DWORD *)(v4 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v7 = (uint64_t *)(v4 - 16);
  __int16 v8 = (MPSGraphTensorData *)*((id *)this + 6);
  if (!v8)
  {
    int v81 = v7;
    unsigned int MPSDataType = getMPSDataType(*(void **)a3);
    uint64_t v9 = *((void *)this + 2);
    __pattern4[0] = v81;
    uint64_t v88 = *((void *)mlir::Value::getParentRegion((mlir::Value *)__pattern4) + 2);
    uint64_t v10 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v9 + 88), &v88);
    if (v10
      && (uint64_t v87 = __pattern4[0],
          (uint64_t v11 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v10 + 3, &v87)) != 0))
    {
      id v12 = (id)v11[3];
    }
    else
    {
      id v12 = 0;
    }
    id v13 = [v12 mpsndarray];
    uint64_t v80 = (MPSGraphTensorData *)v12;
    if (v13
      && ([v13 buffer],
          unint64_t v14 = objc_claimAutoreleasedReturnValue(),
          BOOL v15 = [v14 storageMode] == 2,
          v14,
          !v15))
    {
      int v25 = 1;
      id v83 = v13;
      __int16 v8 = v80;
      if (*((void *)this + 12)) {
        goto LABEL_17;
      }
    }
    else
    {
      unint64_t v16 = (void *)MEMORY[0x1E4F35720];
      uint64_t v17 = getMPSShapeFromMLIR(*(uint64_t ***)a3);
      char v18 = adaptForMPS(v17);
      char v19 = [v16 descriptorWithDataType:MPSDataType shape:v18];

      [v19 setPreferPackedRows:1];
      if (*((unsigned char *)a3 + 58)
        || !*((unsigned char *)a3 + 57)
        || *((unsigned char *)a3 + 56)
        || mlir::mps::CPUNDArray::getNumElements(a3) < 1
        || ([a2[1] device],
            uint64_t v20 = objc_claimAutoreleasedReturnValue(),
            int v21 = [v20 hasUnifiedMemory],
            v20,
            !v21))
      {
        id v26 = objc_alloc(MEMORY[0x1E4F35690]);
        uint64_t v24 = [a2[1] device];
        id v83 = (id)[v26 initWithDevice:v24 descriptor:v19];
        int v25 = 1;
      }
      else
      {
        unint64_t BufferByteSize = mlir::mps::CPUNDArray::getBufferByteSize(a3);
        BOOL v23 = [a2[1] device];
        uint64_t v24 = (void *)[v23 newBufferWithBytesNoCopy:*((void *)a3 + 5) length:BufferByteSize options:0x100000 deallocator:0];

        id v83 = (id)[objc_alloc(MEMORY[0x1E4F35690]) initWithBuffer:v24 descriptor:v19];
        int v25 = 0;
      }

      __int16 v8 = [[MPSGraphTensorData alloc] initWithMPSNDArray:v83 device:*(void *)(*((void *)this + 2) + 48)];
      if (*((void *)this + 12))
      {
LABEL_17:
        if (**((unsigned char **)this + 11)) {
          BOOL v27 = v13 == v83;
        }
        else {
          BOOL v27 = 0;
        }
        int v28 = v27;
        if (!mlir::mps::CPUNDArray::getNumElements(a3) || !(v25 | v28)) {
          goto LABEL_72;
        }
        int64_t NumElements = mlir::mps::CPUNDArray::getNumElements(a3);
        size_t v30 = mlir::mps::CPUNDArray::getBufferByteSize(a3);
        size_t v31 = v30;
        int v32 = *((unsigned __int8 *)a3 + 58);
        size_t v77 = v30;
        if (*((unsigned char *)a3 + 58))
        {
          uint64_t v33 = (unsigned char *)*((void *)a3 + 5);
          unint64_t v34 = (char *)malloc_type_malloc(v30, 0x3772FA53uLL);
          uint64_t v35 = v34;
          if ((unsigned __int16)MPSDataType == 4)
          {
            int v36 = *v33 & 0xF;
            if ((unint64_t)(NumElements + 1) >= 3)
            {
              if (NumElements >= 0) {
                uint64_t v37 = NumElements;
              }
              else {
                uint64_t v37 = NumElements + 1;
              }
              memset(v34, v36 | (16 * v36), v37 >> 1);
            }
            if (NumElements) {
              v35[v31 - 1] = v36;
            }
            char v38 = 1;
          }
          else
          {
            char v38 = 1;
            switch(mlir::mps::CPUNDArray::getElementDataSize(a3))
            {
              case 1uLL:
                memset(v35, *v33, NumElements);
                break;
              case 2uLL:
                LOWORD(__pattern4[0]) = *(_WORD *)v33;
                WORD1(__pattern4[0]) = __pattern4[0];
                memset_pattern4(v35, __pattern4, 2 * NumElements);
                break;
              case 4uLL:
                memset_pattern4(v35, v33, 4 * NumElements);
                break;
              case 8uLL:
                memset_pattern8(v35, v33, 8 * NumElements);
                break;
              default:
                break;
            }
          }
        }
        else
        {
          if (v28)
          {
            if (!*((unsigned char *)a3 + 57)
              || *((unsigned char *)a3 + 56)
              || ([a2[1] device],
                  uint64_t v39 = objc_claimAutoreleasedReturnValue(),
                  char v40 = [v39 hasUnifiedMemory],
                  v39,
                  (v40 & 1) == 0))
            {
              uint64_t v35 = (char *)malloc_type_malloc(v31, 0x6618F233uLL);
              memcpy(v35, *((const void **)a3 + 5), v31);
              char v38 = 1;
              goto LABEL_49;
            }
          }
          char v38 = 0;
          uint64_t v35 = (char *)*((void *)a3 + 5);
        }
        if (!v28)
        {
          [v83 writeBytes:v35 strideBytes:0];
          if (v32) {
            free(v35);
          }
LABEL_72:
          id v66 = a2[11];
          if (v66)
          {
            int v67 = [v83 buffer];
            [v66 setConstantBuffer:v67];
          }
          if (v13)
          {
            BOOL v68 = [v13 buffer];
            BOOL v69 = [v68 storageMode] == 2;

            if (v69)
            {
              id v70 = objc_alloc(MEMORY[0x1E4F35770]);
              unint64_t v71 = [a2[1] device];
              uint64_t v72 = (void *)[v70 initWithDevice:v71];

              [v72 setLabel:&stru_1EC9D55D0];
              int v73 = GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
              id v74 = a2[1];
              id v89 = v83;
              int v75 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v89 count:1];
              [v72 encodeToMPSCommandEncoder:v73 commandBuffer:v74 sourceArrays:v75 destinationArray:v13];

LABEL_79:
            }
          }
          else if (a4)
          {
            uint64_t v76 = v8;
            uint64_t v72 = (void *)*((void *)this + 6);
            *((void *)this + 6) = v76;
            goto LABEL_79;
          }

          uint64_t v7 = v81;
          goto LABEL_81;
        }
LABEL_49:
        if ((MPSDataType & 0xFFF8) != 0)
        {
          unint64_t v41 = [a2[1] device];
          v85[0] = MEMORY[0x1E4F143A8];
          v85[1] = 3221225472;
          v85[2] = ___ZN3GPU13BaseOpHandler16encodeConstantOpEPNS_16EncodeDescriptorERKN4mlir3mps10CPUNDArrayEb_block_invoke;
          v85[3] = &__block_descriptor_33_e12_v24__0_v8Q16l;
          char v86 = v38;
          int v42 = (void *)[v41 newBufferWithBytesNoCopy:v35 length:v77 options:0x100000 deallocator:v85];

          id v43 = objc_alloc(MEMORY[0x1E4F35770]);
          uint64_t v44 = [a2[1] device];
          uint64_t v78 = (void *)[v43 initWithDevice:v44];

          uint64_t v45 = (void *)MEMORY[0x1E4F35720];
          int v46 = [v83 descriptor];
          BOOL v47 = [v46 getShape];
          int v48 = [v45 descriptorWithDataType:MPSDataType shape:v47];

          [v48 setPreferPackedRows:1];
          BOOL v49 = (void *)[objc_alloc(MEMORY[0x1E4F35690]) initWithBuffer:v42 offset:0 descriptor:v48];
          uint64_t v50 = GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
          id v51 = a2[1];
          uint64_t v92 = v49;
          size_t v52 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v92 count:1];
          [v78 encodeToMPSCommandEncoder:v50 commandBuffer:v51 sourceArrays:v52 destinationArray:v83];

          goto LABEL_72;
        }
        uint64_t v53 = (uint64_t *)*((void *)this + 10);
        if (!v53)
        {
          [*(id *)(*((void *)this + 2) + 48) metalDevice];
          objc_claimAutoreleasedReturnValue();
          std::make_unique[abi:ne180100]<GPU::EncodeCPUWorkHelper,objc_object  {objcproto9MTLDevice}* {__strong}>();
        }
        id v54 = v83;
        int v91 = 0;
        int v55 = operator new(0x20uLL);
        *int v55 = &unk_1EC9D1D08;
        v55[1] = v54;
        v55[2] = v35;
        *((unsigned char *)v55 + 24) = v38;
        int v91 = v55;
        uint64_t v56 = v53[2];
        if ((unint64_t)(v56 + 3) <= 1)
        {
          uint64_t v57 = [a2[1] device];
          uint64_t v58 = [v57 newSharedEvent];
          int v59 = (void *)v53[1];
          v53[1] = v58;

          uint64_t v56 = 0;
          v53[2] = 0;
        }
        v53[2] = v56 + 2;
        id v60 = a2[9];
        if (v60)
        {
          [v60 endEncoding];
          id v61 = a2[9];
          a2[9] = 0;
        }
        uint64_t v63 = *v53;
        unint64_t v62 = (void *)v53[1];
        __pattern4[0] = MEMORY[0x1E4F143A8];
        __pattern4[1] = 3321888768;
        __pattern4[2] = ___ZN3GPU19EncodeCPUWorkHelper6encodeEPNS_16EncodeDescriptorENSt3__18functionIFvvEEE_block_invoke;
        __pattern4[3] = &__block_descriptor_72_ea8_32c27_ZTSNSt3__18functionIFvvEEE_e29_v24__0___MTLSharedEvent__8Q16l;
        uint64_t v64 = (uint64_t)v91;
        if (v91)
        {
          int v65 = v62;
          if (v91 == v90)
          {
            uint64_t v95 = v94;
            (*(void (**)(void *, void *))(v90[0] + 24))(v90, v94);
            unint64_t v62 = v65;
            goto LABEL_64;
          }
          uint64_t v64 = (*(uint64_t (**)(void))(*v91 + 16))();
          unint64_t v62 = v65;
        }
        uint64_t v95 = (void *)v64;
LABEL_64:
        uint64_t v96 = v56 + 2;
        [v62 notifyListener:v63 atValue:v56 + 1 block:__pattern4];
        [a2[1] encodeSignalEvent:v53[1] value:v56 + 1];
        [a2[1] encodeWaitForEvent:v53[1] value:v56 + 2];
        if (v95 == v94)
        {
          (*(void (**)(void *))(v94[0] + 32))(v94);
        }
        else if (v95)
        {
          (*(void (**)(void))(*v95 + 40))();
        }
        if (v91 == v90)
        {
          (*(void (**)(void *))(v90[0] + 32))(v90);
        }
        else if (v91)
        {
          (*(void (**)(void))(*v91 + 40))();
        }
        goto LABEL_72;
      }
    }
    __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
  }
LABEL_81:
  BaseRuntime::setTensorDataToDataMap(*((void *)this + 2), v7, v8);
}

void sub_180D5A8B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

void ___ZN3GPU13BaseOpHandler16encodeConstantOpEPNS_16EncodeDescriptorERKN4mlir3mps10CPUNDArrayEb_block_invoke(uint64_t a1, void *a2)
{
  if (*(unsigned char *)(a1 + 32)) {
    free(a2);
  }
}

void std::make_unique[abi:ne180100]<GPU::EncodeCPUWorkHelper,objc_object  {objcproto9MTLDevice}* {__strong}>()
{
}

void sub_180D5ABB0(_Unwind_Exception *a1)
{
  MEMORY[0x1852FDE70](v1, 0x1080C40CC6EE3FDLL);
  _Unwind_Resume(a1);
}

id **std::unique_ptr<GPU::EncodeCPUWorkHelper>::operator=[abi:ne180100](id **a1, id **a2)
{
  uint64_t v3 = *a2;
  *a2 = 0;
  uint64_t v4 = *a1;
  *a1 = v3;
  if (v4)
  {

    MEMORY[0x1852FDE70](v4, 0x1080C40CC6EE3FDLL);
  }
  return a1;
}

uint64_t GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  uint64_t v4 = *((void *)this + 3);
  if ((*(unsigned char *)(v4 + 46) & 0x80) == 0) {
    __assert_rtn("getOperandStorage", "Operation.h", 960, "hasOperandStorage && \"expected operation to have operand storage\"");
  }
  if (*(_DWORD *)(v4 + 68) <= a4) {
    __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
  }
  uint64_t v7 = *(void *)(*(void *)(v4 + 72) + 32 * a4 + 24);
  if ((isStaticMPSType((uint64_t **)(*(void *)(v7 + 8) & 0xFFFFFFFFFFFFFFF8)) & 1) == 0)
  {
    unint64_t StaticType = GPURegionRuntime::getStaticType(*((void *)this + 2), v7);
    uint64_t UnknownLoc = mlir::Builder::getUnknownLoc(a3, v8);
    uint64_t v10 = mlir::OpBuilder::create<mlir::mps::PlaceholderOp,mlir::Type &>((mlir::OpBuilder *)a3, UnknownLoc, (uint64_t *)&StaticType);
    if (!*(_DWORD *)(v10 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v11 = *(void *)(*(void *)(v10 - 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v11) {
      __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
    }
    id v12 = *(void **)(v11 + 136);
    if (v12 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v12 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
    }
    return v10 - 16;
  }
  return v7;
}

unint64_t GPU::BaseOpHandler::_getJITStaticOperandReprConstant(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  uint64_t v4 = *((void *)this + 3);
  if ((*(unsigned char *)(v4 + 46) & 0x80) == 0) {
    __assert_rtn("getOperandStorage", "Operation.h", 960, "hasOperandStorage && \"expected operation to have operand storage\"");
  }
  if (*(_DWORD *)(v4 + 68) <= a4) {
    __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
  }
  unint64_t v85 = *(void *)(*(void *)(v4 + 72) + 32 * a4 + 24);
  *(void *)&long long v86 = v85;
  if (!v85) {
    __assert_rtn("matchPattern", "Matchers.h", 402, "value");
  }
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v86);
  if (DefiningOp)
  {
    uint64_t v9 = DefiningOp;
    uint64_t v10 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    if ((*(unsigned int (**)(void, uint64_t))(**(void **)(v9 + 48) + 32))(*(void *)(v9 + 48), v10)) {
      return v85;
    }
  }
  unint64_t StaticType = (uint64_t **)GPURegionRuntime::getStaticType(*((void *)this + 2), v85);
  if (!*StaticType) {
    goto LABEL_99;
  }
  if ((_UNKNOWN *)(*StaticType)[17] != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  uint64_t v84 = StaticType;
  uint64_t RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v84);
  if (!RHS) {
    __assert_rtn("dyn_cast", "Casting.h", 650, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
  }
  if (!*(void *)RHS) {
LABEL_99:
  }
    __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
  unint64_t v14 = *(void **)(*(void *)RHS + 136);
  BOOL v15 = v14 == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id;
  if (v14 == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id) {
    uint64_t v16 = RHS;
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t v83 = v16;
  if (!v15)
  {
    uint64_t v11 = 0;
    if (MTLReportFailureTypeEnabled())
    {
      MTLReportFailure();
      return 0;
    }
    return (unint64_t)v11;
  }
  uint64_t v17 = *((void *)this + 2) + 344;
  int v81 = (void *)*((void *)mlir::Value::getParentRegion((mlir::Value *)&v85) + 2);
  *(void *)&long long v86 = &v81;
  char v18 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>>>::__emplace_unique_key_args<mlir::Operation *,std::piecewise_construct_t const&,std::tuple<mlir::Operation * const&>,std::tuple<>>(v17, (uint64_t *)&v81, (uint64_t)&std::piecewise_construct, (void **)&v86);
  int8x8_t v20 = *(int8x8_t *)(v18 + 32);
  if (!*(void *)&v20) {
    goto LABEL_37;
  }
  unint64_t v21 = 0x9DDFEA08EB382D69 * (((8 * v85) + 8) ^ HIDWORD(v85));
  unint64_t v22 = 0x9DDFEA08EB382D69 * (HIDWORD(v85) ^ (v21 >> 47) ^ v21);
  unint64_t v23 = 0x9DDFEA08EB382D69 * (v22 ^ (v22 >> 47));
  uint8x8_t v24 = (uint8x8_t)vcnt_s8(v20);
  v24.i16[0] = vaddlv_u8(v24);
  if (v24.u32[0] > 1uLL)
  {
    unint64_t v25 = v23;
    if (v23 >= *(void *)&v20) {
      unint64_t v25 = v23 % *(void *)&v20;
    }
  }
  else
  {
    unint64_t v25 = v23 & (*(void *)&v20 - 1);
  }
  id v26 = *(uint64_t ***)(*((void *)v18 + 3) + 8 * v25);
  if (!v26 || (BOOL v27 = *v26) == 0)
  {
LABEL_37:
    uint64_t v74 = (uint64_t)(v18 + 24);
    int v75 = a3;
    GPURegionRuntime::waitAndReadIntTensorData(*((void *)this + 2), (uint64_t)a2, (void *)v85, (uint64_t)&v81);
    __p = 0;
    uint64_t v79 = 0;
    uint64_t v80 = 0;
    size_t v31 = (uint64_t *)v81;
    int v32 = v82;
    uint64_t v33 = (char *)v82 - (unsigned char *)v81;
    if (v82 != v81)
    {
      if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF9) {
        std::vector<int>::__throw_length_error[abi:ne180100]();
      }
      __p = operator new(2 * v33);
      uint64_t v79 = (llvm::APInt *)__p;
      uint64_t v80 = (llvm::APInt *)((char *)__p + 16 * (v33 >> 3));
      if (v32 != v31)
      {
        uint64_t v76 = v32;
        do
        {
          uint64_t v36 = *v31;
          unsigned int Width = mlir::IntegerType::getWidth((mlir::IntegerType *)&v83);
          int Signedness = mlir::IntegerType::getSignedness((mlir::IntegerType *)&v83);
          int v39 = Signedness;
          char v40 = v79;
          if (v79 < v80)
          {
            *((_DWORD *)v79 + 2) = Width;
            if (Width <= 0x40)
            {
              unint64_t v34 = 0xFFFFFFFFFFFFFFFFLL >> -(char)Width;
              if (!Width) {
                unint64_t v34 = 0;
              }
              *(void *)char v40 = v34 & v36;
            }
            else
            {
              llvm::APInt::initSlowCase(v40, v36, Signedness == 1);
            }
            uint64_t v35 = (llvm::APInt *)((char *)v40 + 16);
            goto LABEL_45;
          }
          unint64_t v41 = (llvm::APInt *)__p;
          uint64_t v42 = (v79 - (llvm::APInt *)__p) >> 4;
          unint64_t v43 = v42 + 1;
          if ((unint64_t)(v42 + 1) >> 60) {
            std::vector<int>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v44 = v80 - (llvm::APInt *)__p;
          if ((v80 - (llvm::APInt *)__p) >> 3 > v43) {
            unint64_t v43 = v44 >> 3;
          }
          if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v45 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v45 = v43;
          }
          id v89 = &v80;
          if (v45 >> 60) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          int v46 = (char *)operator new(16 * v45);
          BOOL v47 = &v46[16 * v42];
          *(void *)&long long v86 = v46;
          *((void *)&v86 + 1) = v47;
          int v48 = (llvm::APInt *)&v46[16 * v45];
          uint64_t v87 = v47;
          uint64_t v88 = v48;
          *((_DWORD *)v47 + 2) = Width;
          if (Width > 0x40)
          {
            llvm::APInt::initSlowCase((llvm::APInt *)&v46[16 * v42], v36, v39 == 1);
            unint64_t v41 = (llvm::APInt *)__p;
            char v40 = v79;
            uint64_t v35 = (llvm::APInt *)(v47 + 16);
            uint64_t v87 = v47 + 16;
            if (v79 == __p) {
              goto LABEL_67;
            }
          }
          else
          {
            unint64_t v49 = 0xFFFFFFFFFFFFFFFFLL >> -(char)Width;
            if (!Width) {
              unint64_t v49 = 0;
            }
            *(void *)BOOL v47 = v49 & v36;
            uint64_t v35 = (llvm::APInt *)(v47 + 16);
            uint64_t v87 = v47 + 16;
            if (v40 == v41)
            {
LABEL_67:
              id v54 = v41;
              goto LABEL_68;
            }
          }
          uint64_t v50 = 0;
          do
          {
            id v51 = (llvm::APInt *)&v47[v50 - 16];
            size_t v52 = (const void **)((char *)v40 + v50 - 16);
            unsigned int v53 = *(_DWORD *)((char *)v40 + v50 - 8);
            *(_DWORD *)&v47[v50 - 8] = v53;
            if (v53 <= 0x40) {
              *(void *)id v51 = *v52;
            }
            else {
              llvm::APInt::initSlowCase(v51, v52);
            }
            v50 -= 16;
          }
          while ((llvm::APInt *)((char *)v40 + v50) != v41);
          id v54 = (llvm::APInt *)__p;
          unint64_t v41 = v79;
          v47 += v50;
          uint64_t v35 = (llvm::APInt *)v87;
          int v48 = v88;
LABEL_68:
          __p = v47;
          uint64_t v79 = v35;
          int v55 = v80;
          uint64_t v80 = v48;
          uint64_t v88 = v55;
          *(void *)&long long v86 = v54;
          *((void *)&v86 + 1) = v54;
          if (v41 != v54)
          {
            uint64_t v56 = (char *)v41 - 16;
            int v32 = v76;
            do
            {
              uint64_t v87 = v56;
              if (*((_DWORD *)v56 + 2) >= 0x41u && *(void *)v56) {
                MEMORY[0x1852FDE40](*(void *)v56, 0x1000C8000313F17);
              }
              v56 -= 16;
            }
            while (v56 + 16 != (char *)v54);
            unint64_t v41 = v54;
            if (!v54) {
              goto LABEL_45;
            }
LABEL_77:
            operator delete(v41);
            goto LABEL_45;
          }
          int v32 = v76;
          if (v41) {
            goto LABEL_77;
          }
LABEL_45:
          uint64_t v79 = v35;
          ++v31;
        }
        while (v31 != v32);
      }
    }
    if (mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v84))
    {
      uint64_t v57 = v84;
      if (v84)
      {
        uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v84);
        if (!InterfaceFor)
        {
          int v59 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
          int v60 = 98;
          id v61 = "InterfaceSupport.h";
          unint64_t v62 = "Interface";
          goto LABEL_106;
        }
      }
      else
      {
        uint64_t InterfaceFor = 0;
      }
      uint64_t v63 = (uint64_t *)mlir::DenseElementsAttr::get((uint64_t)v57, InterfaceFor, (llvm::APInt *)__p, (v79 - (llvm::APInt *)__p) >> 4);
      if (mlir::DenseIntElementsAttr::classof((uint64_t)v63))
      {
        size_t v77 = v63;
        *(void *)&long long v86 = mlir::Attribute::cast<mlir::ElementsAttr>(&v77);
        *((void *)&v86 + 1) = v64;
        uint64_t UnknownLoc = mlir::Builder::getUnknownLoc(v75, v64);
        id v66 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ElementsAttr &>((mlir::OpBuilder *)v75, UnknownLoc, (uint64_t)&v86);
        if (!*((_DWORD *)v66 + 9)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        size_t v77 = (uint64_t *)v85;
        std::__hash_table<std::__hash_value_type<void *,mlir::ElementsAttr>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,mlir::ElementsAttr>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,mlir::ElementsAttr>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,mlir::ElementsAttr>>>::__emplace_unique_key_args<void *,void *,mlir::ElementsAttr&>(v74, (uint64_t *)&v77, &v77, &v86);
        int v67 = (llvm::APInt *)__p;
        if (__p)
        {
          BOOL v68 = v79;
          BOOL v69 = __p;
          if (v79 != __p)
          {
            do
            {
              if (*((_DWORD *)v68 - 2) >= 0x41u)
              {
                uint64_t v70 = *((void *)v68 - 2);
                if (v70) {
                  MEMORY[0x1852FDE40](v70, 0x1000C8000313F17);
                }
              }
              BOOL v68 = (llvm::APInt *)((char *)v68 - 16);
            }
            while (v68 != v67);
            BOOL v69 = __p;
          }
          uint64_t v79 = v67;
          operator delete(v69);
        }
        uint64_t v11 = (char *)v66 - 16;
        if (v81)
        {
          uint64_t v82 = (uint64_t *)v81;
          operator delete(v81);
        }
        return (unint64_t)v11;
      }
    }
    int v59 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v60 = 566;
    id v61 = "Casting.h";
    unint64_t v62 = "cast";
LABEL_106:
    __assert_rtn(v62, v61, v60, v59);
  }
  if (v24.u32[0] < 2uLL)
  {
    uint64_t v28 = *(void *)&v20 - 1;
    while (1)
    {
      uint64_t v30 = v27[1];
      if (v30 == v23)
      {
        if (v27[2] == v85) {
          goto LABEL_97;
        }
      }
      else if ((v30 & v28) != v25)
      {
        goto LABEL_37;
      }
      BOOL v27 = (uint64_t *)*v27;
      if (!v27) {
        goto LABEL_37;
      }
    }
  }
  while (1)
  {
    unint64_t v29 = v27[1];
    if (v29 == v23) {
      break;
    }
    if (v29 >= *(void *)&v20) {
      v29 %= *(void *)&v20;
    }
    if (v29 != v25) {
      goto LABEL_37;
    }
LABEL_27:
    BOOL v27 = (uint64_t *)*v27;
    if (!v27) {
      goto LABEL_37;
    }
  }
  if (v27[2] != v85) {
    goto LABEL_27;
  }
LABEL_97:
  long long v86 = *(_OWORD *)(v27 + 3);
  uint64_t v72 = mlir::Builder::getUnknownLoc(a3, v19);
  int v73 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ElementsAttr &>((mlir::OpBuilder *)a3, v72, (uint64_t)&v86);
  if (!*((_DWORD *)v73 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  return (unint64_t)v73 - 16;
}

void sub_180D5B594(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  if (__p)
  {
    a18 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void **std::vector<llvm::APInt>::~vector[abi:ne180100](void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        if (*((_DWORD *)v3 - 2) >= 0x41u)
        {
          uint64_t v5 = *((void *)v3 - 2);
          if (v5) {
            MEMORY[0x1852FDE40](v5, 0x1000C8000313F17);
          }
        }
        v3 -= 16;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t GPU::BaseOpHandler::kernelDAGOp()
{
  if (MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  return 0;
}

void GPU::BaseOpHandler::~BaseOpHandler(GPU::BaseOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);

  JUMPOUT(0x1852FDE70);
}

{
  char *v2;
  id *v3;

  *(void *)this = &unk_1EC99CE60;
  uint64_t v2 = (char *)*((void *)this + 11);
  if (v2 != (char *)this + 112) {
    free(v2);
  }
  uint64_t v3 = (id *)*((void *)this + 10);
  *((void *)this + 10) = 0;
  if (v3)
  {

    MEMORY[0x1852FDE70](v3, 0x1080C40CC6EE3FDLL);
  }
}

uint64_t GPU::BaseOpHandler::setResultIsGraphOutput(uint64_t this, unsigned int a2)
{
  if (*(void *)(this + 96) <= (unint64_t)a2) {
    __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
  }
  *(unsigned char *)(*(void *)(this + 88) + a2) = 1;
  return this;
}

uint64_t std::__function::__func<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::mps::CPUNDArray const&,BOOL)::$_1,std::allocator<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::mps::CPUNDArray const&,BOOL)::$_1>,void ()(void)>::~__func(uint64_t a1)
{
  return a1;
}

void std::__function::__func<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::mps::CPUNDArray const&,BOOL)::$_1,std::allocator<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::mps::CPUNDArray const&,BOOL)::$_1>,void ()(void)>::~__func(uint64_t a1)
{
  JUMPOUT(0x1852FDE70);
}

void *std::__function::__func<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::mps::CPUNDArray const&,BOOL)::$_1,std::allocator<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::mps::CPUNDArray const&,BOOL)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x20uLL);
  *uint64_t v2 = &unk_1EC9D1D08;
  id v3 = *(id *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  v2[1] = v3;
  v2[2] = v4;
  *((unsigned char *)v2 + 24) = *(unsigned char *)(a1 + 24);
  return v2;
}

id std::__function::__func<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::mps::CPUNDArray const&,BOOL)::$_1,std::allocator<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::mps::CPUNDArray const&,BOOL)::$_1>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EC9D1D08;
  id result = *(id *)(a1 + 8);
  *(void *)(a2 + 8) = result;
  char v5 = *(unsigned char *)(a1 + 24);
  *(void *)(a2 + 16) = *(void *)(a1 + 16);
  *(unsigned char *)(a2 + 24) = v5;
  return result;
}

void std::__function::__func<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::mps::CPUNDArray const&,BOOL)::$_1,std::allocator<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::mps::CPUNDArray const&,BOOL)::$_1>,void ()(void)>::destroy(uint64_t a1)
{
}

void std::__function::__func<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::mps::CPUNDArray const&,BOOL)::$_1,std::allocator<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::mps::CPUNDArray const&,BOOL)::$_1>,void ()(void)>::destroy_deallocate(id *a1)
{
  operator delete(a1);
}

void std::__function::__func<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::mps::CPUNDArray const&,BOOL)::$_1,std::allocator<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::mps::CPUNDArray const&,BOOL)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
  [*(id *)(a1 + 8) writeBytes:*(void *)(a1 + 16) strideBytes:0];
  if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v2 = *(void **)(a1 + 16);
    free(v2);
  }
}

uint64_t std::__function::__func<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::mps::CPUNDArray const&,BOOL)::$_1,std::allocator<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::mps::CPUNDArray const&,BOOL)::$_1>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN3GPU13BaseOpHandler16encodeConstantOpEPNS_16EncodeDescriptorERKN4mlir3mps10CPUNDArrayEbE3$_1") {
    return a1 + 8;
  }
  if (((v3 & (unint64_t)"ZN3GPU13BaseOpHandler16encodeConstantOpEPNS_16EncodeDescriptorERKN4mlir3mps10CPUNDArrayEbE3$_1" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3GPU13BaseOpHandler16encodeConstantOpEPNS_16EncodeDescriptorERKN4mlir3mps10CPUNDArrayEbE3$_1"))return 0; {
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3GPU13BaseOpHandler16encodeConstantOpEPNS_16EncodeDescriptorERKN4mlir3mps10CPUNDArrayEbE3$_1" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8;
  }
  return 0;
}

void *std::__function::__func<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::mps::CPUNDArray const&,BOOL)::$_1,std::allocator<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::mps::CPUNDArray const&,BOOL)::$_1>,void ()(void)>::target_type()
{
}

uint64_t std::__split_buffer<llvm::APInt>::~__split_buffer(uint64_t a1)
{
  unint64_t v3 = *(void **)(a1 + 8);
  uint64_t v2 = *(void **)(a1 + 16);
  while (v2 != v3)
  {
    unsigned int v4 = *((_DWORD *)v2 - 2);
    v2 -= 2;
    *(void *)(a1 + 16) = v2;
    if (v4 >= 0x41)
    {
      if (*v2)
      {
        MEMORY[0x1852FDE40](*v2, 0x1000C8000313F17);
        uint64_t v2 = *(void **)(a1 + 16);
      }
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void GPU::DepthwiseConv2DOpHandler::encodeNDArrayOp(GPU::DepthwiseConv2DOpHandler *this, GPU::EncodeDescriptor *a2, NSArray *a3)
{
  v153[2] = *MEMORY[0x1E4F143B8];
  uint64_t v132 = a3;
  uint64_t v5 = *(void *)(*((void *)this + 3) + 48);
  uint64_t v6 = *(void **)(v5 + 16);
  if (v6 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    unint64_t v146 = *(char **)(v5 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v146);
    if (v123 == 21)
    {
      BOOL v124 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      if (v124 && *(void *)((char *)AttrData + 13) == 0x64325F766E6F635FLL)
      {
        __int16 v145 = 1283;
        uint64_t v141 = "classof on '";
        uint64_t v143 = (uint64_t)"mps.depthwise_conv_2d";
        uint64_t v144 = 21;
        uint64_t v137 = "' failed due to the operation not being registered";
        __int16 v140 = 259;
        llvm::operator+((uint64_t *)&v141, (uint64_t *)&v137, (uint64_t)&v146);
        llvm::report_fatal_error((llvm::Twine *)&v146, 1);
      }
    }
LABEL_239:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v6 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id) {
    goto LABEL_239;
  }
  uint64_t v136 = *((void *)this + 3);
  uint64_t Input = (char *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v136);
  Filter = (char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v136);
  uint64_t v9 = *((void *)this + 2);
  unint64_t v146 = Input;
  uint64_t v141 = (const char *)*((void *)mlir::Value::getParentRegion((mlir::Value *)&v146) + 2);
  uint64_t v10 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v9 + 88), (uint64_t *)&v141);
  if (v10
    && (uint64_t v137 = v146,
        (uint64_t v11 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v10 + 3, (uint64_t *)&v137)) != 0))
  {
    id v12 = (id)v11[3];
  }
  else
  {
    id v12 = 0;
  }
  uint64_t v134 = [v12 mpsndarray];

  uint64_t v13 = *((void *)this + 2);
  unint64_t v146 = Filter;
  uint64_t v141 = (const char *)*((void *)mlir::Value::getParentRegion((mlir::Value *)&v146) + 2);
  unint64_t v14 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v13 + 88), (uint64_t *)&v141);
  if (v14
    && (uint64_t v137 = v146,
        (BOOL v15 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v14 + 3, (uint64_t *)&v137)) != 0))
  {
    id v16 = (id)v15[3];
  }
  else
  {
    id v16 = 0;
  }
  uint64_t v133 = [v16 mpsndarray];

  uint64_t v130 = [(NSArray *)v132 objectAtIndexedSubscript:0];
  uint64_t v135 = [v130 mpsndarray];
  if ((!v134 || !v133 || !v135) && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  if (*((void *)this + 4) && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  unint64_t StaticType = (char *)GPURegionRuntime::getStaticType(*((void *)this + 2), (uint64_t)Filter);
  if (!*(void *)StaticType)
  {
    uint64_t v114 = "abstractType && \"Malformed type storage object.\"";
    int v115 = 160;
    uint64_t v116 = "TypeSupport.h";
    int v117 = "getAbstractType";
    goto LABEL_219;
  }
  if (*(_UNKNOWN **)(*(void *)StaticType + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    uint64_t v114 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v115 = 566;
    uint64_t v116 = "Casting.h";
    int v117 = "cast";
LABEL_219:
    __assert_rtn(v117, v116, v115, v114);
  }
  unint64_t v146 = StaticType;
  uint64_t Value = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v146);
  unint64_t v20 = v19;
  unint64_t v21 = (char *)GPURegionRuntime::getStaticType(*((void *)this + 2), (uint64_t)Input);
  if (!*(void *)v21)
  {
    unint64_t v118 = "abstractType && \"Malformed type storage object.\"";
    int v119 = 160;
    long long v120 = "TypeSupport.h";
    uint64_t v121 = "getAbstractType";
    goto LABEL_222;
  }
  if (*(_UNKNOWN **)(*(void *)v21 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    unint64_t v118 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v119 = 566;
    long long v120 = "Casting.h";
    uint64_t v121 = "cast";
LABEL_222:
    __assert_rtn(v121, v120, v119, v118);
  }
  unint64_t v146 = v21;
  unint64_t v22 = (void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v146);
  unint64_t v24 = v23;
  unint64_t v129 = v20;
  uint64_t v25 = v136;
  id v26 = [*(id *)(*((void *)this + 2) + 48) metalDevice];
  uint64_t v152 = v25;
  id v131 = v26;
  uint64_t Strides = mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v152);
  uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v152);
  uint64_t Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v152);
  int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v152);
  if (StorageType)
  {
    if (StorageType == 1)
    {
      if (v24 >= 4)
      {
        unint64_t v29 = v22[1];
        unint64_t v28 = v22[2];
        uint64_t v30 = v22[3];
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v146, Strides, 0);
        unint64_t v127 = v28;
        uint64_t v128 = v30;
        unint64_t v126 = v29;
        uint64_t v31 = Strides;
        uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v141, v31, NumElements);
        unsigned int v33 = 0;
        unint64_t v34 = 1;
        unint64_t v35 = 1;
        while (1)
        {
          BOOL v36 = v146 == v141 && v147 == v142;
          if (v36 && v148 == v143) {
            break;
          }
          mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v146, (llvm::APInt *)&v137);
          int v37 = v138;
          if (v138 < 0x41)
          {
            uint64_t v38 = (uint64_t)v137;
LABEL_32:
            unint64_t v39 = v38;
            switch(v33)
            {
              case 0u:
                if (v38 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
                  goto LABEL_41;
                }
                goto LABEL_44;
              case 1u:
                goto LABEL_45;
              case 2u:
                unint64_t v39 = v34;
                unint64_t v35 = v38;
                break;
              case 3u:
                if (v38 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
                  goto LABEL_41;
                }
                goto LABEL_44;
              default:
                goto LABEL_40;
            }
            goto LABEL_45;
          }
          if (v37 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v137) <= 0x40)
          {
            uint64_t v38 = *(void *)v137;
            if (v33 <= 3) {
              goto LABEL_32;
            }
          }
          else
          {
            uint64_t v38 = -1;
            if (v33 <= 3) {
              goto LABEL_32;
            }
          }
LABEL_40:
          if (MTLReportFailureTypeEnabled())
          {
LABEL_41:
            MTLReportFailure();
            unint64_t v39 = v34;
          }
          else
          {
LABEL_44:
            unint64_t v39 = v34;
          }
LABEL_45:
          if (v138 >= 0x41)
          {
            if (v137) {
              MEMORY[0x1852FDE40](v137, 0x1000C8000313F17);
            }
          }
          ++v148;
          ++v33;
          unint64_t v34 = v39;
        }
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v146, InputAttributeNames, 0);
        uint64_t v68 = InputAttributeNames;
        uint64_t v69 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v141, v68, v69);
        unsigned int v70 = 0;
        uint64_t v53 = 1;
        uint64_t v54 = 1;
        while (1)
        {
          BOOL v71 = v146 == v141 && v147 == v142;
          if (v71 && v148 == v143)
          {
            mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v146, Rewriter, 0);
            uint64_t v75 = Rewriter;
            uint64_t v76 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
            mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v141, v75, v76);
            uint64_t v61 = 0;
            uint64_t v62 = 0;
            for (int i = 0; ; ++i)
            {
              BOOL v78 = v146 == v141 && v147 == v142;
              if (v78 && v148 == v143) {
                break;
              }
              mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v146, (llvm::APInt *)&v137);
              unsigned int v79 = v138;
              if (v138 >= 0x41)
              {
                if (v79 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v137) <= 0x40) {
                  uint64_t v80 = *(void *)v137;
                }
                else {
                  uint64_t v80 = -1;
                }
              }
              else
              {
                uint64_t v80 = (uint64_t)v137;
              }
              if (i == 2) {
                uint64_t v81 = v80;
              }
              else {
                uint64_t v81 = v62;
              }
              if (i == 4) {
                uint64_t v61 = v80;
              }
              else {
                uint64_t v62 = v81;
              }
              if (v79 >= 0x41 && v137) {
                MEMORY[0x1852FDE40](v137, 0x1000C8000313F17);
              }
              ++v148;
            }
            goto LABEL_181;
          }
          mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v146, (llvm::APInt *)&v137);
          int v72 = v138;
          if (v138 < 0x41) {
            break;
          }
          if (v72 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v137) <= 0x40)
          {
            uint64_t v73 = *(void *)v137;
            if (v70 <= 3) {
              goto LABEL_141;
            }
          }
          else
          {
            uint64_t v73 = -1;
            if (v70 <= 3) {
              goto LABEL_141;
            }
          }
LABEL_149:
          if (MTLReportFailureTypeEnabled())
          {
LABEL_150:
            MTLReportFailure();
            uint64_t v74 = v53;
          }
          else
          {
LABEL_153:
            uint64_t v74 = v53;
          }
LABEL_154:
          if (v138 >= 0x41 && v137) {
            MEMORY[0x1852FDE40](v137, 0x1000C8000313F17);
          }
          ++v148;
          ++v70;
          uint64_t v53 = v74;
        }
        uint64_t v73 = (uint64_t)v137;
LABEL_141:
        uint64_t v74 = v73;
        switch(v70)
        {
          case 0u:
            if (v73 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
              goto LABEL_150;
            }
            goto LABEL_153;
          case 1u:
            goto LABEL_154;
          case 2u:
            uint64_t v74 = v53;
            uint64_t v54 = v73;
            break;
          case 3u:
            if (v73 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
              goto LABEL_150;
            }
            goto LABEL_153;
          default:
            goto LABEL_149;
        }
        goto LABEL_154;
      }
      goto LABEL_211;
    }
    float v110 = "0 && \"Unsupported dataLayout\"";
    int v111 = 200;
LABEL_237:
    long long v112 = "GPUDepthwiseConvOps.mm";
    int v113 = "createDepthwiseConv2D";
LABEL_212:
    __assert_rtn(v113, v112, v111, v110);
  }
  if (v24 < 4) {
    goto LABEL_211;
  }
  unint64_t v41 = v22[2];
  unint64_t v40 = v22[3];
  uint64_t v42 = v22[1];
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v146, Strides, 0);
  unint64_t v127 = v40;
  uint64_t v128 = v42;
  unint64_t v126 = v41;
  uint64_t v43 = Strides;
  uint64_t v44 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v141, v43, v44);
  unsigned int v45 = 0;
  unint64_t v34 = 1;
  unint64_t v35 = 1;
  while (1)
  {
    BOOL v46 = v146 == v141 && v147 == v142;
    if (v46 && v148 == v143) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v146, (llvm::APInt *)&v137);
    int v47 = v138;
    if (v138 < 0x41)
    {
      uint64_t v48 = (uint64_t)v137;
LABEL_61:
      unint64_t v49 = v48;
      switch(v45)
      {
        case 0u:
          if (v48 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
            goto LABEL_70;
          }
          goto LABEL_72;
        case 1u:
          if (v48 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
            goto LABEL_70;
          }
          goto LABEL_72;
        case 2u:
          goto LABEL_73;
        case 3u:
          unint64_t v49 = v34;
          unint64_t v35 = v48;
          if (v138 >= 0x41) {
            goto LABEL_74;
          }
          break;
        default:
          goto LABEL_69;
      }
      goto LABEL_52;
    }
    if (v47 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v137) <= 0x40)
    {
      uint64_t v48 = *(void *)v137;
      if (v45 <= 3) {
        goto LABEL_61;
      }
    }
    else
    {
      uint64_t v48 = -1;
      if (v45 <= 3) {
        goto LABEL_61;
      }
    }
LABEL_69:
    if (MTLReportFailureTypeEnabled())
    {
LABEL_70:
      MTLReportFailure();
      unint64_t v49 = v34;
    }
    else
    {
LABEL_72:
      unint64_t v49 = v34;
    }
LABEL_73:
    if (v138 >= 0x41)
    {
LABEL_74:
      if (v137) {
        MEMORY[0x1852FDE40](v137, 0x1000C8000313F17);
      }
    }
LABEL_52:
    ++v148;
    ++v45;
    unint64_t v34 = v49;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v146, InputAttributeNames, 0);
  uint64_t v50 = InputAttributeNames;
  uint64_t v51 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v141, v50, v51);
  unsigned int v52 = 0;
  uint64_t v53 = 1;
  uint64_t v54 = 1;
  while (1)
  {
    BOOL v55 = v146 == v141 && v147 == v142;
    if (v55 && v148 == v143) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v146, (llvm::APInt *)&v137);
    int v56 = v138;
    if (v138 < 0x41)
    {
      uint64_t v57 = (uint64_t)v137;
LABEL_90:
      uint64_t v58 = v57;
      switch(v52)
      {
        case 0u:
          if (v57 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
            goto LABEL_99;
          }
          goto LABEL_101;
        case 1u:
          if (v57 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
            goto LABEL_99;
          }
          goto LABEL_101;
        case 2u:
          goto LABEL_102;
        case 3u:
          uint64_t v58 = v53;
          uint64_t v54 = v57;
          if (v138 >= 0x41) {
            goto LABEL_103;
          }
          break;
        default:
          goto LABEL_98;
      }
      goto LABEL_81;
    }
    if (v56 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v137) <= 0x40)
    {
      uint64_t v57 = *(void *)v137;
      if (v52 <= 3) {
        goto LABEL_90;
      }
    }
    else
    {
      uint64_t v57 = -1;
      if (v52 <= 3) {
        goto LABEL_90;
      }
    }
LABEL_98:
    if (MTLReportFailureTypeEnabled())
    {
LABEL_99:
      MTLReportFailure();
      uint64_t v58 = v53;
    }
    else
    {
LABEL_101:
      uint64_t v58 = v53;
    }
LABEL_102:
    if (v138 >= 0x41)
    {
LABEL_103:
      if (v137) {
        MEMORY[0x1852FDE40](v137, 0x1000C8000313F17);
      }
    }
LABEL_81:
    ++v148;
    ++v52;
    uint64_t v53 = v58;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v146, Rewriter, 0);
  uint64_t v59 = Rewriter;
  uint64_t v60 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v141, v59, v60);
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  for (int j = 0; ; ++j)
  {
    BOOL v64 = v146 == v141 && v147 == v142;
    if (v64 && v148 == v143) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v146, (llvm::APInt *)&v137);
    unsigned int v65 = v138;
    if (v138 >= 0x41)
    {
      if (v65 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v137) <= 0x40) {
        uint64_t v66 = *(void *)v137;
      }
      else {
        uint64_t v66 = -1;
      }
    }
    else
    {
      uint64_t v66 = (uint64_t)v137;
    }
    if (j == 4) {
      uint64_t v67 = v66;
    }
    else {
      uint64_t v67 = v62;
    }
    if (j == 6) {
      uint64_t v61 = v66;
    }
    else {
      uint64_t v62 = v67;
    }
    if (v65 >= 0x41 && v137) {
      MEMORY[0x1852FDE40](v137, 0x1000C8000313F17);
    }
    ++v148;
  }
LABEL_181:
  int PaddingStyle = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v152);
  if (PaddingStyle == 2)
  {
    if (v129 > 3)
    {
      uint64_t v83 = Value + 3;
      uint64_t v84 = Value + 1;
      Value += 2;
      goto LABEL_187;
    }
    goto LABEL_211;
  }
  if (PaddingStyle != 3)
  {
    float v110 = "0 && \"Unsupported weightsFormat\"";
    int v111 = 219;
    goto LABEL_237;
  }
  if (v129 <= 3)
  {
LABEL_211:
    float v110 = "Index < Length && \"Invalid index!\"";
    int v111 = 257;
    long long v112 = "ArrayRef.h";
    int v113 = "operator[]";
    goto LABEL_212;
  }
  uint64_t v83 = Value + 1;
  uint64_t v84 = Value + 2;
LABEL_187:
  uint64_t v85 = *v83;
  uint64_t v86 = *Value;
  if (v128 != *v84 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  int v87 = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v152);
  uint64_t v88 = (v85 - 1) * v54 + 1;
  uint64_t v89 = (v86 - 1) * v53 + 1;
  switch(v87)
  {
    case 0:
      break;
    case 1:
      uint64_t v61 = 0;
      uint64_t v62 = 0;
      break;
    case 2:
    case 4:
      unint64_t v90 = v126 % v34;
      if (!(v126 % v34)) {
        unint64_t v90 = v34;
      }
      unint64_t v91 = (v89 - v90) & ~((uint64_t)(v89 - v90) >> 63);
      unint64_t v92 = v127 % v35;
      if (!(v127 % v35)) {
        unint64_t v92 = v35;
      }
      unint64_t v93 = (v88 - v92) & ~((uint64_t)(v88 - v92) >> 63);
      unint64_t v94 = v91 >> 1;
      unint64_t v95 = v91 - (v91 >> 1);
      unint64_t v96 = v93 >> 1;
      unint64_t v97 = v93 - (v93 >> 1);
      if (v87 == 4) {
        uint64_t v61 = v97;
      }
      else {
        uint64_t v61 = v96;
      }
      if (v87 == 4) {
        uint64_t v62 = v95;
      }
      else {
        uint64_t v62 = v94;
      }
      break;
    default:
      __assert_rtn("createDepthwiseConv2D", "GPUDepthwiseConvOps.mm", 261, "0 && \"Unsupported paddingStyle\"");
  }
  if (v88 >= 0) {
    uint64_t v98 = (v85 - 1) * v54 + 1;
  }
  else {
    uint64_t v98 = (v85 - 1) * v54 + 2;
  }
  if (v89 >= 0) {
    uint64_t v99 = (v86 - 1) * v53 + 1;
  }
  else {
    uint64_t v99 = (v86 - 1) * v53 + 2;
  }
  BOOL v100 = (void *)[objc_alloc(MEMORY[0x1E4F35718]) initWithDevice:v131];
  unint64_t v146 = (char *)((v98 >> 1) - v61);
  id v147 = (id)((v99 >> 1) - v62);
  uint64_t v148 = 0;
  [v100 setWindowOffsets:&v146];
  uint64_t v141 = (const char *)v35;
  unint64_t v142 = v34;
  uint64_t v143 = 1;
  [v100 setConvStrides:&v141];
  uint64_t v137 = (const char *)v54;
  uint64_t v138 = v53;
  uint64_t v139 = 1;
  [v100 setConvDilationRates:&v137];
  objc_msgSend(v100, "setOptions:", objc_msgSend(v100, "options") | 1);

  uint64_t v101 = (int *)MEMORY[0x1E4F359C0];
  if (*((unsigned char *)v135 + (int)*MEMORY[0x1E4F359C0])) {
    objc_msgSend(v135, "setReadCount:", objc_msgSend(v135, "readCount") + 1);
  }
  int v102 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v136);
  uint64_t v103 = v146;
  id v104 = v147;
  int v105 = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v136);
  uint64_t v106 = (char *)v141;
  uint64_t v107 = GPU::EncodeDescriptor::getcomputeEncoder(a2);
  uint64_t v108 = *((void *)a2 + 1);
  v153[0] = v103;
  v153[1] = v106;
  float v109 = [MEMORY[0x1E4F1C978] arrayWithObjects:v153 count:2];
  [v100 encodeToMPSCommandEncoder:v107 commandBuffer:v108 sourceArrays:v109 destinationArray:v104];

  if (*((unsigned char *)v104 + *v101)) {
    objc_msgSend(v104, "setReadCount:", objc_msgSend(v104, "readCount") - 1);
  }
}

void sub_180D5CC0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, void *a15, void *a16, void *a17, void *a18)
{
  _Unwind_Resume(a1);
}

uint64_t mlir::Type::cast<mlir::RankedTensorType>(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!*(void *)result) {
    __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
  }
  if (*(_UNKNOWN **)(*(void *)result + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  return result;
}

void GPU::anonymous namespace'::permuteImage(uint64_t *a1, GPU::EncodeDescriptor *a2, void *a3, void *a4, int a5)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v9 = a3;
  id v10 = a4;
  uint64_t v11 = [v9 descriptor];
  id v12 = [v10 descriptor];
  [v11 numberOfDimensions];
  if ((unint64_t)[v11 numberOfDimensions] <= 3 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  if (a5 == 1)
  {
    uint64_t v19[4] = xmmword_18112A4D0;
    v19[5] = unk_18112A4E0;
    v19[6] = xmmword_18112A4F0;
    v19[7] = unk_18112A500;
    v19[0] = xmmword_18112A490;
    v19[1] = unk_18112A4A0;
    v19[2] = xmmword_18112A4B0;
    v19[3] = unk_18112A4C0;
    [v11 permuteWithDimensionOrder:v19];
    [v12 permuteWithDimensionOrder:v19];
  }
  else if (a5)
  {
    if (MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
  }
  else
  {
    [v11 transposeDimension:2 withDimension:3];
    [v12 transposeDimension:2 withDimension:3];
  }
  uint64_t v13 = *((void *)a2 + 1);
  unint64_t v14 = GPU::EncodeDescriptor::getcomputeEncoder(a2);
  uint64_t v15 = [v9 safeArrayViewWithCommandBuffer:v13 computeEncoder:v14 descriptor:v11 aliasing:0];

  if (!v15) {
    __assert_rtn("permuteImage", "GPUDepthwiseConvOps.mm", 347, "transSource");
  }
  uint64_t v16 = *((void *)a2 + 1);
  uint64_t v17 = GPU::EncodeDescriptor::getcomputeEncoder(a2);
  uint64_t v18 = [v10 safeArrayViewWithCommandBuffer:v16 computeEncoder:v17 descriptor:v12 aliasing:1];

  if (!v18) {
    __assert_rtn("permuteImage", "GPUDepthwiseConvOps.mm", 354, "transDest");
  }
  *a1 = v15;
  a1[1] = v18;
}

void sub_180D5D0D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GPU::anonymous namespace'::permuteWeights(uint64_t a1, GPU::EncodeDescriptor *a2, void *a3, int a4, uint64_t a5)
{
  v45[4] = *MEMORY[0x1E4F143B8];
  id v38 = a3;
  unint64_t v40 = [v38 descriptor];
  if (a4 == 2)
  {
    uint64_t v7 = [v40 getShape];
    uint64_t v20 = [v7 objectAtIndexedSubscript:0];
    unint64_t v21 = [v20 unsignedIntegerValue];

    unint64_t v22 = [v7 objectAtIndexedSubscript:1];
    uint64_t v23 = [v22 unsignedIntegerValue] * v21;

    unint64_t v24 = [NSNumber numberWithUnsignedInteger:v23];
    v42[0] = v24;
    v42[1] = &unk_1EC9EFC00;
    uint64_t v25 = [v7 objectAtIndexedSubscript:2];
    void v42[2] = v25;
    id v26 = [v7 objectAtIndexedSubscript:3];
    v42[3] = v26;
    BOOL v36 = [MEMORY[0x1E4F1C978] arrayWithObjects:v42 count:4];

    BOOL v27 = [NSNumber numberWithUnsignedInteger:v23];
    v41[0] = v27;
    v41[1] = &unk_1EC9EFC00;
    unint64_t v28 = [v7 objectAtIndexedSubscript:2];
    v41[2] = v28;
    unint64_t v29 = [v7 objectAtIndexedSubscript:3];
    v41[3] = v29;
    unint64_t v19 = [MEMORY[0x1E4F1C978] arrayWithObjects:v41 count:4];

    [v40 transposeDimension:2 withDimension:3];
    if (v21 >= 2) {
      [v40 reshapeWithShape:v36];
    }
    goto LABEL_8;
  }
  if (a4 == 3)
  {
    uint64_t v7 = [v40 getShape];
    __int16 v8 = [v7 objectAtIndexedSubscript:3];
    unint64_t v9 = [v8 unsignedIntegerValue];

    id v10 = [v7 objectAtIndexedSubscript:2];
    uint64_t v11 = [v10 unsignedIntegerValue];

    id v12 = [v7 objectAtIndexedSubscript:0];
    v45[0] = v12;
    uint64_t v13 = [v7 objectAtIndexedSubscript:1];
    unint64_t v14 = v11 * v9;
    v45[1] = v13;
    uint64_t v15 = [NSNumber numberWithUnsignedInteger:v14];
    v45[2] = v15;
    v45[3] = &unk_1EC9EFC00;
    BOOL v36 = [MEMORY[0x1E4F1C978] arrayWithObjects:v45 count:4];

    uint64_t v16 = [NSNumber numberWithUnsignedInteger:v14];
    v44[0] = v16;
    v44[1] = &unk_1EC9EFC00;
    uint64_t v17 = [v7 objectAtIndexedSubscript:0];
    v44[2] = v17;
    uint64_t v18 = [v7 objectAtIndexedSubscript:1];
    v44[3] = v18;
    unint64_t v19 = [MEMORY[0x1E4F1C978] arrayWithObjects:v44 count:4];

    if (v9 >= 2) {
      [v40 reshapeWithShape:v36];
    }
    uint64_t v43[4] = xmmword_18112A550;
    v43[5] = unk_18112A560;
    void v43[6] = xmmword_18112A570;
    v43[7] = unk_18112A580;
    v43[0] = xmmword_18112A510;
    v43[1] = unk_18112A520;
    v43[2] = xmmword_18112A530;
    v43[3] = unk_18112A540;
    [v40 permuteWithDimensionOrder:v43];
LABEL_8:

    goto LABEL_13;
  }
  if (MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  unint64_t v19 = 0;
LABEL_13:
  uint64_t v30 = *((void *)a2 + 1);
  uint64_t v31 = GPU::EncodeDescriptor::getcomputeEncoder(a2);
  int v32 = [v38 safeArrayViewWithCommandBuffer:v30 computeEncoder:v31 descriptor:v40 aliasing:a5];

  if (a5 != 1 && !v32) {
    __assert_rtn("permuteWeights", "GPUDepthwiseConvOps.mm", 412, "transWeights || aliasing==MPSAliasingStrategyShallAlias");
  }
  if (v32)
  {
    id v33 = v32;
    *(void *)a1 = v33;
    *(unsigned char *)(a1 + 8) = 0;
  }
  else
  {
    unint64_t v34 = objc_msgSend(MEMORY[0x1E4F35720], "descriptorWithDataType:shape:", objc_msgSend(v40, "dataType"), v19);
    [v34 setPreferPackedRows:1];
    unint64_t v35 = [MEMORY[0x1E4F35988] temporaryNDArrayWithCommandBuffer:*((void *)a2 + 1) descriptor:v34];
    if (!v35) {
      __assert_rtn("permuteWeights", "GPUDepthwiseConvOps.mm", 423, "transWeights");
    }
    id v33 = v35;
    *(void *)a1 = v33;
    *(unsigned char *)(a1 + 8) = 1;
  }
}

void sub_180D5D63C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, void *a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void GPU::DepthwiseConv2DDataGradientOpHandler::encodeNDArrayOp(GPU::DepthwiseConv2DDataGradientOpHandler *this, GPU::EncodeDescriptor *a2, NSArray *a3)
{
  v162[2] = *MEMORY[0x1E4F143B8];
  uint64_t v139 = a3;
  uint64_t v5 = *(void *)(*((void *)this + 3) + 48);
  uint64_t v6 = *(void **)(v5 + 16);
  if (v6 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    int v153 = *(char **)(v5 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v153);
    if (v128 == 35)
    {
      BOOL v129 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      BOOL v130 = v129 && AttrData[2] == 0x61645F64325F766ELL;
      BOOL v131 = v130 && AttrData[3] == 0x69646172675F6174;
      if (v131 && *(void *)((char *)AttrData + 27) == 0x746E656964617267)
      {
        __int16 v152 = 1283;
        uint64_t v148 = "classof on '";
        uint64_t v150 = (uint64_t)"mps.depthwise_conv_2d_data_gradient";
        uint64_t v151 = 35;
        uint64_t v144 = "' failed due to the operation not being registered";
        __int16 v147 = 259;
        llvm::operator+((uint64_t *)&v148, (uint64_t *)&v144, (uint64_t)&v153);
        llvm::report_fatal_error((llvm::Twine *)&v153, 1);
      }
    }
LABEL_247:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v6 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id) {
    goto LABEL_247;
  }
  uint64_t v143 = *((void *)this + 3);
  uint64_t Input = (char *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v143);
  Filter = (char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v143);
  uint64_t v9 = *((void *)this + 2);
  int v153 = Input;
  uint64_t v148 = (const char *)*((void *)mlir::Value::getParentRegion((mlir::Value *)&v153) + 2);
  id v10 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v9 + 88), (uint64_t *)&v148);
  if (v10
    && (uint64_t v144 = v153,
        (uint64_t v11 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v10 + 3, (uint64_t *)&v144)) != 0))
  {
    id v12 = (id)v11[3];
  }
  else
  {
    id v12 = 0;
  }
  uint64_t v141 = [v12 mpsndarray];

  uint64_t v13 = *((void *)this + 2);
  int v153 = Filter;
  uint64_t v148 = (const char *)*((void *)mlir::Value::getParentRegion((mlir::Value *)&v153) + 2);
  unint64_t v14 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v13 + 88), (uint64_t *)&v148);
  if (v14
    && (uint64_t v144 = v153,
        (uint64_t v15 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v14 + 3, (uint64_t *)&v144)) != 0))
  {
    id v16 = (id)v15[3];
  }
  else
  {
    id v16 = 0;
  }
  __int16 v140 = [v16 mpsndarray];

  uint64_t v137 = [(NSArray *)v139 objectAtIndexedSubscript:0];
  unint64_t v142 = [v137 mpsndarray];
  if ((!v141 || !v140 || !v142) && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  if (*((void *)this + 4) && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  uint64_t v17 = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v143);
  unint64_t StaticType = (char *)GPURegionRuntime::getStaticType(*((void *)this + 2), v17);
  if (!*(void *)StaticType)
  {
    int v119 = "abstractType && \"Malformed type storage object.\"";
    int v120 = 160;
    uint64_t v121 = "TypeSupport.h";
    std::vector<int>::pointer v122 = "getAbstractType";
    goto LABEL_221;
  }
  if (*(_UNKNOWN **)(*(void *)StaticType + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    int v119 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v120 = 566;
    uint64_t v121 = "Casting.h";
    std::vector<int>::pointer v122 = "cast";
LABEL_221:
    __assert_rtn(v122, v121, v120, v119);
  }
  int v153 = StaticType;
  uint64_t Value = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v153);
  unint64_t v21 = v20;
  uint64_t Result = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v143);
  uint64_t v23 = (char *)GPURegionRuntime::getStaticType(*((void *)this + 2), Result);
  if (!*(void *)v23)
  {
    uint64_t v123 = "abstractType && \"Malformed type storage object.\"";
    int v124 = 160;
    uint64_t v125 = "TypeSupport.h";
    unint64_t v126 = "getAbstractType";
    goto LABEL_224;
  }
  if (*(_UNKNOWN **)(*(void *)v23 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    uint64_t v123 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v124 = 566;
    uint64_t v125 = "Casting.h";
    unint64_t v126 = "cast";
LABEL_224:
    __assert_rtn(v126, v125, v124, v123);
  }
  int v153 = v23;
  unint64_t v24 = (void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v153);
  unint64_t v26 = v25;
  unint64_t v136 = v21;
  uint64_t v27 = v143;
  unint64_t v28 = [*(id *)(*((void *)this + 2) + 48) metalDevice];
  uint64_t v159 = v27;
  id v138 = v28;
  uint64_t Strides = mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v159);
  uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v159);
  uint64_t Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v159);
  int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v159);
  if (StorageType)
  {
    if (StorageType == 1)
    {
      if (v26 >= 4)
      {
        unint64_t v31 = v24[1];
        unint64_t v30 = v24[2];
        uint64_t v32 = v24[3];
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v153, Strides, 0);
        unint64_t v134 = v30;
        uint64_t v135 = v32;
        unint64_t v133 = v31;
        uint64_t v33 = Strides;
        uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v148, v33, NumElements);
        unsigned int v35 = 0;
        unint64_t v36 = 1;
        unint64_t v37 = 1;
        while (1)
        {
          BOOL v38 = v153 == v148 && v154 == v149;
          if (v38 && v155 == v150) {
            break;
          }
          mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v153, (llvm::APInt *)&v144);
          int v39 = v145;
          if (v145 < 0x41)
          {
            uint64_t v40 = (uint64_t)v144;
LABEL_32:
            unint64_t v41 = v40;
            switch(v35)
            {
              case 0u:
                if (v40 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
                  goto LABEL_41;
                }
                goto LABEL_44;
              case 1u:
                goto LABEL_45;
              case 2u:
                unint64_t v41 = v36;
                unint64_t v37 = v40;
                break;
              case 3u:
                if (v40 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
                  goto LABEL_41;
                }
                goto LABEL_44;
              default:
                goto LABEL_40;
            }
            goto LABEL_45;
          }
          if (v39 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v144) <= 0x40)
          {
            uint64_t v40 = *(void *)v144;
            if (v35 <= 3) {
              goto LABEL_32;
            }
          }
          else
          {
            uint64_t v40 = -1;
            if (v35 <= 3) {
              goto LABEL_32;
            }
          }
LABEL_40:
          if (MTLReportFailureTypeEnabled())
          {
LABEL_41:
            MTLReportFailure();
            unint64_t v41 = v36;
          }
          else
          {
LABEL_44:
            unint64_t v41 = v36;
          }
LABEL_45:
          if (v145 >= 0x41)
          {
            if (v144) {
              MEMORY[0x1852FDE40](v144, 0x1000C8000313F17);
            }
          }
          ++v155;
          ++v35;
          unint64_t v36 = v41;
        }
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v153, InputAttributeNames, 0);
        uint64_t v70 = InputAttributeNames;
        uint64_t v71 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v148, v70, v71);
        unsigned int v72 = 0;
        uint64_t v55 = 1;
        uint64_t v56 = 1;
        while (1)
        {
          BOOL v73 = v153 == v148 && v154 == v149;
          if (v73 && v155 == v150)
          {
            mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v153, Rewriter, 0);
            uint64_t v77 = Rewriter;
            uint64_t v78 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
            mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v148, v77, v78);
            uint64_t v63 = 0;
            uint64_t v64 = 0;
            for (int i = 0; ; ++i)
            {
              BOOL v80 = v153 == v148 && v154 == v149;
              if (v80 && v155 == v150) {
                break;
              }
              mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v153, (llvm::APInt *)&v144);
              unsigned int v81 = v145;
              if (v145 >= 0x41)
              {
                if (v81 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v144) <= 0x40) {
                  uint64_t v82 = *(void *)v144;
                }
                else {
                  uint64_t v82 = -1;
                }
              }
              else
              {
                uint64_t v82 = (uint64_t)v144;
              }
              if (i == 2) {
                uint64_t v83 = v82;
              }
              else {
                uint64_t v83 = v64;
              }
              if (i == 4) {
                uint64_t v63 = v82;
              }
              else {
                uint64_t v64 = v83;
              }
              if (v81 >= 0x41 && v144) {
                MEMORY[0x1852FDE40](v144, 0x1000C8000313F17);
              }
              ++v155;
            }
            goto LABEL_181;
          }
          mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v153, (llvm::APInt *)&v144);
          int v74 = v145;
          if (v145 < 0x41) {
            break;
          }
          if (v74 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v144) <= 0x40)
          {
            uint64_t v75 = *(void *)v144;
            if (v72 <= 3) {
              goto LABEL_141;
            }
          }
          else
          {
            uint64_t v75 = -1;
            if (v72 <= 3) {
              goto LABEL_141;
            }
          }
LABEL_149:
          if (MTLReportFailureTypeEnabled())
          {
LABEL_150:
            MTLReportFailure();
            uint64_t v76 = v55;
          }
          else
          {
LABEL_153:
            uint64_t v76 = v55;
          }
LABEL_154:
          if (v145 >= 0x41 && v144) {
            MEMORY[0x1852FDE40](v144, 0x1000C8000313F17);
          }
          ++v155;
          ++v72;
          uint64_t v55 = v76;
        }
        uint64_t v75 = (uint64_t)v144;
LABEL_141:
        uint64_t v76 = v75;
        switch(v72)
        {
          case 0u:
            if (v75 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
              goto LABEL_150;
            }
            goto LABEL_153;
          case 1u:
            goto LABEL_154;
          case 2u:
            uint64_t v76 = v55;
            uint64_t v56 = v75;
            break;
          case 3u:
            if (v75 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
              goto LABEL_150;
            }
            goto LABEL_153;
          default:
            goto LABEL_149;
        }
        goto LABEL_154;
      }
      goto LABEL_213;
    }
    int v115 = "0 && \"Unsupported dataLayout\"";
    int v116 = 200;
LABEL_245:
    int v117 = "GPUDepthwiseConvOps.mm";
    unint64_t v118 = "createDepthwiseConv2D";
LABEL_214:
    __assert_rtn(v118, v117, v116, v115);
  }
  if (v26 < 4) {
    goto LABEL_213;
  }
  unint64_t v43 = v24[2];
  unint64_t v42 = v24[3];
  uint64_t v44 = v24[1];
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v153, Strides, 0);
  unint64_t v134 = v42;
  uint64_t v135 = v44;
  unint64_t v133 = v43;
  uint64_t v45 = Strides;
  uint64_t v46 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v148, v45, v46);
  unsigned int v47 = 0;
  unint64_t v36 = 1;
  unint64_t v37 = 1;
  while (1)
  {
    BOOL v48 = v153 == v148 && v154 == v149;
    if (v48 && v155 == v150) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v153, (llvm::APInt *)&v144);
    int v49 = v145;
    if (v145 < 0x41)
    {
      uint64_t v50 = (uint64_t)v144;
LABEL_61:
      unint64_t v51 = v50;
      switch(v47)
      {
        case 0u:
          if (v50 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
            goto LABEL_70;
          }
          goto LABEL_72;
        case 1u:
          if (v50 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
            goto LABEL_70;
          }
          goto LABEL_72;
        case 2u:
          goto LABEL_73;
        case 3u:
          unint64_t v51 = v36;
          unint64_t v37 = v50;
          if (v145 >= 0x41) {
            goto LABEL_74;
          }
          break;
        default:
          goto LABEL_69;
      }
      goto LABEL_52;
    }
    if (v49 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v144) <= 0x40)
    {
      uint64_t v50 = *(void *)v144;
      if (v47 <= 3) {
        goto LABEL_61;
      }
    }
    else
    {
      uint64_t v50 = -1;
      if (v47 <= 3) {
        goto LABEL_61;
      }
    }
LABEL_69:
    if (MTLReportFailureTypeEnabled())
    {
LABEL_70:
      MTLReportFailure();
      unint64_t v51 = v36;
    }
    else
    {
LABEL_72:
      unint64_t v51 = v36;
    }
LABEL_73:
    if (v145 >= 0x41)
    {
LABEL_74:
      if (v144) {
        MEMORY[0x1852FDE40](v144, 0x1000C8000313F17);
      }
    }
LABEL_52:
    ++v155;
    ++v47;
    unint64_t v36 = v51;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v153, InputAttributeNames, 0);
  uint64_t v52 = InputAttributeNames;
  uint64_t v53 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v148, v52, v53);
  unsigned int v54 = 0;
  uint64_t v55 = 1;
  uint64_t v56 = 1;
  while (1)
  {
    BOOL v57 = v153 == v148 && v154 == v149;
    if (v57 && v155 == v150) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v153, (llvm::APInt *)&v144);
    int v58 = v145;
    if (v145 < 0x41)
    {
      uint64_t v59 = (uint64_t)v144;
LABEL_90:
      uint64_t v60 = v59;
      switch(v54)
      {
        case 0u:
          if (v59 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
            goto LABEL_99;
          }
          goto LABEL_101;
        case 1u:
          if (v59 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
            goto LABEL_99;
          }
          goto LABEL_101;
        case 2u:
          goto LABEL_102;
        case 3u:
          uint64_t v60 = v55;
          uint64_t v56 = v59;
          if (v145 >= 0x41) {
            goto LABEL_103;
          }
          break;
        default:
          goto LABEL_98;
      }
      goto LABEL_81;
    }
    if (v58 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v144) <= 0x40)
    {
      uint64_t v59 = *(void *)v144;
      if (v54 <= 3) {
        goto LABEL_90;
      }
    }
    else
    {
      uint64_t v59 = -1;
      if (v54 <= 3) {
        goto LABEL_90;
      }
    }
LABEL_98:
    if (MTLReportFailureTypeEnabled())
    {
LABEL_99:
      MTLReportFailure();
      uint64_t v60 = v55;
    }
    else
    {
LABEL_101:
      uint64_t v60 = v55;
    }
LABEL_102:
    if (v145 >= 0x41)
    {
LABEL_103:
      if (v144) {
        MEMORY[0x1852FDE40](v144, 0x1000C8000313F17);
      }
    }
LABEL_81:
    ++v155;
    ++v54;
    uint64_t v55 = v60;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v153, Rewriter, 0);
  uint64_t v61 = Rewriter;
  uint64_t v62 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v148, v61, v62);
  uint64_t v63 = 0;
  uint64_t v64 = 0;
  for (int j = 0; ; ++j)
  {
    BOOL v66 = v153 == v148 && v154 == v149;
    if (v66 && v155 == v150) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v153, (llvm::APInt *)&v144);
    unsigned int v67 = v145;
    if (v145 >= 0x41)
    {
      if (v67 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v144) <= 0x40) {
        uint64_t v68 = *(void *)v144;
      }
      else {
        uint64_t v68 = -1;
      }
    }
    else
    {
      uint64_t v68 = (uint64_t)v144;
    }
    if (j == 4) {
      uint64_t v69 = v68;
    }
    else {
      uint64_t v69 = v64;
    }
    if (j == 6) {
      uint64_t v63 = v68;
    }
    else {
      uint64_t v64 = v69;
    }
    if (v67 >= 0x41 && v144) {
      MEMORY[0x1852FDE40](v144, 0x1000C8000313F17);
    }
    ++v155;
  }
LABEL_181:
  int PaddingStyle = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v159);
  if (PaddingStyle == 2)
  {
    if (v136 > 3)
    {
      uint64_t v85 = Value + 3;
      uint64_t v86 = Value + 1;
      Value += 2;
      goto LABEL_187;
    }
    goto LABEL_213;
  }
  if (PaddingStyle != 3)
  {
    int v115 = "0 && \"Unsupported weightsFormat\"";
    int v116 = 219;
    goto LABEL_245;
  }
  if (v136 <= 3)
  {
LABEL_213:
    int v115 = "Index < Length && \"Invalid index!\"";
    int v116 = 257;
    int v117 = "ArrayRef.h";
    unint64_t v118 = "operator[]";
    goto LABEL_214;
  }
  uint64_t v85 = Value + 1;
  uint64_t v86 = Value + 2;
LABEL_187:
  uint64_t v87 = *v85;
  uint64_t v88 = *Value;
  if (v135 != *v86 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  int v89 = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v159);
  uint64_t v90 = (v87 - 1) * v56 + 1;
  uint64_t v91 = (v88 - 1) * v55 + 1;
  switch(v89)
  {
    case 0:
      break;
    case 1:
      uint64_t v63 = 0;
      uint64_t v64 = 0;
      break;
    case 2:
    case 4:
      unint64_t v92 = v133 % v36;
      if (!(v133 % v36)) {
        unint64_t v92 = v36;
      }
      unint64_t v93 = (v91 - v92) & ~((uint64_t)(v91 - v92) >> 63);
      unint64_t v94 = v134 % v37;
      if (!(v134 % v37)) {
        unint64_t v94 = v37;
      }
      unint64_t v95 = (v90 - v94) & ~((uint64_t)(v90 - v94) >> 63);
      unint64_t v96 = v93 >> 1;
      unint64_t v97 = v93 - (v93 >> 1);
      unint64_t v98 = v95 >> 1;
      unint64_t v99 = v95 - (v95 >> 1);
      if (v89 == 4) {
        uint64_t v63 = v99;
      }
      else {
        uint64_t v63 = v98;
      }
      if (v89 == 4) {
        uint64_t v64 = v97;
      }
      else {
        uint64_t v64 = v96;
      }
      break;
    default:
      __assert_rtn("createDepthwiseConv2D", "GPUDepthwiseConvOps.mm", 261, "0 && \"Unsupported paddingStyle\"");
  }
  if (v90 >= 0) {
    uint64_t v100 = (v87 - 1) * v56 + 1;
  }
  else {
    uint64_t v100 = (v87 - 1) * v56 + 2;
  }
  if (v91 >= 0) {
    uint64_t v101 = v91;
  }
  else {
    uint64_t v101 = v91 + 1;
  }
  int v102 = (void *)[objc_alloc(MEMORY[0x1E4F35718]) initWithDevice:v138];
  int v153 = (char *)((v100 >> 1) - v63);
  id v154 = (id)((v101 >> 1) - v64);
  uint64_t v155 = 0;
  [v102 setWindowOffsets:&v153];
  uint64_t v148 = (const char *)v37;
  unint64_t v149 = v36;
  uint64_t v150 = 1;
  [v102 setConvStrides:&v148];
  uint64_t v144 = (const char *)v56;
  uint64_t v145 = v55;
  uint64_t v146 = 1;
  [v102 setConvDilationRates:&v144];
  objc_msgSend(v102, "setOptions:", objc_msgSend(v102, "options") | 1);

  if (*((unsigned char *)v142 + (int)*MEMORY[0x1E4F359C0])) {
    objc_msgSend(v142, "setReadCount:", objc_msgSend(v142, "readCount") + 1);
  }
  int v103 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v143);
  id v104 = v153;
  id v105 = v154;
  int v106 = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v143);
  uint64_t v107 = (char *)v148;
  if (*((unsigned char *)v105 + (int)*MEMORY[0x1E4F359C0])) {
    objc_msgSend(v105, "setReadCount:", objc_msgSend(v105, "readCount") + 1);
  }
  v162[0] = v105;
  v162[1] = v107;
  uint64_t v108 = [MEMORY[0x1E4F1C978] arrayWithObjects:v162 count:2];
  float v109 = [v102 resultStateForSourceArrays:v108 sourceStates:0 destinationArray:v105];

  float v110 = GPU::EncodeDescriptor::getcomputeEncoder(a2);
  uint64_t v111 = *((void *)a2 + 1);
  v161[0] = v105;
  v161[1] = v107;
  long long v112 = [MEMORY[0x1E4F1C978] arrayWithObjects:v161 count:2];
  v160[0] = v105;
  int v113 = [MEMORY[0x1E4F1CA98] null];
  v160[1] = v113;
  uint64_t v114 = [MEMORY[0x1E4F1C978] arrayWithObjects:v160 count:2];
  [v102 encodeGradientsToCommandEncoder:v110 commandBuffer:v111 sourceArrays:v112 sourceGradient:v104 gradientState:v109 destinationGradients:v114 kernelDAGObject:0];

  if (*((unsigned char *)v105 + (int)*MEMORY[0x1E4F359C0])) {
    objc_msgSend(v105, "setReadCount:", objc_msgSend(v105, "readCount") - 1);
  }
}

void sub_180D5E9D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, void *a17, void *a18, void *a19, void *a20)
{
  _Unwind_Resume(a1);
}

unint64_t GPU::DepthwiseConv2DDataGradientOpHandler::getJITStaticOperandRepr(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  if (a4 == 2) {
    return GPU::BaseOpHandler::_getJITStaticOperandReprConstant(this, a2, a3, 2u);
  }
  else {
    return GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(this, a2, a3, a4);
  }
}

void GPU::DepthwiseConv2DWeightsGradientOpHandler::encodeNDArrayOp(GPU::DepthwiseConv2DWeightsGradientOpHandler *this, id *a2, NSArray *a3)
{
  uint64_t v199 = *MEMORY[0x1E4F143B8];
  int v163 = a3;
  uint64_t v4 = *(void *)(*((void *)this + 3) + 48);
  uint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    *(void *)&long long v191 = *(void *)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v191);
    if (v150 == 38)
    {
      BOOL v151 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      BOOL v152 = v151 && AttrData[2] == 0x65775F64325F766ELL;
      BOOL v153 = v152 && AttrData[3] == 0x72675F7374686769;
      if (v153 && *(void *)((char *)AttrData + 30) == 0x746E656964617267)
      {
        __int16 v189 = 1283;
        uint64_t v185 = "classof on '";
        uint64_t v187 = (uint64_t)"mps.depthwise_conv_2d_weights_gradient";
        uint64_t v188 = 38;
        int v176 = "' failed due to the operation not being registered";
        __int16 v179 = 259;
        llvm::operator+((uint64_t *)&v185, (uint64_t *)&v176, (uint64_t)&v191);
        llvm::report_fatal_error((llvm::Twine *)&v191, 1);
      }
    }
LABEL_260:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DWeightsGradientOp,void>::id) {
    goto LABEL_260;
  }
  uint64_t v175 = (void *)*((void *)this + 3);
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v175);
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v175);
  uint64_t v8 = *((void *)this + 2);
  *(void *)&long long v191 = Input;
  uint64_t v185 = (const char *)*((void *)mlir::Value::getParentRegion((mlir::Value *)&v191) + 2);
  uint64_t v9 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v8 + 88), (uint64_t *)&v185);
  if (v9
    && (int v176 = (char *)v191,
        (id v10 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v9 + 3, (uint64_t *)&v176)) != 0))
  {
    id v11 = (id)v10[3];
  }
  else
  {
    id v11 = 0;
  }
  uint64_t v168 = this;
  uint64_t v167 = [v11 mpsndarray];

  uint64_t v12 = *((void *)this + 2);
  *(void *)&long long v191 = Filter;
  uint64_t v185 = (const char *)*((void *)mlir::Value::getParentRegion((mlir::Value *)&v191) + 2);
  uint64_t v13 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v12 + 88), (uint64_t *)&v185);
  if (v13
    && (int v176 = (char *)v191,
        (unint64_t v14 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v13 + 3, (uint64_t *)&v176)) != 0))
  {
    id v15 = (id)v14[3];
  }
  else
  {
    id v15 = 0;
  }
  int v166 = [v15 mpsndarray];

  std::vector<int>::pointer v158 = [(NSArray *)v163 objectAtIndexedSubscript:0];
  v171 = [v158 mpsndarray];
  if ((!v167 || !v166 || !v171) && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  if (*((void *)this + 4) && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  uint64_t Result = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v175);
  unint64_t StaticType = GPURegionRuntime::getStaticType(*((void *)this + 2), Result);
  if (!*(void *)StaticType)
  {
    uint64_t v141 = "abstractType && \"Malformed type storage object.\"";
    int v142 = 160;
    uint64_t v143 = "TypeSupport.h";
    uint64_t v144 = "getAbstractType";
    goto LABEL_233;
  }
  if (*(_UNKNOWN **)(*(void *)StaticType + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    uint64_t v141 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v142 = 566;
    uint64_t v143 = "Casting.h";
    uint64_t v144 = "cast";
LABEL_233:
    __assert_rtn(v144, v143, v142, v141);
  }
  *(void *)&long long v191 = StaticType;
  uint64_t Value = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v191);
  unint64_t v20 = v19;
  unint64_t v21 = GPURegionRuntime::getStaticType(*((void *)this + 2), Filter);
  if (!*(void *)v21)
  {
    uint64_t v145 = "abstractType && \"Malformed type storage object.\"";
    int v146 = 160;
    __int16 v147 = "TypeSupport.h";
    uint64_t v148 = "getAbstractType";
    goto LABEL_236;
  }
  if (*(_UNKNOWN **)(*(void *)v21 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    uint64_t v145 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v146 = 566;
    __int16 v147 = "Casting.h";
    uint64_t v148 = "cast";
LABEL_236:
    __assert_rtn(v148, v147, v146, v145);
  }
  *(void *)&long long v191 = v21;
  unint64_t v22 = (void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v191);
  unint64_t v24 = v23;
  unint64_t v169 = v20;
  unint64_t v25 = v175;
  [*(id *)(*((void *)this + 2) + 48) metalDevice];
  id v173 = v25;
  id v26 = (id)objc_claimAutoreleasedReturnValue();
  uint64_t Strides = mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v173);
  uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v173);
  uint64_t Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v173);
  int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v173);
  if (StorageType)
  {
    if (StorageType == 1)
    {
      if (v24 >= 4)
      {
        unint64_t v29 = v22[1];
        unint64_t v28 = v22[2];
        uint64_t v30 = v22[3];
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v191, Strides, 0);
        uint64_t v164 = v30;
        unint64_t v159 = v29;
        unint64_t v161 = v28;
        uint64_t v31 = Strides;
        uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v185, v31, NumElements);
        unsigned int v33 = 0;
        unint64_t v34 = 1;
        unint64_t v35 = 1;
        while (1)
        {
          BOOL v36 = (const char *)v191 == v185 && BYTE8(v191) == v186;
          if (v36 && (void)v192 == v187) {
            break;
          }
          mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v191, (llvm::APInt *)&v176);
          int v37 = (int)v177;
          if (v177 < 0x41)
          {
            uint64_t v38 = (uint64_t)v176;
LABEL_32:
            unint64_t v39 = v38;
            switch(v33)
            {
              case 0u:
                if (v38 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
                  goto LABEL_41;
                }
                goto LABEL_44;
              case 1u:
                goto LABEL_45;
              case 2u:
                unint64_t v39 = v34;
                unint64_t v35 = v38;
                break;
              case 3u:
                if (v38 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
                  goto LABEL_41;
                }
                goto LABEL_44;
              default:
                goto LABEL_40;
            }
            goto LABEL_45;
          }
          if (v37 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v176) <= 0x40)
          {
            uint64_t v38 = *(void *)v176;
            if (v33 <= 3) {
              goto LABEL_32;
            }
          }
          else
          {
            uint64_t v38 = -1;
            if (v33 <= 3) {
              goto LABEL_32;
            }
          }
LABEL_40:
          if (MTLReportFailureTypeEnabled())
          {
LABEL_41:
            MTLReportFailure();
            unint64_t v39 = v34;
          }
          else
          {
LABEL_44:
            unint64_t v39 = v34;
          }
LABEL_45:
          if (v177 >= 0x41)
          {
            if (v176) {
              MEMORY[0x1852FDE40](v176, 0x1000C8000313F17);
            }
          }
          *(void *)&long long v192 = v192 + 1;
          ++v33;
          unint64_t v34 = v39;
        }
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v191, InputAttributeNames, 0);
        uint64_t v68 = InputAttributeNames;
        uint64_t v69 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v185, v68, v69);
        unsigned int v70 = 0;
        uint64_t v53 = 1;
        uint64_t v54 = 1;
        while (1)
        {
          BOOL v71 = (const char *)v191 == v185 && BYTE8(v191) == v186;
          if (v71 && (void)v192 == v187)
          {
            mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v191, Rewriter, 0);
            uint64_t v75 = Rewriter;
            uint64_t v76 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
            mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v185, v75, v76);
            uint64_t v61 = 0;
            uint64_t v62 = 0;
            for (int i = 0; ; ++i)
            {
              BOOL v78 = (const char *)v191 == v185 && BYTE8(v191) == v186;
              if (v78 && (void)v192 == v187) {
                break;
              }
              mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v191, (llvm::APInt *)&v176);
              unsigned int v79 = v177;
              if (v177 >= 0x41)
              {
                if (v79 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v176) <= 0x40) {
                  uint64_t v80 = *(void *)v176;
                }
                else {
                  uint64_t v80 = -1;
                }
              }
              else
              {
                uint64_t v80 = (uint64_t)v176;
              }
              if (i == 2) {
                uint64_t v81 = v80;
              }
              else {
                uint64_t v81 = v62;
              }
              if (i == 4) {
                uint64_t v61 = v80;
              }
              else {
                uint64_t v62 = v81;
              }
              if (v79 >= 0x41 && v176) {
                MEMORY[0x1852FDE40](v176, 0x1000C8000313F17);
              }
              *(void *)&long long v192 = v192 + 1;
            }
            goto LABEL_181;
          }
          mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v191, (llvm::APInt *)&v176);
          int v72 = (int)v177;
          if (v177 < 0x41) {
            break;
          }
          if (v72 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v176) <= 0x40)
          {
            uint64_t v73 = *(void *)v176;
            if (v70 <= 3) {
              goto LABEL_141;
            }
          }
          else
          {
            uint64_t v73 = -1;
            if (v70 <= 3) {
              goto LABEL_141;
            }
          }
LABEL_149:
          if (MTLReportFailureTypeEnabled())
          {
LABEL_150:
            MTLReportFailure();
            uint64_t v74 = v53;
          }
          else
          {
LABEL_153:
            uint64_t v74 = v53;
          }
LABEL_154:
          if (v177 >= 0x41 && v176) {
            MEMORY[0x1852FDE40](v176, 0x1000C8000313F17);
          }
          *(void *)&long long v192 = v192 + 1;
          ++v70;
          uint64_t v53 = v74;
        }
        uint64_t v73 = (uint64_t)v176;
LABEL_141:
        uint64_t v74 = v73;
        switch(v70)
        {
          case 0u:
            if (v73 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
              goto LABEL_150;
            }
            goto LABEL_153;
          case 1u:
            goto LABEL_154;
          case 2u:
            uint64_t v74 = v53;
            uint64_t v54 = v73;
            break;
          case 3u:
            if (v73 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
              goto LABEL_150;
            }
            goto LABEL_153;
          default:
            goto LABEL_149;
        }
        goto LABEL_154;
      }
      goto LABEL_225;
    }
    uint64_t v137 = "0 && \"Unsupported dataLayout\"";
    int v138 = 200;
LABEL_258:
    uint64_t v139 = "GPUDepthwiseConvOps.mm";
    __int16 v140 = "createDepthwiseConv2D";
LABEL_226:
    __assert_rtn(v140, v139, v138, v137);
  }
  if (v24 < 4) {
    goto LABEL_225;
  }
  unint64_t v41 = v22[2];
  unint64_t v40 = v22[3];
  uint64_t v42 = v22[1];
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v191, Strides, 0);
  uint64_t v164 = v42;
  unint64_t v159 = v41;
  unint64_t v161 = v40;
  uint64_t v43 = Strides;
  uint64_t v44 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v185, v43, v44);
  unsigned int v45 = 0;
  unint64_t v34 = 1;
  unint64_t v35 = 1;
  while (1)
  {
    BOOL v46 = (const char *)v191 == v185 && BYTE8(v191) == v186;
    if (v46 && (void)v192 == v187) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v191, (llvm::APInt *)&v176);
    int v47 = (int)v177;
    if (v177 < 0x41)
    {
      uint64_t v48 = (uint64_t)v176;
LABEL_61:
      unint64_t v49 = v48;
      switch(v45)
      {
        case 0u:
          if (v48 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
            goto LABEL_70;
          }
          goto LABEL_72;
        case 1u:
          if (v48 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
            goto LABEL_70;
          }
          goto LABEL_72;
        case 2u:
          goto LABEL_73;
        case 3u:
          unint64_t v49 = v34;
          unint64_t v35 = v48;
          if (v177 >= 0x41) {
            goto LABEL_74;
          }
          break;
        default:
          goto LABEL_69;
      }
      goto LABEL_52;
    }
    if (v47 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v176) <= 0x40)
    {
      uint64_t v48 = *(void *)v176;
      if (v45 <= 3) {
        goto LABEL_61;
      }
    }
    else
    {
      uint64_t v48 = -1;
      if (v45 <= 3) {
        goto LABEL_61;
      }
    }
LABEL_69:
    if (MTLReportFailureTypeEnabled())
    {
LABEL_70:
      MTLReportFailure();
      unint64_t v49 = v34;
    }
    else
    {
LABEL_72:
      unint64_t v49 = v34;
    }
LABEL_73:
    if (v177 >= 0x41)
    {
LABEL_74:
      if (v176) {
        MEMORY[0x1852FDE40](v176, 0x1000C8000313F17);
      }
    }
LABEL_52:
    *(void *)&long long v192 = v192 + 1;
    ++v45;
    unint64_t v34 = v49;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v191, InputAttributeNames, 0);
  uint64_t v50 = InputAttributeNames;
  uint64_t v51 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v185, v50, v51);
  unsigned int v52 = 0;
  uint64_t v53 = 1;
  uint64_t v54 = 1;
  while (1)
  {
    BOOL v55 = (const char *)v191 == v185 && BYTE8(v191) == v186;
    if (v55 && (void)v192 == v187) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v191, (llvm::APInt *)&v176);
    int v56 = (int)v177;
    if (v177 < 0x41)
    {
      uint64_t v57 = (uint64_t)v176;
LABEL_90:
      uint64_t v58 = v57;
      switch(v52)
      {
        case 0u:
          if (v57 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
            goto LABEL_99;
          }
          goto LABEL_101;
        case 1u:
          if (v57 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
            goto LABEL_99;
          }
          goto LABEL_101;
        case 2u:
          goto LABEL_102;
        case 3u:
          uint64_t v58 = v53;
          uint64_t v54 = v57;
          if (v177 >= 0x41) {
            goto LABEL_103;
          }
          break;
        default:
          goto LABEL_98;
      }
      goto LABEL_81;
    }
    if (v56 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v176) <= 0x40)
    {
      uint64_t v57 = *(void *)v176;
      if (v52 <= 3) {
        goto LABEL_90;
      }
    }
    else
    {
      uint64_t v57 = -1;
      if (v52 <= 3) {
        goto LABEL_90;
      }
    }
LABEL_98:
    if (MTLReportFailureTypeEnabled())
    {
LABEL_99:
      MTLReportFailure();
      uint64_t v58 = v53;
    }
    else
    {
LABEL_101:
      uint64_t v58 = v53;
    }
LABEL_102:
    if (v177 >= 0x41)
    {
LABEL_103:
      if (v176) {
        MEMORY[0x1852FDE40](v176, 0x1000C8000313F17);
      }
    }
LABEL_81:
    *(void *)&long long v192 = v192 + 1;
    ++v52;
    uint64_t v53 = v58;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v191, Rewriter, 0);
  uint64_t v59 = Rewriter;
  uint64_t v60 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v185, v59, v60);
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  for (int j = 0; ; ++j)
  {
    BOOL v64 = (const char *)v191 == v185 && BYTE8(v191) == v186;
    if (v64 && (void)v192 == v187) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v191, (llvm::APInt *)&v176);
    unsigned int v65 = v177;
    if (v177 >= 0x41)
    {
      if (v65 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v176) <= 0x40) {
        uint64_t v66 = *(void *)v176;
      }
      else {
        uint64_t v66 = -1;
      }
    }
    else
    {
      uint64_t v66 = (uint64_t)v176;
    }
    if (j == 4) {
      uint64_t v67 = v66;
    }
    else {
      uint64_t v67 = v62;
    }
    if (j == 6) {
      uint64_t v61 = v66;
    }
    else {
      uint64_t v62 = v67;
    }
    if (v65 >= 0x41 && v176) {
      MEMORY[0x1852FDE40](v176, 0x1000C8000313F17);
    }
    *(void *)&long long v192 = v192 + 1;
  }
LABEL_181:
  int PaddingStyle = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v173);
  if (PaddingStyle == 2)
  {
    if (v169 > 3)
    {
      uint64_t v83 = Value + 3;
      uint64_t v84 = Value + 1;
      Value += 2;
      goto LABEL_187;
    }
    goto LABEL_225;
  }
  if (PaddingStyle != 3)
  {
    uint64_t v137 = "0 && \"Unsupported weightsFormat\"";
    int v138 = 219;
    goto LABEL_258;
  }
  if (v169 <= 3)
  {
LABEL_225:
    uint64_t v137 = "Index < Length && \"Invalid index!\"";
    int v138 = 257;
    uint64_t v139 = "ArrayRef.h";
    __int16 v140 = "operator[]";
    goto LABEL_226;
  }
  uint64_t v83 = Value + 1;
  uint64_t v84 = Value + 2;
LABEL_187:
  uint64_t v85 = *v83;
  uint64_t v86 = *Value;
  if (v164 != *v84 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  int v87 = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v173);
  uint64_t v88 = (v85 - 1) * v54 + 1;
  uint64_t v89 = (v86 - 1) * v53 + 1;
  switch(v87)
  {
    case 0:
      break;
    case 1:
      uint64_t v61 = 0;
      uint64_t v62 = 0;
      break;
    case 2:
    case 4:
      unint64_t v90 = v159 % v34;
      if (!(v159 % v34)) {
        unint64_t v90 = v34;
      }
      unint64_t v91 = (v89 - v90) & ~((uint64_t)(v89 - v90) >> 63);
      unint64_t v92 = v161 % v35;
      if (!(v161 % v35)) {
        unint64_t v92 = v35;
      }
      unint64_t v93 = (v88 - v92) & ~((uint64_t)(v88 - v92) >> 63);
      unint64_t v94 = v91 >> 1;
      unint64_t v95 = v91 - (v91 >> 1);
      unint64_t v96 = v93 >> 1;
      unint64_t v97 = v93 - (v93 >> 1);
      if (v87 == 4) {
        uint64_t v61 = v97;
      }
      else {
        uint64_t v61 = v96;
      }
      if (v87 == 4) {
        uint64_t v62 = v95;
      }
      else {
        uint64_t v62 = v94;
      }
      break;
    default:
      __assert_rtn("createDepthwiseConv2D", "GPUDepthwiseConvOps.mm", 261, "0 && \"Unsupported paddingStyle\"");
  }
  if (v88 >= 0) {
    uint64_t v98 = (v85 - 1) * v54 + 1;
  }
  else {
    uint64_t v98 = (v85 - 1) * v54 + 2;
  }
  if (v89 >= 0) {
    uint64_t v99 = v89;
  }
  else {
    uint64_t v99 = v89 + 1;
  }
  uint64_t v100 = (void *)[objc_alloc(MEMORY[0x1E4F35718]) initWithDevice:v26];
  *(void *)&long long v191 = (v98 >> 1) - v61;
  *((void *)&v191 + 1) = (v99 >> 1) - v62;
  *(void *)&long long v192 = 0;
  [v100 setWindowOffsets:&v191];
  uint64_t v185 = (const char *)v35;
  unint64_t v186 = v34;
  uint64_t v187 = 1;
  [v100 setConvStrides:&v185];
  int v176 = (char *)v54;
  id v177 = (id)v53;
  uint64_t v178 = 1;
  [v100 setConvDilationRates:&v176];
  objc_msgSend(v100, "setOptions:", objc_msgSend(v100, "options") | 1);

  int v101 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v175);
  uint64_t v170 = v176;
  id v165 = v177;
  int v102 = (int *)MEMORY[0x1E4F359C0];
  if (*((unsigned char *)v171 + (int)*MEMORY[0x1E4F359C0])) {
    objc_msgSend(v171, "setReadCount:", objc_msgSend(v171, "readCount") + 1);
  }
  int v103 = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v175);
  id v104 = v173;
  id v105 = v104;
  int v106 = v174;
  if (*((unsigned char *)v104 + *v102)) {
    objc_msgSend(v104, "setReadCount:", objc_msgSend(v104, "readCount") + 1);
  }
  v184[0] = v170;
  v184[1] = v105;
  uint64_t v107 = [MEMORY[0x1E4F1C978] arrayWithObjects:v184 count:2];
  uint64_t v162 = [v100 resultStateForSourceArrays:v107 sourceStates:0 destinationArray:v105];

  uint64_t v108 = GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
  id v109 = a2[1];
  v183[0] = v170;
  v183[1] = v105;
  float v110 = [MEMORY[0x1E4F1C978] arrayWithObjects:v183 count:2];
  uint64_t v111 = [MEMORY[0x1E4F1CA98] null];
  v182[0] = v111;
  v182[1] = v105;
  long long v112 = [MEMORY[0x1E4F1C978] arrayWithObjects:v182 count:2];
  [v100 encodeGradientsToCommandEncoder:v108 commandBuffer:v109 sourceArrays:v110 sourceGradient:v165 gradientState:v162 destinationGradients:v112 kernelDAGObject:0];

  if (v106)
  {
    int v113 = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v175);
    id v114 = v105;
    id v156 = v171;
    uint64_t v157 = v114;
    uint64_t v160 = [v114 descriptor];
    uint64_t v155 = [v156 descriptor];
    int v115 = [v155 getShape];
    int v116 = v115;
    if (v113 == 2)
    {
      std::vector<int>::pointer v122 = [v115 objectAtIndexedSubscript:1];
      *(void *)&long long v191 = v122;
      uint64_t v123 = [v116 objectAtIndexedSubscript:0];
      *((void *)&v191 + 1) = v123;
      int v124 = [v116 objectAtIndexedSubscript:2];
      *(void *)&long long v192 = v124;
      uint64_t v125 = [v116 objectAtIndexedSubscript:3];
      *((void *)&v192 + 1) = v125;
      uint64_t v121 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v191 count:4];

      [v160 reshapeWithShape:v121];
      [v160 transposeDimension:2 withDimension:3];
LABEL_217:
    }
    else
    {
      if (v113 == 3)
      {
        int v117 = [v115 objectAtIndexedSubscript:2];
        uint64_t v185 = v117;
        unint64_t v118 = [v116 objectAtIndexedSubscript:3];
        unint64_t v186 = (unint64_t)v118;
        int v119 = [v116 objectAtIndexedSubscript:0];
        uint64_t v187 = (uint64_t)v119;
        int v120 = [v116 objectAtIndexedSubscript:1];
        uint64_t v188 = (uint64_t)v120;
        uint64_t v121 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v185 count:4];

        long long v195 = xmmword_18112A550;
        long long v196 = unk_18112A560;
        long long v197 = xmmword_18112A570;
        long long v198 = unk_18112A580;
        long long v191 = xmmword_18112A510;
        long long v192 = unk_18112A520;
        long long v193 = xmmword_18112A530;
        long long v194 = unk_18112A540;
        [v160 reshapeWithShape:v121];
        [v160 permuteWithDimensionOrder:&v191];
        goto LABEL_217;
      }
      if (MTLReportFailureTypeEnabled()) {
        MTLReportFailure();
      }
    }
    id v126 = a2[1];
    unint64_t v127 = GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
    uint64_t v128 = [v157 safeArrayViewWithCommandBuffer:v126 computeEncoder:v127 descriptor:v160 aliasing:1];

    if (!v128) {
      __assert_rtn("permuteWeightsBack", "GPUDepthwiseConvOps.mm", 462, "tmp");
    }
    BOOL v129 = (void *)*((void *)v168 + 1);
    if (!v129)
    {
      id v130 = objc_alloc(MEMORY[0x1E4F35770]);
      BOOL v131 = [a2[1] device];
      uint64_t v132 = [v130 initWithDevice:v131];
      unint64_t v133 = (void *)*((void *)v168 + 1);
      *((void *)v168 + 1) = v132;

      objc_msgSend(*((id *)v168 + 1), "setOptions:", objc_msgSend(*((id *)v168 + 1), "options") | 1);
      BOOL v129 = (void *)*((void *)v168 + 1);
    }
    unint64_t v134 = GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
    id v135 = a2[1];
    uint64_t Strides = (uint64_t)v128;
    unint64_t v136 = [MEMORY[0x1E4F1C978] arrayWithObjects:&Strides count:1];
    [v129 encodeToMPSCommandEncoder:v134 commandBuffer:v135 sourceArrays:v136 destinationArray:v156];
  }
  else if (*((unsigned char *)v105 + *v102))
  {
    objc_msgSend(v105, "setReadCount:", objc_msgSend(v105, "readCount") - 1);
  }
}

void sub_180D601A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, void *a19, void *a20,uint64_t a21,uint64_t a22,void *a23)
{
  _Unwind_Resume(a1);
}

unint64_t GPU::DepthwiseConv2DWeightsGradientOpHandler::getJITStaticOperandRepr(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  if (a4 == 2) {
    return GPU::BaseOpHandler::_getJITStaticOperandReprConstant(this, a2, a3, 2u);
  }
  else {
    return GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(this, a2, a3, a4);
  }
}

void GPU::DepthwiseConv3DOpHandler::_createKernel(GPU::DepthwiseConv3DOpHandler *this)
{
  uint64_t v112 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(*((void *)this + 3) + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    *(void *)&long long v109 = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v109);
    if (v82 == 21)
    {
      BOOL v83 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      if (v83 && *(void *)((char *)AttrData + 13) == 0x64335F766E6F635FLL)
      {
        __int16 v98 = 1283;
        unint64_t v94 = "classof on '";
        unint64_t v96 = "mps.depthwise_conv_3d";
        uint64_t v97 = 21;
        *(void *)&long long v91 = "' failed due to the operation not being registered";
        __int16 v93 = 259;
        llvm::operator+((uint64_t *)&v94, (uint64_t *)&v91, (uint64_t)&v109);
        llvm::report_fatal_error((llvm::Twine *)&v109, 1);
      }
    }
LABEL_134:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id) {
    goto LABEL_134;
  }
  uint64_t v90 = *((void *)this + 3);
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v90);
  unint64_t StaticType = GPURegionRuntime::getStaticType(*((void *)this + 2), Filter);
  if (!*(void *)StaticType) {
    __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
  }
  if (*(_UNKNOWN **)(*(void *)StaticType + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  *(void *)&long long v109 = StaticType;
  uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v109);
  uint64_t v8 = v7;
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v90);
  unint64_t v10 = GPURegionRuntime::getStaticType(*((void *)this + 2), Input);
  if (!*(void *)v10) {
    __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
  }
  if (*(_UNKNOWN **)(*(void *)v10 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  *(void *)&long long v109 = v10;
  uint64_t v11 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v109);
  unint64_t v13 = v12;
  uint64_t v14 = v90;
  id v15 = [*(id *)(*((void *)this + 2) + 48) metalDevice];
  uint64_t v108 = v14;
  id v16 = v15;
  uint64_t Strides = mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v108);
  uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v108);
  long long v110 = 0u;
  long long v111 = 0u;
  long long v109 = 0u;
  uint64_t v88 = v8;
  id v89 = v16;
  uint64_t v85 = Value;
  uint64_t Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v108);
  int ChannelAxis = mlir::mps::DepthwiseConv3DDataGradientOp::getChannelAxis((mlir::mps::DepthwiseConv3DDataGradientOp *)&v108);
  if (ChannelAxis >= 0) {
    unint64_t v18 = v13;
  }
  else {
    unint64_t v18 = 0;
  }
  unint64_t v86 = v18;
  uint64_t v87 = ChannelAxis;
  if (ChannelAxis >= 0) {
    unint64_t v19 = 0;
  }
  else {
    unint64_t v19 = v13;
  }
  long long v103 = xmmword_18112A6B0;
  unint64_t v20 = 1;
  unint64_t v104 = 1;
  int64_t v21 = v19 + ChannelAxis;
  long long v101 = xmmword_18112A6B0;
  uint64_t v102 = 1;
  unint64_t v22 = 1;
  unint64_t v23 = 1;
  if (v13 >= 3)
  {
    unint64_t v24 = (int)(v13 - 1 - (v21 >= (int)v13 - 1));
    if (v13 <= v24
      || (unint64_t v25 = (int)(v13 - 2 - (v21 >= (int)v13 - 2)), v13 <= v25)
      || (unint64_t v26 = (int)(v13 - 3 - (v21 >= (int)v13 - 3)), v13 <= v26))
    {
      __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
    }
    unint64_t v23 = *(void *)(v11 + 8 * v24);
    unint64_t v22 = *(void *)(v11 + 8 * v25);
    unint64_t v20 = *(void *)(v11 + 8 * v26);
  }
  if (Strides && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides) == 3)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v94, Strides, 0);
    uint64_t v27 = Strides;
    uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v91, v27, NumElements);
    int v29 = 2;
    while (1)
    {
      BOOL v30 = v94 == (const char *)v91 && v95 == BYTE8(v91);
      if (v30 && v96 == v92) {
        goto LABEL_35;
      }
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v94, (llvm::APInt *)&v99);
      int v31 = DWORD2(v99);
      if (DWORD2(v99) < 0x41)
      {
        *((void *)&v103 + v29--) = v99;
        goto LABEL_22;
      }
      unsigned int v32 = v31 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v99);
      uint64_t v33 = v99;
      if (v32 <= 0x40) {
        break;
      }
      *((void *)&v103 + v29--) = -1;
      if (v33) {
        goto LABEL_34;
      }
LABEL_22:
      ++v96;
    }
    *((void *)&v103 + v29--) = *(void *)v99;
LABEL_34:
    MEMORY[0x1852FDE40]();
    goto LABEL_22;
  }
LABEL_35:
  if (InputAttributeNames
    && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames) == 3)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v94, InputAttributeNames, 0);
    uint64_t v34 = InputAttributeNames;
    uint64_t v35 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v91, v34, v35);
    int v36 = 2;
    while (1)
    {
      BOOL v37 = v94 == (const char *)v91 && v95 == BYTE8(v91);
      if (v37 && v96 == v92) {
        goto LABEL_52;
      }
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v94, (llvm::APInt *)&v99);
      int v38 = DWORD2(v99);
      if (DWORD2(v99) < 0x41)
      {
        *((void *)&v101 + v36--) = v99;
        goto LABEL_39;
      }
      unsigned int v39 = v38 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v99);
      uint64_t v40 = v99;
      if (v39 <= 0x40) {
        break;
      }
      *((void *)&v101 + v36--) = -1;
      if (v40) {
        goto LABEL_51;
      }
LABEL_39:
      ++v96;
    }
    *((void *)&v101 + v36--) = *(void *)v99;
LABEL_51:
    MEMORY[0x1852FDE40]();
    goto LABEL_39;
  }
LABEL_52:
  if (Rewriter && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter) == 6)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v94, Rewriter, 0);
    uint64_t v41 = Rewriter;
    uint64_t v42 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v91, v41, v42);
    int v43 = 5;
    while (1)
    {
      BOOL v44 = v94 == (const char *)v91 && v95 == BYTE8(v91);
      if (v44 && v96 == v92) {
        goto LABEL_69;
      }
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v94, (llvm::APInt *)&v99);
      int v45 = DWORD2(v99);
      if (DWORD2(v99) < 0x41)
      {
        *((void *)&v109 + v43--) = v99;
        goto LABEL_56;
      }
      unsigned int v46 = v45 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v99);
      uint64_t v47 = v99;
      if (v46 <= 0x40) {
        break;
      }
      *((void *)&v109 + v43--) = -1;
      if (v47) {
        goto LABEL_68;
      }
LABEL_56:
      ++v96;
    }
    *((void *)&v109 + v43--) = *(void *)v99;
LABEL_68:
    MEMORY[0x1852FDE40]();
    goto LABEL_56;
  }
LABEL_69:
  if (v88 == 4)
  {
    uint64_t v48 = v21 - v13 + 4;
    uint64_t v49 = 24;
    if (v48 > 2) {
      uint64_t v49 = 16;
    }
    uint64_t v50 = *(void *)(v85 + v49);
    BOOL v51 = __OFSUB__(v48, 1);
    BOOL v30 = v48 == 1;
    uint64_t v52 = 8;
    if (((uint64_t)(v21 - v13 + 3) < 0) ^ v51 | v30) {
      uint64_t v52 = 16;
    }
    uint64_t v53 = *(void *)(v85 + v52);
    BOOL v54 = (uint64_t)(v21 - v13 + 3) < 0 != v51;
    uint64_t v55 = v50 - 1;
    uint64_t v56 = v53 - 1;
    uint64_t v57 = *(void *)(v85 + 8 * v54) - 1;
  }
  else
  {
    uint64_t v55 = 0;
    uint64_t v56 = 0;
    uint64_t v57 = 0;
  }
  unsigned int PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v108);
  if (PaddingStyle >= 3 && PaddingStyle != 4) {
    __assert_rtn("createDepthwiseConv3D", "GPUDepthwiseConvOps.mm", 791, "0 && \"Unknown paddingStyle\"");
  }
  uint64_t v59 = v101 * v55 + 1;
  if (PaddingStyle)
  {
    if (PaddingStyle == 2 || PaddingStyle == 4)
    {
      unint64_t v60 = v103;
      if (v23 % (unint64_t)v103) {
        unint64_t v60 = v23 % (unint64_t)v103;
      }
      unint64_t v61 = (v59 - v60) & ~((uint64_t)(v59 - v60) >> 63);
      unint64_t v62 = v61 >> 1;
      unint64_t v63 = v61 - (v61 >> 1);
      if (PaddingStyle != 4) {
        unint64_t v63 = v62;
      }
    }
    else
    {
      unint64_t v63 = 0;
    }
    if (v59 < 0) {
      uint64_t v59 = v101 * v55 + 2;
    }
    BOOL v64 = (const char *)((v59 >> 1) - v63);
    uint64_t v65 = *((void *)&v101 + 1) * v56 + 1;
    if (PaddingStyle == 4 || PaddingStyle == 2)
    {
      unint64_t v66 = *((void *)&v103 + 1);
      if (v22 % *((void *)&v103 + 1)) {
        unint64_t v66 = v22 % *((void *)&v103 + 1);
      }
      unint64_t v67 = (v65 - v66) & ~((uint64_t)(v65 - v66) >> 63);
      unint64_t v68 = v67 >> 1;
      unint64_t v69 = v67 - (v67 >> 1);
      if (PaddingStyle != 4) {
        unint64_t v69 = v68;
      }
    }
    else
    {
      unint64_t v69 = 0;
    }
    int v72 = v89;
    if (v65 < 0) {
      uint64_t v65 = *((void *)&v101 + 1) * v56 + 2;
    }
    uint64_t v70 = (v65 >> 1) - v69;
    uint64_t v71 = v102 * v57 + 1;
    if (PaddingStyle == 4 || PaddingStyle == 2)
    {
      unint64_t v73 = v104;
      if (v20 % v104) {
        unint64_t v73 = v20 % v104;
      }
      unint64_t v74 = (v71 - v73) & ~((uint64_t)(v71 - v73) >> 63);
      unint64_t v75 = v74 >> 1;
      unint64_t v76 = v74 - (v74 >> 1);
      if (PaddingStyle == 4) {
        unint64_t v77 = v76;
      }
      else {
        unint64_t v77 = v75;
      }
    }
    else
    {
      unint64_t v77 = 0;
    }
  }
  else
  {
    if (v59 < 0) {
      uint64_t v59 = v101 * v55 + 2;
    }
    BOOL v64 = (const char *)((v59 >> 1) - *((void *)&v109 + 1));
    uint64_t v70 = (*((void *)&v101 + 1) * v56 + 1) / 2 - *((void *)&v110 + 1);
    uint64_t v71 = v102 * v57 + 1;
    int v72 = v89;
    unint64_t v77 = *((void *)&v111 + 1);
  }
  if (v71 >= 0) {
    uint64_t v78 = v71;
  }
  else {
    uint64_t v78 = v71 + 1;
  }
  unsigned int v79 = (void *)[objc_alloc(MEMORY[0x1E4F35718]) initWithDevice:v72];
  unint64_t v94 = v64;
  uint64_t v95 = v70;
  unint64_t v96 = (const char *)((v78 >> 1) - v77);
  [v79 setWindowOffsets:&v94];
  long long v91 = v103;
  unint64_t v92 = (const char *)v104;
  [v79 setConvStrides:&v91];
  long long v99 = v101;
  uint64_t v100 = v102;
  [v79 setConvDilationRates:&v99];
  [v79 setChannelAxis:v86 + ~v87];
  objc_msgSend(v79, "setOptions:", objc_msgSend(v79, "options") | 1);

  uint64_t v80 = (void *)*((void *)this + 1);
  *((void *)this + 1) = v79;
}

void sub_180D60E74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

GPU::DepthwiseConv3DOpHandler **GPU::DepthwiseConv3DOpHandler::postInitializeHook(GPU::DepthwiseConv3DOpHandler **this)
{
  if (*((unsigned char *)this + 40))
  {
    uint64_t v1 = (GPU::DepthwiseConv3DOpHandler *)this;
    if (!this[4])
    {
      this = (GPU::DepthwiseConv3DOpHandler **)GPU::DepthwiseConv3DOpHandler::getQuantizationParameters(this[3], (mlir::Value *)v3, (mlir::Value *)&v2);
      if (this) {
        return (GPU::DepthwiseConv3DOpHandler **)GPU::DepthwiseConv3DOpHandler::_getQuantKernelDAGObject(v1);
      }
    }
  }
  return this;
}

uint64_t GPU::DepthwiseConv3DOpHandler::getQuantizationParameters(GPU::DepthwiseConv3DOpHandler *this, mlir::Value *a2, mlir::Value *a3)
{
  uint64_t v3 = *((void *)this + 6);
  uint64_t v4 = *(void **)(v3 + 16);
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t Input = *(void **)(v3 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&Input);
    if (v28 == 21)
    {
      BOOL v29 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      if (v29 && *(void *)((char *)AttrData + 13) == 0x64335F766E6F635FLL)
      {
        __int16 v38 = 1283;
        v37[0] = (uint64_t)"classof on '";
        v37[2] = (uint64_t)"mps.depthwise_conv_3d";
        v37[3] = 21;
        v35[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v36 = 259;
        llvm::operator+(v37, v35, (uint64_t)&Input);
        llvm::report_fatal_error((llvm::Twine *)&Input, 1);
      }
    }
LABEL_83:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id) {
    goto LABEL_83;
  }
  uint64_t v34 = this;
  uint64_t Input = (void *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v34);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Input);
  if (DefiningOp) {
    uint64_t DefiningOp = llvm::DefaultDoCastIfPossible<mlir::mps::DequantizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DequantizeOp,mlir::Operation *,void>>::doCastIfPossible(DefiningOp);
  }
  uint64_t v33 = DefiningOp;
  uint64_t Input = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v34);
  uint64_t v8 = mlir::Value::getDefiningOp((mlir::Value *)&Input);
  if (v8)
  {
    uint64_t v32 = llvm::DefaultDoCastIfPossible<mlir::mps::DequantizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DequantizeOp,mlir::Operation *,void>>::doCastIfPossible(v8);
    if ((v32 == 0) == (v33 == 0))
    {
      if (v33) {
        goto LABEL_8;
      }
      return 0;
    }
  }
  else
  {
    uint64_t v32 = 0;
    if (!v33) {
      return 0;
    }
  }
  if (MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  if (v33)
  {
LABEL_8:
    *(void *)a2 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v33);
    *(void *)a3 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v32);
    int v31 = mlir::m_OneFloat(void)::{lambda(llvm::APFloat const&)#1}::__invoke;
    uint64_t Input = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v33);
    if (!Input) {
      goto LABEL_68;
    }
    uint64_t v9 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&Input);
    if (v9
      && mlir::detail::constant_float_predicate_matcher::match((mlir::detail::constant_float_predicate_matcher *)&v31, v9))
    {
      v35[0] = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v33);
      if (!v35[0]) {
        goto LABEL_68;
      }
      unint64_t v10 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)v35);
      if (v10)
      {
        unsigned int v40 = 1;
        uint64_t Input = 0;
        v37[0] = (uint64_t)&Input;
        mlir::detail::constant_int_value_binder::match((mlir::detail::constant_int_value_binder *)v37, v10);
        if (v40 >= 0x41)
        {
          if (Input) {
            MEMORY[0x1852FDE40](Input, 0x1000C8000313F17);
          }
        }
      }
    }
    uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v33);
    int v31 = mlir::m_OneFloat(void)::{lambda(llvm::APFloat const&)#1}::__invoke;
    uint64_t Input = (void *)Filter;
    if (!Filter) {
      goto LABEL_68;
    }
    unint64_t v12 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&Input);
    if (!v12
      || !mlir::detail::constant_float_predicate_matcher::match((mlir::detail::constant_float_predicate_matcher *)&v31, v12))
    {
      goto LABEL_36;
    }
    v35[0] = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v33);
    if (!v35[0]) {
      goto LABEL_68;
    }
    unint64_t v13 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)v35);
    if (!v13) {
      goto LABEL_36;
    }
    unsigned int v40 = 1;
    uint64_t Input = 0;
    v37[0] = (uint64_t)&Input;
    int v14 = mlir::detail::constant_int_value_binder::match((mlir::detail::constant_int_value_binder *)v37, v13);
    unsigned int v15 = v40;
    if (v14)
    {
      if (v40 < 0x41)
      {
        BOOL v16 = Input == 0;
        goto LABEL_32;
      }
      if (v15 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&Input) > 0x40)
      {
        if (Input) {
          MEMORY[0x1852FDE40](Input, 0x1000C8000313F17);
        }
        goto LABEL_36;
      }
      BOOL v16 = *Input == 0;
    }
    else
    {
      BOOL v16 = 0;
      if (v40 < 0x41) {
        goto LABEL_32;
      }
    }
    if (Input) {
      MEMORY[0x1852FDE40](Input, 0x1000C8000313F17);
    }
LABEL_32:
    if (v16)
    {
LABEL_38:
      uint64_t v18 = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v32);
      int v31 = mlir::m_OneFloat(void)::{lambda(llvm::APFloat const&)#1}::__invoke;
      uint64_t Input = (void *)v18;
      if (!v18) {
        goto LABEL_68;
      }
      unint64_t v19 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&Input);
      if (v19
        && mlir::detail::constant_float_predicate_matcher::match((mlir::detail::constant_float_predicate_matcher *)&v31, v19))
      {
        v35[0] = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v32);
        if (!v35[0]) {
          goto LABEL_68;
        }
        unint64_t v20 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)v35);
        if (v20)
        {
          unsigned int v40 = 1;
          uint64_t Input = 0;
          v37[0] = (uint64_t)&Input;
          mlir::detail::constant_int_value_binder::match((mlir::detail::constant_int_value_binder *)v37, v20);
          if (v40 >= 0x41)
          {
            if (Input) {
              MEMORY[0x1852FDE40](Input, 0x1000C8000313F17);
            }
          }
        }
      }
      uint64_t v21 = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v32);
      int v31 = mlir::m_OneFloat(void)::{lambda(llvm::APFloat const&)#1}::__invoke;
      uint64_t Input = (void *)v21;
      if (v21)
      {
        unint64_t v22 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&Input);
        if (!v22
          || !mlir::detail::constant_float_predicate_matcher::match((mlir::detail::constant_float_predicate_matcher *)&v31, v22))
        {
          goto LABEL_65;
        }
        v35[0] = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v32);
        if (v35[0])
        {
          unint64_t v23 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)v35);
          if (!v23) {
            goto LABEL_65;
          }
          unsigned int v40 = 1;
          uint64_t Input = 0;
          v37[0] = (uint64_t)&Input;
          int v24 = mlir::detail::constant_int_value_binder::match((mlir::detail::constant_int_value_binder *)v37, v23);
          unsigned int v25 = v40;
          if (!v24)
          {
            BOOL v26 = 0;
            if (v40 < 0x41) {
              goto LABEL_61;
            }
            goto LABEL_58;
          }
          if (v40 < 0x41)
          {
            BOOL v26 = Input == 0;
            goto LABEL_61;
          }
          if (v25 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&Input) <= 0x40)
          {
            BOOL v26 = *Input == 0;
LABEL_58:
            if (Input)
            {
              MEMORY[0x1852FDE40](Input, 0x1000C8000313F17);
              if (!v26) {
                goto LABEL_65;
              }
              return 1;
            }
LABEL_61:
            if (!v26) {
              goto LABEL_65;
            }
            return 1;
          }
          if (Input) {
            MEMORY[0x1852FDE40](Input, 0x1000C8000313F17);
          }
LABEL_65:
          if (MTLReportFailureTypeEnabled())
          {
            MTLReportFailure();
            return 1;
          }
          return 1;
        }
      }
LABEL_68:
      __assert_rtn("matchPattern", "Matchers.h", 402, "value");
    }
LABEL_36:
    if (MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    goto LABEL_38;
  }
  return 0;
}

void sub_180D61578(_Unwind_Exception *exception_object)
{
  if (*(_DWORD *)(v1 - 48) >= 0x41u)
  {
    uint64_t v3 = *(void *)(v1 - 56);
    if (v3) {
      MEMORY[0x1852FDE40](v3, 0x1000C8000313F17);
    }
  }
  _Unwind_Resume(exception_object);
}

id GPU::DepthwiseConv3DOpHandler::_getQuantKernelDAGObject(GPU::DepthwiseConv3DOpHandler *this)
{
  uint64_t v2 = *((void *)this + 15);
  if (!v2 || !*((unsigned char *)this + 40)) {
    operator new();
  }
  if (!*(void *)(v2 + 120) && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  id v3 = *(id *)(*((void *)this + 15) + 120);

  return v3;
}

void sub_180D61700(_Unwind_Exception *a1)
{
  MEMORY[0x1852FDE70](v1, 0x10A1C40A031F3DELL);
  _Unwind_Resume(a1);
}

id GPU::MPSGraphKernelDAG::getKernelDAGObject(GPU::MPSGraphKernelDAG *this)
{
  uint64_t v1 = (void *)*((void *)this + 15);
  if (v1)
  {
    id v2 = v1;
  }
  else
  {
    if (!*((void *)this + 12) && MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    uint64_t v5 = [objc_alloc(MEMORY[0x1E4F35608]) initWithKernelDAG:(char *)this + 80 finalOp:*(void *)(*((void *)this + 12) + 32)];
    uint64_t v6 = (void *)*((void *)this + 15);
    *((void *)this + 15) = v5;

    id v2 = *((id *)this + 15);
  }
  return v2;
}

void GPU::DepthwiseConv3DOpHandler::encodeNDArrayOp(GPU::DepthwiseConv3DOpHandler *this, GPU::EncodeDescriptor *a2, NSArray *a3)
{
  v72[2] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a3;
  if (!*((unsigned char *)this + 40)) {
    GPU::DepthwiseConv3DOpHandler::_createKernel(this);
  }
  uint64_t v62 = 0;
  uint64_t v63 = 0;
  if (GPU::DepthwiseConv3DOpHandler::getQuantizationParameters(*((GPU::DepthwiseConv3DOpHandler **)this + 3), (mlir::Value *)&v63, (mlir::Value *)&v62))id v6 = GPU::DepthwiseConv3DOpHandler::_getQuantKernelDAGObject(this); {
  uint64_t v7 = *(void *)(*((void *)this + 3) + 48);
  }
  uint64_t v8 = *(void **)(v7 + 16);
  if (v8 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v70[0] = *(void *)(v7 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v70);
    if (v57 == 21)
    {
      BOOL v58 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      if (v58 && *(void *)((char *)AttrData + 13) == 0x64335F766E6F635FLL)
      {
        __int16 v69 = 1283;
        v66[0] = (uint64_t)"classof on '";
        unint64_t v67 = "mps.depthwise_conv_3d";
        uint64_t v68 = 21;
        v64[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v65 = 259;
        llvm::operator+(v66, v64, (uint64_t)v70);
        llvm::report_fatal_error((llvm::Twine *)v70, 1);
      }
    }
LABEL_64:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v8 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id) {
    goto LABEL_64;
  }
  uint64_t v61 = *((void *)this + 3);
  uint64_t v9 = [(NSArray *)v5 objectAtIndexedSubscript:0];
  unint64_t v10 = [v9 mpsndarray];
  id v11 = *((id *)this + 1);
  if (*((void *)this + 4))
  {
    uint64_t v12 = *(void *)(mlir::Block::getParentOp(*(mlir::Block **)(*((void *)this + 3) + 16)) + 48);
    if (*(_UNKNOWN **)(v12 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v70[0] = *(void *)(v12 + 8);
      unint64_t v13 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v70);
      if (v14 == 13 && *v13 == 0x6974732E7873706DLL && *(void *)((char *)v13 + 5) == 0x6465686374697473)
      {
        __int16 v69 = 1283;
        v66[0] = (uint64_t)"classof on '";
        unint64_t v67 = "mpsx.stitched";
        uint64_t v68 = 13;
        v64[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v65 = 259;
        llvm::operator+(v66, v64, (uint64_t)v70);
        llvm::report_fatal_error((llvm::Twine *)v70, 1);
      }
    }
    uint64_t v16 = *(void *)(mlir::Block::getParentOp(*(mlir::Block **)(*((void *)this + 3) + 16)) + 48);
    uint64_t v17 = *(void **)(v16 + 16);
    if (v17 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v70[0] = *(void *)(v16 + 8);
      __int16 v38 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v70);
      if (v39 == 13 && *v38 == 0x6974732E7873706DLL && *(void *)((char *)v38 + 5) == 0x6465686374697473)
      {
        __int16 v69 = 1283;
        v66[0] = (uint64_t)"classof on '";
        unint64_t v67 = "mpsx.stitched";
        uint64_t v68 = 13;
        v70[0] = v66;
        v70[2] = "' failed due to the operation not being registered";
        __int16 v71 = 770;
        llvm::report_fatal_error((llvm::Twine *)v70, 1);
      }
    }
    else if (v17 == &mlir::detail::TypeIDResolver<mlir::mpsx::StitchedOp,void>::id)
    {
LABEL_16:
      uint64_t v18 = GPU::MPSGraphKernelDAG::getNDArraysForPlaceholders(*((GPU::MPSGraphKernelDAG **)this + 4), *((GPURegionRuntime **)this + 2));
      unint64_t v19 = (void *)*((void *)a2 + 9);
      if (!v19)
      {
        uint64_t v20 = [objc_alloc(MEMORY[0x1E4F35528]) initWithCommandBuffer:*((void *)a2 + 1) withDispatchType:0];
        uint64_t v21 = (void *)*((void *)a2 + 9);
        *((void *)a2 + 9) = v20;

        unint64_t v22 = (void *)*((void *)a2 + 11);
        unint64_t v19 = (void *)*((void *)a2 + 9);
        if (v22)
        {
          uint64_t v23 = [v22 wrapComputeEncoder:*((void *)a2 + 9)];
          int v24 = (void *)*((void *)a2 + 9);
          *((void *)a2 + 9) = v23;

          unint64_t v19 = (void *)*((void *)a2 + 9);
        }
      }
      if (*((void *)a2 + 10))
      {
        objc_msgSend(v19, "setLabel:");
        unint64_t v19 = (void *)*((void *)a2 + 9);
      }
      id v25 = v19;
      uint64_t v26 = *((void *)a2 + 1);
      uint64_t v27 = *((void *)this + 4);
      uint64_t v28 = *(void **)(v27 + 120);
      if (!v28)
      {
        if (!*(void *)(v27 + 96) && MTLReportFailureTypeEnabled()) {
          MTLReportFailure();
        }
        uint64_t v29 = [objc_alloc(MEMORY[0x1E4F35608]) initWithKernelDAG:v27 + 80 finalOp:*(void *)(*(void *)(v27 + 96) + 32)];
        int v31 = *(void **)(v27 + 120);
        BOOL v30 = (uint64_t *)(v27 + 120);
        *BOOL v30 = v29;

        uint64_t v28 = (void *)*v30;
      }
      id v32 = v28;
      [v11 encodeToMPSCommandEncoder:v25 commandBuffer:v26 sourceArrays:v18 resultState:0 destinationArray:v10 kernelDAGObject:v32];

      goto LABEL_46;
    }
    if (MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    goto LABEL_16;
  }
  uint64_t v33 = (GPU::MPSGraphKernelDAG *)*((void *)this + 15);
  if (v33)
  {
    uint64_t v34 = GPU::MPSGraphKernelDAG::getNDArraysForPlaceholders(v33, *((GPURegionRuntime **)this + 2));
    uint64_t v35 = GPU::EncodeDescriptor::getcomputeEncoder(a2);
    uint64_t v36 = *((void *)a2 + 1);
    BOOL v37 = GPU::MPSGraphKernelDAG::getKernelDAGObject(*((GPU::MPSGraphKernelDAG **)this + 15));
    [v11 encodeToMPSCommandEncoder:v35 commandBuffer:v36 sourceArrays:v34 resultState:0 destinationArray:v10 kernelDAGObject:v37];
  }
  else
  {
    uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v61);
    uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v61);
    uint64_t v43 = *((void *)this + 2);
    v70[0] = Input;
    v66[0] = *((void *)mlir::Value::getParentRegion((mlir::Value *)v70) + 2);
    BOOL v44 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v43 + 88), v66);
    if (v44
      && (v64[0] = v70[0],
          (int v45 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v44 + 3, v64)) != 0))
    {
      id v60 = (id)v45[3];
    }
    else
    {
      id v60 = 0;
    }
    uint64_t v46 = *((void *)this + 2);
    v70[0] = Filter;
    v66[0] = *((void *)mlir::Value::getParentRegion((mlir::Value *)v70) + 2);
    uint64_t v47 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v46 + 88), v66);
    if (v47
      && (v64[0] = v70[0],
          (uint64_t v48 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v47 + 3, v64)) != 0))
    {
      id v49 = (id)v48[3];
    }
    else
    {
      id v49 = 0;
    }
    uint64_t v50 = [v60 mpsndarray];
    uint64_t v51 = [v49 mpsndarray];
    uint64_t v52 = (void *)v51;
    if ((!v10 || !v50 || !v51) && MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    uint64_t v53 = GPU::EncodeDescriptor::getcomputeEncoder(a2);
    uint64_t v54 = *((void *)a2 + 1);
    v72[0] = v50;
    v72[1] = v52;
    uint64_t v55 = [MEMORY[0x1E4F1C978] arrayWithObjects:v72 count:2];
    [v11 encodeToMPSCommandEncoder:v53 commandBuffer:v54 sourceArrays:v55 destinationArray:v10];
  }
LABEL_46:
}

void sub_180D61EBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GPU::DepthwiseConv3DDataGradientOpHandler::encodeNDArrayOp(GPU::DepthwiseConv3DDataGradientOpHandler *this, GPU::EncodeDescriptor *a2, NSArray *a3)
{
  uint64_t v291 = *MEMORY[0x1E4F143B8];
  v264 = a3;
  uint64_t v5 = *(void *)(*((void *)this + 3) + 48);
  id v6 = *(void **)(v5 + 16);
  if (v6 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    *(void *)&long long v288 = *(void *)(v5 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v288);
    if (v226 == 35)
    {
      BOOL v227 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      BOOL v228 = v227 && AttrData[2] == 0x61645F64335F766ELL;
      BOOL v229 = v228 && AttrData[3] == 0x69646172675F6174;
      if (v229 && *(void *)((char *)AttrData + 27) == 0x746E656964617267)
      {
        __int16 v284 = 1283;
        std::string v280 = "classof on '";
        uint64_t v282 = "mps.depthwise_conv_3d_data_gradient";
        uint64_t v283 = 35;
        *(void *)&long long v277 = "' failed due to the operation not being registered";
        __int16 v279 = 259;
        llvm::operator+((uint64_t *)&v280, (uint64_t *)&v277, (uint64_t)&v288);
        llvm::report_fatal_error((llvm::Twine *)&v288, 1);
      }
    }
LABEL_424:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v6 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id) {
    goto LABEL_424;
  }
  uint64_t v266 = *((void *)this + 3);
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v266);
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v266);
  uint64_t v9 = *(void *)(*((void *)this + 3) + 48);
  unint64_t v10 = *(void **)(v9 + 16);
  if (v10 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    *(void *)&long long v288 = *(void *)(v9 + 8);
    int v231 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v288);
    if (v232 == 35)
    {
      BOOL v233 = *v231 == 0x747065642E73706DLL && v231[1] == 0x6F635F6573697768;
      BOOL v234 = v233 && v231[2] == 0x61645F64335F766ELL;
      BOOL v235 = v234 && v231[3] == 0x69646172675F6174;
      if (v235 && *(void *)((char *)v231 + 27) == 0x746E656964617267)
      {
        __int16 v284 = 1283;
        std::string v280 = "classof on '";
        uint64_t v282 = "mps.depthwise_conv_3d_data_gradient";
        uint64_t v283 = 35;
        *(void *)&long long v277 = "' failed due to the operation not being registered";
        __int16 v279 = 259;
        llvm::operator+((uint64_t *)&v280, (uint64_t *)&v277, (uint64_t)&v288);
        goto LABEL_396;
      }
    }
LABEL_425:
    long long v197 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v198 = 578;
    uint64_t v199 = "Casting.h";
    uint64_t v200 = "cast";
LABEL_334:
    __assert_rtn(v200, v199, v198, v197);
  }
  if (v10 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id) {
    goto LABEL_425;
  }
  uint64_t v11 = Filter;
  *(void *)&long long v269 = *((void *)this + 3);
  *(void *)&long long v271 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v269);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v271);
  if (!DefiningOp)
  {
LABEL_15:
    uint64_t v15 = 0;
    goto LABEL_16;
  }
  uint64_t v13 = *(void *)(DefiningOp + 48);
  uint64_t v14 = *(void **)(v13 + 16);
  if (v14 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    *(void *)&long long v288 = *(void *)(v13 + 8);
    uint64_t v16 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v288);
    if (v17 == 14)
    {
      BOOL v18 = *v16 == 0x757165642E73706DLL && *(void *)((char *)v16 + 6) == 0x657A69746E617571;
      if (v18)
      {
LABEL_422:
        __int16 v284 = 1283;
        std::string v280 = "classof on '";
        uint64_t v282 = "mps.dequantize";
        uint64_t v283 = 14;
        *(void *)&long long v277 = "' failed due to the operation not being registered";
        __int16 v279 = 259;
        llvm::operator+((uint64_t *)&v280, (uint64_t *)&v277, (uint64_t)&v288);
LABEL_396:
        llvm::report_fatal_error((llvm::Twine *)&v288, 1);
      }
    }
    goto LABEL_15;
  }
  if (v14 == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id) {
    uint64_t v15 = DefiningOp;
  }
  else {
    uint64_t v15 = 0;
  }
LABEL_16:
  *(void *)&long long v267 = v15;
  *(void *)&long long v271 = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v269);
  uint64_t v19 = mlir::Value::getDefiningOp((mlir::Value *)&v271);
  if (!v19) {
    goto LABEL_57;
  }
  uint64_t v20 = *(void *)(v19 + 48);
  uint64_t v21 = *(void **)(v20 + 16);
  if (v21 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    *(void *)&long long v288 = *(void *)(v20 + 8);
    uint64_t v35 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v288);
    if (v36 != 14
      || (*v35 == 0x757165642E73706DLL ? (BOOL v37 = *(void *)((char *)v35 + 6) == 0x657A69746E617571) : (BOOL v37 = 0), !v37))
    {
LABEL_57:
      uint64_t v276 = 0;
      if (!(void)v267) {
        goto LABEL_58;
      }
      goto LABEL_336;
    }
    goto LABEL_422;
  }
  BOOL v18 = v21 == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id;
  BOOL v22 = v21 != &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id;
  if (v18) {
    uint64_t v23 = v19;
  }
  else {
    uint64_t v23 = 0;
  }
  uint64_t v276 = v23;
  if (v22 != ((void)v267 == 0))
  {
LABEL_336:
    if (MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    if (!(void)v267) {
      goto LABEL_58;
    }
    goto LABEL_23;
  }
  if (!(void)v267) {
    goto LABEL_58;
  }
LABEL_23:
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v267);
  uint64_t v11 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v276);
  uint64_t v24 = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v267);
  *(void *)&long long v271 = mlir::m_OneFloat(void)::{lambda(llvm::APFloat const&)#1}::__invoke;
  *(void *)&long long v288 = v24;
  if (!v24) {
    goto LABEL_333;
  }
  id v25 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v288);
  if (v25
    && mlir::detail::constant_float_predicate_matcher::match((mlir::detail::constant_float_predicate_matcher *)&v271, v25))
  {
    *(void *)&long long v277 = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v267);
    if (!(void)v277) {
      goto LABEL_333;
    }
    uint64_t v26 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v277);
    if (v26)
    {
      DWORD2(v288) = 1;
      *(void *)&long long v288 = 0;
      std::string v280 = (const char *)&v288;
      mlir::detail::constant_int_value_binder::match((mlir::detail::constant_int_value_binder *)&v280, v26);
      if (DWORD2(v288) >= 0x41)
      {
        if ((void)v288) {
          MEMORY[0x1852FDE40](v288, 0x1000C8000313F17);
        }
      }
    }
  }
  uint64_t v27 = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v267);
  uint64_t Strides = mlir::m_OneFloat(void)::{lambda(llvm::APFloat const&)#1}::__invoke;
  *(void *)&long long v288 = v27;
  if (!v27) {
    goto LABEL_333;
  }
  uint64_t v28 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v288);
  if (!v28
    || !mlir::detail::constant_float_predicate_matcher::match((mlir::detail::constant_float_predicate_matcher *)&Strides, v28))
  {
    goto LABEL_282;
  }
  *(void *)&long long v271 = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v267);
  if (!(void)v271) {
    goto LABEL_333;
  }
  uint64_t v29 = mlir::Value::getDefiningOp((mlir::Value *)&v271);
  if (!v29) {
    goto LABEL_282;
  }
  LODWORD(v281) = 1;
  std::string v280 = 0;
  *(void *)&long long v277 = &v280;
  {
    *(void *)&long long v288 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ConstantLike<Empty>]";
    *((void *)&v288 + 1) = 84;
    unint64_t v237 = llvm::StringRef::find((uint64_t *)&v288, "DesiredTypeName = ", 0x12uLL, 0);
    long long v238 = v288;
    if (*((void *)&v288 + 1) >= v237) {
      unint64_t v239 = v237;
    }
    else {
      unint64_t v239 = *((void *)&v288 + 1);
    }
    unint64_t v240 = *((void *)&v288 + 1) - v239;
    uint64_t v241 = v288 + v239;
    *(void *)&long long v288 = v288 + v239;
    *((void *)&v288 + 1) -= v239;
    if (*((void *)&v238 + 1) <= v237)
    {
      unint64_t v249 = "!Name.empty() && \"Unable to find the template parameter!\"";
      int v250 = 33;
    }
    else
    {
      if (v240 < 0x12)
      {
        unint64_t v249 = "size() >= N && \"Dropping more elements than exist\"";
        int v250 = 614;
        uint64_t v251 = "StringRef.h";
        uint64_t v252 = "drop_front";
        goto LABEL_430;
      }
      *(void *)&long long v288 = v241 + 18;
      *((void *)&v288 + 1) = v240 - 18;
      if (v240 != 18 && *(unsigned char *)(v238 + *((void *)&v238 + 1) - 1) == 93)
      {
        if (v240 - 18 >= v240 - 19) {
          uint64_t v242 = v240 - 19;
        }
        else {
          uint64_t v242 = v240 - 18;
        }
        mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v241 + 18, v242);
        goto LABEL_37;
      }
      unint64_t v249 = "Name.ends_with(\"]\") && \"Name doesn't end in the substitution key!\"";
      int v250 = 36;
    }
    uint64_t v251 = "TypeName.h";
    uint64_t v252 = "getTypeName";
LABEL_430:
    __assert_rtn(v252, v251, v250, v249);
  }
LABEL_37:
  if (!(*(unsigned int (**)(void, uint64_t))(**(void **)(v29 + 48) + 32))(*(void *)(v29 + 48), mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id))goto LABEL_50; {
  *(void *)&long long v288 = &v289;
  }
  *((void *)&v288 + 1) = 0x100000000;
  if (!mlir::Operation::fold(v29, 0, 0, (uint64_t)&v288)) {
    __assert_rtn("match", "Matchers.h", 92, "succeeded(result) && \"expected ConstantLike op to be foldable\"");
  }
  if (!DWORD2(v288))
  {
    uint64_t v209 = "!empty()";
    int v210 = 303;
    int v211 = "SmallVector.h";
    uint64_t v212 = "front";
    goto LABEL_352;
  }
  uint64_t v30 = *(void *)v288;
  if ((*(void *)v288 & 4) != 0)
  {
    uint64_t v209 = "isa<T>(*this) && \"Invalid accessor called\"";
    int v210 = 156;
    int v211 = "PointerUnion.h";
    uint64_t v212 = "get";
    goto LABEL_352;
  }
  unint64_t v31 = v30 & 0xFFFFFFFFFFFFFFF8;
  if ((v30 & 0xFFFFFFFFFFFFFFF8) == 0)
  {
    uint64_t v209 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v210 = 650;
    int v211 = "Casting.h";
    uint64_t v212 = "dyn_cast";
LABEL_352:
    __assert_rtn(v212, v211, v210, v209);
  }
  if ((long long *)v288 != &v289) {
    free((void *)v288);
  }
  if (!*(_DWORD *)(v29 + 36))
  {
    uint64_t v213 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    int v214 = 984;
    v215 = "Operation.h";
    unint64_t v216 = "getOpResultImpl";
    goto LABEL_355;
  }
  uint64_t v32 = *(void *)(*(void *)(v29 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v32)
  {
    uint64_t v213 = "abstractType && \"Malformed type storage object.\"";
    int v214 = 160;
    v215 = "TypeSupport.h";
    unint64_t v216 = "getAbstractType";
LABEL_355:
    __assert_rtn(v216, v215, v214, v213);
  }
  uint64_t v33 = *(void **)(v32 + 136);
  if (v33 != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id
    && v33 != &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id
    && v33 != &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id
    && v33 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
LABEL_50:
    BOOL v34 = 0;
    if (v281 < 0x41) {
      goto LABEL_278;
    }
    goto LABEL_276;
  }
  int v58 = mlir::detail::constant_int_value_binder::match((uint64_t *)&v277, v31);
  unsigned int v59 = v281;
  if (!v58)
  {
    BOOL v34 = 0;
    if (v281 < 0x41) {
      goto LABEL_278;
    }
    goto LABEL_276;
  }
  if (v281 < 0x41)
  {
    id v60 = &v280;
    goto LABEL_275;
  }
  if (v59 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v280) <= 0x40)
  {
    id v60 = (const char **)v280;
LABEL_275:
    BOOL v34 = *v60 == 0;
    if (v59 < 0x41) {
      goto LABEL_278;
    }
LABEL_276:
    if (v280) {
      MEMORY[0x1852FDE40](v280, 0x1000C8000313F17);
    }
LABEL_278:
    if (v34) {
      goto LABEL_284;
    }
    goto LABEL_282;
  }
  if (v280) {
    MEMORY[0x1852FDE40](v280, 0x1000C8000313F17);
  }
LABEL_282:
  if (MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
LABEL_284:
  uint64_t v183 = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v276);
  *(void *)&long long v271 = mlir::m_OneFloat(void)::{lambda(llvm::APFloat const&)#1}::__invoke;
  *(void *)&long long v288 = v183;
  if (!v183) {
    goto LABEL_333;
  }
  int32x4_t v184 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v288);
  if (v184
    && mlir::detail::constant_float_predicate_matcher::match((mlir::detail::constant_float_predicate_matcher *)&v271, v184))
  {
    *(void *)&long long v277 = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v276);
    if ((void)v277)
    {
      uint64_t v185 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v277);
      if (v185)
      {
        DWORD2(v288) = 1;
        *(void *)&long long v288 = 0;
        std::string v280 = (const char *)&v288;
        mlir::detail::constant_int_value_binder::match((mlir::detail::constant_int_value_binder *)&v280, v185);
        if (DWORD2(v288) >= 0x41)
        {
          if ((void)v288) {
            MEMORY[0x1852FDE40](v288, 0x1000C8000313F17);
          }
        }
      }
      goto LABEL_292;
    }
LABEL_333:
    long long v197 = "value";
    int v198 = 402;
    uint64_t v199 = "Matchers.h";
    uint64_t v200 = "matchPattern";
    goto LABEL_334;
  }
LABEL_292:
  uint64_t v186 = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v276);
  uint64_t Strides = mlir::m_OneFloat(void)::{lambda(llvm::APFloat const&)#1}::__invoke;
  *(void *)&long long v288 = v186;
  if (!v186) {
    goto LABEL_333;
  }
  uint64_t v187 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v288);
  if (!v187
    || !mlir::detail::constant_float_predicate_matcher::match((mlir::detail::constant_float_predicate_matcher *)&Strides, v187))
  {
LABEL_327:
    if (MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    goto LABEL_58;
  }
  *(void *)&long long v271 = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v276);
  if (!(void)v271) {
    goto LABEL_333;
  }
  uint64_t v188 = mlir::Value::getDefiningOp((mlir::Value *)&v271);
  if (!v188) {
    goto LABEL_327;
  }
  LODWORD(v281) = 1;
  std::string v280 = 0;
  *(void *)&long long v277 = &v280;
  {
    *(void *)&long long v288 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ConstantLike<Empty>]";
    *((void *)&v288 + 1) = 84;
    unint64_t v243 = llvm::StringRef::find((uint64_t *)&v288, "DesiredTypeName = ", 0x12uLL, 0);
    long long v244 = v288;
    if (*((void *)&v288 + 1) >= v243) {
      unint64_t v245 = v243;
    }
    else {
      unint64_t v245 = *((void *)&v288 + 1);
    }
    unint64_t v246 = *((void *)&v288 + 1) - v245;
    uint64_t v247 = v288 + v245;
    *(void *)&long long v288 = v288 + v245;
    *((void *)&v288 + 1) -= v245;
    if (*((void *)&v244 + 1) <= v243)
    {
      uint64_t v253 = "!Name.empty() && \"Unable to find the template parameter!\"";
      int v254 = 33;
    }
    else
    {
      if (v246 < 0x12)
      {
        uint64_t v253 = "size() >= N && \"Dropping more elements than exist\"";
        int v254 = 614;
        unint64_t v255 = "StringRef.h";
        uint64_t v256 = "drop_front";
        goto LABEL_435;
      }
      *(void *)&long long v288 = v247 + 18;
      *((void *)&v288 + 1) = v246 - 18;
      if (v246 != 18 && *(unsigned char *)(v244 + *((void *)&v244 + 1) - 1) == 93)
      {
        if (v246 - 18 >= v246 - 19) {
          uint64_t v248 = v246 - 19;
        }
        else {
          uint64_t v248 = v246 - 18;
        }
        mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v247 + 18, v248);
        goto LABEL_298;
      }
      uint64_t v253 = "Name.ends_with(\"]\") && \"Name doesn't end in the substitution key!\"";
      int v254 = 36;
    }
    unint64_t v255 = "TypeName.h";
    uint64_t v256 = "getTypeName";
LABEL_435:
    __assert_rtn(v256, v255, v254, v253);
  }
LABEL_298:
  if (!(*(unsigned int (**)(void, uint64_t))(**(void **)(v188 + 48) + 32))(*(void *)(v188 + 48), mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id))goto LABEL_311; {
  *(void *)&long long v288 = &v289;
  }
  *((void *)&v288 + 1) = 0x100000000;
  if (!mlir::Operation::fold(v188, 0, 0, (uint64_t)&v288)) {
    __assert_rtn("match", "Matchers.h", 92, "succeeded(result) && \"expected ConstantLike op to be foldable\"");
  }
  if (!DWORD2(v288))
  {
    long long v217 = "!empty()";
    int v218 = 303;
    uint64_t v219 = "SmallVector.h";
    uint64_t v220 = "front";
    goto LABEL_360;
  }
  uint64_t v189 = *(void *)v288;
  if ((*(void *)v288 & 4) != 0)
  {
    long long v217 = "isa<T>(*this) && \"Invalid accessor called\"";
    int v218 = 156;
    uint64_t v219 = "PointerUnion.h";
    uint64_t v220 = "get";
    goto LABEL_360;
  }
  unint64_t v190 = v189 & 0xFFFFFFFFFFFFFFF8;
  if ((v189 & 0xFFFFFFFFFFFFFFF8) == 0)
  {
    long long v217 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v218 = 650;
    uint64_t v219 = "Casting.h";
    uint64_t v220 = "dyn_cast";
LABEL_360:
    __assert_rtn(v220, v219, v218, v217);
  }
  if ((long long *)v288 != &v289) {
    free((void *)v288);
  }
  if (!*(_DWORD *)(v188 + 36))
  {
    uint64_t v221 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    int v222 = 984;
    uint64_t v223 = "Operation.h";
    int v224 = "getOpResultImpl";
    goto LABEL_363;
  }
  uint64_t v191 = *(void *)(*(void *)(v188 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v191)
  {
    uint64_t v221 = "abstractType && \"Malformed type storage object.\"";
    int v222 = 160;
    uint64_t v223 = "TypeSupport.h";
    int v224 = "getAbstractType";
LABEL_363:
    __assert_rtn(v224, v223, v222, v221);
  }
  long long v192 = *(void **)(v191 + 136);
  if (v192 != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id
    && v192 != &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id
    && v192 != &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id
    && v192 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
LABEL_311:
    BOOL v193 = 0;
    if (v281 < 0x41) {
      goto LABEL_323;
    }
    goto LABEL_321;
  }
  int v194 = mlir::detail::constant_int_value_binder::match((uint64_t *)&v277, v190);
  unsigned int v195 = v281;
  if (!v194)
  {
    BOOL v193 = 0;
    if (v281 < 0x41) {
      goto LABEL_323;
    }
    goto LABEL_321;
  }
  if (v281 >= 0x41)
  {
    if (v195 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v280) > 0x40)
    {
      if (v280) {
        MEMORY[0x1852FDE40](v280, 0x1000C8000313F17);
      }
      goto LABEL_327;
    }
    long long v196 = (const char **)v280;
  }
  else
  {
    long long v196 = &v280;
  }
  BOOL v193 = *v196 == 0;
  if (v195 >= 0x41)
  {
LABEL_321:
    if (v280) {
      MEMORY[0x1852FDE40](v280, 0x1000C8000313F17);
    }
  }
LABEL_323:
  if (!v193) {
    goto LABEL_327;
  }
LABEL_58:
  __int16 v38 = (int8x8_t *)*((void *)this + 2);
  *(void *)&long long v288 = Input;
  ParentRegion = mlir::Value::getParentRegion((mlir::Value *)&v288);
  int8x8_t v40 = v38[12];
  if (!*(void *)&v40) {
    goto LABEL_104;
  }
  unint64_t v41 = *((void *)ParentRegion + 2);
  unint64_t v42 = 0x9DDFEA08EB382D69 * (((8 * v41) + 8) ^ HIDWORD(v41));
  unint64_t v43 = 0x9DDFEA08EB382D69 * (HIDWORD(v41) ^ (v42 >> 47) ^ v42);
  unint64_t v44 = 0x9DDFEA08EB382D69 * (v43 ^ (v43 >> 47));
  uint8x8_t v45 = (uint8x8_t)vcnt_s8(v40);
  v45.i16[0] = vaddlv_u8(v45);
  if (v45.u32[0] > 1uLL)
  {
    unint64_t v46 = 0x9DDFEA08EB382D69 * (v43 ^ (v43 >> 47));
    if (v44 >= *(void *)&v40) {
      unint64_t v46 = v44 % *(void *)&v40;
    }
  }
  else
  {
    unint64_t v46 = v44 & (*(void *)&v40 - 1);
  }
  uint64_t v47 = *(void **)(*(void *)&v38[11] + 8 * v46);
  if (!v47) {
    goto LABEL_104;
  }
  uint64_t v48 = (void *)*v47;
  if (!v48) {
    goto LABEL_104;
  }
  if (v45.u32[0] < 2uLL)
  {
    uint64_t v49 = *(void *)&v40 - 1;
    while (1)
    {
      uint64_t v51 = v48[1];
      if (v51 == v44)
      {
        if (v48[2] == v41) {
          goto LABEL_79;
        }
      }
      else if ((v51 & v49) != v46)
      {
        goto LABEL_104;
      }
      uint64_t v48 = (void *)*v48;
      if (!v48) {
        goto LABEL_104;
      }
    }
  }
  while (1)
  {
    unint64_t v50 = v48[1];
    if (v50 == v44) {
      break;
    }
    if (v50 >= *(void *)&v40) {
      v50 %= *(void *)&v40;
    }
    if (v50 != v46) {
      goto LABEL_104;
    }
LABEL_68:
    uint64_t v48 = (void *)*v48;
    if (!v48) {
      goto LABEL_104;
    }
  }
  if (v48[2] != v41) {
    goto LABEL_68;
  }
LABEL_79:
  int8x8_t v52 = (int8x8_t)v48[4];
  if (v52)
  {
    unint64_t v53 = 0x9DDFEA08EB382D69 * (((8 * v288) + 8) ^ DWORD1(v288));
    unint64_t v54 = 0x9DDFEA08EB382D69 * (DWORD1(v288) ^ (v53 >> 47) ^ v53);
    unint64_t v55 = 0x9DDFEA08EB382D69 * (v54 ^ (v54 >> 47));
    uint8x8_t v56 = (uint8x8_t)vcnt_s8(v52);
    v56.i16[0] = vaddlv_u8(v56);
    if (v56.u32[0] > 1uLL)
    {
      unint64_t v57 = v55;
      if (v55 >= *(void *)&v52) {
        unint64_t v57 = v55 % *(void *)&v52;
      }
    }
    else
    {
      unint64_t v57 = v55 & (*(void *)&v52 - 1);
    }
    uint64_t v61 = *(uint64_t ****)(v48[3] + 8 * v57);
    if (v61)
    {
      uint64_t v62 = *v61;
      if (v62)
      {
        if (v56.u32[0] < 2uLL)
        {
          uint64_t v63 = *(void *)&v52 - 1;
          while (1)
          {
            unint64_t v66 = v62[1];
            if (v66 == (uint64_t *)v55)
            {
              if (v62[2] == (uint64_t *)v288) {
                goto LABEL_329;
              }
            }
            else if (((unint64_t)v66 & v63) != v57)
            {
              goto LABEL_104;
            }
            BOOL v64 = 0;
            uint64_t v62 = (uint64_t **)*v62;
            if (!v62) {
              goto LABEL_105;
            }
          }
        }
        while (1)
        {
          unint64_t v65 = (unint64_t)v62[1];
          if (v65 == v55)
          {
            if (v62[2] == (uint64_t *)v288)
            {
LABEL_329:
              BOOL v64 = v62[3];
              goto LABEL_105;
            }
          }
          else
          {
            if (v65 >= *(void *)&v52) {
              v65 %= *(void *)&v52;
            }
            if (v65 != v57) {
              break;
            }
          }
          BOOL v64 = 0;
          uint64_t v62 = (uint64_t **)*v62;
          if (!v62) {
            goto LABEL_105;
          }
        }
      }
    }
  }
LABEL_104:
  BOOL v64 = 0;
LABEL_105:
  uint64_t v67 = [v64 mpsndarray];

  uint64_t v68 = (int8x8_t *)*((void *)this + 2);
  *(void *)&long long v288 = v11;
  __int16 v69 = mlir::Value::getParentRegion((mlir::Value *)&v288);
  int8x8_t v70 = v68[12];
  if (!*(void *)&v70) {
    goto LABEL_146;
  }
  unint64_t v71 = *((void *)v69 + 2);
  unint64_t v72 = 0x9DDFEA08EB382D69 * (((8 * v71) + 8) ^ HIDWORD(v71));
  unint64_t v73 = 0x9DDFEA08EB382D69 * (HIDWORD(v71) ^ (v72 >> 47) ^ v72);
  unint64_t v74 = 0x9DDFEA08EB382D69 * (v73 ^ (v73 >> 47));
  uint8x8_t v75 = (uint8x8_t)vcnt_s8(v70);
  v75.i16[0] = vaddlv_u8(v75);
  if (v75.u32[0] > 1uLL)
  {
    unint64_t v76 = 0x9DDFEA08EB382D69 * (v73 ^ (v73 >> 47));
    if (v74 >= *(void *)&v70) {
      unint64_t v76 = v74 % *(void *)&v70;
    }
  }
  else
  {
    unint64_t v76 = v74 & (*(void *)&v70 - 1);
  }
  unint64_t v77 = *(void **)(*(void *)&v68[11] + 8 * v76);
  if (!v77) {
    goto LABEL_146;
  }
  uint64_t v78 = (void *)*v77;
  if (!v78) {
    goto LABEL_146;
  }
  if (v75.u32[0] < 2uLL)
  {
    uint64_t v79 = *(void *)&v70 - 1;
    while (1)
    {
      uint64_t v81 = v78[1];
      if (v81 == v74)
      {
        if (v78[2] == v71) {
          goto LABEL_126;
        }
      }
      else if ((v81 & v79) != v76)
      {
        goto LABEL_146;
      }
      uint64_t v78 = (void *)*v78;
      if (!v78) {
        goto LABEL_146;
      }
    }
  }
  while (1)
  {
    unint64_t v80 = v78[1];
    if (v80 == v74) {
      break;
    }
    if (v80 >= *(void *)&v70) {
      v80 %= *(void *)&v70;
    }
    if (v80 != v76) {
      goto LABEL_146;
    }
LABEL_115:
    uint64_t v78 = (void *)*v78;
    if (!v78) {
      goto LABEL_146;
    }
  }
  if (v78[2] != v71) {
    goto LABEL_115;
  }
LABEL_126:
  int8x8_t v82 = (int8x8_t)v78[4];
  if (!*(void *)&v82) {
    goto LABEL_146;
  }
  unint64_t v83 = 0x9DDFEA08EB382D69 * (((8 * v288) + 8) ^ DWORD1(v288));
  unint64_t v84 = 0x9DDFEA08EB382D69 * (DWORD1(v288) ^ (v83 >> 47) ^ v83);
  unint64_t v85 = 0x9DDFEA08EB382D69 * (v84 ^ (v84 >> 47));
  uint8x8_t v86 = (uint8x8_t)vcnt_s8(v82);
  v86.i16[0] = vaddlv_u8(v86);
  if (v86.u32[0] > 1uLL)
  {
    unint64_t v87 = v85;
    if (v85 >= *(void *)&v82) {
      unint64_t v87 = v85 % *(void *)&v82;
    }
  }
  else
  {
    unint64_t v87 = v85 & (*(void *)&v82 - 1);
  }
  uint64_t v88 = *(uint64_t ****)(v78[3] + 8 * v87);
  if (!v88 || (id v89 = *v88) == 0)
  {
LABEL_146:
    long long v91 = 0;
    goto LABEL_147;
  }
  if (v86.u32[0] < 2uLL)
  {
    uint64_t v90 = *(void *)&v82 - 1;
    while (1)
    {
      __int16 v93 = v89[1];
      if (v93 == (uint64_t *)v85)
      {
        if (v89[2] == (uint64_t *)v288) {
          goto LABEL_330;
        }
      }
      else if (((unint64_t)v93 & v90) != v87)
      {
        goto LABEL_146;
      }
      long long v91 = 0;
      id v89 = (uint64_t **)*v89;
      if (!v89) {
        goto LABEL_147;
      }
    }
  }
  while (1)
  {
    unint64_t v92 = (unint64_t)v89[1];
    if (v92 == v85) {
      break;
    }
    if (v92 >= *(void *)&v82) {
      v92 %= *(void *)&v82;
    }
    if (v92 != v87) {
      goto LABEL_146;
    }
LABEL_136:
    long long v91 = 0;
    id v89 = (uint64_t **)*v89;
    if (!v89) {
      goto LABEL_147;
    }
  }
  if (v89[2] != (uint64_t *)v288) {
    goto LABEL_136;
  }
LABEL_330:
  long long v91 = v89[3];
LABEL_147:
  char v265 = [v91 mpsndarray];

  uint64_t v263 = [(NSArray *)v264 objectAtIndexedSubscript:0];
  uint64_t v94 = [v263 mpsndarray];
  uint64_t v95 = (void *)v94;
  if ((!v67 || !v265 || !v94) && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  if (*((void *)this + 4) && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  unint64_t StaticType = GPURegionRuntime::getStaticType(*((void *)this + 2), v11);
  if (!*(void *)StaticType)
  {
    uint64_t v201 = "abstractType && \"Malformed type storage object.\"";
    int v202 = 160;
    char v203 = "TypeSupport.h";
    int v204 = "getAbstractType";
    goto LABEL_344;
  }
  if (*(_UNKNOWN **)(*(void *)StaticType + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    uint64_t v201 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v202 = 566;
    char v203 = "Casting.h";
    int v204 = "cast";
LABEL_344:
    __assert_rtn(v204, v203, v202, v201);
  }
  *(void *)&long long v288 = StaticType;
  uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v288);
  uint64_t v99 = v98;
  int v262 = a2;
  uint64_t Result = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v266);
  unint64_t v101 = GPURegionRuntime::getStaticType(*((void *)this + 2), Result);
  if (!*(void *)v101)
  {
    int v205 = "abstractType && \"Malformed type storage object.\"";
    int v206 = 160;
    uint64_t v207 = "TypeSupport.h";
    uint64_t v208 = "getAbstractType";
    goto LABEL_347;
  }
  if (*(_UNKNOWN **)(*(void *)v101 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    int v205 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v206 = 566;
    uint64_t v207 = "Casting.h";
    uint64_t v208 = "cast";
LABEL_347:
    __assert_rtn(v208, v207, v206, v205);
  }
  *(void *)&long long v288 = v101;
  uint64_t v102 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v288);
  unint64_t v104 = v103;
  uint64_t v105 = v266;
  int v106 = [*(id *)(*((void *)this + 2) + 48) metalDevice];
  uint64_t v276 = v105;
  id v107 = v106;
  uint64_t Strides = (BOOL (*)(llvm::APFloatBase *))mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v276);
  uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v276);
  long long v289 = 0u;
  long long v290 = 0u;
  long long v288 = 0u;
  uint64_t v260 = v99;
  uint64_t v257 = Value;
  uint64_t v261 = (void *)v67;
  uint64_t Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v276);
  int ChannelAxis = mlir::mps::DepthwiseConv3DDataGradientOp::getChannelAxis((mlir::mps::DepthwiseConv3DDataGradientOp *)&v276);
  if (ChannelAxis >= 0) {
    unint64_t v109 = v104;
  }
  else {
    unint64_t v109 = 0;
  }
  unint64_t v258 = v109;
  uint64_t v259 = ChannelAxis;
  if (ChannelAxis >= 0) {
    unint64_t v110 = 0;
  }
  else {
    unint64_t v110 = v104;
  }
  long long v271 = xmmword_18112A6B0;
  unint64_t v111 = 1;
  unint64_t v272 = 1;
  int64_t v112 = v110 + ChannelAxis;
  long long v269 = xmmword_18112A6B0;
  uint64_t v270 = 1;
  unint64_t v113 = 1;
  unint64_t v114 = 1;
  if (v104 >= 3)
  {
    unint64_t v115 = (int)(v104 - 1 - (v112 >= (int)v104 - 1));
    if (v104 <= v115
      || (unint64_t v116 = (int)(v104 - 2 - (v112 >= (int)v104 - 2)), v104 <= v116)
      || (unint64_t v117 = (int)(v104 - 3 - (v112 >= (int)v104 - 3)), v104 <= v117))
    {
      __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
    }
    unint64_t v114 = *(void *)(v102 + 8 * v115);
    unint64_t v113 = *(void *)(v102 + 8 * v116);
    unint64_t v111 = *(void *)(v102 + 8 * v117);
  }
  if (Strides && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides) == 3)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v280, (uint64_t)Strides, 0);
    unint64_t v118 = Strides;
    uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v277, (uint64_t)v118, NumElements);
    int v120 = 2;
    while (1)
    {
      BOOL v121 = v280 == (const char *)v277 && v281 == BYTE8(v277);
      if (v121 && v282 == v278) {
        goto LABEL_183;
      }
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v280, (llvm::APInt *)&v267);
      int v122 = DWORD2(v267);
      if (DWORD2(v267) < 0x41)
      {
        *((void *)&v271 + v120--) = v267;
        goto LABEL_170;
      }
      unsigned int v123 = v122 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v267);
      uint64_t v124 = v267;
      if (v123 <= 0x40) {
        break;
      }
      *((void *)&v271 + v120--) = -1;
      if (v124) {
        goto LABEL_182;
      }
LABEL_170:
      ++v282;
    }
    *((void *)&v271 + v120--) = *(void *)v267;
LABEL_182:
    MEMORY[0x1852FDE40]();
    goto LABEL_170;
  }
LABEL_183:
  if (InputAttributeNames
    && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames) == 3)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v280, InputAttributeNames, 0);
    uint64_t v125 = InputAttributeNames;
    uint64_t v126 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v277, v125, v126);
    int v127 = 2;
    while (1)
    {
      BOOL v128 = v280 == (const char *)v277 && v281 == BYTE8(v277);
      if (v128 && v282 == v278) {
        goto LABEL_200;
      }
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v280, (llvm::APInt *)&v267);
      int v129 = DWORD2(v267);
      if (DWORD2(v267) < 0x41)
      {
        *((void *)&v269 + v127--) = v267;
        goto LABEL_187;
      }
      unsigned int v130 = v129 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v267);
      uint64_t v131 = v267;
      if (v130 <= 0x40) {
        break;
      }
      *((void *)&v269 + v127--) = -1;
      if (v131) {
        goto LABEL_199;
      }
LABEL_187:
      ++v282;
    }
    *((void *)&v269 + v127--) = *(void *)v267;
LABEL_199:
    MEMORY[0x1852FDE40]();
    goto LABEL_187;
  }
LABEL_200:
  if (Rewriter && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter) == 6)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v280, Rewriter, 0);
    uint64_t v132 = Rewriter;
    uint64_t v133 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v277, v132, v133);
    int v134 = 5;
    while (1)
    {
      BOOL v135 = v280 == (const char *)v277 && v281 == BYTE8(v277);
      if (v135 && v282 == v278) {
        goto LABEL_217;
      }
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v280, (llvm::APInt *)&v267);
      int v136 = DWORD2(v267);
      if (DWORD2(v267) < 0x41)
      {
        *((void *)&v288 + v134--) = v267;
        goto LABEL_204;
      }
      unsigned int v137 = v136 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v267);
      uint64_t v138 = v267;
      if (v137 <= 0x40) {
        break;
      }
      *((void *)&v288 + v134--) = -1;
      if (v138) {
        goto LABEL_216;
      }
LABEL_204:
      ++v282;
    }
    *((void *)&v288 + v134--) = *(void *)v267;
LABEL_216:
    MEMORY[0x1852FDE40]();
    goto LABEL_204;
  }
LABEL_217:
  if (v260 == 4)
  {
    uint64_t v139 = v112 - v104 + 4;
    uint64_t v140 = 24;
    if (v139 > 2) {
      uint64_t v140 = 16;
    }
    uint64_t v141 = *(void *)(v257 + v140);
    BOOL v142 = __OFSUB__(v139, 1);
    BOOL v18 = v139 == 1;
    uint64_t v143 = 8;
    if (((uint64_t)(v112 - v104 + 3) < 0) ^ v142 | v18) {
      uint64_t v143 = 16;
    }
    uint64_t v144 = *(void *)(v257 + v143);
    BOOL v145 = (uint64_t)(v112 - v104 + 3) < 0 != v142;
    uint64_t v146 = v141 - 1;
    uint64_t v147 = v144 - 1;
    uint64_t v148 = *(void *)(v257 + 8 * v145) - 1;
  }
  else
  {
    uint64_t v146 = 0;
    uint64_t v147 = 0;
    uint64_t v148 = 0;
  }
  unsigned int PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v276);
  if (PaddingStyle >= 3 && PaddingStyle != 4) {
    __assert_rtn("createDepthwiseConv3D", "GPUDepthwiseConvOps.mm", 791, "0 && \"Unknown paddingStyle\"");
  }
  uint64_t v150 = v269 * v146 + 1;
  if (PaddingStyle)
  {
    if (PaddingStyle == 2 || PaddingStyle == 4)
    {
      unint64_t v151 = v271;
      if (v114 % (unint64_t)v271) {
        unint64_t v151 = v114 % (unint64_t)v271;
      }
      unint64_t v152 = (v150 - v151) & ~((uint64_t)(v150 - v151) >> 63);
      unint64_t v153 = v152 >> 1;
      unint64_t v154 = v152 - (v152 >> 1);
      if (PaddingStyle != 4) {
        unint64_t v154 = v153;
      }
    }
    else
    {
      unint64_t v154 = 0;
    }
    if (v150 < 0) {
      uint64_t v150 = v269 * v146 + 2;
    }
    uint64_t v155 = (v150 >> 1) - v154;
    uint64_t v156 = *((void *)&v269 + 1) * v147 + 1;
    if (PaddingStyle == 4 || PaddingStyle == 2)
    {
      unint64_t v157 = *((void *)&v271 + 1);
      if (v113 % *((void *)&v271 + 1)) {
        unint64_t v157 = v113 % *((void *)&v271 + 1);
      }
      unint64_t v158 = (v156 - v157) & ~((uint64_t)(v156 - v157) >> 63);
      unint64_t v159 = v158 >> 1;
      unint64_t v160 = v158 - (v158 >> 1);
      if (PaddingStyle != 4) {
        unint64_t v160 = v159;
      }
    }
    else
    {
      unint64_t v160 = 0;
    }
    if (v156 < 0) {
      uint64_t v156 = *((void *)&v269 + 1) * v147 + 2;
    }
    uint64_t v161 = (v156 >> 1) - v160;
    uint64_t v162 = v270 * v148 + 1;
    if (PaddingStyle == 4 || PaddingStyle == 2)
    {
      unint64_t v163 = v272;
      if (v111 % v272) {
        unint64_t v163 = v111 % v272;
      }
      unint64_t v164 = (v162 - v163) & ~((uint64_t)(v162 - v163) >> 63);
      unint64_t v165 = v164 >> 1;
      unint64_t v166 = v164 - (v164 >> 1);
      if (PaddingStyle == 4) {
        unint64_t v167 = v166;
      }
      else {
        unint64_t v167 = v165;
      }
    }
    else
    {
      unint64_t v167 = 0;
    }
  }
  else
  {
    if (v150 < 0) {
      uint64_t v150 = v269 * v146 + 2;
    }
    uint64_t v155 = (v150 >> 1) - *((void *)&v288 + 1);
    uint64_t v161 = (*((void *)&v269 + 1) * v147 + 1) / 2 - *((void *)&v289 + 1);
    uint64_t v162 = v270 * v148 + 1;
    unint64_t v167 = *((void *)&v290 + 1);
  }
  if (v162 >= 0) {
    uint64_t v168 = v162;
  }
  else {
    uint64_t v168 = v162 + 1;
  }
  unint64_t v169 = (void *)[objc_alloc(MEMORY[0x1E4F35718]) initWithDevice:v107];
  std::string v280 = (const char *)v155;
  uint64_t v281 = v161;
  uint64_t v282 = (const char *)((v168 >> 1) - v167);
  [v169 setWindowOffsets:&v280];
  long long v277 = v271;
  v278 = (const char *)v272;
  [v169 setConvStrides:&v277];
  long long v267 = v269;
  uint64_t v268 = v270;
  [v169 setConvDilationRates:&v267];
  [v169 setChannelAxis:v258 + ~v259];
  objc_msgSend(v169, "setOptions:", objc_msgSend(v169, "options") | 1);

  if (*((unsigned char *)v95 + (int)*MEMORY[0x1E4F359C0])) {
    objc_msgSend(v95, "setReadCount:", objc_msgSend(v95, "readCount") + 1);
  }
  v287[0] = v95;
  v287[1] = v265;
  uint64_t v170 = [MEMORY[0x1E4F1C978] arrayWithObjects:v287 count:2];
  v171 = [v169 resultStateForSourceArrays:v170 sourceStates:0 destinationArray:v95];

  uint64_t v172 = (void *)*((void *)v262 + 9);
  if (!v172)
  {
    uint64_t v173 = [objc_alloc(MEMORY[0x1E4F35528]) initWithCommandBuffer:*((void *)v262 + 1) withDispatchType:0];
    unsigned __int8 v174 = (void *)*((void *)v262 + 9);
    *((void *)v262 + 9) = v173;

    uint64_t v175 = (void *)*((void *)v262 + 11);
    uint64_t v172 = (void *)*((void *)v262 + 9);
    if (v175)
    {
      uint64_t v176 = [v175 wrapComputeEncoder:*((void *)v262 + 9)];
      id v177 = (void *)*((void *)v262 + 9);
      *((void *)v262 + 9) = v176;

      uint64_t v172 = (void *)*((void *)v262 + 9);
    }
  }
  if (*((void *)v262 + 10))
  {
    objc_msgSend(v172, "setLabel:");
    uint64_t v172 = (void *)*((void *)v262 + 9);
  }
  id v178 = v172;
  uint64_t v179 = *((void *)v262 + 1);
  v286[0] = v95;
  v286[1] = v265;
  int64x2_t v180 = [MEMORY[0x1E4F1C978] arrayWithObjects:v286 count:2];
  v285[0] = v95;
  int64x2_t v181 = [MEMORY[0x1E4F1CA98] null];
  v285[1] = v181;
  int64x2_t v182 = [MEMORY[0x1E4F1C978] arrayWithObjects:v285 count:2];
  [v169 encodeGradientsToCommandEncoder:v178 commandBuffer:v179 sourceArrays:v180 sourceGradient:v261 gradientState:v171 destinationGradients:v182 kernelDAGObject:0];
}

void sub_180D63CB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  if (*(_DWORD *)(v18 - 240) >= 0x41u)
  {
    uint64_t v20 = *(void *)(v18 - 248);
    if (v20) {
      MEMORY[0x1852FDE40](v20, 0x1000C8000313F17);
    }
  }

  _Unwind_Resume(a1);
}

unint64_t GPU::DepthwiseConv3DDataGradientOpHandler::getJITStaticOperandRepr(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  if (a4 == 2) {
    return GPU::BaseOpHandler::_getJITStaticOperandReprConstant(this, a2, a3, 2u);
  }
  else {
    return GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(this, a2, a3, a4);
  }
}

void GPU::DepthwiseConv3DWeightsGradientOpHandler::encodeNDArrayOp(GPU::DepthwiseConv3DWeightsGradientOpHandler *this, GPU::EncodeDescriptor *a2, NSArray *a3)
{
  uint64_t v200 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a3;
  uint64_t v6 = *(void *)(*((void *)this + 3) + 48);
  uint64_t v7 = *(void **)(v6 + 16);
  if (v7 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    *(void *)&long long v197 = *(void *)(v6 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v197);
    if (v161 == 38)
    {
      BOOL v162 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      BOOL v163 = v162 && AttrData[2] == 0x65775F64335F766ELL;
      BOOL v164 = v163 && AttrData[3] == 0x72675F7374686769;
      if (v164 && *(void *)((char *)AttrData + 30) == 0x746E656964617267)
      {
        __int16 v183 = 1283;
        uint64_t v179 = "classof on '";
        int64x2_t v181 = "mps.depthwise_conv_3d_weights_gradient";
        uint64_t v182 = 38;
        *(void *)&long long v176 = "' failed due to the operation not being registered";
        __int16 v178 = 259;
        llvm::operator+((uint64_t *)&v179, (uint64_t *)&v176, (uint64_t)&v197);
        llvm::report_fatal_error((llvm::Twine *)&v197, 1);
      }
    }
LABEL_243:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DWeightsGradientOp,void>::id) {
    goto LABEL_243;
  }
  uint64_t v175 = *((void *)this + 3);
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v175);
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v175);
  unint64_t v10 = (int8x8_t *)*((void *)this + 2);
  *(void *)&long long v197 = Input;
  ParentRegion = mlir::Value::getParentRegion((mlir::Value *)&v197);
  int8x8_t v12 = v10[12];
  if (!*(void *)&v12) {
    goto LABEL_44;
  }
  unint64_t v13 = *((void *)ParentRegion + 2);
  unint64_t v14 = 0x9DDFEA08EB382D69 * (((8 * v13) + 8) ^ HIDWORD(v13));
  unint64_t v15 = 0x9DDFEA08EB382D69 * (HIDWORD(v13) ^ (v14 >> 47) ^ v14);
  unint64_t v16 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
  uint8x8_t v17 = (uint8x8_t)vcnt_s8(v12);
  v17.i16[0] = vaddlv_u8(v17);
  if (v17.u32[0] > 1uLL)
  {
    unint64_t v18 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
    if (v16 >= *(void *)&v12) {
      unint64_t v18 = v16 % *(void *)&v12;
    }
  }
  else
  {
    unint64_t v18 = v16 & (*(void *)&v12 - 1);
  }
  uint64_t v19 = *(void **)(*(void *)&v10[11] + 8 * v18);
  if (!v19) {
    goto LABEL_44;
  }
  uint64_t v20 = (void *)*v19;
  if (!v20) {
    goto LABEL_44;
  }
  if (v17.u32[0] < 2uLL)
  {
    uint64_t v21 = *(void *)&v12 - 1;
    while (1)
    {
      uint64_t v23 = v20[1];
      if (v23 == v16)
      {
        if (v20[2] == v13) {
          goto LABEL_24;
        }
      }
      else if ((v23 & v21) != v18)
      {
        goto LABEL_44;
      }
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        goto LABEL_44;
      }
    }
  }
  while (1)
  {
    unint64_t v22 = v20[1];
    if (v22 == v16) {
      break;
    }
    if (v22 >= *(void *)&v12) {
      v22 %= *(void *)&v12;
    }
    if (v22 != v18) {
      goto LABEL_44;
    }
LABEL_13:
    uint64_t v20 = (void *)*v20;
    if (!v20) {
      goto LABEL_44;
    }
  }
  if (v20[2] != v13) {
    goto LABEL_13;
  }
LABEL_24:
  int8x8_t v24 = (int8x8_t)v20[4];
  if (v24)
  {
    unint64_t v25 = 0x9DDFEA08EB382D69 * (((8 * v197) + 8) ^ DWORD1(v197));
    unint64_t v26 = 0x9DDFEA08EB382D69 * (DWORD1(v197) ^ (v25 >> 47) ^ v25);
    unint64_t v27 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
    uint8x8_t v28 = (uint8x8_t)vcnt_s8(v24);
    v28.i16[0] = vaddlv_u8(v28);
    if (v28.u32[0] > 1uLL)
    {
      unint64_t v29 = v27;
      if (v27 >= *(void *)&v24) {
        unint64_t v29 = v27 % *(void *)&v24;
      }
    }
    else
    {
      unint64_t v29 = v27 & (*(void *)&v24 - 1);
    }
    uint64_t v30 = *(uint64_t ****)(v20[3] + 8 * v29);
    if (v30)
    {
      unint64_t v31 = *v30;
      if (v31)
      {
        if (v28.u32[0] < 2uLL)
        {
          uint64_t v32 = *(void *)&v24 - 1;
          while (1)
          {
            uint64_t v35 = v31[1];
            if (v35 == (uint64_t *)v27)
            {
              if (v31[2] == (uint64_t *)v197) {
                goto LABEL_213;
              }
            }
            else if (((unint64_t)v35 & v32) != v29)
            {
              goto LABEL_44;
            }
            uint64_t v33 = 0;
            unint64_t v31 = (uint64_t **)*v31;
            if (!v31) {
              goto LABEL_45;
            }
          }
        }
        while (1)
        {
          unint64_t v34 = (unint64_t)v31[1];
          if (v34 == v27)
          {
            if (v31[2] == (uint64_t *)v197)
            {
LABEL_213:
              uint64_t v33 = v31[3];
              goto LABEL_45;
            }
          }
          else
          {
            if (v34 >= *(void *)&v24) {
              v34 %= *(void *)&v24;
            }
            if (v34 != v29) {
              break;
            }
          }
          uint64_t v33 = 0;
          unint64_t v31 = (uint64_t **)*v31;
          if (!v31) {
            goto LABEL_45;
          }
        }
      }
    }
  }
LABEL_44:
  uint64_t v33 = 0;
LABEL_45:
  uint64_t v173 = [v33 mpsndarray];

  uint64_t v36 = (int8x8_t *)*((void *)this + 2);
  *(void *)&long long v197 = Filter;
  BOOL v37 = mlir::Value::getParentRegion((mlir::Value *)&v197);
  int8x8_t v38 = v36[12];
  if (!*(void *)&v38) {
    goto LABEL_86;
  }
  unint64_t v39 = *((void *)v37 + 2);
  unint64_t v40 = 0x9DDFEA08EB382D69 * (((8 * v39) + 8) ^ HIDWORD(v39));
  unint64_t v41 = 0x9DDFEA08EB382D69 * (HIDWORD(v39) ^ (v40 >> 47) ^ v40);
  unint64_t v42 = 0x9DDFEA08EB382D69 * (v41 ^ (v41 >> 47));
  uint8x8_t v43 = (uint8x8_t)vcnt_s8(v38);
  v43.i16[0] = vaddlv_u8(v43);
  if (v43.u32[0] > 1uLL)
  {
    unint64_t v44 = 0x9DDFEA08EB382D69 * (v41 ^ (v41 >> 47));
    if (v42 >= *(void *)&v38) {
      unint64_t v44 = v42 % *(void *)&v38;
    }
  }
  else
  {
    unint64_t v44 = v42 & (*(void *)&v38 - 1);
  }
  uint8x8_t v45 = *(void **)(*(void *)&v36[11] + 8 * v44);
  if (!v45) {
    goto LABEL_86;
  }
  unint64_t v46 = (void *)*v45;
  if (!v46) {
    goto LABEL_86;
  }
  if (v43.u32[0] < 2uLL)
  {
    uint64_t v47 = *(void *)&v38 - 1;
    while (1)
    {
      uint64_t v49 = v46[1];
      if (v49 == v42)
      {
        if (v46[2] == v39) {
          goto LABEL_66;
        }
      }
      else if ((v49 & v47) != v44)
      {
        goto LABEL_86;
      }
      unint64_t v46 = (void *)*v46;
      if (!v46) {
        goto LABEL_86;
      }
    }
  }
  while (1)
  {
    unint64_t v48 = v46[1];
    if (v48 == v42) {
      break;
    }
    if (v48 >= *(void *)&v38) {
      v48 %= *(void *)&v38;
    }
    if (v48 != v44) {
      goto LABEL_86;
    }
LABEL_55:
    unint64_t v46 = (void *)*v46;
    if (!v46) {
      goto LABEL_86;
    }
  }
  if (v46[2] != v39) {
    goto LABEL_55;
  }
LABEL_66:
  int8x8_t v50 = (int8x8_t)v46[4];
  if (!*(void *)&v50) {
    goto LABEL_86;
  }
  unint64_t v51 = 0x9DDFEA08EB382D69 * (((8 * v197) + 8) ^ DWORD1(v197));
  unint64_t v52 = 0x9DDFEA08EB382D69 * (DWORD1(v197) ^ (v51 >> 47) ^ v51);
  unint64_t v53 = 0x9DDFEA08EB382D69 * (v52 ^ (v52 >> 47));
  uint8x8_t v54 = (uint8x8_t)vcnt_s8(v50);
  v54.i16[0] = vaddlv_u8(v54);
  if (v54.u32[0] > 1uLL)
  {
    unint64_t v55 = v53;
    if (v53 >= *(void *)&v50) {
      unint64_t v55 = v53 % *(void *)&v50;
    }
  }
  else
  {
    unint64_t v55 = v53 & (*(void *)&v50 - 1);
  }
  uint8x8_t v56 = *(uint64_t ****)(v46[3] + 8 * v55);
  if (!v56 || (unint64_t v57 = *v56) == 0)
  {
LABEL_86:
    unsigned int v59 = 0;
    goto LABEL_87;
  }
  if (v54.u32[0] < 2uLL)
  {
    uint64_t v58 = *(void *)&v50 - 1;
    while (1)
    {
      uint64_t v61 = v57[1];
      if (v61 == (uint64_t *)v53)
      {
        if (v57[2] == (uint64_t *)v197) {
          goto LABEL_214;
        }
      }
      else if (((unint64_t)v61 & v58) != v55)
      {
        goto LABEL_86;
      }
      unsigned int v59 = 0;
      unint64_t v57 = (uint64_t **)*v57;
      if (!v57) {
        goto LABEL_87;
      }
    }
  }
  while (1)
  {
    unint64_t v60 = (unint64_t)v57[1];
    if (v60 == v53) {
      break;
    }
    if (v60 >= *(void *)&v50) {
      v60 %= *(void *)&v50;
    }
    if (v60 != v55) {
      goto LABEL_86;
    }
LABEL_76:
    unsigned int v59 = 0;
    unint64_t v57 = (uint64_t **)*v57;
    if (!v57) {
      goto LABEL_87;
    }
  }
  if (v57[2] != (uint64_t *)v197) {
    goto LABEL_76;
  }
LABEL_214:
  unsigned int v59 = v57[3];
LABEL_87:
  unsigned __int8 v174 = [v59 mpsndarray];

  uint64_t v172 = [(NSArray *)v5 objectAtIndexedSubscript:0];
  uint64_t v62 = [v172 mpsndarray];
  uint64_t v63 = (void *)v62;
  if ((!v173 || !v174 || !v62) && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  if (*((void *)this + 4) && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  uint64_t Result = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v175);
  unint64_t StaticType = GPURegionRuntime::getStaticType(*((void *)this + 2), Result);
  if (!*(void *)StaticType)
  {
    unint64_t v152 = "abstractType && \"Malformed type storage object.\"";
    int v153 = 160;
    unint64_t v154 = "TypeSupport.h";
    uint64_t v155 = "getAbstractType";
    goto LABEL_222;
  }
  if (*(_UNKNOWN **)(*(void *)StaticType + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    unint64_t v152 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v153 = 566;
    unint64_t v154 = "Casting.h";
    uint64_t v155 = "cast";
LABEL_222:
    __assert_rtn(v155, v154, v153, v152);
  }
  *(void *)&long long v197 = StaticType;
  uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v197);
  uint64_t v68 = v67;
  unint64_t v69 = GPURegionRuntime::getStaticType(*((void *)this + 2), Filter);
  if (!*(void *)v69)
  {
    uint64_t v156 = "abstractType && \"Malformed type storage object.\"";
    int v157 = 160;
    unint64_t v158 = "TypeSupport.h";
    unint64_t v159 = "getAbstractType";
    goto LABEL_225;
  }
  if (*(_UNKNOWN **)(*(void *)v69 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    uint64_t v156 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v157 = 566;
    unint64_t v158 = "Casting.h";
    unint64_t v159 = "cast";
LABEL_225:
    __assert_rtn(v159, v158, v157, v156);
  }
  *(void *)&long long v197 = v69;
  uint64_t v70 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v197);
  unint64_t v72 = v71;
  uint64_t v73 = v175;
  unint64_t v74 = [*(id *)(*((void *)this + 2) + 48) metalDevice];
  uint64_t v193 = v73;
  id v75 = v74;
  uint64_t Strides = mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v193);
  uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v193);
  long long v198 = 0u;
  long long v199 = 0u;
  long long v197 = 0u;
  uint64_t v170 = v68;
  uint64_t v166 = Value;
  unint64_t v169 = a2;
  v171 = v5;
  uint64_t Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v193);
  int ChannelAxis = mlir::mps::DepthwiseConv3DDataGradientOp::getChannelAxis((mlir::mps::DepthwiseConv3DDataGradientOp *)&v193);
  if (ChannelAxis >= 0) {
    unint64_t v77 = v72;
  }
  else {
    unint64_t v77 = 0;
  }
  unint64_t v167 = v77;
  uint64_t v168 = ChannelAxis;
  if (ChannelAxis >= 0) {
    unint64_t v78 = 0;
  }
  else {
    unint64_t v78 = v72;
  }
  long long v188 = xmmword_18112A6B0;
  unint64_t v79 = 1;
  unint64_t v189 = 1;
  int64_t v80 = v78 + ChannelAxis;
  long long v186 = xmmword_18112A6B0;
  uint64_t v187 = 1;
  unint64_t v81 = 1;
  unint64_t v82 = 1;
  if (v72 >= 3)
  {
    unint64_t v83 = (int)(v72 - 1 - (v80 >= (int)v72 - 1));
    if (v72 <= v83
      || (unint64_t v84 = (int)(v72 - 2 - (v80 >= (int)v72 - 2)), v72 <= v84)
      || (unint64_t v85 = (int)(v72 - 3 - (v80 >= (int)v72 - 3)), v72 <= v85))
    {
      __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
    }
    unint64_t v82 = *(void *)(v70 + 8 * v83);
    unint64_t v81 = *(void *)(v70 + 8 * v84);
    unint64_t v79 = *(void *)(v70 + 8 * v85);
  }
  if (Strides && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides) == 3)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v179, Strides, 0);
    uint64_t v86 = Strides;
    uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v176, v86, NumElements);
    int v88 = 2;
    while (1)
    {
      BOOL v89 = v179 == (const char *)v176 && v180 == BYTE8(v176);
      if (v89 && v181 == v177) {
        goto LABEL_123;
      }
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v179, (llvm::APInt *)&v184);
      int v90 = DWORD2(v184);
      if (DWORD2(v184) < 0x41)
      {
        *((void *)&v188 + v88--) = v184;
        goto LABEL_110;
      }
      unsigned int v91 = v90 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v184);
      uint64_t v92 = v184;
      if (v91 <= 0x40) {
        break;
      }
      *((void *)&v188 + v88--) = -1;
      if (v92) {
        goto LABEL_122;
      }
LABEL_110:
      ++v181;
    }
    *((void *)&v188 + v88--) = *(void *)v184;
LABEL_122:
    MEMORY[0x1852FDE40]();
    goto LABEL_110;
  }
LABEL_123:
  if (InputAttributeNames
    && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames) == 3)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v179, InputAttributeNames, 0);
    uint64_t v93 = InputAttributeNames;
    uint64_t v94 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v176, v93, v94);
    int v95 = 2;
    while (1)
    {
      BOOL v96 = v179 == (const char *)v176 && v180 == BYTE8(v176);
      if (v96 && v181 == v177) {
        goto LABEL_140;
      }
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v179, (llvm::APInt *)&v184);
      int v97 = DWORD2(v184);
      if (DWORD2(v184) < 0x41)
      {
        *((void *)&v186 + v95--) = v184;
        goto LABEL_127;
      }
      unsigned int v98 = v97 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v184);
      uint64_t v99 = v184;
      if (v98 <= 0x40) {
        break;
      }
      *((void *)&v186 + v95--) = -1;
      if (v99) {
        goto LABEL_139;
      }
LABEL_127:
      ++v181;
    }
    *((void *)&v186 + v95--) = *(void *)v184;
LABEL_139:
    MEMORY[0x1852FDE40]();
    goto LABEL_127;
  }
LABEL_140:
  if (Rewriter && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter) == 6)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v179, Rewriter, 0);
    uint64_t v100 = Rewriter;
    uint64_t v101 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v176, v100, v101);
    int v102 = 5;
    while (1)
    {
      BOOL v103 = v179 == (const char *)v176 && v180 == BYTE8(v176);
      if (v103 && v181 == v177) {
        goto LABEL_157;
      }
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v179, (llvm::APInt *)&v184);
      int v104 = DWORD2(v184);
      if (DWORD2(v184) < 0x41)
      {
        *((void *)&v197 + v102--) = v184;
        goto LABEL_144;
      }
      unsigned int v105 = v104 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v184);
      uint64_t v106 = v184;
      if (v105 <= 0x40) {
        break;
      }
      *((void *)&v197 + v102--) = -1;
      if (v106) {
        goto LABEL_156;
      }
LABEL_144:
      ++v181;
    }
    *((void *)&v197 + v102--) = *(void *)v184;
LABEL_156:
    MEMORY[0x1852FDE40]();
    goto LABEL_144;
  }
LABEL_157:
  if (v170 == 4)
  {
    uint64_t v107 = v80 - v72 + 4;
    uint64_t v108 = 24;
    if (v107 > 2) {
      uint64_t v108 = 16;
    }
    uint64_t v109 = *(void *)(v166 + v108);
    BOOL v110 = __OFSUB__(v107, 1);
    BOOL v89 = v107 == 1;
    uint64_t v111 = 8;
    if (((uint64_t)(v80 - v72 + 3) < 0) ^ v110 | v89) {
      uint64_t v111 = 16;
    }
    uint64_t v112 = *(void *)(v166 + v111);
    BOOL v113 = (uint64_t)(v80 - v72 + 3) < 0 != v110;
    uint64_t v114 = v109 - 1;
    uint64_t v115 = v112 - 1;
    uint64_t v116 = *(void *)(v166 + 8 * v113) - 1;
  }
  else
  {
    uint64_t v114 = 0;
    uint64_t v115 = 0;
    uint64_t v116 = 0;
  }
  unsigned int PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v193);
  if (PaddingStyle >= 3 && PaddingStyle != 4) {
    __assert_rtn("createDepthwiseConv3D", "GPUDepthwiseConvOps.mm", 791, "0 && \"Unknown paddingStyle\"");
  }
  uint64_t v118 = v186 * v114 + 1;
  if (PaddingStyle)
  {
    if (PaddingStyle == 2 || PaddingStyle == 4)
    {
      unint64_t v119 = v188;
      if (v82 % (unint64_t)v188) {
        unint64_t v119 = v82 % (unint64_t)v188;
      }
      unint64_t v120 = (v118 - v119) & ~((uint64_t)(v118 - v119) >> 63);
      unint64_t v121 = v120 >> 1;
      unint64_t v122 = v120 - (v120 >> 1);
      if (PaddingStyle != 4) {
        unint64_t v122 = v121;
      }
    }
    else
    {
      unint64_t v122 = 0;
    }
    if (v118 < 0) {
      uint64_t v118 = v186 * v114 + 2;
    }
    unsigned int v123 = (const char *)((v118 >> 1) - v122);
    uint64_t v124 = *((void *)&v186 + 1) * v115 + 1;
    if (PaddingStyle == 4 || PaddingStyle == 2)
    {
      unint64_t v125 = *((void *)&v188 + 1);
      if (v81 % *((void *)&v188 + 1)) {
        unint64_t v125 = v81 % *((void *)&v188 + 1);
      }
      unint64_t v126 = (v124 - v125) & ~((uint64_t)(v124 - v125) >> 63);
      unint64_t v127 = v126 >> 1;
      unint64_t v128 = v126 - (v126 >> 1);
      if (PaddingStyle != 4) {
        unint64_t v128 = v127;
      }
    }
    else
    {
      unint64_t v128 = 0;
    }
    if (v124 < 0) {
      uint64_t v124 = *((void *)&v186 + 1) * v115 + 2;
    }
    uint64_t v129 = (v124 >> 1) - v128;
    uint64_t v130 = v187 * v116 + 1;
    BOOL v135 = v169;
    if (PaddingStyle == 4 || PaddingStyle == 2)
    {
      unint64_t v131 = v189;
      if (v79 % v189) {
        unint64_t v131 = v79 % v189;
      }
      unint64_t v132 = (v130 - v131) & ~((uint64_t)(v130 - v131) >> 63);
      unint64_t v133 = v132 >> 1;
      unint64_t v134 = v132 - (v132 >> 1);
      if (PaddingStyle == 4) {
        unint64_t v136 = v134;
      }
      else {
        unint64_t v136 = v133;
      }
    }
    else
    {
      unint64_t v136 = 0;
    }
  }
  else
  {
    if (v118 < 0) {
      uint64_t v118 = v186 * v114 + 2;
    }
    unsigned int v123 = (const char *)((v118 >> 1) - *((void *)&v197 + 1));
    uint64_t v129 = (*((void *)&v186 + 1) * v115 + 1) / 2 - *((void *)&v198 + 1);
    uint64_t v130 = v187 * v116 + 1;
    BOOL v135 = v169;
    unint64_t v136 = *((void *)&v199 + 1);
  }
  if (v130 >= 0) {
    uint64_t v137 = v130;
  }
  else {
    uint64_t v137 = v130 + 1;
  }
  uint64_t v138 = (void *)[objc_alloc(MEMORY[0x1E4F35718]) initWithDevice:v75];
  uint64_t v179 = v123;
  uint64_t v180 = v129;
  int64x2_t v181 = (const char *)((v137 >> 1) - v136);
  [v138 setWindowOffsets:&v179];
  long long v176 = v188;
  id v177 = (const char *)v189;
  [v138 setConvStrides:&v176];
  long long v184 = v186;
  uint64_t v185 = v187;
  [v138 setConvDilationRates:&v184];
  [v138 setChannelAxis:v167 + ~v168];
  objc_msgSend(v138, "setOptions:", objc_msgSend(v138, "options") | 1);

  if (*((unsigned char *)v63 + (int)*MEMORY[0x1E4F359C0])) {
    objc_msgSend(v63, "setReadCount:", objc_msgSend(v63, "readCount") + 1);
  }
  v196[0] = v174;
  v196[1] = v63;
  uint64_t v139 = [MEMORY[0x1E4F1C978] arrayWithObjects:v196 count:2];
  uint64_t v140 = [v138 resultStateForSourceArrays:v139 sourceStates:0 destinationArray:v63];

  uint64_t v141 = (void *)*((void *)v135 + 9);
  if (!v141)
  {
    uint64_t v142 = [objc_alloc(MEMORY[0x1E4F35528]) initWithCommandBuffer:*((void *)v135 + 1) withDispatchType:0];
    uint64_t v143 = (void *)*((void *)v135 + 9);
    *((void *)v135 + 9) = v142;

    uint64_t v144 = (void *)*((void *)v135 + 11);
    uint64_t v141 = (void *)*((void *)v135 + 9);
    if (v144)
    {
      uint64_t v145 = [v144 wrapComputeEncoder:*((void *)v135 + 9)];
      uint64_t v146 = (void *)*((void *)v135 + 9);
      *((void *)v135 + 9) = v145;

      uint64_t v141 = (void *)*((void *)v135 + 9);
    }
  }
  if (*((void *)v135 + 10))
  {
    objc_msgSend(v141, "setLabel:");
    uint64_t v141 = (void *)*((void *)v135 + 9);
  }
  id v147 = v141;
  uint64_t v148 = *((void *)v135 + 1);
  v195[0] = v174;
  v195[1] = v63;
  unint64_t v149 = [MEMORY[0x1E4F1C978] arrayWithObjects:v195 count:2];
  uint64_t v150 = [MEMORY[0x1E4F1CA98] null];
  v194[0] = v150;
  v194[1] = v63;
  unint64_t v151 = [MEMORY[0x1E4F1C978] arrayWithObjects:v194 count:2];
  [v138 encodeGradientsToCommandEncoder:v147 commandBuffer:v148 sourceArrays:v149 sourceGradient:v173 gradientState:v140 destinationGradients:v151 kernelDAGObject:0];
}

void sub_180D64F1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

unint64_t GPU::DepthwiseConv3DWeightsGradientOpHandler::getJITStaticOperandRepr(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  if (a4 == 2) {
    return GPU::BaseOpHandler::_getJITStaticOperandReprConstant(this, a2, a3, 2u);
  }
  else {
    return GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(this, a2, a3, a4);
  }
}

void GPU::DepthwiseConv2DOpHandler::~DepthwiseConv2DOpHandler(GPU::DepthwiseConv2DOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);

  JUMPOUT(0x1852FDE70);
}

void GPU::DepthwiseConv2DDataGradientOpHandler::~DepthwiseConv2DDataGradientOpHandler(GPU::DepthwiseConv2DDataGradientOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);

  JUMPOUT(0x1852FDE70);
}

void GPU::DepthwiseConv2DWeightsGradientOpHandler::~DepthwiseConv2DWeightsGradientOpHandler(GPU::DepthwiseConv2DWeightsGradientOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);

  JUMPOUT(0x1852FDE70);
}

uint64_t GPU::DepthwiseConv3DOpHandler::kernelDAGOp(uint64_t a1, uint64_t a2)
{
  id v3 = *(GPU::DepthwiseConv3DOpHandler **)(a1 + 24);
  uint64_t v4 = *((void *)v3 + 6);
  uint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v18[0] = *(void *)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v18);
    if (v11 == 21)
    {
      BOOL v12 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      if (v12 && *(void *)((char *)AttrData + 13) == 0x64335F766E6F635FLL)
      {
        __int16 v17 = 1283;
        v16[0] = (uint64_t)"classof on '";
        v16[2] = (uint64_t)"mps.depthwise_conv_3d";
        v16[3] = 21;
        v14[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v15 = 259;
        llvm::operator+(v16, v14, (uint64_t)v18);
        llvm::report_fatal_error((llvm::Twine *)v18, 1);
      }
    }
LABEL_17:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id) {
    goto LABEL_17;
  }
  v18[0] = v3;
  v16[0] = 0;
  v14[0] = 0;
  if (GPU::DepthwiseConv3DOpHandler::getQuantizationParameters(v3, (mlir::Value *)v16, (mlir::Value *)v14))
  {
    GPU::MPSGraphKernelDAG::getBaseTensorFromDataMap(a2, v16[0], 0);
    GPU::MPSGraphKernelDAG::getBaseTensorFromDataMap(a2, v14[0], 0);
    MPSKernelDAG::binaryCoreOp();
    uint64_t result = MPSKernelDAG::castOp();
  }
  else
  {
    unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)v18);
    GPU::MPSGraphKernelDAG::getBaseTensorFromDataMap(a2, Input, 0);
    unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)v18);
    GPU::MPSGraphKernelDAG::getBaseTensorFromDataMap(a2, Filter, 0);
    uint64_t result = MPSKernelDAG::binaryCoreOp();
  }
  *(void *)(a2 + 104) = *(void *)(a1 + 24);
  return result;
}

void GPU::DepthwiseConv3DOpHandler::~DepthwiseConv3DOpHandler(GPU::DepthwiseConv3DOpHandler *this)
{
  *(void *)this = &unk_1EC9A0908;
  uint64_t v2 = *((void *)this + 15);
  *((void *)this + 15) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  GPU::BaseOpHandler::~BaseOpHandler(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1EC9A0908;
  uint64_t v2 = *((void *)this + 15);
  *((void *)this + 15) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  GPU::BaseOpHandler::~BaseOpHandler(this);

  JUMPOUT(0x1852FDE70);
}

void GPU::DepthwiseConv3DDataGradientOpHandler::~DepthwiseConv3DDataGradientOpHandler(GPU::DepthwiseConv3DDataGradientOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);

  JUMPOUT(0x1852FDE70);
}

void GPU::DepthwiseConv3DWeightsGradientOpHandler::~DepthwiseConv3DWeightsGradientOpHandler(GPU::DepthwiseConv3DWeightsGradientOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);

  JUMPOUT(0x1852FDE70);
}

void GPU::MPSGraphKernelDAG::MPSGraphKernelDAG(GPU::MPSGraphKernelDAG *this, GPURegionRuntime *a2, mlir::Operation *a3)
{
  *(void *)this = &unk_1EC99E538;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((void *)this + 5) = 0;
  *((_DWORD *)this + 12) = 1065353216;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((void *)this + 11) = 0;
  *((void *)this + 14) = a3;
  *((void *)this + 15) = 0;
  *((void *)this + 16) = a2;
  *((void *)this + 17) = 0;
  operator new();
}

void sub_180D656C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  uint64_t v14 = *(void *)(v11 + 136);
  *(void *)(v11 + 136) = 0;
  if (v14)
  {
    (*(void (**)(uint64_t))(*(void *)v14 + 24))(v14);

    mlir::FrozenRewritePatternSet::~FrozenRewritePatternSet((mlir::FrozenRewritePatternSet *)(v11 + 80));
    BOOL v12 = *(void **)(v11 + 56);
    if (v12)
    {
LABEL_6:
      *(void *)(v11 + 64) = v12;
      operator delete(v12);
      std::unordered_set<mlir::Operation *>::~unordered_set[abi:ne180100](v11 + 16);
      _Unwind_Resume(a1);
    }
  }
  else
  {

    mlir::FrozenRewritePatternSet::~FrozenRewritePatternSet((mlir::FrozenRewritePatternSet *)(v11 + 80));
    BOOL v12 = *(void **)(v11 + 56);
    if (v12) {
      goto LABEL_6;
    }
  }
  std::unordered_set<mlir::Operation *>::~unordered_set[abi:ne180100](v11 + 16);
  _Unwind_Resume(a1);
}

void GPU::MPSGraphKernelDAG::~MPSGraphKernelDAG(GPU::MPSGraphKernelDAG *this)
{
  GPU::MPSGraphKernelDAG::~MPSGraphKernelDAG(this);

  JUMPOUT(0x1852FDE70);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  *(void *)this = &unk_1EC99E538;
  uint64_t v2 = *((void *)this + 17);
  *((void *)this + 17) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  id v3 = (std::__shared_weak_count *)*((void *)this + 11);
  if (!v3 || atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    uint64_t v4 = (void *)*((void *)this + 7);
    if (!v4) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  uint64_t v4 = (void *)*((void *)this + 7);
  if (v4)
  {
LABEL_6:
    *((void *)this + 8) = v4;
    operator delete(v4);
  }
LABEL_7:
  uint64_t v5 = (void *)*((void *)this + 4);
  if (v5)
  {
    do
    {
      uint64_t v6 = (void *)*v5;
      operator delete(v5);
      uint64_t v5 = v6;
    }
    while (v6);
  }
  uint64_t v7 = (void *)*((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v7) {
    operator delete(v7);
  }
}

void std::__shared_ptr_pointer<MPSKernelDAG *,std::shared_ptr<MPSKernelDAG>::__shared_ptr_default_delete<MPSKernelDAG,MPSKernelDAG>,std::allocator<MPSKernelDAG>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1852FDE70);
}

uint64_t std::__shared_ptr_pointer<MPSKernelDAG *,std::shared_ptr<MPSKernelDAG>::__shared_ptr_default_delete<MPSKernelDAG,MPSKernelDAG>,std::allocator<MPSKernelDAG>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<MPSKernelDAG *,std::shared_ptr<MPSKernelDAG>::__shared_ptr_default_delete<MPSKernelDAG,MPSKernelDAG>,std::allocator<MPSKernelDAG>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x800000018112A627) {
    return a1 + 24;
  }
  if (((v3 & 0x800000018112A627 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x800000018112A627)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x800000018112A627 & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 24;
  }
  return 0;
}

uint64_t mlir::mps::MPSFusableCoreOps::isCoreOperandStitchable(mlir::mps::MPSFusableCoreOps *this, mlir::Operation *a2, int a3)
{
  uint64_t v6 = *((void *)a2 + 6);
  uint64_t v7 = *(void **)(v6 + 16);
  if (v7 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v67[0] = *(void *)(v6 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v67);
    if (v9 == 17)
    {
      BOOL v10 = *(void *)AttrData == 0x756465722E73706DLL && *(void *)(AttrData + 8) == 0x75735F6E6F697463;
      if (v10 && *(unsigned char *)(AttrData + 16) == 109)
      {
        __int16 v66 = 1283;
        uint8x8_t v56 = "mps.reduction_sum";
        goto LABEL_90;
      }
    }
  }
  else if (v7 == &mlir::detail::TypeIDResolver<mlir::mps::ReductionSumOp,void>::id)
  {
    return a3 < 1;
  }
  uint64_t v12 = *((void *)a2 + 6);
  unint64_t v13 = *(void **)(v12 + 16);
  if (v13 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v67[0] = *(void *)(v12 + 8);
    uint64_t v15 = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v67);
    if (v16 != 17) {
      goto LABEL_23;
    }
    BOOL v17 = *(void *)v15 == 0x756465722E73706DLL && *(void *)(v15 + 8) == 0x616D5F6E6F697463;
    if (!v17 || *(unsigned char *)(v15 + 16) != 120) {
      goto LABEL_23;
    }
    __int16 v66 = 1283;
    uint8x8_t v56 = "mps.reduction_max";
LABEL_90:
    uint64_t v63 = "classof on '";
    BOOL v64 = v56;
    uint64_t v57 = 17;
    goto LABEL_101;
  }
  if (v13 == &mlir::detail::TypeIDResolver<mlir::mps::ReductionMaxOp,void>::id) {
    return a3 < 1;
  }
LABEL_23:
  uint64_t v19 = *((void *)a2 + 6);
  uint64_t v20 = *(void **)(v19 + 16);
  if (v20 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v67[0] = *(void *)(v19 + 8);
    uint64_t v22 = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v67);
    if (v23 == 10 && *(void *)v22 == 0x6D74616D2E73706DLL && *(_WORD *)(v22 + 8) == 27765)
    {
      __int16 v66 = 1283;
      uint64_t v58 = "mps.matmul";
      goto LABEL_98;
    }
LABEL_31:
    uint64_t v25 = *((void *)a2 + 6);
    unint64_t v26 = *(void **)(v25 + 16);
    if (v26 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v67[0] = *(void *)(v25 + 8);
      unint64_t v27 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v67);
      if (v28 == 11 && *v27 == 0x766E6F632E73706DLL && *(void *)((char *)v27 + 3) == 0x64325F766E6F632ELL)
      {
        __int16 v66 = 1283;
        unsigned int v59 = "mps.conv_2d";
        goto LABEL_96;
      }
    }
    else if (v26 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id)
    {
      uint64_t v21 = (void *)MEMORY[0x1E4F356C8];
      return [v21 supportsPrefixForDevice:*((void *)this + 1)];
    }
    uint64_t v30 = *((void *)a2 + 6);
    unint64_t v31 = *(void **)(v30 + 16);
    if (v31 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v67[0] = *(void *)(v30 + 8);
      uint64_t v32 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v67);
      if (v33 == 8 && *v32 == 0x656C69742E73706DLL)
      {
        __int16 v66 = 1283;
        uint64_t v63 = "classof on '";
        BOOL v64 = "mps.tile";
        uint64_t v57 = 8;
        goto LABEL_101;
      }
    }
    else if (v31 == &mlir::detail::TypeIDResolver<mlir::mps::TileOp,void>::id)
    {
      if (*((unsigned char *)this + 16)) {
        return 0;
      }
      uint64_t v21 = (void *)MEMORY[0x1E4F358E0];
      return [v21 supportsPrefixForDevice:*((void *)this + 1)];
    }
    uint64_t v34 = *((void *)a2 + 6);
    uint64_t v35 = *(void **)(v34 + 16);
    if (v35 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v67[0] = *(void *)(v34 + 8);
      uint64_t v36 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v67);
      if (v37 == 21)
      {
        BOOL v38 = *v36 == 0x747065642E73706DLL && v36[1] == 0x6F635F6573697768;
        if (v38 && *(void *)((char *)v36 + 13) == 0x64335F766E6F635FLL)
        {
          __int16 v66 = 1283;
          unint64_t v60 = "mps.depthwise_conv_3d";
LABEL_100:
          uint64_t v63 = "classof on '";
          BOOL v64 = v60;
          uint64_t v57 = 21;
LABEL_101:
          uint64_t v65 = v57;
          uint64_t v61 = "' failed due to the operation not being registered";
          __int16 v62 = 259;
          llvm::operator+((uint64_t *)&v63, (uint64_t *)&v61, (uint64_t)v67);
          llvm::report_fatal_error((llvm::Twine *)v67, 1);
        }
      }
    }
    else if (v35 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id)
    {
      uint64_t v21 = (void *)MEMORY[0x1E4F35718];
      return [v21 supportsPrefixForDevice:*((void *)this + 1)];
    }
    uint64_t v40 = *((void *)a2 + 6);
    unint64_t v41 = *(void **)(v40 + 16);
    if (v41 != &mlir::detail::TypeIDResolver<void,void>::id)
    {
      if (v41 == &mlir::detail::TypeIDResolver<mlir::mps::StencilOp,void>::id)
      {
        if (*((unsigned char *)this + 16)) {
          return 0;
        }
        uint64_t v21 = (void *)MEMORY[0x1E4F358B8];
        return [v21 supportsPrefixForDevice:*((void *)this + 1)];
      }
      goto LABEL_65;
    }
    v67[0] = *(void *)(v40 + 8);
    unint64_t v42 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v67);
    if (v43 != 11
      || (*v42 == 0x6E6574732E73706DLL ? (BOOL v44 = *(void *)((char *)v42 + 3) == 0x6C69636E6574732ELL) : (BOOL v44 = 0), !v44))
    {
LABEL_65:
      uint64_t v45 = *((void *)a2 + 6);
      unint64_t v46 = *(void **)(v45 + 16);
      if (v46 != &mlir::detail::TypeIDResolver<void,void>::id)
      {
        if (v46 == &mlir::detail::TypeIDResolver<mlir::mps::ResizeOp,void>::id) {
          return 0;
        }
        goto LABEL_73;
      }
      v67[0] = *(void *)(v45 + 8);
      uint64_t v47 = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v67);
      if (v48 != 10
        || (*(void *)v47 == 0x697365722E73706DLL ? (BOOL v49 = *(unsigned __int16 *)(v47 + 8) == 25978) : (BOOL v49 = 0), !v49))
      {
LABEL_73:
        uint64_t v50 = *((void *)a2 + 6);
        unint64_t v51 = *(void **)(v50 + 16);
        if (v51 != &mlir::detail::TypeIDResolver<void,void>::id)
        {
          if (v51 == &mlir::detail::TypeIDResolver<mlir::mpsx::QuantizedMatMulOp,void>::id)
          {
            uint64_t v21 = (void *)MEMORY[0x1E4F35840];
            return [v21 supportsPrefixForDevice:*((void *)this + 1)];
          }
          return 1;
        }
        v67[0] = *(void *)(v50 + 8);
        unint64_t v52 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v67);
        if (v53 != 21) {
          return 1;
        }
        BOOL v54 = *v52 == 0x6175712E7873706DLL && v52[1] == 0x6D5F64657A69746ELL;
        if (!v54 || *(void *)((char *)v52 + 13) != 0x6C756D74616D5F64) {
          return 1;
        }
        __int16 v66 = 1283;
        unint64_t v60 = "mpsx.quantized_matmul";
        goto LABEL_100;
      }
      __int16 v66 = 1283;
      uint64_t v58 = "mps.resize";
LABEL_98:
      uint64_t v63 = "classof on '";
      BOOL v64 = v58;
      uint64_t v57 = 10;
      goto LABEL_101;
    }
    __int16 v66 = 1283;
    unsigned int v59 = "mps.stencil";
LABEL_96:
    uint64_t v63 = "classof on '";
    BOOL v64 = v59;
    uint64_t v57 = 11;
    goto LABEL_101;
  }
  if (v20 != &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id) {
    goto LABEL_31;
  }
  uint64_t v21 = (void *)MEMORY[0x1E4F357B8];
  return [v21 supportsPrefixForDevice:*((void *)this + 1)];
}

uint64_t mlir::mps::MPSFusableCoreOps::isCorePostfixStitchable(mlir::mps::MPSFusableCoreOps *this, mlir::Operation *a2)
{
  uint64_t v4 = *((void *)a2 + 6);
  uint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v124 = *(const char **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v124);
    if (v10 == 10 && *(void *)AttrData == 0x6D74616D2E73706DLL && *(_WORD *)(AttrData + 8) == 27765)
    {
      LOWORD(v122) = 1283;
      int v95 = "mps.matmul";
      goto LABEL_210;
    }
LABEL_11:
    uint64_t v12 = *((void *)a2 + 6);
    unint64_t v13 = *(void **)(v12 + 16);
    if (v13 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      uint64_t v124 = *(const char **)(v12 + 8);
      int8x8_t v24 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v124);
      if (v25 == 11 && *v24 == 0x766E6F632E73706DLL && *(void *)((char *)v24 + 3) == 0x64325F766E6F632ELL)
      {
LABEL_207:
        LOWORD(v122) = 1283;
        uint64_t v100 = "mps.conv_2d";
LABEL_208:
        uint64_t v118 = "classof on '";
        uint64_t v120 = (uint64_t)v100;
        uint64_t v96 = 11;
        goto LABEL_215;
      }
    }
    else if (v13 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id)
    {
      if (objc_opt_respondsToSelector())
      {
        uint64_t v14 = *((void *)a2 + 6);
        uint64_t v15 = *(void **)(v14 + 16);
        if (v15 != &mlir::detail::TypeIDResolver<void,void>::id)
        {
          if (v15 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id)
          {
            v141[0] = a2;
            uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)v141);
            uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)v141);
            uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v141);
            uint64_t v19 = *(void *)(Input + 8);
            uint64_t v20 = (uint64_t **)(v19 & 0xFFFFFFFFFFFFFFF8);
            unint64_t v140 = v19 & 0xFFFFFFFFFFFFFFF8;
            if ((v19 & 0xFFFFFFFFFFFFFFF8) == 0) {
              goto LABEL_83;
            }
            uint64_t v21 = v18;
            if (mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor((uint64_t **)(v19 & 0xFFFFFFFFFFFFFFF8)))
            {
              uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v20);
              if (!InterfaceFor) {
                goto LABEL_197;
              }
              uint64_t v138 = v20;
              uint64_t v139 = InterfaceFor;
              uint64_t v23 = (uint64_t **)(*(void *)(Filter + 8) & 0xFFFFFFFFFFFFFFF8);
              uint64_t v137 = v23;
              if (!v23) {
LABEL_83:
              }
                __assert_rtn("dyn_cast", "Casting.h", 650, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
            }
            else
            {
              uint64_t v138 = 0;
              uint64_t v139 = 0;
              uint64_t v23 = (uint64_t **)(*(void *)(Filter + 8) & 0xFFFFFFFFFFFFFFF8);
              uint64_t v137 = v23;
              if (!v23) {
                goto LABEL_83;
              }
            }
            if (mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v23))
            {
              uint64_t v55 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v23);
              if (!v55) {
                goto LABEL_197;
              }
              BOOL v135 = v23;
              uint64_t v136 = v55;
              uint8x8_t v56 = (uint64_t **)(*(void *)(v21 + 8) & 0xFFFFFFFFFFFFFFF8);
              unint64_t v134 = v56;
              if (!v56) {
                goto LABEL_83;
              }
            }
            else
            {
              BOOL v135 = 0;
              uint64_t v136 = 0;
              uint8x8_t v56 = (uint64_t **)(*(void *)(v21 + 8) & 0xFFFFFFFFFFFFFFF8);
              unint64_t v134 = v56;
              if (!v56) {
                goto LABEL_83;
              }
            }
            if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v56))
            {
              unint64_t v132 = 0;
              uint64_t v133 = 0;
              if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v138)) {
                return [MEMORY[0x1E4F356C8] supportsPostfixForDevice:*((void *)this + 1) convolutionDescriptor:0 sourceTensorDescriptor:0 destinationTensorDescriptor:0 weightsTensorDescriptor:0];
              }
              goto LABEL_85;
            }
            uint64_t v57 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v56);
            if (v57)
            {
              unint64_t v132 = v56;
              uint64_t v133 = v57;
              if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v138)) {
                return [MEMORY[0x1E4F356C8] supportsPostfixForDevice:*((void *)this + 1) convolutionDescriptor:0 sourceTensorDescriptor:0 destinationTensorDescriptor:0 weightsTensorDescriptor:0];
              }
LABEL_85:
              uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v138);
              if (v59)
              {
                uint64_t v60 = 8 * v59;
                while (*ArgAttrsAttr != 0x8000000000000000)
                {
                  ++ArgAttrsAttr;
                  v60 -= 8;
                  if (!v60) {
                    goto LABEL_89;
                  }
                }
                return [MEMORY[0x1E4F356C8] supportsPostfixForDevice:*((void *)this + 1) convolutionDescriptor:0 sourceTensorDescriptor:0 destinationTensorDescriptor:0 weightsTensorDescriptor:0];
              }
LABEL_89:
              if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v135))
              {
                uint64_t v61 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v135);
                if (v62)
                {
                  uint64_t v63 = 8 * v62;
                  while (*v61 != 0x8000000000000000)
                  {
                    ++v61;
                    v63 -= 8;
                    if (!v63) {
                      goto LABEL_94;
                    }
                  }
                  return [MEMORY[0x1E4F356C8] supportsPostfixForDevice:*((void *)this + 1) convolutionDescriptor:0 sourceTensorDescriptor:0 destinationTensorDescriptor:0 weightsTensorDescriptor:0];
                }
LABEL_94:
                if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v132))
                {
                  BOOL v64 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v132);
                  if (v65)
                  {
                    uint64_t v66 = 8 * v65;
                    while (*v64 != 0x8000000000000000)
                    {
                      ++v64;
                      v66 -= 8;
                      if (!v66) {
                        goto LABEL_99;
                      }
                    }
                    return [MEMORY[0x1E4F356C8] supportsPostfixForDevice:*((void *)this + 1) convolutionDescriptor:0 sourceTensorDescriptor:0 destinationTensorDescriptor:0 weightsTensorDescriptor:0];
                  }
LABEL_99:
                  id v67 = objc_alloc_init(MEMORY[0x1E4F356D0]);
                  [v67 setGroups:mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)v141)];
                  uint64_t v124 = (const char *)mlir::Type::cast<mlir::RankedTensorType>((uint64_t *)&v137);
                  uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v124);
                  unint64_t v110 = v69;
                  uint64_t v111 = (void *)Value;
                  uint64_t v124 = (const char *)mlir::Type::cast<mlir::RankedTensorType>((uint64_t *)&v140);
                  uint64_t v70 = (void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v124);
                  unint64_t v72 = v71;
                  uint64_t v124 = (const char *)mlir::Type::cast<mlir::RankedTensorType>((uint64_t *)&v134);
                  uint64_t v73 = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v124);
                  unint64_t v75 = v74;
                  uint64_t Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)v141);
                  uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)v141);
                  if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)v141))
                  {
                    [v67 setDataFormat:1];
                    if (v72 >= 4 && v75 >= 4)
                    {
                      uint64_t v76 = v70[2];
                      uint64_t v108 = v70[1];
                      uint64_t v109 = v70[3];
                      uint64_t v102 = v73[2];
                      uint64_t v77 = *v73;
                      uint64_t v104 = v73[1];
                      uint64_t v106 = v73[3];
                      mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v124, Strides, 0);
                      mlir::DenseIntElementsAttr::end((mlir::DenseIntElementsAttr *)&Strides, &v118);
                      for (int i = 0; ; ++i)
                      {
                        BOOL v79 = v124 == v118 && v125 == v119;
                        if (v79 && v126 == v120) {
                          break;
                        }
                        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v124, (llvm::APInt *)&v112);
                        int v80 = v113;
                        if (v113 >= 0x41)
                        {
                          if (v80 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v112) <= 0x40)
                          {
                            uint64_t v81 = *(void *)v112;
                            if (i == 1)
                            {
LABEL_118:
                              objc_msgSend(v67, "setStrideInPixelsY:", v81, v102, v104, v106);
                              goto LABEL_119;
                            }
                          }
                          else
                          {
                            uint64_t v81 = -1;
                            if (i == 1) {
                              goto LABEL_118;
                            }
                          }
                        }
                        else
                        {
                          uint64_t v81 = (uint64_t)v112;
                          if (i == 1) {
                            goto LABEL_118;
                          }
                        }
                        if (i == 2) {
                          [v67 setStrideInPixelsX:v81];
                        }
LABEL_119:
                        if (v113 >= 0x41 && v112) {
                          MEMORY[0x1852FDE40](v112, 0x1000C8000313F17);
                        }
                        ++v126;
                      }
                      mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v124, InputAttributeNames, 0);
                      mlir::DenseIntElementsAttr::end((mlir::DenseIntElementsAttr *)&InputAttributeNames, &v118);
                      for (int j = 0; ; ++j)
                      {
                        BOOL v84 = v124 == v118 && v125 == v119;
                        if (v84 && v126 == v120) {
                          goto LABEL_189;
                        }
                        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v124, (llvm::APInt *)&v112);
                        int v85 = v113;
                        if (v113 >= 0x41)
                        {
                          if (v85 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v112) <= 0x40)
                          {
                            uint64_t v86 = *(void *)v112;
                            if (j == 1)
                            {
LABEL_143:
                              objc_msgSend(v67, "setDilationRateInY:", v86, v102, v104, v106);
                              goto LABEL_144;
                            }
                          }
                          else
                          {
                            uint64_t v86 = -1;
                            if (j == 1) {
                              goto LABEL_143;
                            }
                          }
                        }
                        else
                        {
                          uint64_t v86 = (uint64_t)v112;
                          if (j == 1) {
                            goto LABEL_143;
                          }
                        }
                        if (j == 2) {
                          [v67 setDilationRateInX:v86];
                        }
LABEL_144:
                        if (v113 >= 0x41 && v112) {
                          MEMORY[0x1852FDE40](v112, 0x1000C8000313F17);
                        }
                        ++v126;
                      }
                    }
                  }
                  else
                  {
                    [v67 setDataFormat:0];
                    if (v72 >= 4 && v75 >= 4)
                    {
                      uint64_t v76 = v70[3];
                      uint64_t v108 = v70[2];
                      uint64_t v109 = v70[1];
                      uint64_t v102 = v73[3];
                      uint64_t v104 = v73[2];
                      uint64_t v77 = *v73;
                      uint64_t v106 = v73[1];
                      mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v124, Strides, 0);
                      mlir::DenseIntElementsAttr::end((mlir::DenseIntElementsAttr *)&Strides, &v118);
                      for (int k = 0; ; ++k)
                      {
                        BOOL v88 = v124 == v118 && v125 == v119;
                        if (v88 && v126 == v120) {
                          break;
                        }
                        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v124, (llvm::APInt *)&v112);
                        int v89 = v113;
                        if (v113 >= 0x41)
                        {
                          if (v89 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v112) <= 0x40) {
                            uint64_t v90 = *(void *)v112;
                          }
                          else {
                            uint64_t v90 = -1;
                          }
                        }
                        else
                        {
                          uint64_t v90 = (uint64_t)v112;
                        }
                        if (k == 2)
                        {
                          [v67 setStrideInPixelsY:v90];
                        }
                        else if (k == 3)
                        {
                          [v67 setStrideInPixelsX:v90];
                        }
                        if (v113 >= 0x41 && v112) {
                          MEMORY[0x1852FDE40](v112, 0x1000C8000313F17);
                        }
                        ++v126;
                      }
                      mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v124, InputAttributeNames, 0);
                      mlir::DenseIntElementsAttr::end((mlir::DenseIntElementsAttr *)&InputAttributeNames, &v118);
                      for (int m = 0; ; ++m)
                      {
                        BOOL v92 = v124 == v118 && v125 == v119;
                        if (v92 && v126 == v120) {
                          break;
                        }
                        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v124, (llvm::APInt *)&v112);
                        int v93 = v113;
                        if (v113 >= 0x41)
                        {
                          if (v93 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v112) <= 0x40) {
                            uint64_t v94 = *(void *)v112;
                          }
                          else {
                            uint64_t v94 = -1;
                          }
                        }
                        else
                        {
                          uint64_t v94 = (uint64_t)v112;
                        }
                        if (m == 2)
                        {
                          [v67 setDilationRateInY:v94];
                        }
                        else if (m == 3)
                        {
                          [v67 setDilationRateInX:v94];
                        }
                        if (v113 >= 0x41 && v112) {
                          MEMORY[0x1852FDE40](v112, 0x1000C8000313F17);
                        }
                        ++v126;
                      }
LABEL_189:
                      if (mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)v141) == 2)
                      {
                        [v67 setWeightsFormat:1];
                        if (v110 < 4) {
                          goto LABEL_198;
                        }
                        [v67 setKernelWidth:v111[3]];
                        [v67 setKernelHeight:v111[2]];
                        [v67 setInputFeatureChannels:v111[1]];
                      }
                      else
                      {
                        [v67 setWeightsFormat:0];
                        if (v110 < 2) {
                          goto LABEL_198;
                        }
                        [v67 setKernelWidth:v111[1]];
                        [v67 setKernelHeight:*v111];
                        if (v110 < 3) {
                          goto LABEL_198;
                        }
                        [v67 setInputFeatureChannels:v111[2]];
                        if (v110 <= 3) {
                          goto LABEL_198;
                        }
                        v111 += 3;
                      }
                      objc_msgSend(v67, "setOutputFeatureChannels:", *v111, v102, v104, v106);
                      uint64_t v124 = (const char *)v76;
                      uint64_t v125 = v108;
                      uint64_t v126 = 1;
                      uint64_t v127 = v109;
                      uint64_t v128 = v77;
                      uint64_t v129 = 0;
                      LODWORD(v129) = getMPSDataType((void *)(*(void *)(Input + 8) & 0xFFFFFFFFFFFFFFF8));
                      uint64_t v118 = v103;
                      uint64_t v119 = v105;
                      uint64_t v120 = 1;
                      uint64_t v121 = v107;
                      uint64_t v122 = v77;
                      uint64_t v123 = 0;
                      LODWORD(v123) = getMPSDataType((void *)(*(void *)(v21 + 8) & 0xFFFFFFFFFFFFFFF8));
                      uint64_t v117 = 0;
                      uint64_t v112 = (const char *)[v67 kernelWidth];
                      uint64_t v113 = [v67 kernelHeight];
                      uint64_t v114 = 1;
                      uint64_t v115 = [v67 inputFeatureChannels];
                      uint64_t v116 = [v67 outputFeatureChannels];
                      LODWORD(v117) = getMPSDataType((void *)(*(void *)(Filter + 8) & 0xFFFFFFFFFFFFFFF8));
                      uint64_t v45 = [MEMORY[0x1E4F356C8] supportsPostfixForDevice:*((void *)this + 1) convolutionDescriptor:v67 sourceTensorDescriptor:&v124 destinationTensorDescriptor:&v118 weightsTensorDescriptor:&v112];

                      return v45;
                    }
                  }
LABEL_198:
                  __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
                }
              }
              return [MEMORY[0x1E4F356C8] supportsPostfixForDevice:*((void *)this + 1) convolutionDescriptor:0 sourceTensorDescriptor:0 destinationTensorDescriptor:0 weightsTensorDescriptor:0];
            }
LABEL_197:
            __assert_rtn("Interface", "InterfaceSupport.h", 98, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
          }
LABEL_216:
          __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
        }
        uint64_t v124 = *(const char **)(v14 + 8);
        int v97 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v124);
        if (v98 != 11) {
          goto LABEL_216;
        }
        if (*v97 != 0x766E6F632E73706DLL || *(void *)((char *)v97 + 3) != 0x64325F766E6F632ELL) {
          goto LABEL_216;
        }
        goto LABEL_207;
      }
      unint64_t v29 = (void *)MEMORY[0x1E4F356C8];
      return [v29 supportsPostfixForDevice:*((void *)this + 1)];
    }
    uint64_t v27 = *((void *)a2 + 6);
    uint64_t v28 = *(void **)(v27 + 16);
    if (v28 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      uint64_t v124 = *(const char **)(v27 + 8);
      uint64_t v30 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v124);
      if (v31 == 8 && *v30 == 0x656C69742E73706DLL)
      {
        LOWORD(v122) = 1283;
        uint64_t v118 = "classof on '";
        uint64_t v120 = (uint64_t)"mps.tile";
        uint64_t v96 = 8;
        goto LABEL_215;
      }
    }
    else if (v28 == &mlir::detail::TypeIDResolver<mlir::mps::TileOp,void>::id)
    {
      if (!*((unsigned char *)this + 16))
      {
        unint64_t v29 = (void *)MEMORY[0x1E4F358E0];
        return [v29 supportsPostfixForDevice:*((void *)this + 1)];
      }
      return 0;
    }
    uint64_t v32 = *((void *)a2 + 6);
    uint64_t v33 = *(void **)(v32 + 16);
    if (v33 != &mlir::detail::TypeIDResolver<void,void>::id)
    {
      if (v33 == &mlir::detail::TypeIDResolver<mlir::mps::ResizeOp,void>::id)
      {
        if (!*((unsigned char *)this + 16))
        {
          unint64_t v29 = (void *)MEMORY[0x1E4F35880];
          return [v29 supportsPostfixForDevice:*((void *)this + 1)];
        }
        return 0;
      }
LABEL_41:
      uint64_t v37 = *((void *)a2 + 6);
      BOOL v38 = *(void **)(v37 + 16);
      if (v38 == &mlir::detail::TypeIDResolver<void,void>::id)
      {
        uint64_t v124 = *(const char **)(v37 + 8);
        unint64_t v39 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v124);
        if (v40 == 21)
        {
          BOOL v41 = *v39 == 0x747065642E73706DLL && v39[1] == 0x6F635F6573697768;
          if (v41 && *(void *)((char *)v39 + 13) == 0x64335F766E6F635FLL)
          {
            LOWORD(v122) = 1283;
            uint64_t v101 = "mps.depthwise_conv_3d";
LABEL_214:
            uint64_t v118 = "classof on '";
            uint64_t v120 = (uint64_t)v101;
            uint64_t v96 = 21;
LABEL_215:
            uint64_t v121 = v96;
            uint64_t v112 = "' failed due to the operation not being registered";
            LOWORD(v116) = 259;
            llvm::operator+((uint64_t *)&v118, (uint64_t *)&v112, (uint64_t)&v124);
            llvm::report_fatal_error((llvm::Twine *)&v124, 1);
          }
        }
      }
      else if (v38 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id)
      {
        unint64_t v29 = (void *)MEMORY[0x1E4F35718];
        return [v29 supportsPostfixForDevice:*((void *)this + 1)];
      }
      uint64_t v43 = *((void *)a2 + 6);
      BOOL v44 = *(void **)(v43 + 16);
      if (v44 == &mlir::detail::TypeIDResolver<void,void>::id)
      {
        uint64_t v124 = *(const char **)(v43 + 8);
        unint64_t v46 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v124);
        if (v47 == 11 && *v46 == 0x6E6574732E73706DLL && *(void *)((char *)v46 + 3) == 0x6C69636E6574732ELL)
        {
          LOWORD(v122) = 1283;
          uint64_t v100 = "mps.stencil";
          goto LABEL_208;
        }
      }
      else if (v44 == &mlir::detail::TypeIDResolver<mlir::mps::StencilOp,void>::id)
      {
        if (!*((unsigned char *)this + 16))
        {
          unint64_t v29 = (void *)MEMORY[0x1E4F358B8];
          return [v29 supportsPostfixForDevice:*((void *)this + 1)];
        }
        return 0;
      }
      uint64_t v49 = *((void *)a2 + 6);
      uint64_t v50 = *(void **)(v49 + 16);
      if (v50 != &mlir::detail::TypeIDResolver<void,void>::id)
      {
        if (v50 == &mlir::detail::TypeIDResolver<mlir::mpsx::QuantizedMatMulOp,void>::id)
        {
          unint64_t v29 = (void *)MEMORY[0x1E4F35840];
          return [v29 supportsPostfixForDevice:*((void *)this + 1)];
        }
        return 1;
      }
      uint64_t v124 = *(const char **)(v49 + 8);
      unint64_t v51 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v124);
      if (v52 != 21) {
        return 1;
      }
      BOOL v53 = *v51 == 0x6175712E7873706DLL && v51[1] == 0x6D5F64657A69746ELL;
      if (!v53 || *(void *)((char *)v51 + 13) != 0x6C756D74616D5F64) {
        return 1;
      }
      LOWORD(v122) = 1283;
      uint64_t v101 = "mpsx.quantized_matmul";
      goto LABEL_214;
    }
    uint64_t v124 = *(const char **)(v32 + 8);
    uint64_t v34 = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v124);
    if (v35 != 10) {
      goto LABEL_41;
    }
    if (*(void *)v34 != 0x697365722E73706DLL || *(_WORD *)(v34 + 8) != 25978) {
      goto LABEL_41;
    }
    LOWORD(v122) = 1283;
    int v95 = "mps.resize";
LABEL_210:
    uint64_t v118 = "classof on '";
    uint64_t v120 = (uint64_t)v95;
    uint64_t v96 = 10;
    goto LABEL_215;
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id) {
    goto LABEL_11;
  }
  uint64_t v6 = (void *)MEMORY[0x1E4F357B8];
  uint64_t v7 = *((void *)this + 1);

  return [v6 supportsPostfixForDevice:v7];
}

void sub_180D66DE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void mlir::mps::MPSFusableCoreOps::~MPSFusableCoreOps(mlir::mps::MPSFusableCoreOps *this)
{
}

uint64_t mlir::detail::constant_float_predicate_matcher::match(mlir::detail::constant_float_predicate_matcher *this, mlir::Operation *a2)
{
  v32[2] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (llvm::APFloatBase *)llvm::APFloatBase::Bogus(this);
  uint64_t v5 = (llvm::APFloatBase *)llvm::APFloatBase::PPCDoubleDouble(v4);
  if (v5 == v4) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat(&v31, (uint64_t)v4);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v31, (uint64_t)v4);
  }
  uint64_t v27 = v30;
  uint64_t v28 = (unint64_t *)&v29;
  uint64_t v29 = 0;
  if (!mlir::detail::constant_op_binder<mlir::Attribute>::match(&v28, (uint64_t)a2)) {
    goto LABEL_51;
  }
  if (!*((_DWORD *)a2 + 9))
  {
    uint64_t v23 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    int v24 = 984;
    uint64_t v25 = "Operation.h";
    unint64_t v26 = "getOpResultImpl";
    goto LABEL_56;
  }
  uint64_t v6 = *(void *)(*((void *)a2 - 1) & 0xFFFFFFFFFFFFFFF8);
  if (!v6)
  {
    uint64_t v23 = "abstractType && \"Malformed type storage object.\"";
    int v24 = 160;
    uint64_t v25 = "TypeSupport.h";
    unint64_t v26 = "getAbstractType";
LABEL_56:
    __assert_rtn(v26, v25, v24, v23);
  }
  uint64_t v7 = *(void **)(v6 + 136);
  BOOL v20 = v7 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id;
  if (!v20 || !mlir::detail::constant_float_value_binder::match((uint64_t *)&v27, v29))
  {
LABEL_51:
    uint64_t v21 = 0;
    if (v5 == v31) {
      goto LABEL_50;
    }
LABEL_52:
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v31);
    return v21;
  }
  uint64_t v21 = (*(uint64_t (**)(char *))this)(v30);
  if (v5 != v31) {
    goto LABEL_52;
  }
LABEL_50:
  std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v32);
  return v21;
}

void sub_180D671F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  llvm::APFloat::~APFloat((llvm::APFloat *)va);
  _Unwind_Resume(a1);
}

GPU::ANERegionCallOpHandler *GPU::ANERegionCallOpHandler::ANERegionCallOpHandler(GPU::ANERegionCallOpHandler *this, GPU::BaseOpHandler *a2)
{
  v250[5] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = a2;
  long long v3 = *((_OWORD *)a2 + 1);
  *((_OWORD *)this + 1) = v3;
  *(void *)this = &unk_1EC99F5E8;
  *((void *)this + 4) = 0;
  *((void *)this + 6) = (char *)this + 64;
  int v205 = (char *)this + 48;
  int v206 = (char *)this + 64;
  *((void *)this + 12) = (char *)this + 112;
  char v203 = (char *)this + 96;
  int v204 = (char *)this + 112;
  *((void *)this + 18) = 0;
  location = (id *)((char *)this + 144);
  *((void *)this + 19) = 0;
  uint64_t v4 = (id *)((char *)this + 152);
  *((void *)this + 7) = 0x400000000;
  *((void *)this + 20) = 0;
  uint64_t v5 = (id *)((char *)this + 160);
  *((_OWORD *)this + 11) = 0u;
  uint64_t v6 = (dispatch_queue_t *)((char *)this + 176);
  int v202 = (char *)this + 232;
  *((void *)this + 27) = (char *)this + 232;
  long long v217 = (void *)((char *)this + 216);
  *((void *)this + 13) = 0x400000000;
  *((_OWORD *)this + 12) = 0u;
  *((void *)this + 28) = 0x400000000;
  uint64_t v207 = (char **)((char *)this + 264);
  uint64_t v208 = (char *)this + 280;
  *((void *)this + 33) = (char *)this + 280;
  *((void *)this + 34) = 0x400000000;
  *((void *)this + 79) = 0;
  *((void *)this + 81) = 0;
  *((void *)this + 80) = 0;
  if (!*(unsigned char *)(v3 + 256) && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  std::string::size_type v7 = *((void *)this + 3);
  uint64_t v8 = *(void *)(v7 + 48);
  uint64_t v9 = *(void **)(v8 + 16);
  if (v9 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst.__r_.__value_.__r.__words[0] = *(void *)(v8 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&__dst);
    if (v199 == 21)
    {
      BOOL v200 = *AttrData == 0x6E656D6563616C70 && AttrData[1] == 0x6E6F696765722E74;
      if (v200 && *(void *)((char *)AttrData + 13) == 0x6C6C61635F6E6F69)
      {
        __int16 v246 = 1283;
        v243[0] = (uint64_t)"classof on '";
        long long v244 = "placement.region_call";
        uint64_t v245 = 21;
        v241[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v242 = 259;
        llvm::operator+(v243, v241, (uint64_t)&__dst);
        llvm::report_fatal_error((llvm::Twine *)&__dst, 1);
      }
    }
LABEL_327:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v9 != &mlir::detail::TypeIDResolver<mlir::placement::RegionCall,void>::id) {
    goto LABEL_327;
  }
  unint64_t v240 = (mlir::Operation *)*((void *)this + 3);
  uint64_t v10 = *(void *)(*((void *)this + 2) + 600);
  __dst.__r_.__value_.__r.__words[0] = v7;
  if (*(unsigned char *)(v10 + 28))
  {
    uint64_t v11 = (id *)(v10 + 32);
    goto LABEL_21;
  }
  uint64_t v14 = *(void *)(v10 + 64);
  uint64_t v12 = v10 + 64;
  uint64_t v13 = v14;
  int v15 = *(_DWORD *)(v12 + 16);
  if (v15)
  {
    if ((v7 | 0x1000) == 0xFFFFFFFFFFFFF000) {
      __assert_rtn("LookupBucketFor", "DenseMap.h", 651, "!KeyInfoT::isEqual(Val, EmptyKey) && !KeyInfoT::isEqual(Val, TombstoneKey) && \"Empty/Tombstone value shouldn't be inserted into map!\"");
    }
    unsigned int v16 = v15 - 1;
    uint64_t v17 = (v15 - 1) & ((v7 >> 4) ^ (v7 >> 9));
    uint64_t v18 = (uint64_t *)(v13 + 32 * v17);
    uint64_t v19 = *v18;
    if (*v18 == v7) {
      goto LABEL_20;
    }
    BOOL v20 = 0;
    int v21 = 1;
    while (v19 != -4096)
    {
      if (v20) {
        BOOL v22 = 0;
      }
      else {
        BOOL v22 = v19 == -8192;
      }
      if (v22) {
        BOOL v20 = v18;
      }
      int v23 = v17 + v21++;
      uint64_t v17 = v23 & v16;
      uint64_t v18 = (uint64_t *)(v13 + 32 * v17);
      uint64_t v19 = *v18;
      if (*v18 == v7) {
        goto LABEL_20;
      }
    }
    if (v20) {
      int v24 = v20;
    }
    else {
      int v24 = v18;
    }
  }
  else
  {
    int v24 = 0;
  }
  uint64_t v18 = llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,GPU::ANECompilerHelper::CompiledProduct,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,GPU::ANECompilerHelper::CompiledProduct>>,mlir::Operation *,GPU::ANECompilerHelper::CompiledProduct,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,GPU::ANECompilerHelper::CompiledProduct>>::InsertIntoBucket<mlir::Operation * const&>(v12, v24, (uint64_t *)&__dst);
LABEL_20:
  uint64_t v11 = (id *)(v18 + 1);
LABEL_21:
  objc_storeStrong(location, *v11);
  objc_storeStrong(v4, v11[1]);
  objc_storeStrong(v5, v11[2]);
  uint64_t v25 = *(void *)(*((void *)this + 2) + 600);
  *((_DWORD *)this + 42) = *(_DWORD *)(v25 + 24);
  *((unsigned char *)this + 172) = *(unsigned char *)(v25 + 100);
  *((unsigned char *)this + 173) = *(unsigned char *)(v25 + 96);
  if (qword_1EB216E48 != -1) {
    dispatch_once(&qword_1EB216E48, &__block_literal_global_0);
  }
  dispatch_queue_t v26 = dispatch_queue_create("com.apple.MPSANEQueue", 0);
  dispatch_queue_t v27 = *v6;
  *uint64_t v6 = v26;

  uint64_t v28 = objc_msgSend(objc_alloc(MEMORY[0x1E4F35308]), "initWithDispatchQueue:", *v6, v202);
  uint64_t v29 = (void *)*((void *)this + 23);
  *((void *)this + 23) = v28;

  int v211 = [*(id *)(*((void *)this + 2) + 48) metalDevice];
  id v30 = objc_alloc_init(MEMORY[0x1E4F2EF90]);
  uint64_t v31 = (void *)*((void *)this + 24);
  *((void *)this + 24) = v30;

  uint64_t v32 = objc_msgSend(v211, "newSharedEventWithMachPort:", objc_msgSend(*((id *)this + 24), "eventPort"));
  uint64_t v33 = (void *)*((void *)this + 25);
  *((void *)this + 25) = v32;

  *((void *)this + 26) = 0;
  *((unsigned char *)this + 41) = _MergedGlobals_58;
  *((unsigned char *)this + 42) = byte_1EB216E41;
  *((unsigned char *)this + 40) = byte_1EB216E42;
  *((unsigned char *)this + 43) = byte_1EB216E43;
  *((unsigned char *)this + 44) = byte_1EB216E44;
  if ((*((unsigned char *)v240 + 46) & 0x80) == 0)
  {
    unint64_t v35 = 0;
    unsigned int v37 = 0;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&__dst.__r_.__value_.__r.__words[2];
    __dst.__r_.__value_.__l.__size_ = 0x400000000;
    unsigned int v49 = 4;
    goto LABEL_39;
  }
  uint64_t v34 = *((void *)v240 + 9);
  unint64_t v35 = *((unsigned int *)v240 + 17);
  __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&__dst.__r_.__value_.__r.__words[2];
  __dst.__r_.__value_.__l.__size_ = 0x400000000;
  if (v35 <= 4)
  {
    unsigned int v37 = 0;
    if (!v35)
    {
      unint64_t v35 = 0;
      unsigned int v49 = 4;
      goto LABEL_39;
    }
    uint64_t v36 = &__dst.__r_.__value_.__r.__words[2];
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &__dst.__r_.__value_.__r.__words[2], v35, 8);
    uint64_t v36 = (std::string::size_type *)(__dst.__r_.__value_.__r.__words[0]
                                   + 8 * LODWORD(__dst.__r_.__value_.__r.__words[1]));
    if (v35 >= 0xD
      && ((unint64_t)v36 >= v34 + 32 * v35
       || v34 + 24 >= __dst.__r_.__value_.__r.__words[0] + 8 * (v35 + LODWORD(__dst.__r_.__value_.__r.__words[1]))))
    {
      uint64_t v39 = v35 & 3;
      if ((v35 & 3) == 0) {
        uint64_t v39 = 4;
      }
      unint64_t v38 = v35 - v39;
      v36 += v38;
      uint64_t v40 = (const double *)(v34 + 88);
      BOOL v41 = (unsigned long long *)(__dst.__r_.__value_.__r.__words[0]
                                + 8 * LODWORD(__dst.__r_.__value_.__r.__words[1])
                                + 16);
      unint64_t v42 = v38;
      do
      {
        uint64_t v43 = v40 - 8;
        unsigned long long v44 = (unsigned __int128)vld4q_f64(v43);
        unsigned long long v45 = (unsigned __int128)vld4q_f64(v40);
        *(v41 - 1) = v44;
        unsigned long long *v41 = v45;
        v40 += 16;
        v41 += 2;
        v42 -= 4;
      }
      while (v42);
      goto LABEL_36;
    }
  }
  unint64_t v38 = 0;
LABEL_36:
  unint64_t v46 = v35 - v38;
  uint64_t v47 = (std::string::size_type *)(v34 + 32 * v38 + 24);
  do
  {
    std::string::size_type v48 = *v47;
    v47 += 4;
    *v36++ = v48;
    --v46;
  }
  while (v46);
  unsigned int v37 = __dst.__r_.__value_.__r.__words[1];
  unsigned int v49 = HIDWORD(__dst.__r_.__value_.__r.__words[1]);
LABEL_39:
  unint64_t v50 = v35 + v37;
  if (v50 > v49) {
    __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
  }
  LODWORD(__dst.__r_.__value_.__r.__words[1]) = v50;
  llvm::SmallVectorImpl<mlir::Value>::operator=((uint64_t)v217, (uint64_t)&__dst);
  if ((std::string::size_type *)__dst.__r_.__value_.__l.__data_ != &__dst.__r_.__value_.__r.__words[2]) {
    free(__dst.__r_.__value_.__l.__data_);
  }
  unint64_t v237 = 0;
  uint64_t v238 = 0;
  uint64_t v239 = 0x1000000000;
  if (*((_DWORD *)this + 56))
  {
    unint64_t v51 = 0;
    do
    {
      mlir::anec::getANECInputName(v51, &__dst);
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_dst = (int8x16_t *)&__dst;
      }
      else {
        p_dst = (int8x16_t *)__dst.__r_.__value_.__r.__words[0];
      }
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = __dst.__r_.__value_.__l.__size_;
      }
      *(void *)(*llvm::StringMap<unsigned long long,llvm::MallocAllocator>::try_emplace<>((uint64_t)&v237, p_dst, (const unsigned __int8 *)size)+ 8) = v51;
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      unint64_t v51 = (mlir::anec *)((char *)v51 + 1);
    }
    while (v51 != (mlir::anec *)*((unsigned int *)this + 56));
  }
  BOOL v234 = 0;
  uint64_t v235 = 0;
  uint64_t v236 = 0x1000000000;
  BOOL v54 = v240;
  unint64_t v55 = *((unsigned int *)v240 + 9);
  if (*((_DWORD *)this + 69) < v55)
  {
    __dst.__r_.__value_.__r.__words[0] = 0;
    uint8x8_t v56 = llvm::SmallVectorBase<unsigned int>::mallocForGrow((uint64_t)v207, v208, v55, 88, (unint64_t *)&__dst);
    std::__uninitialized_move[abi:ne180100]<GPU::ANERegionCallOpHandler::ResultInfo,GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*,std::__always_false,GPU::ANERegionCallOpHandler::ResultInfo* std::uninitialized_move[abi:ne180100]<GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*>(GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*)::{lambda(GPU::ANERegionCallOpHandler::ResultInfo*&&)#1}>(*((void *)this + 33), *((void *)this + 33) + 88 * *((unsigned int *)this + 68), (uint64_t)v56);
    uint64_t v57 = (char *)*((void *)this + 33);
    unsigned int v58 = *((_DWORD *)this + 68);
    if (v58)
    {
      uint64_t v59 = 88 * v58;
      do
      {
        uint64_t v60 = *(char **)&v57[v59 - 56];
        if (&v57[v59 - 40] != v60) {
          free(v60);
        }
        v59 -= 88;
      }
      while (v59);
      uint64_t v57 = *v207;
    }
    int data = (int)__dst.__r_.__value_.__l.__data_;
    if (v57 != v208) {
      free(v57);
    }
    *((void *)this + 33) = v56;
    *((_DWORD *)this + 69) = data;
    BOOL v54 = v240;
    LODWORD(v55) = *((_DWORD *)v240 + 9);
  }
  uint64_t v62 = (mlir::Operation *)((char *)v54 - 16);
  if (!v55) {
    uint64_t v62 = 0;
  }
  int v231 = v62;
  if (v55)
  {
    uint64_t v63 = 0;
    BOOL v227 = (mlir::anec *)v55;
    do
    {
      uint64_t NextResultAtOffset = (void *)mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v231, (uint64_t)v63);
      BOOL v233 = 0;
      uint64_t v65 = (void *)*NextResultAtOffset;
      if (!*NextResultAtOffset) {
LABEL_305:
      }
        __assert_rtn("ANERegionCallOpHandler", "ANERegion.mm", 106, "memrefToTensorOp");
      uint64_t v66 = 0;
      do
      {
        id v67 = (mlir::Operation *)v65[2];
        if (v66 && MTLReportFailureTypeEnabled()) {
          MTLReportFailure();
        }
        if (!v67) {
          __assert_rtn("dyn_cast", "Casting.h", 662, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
        }
        uint64_t v68 = *((void *)v67 + 6);
        unint64_t v69 = *(void **)(v68 + 16);
        if (v69 == &mlir::detail::TypeIDResolver<void,void>::id)
        {
          __dst.__r_.__value_.__r.__words[0] = *(void *)(v68 + 8);
          uint64_t v70 = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&__dst);
          if (v71 == 26)
          {
            BOOL v72 = *(void *)v70 == 0x6E656D6563616C70 && *(void *)(v70 + 8) == 0x6665726D656D2E74;
            BOOL v73 = v72 && *(void *)(v70 + 16) == 0x736E65745F6F745FLL;
            if (v73 && *(_WORD *)(v70 + 24) == 29295)
            {
              __int16 v246 = 1283;
              v243[0] = (uint64_t)"classof on '";
              long long v244 = "placement.memref_to_tensor";
              uint64_t v245 = 26;
              v241[0] = (uint64_t)"' failed due to the operation not being registered";
              __int16 v242 = 259;
              llvm::operator+(v243, v241, (uint64_t)&__dst);
              llvm::report_fatal_error((llvm::Twine *)&__dst, 1);
            }
          }
        }
        else if (v69 == &mlir::detail::TypeIDResolver<mlir::placement::MemrefToTensor,void>::id)
        {
          BOOL v233 = v67;
          goto LABEL_70;
        }
        BOOL v233 = 0;
        if (MTLReportFailureTypeEnabled()) {
          MTLReportFailure();
        }
LABEL_70:
        uint64_t v65 = (void *)*v65;
        uint64_t v66 = v233;
      }
      while (v65);
      if (!v233) {
        goto LABEL_305;
      }
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)NextResultAtOffset;
      __dst.__r_.__value_.__l.__size_ = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v233);
      unint64_t v75 = NextResultAtOffset[1] & 0xFFFFFFFFFFFFFFF8;
      if (!*(void *)v75)
      {
        int v193 = 160;
        int v194 = "abstractType && \"Malformed type storage object.\"";
        unsigned int v195 = "TypeSupport.h";
        long long v196 = "getAbstractType";
        goto LABEL_288;
      }
      if (*(_UNKNOWN **)(*(void *)v75 + 136) != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
      {
        int v193 = 566;
        long long v196 = "cast";
        unsigned int v195 = "Casting.h";
        int v194 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
LABEL_288:
        __assert_rtn(v196, v195, v193, v194);
      }
      __dst.__r_.__value_.__r.__words[2] = getMemRefRowBytes(v75);
      uint64_t v76 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v233);
      uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v76);
      mlir::placement::MemrefToTensor::getInputShapeAfterInterleave(&v233, &v249);
      uint64_t v77 = *((unsigned int *)this + 68);
      unint64_t v78 = *((void *)this + 33);
      if (v77 >= *((_DWORD *)this + 69))
      {
        unint64_t v87 = v77 + 1;
        BOOL v88 = v78 + 88 * v77 > (unint64_t)&__dst;
        if (v78 <= (unint64_t)&__dst && v88)
        {
          v243[0] = 0;
          int v80 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow((uint64_t)v207, v208, v87, 88, (unint64_t *)v243);
          std::__uninitialized_move[abi:ne180100]<GPU::ANERegionCallOpHandler::ResultInfo,GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*,std::__always_false,GPU::ANERegionCallOpHandler::ResultInfo* std::uninitialized_move[abi:ne180100]<GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*>(GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*)::{lambda(GPU::ANERegionCallOpHandler::ResultInfo*&&)#1}>(*((void *)this + 33), *((void *)this + 33) + 88 * *((unsigned int *)this + 68), (uint64_t)v80);
          obint j = (char *)*((void *)this + 33);
          unsigned int v94 = *((_DWORD *)this + 68);
          if (v94)
          {
            uint64_t v95 = 88 * v94;
            do
            {
              uint64_t v96 = *(char **)&obj[v95 - 56];
              if (&obj[v95 - 40] != v96) {
                free(v96);
              }
              v95 -= 88;
            }
            while (v95);
            obint j = *v207;
          }
          int v97 = v243[0];
          if (obj != v208) {
            free(obj);
          }
          *((void *)this + 33) = v80;
          *((_DWORD *)this + 69) = v97;
          BOOL v79 = (std::string *)&v80[8 * ((uint64_t)((uint64_t)&__dst - v78) >> 3)];
        }
        else
        {
          v243[0] = 0;
          int v80 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow((uint64_t)v207, v208, v87, 88, (unint64_t *)v243);
          std::__uninitialized_move[abi:ne180100]<GPU::ANERegionCallOpHandler::ResultInfo,GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*,std::__always_false,GPU::ANERegionCallOpHandler::ResultInfo* std::uninitialized_move[abi:ne180100]<GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*>(GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*)::{lambda(GPU::ANERegionCallOpHandler::ResultInfo*&&)#1}>(*((void *)this + 33), *((void *)this + 33) + 88 * *((unsigned int *)this + 68), (uint64_t)v80);
          int v89 = (char *)*((void *)this + 33);
          unsigned int v90 = *((_DWORD *)this + 68);
          if (v90)
          {
            uint64_t v91 = 88 * v90;
            do
            {
              BOOL v92 = *(char **)&v89[v91 - 56];
              if (&v89[v91 - 40] != v92) {
                free(v92);
              }
              v91 -= 88;
            }
            while (v91);
            int v89 = *v207;
          }
          int v93 = v243[0];
          if (v89 != v208) {
            free(v89);
          }
          *((void *)this + 33) = v80;
          *((_DWORD *)this + 69) = v93;
          BOOL v79 = &__dst;
        }
      }
      else
      {
        BOOL v79 = &__dst;
        int v80 = (char *)*((void *)this + 33);
      }
      uint64_t v81 = &v80[88 * *((unsigned int *)this + 68)];
      long long v82 = *(_OWORD *)&v79->__r_.__value_.__r.__words[2];
      *(_OWORD *)uint64_t v81 = *(_OWORD *)&v79->__r_.__value_.__l.__data_;
      *((_OWORD *)v81 + 1) = v82;
      *((void *)v81 + 5) = 0x500000000;
      *((void *)v81 + 4) = v81 + 48;
      uint64_t v83 = (uint64_t)(v81 + 32);
      if (LODWORD(v79[1].__r_.__value_.__r.__words[2])) {
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=(v83, (uint64_t)&v79[1].__r_.__value_.__l.__size_);
      }
      unsigned int v84 = *((_DWORD *)this + 68);
      if (v84 >= *((_DWORD *)this + 69)) {
        __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
      }
      *((_DWORD *)this + 68) = v84 + 1;
      if (v249 != v250) {
        free(v249);
      }
      mlir::anec::getANECOutputName(v63, &__dst);
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v85 = (int8x16_t *)&__dst;
      }
      else {
        int v85 = (int8x16_t *)__dst.__r_.__value_.__r.__words[0];
      }
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v86 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v86 = __dst.__r_.__value_.__l.__size_;
      }
      *(void *)(*llvm::StringMap<unsigned long long,llvm::MallocAllocator>::try_emplace<>((uint64_t)&v234, v85, (const unsigned __int8 *)v86)+ 8) = v63;
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      uint64_t v63 = (mlir::anec *)((char *)v63 + 1);
    }
    while (v63 != v227);
  }
  uint64_t v98 = [*location modelAttributes];
  uint64_t v99 = (void *)MEMORY[0x1E4F4E108];
  v215 = v98;
  uint64_t v100 = [v98 objectForKeyedSubscript:*MEMORY[0x1E4F4E108]];
  int v210 = [v100 objectForKeyedSubscript:*MEMORY[0x1E4F4E170]];

  uint64_t v101 = NSString;
  Callee = (const void *)mlir::placement::RegionCall::getCallee(&v240);
  if (!Callee)
  {
    memset(&__dst, 0, sizeof(__dst));
    uint64_t v106 = &__dst;
    goto LABEL_142;
  }
  std::string::size_type v104 = v102;
  if (v102 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v102 >= 0x17)
  {
    uint64_t v107 = (v102 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v102 | 7) != 0x17) {
      uint64_t v107 = v102 | 7;
    }
    uint64_t v108 = v107 + 1;
    uint64_t v105 = (std::string *)operator new(v107 + 1);
    __dst.__r_.__value_.__l.__size_ = v104;
    __dst.__r_.__value_.__r.__words[2] = v108 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v105;
    goto LABEL_138;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v102;
  uint64_t v105 = &__dst;
  if (v102) {
LABEL_138:
  }
    memmove(v105, Callee, v104);
  v105->__r_.__value_.__s.__data_[v104] = 0;
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v106 = &__dst;
  }
  else {
    uint64_t v106 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
LABEL_142:
  uint64_t v109 = [v101 stringWithUTF8String:v106];
  unint64_t v110 = [v210 objectForKeyedSubscript:v109];

  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  int v230 = v110;
  if (!v110 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  uint64_t v111 = [v110 copy];
  uint64_t v112 = (void *)*((void *)this + 4);
  *((void *)this + 4) = v111;

  uint64_t v212 = [v215 objectForKeyedSubscript:@"NetworkStatusList"];
  uint64_t v113 = [v215 objectForKeyedSubscript:*v99];
  uint64_t v213 = [v113 objectForKeyedSubscript:*MEMORY[0x1E4F4E180]];

  if (!v213 || ![v213 count])
  {
    int v197 = 127;
    goto LABEL_308;
  }
  if (!v212 || ![v212 count])
  {
    int v197 = 130;
LABEL_308:
    __assert_rtn("ANERegionCallOpHandler", "ANERegion.mm", v197, "0");
  }
  uint64_t v209 = objc_msgSend(v213, "objectAtIndexedSubscript:", objc_msgSend(v110, "unsignedIntValue"));
  locationa = [v209 objectForKeyedSubscript:*MEMORY[0x1E4F4E128]];
  if (!locationa || ![locationa count]) {
    __assert_rtn("ANERegionCallOpHandler", "ANERegion.mm", 136, "0");
  }
  int v222 = [v209 objectForKeyedSubscript:*MEMORY[0x1E4F4E150]];
  if (!v222 || ![v222 count]) {
    __assert_rtn("ANERegionCallOpHandler", "ANERegion.mm", 140, "0");
  }
  uint64_t v114 = objc_msgSend(v212, "objectAtIndexedSubscript:", objc_msgSend(v110, "unsignedIntValue"));
  int v214 = v114;
  if (!v114 || ![v114 count]) {
    __assert_rtn("ANERegionCallOpHandler", "ANERegion.mm", 145, "0");
  }
  uint64_t v232 = [v214 objectForKeyedSubscript:@"LiveInputList"];
  if (!v232 || ![(mlir::detail::OpResultImpl *)v232 count]) {
    __assert_rtn("ANERegionCallOpHandler", "ANERegion.mm", 149, "0");
  }
  uint64_t v115 = [v214 objectForKeyedSubscript:@"LiveOutputList"];
  BOOL v229 = v115;
  if (!v115 || ![v115 count]) {
    __assert_rtn("ANERegionCallOpHandler", "ANERegion.mm", 153, "0");
  }
  uint64_t v116 = [v215 objectForKeyedSubscript:*v99];
  uint64_t v219 = [v116 objectForKeyedSubscript:*MEMORY[0x1E4F4E120]];

  if (!v219) {
    __assert_rtn("ANERegionCallOpHandler", "ANERegion.mm", 159, "0");
  }
  uint64_t v117 = [v215 objectForKeyedSubscript:*v99];
  BOOL v228 = [v117 objectForKeyedSubscript:*MEMORY[0x1E4F4E148]];

  if (!v228) {
    __assert_rtn("ANERegionCallOpHandler", "ANERegion.mm", 163, "0");
  }
  objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", -[mlir::detail::OpResultImpl count](v232, "count"));
  id obja = (id)objc_claimAutoreleasedReturnValue();
  unint64_t v118 = [(mlir::detail::OpResultImpl *)v232 count];
  if (v118 > *((unsigned int *)this + 15)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v205, v206, v118, 8);
  }
  for (unint64_t i = 0; i < [(mlir::detail::OpResultImpl *)v232 count]; ++i)
  {
    uint64_t v120 = [(mlir::detail::OpResultImpl *)v232 objectAtIndexedSubscript:i];
    id v121 = [v120 objectForKeyedSubscript:@"Name"];
    uint64_t v122 = (const char *)[v121 UTF8String];
    uint64_t v123 = (int8x16_t *)v122;
    if (v122) {
      uint64_t v124 = (const unsigned __int8 *)strlen(v122);
    }
    else {
      uint64_t v124 = 0;
    }
    int Key = llvm::StringMapImpl::FindKey((uint64_t *)&v237, v123, v124);
    if (Key == -1 || Key == (unint64_t)v238)
    {
      int v130 = 245;
      uint64_t v133 = "Iter != this->end() && \"StringMap::at failed due to a missing key\"";
      unint64_t v132 = "StringMap.h";
      unint64_t v131 = "at";
LABEL_175:
      __assert_rtn(v131, v132, v130, v133);
    }
    uint64_t v126 = *(void *)(*((void *)v237 + Key) + 8);
    unint64_t v127 = *((unsigned int *)this + 14);
    if (v127 >= *((unsigned int *)this + 15))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v205, v206, v127 + 1, 8);
      *(void *)(*((void *)this + 6) + 8 * *((unsigned int *)this + 14)) = v126;
      unsigned int v128 = *((_DWORD *)this + 14);
      if (v128 >= *((_DWORD *)this + 15))
      {
LABEL_174:
        int v130 = 102;
        unint64_t v131 = "set_size";
        unint64_t v132 = "SmallVector.h";
        uint64_t v133 = "N <= capacity()";
        goto LABEL_175;
      }
    }
    else
    {
      *(void *)(*((void *)this + 6) + 8 * v127) = v126;
      unsigned int v128 = *((_DWORD *)this + 14);
      if (v128 >= *((_DWORD *)this + 15)) {
        goto LABEL_174;
      }
    }
    *((_DWORD *)this + 14) = v128 + 1;
    uint64_t v129 = [locationa objectAtIndexedSubscript:i];
    [obja addObject:v129];

    unint64_t v110 = v230;
  }
  objc_storeStrong((id *)this + 79, obja);
  unint64_t v134 = [v229 count];
  if (v134 > *((unsigned int *)this + 27)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v203, v204, v134, 8);
  }
  objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", -[mlir::detail::OpResultImpl count](v232, "count", v134));
  id v220 = (id)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(v229, "count"));
  id v221 = (id)objc_claimAutoreleasedReturnValue();
  unint64_t v135 = 0;
  unint64_t v136 = (unint64_t)"SmallVector.h";
  uint64_t v137 = MEMORY[0x1E4F1CC28];
  while (v135 < [v229 count])
  {
    uint64_t v138 = [v229 objectAtIndexedSubscript:v135];
    id v139 = [v138 objectForKeyedSubscript:@"Name"];
    unint64_t v140 = (const char *)[v139 UTF8String];
    uint64_t v141 = (int8x16_t *)v140;
    if (v140) {
      uint64_t v142 = (const unsigned __int8 *)strlen(v140);
    }
    else {
      uint64_t v142 = 0;
    }
    int v143 = llvm::StringMapImpl::FindKey((uint64_t *)&v234, v141, v142);
    if (v143 == -1 || v143 == (unint64_t)v235)
    {
      int v149 = 245;
      unint64_t v152 = "Iter != this->end() && \"StringMap::at failed due to a missing key\"";
      unint64_t v151 = "StringMap.h";
      uint64_t v150 = "at";
LABEL_193:
      __assert_rtn(v150, v151, v149, v152);
    }
    uint64_t v144 = *(void *)(*((void *)v234 + v143) + 8);
    unint64_t v145 = *((unsigned int *)this + 26);
    if (v145 >= *((unsigned int *)this + 27))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v203, v204, v145 + 1, 8);
      *(void *)(*((void *)this + 12) + 8 * *((unsigned int *)this + 26)) = v144;
      unsigned int v146 = *((_DWORD *)this + 26);
      if (v146 >= *((_DWORD *)this + 27))
      {
LABEL_192:
        int v149 = 102;
        uint64_t v150 = "set_size";
        unint64_t v151 = "SmallVector.h";
        unint64_t v152 = "N <= capacity()";
        goto LABEL_193;
      }
    }
    else
    {
      *(void *)(*((void *)this + 12) + 8 * v145) = v144;
      unsigned int v146 = *((_DWORD *)this + 26);
      if (v146 >= *((_DWORD *)this + 27)) {
        goto LABEL_192;
      }
    }
    *((_DWORD *)this + 26) = v146 + 1;
    id v147 = [v222 objectAtIndexedSubscript:v135];
    [v221 addObject:v147];

    if (v135 >= [v228 count])
    {
      [v220 addObject:v137];
    }
    else
    {
      uint64_t v148 = [v228 objectAtIndexedSubscript:v135];
      [v220 addObject:v148];
    }
    unint64_t v110 = v230;

    ++v135;
  }
  objc_storeStrong((id *)this + 80, v221);
  objc_storeStrong((id *)this + 81, v220);
  uint64_t v153 = *((unsigned int *)this + 14);
  if (v153)
  {
    unint64_t v154 = 0;
    uint64_t v155 = (void *)*((void *)this + 6);
    unint64_t v216 = (id *)&v155[v153];
    while (1)
    {
      if (v154 >= [v219 count]) {
        goto LABEL_265;
      }
      if (*v155 >= (unint64_t)*((unsigned int *)this + 56)) {
        __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
      }
      v243[0] = *(void *)(*v217 + 8 * *v155);
      uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v243);
      if (!DefiningOp) {
        __assert_rtn("dyn_cast", "Casting.h", 662, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
      }
      if (!llvm::DefaultDoCastIfPossible<mlir::placement::TensorToMemref,mlir::Operation *,llvm::CastInfo<mlir::placement::TensorToMemref,mlir::Operation *,void>>::doCastIfPossible(DefiningOp)
        && MTLReportFailureTypeEnabled())
      {
        MTLReportFailure();
      }
      unint64_t v160 = [v219 objectAtIndexedSubscript:v154];
      int v161 = [v160 isEqual:MEMORY[0x1E4F1CC38]];

      if (v161) {
        break;
      }
LABEL_201:
      ++v154;
      if (++v155 == v216) {
        goto LABEL_265;
      }
    }
    uint64_t v162 = *((void *)this + 2);
    unint64_t v163 = mlir::Value::getDefiningOp((mlir::Value *)v243);
    unint64_t v164 = v163;
    int v218 = (id *)(v162 + 264);
    unint64_t v165 = 0x9DDFEA08EB382D69 * (((8 * v163) + 8) ^ HIDWORD(v163));
    unint64_t v166 = 0x9DDFEA08EB382D69 * (HIDWORD(v163) ^ (v165 >> 47) ^ v165);
    unint64_t v167 = 0x9DDFEA08EB382D69 * (v166 ^ (v166 >> 47));
    unint64_t v168 = *(void *)(v162 + 272);
    if (v168)
    {
      uint8x8_t v169 = (uint8x8_t)vcnt_s8((int8x8_t)v168);
      v169.i16[0] = vaddlv_u8(v169);
      if (v169.u32[0] > 1uLL)
      {
        unint64_t v136 = 0x9DDFEA08EB382D69 * (v166 ^ (v166 >> 47));
        if (v167 >= v168) {
          unint64_t v136 = v167 % v168;
        }
      }
      else
      {
        unint64_t v136 = (v168 - 1) & v167;
      }
      uint64_t v170 = (void **)*((void *)*v218 + v136);
      if (v170)
      {
        v171 = *v170;
        if (*v170)
        {
          if (v169.u32[0] < 2uLL)
          {
            while (1)
            {
              uint64_t v173 = v171[1];
              if (v173 == v167)
              {
                if (v171[2] == v163) {
                  goto LABEL_200;
                }
              }
              else if ((v173 & (v168 - 1)) != v136)
              {
                goto LABEL_227;
              }
              v171 = (void *)*v171;
              if (!v171) {
                goto LABEL_227;
              }
            }
          }
          do
          {
            unint64_t v172 = v171[1];
            if (v172 == v167)
            {
              if (v171[2] == v163) {
                goto LABEL_200;
              }
            }
            else
            {
              if (v172 >= v168) {
                v172 %= v168;
              }
              if (v172 != v136) {
                break;
              }
            }
            v171 = (void *)*v171;
          }
          while (v171);
        }
      }
    }
LABEL_227:
    v171 = operator new(0x20uLL);
    unsigned __int8 v174 = (void *)(v162 + 280);
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v171;
    __dst.__r_.__value_.__l.__size_ = v162 + 280;
    void *v171 = 0;
    v171[1] = v167;
    v171[2] = v164;
    v171[3] = 0;
    __dst.__r_.__value_.__s.__data_[16] = 1;
    float v175 = (float)(unint64_t)(*(void *)(v162 + 288) + 1);
    float v176 = *(float *)(v162 + 296);
    if (v168 && (float)(v176 * (float)v168) >= v175)
    {
      uint64_t v156 = (void *)(v162 + 264);
      int v157 = *v218;
      unint64_t v158 = (void *)*((void *)*v218 + v136);
      if (!v158) {
        goto LABEL_230;
      }
    }
    else
    {
      BOOL v178 = (v168 & (v168 - 1)) != 0;
      if (v168 < 3) {
        BOOL v178 = 1;
      }
      unint64_t v179 = v178 | (2 * v168);
      unint64_t v180 = vcvtps_u32_f32(v175 / v176);
      if (v179 <= v180) {
        size_t prime = v180;
      }
      else {
        size_t prime = v179;
      }
      if (prime == 1)
      {
        size_t prime = 2;
      }
      else if ((prime & (prime - 1)) != 0)
      {
        size_t prime = std::__next_prime(prime);
        unint64_t v168 = *(void *)(v162 + 272);
      }
      if (prime > v168) {
        goto LABEL_243;
      }
      if (prime < v168)
      {
        unint64_t v182 = vcvtps_u32_f32((float)*(unint64_t *)(v162 + 288) / *(float *)(v162 + 296));
        if (v168 < 3 || (uint8x8_t v183 = (uint8x8_t)vcnt_s8((int8x8_t)v168), v183.i16[0] = vaddlv_u8(v183), v183.u32[0] > 1uLL))
        {
          unint64_t v182 = std::__next_prime(v182);
        }
        else
        {
          uint64_t v184 = 1 << -(char)__clz(v182 - 1);
          if (v182 >= 2) {
            unint64_t v182 = v184;
          }
        }
        if (prime <= v182) {
          size_t prime = v182;
        }
        if (prime < v168) {
LABEL_243:
        }
          std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__do_rehash<true>((uint64_t)v218, prime);
      }
      unint64_t v168 = *(void *)(v162 + 272);
      unint64_t v185 = v168 - 1;
      if ((v168 & (v168 - 1)) != 0)
      {
        uint64_t v156 = (void *)(v162 + 264);
        if (v167 >= v168)
        {
          unint64_t v136 = v167 % v168;
          int v157 = *v218;
          unint64_t v158 = (void *)*((void *)*v218 + v167 % v168);
          if (!v158) {
            goto LABEL_230;
          }
        }
        else
        {
          unint64_t v136 = v167;
          int v157 = *v218;
          unint64_t v158 = (void *)*((void *)*v218 + v167);
          if (!v158) {
            goto LABEL_230;
          }
        }
      }
      else
      {
        unint64_t v136 = v185 & v167;
        uint64_t v156 = (void *)(v162 + 264);
        int v157 = *v218;
        unint64_t v158 = (void *)*((void *)*v218 + (v185 & v167));
        if (!v158)
        {
LABEL_230:
          void *v171 = *v174;
          *unsigned __int8 v174 = v171;
          v157[v136] = v174;
          unint64_t v110 = v230;
          if (!*v171)
          {
LABEL_199:
            ++*(void *)(v162 + 288);
LABEL_200:
            GPU::TensorToMemrefOpHandler::setAlignBytes(v171[3], 0x4000);
            goto LABEL_201;
          }
          unint64_t v177 = *(void *)(*v171 + 8);
          if ((v168 & (v168 - 1)) != 0)
          {
            if (v177 >= v168) {
              v177 %= v168;
            }
          }
          else
          {
            v177 &= v168 - 1;
          }
          unint64_t v158 = (void *)(*v156 + 8 * v177);
LABEL_198:
          *unint64_t v158 = v171;
          goto LABEL_199;
        }
      }
    }
    void *v171 = *v158;
    unint64_t v110 = v230;
    goto LABEL_198;
  }
LABEL_265:

  if (HIDWORD(v235) && v235)
  {
    uint64_t v186 = 0;
    do
    {
      uint64_t v187 = *(llvm **)((char *)v234 + v186);
      if (v187 != (llvm *)-8 && v187 != 0) {
        llvm::deallocate_buffer(v187, (void *)(*(void *)v187 + 17));
      }
      v186 += 8;
    }
    while (8 * v235 != v186);
  }
  free(v234);
  if (HIDWORD(v238) && v238)
  {
    uint64_t v189 = 0;
    do
    {
      unint64_t v190 = *(llvm **)((char *)v237 + v189);
      if (v190 != (llvm *)-8 && v190 != 0) {
        llvm::deallocate_buffer(v190, (void *)(*(void *)v190 + 17));
      }
      v189 += 8;
    }
    while (8 * v238 != v189);
  }
  free(v237);

  return this;
}

void sub_180D68C54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, void *a11, void **a12, void *a13, void **a14, char *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void **a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,int a38,int a39,uint64_t a40,void *a41,int a42,int a43)
{
  unsigned long long v45 = *(char **)(v43 + 264);
  unsigned int v46 = *(_DWORD *)(v43 + 272);
  if (v46)
  {
    uint64_t v49 = 88 * v46;
    do
    {
      unint64_t v50 = *(char **)&v45[v49 - 56];
      if (&v45[v49 - 40] != v50) {
        free(v50);
      }
      v49 -= 88;
    }
    while (v49);
    unsigned long long v45 = (char *)*a14;
    if (*a14 == a15)
    {
LABEL_3:
      uint64_t v47 = *a24;
      if (*a24 == a9) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  else if (v45 == a15)
  {
    goto LABEL_3;
  }
  free(v45);
  uint64_t v47 = *a24;
  if (*a24 == a9)
  {
LABEL_5:

    std::string::size_type v48 = *(void **)(v43 + 96);
    if (v48 != a11) {
      free(v48);
    }
    if (*a12 != a13) {
      free(*a12);
    }

    _Unwind_Resume(a1);
  }
LABEL_4:
  free(v47);
  goto LABEL_5;
}

void ___ZN3GPU22ANERegionCallOpHandlerC2EPNS_13BaseOpHandlerE_block_invoke()
{
  if (getenv("MPSGRAPH_DISABLE_ANE_SHARED_EVENTS"))
  {
    NSLog(&cfstr_MpsgraphDisabl_2.isa);
    _MergedGlobals_58 = 1;
  }
  if (getenv("MPSGRAPH_ENABLE_ANE_SHARED_EVENTS"))
  {
    NSLog(&cfstr_MpsgraphEnable_0.isa);
    byte_1EB216E41 = 1;
  }
  if (getenv("MPSGRAPH_ENABLE_ANE_SYNC_RUN"))
  {
    NSLog(&cfstr_MpsgraphEnable_2.isa);
    byte_1EB216E42 = 1;
  }
  if (getenv("MPS_GRAPH_ENABLE_ANE_ERRORS_AS_FAILURES"))
  {
    NSLog(&cfstr_MpsGraphEnable_0.isa);
    byte_1EB216E43 = 1;
  }
  if (getenv("MPS_GRAPH_ENABLE_ANE_OVERFLOW_AS_FAILURES"))
  {
    NSLog(&cfstr_MpsGraphEnable_2.isa);
    byte_1EB216E44 = 1;
  }
}

void GPU::ANERegionCallOpHandler::checkAndResetSharedEvents(GPU::ANERegionCallOpHandler *this)
{
  if ((unint64_t)(*((void *)this + 26) + 3) <= 1)
  {
    id v6 = [*(id *)(*((void *)this + 2) + 48) metalDevice];
    id v2 = objc_alloc_init(MEMORY[0x1E4F2EF90]);
    long long v3 = (void *)*((void *)this + 24);
    *((void *)this + 24) = v2;

    uint64_t v4 = objc_msgSend(v6, "newSharedEventWithMachPort:", objc_msgSend(*((id *)this + 24), "eventPort"));
    uint64_t v5 = (void *)*((void *)this + 25);
    *((void *)this + 25) = v4;

    *((void *)this + 26) = 0;
  }
}

void sub_180D692F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void GPU::ANERegionCallOpHandler::encodeSynchronous(uint64_t a1, uint64_t a2, void *a3, void *a4, char a5)
{
  id v13 = a3;
  id v9 = a4;
  if ((a5 & 1) == 0)
  {
    uint64_t v10 = [*(id *)(a2 + 8) rootCommandBuffer];
    (**(void (***)(uint64_t))a2)(a2);
    [v10 waitUntilCompleted];
  }
  uint64_t v11 = [MEMORY[0x1E4F4E088] requestWithInputs:v13 inputIndices:*(void *)(a1 + 632) outputs:v9 outputIndices:*(void *)(a1 + 640) weightsBuffer:0 perfStats:0 procedureIndex:*(void *)(a1 + 32) sharedEvents:0];
  uint64_t v12 = (void *)[*(id *)(a1 + 160) mutableCopy];
  [v12 setObject:MEMORY[0x1E4F1CC28] forKeyedSubscript:*MEMORY[0x1E4F4E0D0]];

  [*(id *)(a1 + 144) programHandle];
  kdebug_trace();
}

void sub_180D69470(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_180D69488(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_180D694A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_180D694BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_180D694D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void GPU::anonymous namespace'::evaluateModel(void *a1, void *a2, void *a3, void *a4, uint64_t a5, int a6, NSError *a7, int a8)
{
  id v15 = a1;
  id v16 = a2;
  id v17 = a3;
  id v18 = a4;
  if (v15)
  {
    if (a6)
    {
      uint64_t v24 = 0;
      uint64_t v19 = (id *)&v24;
      uint64_t v20 = [v16 evaluateRealTimeWithModel:v15 options:v17 request:v18 error:&v24];
    }
    else
    {
      uint64_t v23 = 0;
      uint64_t v19 = (id *)&v23;
      uint64_t v20 = [v16 evaluateWithModel:v15 options:v17 request:v18 qos:a5 error:&v23];
    }
    uint64_t v22 = v20;
    id v21 = *v19;
  }
  else
  {
    id v21 = 0;
    uint64_t v22 = 1;
  }
}

void sub_180D69618(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GPU::ANERegionCallOpHandler::encodeAsynchronousWithIOFences(uint64_t a1, uint64_t a2, void *a3, void *a4, int a5)
{
  id v9 = a3;
  id v10 = a4;
  dispatch_queue_t v26 = v10;
  dispatch_queue_t v27 = v9;
  GPU::ANERegionCallOpHandler::checkAndResetSharedEvents((GPU::ANERegionCallOpHandler *)a1);
  uint64_t v11 = *(void *)(a1 + 208);
  id v12 = *(id *)(a2 + 8);
  id v13 = v12;
  if ((a5 & 1) == 0)
  {
    ++v11;
    uint64_t v14 = *(void *)(a1 + 200);
    ++*(void *)(a1 + 208);
    [v12 encodeSignalEvent:v14 value:v11];
  }
  uint64_t v15 = *(void *)(a1 + 208) + 1;
  *(void *)(a1 + 208) = v15;
  id v16 = [MEMORY[0x1E4F4E088] requestWithInputs:v9 inputIndices:*(void *)(a1 + 632) outputs:v10 outputIndices:*(void *)(a1 + 640) weightsBuffer:0 perfStats:0 procedureIndex:*(void *)(a1 + 32) sharedEvents:0];
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 16) + 56));

  id v18 = *(id *)(a1 + 200);
  v34[0] = MEMORY[0x1E4F143A8];
  v34[1] = 3221225472;
  v34[2] = ___ZN3GPU22ANERegionCallOpHandler30encodeAsynchronousWithIOFencesEPNS_16EncodeDescriptorEP7NSArrayIP19_ANEIOSurfaceObjectES7_b_block_invoke;
  v34[3] = &unk_1E4FC10F0;
  uint64_t v36 = a1;
  id v19 = v18;
  id v35 = v19;
  uint64_t v37 = v15;
  id v38 = WeakRetained;
  [v16 setCompletionHandler:v34];
  uint64_t v20 = (void *)[*(id *)(a1 + 160) mutableCopy];
  [v20 setObject:MEMORY[0x1E4F1CC28] forKeyedSubscript:*MEMORY[0x1E4F4E0D0]];
  if (a5)
  {
    id v21 = *(NSObject **)(a1 + 176);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = ___ZN3GPU22ANERegionCallOpHandler30encodeAsynchronousWithIOFencesEPNS_16EncodeDescriptorEP7NSArrayIP19_ANEIOSurfaceObjectES7_b_block_invoke_2;
    block[3] = &unk_1E4FC1118;
    v33[1] = a1;
    uint64_t v22 = &v32;
    id v32 = v20;
    uint64_t v23 = (id *)v33;
    v33[0] = v16;
    dispatch_async(v21, block);
  }
  else
  {
    uint64_t v24 = *(void **)(a1 + 200);
    uint64_t v25 = *(void *)(a1 + 184);
    v28[0] = MEMORY[0x1E4F143A8];
    v28[1] = 3221225472;
    v28[2] = ___ZN3GPU22ANERegionCallOpHandler30encodeAsynchronousWithIOFencesEPNS_16EncodeDescriptorEP7NSArrayIP19_ANEIOSurfaceObjectES7_b_block_invoke_3;
    v28[3] = &unk_1E4FC1140;
    v30[1] = a1;
    id v29 = v20;
    v30[0] = v16;
    [v24 notifyListener:v25 atValue:v11 block:v28];
    uint64_t v22 = &v29;
    uint64_t v23 = (id *)v30;
  }

  [v13 encodeWaitForEvent:*(void *)(a1 + 200) value:v15];
}

void sub_180D698F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32)
{
  _Unwind_Resume(a1);
}

void ___ZN3GPU22ANERegionCallOpHandler30encodeAsynchronousWithIOFencesEPNS_16EncodeDescriptorEP7NSArrayIP19_ANEIOSurfaceObjectES7_b_block_invoke(uint64_t a1, GPU::_anonymous_namespace_ *a2, void *a3)
{
  id v6 = a3;
  uint64_t v5 = *(void *)(a1 + 40);
  [*(id *)(a1 + 32) setSignaledValue:*(void *)(a1 + 48)];
  [*(id *)(v5 + 144) programHandle];
  kdebug_trace();
}

void sub_180D69A10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t GPU::anonymous namespace'::checkANEEvaluationStatus(GPU::_anonymous_namespace_ *this, void *a2, NSError *a3, int a4)
{
  int v5 = (int)a3;
  char v6 = (char)this;
  id v7 = a2;
  id v8 = v7;
  if ((v6 & 1) == 0)
  {
    uint64_t v11 = v7;
    if ([v7 code] == 5)
    {
      if (!v5)
      {
        id v9 = [v11 debugDescription];
        NSLog(&cfstr_AneOverflowErr.isa, v9);
        goto LABEL_11;
      }
      id v7 = (id)MTLReportFailureTypeEnabled();
      id v8 = v11;
      if (!v7) {
        goto LABEL_12;
      }
    }
    else
    {
      if (!a4)
      {
        id v9 = [v11 debugDescription];
        NSLog(&cfstr_AneEvaluationE.isa, v9);
        goto LABEL_11;
      }
      id v7 = (id)MTLReportFailureTypeEnabled();
      id v8 = v11;
      if (!v7) {
        goto LABEL_12;
      }
    }
    id v9 = [v11 debugDescription];
    MTLReportFailure();
LABEL_11:

    id v8 = v11;
  }
LABEL_12:

  return MEMORY[0x1F41817F8](v7, v8);
}

void sub_180D69B68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_180D69B8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZN3GPU22ANERegionCallOpHandler30encodeAsynchronousWithIOFencesEPNS_16EncodeDescriptorEP7NSArrayIP19_ANEIOSurfaceObjectES7_b_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
}

void ___ZN3GPU22ANERegionCallOpHandler30encodeAsynchronousWithIOFencesEPNS_16EncodeDescriptorEP7NSArrayIP19_ANEIOSurfaceObjectES7_b_block_invoke_3(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
}

void GPU::ANERegionCallOpHandler::encodeAsynchronousWithSharedEvents(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  v85[1] = *MEMORY[0x1E4F143B8];
  id v77 = a3;
  id v78 = a4;
  GPU::ANERegionCallOpHandler::checkAndResetSharedEvents((GPU::ANERegionCallOpHandler *)a1);
  unint64_t v75 = [*(id *)(*(void *)(a1 + 16) + 48) metalDevice];
  uint64_t v8 = *(void *)(a1 + 208) + 1;
  *(void *)(a1 + 208) = v8;
  id v76 = *(id *)(a2 + 8);
  [v76 encodeSignalEvent:*(void *)(a1 + 200) value:v8];
  uint64_t v79 = *(void *)(a1 + 208) + 1;
  *(void *)(a1 + 208) = v79;
  int v80 = [MEMORY[0x1E4F1CA48] arrayWithCapacity:3];
  unint64_t v9 = [*(id *)(a2 + 8) rootCommandBuffer];
  id v10 = (void *)v9;
  uint64_t v11 = (uint64_t *)(a2 + 32);
  unint64_t v12 = 0x9DDFEA08EB382D69 * (((8 * v9) + 8) ^ HIDWORD(v9));
  unint64_t v13 = 0x9DDFEA08EB382D69 * (HIDWORD(v9) ^ (v12 >> 47) ^ v12);
  unint64_t v14 = 0x9DDFEA08EB382D69 * (v13 ^ (v13 >> 47));
  unint64_t v15 = *(void *)(a2 + 40);
  uint64_t v73 = v8;
  if (v15)
  {
    uint8x8_t v16 = (uint8x8_t)vcnt_s8((int8x8_t)v15);
    v16.i16[0] = vaddlv_u8(v16);
    if (v16.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69 * (v13 ^ (v13 >> 47));
      if (v14 >= v15) {
        unint64_t v4 = v14 % v15;
      }
    }
    else
    {
      unint64_t v4 = (v15 - 1) & v14;
    }
    id v17 = *(void ***)(*v11 + 8 * v4);
    if (v17)
    {
      id v18 = *v17;
      if (*v17)
      {
        if (v16.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v20 = *((void *)v18 + 1);
            if (v20 == v14)
            {
              if (*((void *)v18 + 2) == v9) {
                goto LABEL_62;
              }
            }
            else if ((v20 & (v15 - 1)) != v4)
            {
              goto LABEL_22;
            }
            id v18 = *(void **)v18;
            if (!v18) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v19 = *((void *)v18 + 1);
          if (v19 == v14)
          {
            if (*((void *)v18 + 2) == v9) {
              goto LABEL_62;
            }
          }
          else
          {
            if (v19 >= v15) {
              v19 %= v15;
            }
            if (v19 != v4) {
              break;
            }
          }
          id v18 = *(void **)v18;
        }
        while (v18);
      }
    }
  }
LABEL_22:
  id v18 = operator new(0x20uLL);
  id v21 = (void *)(a2 + 48);
  long long v82 = v18;
  uint64_t v83 = a2 + 48;
  *(void *)id v18 = 0;
  *((void *)v18 + 1) = v14;
  *((void *)v18 + 2) = v10;
  *((void *)v18 + 3) = 0;
  char v84 = 1;
  float v22 = (float)(unint64_t)(*(void *)(a2 + 56) + 1);
  float v23 = *(float *)(a2 + 64);
  if (v15 && (float)(v23 * (float)v15) >= v22)
  {
    uint64_t v24 = *v11;
    uint64_t v25 = *(void **)(*v11 + 8 * v4);
    if (v25)
    {
LABEL_25:
      *(void *)id v18 = *v25;
LABEL_60:
      void *v25 = v18;
      goto LABEL_61;
    }
  }
  else
  {
    BOOL v26 = 1;
    if (v15 >= 3) {
      BOOL v26 = (v15 & (v15 - 1)) != 0;
    }
    unint64_t v27 = v26 | (2 * v15);
    unint64_t v28 = vcvtps_u32_f32(v22 / v23);
    if (v27 <= v28) {
      size_t prime = v28;
    }
    else {
      size_t prime = v27;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v15 = *(void *)(a2 + 40);
    }
    if (prime > v15) {
      goto LABEL_36;
    }
    if (prime < v15)
    {
      unint64_t v30 = vcvtps_u32_f32((float)*(unint64_t *)(a2 + 56) / *(float *)(a2 + 64));
      if (v15 < 3 || (uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v15), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
      {
        unint64_t v30 = std::__next_prime(v30);
      }
      else
      {
        uint64_t v32 = 1 << -(char)__clz(v30 - 1);
        if (v30 >= 2) {
          unint64_t v30 = v32;
        }
      }
      if (prime <= v30) {
        size_t prime = v30;
      }
      if (prime < v15) {
LABEL_36:
      }
        std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__do_rehash<true>(a2 + 32, prime);
    }
    unint64_t v15 = *(void *)(a2 + 40);
    unint64_t v33 = v15 - 1;
    if ((v15 & (v15 - 1)) != 0)
    {
      if (v14 >= v15)
      {
        unint64_t v4 = v14 % v15;
        uint64_t v24 = *v11;
        uint64_t v25 = *(void **)(*v11 + 8 * (v14 % v15));
        if (v25) {
          goto LABEL_25;
        }
      }
      else
      {
        unint64_t v4 = v14;
        uint64_t v24 = *v11;
        uint64_t v25 = *(void **)(*v11 + 8 * v14);
        if (v25) {
          goto LABEL_25;
        }
      }
    }
    else
    {
      unint64_t v4 = v33 & v14;
      uint64_t v24 = *v11;
      uint64_t v25 = *(void **)(*v11 + 8 * (v33 & v14));
      if (v25) {
        goto LABEL_25;
      }
    }
  }
  *(void *)id v18 = *v21;
  *id v21 = v18;
  *(void *)(v24 + 8 * v4) = v21;
  if (*(void *)v18)
  {
    unint64_t v34 = *(void *)(*(void *)v18 + 8);
    if ((v15 & (v15 - 1)) != 0)
    {
      if (v34 >= v15) {
        v34 %= v15;
      }
    }
    else
    {
      v34 &= v15 - 1;
    }
    uint64_t v25 = (void *)(*v11 + 8 * v34);
    goto LABEL_60;
  }
LABEL_61:
  ++*(void *)(a2 + 56);
LABEL_62:
  id v35 = (GraphANESharedEventHandler *)*((id *)v18 + 3);
  if (!v35)
  {
    id v35 = [[GraphANESharedEventHandler alloc] initWithDevice:v75];
    unint64_t v36 = *(void *)(a2 + 40);
    if (v36)
    {
      uint8x8_t v37 = (uint8x8_t)vcnt_s8((int8x8_t)v36);
      v37.i16[0] = vaddlv_u8(v37);
      if (v37.u32[0] > 1uLL)
      {
        unint64_t v4 = v14;
        if (v14 >= v36) {
          unint64_t v4 = v14 % v36;
        }
      }
      else
      {
        unint64_t v4 = (v36 - 1) & v14;
      }
      id v38 = *(void **)(*v11 + 8 * v4);
      if (v38)
      {
        uint64_t v39 = (void *)*v38;
        if (v39)
        {
          if (v37.u32[0] < 2uLL)
          {
            while (1)
            {
              uint64_t v41 = v39[1];
              if (v41 == v14)
              {
                if ((void *)v39[2] == v10) {
                  goto LABEL_124;
                }
              }
              else if ((v41 & (v36 - 1)) != v4)
              {
                goto LABEL_84;
              }
              uint64_t v39 = (void *)*v39;
              if (!v39) {
                goto LABEL_84;
              }
            }
          }
          do
          {
            unint64_t v40 = v39[1];
            if (v40 == v14)
            {
              if ((void *)v39[2] == v10) {
                goto LABEL_124;
              }
            }
            else
            {
              if (v40 >= v36) {
                v40 %= v36;
              }
              if (v40 != v4) {
                break;
              }
            }
            uint64_t v39 = (void *)*v39;
          }
          while (v39);
        }
      }
    }
LABEL_84:
    unint64_t v42 = operator new(0x20uLL);
    uint64_t v43 = (void *)(a2 + 48);
    long long v82 = v42;
    uint64_t v83 = a2 + 48;
    *unint64_t v42 = 0;
    v42[1] = v14;
    void v42[2] = v10;
    v42[3] = v35;
    char v84 = 1;
    float v44 = (float)(unint64_t)(*(void *)(a2 + 56) + 1);
    float v45 = *(float *)(a2 + 64);
    if (v36 && (float)(v45 * (float)v36) >= v44)
    {
      uint64_t v46 = *v11;
      uint64_t v47 = *(void **)(*v11 + 8 * v4);
      if (v47)
      {
LABEL_87:
        *unint64_t v42 = *v47;
        goto LABEL_122;
      }
    }
    else
    {
      BOOL v48 = 1;
      if (v36 >= 3) {
        BOOL v48 = (v36 & (v36 - 1)) != 0;
      }
      unint64_t v49 = v48 | (2 * v36);
      unint64_t v50 = vcvtps_u32_f32(v44 / v45);
      if (v49 <= v50) {
        size_t v51 = v50;
      }
      else {
        size_t v51 = v49;
      }
      if (v51 == 1)
      {
        size_t v51 = 2;
      }
      else if ((v51 & (v51 - 1)) != 0)
      {
        size_t v51 = std::__next_prime(v51);
      }
      int8x8_t v52 = *(int8x8_t *)(a2 + 40);
      if (v51 > *(void *)&v52) {
        goto LABEL_98;
      }
      if (v51 < *(void *)&v52)
      {
        unint64_t v53 = vcvtps_u32_f32((float)*(unint64_t *)(a2 + 56) / *(float *)(a2 + 64));
        if (*(void *)&v52 < 3uLL || (uint8x8_t v54 = (uint8x8_t)vcnt_s8(v52), v54.i16[0] = vaddlv_u8(v54), v54.u32[0] > 1uLL))
        {
          unint64_t v53 = std::__next_prime(v53);
        }
        else
        {
          uint64_t v55 = 1 << -(char)__clz(v53 - 1);
          if (v53 >= 2) {
            unint64_t v53 = v55;
          }
        }
        if (v51 <= v53) {
          size_t v51 = v53;
        }
        if (v51 < *(void *)&v52) {
LABEL_98:
        }
          std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__do_rehash<true>(a2 + 32, v51);
      }
      unint64_t v36 = *(void *)(a2 + 40);
      unint64_t v56 = v36 - 1;
      if ((v36 & (v36 - 1)) != 0)
      {
        if (v14 >= v36)
        {
          unint64_t v4 = v14 % v36;
          uint64_t v46 = *v11;
          uint64_t v47 = *(void **)(*v11 + 8 * (v14 % v36));
          if (v47) {
            goto LABEL_87;
          }
        }
        else
        {
          unint64_t v4 = v14;
          uint64_t v46 = *v11;
          uint64_t v47 = *(void **)(*v11 + 8 * v14);
          if (v47) {
            goto LABEL_87;
          }
        }
      }
      else
      {
        unint64_t v4 = v56 & v14;
        uint64_t v46 = *v11;
        uint64_t v47 = *(void **)(*v11 + 8 * (v56 & v14));
        if (v47) {
          goto LABEL_87;
        }
      }
    }
    *unint64_t v42 = *v43;
    *uint64_t v43 = v42;
    *(void *)(v46 + 8 * v4) = v43;
    if (!*v42) {
      goto LABEL_123;
    }
    unint64_t v57 = *(void *)(*v42 + 8);
    if ((v36 & (v36 - 1)) != 0)
    {
      if (v57 >= v36) {
        v57 %= v36;
      }
    }
    else
    {
      v57 &= v36 - 1;
    }
    uint64_t v47 = (void *)(*v11 + 8 * v57);
LABEL_122:
    void *v47 = v42;
LABEL_123:
    ++*(void *)(a2 + 56);
LABEL_124:
    [v10 encodeSignalEventScheduled:v35->_sharedEvent value:1];
  }
  unint64_t v74 = [MEMORY[0x1E4F4E0A0] waitEventWithValue:v73 sharedEvent:*(void *)(a1 + 192) eventType:0];
  objc_msgSend(v80, "addObject:");
  if ([*(id *)(*(void *)(a2 + 16) + 24) count])
  {
    uint64_t v58 = [*(id *)(*(void *)(a2 + 16) + 24) objectAtIndexedSubscript:0];
    uint64_t v59 = (void *)[*(id *)(v58 + 8) newSharedEventHandle];
    uint64_t v60 = [v59 eventPort];
    uint64_t v61 = (IOSurfaceSharedEvent *)[objc_alloc(MEMORY[0x1E4F2EF90]) initWithMachPort:v60];
    uint64_t v62 = [MEMORY[0x1E4F4E0A0] waitEventWithValue:*(void *)(v58 + 16) sharedEvent:v61 eventType:1];
    [v80 addObject:v62];
  }
  else
  {
    uint64_t v61 = v35->_ioSurfaceStartSharedEvent;
    uint64_t v58 = [MEMORY[0x1E4F4E0A0] waitEventWithValue:1 sharedEvent:v61 eventType:1];
    [v80 addObject:v58];
  }

  uint64_t v63 = v35->_ioSurfaceStartSharedEvent;
  BOOL v64 = [MEMORY[0x1E4F4E0A0] waitEventWithValue:1 sharedEvent:v63 eventType:2];
  [v80 addObject:v64];
  uint64_t v65 = [MEMORY[0x1E4F4E098] signalEventWithValue:v79 symbolIndex:0 eventType:0 sharedEvent:*(void *)(a1 + 192)];
  uint64_t v66 = v65;
  if (*(unsigned char *)(a1 + 173)) {
    [v65 setAgentMask:6];
  }
  id v67 = (void *)MEMORY[0x1E4F4E090];
  v85[0] = v66;
  uint64_t v68 = [MEMORY[0x1E4F1C978] arrayWithObjects:v85 count:1];
  unint64_t v69 = [v67 sharedEventsWithSignalEvents:v68 waitEvents:v80];

  uint64_t v70 = [MEMORY[0x1E4F4E088] requestWithInputs:v77 inputIndices:*(void *)(a1 + 632) outputs:v78 outputIndices:*(void *)(a1 + 640) weightsBuffer:0 perfStats:0 procedureIndex:*(void *)(a1 + 32) sharedEvents:v69];
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 16) + 56));

  v81[0] = MEMORY[0x1E4F143A8];
  v81[1] = 3221225472;
  v81[2] = ___ZN3GPU22ANERegionCallOpHandler34encodeAsynchronousWithSharedEventsEPNS_16EncodeDescriptorEP7NSArrayIP19_ANEIOSurfaceObjectES7__block_invoke;
  v81[3] = &__block_descriptor_48_e20_v20__0B8__NSError_12l;
  v81[4] = a1;
  v81[5] = WeakRetained;
  [v70 setCompletionHandler:v81];
  [v76 encodeWaitForEvent:*(void *)(a1 + 200) value:v79];
  BOOL v72 = (void *)[*(id *)(a1 + 160) mutableCopy];
  [v72 setObject:MEMORY[0x1E4F1CC38] forKeyedSubscript:*MEMORY[0x1E4F4E0D0]];
}

void sub_180D6A5F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7, void *a8, void *a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t)va);

  _Unwind_Resume(a1);
}

void ___ZN3GPU22ANERegionCallOpHandler34encodeAsynchronousWithSharedEventsEPNS_16EncodeDescriptorEP7NSArrayIP19_ANEIOSurfaceObjectES7__block_invoke(uint64_t a1, GPU::_anonymous_namespace_ *a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = *(void *)(a1 + 32);
  id v7 = v5;
  [*(id *)(v6 + 144) programHandle];
  kdebug_trace();
}

void sub_180D6A810(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void GPU::ANERegionCallOpHandler::encodeOpWithInputsAndOutputs(uint64_t a1, uint64_t a2, void *a3, void *a4, int a5, int a6)
{
  id v12 = a3;
  id v11 = a4;
  if (a5 == 2)
  {
    GPU::ANERegionCallOpHandler::encodeAsynchronousWithSharedEvents(a1, a2, v12, v11);
  }
  else if (a5 == 1)
  {
    GPU::ANERegionCallOpHandler::encodeAsynchronousWithIOFences(a1, a2, v12, v11, a6);
  }
  else
  {
    if (a5) {
      llvm::llvm_unreachable_internal((llvm *)"Unknown encodeMode", "/Library/Caches/com.apple.xbs/Sources/MetalPerformanceShadersGraph/mpsgraph/MetalPerformanceShadersGraph/Runtimes/MPSRuntime/Operations/RegionOps/ANERegion.mm", (const char *)0x206);
    }
    GPU::ANERegionCallOpHandler::encodeSynchronous(a1, a2, v12, v11, a6);
  }
}

void sub_180D6A910(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void GPU::ANERegionCallOpHandler::encodeOp(GPU::ANERegionCallOpHandler *this, GPU::EncodeDescriptor *a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*((void *)this + 2) + 56));
  id v5 = (void *)*((void *)this + 18);
  if (v5) {
    [v5 programHandle];
  }
  kdebug_trace();

  uint64_t v6 = (void *)*((void *)a2 + 9);
  if (v6)
  {
    [v6 endEncoding];
    id v7 = (void *)*((void *)a2 + 9);
    *((void *)a2 + 9) = 0;
  }
  unint64_t v49 = a2;
  unint64_t v50 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(*((id *)this + 79), "count"));
  uint64_t v8 = *((unsigned int *)this + 14);
  if (v8)
  {
    unint64_t v9 = (void *)*((void *)this + 6);
    uint64_t v10 = 8 * v8;
    do
    {
      if (*v9 >= (unint64_t)*((unsigned int *)this + 56)) {
        __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
      }
      uint64_t v11 = *((void *)this + 2);
      memptr = *(void **)(*((void *)this + 27) + 8 * *v9);
      uint64_t v52 = *((void *)mlir::Value::getParentRegion((mlir::Value *)&memptr) + 2);
      id v12 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v11 + 88), &v52);
      if (v12
        && (size_t v51 = memptr,
            (unint64_t v13 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v12 + 3, (uint64_t *)&v51)) != 0))
      {
        id v14 = (id)v13[3];
      }
      else
      {
        id v14 = 0;
      }
      unint64_t v15 = objc_msgSend(MEMORY[0x1E4F4E048], "objectWithIOSurface:", objc_msgSend(v14, "iosurface"));
      if (!v15 && MTLReportFailureTypeEnabled()) {
        MTLReportFailure();
      }
      [v50 addObject:v15];

      ++v9;
      v10 -= 8;
    }
    while (v10);
  }
  BOOL v48 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(*((id *)this + 80), "count"));
  uint64_t v16 = *((unsigned int *)this + 26);
  if (v16)
  {
    uint64_t v17 = 0;
    uint64_t v47 = *((void *)this + 12);
    for (uint64_t i = 8 * v16; i; i -= 8)
    {
      unint64_t v19 = *(void *)(v47 + 8 * v17);
      if (v19 >= *((unsigned int *)this + 68)) {
        __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
      }
      uint64_t v20 = *((void *)this + 33);
      id v21 = [*((id *)this + 81) objectAtIndexedSubscript:v17];
      int v22 = [v21 isEqual:MEMORY[0x1E4F1CC38]];

      (*(void (**)(void, void, void, uint64_t, void, uint64_t))(**((void **)this + 2) + 80))(*((void *)this + 2), *(void *)(v20 + 88 * v19 + 8), *((void *)v49 + 1), 1, 0, 64);
      float v23 = (id *)objc_claimAutoreleasedReturnValue();
      uint64_t v24 = [v23 mpsndarray];
      uint64_t v25 = v24;
      uint64_t v26 = *(void *)((unsigned char *)v24 + (int)*MEMORY[0x1E4F359D0]) & 0x3FLL;
      if (v26) {
        int v27 = 0;
      }
      else {
        int v27 = v22;
      }
      if (v27 == 1)
      {
        unint64_t v28 = [v23[13] buffer];
        uint64_t v29 = [v28 gpuAddress] & 0x3FFF;

        if (v29) {
          goto LABEL_27;
        }
      }
      else
      {

        if (v26)
        {
LABEL_27:
          uint8x8_t v31 = (void *)MEMORY[0x1E4F35720];
          uint64_t MPSDataType = getMPSDataType(*(void **)(v20 + 88 * v19 + 24));
          unint64_t v33 = getMPSShapeFromMLIR(*(uint64_t **)(v20 + 88 * v19 + 32), *(unsigned int *)(v20 + 88 * v19 + 40));
          unint64_t v34 = [v31 descriptorWithDataType:MPSDataType shape:v33];

          *(void *)((char *)v34 + (int)*MEMORY[0x1E4F35A10]) = *(void *)(v20 + 88 * v19 + 16);
          if (v22)
          {
            memptr = 0;
            size_t v36 = GPU::calculateNDArrayAllocationSize(v34, v35);
            if (malloc_type_posix_memalign(&memptr, 0x4000uLL, v36, 0x2B559245uLL)) {
              BOOL v37 = 1;
            }
            else {
              BOOL v37 = memptr == 0;
            }
            if (v37 && MTLReportFailureTypeEnabled()) {
              MTLReportFailure();
            }
            id v38 = [*(id *)(*((void *)this + 2) + 48) metalDevice];
            uint64_t v39 = (void *)[v38 newBufferWithBytesNoCopy:memptr length:v36 options:0 deallocator:&__block_literal_global_147];

            uint64_t v40 = [objc_alloc(MEMORY[0x1E4F35690]) initWithBuffer:v39 descriptor:v34];
          }
          else
          {
            id v41 = objc_alloc(MEMORY[0x1E4F35690]);
            uint64_t v39 = [*(id *)(*((void *)this + 2) + 48) metalDevice];
            uint64_t v40 = [v41 initWithDevice:v39 descriptor:v34];
          }
          unint64_t v42 = (void *)v40;

          uint64_t v43 = [[MPSGraphTensorData alloc] initWithMPSNDArray:v42 device:*(void *)(*((void *)this + 2) + 48)];
          BaseRuntime::setTensorDataToDataMap(*((void *)this + 2), *(uint64_t **)(v20 + 88 * v19), v43);
          unint64_t v30 = objc_msgSend(MEMORY[0x1E4F4E048], "objectWithIOSurface:", -[MPSGraphTensorData iosurface](v43, "iosurface"));

          goto LABEL_35;
        }
      }
      unint64_t v30 = objc_msgSend(MEMORY[0x1E4F4E048], "objectWithIOSurface:", objc_msgSend(v23, "iosurface"));
LABEL_35:
      if (!v30 && MTLReportFailureTypeEnabled()) {
        MTLReportFailure();
      }
      [v48 addObject:v30];

      ++v17;
    }
  }
  if (*((unsigned char *)this + 42))
  {
    int v44 = 2;
    uint64_t v45 = (uint64_t)v49;
    uint64_t v46 = v50;
  }
  else
  {
    uint64_t v45 = (uint64_t)v49;
    uint64_t v46 = v50;
    if (*((unsigned char *)this + 40))
    {
      int v44 = 0;
    }
    else if (*((unsigned char *)this + 41))
    {
      int v44 = 1;
    }
    else
    {
      int v44 = 2;
    }
  }
  GPU::ANERegionCallOpHandler::encodeOpWithInputsAndOutputs((uint64_t)this, v45, v46, v48, v44, 0);
}

void sub_180D6AF1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D6AF30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D6AF40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_180D6AF54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_180D6B088(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void ___ZN3GPU22ANERegionCallOpHandler8encodeOpEPNS_16EncodeDescriptorE_block_invoke(int a1, void *a2)
{
}

void GPU::ANERegionCallOpHandler::~ANERegionCallOpHandler(id *this)
{
  GPU::ANERegionCallOpHandler::~ANERegionCallOpHandler(this);

  JUMPOUT(0x1852FDE70);
}

{
  id *v2;
  unsigned int v3;
  uint64_t v4;
  id *v5;
  id *v6;
  id *v7;
  id *v8;

  *this = &unk_1EC99F5E8;

  id v2 = (id *)this[33];
  long long v3 = *((_DWORD *)this + 68);
  if (v3)
  {
    unint64_t v4 = 11 * v3;
    do
    {
      id v5 = (id *)v2[v4 - 7];
      if (&v2[v4 - 5] != v5) {
        free(v5);
      }
      v4 -= 11;
    }
    while (v4 * 8);
    id v2 = (id *)this[33];
  }
  if (v2 != this + 35) {
    free(v2);
  }
  uint64_t v6 = (id *)this[27];
  if (v6 != this + 29) {
    free(v6);
  }

  id v7 = (id *)this[12];
  if (v7 != this + 14) {
    free(v7);
  }
  uint64_t v8 = (id *)this[6];
  if (v8 != this + 8) {
    free(v8);
  }
}

uint64_t *llvm::StringMap<unsigned long long,llvm::MallocAllocator>::try_emplace<>(uint64_t a1, int8x16_t *a2, const unsigned __int8 *a3)
{
  uint64_t v6 = llvm::StringMapImpl::LookupBucketFor((uint64_t *)a1, a2, a3);
  id v7 = (uint64_t *)(*(void *)a1 + 8 * v6);
  uint64_t v8 = *v7;
  if (*v7 == -8)
  {
    --*(_DWORD *)(a1 + 16);
    buffer = llvm::allocate_buffer((size_t)(a3 + 17), (std::align_val_t)8uLL);
    uint64_t v10 = buffer + 2;
    if (!a3) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  if (v8)
  {
    while (!v8 || v8 == -8)
    {
      uint64_t v17 = v7[1];
      ++v7;
      uint64_t v8 = v17;
    }
    return v7;
  }
  buffer = llvm::allocate_buffer((size_t)(a3 + 17), (std::align_val_t)8uLL);
  uint64_t v10 = buffer + 2;
  if (a3) {
LABEL_4:
  }
    memcpy(v10, a2, (size_t)a3);
LABEL_5:
  a3[(void)v10] = 0;
  void *buffer = a3;
  buffer[1] = 0;
  uint64_t *v7 = (uint64_t)buffer;
  unsigned int v11 = *(_DWORD *)(a1 + 8);
  int v12 = *(_DWORD *)(a1 + 12) + 1;
  *(_DWORD *)(a1 + 12) = v12;
  if (*(_DWORD *)(a1 + 16) + v12 > v11) {
    __assert_rtn("try_emplace", "StringMap.h", 353, "NumItems + NumTombstones <= NumBuckets");
  }
  id v7 = (uint64_t *)(*(void *)a1 + 8 * llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)a1, v6));
  if (*v7) {
    BOOL v13 = *v7 == -8;
  }
  else {
    BOOL v13 = 1;
  }
  if (v13)
  {
    do
    {
      uint64_t v15 = v7[1];
      ++v7;
      uint64_t v14 = v15;
      if (v15) {
        BOOL v16 = v14 == -8;
      }
      else {
        BOOL v16 = 1;
      }
    }
    while (v16);
  }
  return v7;
}

uint64_t std::__uninitialized_move[abi:ne180100]<GPU::ANERegionCallOpHandler::ResultInfo,GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*,std::__always_false,GPU::ANERegionCallOpHandler::ResultInfo* std::uninitialized_move[abi:ne180100]<GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*>(GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*)::{lambda(GPU::ANERegionCallOpHandler::ResultInfo*&&)#1}>(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result != a2)
  {
    uint64_t v5 = result;
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = v5 + v6;
      uint64_t v8 = a3 + v6;
      long long v9 = *(_OWORD *)(v5 + v6 + 16);
      *(_OWORD *)uint64_t v8 = *(_OWORD *)(v5 + v6);
      *(_OWORD *)(v8 + 16) = v9;
      *(void *)(v8 + 40) = 0x500000000;
      *(void *)(v8 + 32) = a3 + v6 + 48;
      uint64_t result = a3 + v6 + 32;
      if (*(_DWORD *)(v5 + v6 + 40)) {
        uint64_t result = llvm::SmallVectorImpl<llvm::SMLoc>::operator=(result, v7 + 32);
      }
      v6 += 88;
    }
    while (v7 + 88 != a2);
  }
  return result;
}

void sub_180D6B3F0(void *a1)
{
  unint64_t v4 = *(void **)(v1 + v2 + 32);
  if ((void *)(v1 + v2 + 48) != v4) {
    free(v4);
  }
  __cxa_begin_catch(a1);
  if (v2)
  {
    uint64_t v5 = (void *)(v1 + 48);
    do
    {
      uint64_t v6 = (void *)*(v5 - 2);
      if (v5 != v6) {
        free(v6);
      }
      v5 += 11;
      v2 -= 88;
    }
    while (v2);
  }
  __cxa_rethrow();
}

void sub_180D6B448(_Unwind_Exception *a1)
{
}

void sub_180D6B4E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D6B63C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D6B708(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D6C278(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,void *a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,uint64_t a26,char a27)
{
  if (__p) {
    operator delete(__p);
  }

  ScopedMPSSignpost::~ScopedMPSSignpost((ScopedMPSSignpost *)&a27);
  _Unwind_Resume(a1);
}

void ScopedMPSSignpost::~ScopedMPSSignpost(ScopedMPSSignpost *this)
{
}

void sub_180D6C528(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D6C738(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

BOOL validateLayout(MPSGraphTensor *a1, MPSGraphTensorNamedDataLayout a2, MPSGraphTensorNamedDataLayout *a3, int a4)
{
  uint64_t v7 = [(MPSGraphTensor *)a1 shape];
  uint64_t v8 = [v7 count];

  if (a4 < 1) {
    return 0;
  }
  uint64_t v9 = a4;
  while (1)
  {
    uint64_t v10 = *a3++;
    if (v10 == a2) {
      break;
    }
    if (!--v9) {
      return 0;
    }
  }
  if (!v8) {
    return 1;
  }
  if (a2 >= MPSGraphTensorNamedDataLayoutNCDHW)
  {
    int v13 = MTLReportFailureTypeEnabled();
    uint64_t v12 = 0;
    if (v13)
    {
      MTLReportFailure();
      uint64_t v12 = 0;
    }
  }
  else
  {
    uint64_t v12 = qword_18112A710[a2];
  }
  return v8 == v12;
}

void sub_180D6CB48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *EmitterObjC::QuantizationGenericOpHandler<mlir::mps::QuantizeOp,true>::QuantizationGenericOpHandler(void *a1, id *a2, uint64_t a3)
{
  a1[1] = a2;
  a1[2] = a3;
  *a1 = &unk_1EC997358;
  uint64_t v3 = *(void *)(a3 + 48);
  unint64_t v4 = *(void **)(v3 + 16);
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v49[0] = *(void **)(v3 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v49);
    if (v34 == 12 && *(void *)AttrData == 0x6E6175712E73706DLL && *(_DWORD *)(AttrData + 8) == 1702521204)
    {
      __int16 v48 = 1283;
      v45[0] = "classof on '";
      uint64_t v46 = "mps.quantize";
      uint64_t v47 = 12;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)"' failed due to the operation not being registered";
      __int16 v44 = 259;
      llvm::operator+((uint64_t *)v45, (uint64_t *)&__p, (uint64_t)v49);
      llvm::report_fatal_error((llvm::Twine *)v49, 1);
    }
LABEL_35:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::QuantizeOp,void>::id) {
    goto LABEL_35;
  }
  uint64_t v42 = a3;
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v42);
  uint64_t v8 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v42);
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v42);
  uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v42);
  FunctionType = (void *)mlir::func::FuncOp::getFunctionType((mlir::func::FuncOp *)&v42);
  uint64_t MPSDataType = (char *)getMPSDataType(FunctionType);
  EmitterObjC::emitMPSDataType(MPSDataType, (uint64_t)v49);
  uint64_t Axis = mlir::mps::DequantizeLUTOp::getAxis((mlir::mps::DequantizeLUTOp *)&v42);
  if ((Axis & 0xFF00000000) != 0) {
    uint64_t v14 = Axis;
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v15 = NSString;
  BOOL v16 = v45;
  (*((void (**)(void **__return_ptr, id *, uint64_t))*a2 + 4))(v45, a2, v8);
  if (SHIBYTE(v46) < 0) {
    BOOL v16 = (void **)v45[0];
  }
  uint64_t v41 = Input;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v41;
  uint64_t v17 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)(a2 + 32), &v41, (uint64_t)&std::piecewise_construct, &__p);
  id v18 = v17 + 3;
  if (*((char *)v17 + 47) < 0) {
    id v18 = (void *)*v18;
  }
  uint64_t v40 = Filter;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v40;
  unint64_t v19 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)(a2 + 32), &v40, (uint64_t)&std::piecewise_construct, &__p);
  uint64_t v20 = v19 + 3;
  if (*((char *)v19 + 47) < 0) {
    uint64_t v20 = (void *)*v20;
  }
  size_t v36 = v18;
  uint64_t v39 = Bias;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v39;
  id v21 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)(a2 + 32), &v39, (uint64_t)&std::piecewise_construct, &__p);
  int v22 = a1;
  float v23 = v21 + 3;
  uint64_t v24 = v16;
  if (*((char *)v21 + 47) < 0) {
    float v23 = (void *)*v23;
  }
  int v25 = v50;
  uint64_t v26 = (void **)v49[0];
  char v38 = 0;
  LOBYTE(v37) = 0;
  EmitObjC::emitTensorName((uint64_t)a2, v8, (uint64_t)&v37, &__p);
  int v27 = v49;
  if (v25 < 0) {
    int v27 = v26;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  objc_msgSend(v15, "stringWithFormat:", @"\n        MPSGraphTensor *%s = \n        [graph               %s:%s\n                    scaleTensor:%s\n                zeroPointTensor:%s\n                    dataType:%s\n                        axis:%d\n                        name:%s];\n        ",
    v24,
    "quantizeTensor",
    v36,
    v20,
    v23,
    v27,
    v14,
  uint64_t v29 = p_p);
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v38 & 0x80000000) == 0) {
      goto LABEL_21;
    }
LABEL_26:
    operator delete(v37);
    if ((SHIBYTE(v46) & 0x80000000) == 0) {
      goto LABEL_22;
    }
    goto LABEL_27;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (v38 < 0) {
    goto LABEL_26;
  }
LABEL_21:
  if ((SHIBYTE(v46) & 0x80000000) == 0) {
    goto LABEL_22;
  }
LABEL_27:
  operator delete(v45[0]);
LABEL_22:
  uint64_t v30 = [a2[27] stringByAppendingString:v29];
  id v31 = a2[27];
  a2[27] = (id)v30;

  if (v50 < 0) {
    operator delete(v49[0]);
  }
  return v22;
}

void sub_180D6CEFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  if ((*(char *)(v43 - 113) & 0x80000000) == 0) {
    _Unwind_Resume(a1);
  }
  operator delete(*(void **)(v43 - 136));
  _Unwind_Resume(a1);
}

void *EmitterObjC::QuantizationGenericOpHandler<mlir::mps::DequantizeOp,false>::QuantizationGenericOpHandler(void *a1, uint64_t a2, uint64_t a3)
{
  a1[1] = a2;
  a1[2] = a3;
  *a1 = &unk_1EC997370;
  uint64_t v3 = *(void *)(a3 + 48);
  unint64_t v4 = *(void **)(v3 + 16);
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v73[0] = *(void **)(v3 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v73);
    if (v53 == 14 && *AttrData == 0x757165642E73706DLL && *(void *)((char *)AttrData + 6) == 0x657A69746E617571)
    {
      __int16 v72 = 1283;
      v69[0] = "classof on '";
      uint64_t v70 = "mps.dequantize";
      uint64_t v71 = 14;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)"' failed due to the operation not being registered";
      __int16 v68 = 259;
      llvm::operator+((uint64_t *)v69, (uint64_t *)&__p, (uint64_t)v73);
      llvm::report_fatal_error((llvm::Twine *)v73, 1);
    }
LABEL_60:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id) {
    goto LABEL_60;
  }
  uint64_t v6 = a1;
  uint64_t v66 = a3;
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v66);
  uint64_t v8 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v66);
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v66);
  uint64_t v10 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(Filter + 8) & 0xFFFFFFFFFFFFFFF8));
  unint64_t v57 = v10;
  uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v66);
  mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v66);
  FunctionType = (void *)mlir::func::FuncOp::getFunctionType((mlir::func::FuncOp *)&v66);
  uint64_t MPSDataType = (char *)getMPSDataType(FunctionType);
  int v14 = (int)MPSDataType;
  EmitterObjC::emitMPSDataType(MPSDataType, (uint64_t)v73);
  uint64_t Axis = mlir::mps::DequantizeLUTOp::getAxis((mlir::mps::DequantizeLUTOp *)&v66);
  if ((Axis & 0xFF00000000) != 0) {
    uint64_t v16 = Axis;
  }
  else {
    uint64_t v16 = 0;
  }
  if ((v14 & 0xDFFFFFFF) == 4) {
    **(unsigned char **)(a2 + 312) = 1;
  }
  if ((unint64_t)[v10 count] < 2)
  {
    uint64_t v56 = v16;
    uint64_t v30 = NSString;
    id v31 = v69;
    (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)a2 + 32))(v69, a2, v8);
    if (SHIBYTE(v70) < 0) {
      id v31 = (void **)v69[0];
    }
    uint64_t v65 = Input;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v65;
    uint64_t v32 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>(a2 + 256, &v65, (uint64_t)&std::piecewise_construct, &__p);
    unint64_t v33 = v32 + 3;
    if (*((char *)v32 + 47) < 0) {
      unint64_t v33 = (void *)*v33;
    }
    uint64_t v64 = Filter;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v64;
    uint64_t v34 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>(a2 + 256, &v64, (uint64_t)&std::piecewise_construct, &__p);
    id v35 = v34 + 3;
    if (*((char *)v34 + 47) < 0) {
      id v35 = (void *)*v35;
    }
    uint64_t v63 = Bias;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v63;
    size_t v36 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>(a2 + 256, &v63, (uint64_t)&std::piecewise_construct, &__p);
    BOOL v37 = v36 + 3;
    if (*((char *)v36 + 47) < 0) {
      BOOL v37 = (void *)*v37;
    }
    int v38 = v74;
    uint64_t v39 = (void **)v73[0];
    char v59 = 0;
    LOBYTE(v58) = 0;
    EmitObjC::emitTensorName(a2, v8, (uint64_t)&v58, &__p);
    uint64_t v40 = v73;
    if (v38 < 0) {
      uint64_t v40 = v39;
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    objc_msgSend(v30, "stringWithFormat:", @"\n            MPSGraphTensor *%s = \n            [graph               %s:%s\n                        scaleTensor:%s\n                    zeroPointTensor:%s\n                        dataType:%s\n                            axis:%d\n                            name:%s];\n            ",
      v31,
      "dequantizeTensor",
      v33,
      v35,
      v37,
      v40,
      v56,
    uint64_t v42 = p_p);
    uint64_t v43 = v57;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((v59 & 0x80000000) == 0) {
        goto LABEL_48;
      }
    }
    else if ((v59 & 0x80000000) == 0)
    {
      goto LABEL_48;
    }
    __int16 v48 = v58;
  }
  else
  {
    uint64_t v55 = v8;
    Sparseuint64_t Shape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v66);
    id v18 = NSString;
    unint64_t v19 = v69;
    (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)a2 + 32))(v69, a2, v55);
    if (SHIBYTE(v70) < 0) {
      unint64_t v19 = (void **)v69[0];
    }
    uint64_t v65 = Input;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v65;
    uint64_t v20 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>(a2 + 256, &v65, (uint64_t)&std::piecewise_construct, &__p);
    id v21 = v20 + 3;
    if (*((char *)v20 + 47) < 0) {
      id v21 = (void *)*v21;
    }
    uint64_t v64 = Filter;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v64;
    int v22 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>(a2 + 256, &v64, (uint64_t)&std::piecewise_construct, &__p);
    float v23 = v22 + 3;
    if (*((char *)v22 + 47) < 0) {
      float v23 = (void *)*v23;
    }
    uint64_t v63 = Bias;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v63;
    uint64_t v24 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>(a2 + 256, &v63, (uint64_t)&std::piecewise_construct, &__p);
    int v25 = v24 + 3;
    if (*((char *)v24 + 47) < 0) {
      int v25 = (void *)*v25;
    }
    uint64_t v62 = SparseShape;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v62;
    uint64_t v26 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>(a2 + 256, &v62, (uint64_t)&std::piecewise_construct, &__p);
    int v27 = v6;
    unint64_t v28 = v26 + 3;
    uint64_t v29 = v21;
    if (*((char *)v26 + 47) < 0) {
      unint64_t v28 = (void *)*v28;
    }
    int v44 = v74;
    uint64_t v45 = (void **)v73[0];
    char v61 = 0;
    LOBYTE(v60) = 0;
    EmitObjC::emitTensorName(a2, v55, (uint64_t)&v60, &__p);
    uint64_t v46 = v73;
    if (v44 < 0) {
      uint64_t v46 = v45;
    }
    uint64_t v47 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v47 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    objc_msgSend(v18, "stringWithFormat:", @"\n            MPSGraphTensor *%s = \n            [graph               %s:%s\n                        scaleTensor:%s\n                    zeroPointTensor:%s\n                        minTensor:%s\n                        dataType:%s\n                            name:%s];\n            ",
      v19,
      "dequantizeTensor",
      v29,
      v23,
      v25,
      v28,
      v46,
    uint64_t v42 = v47);
    uint64_t v43 = v57;
    uint64_t v6 = v27;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((v61 & 0x80000000) == 0) {
        goto LABEL_48;
      }
    }
    else if ((v61 & 0x80000000) == 0)
    {
      goto LABEL_48;
    }
    __int16 v48 = v60;
  }
  operator delete(v48);
LABEL_48:
  if (SHIBYTE(v70) < 0) {
    operator delete(v69[0]);
  }
  uint64_t v49 = [*(id *)(a2 + 216) stringByAppendingString:v42];
  char v50 = *(void **)(a2 + 216);
  *(void *)(a2 + 216) = v49;

  if (v74 < 0) {
    operator delete(v73[0]);
  }

  return v6;
}

void sub_180D6D5C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  if (a41 < 0) {
    operator delete(__p);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  if (*(char *)(v41 - 153) < 0)
  {
    operator delete(*(void **)(v41 - 176));
    if ((*(char *)(v41 - 113) & 0x80000000) == 0) {
      goto LABEL_7;
    }
  }
  else if ((*(char *)(v41 - 113) & 0x80000000) == 0)
  {
LABEL_7:

    _Unwind_Resume(a1);
  }
  operator delete(*(void **)(v41 - 136));

  _Unwind_Resume(a1);
}

void sub_180D6D690()
{
  if (*(char *)(v0 - 113) < 0) {
    JUMPOUT(0x180D6D670);
  }
  JUMPOUT(0x180D6D658);
}

void sub_180D6D6A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_180D6D6B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_180D6D6C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_180D6D6DC()
{
  if (*(char *)(v1 - 113) < 0) {
    JUMPOUT(0x180D6D670);
  }
  JUMPOUT(0x180D6D658);
}

void sub_180D6D6F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void EmitObjC::emitTensorName(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, std::string *a4@<X8>)
{
  *((unsigned char *)&v24.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v24, "@\"");
  uint64_t v23 = a2;
  *(void *)__s = &v23;
  uint64_t v6 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>(a1 + 256, &v23, (uint64_t)&std::piecewise_construct, (void **)__s);
  uint64_t v9 = (const std::string::value_type *)v6[3];
  uint64_t v7 = (const std::string::value_type *)(v6 + 3);
  uint64_t v8 = v9;
  int v10 = v7[23];
  if (v10 >= 0) {
    unsigned int v11 = v7;
  }
  else {
    unsigned int v11 = v8;
  }
  if (v10 >= 0) {
    std::string::size_type v12 = *((unsigned __int8 *)v7 + 23);
  }
  else {
    std::string::size_type v12 = *((void *)v7 + 1);
  }
  int v13 = std::string::append(&v24, v11, v12);
  long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v25.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v14;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  int v15 = *(char *)(a3 + 23);
  if (v15 >= 0) {
    uint64_t v16 = (const std::string::value_type *)a3;
  }
  else {
    uint64_t v16 = *(const std::string::value_type **)a3;
  }
  if (v15 >= 0) {
    std::string::size_type v17 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    std::string::size_type v17 = *(void *)(a3 + 8);
  }
  id v18 = std::string::append(&v25, v16, v17);
  long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  v26.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  char v22 = 1;
  strcpy(__s, "\"");
  uint64_t v20 = std::string::append(&v26, __s, 1uLL);
  *a4 = *v20;
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  if (v22 < 0)
  {
    operator delete(*(void **)__s);
    if ((SHIBYTE(v26.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_15:
      if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_16;
      }
      goto LABEL_20;
    }
  }
  else if ((SHIBYTE(v26.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_15;
  }
  operator delete(v26.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_16:
    if ((SHIBYTE(v24.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
LABEL_21:
    operator delete(v24.__r_.__value_.__l.__data_);
    return;
  }
LABEL_20:
  operator delete(v25.__r_.__value_.__l.__data_);
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_21;
  }
}

void sub_180D6D884(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((*(char *)(v28 - 25) & 0x80000000) == 0)
    {
LABEL_3:
      if ((a28 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  else if ((*(char *)(v28 - 25) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*(void **)(v28 - 48));
  if ((a28 & 0x80000000) == 0)
  {
LABEL_4:
    if ((a22 & 0x80000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_9;
  }
LABEL_8:
  operator delete(a23);
  if ((a22 & 0x80000000) == 0) {
LABEL_5:
  }
    _Unwind_Resume(exception_object);
LABEL_9:
  operator delete(a17);
  _Unwind_Resume(exception_object);
}

void *std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>(uint64_t a1, uint64_t *a2, uint64_t a3, void **a4)
{
  uint64_t v7 = *a2;
  unint64_t v8 = HIDWORD(*a2);
  unint64_t v9 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ v8);
  unint64_t v10 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
    }
    else
    {
      unint64_t v4 = v10 & (v11 - 1);
    }
    int v13 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v13)
    {
      long long v14 = *v13;
      if (*v13)
      {
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v16 = v14[1];
            if (v16 == v10)
            {
              if (v14[2] == v7) {
                return v14;
              }
            }
            else if ((v16 & (v11 - 1)) != v4)
            {
              goto LABEL_23;
            }
            long long v14 = (void *)*v14;
            if (!v14) {
              goto LABEL_23;
            }
          }
        }
        do
        {
          unint64_t v15 = v14[1];
          if (v15 == v10)
          {
            if (v14[2] == v7) {
              return v14;
            }
          }
          else
          {
            if (v15 >= v11) {
              v15 %= v11;
            }
            if (v15 != v4) {
              break;
            }
          }
          long long v14 = (void *)*v14;
        }
        while (v14);
      }
    }
  }
LABEL_23:
  std::string::size_type v17 = (void *)(a1 + 16);
  long long v14 = operator new(0x30uLL);
  *long long v14 = 0;
  v14[1] = v10;
  v14[2] = **a4;
  v14[3] = 0;
  uint64_t v14[4] = 0;
  v14[5] = 0;
  float v18 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v19 = *(float *)(a1 + 32);
  if (v11 && (float)(v19 * (float)v11) >= v18)
  {
    uint64_t v20 = *(void *)a1;
    id v21 = *(void **)(*(void *)a1 + 8 * v4);
    if (v21)
    {
LABEL_26:
      *long long v14 = *v21;
LABEL_61:
      *id v21 = v14;
      goto LABEL_62;
    }
  }
  else
  {
    BOOL v22 = 1;
    if (v11 >= 3) {
      BOOL v22 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v11);
    unint64_t v24 = vcvtps_u32_f32(v18 / v19);
    if (v23 <= v24) {
      size_t prime = v24;
    }
    else {
      size_t prime = v23;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v11 = *(void *)(a1 + 8);
    }
    if (prime > v11) {
      goto LABEL_37;
    }
    if (prime < v11)
    {
      unint64_t v26 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v11 < 3 || (uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v11), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
      {
        unint64_t v26 = std::__next_prime(v26);
      }
      else
      {
        uint64_t v28 = 1 << -(char)__clz(v26 - 1);
        if (v26 >= 2) {
          unint64_t v26 = v28;
        }
      }
      if (prime <= v26) {
        size_t prime = v26;
      }
      if (prime < v11) {
LABEL_37:
      }
        std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v11 = *(void *)(a1 + 8);
    unint64_t v29 = v11 - 1;
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
      {
        unint64_t v4 = v10 % v11;
        uint64_t v20 = *(void *)a1;
        id v21 = *(void **)(*(void *)a1 + 8 * (v10 % v11));
        if (v21) {
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v4 = v10;
        uint64_t v20 = *(void *)a1;
        id v21 = *(void **)(*(void *)a1 + 8 * v10);
        if (v21) {
          goto LABEL_26;
        }
      }
    }
    else
    {
      unint64_t v4 = v29 & v10;
      uint64_t v20 = *(void *)a1;
      id v21 = *(void **)(*(void *)a1 + 8 * (v29 & v10));
      if (v21) {
        goto LABEL_26;
      }
    }
  }
  *long long v14 = *v17;
  void *v17 = v14;
  *(void *)(v20 + 8 * v4) = v17;
  if (*v14)
  {
    unint64_t v30 = *(void *)(*v14 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v30 >= v11) {
        v30 %= v11;
      }
    }
    else
    {
      v30 &= v11 - 1;
    }
    id v21 = (void *)(*(void *)a1 + 8 * v30);
    goto LABEL_61;
  }
LABEL_62:
  ++*(void *)(a1 + 24);
  return v14;
}

void sub_180D6DC68(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<void *,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<void *,std::string>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<std::__hash_node<std::__hash_value_type<void *,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<void *,std::string>,void *>>>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16) && *(char *)(v2 + 47) < 0) {
      operator delete(*(void **)(v2 + 24));
    }
    operator delete((void *)v2);
  }
  return a1;
}

uint64_t MILToMLIR::PoolingPattern::matchAndRewrite(MILToMLIR::PoolingPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  unint64_t v4 = a2;
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  v349[0] = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, v4, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)v4 + 192))(v4) != 1)
  {
    v347 = (char *)operator new(0x40uLL);
    long long v348 = xmmword_181129DA0;
    strcpy(v347, "The number of outputs does not match the number of results.");
    uint64_t v38 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)v4, (const std::string::value_type *)&v347);
    if (SHIBYTE(v348) < 0) {
      operator delete(v347);
    }
    return v38;
  }
  uint64_t v6 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(void *)v4 + 160))(v4);
  long long v348 = 0uLL;
  v347 = (char *)&v348;
  uint64_t v7 = v6 + 1;
  unint64_t v8 = *v6;
  uint64_t v332 = (MILToMLIRRewriter *)a3;
  if (*v6 == (const void **)(v6 + 1)) {
    goto LABEL_86;
  }
  v331 = v4;
  uint64_t v329 = LocationForOp;
  uint64_t v330 = (mlir::Builder *)(a3 + 18);
  while (2)
  {
    unint64_t v9 = std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__find_equal<std::string>((uint64_t **)&v347, (uint64_t *)&v348, (uint64_t **)&__s2, (uint64_t **)__s1, v8 + 4);
    if (*v9)
    {
      unint64_t v10 = (const void **)v8[1];
      if (!v10) {
        goto LABEL_43;
      }
      goto LABEL_37;
    }
    unint64_t v11 = (char *)operator new(0x50uLL);
    uint8x8_t v12 = (uint64_t *)v11;
    if (*((char *)v8 + 55) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)(v11 + 32), (const std::string::value_type *)v8[4], (std::string::size_type)v8[5]);
    }
    else
    {
      long long v13 = *((_OWORD *)v8 + 2);
      *((void *)v11 + 6) = v8[6];
      *((_OWORD *)v11 + 2) = v13;
    }
    v12[7] = 0;
    v12[8] = 0;
    v12[9] = 0;
    long long v14 = v8[7];
    unint64_t v15 = v8[8];
    uint64_t v16 = v15 - v14;
    if (v15 != v14)
    {
      if (v16 < 0) {
        std::vector<int>::__throw_length_error[abi:ne180100]();
      }
      std::string::size_type v17 = (char *)operator new(v15 - v14);
      uint64_t v18 = 0;
      v12[7] = (uint64_t)v17;
      v12[8] = (uint64_t)v17;
      v12[9] = (uint64_t)&v17[16 * (v16 >> 4)];
      do
      {
        float v19 = &v14[v18];
        uint64_t v20 = &v17[v18];
        *(void *)uint64_t v20 = *(void *)&v14[v18];
        uint64_t v21 = *(void *)&v14[v18 + 8];
        *((void *)v20 + 1) = v21;
        if (v21) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v21 + 8), 1uLL, memory_order_relaxed);
        }
        v18 += 16;
      }
      while (v19 + 16 != v15);
      v12[8] = (uint64_t)&v17[v18];
    }
    BOOL v22 = __s2;
    *uint8x8_t v12 = 0;
    v12[1] = 0;
    v12[2] = (uint64_t)v22;
    uint64_t *v9 = (uint64_t)v12;
    if (*(void *)v347)
    {
      v347 = *(char **)v347;
      uint8x8_t v12 = (uint64_t *)*v9;
    }
    unint64_t v23 = (uint64_t *)v348;
    *((unsigned char *)v12 + 24) = v12 == (uint64_t *)v348;
    if (v12 == v23)
    {
LABEL_36:
      ++*((void *)&v348 + 1);
      unint64_t v10 = (const void **)v8[1];
      if (!v10) {
        goto LABEL_43;
      }
      goto LABEL_37;
    }
    while (1)
    {
      uint64_t v24 = v12[2];
      if (*(unsigned char *)(v24 + 24)) {
        goto LABEL_36;
      }
      std::string v25 = *(uint64_t **)(v24 + 16);
      uint64_t v26 = *v25;
      if (*v25 != v24) {
        break;
      }
      uint64_t v29 = v25[1];
      if (!v29 || (int v30 = *(unsigned __int8 *)(v29 + 24), v27 = (unsigned char *)(v29 + 24), v30))
      {
        if (*(uint64_t **)v24 == v12)
        {
          *(unsigned char *)(v24 + 24) = 1;
          *((unsigned char *)v25 + 24) = 0;
          uint64_t v33 = *(void *)(v24 + 8);
          uint64_t *v25 = v33;
          if (v33) {
            goto LABEL_34;
          }
        }
        else
        {
          id v31 = *(uint64_t **)(v24 + 8);
          uint64_t v32 = *v31;
          *(void *)(v24 + 8) = *v31;
          if (v32)
          {
            *(void *)(v32 + 16) = v24;
            std::string v25 = *(uint64_t **)(v24 + 16);
          }
          v31[2] = (uint64_t)v25;
          *(void *)(*(void *)(v24 + 16) + 8 * (**(void **)(v24 + 16) != v24)) = v31;
          *id v31 = v24;
          *(void *)(v24 + 16) = v31;
          std::string v25 = (uint64_t *)v31[2];
          uint64_t v24 = *v25;
          *((unsigned char *)v31 + 24) = 1;
          *((unsigned char *)v25 + 24) = 0;
          uint64_t v33 = *(void *)(v24 + 8);
          uint64_t *v25 = v33;
          if (v33) {
LABEL_34:
          }
            *(void *)(v33 + 16) = v25;
        }
        *(void *)(v24 + 16) = v25[2];
        *(void *)(v25[2] + 8 * (*(void *)v25[2] != (void)v25)) = v24;
        *(void *)(v24 + 8) = v25;
        v25[2] = v24;
        goto LABEL_36;
      }
LABEL_22:
      *(unsigned char *)(v24 + 24) = 1;
      uint8x8_t v12 = v25;
      *((unsigned char *)v25 + 24) = v25 == v23;
      unsigned char *v27 = 1;
      if (v25 == v23) {
        goto LABEL_36;
      }
    }
    if (v26)
    {
      int v28 = *(unsigned __int8 *)(v26 + 24);
      uint8x8_t v27 = (unsigned char *)(v26 + 24);
      if (!v28) {
        goto LABEL_22;
      }
    }
    if (*(uint64_t **)v24 == v12)
    {
      uint64_t v37 = v12[1];
      *(void *)uint64_t v24 = v37;
      if (v37)
      {
        *(void *)(v37 + 16) = v24;
        std::string v25 = *(uint64_t **)(v24 + 16);
      }
      v12[2] = (uint64_t)v25;
      *(void *)(*(void *)(v24 + 16) + 8 * (**(void **)(v24 + 16) != v24)) = v12;
      v12[1] = v24;
      *(void *)(v24 + 16) = v12;
      std::string v25 = (uint64_t *)v12[2];
      *((unsigned char *)v12 + 24) = 1;
      *((unsigned char *)v25 + 24) = 0;
      id v35 = (uint64_t *)v25[1];
      uint64_t v36 = *v35;
      v25[1] = *v35;
      if (v36) {
LABEL_41:
      }
        *(void *)(v36 + 16) = v25;
    }
    else
    {
      *(unsigned char *)(v24 + 24) = 1;
      *((unsigned char *)v25 + 24) = 0;
      id v35 = (uint64_t *)v25[1];
      uint64_t v36 = *v35;
      v25[1] = *v35;
      if (v36) {
        goto LABEL_41;
      }
    }
    v35[2] = v25[2];
    *(void *)(v25[2] + 8 * (*(void *)v25[2] != (void)v25)) = v35;
    uint64_t *v35 = (uint64_t)v25;
    v25[2] = (uint64_t)v35;
    ++*((void *)&v348 + 1);
    unint64_t v10 = (const void **)v8[1];
    if (!v10)
    {
      do
      {
LABEL_43:
        uint64_t v34 = (const void ***)v8[2];
        BOOL v179 = *v34 == v8;
        unint64_t v8 = (const void **)v34;
      }
      while (!v179);
      goto LABEL_4;
    }
    do
    {
LABEL_37:
      uint64_t v34 = (const void ***)v10;
      unint64_t v10 = (const void **)*v10;
    }
    while (v10);
LABEL_4:
    unint64_t v8 = (const void **)v34;
    if (v34 != v7) {
      continue;
    }
    break;
  }
  uint64_t v39 = v348;
  HIBYTE(v346) = 1;
  LOWORD(__s2) = 120;
  unint64_t v4 = v331;
  if (!(void)v348) {
    goto LABEL_86;
  }
  uint64_t v40 = &v348;
  do
  {
    uint64_t v41 = (uint64_t *)v39;
    uint64_t v42 = v40;
    int v44 = (const void *)(v39 + 32);
    uint64_t v43 = *(const void **)(v39 + 32);
    uint64_t v45 = *(unsigned __int8 *)(v39 + 55);
    int v46 = (char)v45;
    if ((v45 & 0x80u) != 0) {
      uint64_t v45 = v41[5];
    }
    if (v46 >= 0) {
      uint64_t v47 = v44;
    }
    else {
      uint64_t v47 = v43;
    }
    BOOL v48 = v45 == 0;
    int v49 = memcmp(v47, &__s2, v45 != 0);
    if (v49) {
      BOOL v50 = v49 < 0;
    }
    else {
      BOOL v50 = v48;
    }
    if (v50) {
      size_t v51 = v41 + 1;
    }
    else {
      size_t v51 = v41;
    }
    if (v50) {
      uint64_t v40 = v42;
    }
    else {
      uint64_t v40 = (long long *)v41;
    }
    uint64_t v39 = *v51;
  }
  while (v39);
  if (v40 == &v348) {
    goto LABEL_86;
  }
  uint64_t v52 = v42 + 2;
  if (v50) {
    uint64_t v53 = v42;
  }
  else {
    uint64_t v53 = (long long *)v41;
  }
  if (!v50) {
    uint64_t v52 = v44;
  }
  unint64_t v54 = *((unsigned __int8 *)v40 + 55);
  uint64_t v56 = (const void *)*((void *)v53 + 4);
  unint64_t v55 = *((void *)v53 + 5);
  if ((v54 & 0x80u) == 0) {
    unint64_t v57 = v54;
  }
  else {
    unint64_t v57 = v55;
  }
  if ((v54 & 0x80u) == 0) {
    uint64_t v58 = v52;
  }
  else {
    uint64_t v58 = v56;
  }
  int v59 = memcmp(&__s2, v58, v57 != 0);
  BOOL v60 = v57 > 1;
  if (v59) {
    BOOL v60 = v59 < 0;
  }
  if (v60)
  {
LABEL_86:
    uint64_t __s2 = (char *)operator new(0x28uLL);
    long long v346 = xmmword_1811286F0;
    strcpy(__s2, "Could not find parameter with name 'x'.");
    uint64_t v61 = MILToMLIRRewriter::notifyFailure((uint64_t)v332, (uint64_t)v4, (const std::string::value_type *)&__s2);
    goto LABEL_87;
  }
  if (v50) {
    uint64_t v64 = v42;
  }
  else {
    uint64_t v64 = (long long *)v41;
  }
  if (*((void *)v64 + 8) - *((void *)v64 + 7) == 16)
  {
    HIBYTE(v346) = 1;
    LOWORD(__s2) = 120;
    ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
    if (SHIBYTE(v346) < 0) {
      operator delete(__s2);
    }
    uint64_t v66 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(ParameterType);
    uint64_t v67 = MIL::IRTensorValueType::Rank(v66);
    int v68 = v67;
    if (v67 <= 2)
    {
      uint64_t __s2 = (char *)operator new(0x20uLL);
      long long v346 = xmmword_181128710;
      strcpy(__s2, "Unexpectedly small rank for 'x'");
      uint64_t v61 = MILToMLIRRewriter::notifyFailure((uint64_t)v332, (uint64_t)v331, (const std::string::value_type *)&__s2);
      goto LABEL_87;
    }
    int v69 = v67 - 3;
    if ((unint64_t)(v67 - 3) < 3)
    {
      uint64_t v70 = (char *)operator new(0x20uLL);
      *(void *)&long long v346 = v70 + 32;
      *((void *)&v346 + 1) = v70 + 32;
      v328[0] = unk_18112A8C0;
      v328[1] = xmmword_18112A8B0;
      *(_OWORD *)uint64_t v70 = xmmword_18112A8B0;
      *((_OWORD *)v70 + 1) = unk_18112A8C0;
      uint64_t __s2 = v70;
      __s1[23] = 12;
      strcpy(__s1, "kernel_sizes");
      uint64_t v71 = v348;
      if (!(void)v348) {
        goto LABEL_138;
      }
      int v327 = v69 + 1;
      __int16 v72 = &v348;
      do
      {
        uint64_t v73 = (uint64_t *)v71;
        char v74 = v72;
        id v76 = (const void *)(v71 + 32);
        unint64_t v75 = *(const void **)(v71 + 32);
        unint64_t v77 = *(unsigned __int8 *)(v71 + 55);
        int v78 = (char)v77;
        if ((v77 & 0x80u) != 0) {
          unint64_t v77 = v73[5];
        }
        if (v78 >= 0) {
          uint64_t v79 = v76;
        }
        else {
          uint64_t v79 = v75;
        }
        if (v77 >= 0xC) {
          size_t v80 = 12;
        }
        else {
          size_t v80 = v77;
        }
        BOOL v81 = v77 < 0xC;
        int v82 = memcmp(v79, __s1, v80);
        if (v82) {
          BOOL v81 = v82 < 0;
        }
        if (v81) {
          uint64_t v83 = v73 + 1;
        }
        else {
          uint64_t v83 = v73;
        }
        if (v81) {
          __int16 v72 = v74;
        }
        else {
          __int16 v72 = (long long *)v73;
        }
        uint64_t v71 = *v83;
      }
      while (v71);
      if (v72 == &v348) {
        goto LABEL_138;
      }
      char v84 = v74 + 2;
      if (v81) {
        int v85 = v74;
      }
      else {
        int v85 = (long long *)v73;
      }
      if (!v81) {
        char v84 = v76;
      }
      unint64_t v86 = *((unsigned __int8 *)v72 + 55);
      int v87 = (char)v86;
      int v89 = (const void *)*((void *)v85 + 4);
      unint64_t v88 = *((void *)v85 + 5);
      if ((v86 & 0x80u) != 0) {
        unint64_t v86 = v88;
      }
      if (v87 >= 0) {
        unsigned int v90 = v84;
      }
      else {
        unsigned int v90 = v89;
      }
      if (v86 >= 0xC) {
        size_t v91 = 12;
      }
      else {
        size_t v91 = v86;
      }
      BOOL v92 = v86 > 0xC;
      int v93 = memcmp(__s1, v90, v91);
      BOOL v94 = v93 < 0;
      if (!v93) {
        BOOL v94 = v92;
      }
      if (v94)
      {
LABEL_138:
        uint64_t v95 = v332;
        goto LABEL_139;
      }
      if (v81) {
        uint64_t v98 = v74;
      }
      else {
        uint64_t v98 = (long long *)v73;
      }
      uint64_t v95 = v332;
      if (*((void *)v98 + 8) - *((void *)v98 + 7) != 16)
      {
LABEL_139:
        *(void *)__s1 = operator new(0x40uLL);
        *(_OWORD *)&__s1[8] = xmmword_18112A880;
        strcpy(*(char **)__s1, "required parameter \"kernel_sizes\" not found for pooling layer.");
        uint64_t v96 = MILToMLIRRewriter::notifyFailure((uint64_t)v95, (uint64_t)v331, __s1);
        goto LABEL_140;
      }
      __s1[23] = 12;
      strcpy(__s1, "kernel_sizes");
      Parameteruint64_t Value = MIL::IROperation::GetParameterValue();
      if ((__s1[23] & 0x80000000) != 0) {
        operator delete(*(void **)__s1);
      }
      (*(void (**)(uint64_t))(*(void *)ParameterValue + 40))(ParameterValue);
      uint64_t Data = MIL::IRTensorValue::GetDataView<int>();
      if (v101 == v327)
      {
        if (v101 < 8)
        {
          unint64_t v102 = 0;
          goto LABEL_154;
        }
        unint64_t v102 = 0;
        int v132 = 3 - v69;
        if (3 - v69 + (int)v101 - 1 < 3 - v69) {
          goto LABEL_154;
        }
        if ((v101 - 1) >> 32) {
          goto LABEL_154;
        }
        unint64_t v102 = v101 & 0xFFFFFFFFFFFFFFF8;
        uint64_t v133 = Data + 16;
        unint64_t v134 = v101 & 0xFFFFFFFFFFFFFFF8;
        do
        {
          long long v135 = *(_OWORD *)(v133 - 16);
          *(void *)&long long v136 = (int)v135;
          *((void *)&v136 + 1) = SDWORD1(v135);
          long long v137 = v136;
          *(void *)&long long v136 = SDWORD2(v135);
          *((void *)&v136 + 1) = SHIDWORD(v135);
          long long v138 = v136;
          *(void *)&long long v136 = (int)*(_OWORD *)v133;
          *((void *)&v136 + 1) = (int)HIDWORD(*(void *)v133);
          long long v139 = v136;
          *(void *)&long long v136 = (int)*(void *)(v133 + 8);
          *((void *)&v136 + 1) = (int)HIDWORD(*(_OWORD *)v133);
          unint64_t v140 = &v70[8 * v132];
          *(_OWORD *)unint64_t v140 = v137;
          *((_OWORD *)v140 + 1) = v138;
          *((_OWORD *)v140 + 2) = v139;
          *((_OWORD *)v140 + 3) = v136;
          v133 += 32;
          v132 += 8;
          v134 -= 8;
        }
        while (v134);
        if (v101 != v102)
        {
LABEL_154:
          int v103 = v102 - v68 + 6;
          unint64_t v104 = v101 - v102;
          uint64_t v105 = (int *)(Data + 4 * v102);
          do
          {
            uint64_t v106 = *v105++;
            *(void *)&v70[8 * v103++] = v106;
            --v104;
          }
          while (v104);
        }
        unint64_t v326 = v101;
        __s1[23] = 8;
        strcpy(__s1, "pad_type");
        uint64_t v107 = v348;
        if (!(void)v348) {
          goto LABEL_192;
        }
        uint64_t v108 = &v348;
        uint64_t v109 = v348;
        do
        {
          unint64_t v110 = (uint64_t *)v109;
          uint64_t v111 = v108;
          uint64_t v113 = (const void *)(v109 + 32);
          uint64_t v112 = *(const void **)(v109 + 32);
          unint64_t v114 = *(unsigned __int8 *)(v109 + 55);
          int v115 = (char)v114;
          if ((v114 & 0x80u) != 0) {
            unint64_t v114 = v110[5];
          }
          if (v115 >= 0) {
            uint64_t v116 = v113;
          }
          else {
            uint64_t v116 = v112;
          }
          if (v114 >= 8) {
            size_t v117 = 8;
          }
          else {
            size_t v117 = v114;
          }
          BOOL v118 = v114 < 8;
          int v119 = memcmp(v116, __s1, v117);
          if (v119) {
            BOOL v118 = v119 < 0;
          }
          if (v118) {
            uint64_t v120 = v110 + 1;
          }
          else {
            uint64_t v120 = v110;
          }
          if (v118) {
            uint64_t v108 = v111;
          }
          else {
            uint64_t v108 = (long long *)v110;
          }
          uint64_t v109 = *v120;
        }
        while (v109);
        if (v108 == &v348) {
          goto LABEL_192;
        }
        id v121 = v111 + 2;
        if (v118) {
          uint64_t v122 = v111;
        }
        else {
          uint64_t v122 = (long long *)v110;
        }
        if (!v118) {
          id v121 = v113;
        }
        unint64_t v123 = *((unsigned __int8 *)v108 + 55);
        int v124 = (char)v123;
        uint64_t v126 = (const void *)*((void *)v122 + 4);
        unint64_t v125 = *((void *)v122 + 5);
        if ((v123 & 0x80u) != 0) {
          unint64_t v123 = v125;
        }
        if (v124 >= 0) {
          unint64_t v127 = v121;
        }
        else {
          unint64_t v127 = v126;
        }
        if (v123 >= 8) {
          size_t v128 = 8;
        }
        else {
          size_t v128 = v123;
        }
        BOOL v129 = v123 > 8;
        int v130 = memcmp(__s1, v127, v128);
        BOOL v131 = v130 < 0;
        if (!v130) {
          BOOL v131 = v129;
        }
        if (v131)
        {
LABEL_192:
          *(void *)__s1 = operator new(0x30uLL);
          *(_OWORD *)&__s1[8] = xmmword_181129DC0;
          strcpy(*(char **)__s1, "Could not find parameter with name 'pad_type'.");
          uint64_t v96 = MILToMLIRRewriter::notifyFailure((uint64_t)v332, (uint64_t)v331, __s1);
          goto LABEL_140;
        }
        if (v118) {
          uint64_t v141 = v111;
        }
        else {
          uint64_t v141 = (long long *)v110;
        }
        if (*((void *)v141 + 8) - *((void *)v141 + 7) == 16)
        {
          unint64_t v325 = operator new(0x20uLL);
          *(void *)&__s1[8] = v325 + 2;
          *(void *)&__s1[16] = v325 + 2;
          _OWORD *v325 = v328[1];
          v325[1] = v328[0];
          *(void *)__s1 = v325;
          v343[23] = 7;
          strcpy(v343, "strides");
          uint64_t v142 = &v348;
          do
          {
            int v143 = (long long *)v107;
            uint64_t v144 = v142;
            unint64_t v145 = (const void *)(v107 + 32);
            unint64_t v146 = *(unsigned __int8 *)(v107 + 55);
            int v147 = (char)v146;
            if ((v146 & 0x80u) != 0) {
              unint64_t v146 = *(void *)(v107 + 40);
            }
            if (v147 >= 0) {
              uint64_t v148 = (const void *)(v107 + 32);
            }
            else {
              uint64_t v148 = *(const void **)(v107 + 32);
            }
            if (v146 >= 7) {
              size_t v149 = 7;
            }
            else {
              size_t v149 = v146;
            }
            BOOL v150 = v146 < 7;
            int v151 = memcmp(v148, v343, v149);
            if (v151) {
              BOOL v152 = v151 < 0;
            }
            else {
              BOOL v152 = v150;
            }
            if (v152) {
              uint64_t v153 = (long long *)((char *)v143 + 8);
            }
            else {
              uint64_t v153 = v143;
            }
            if (v152) {
              uint64_t v142 = v144;
            }
            else {
              uint64_t v142 = v143;
            }
            uint64_t v107 = *(void *)v153;
          }
          while (*(void *)v153);
          if (v142 != &v348)
          {
            unint64_t v154 = v144 + 2;
            if (v152) {
              uint64_t v155 = v144;
            }
            else {
              uint64_t v155 = v143;
            }
            if (!v152) {
              unint64_t v154 = v145;
            }
            unint64_t v156 = *((unsigned __int8 *)v142 + 55);
            int v157 = (char)v156;
            unint64_t v159 = (const void *)*((void *)v155 + 4);
            unint64_t v158 = *((void *)v155 + 5);
            if ((v156 & 0x80u) != 0) {
              unint64_t v156 = v158;
            }
            if (v157 >= 0) {
              unint64_t v160 = v154;
            }
            else {
              unint64_t v160 = v159;
            }
            if (v156 >= 7) {
              size_t v161 = 7;
            }
            else {
              size_t v161 = v156;
            }
            BOOL v162 = v156 > 7;
            int v163 = memcmp(v343, v160, v161);
            BOOL v164 = v163 < 0;
            if (!v163) {
              BOOL v164 = v162;
            }
            if (!v164)
            {
              unint64_t v165 = v152 ? v144 : v143;
              if (*((void *)v165 + 8) - *((void *)v165 + 7) == 16)
              {
                v343[23] = 7;
                strcpy(v343, "strides");
                uint64_t v166 = MIL::IROperation::TryGetParameterValue();
                if ((v343[23] & 0x80000000) != 0) {
                  operator delete(*(void **)v343);
                }
                (*(void (**)(uint64_t))(*(void *)v166 + 40))(v166);
                uint64_t v167 = MIL::IRTensorValue::GetDataView<int>();
                if (v168 == v326)
                {
                  if (v326 < 8)
                  {
                    unint64_t v169 = 0;
                    goto LABEL_249;
                  }
                  unint64_t v169 = 0;
                  int v300 = 3 - v69;
                  if (3 - v69 + (int)v326 - 1 < 3 - v69)
                  {
LABEL_249:
                    uint64_t v170 = v325;
                  }
                  else
                  {
                    uint64_t v170 = v325;
                    if (!((v326 - 1) >> 32))
                    {
                      unint64_t v169 = v326 & 0xFFFFFFFFFFFFFFF8;
                      uint64_t v301 = v167 + 16;
                      unint64_t v302 = v326 & 0xFFFFFFFFFFFFFFF8;
                      do
                      {
                        long long v303 = *(_OWORD *)(v301 - 16);
                        *(void *)&long long v304 = (int)v303;
                        *((void *)&v304 + 1) = SDWORD1(v303);
                        long long v305 = v304;
                        *(void *)&long long v304 = SDWORD2(v303);
                        *((void *)&v304 + 1) = SHIDWORD(v303);
                        long long v306 = v304;
                        *(void *)&long long v304 = (int)*(_OWORD *)v301;
                        *((void *)&v304 + 1) = (int)HIDWORD(*(void *)v301);
                        long long v307 = v304;
                        *(void *)&long long v304 = (int)*(void *)(v301 + 8);
                        *((void *)&v304 + 1) = (int)HIDWORD(*(_OWORD *)v301);
                        uint64_t v308 = (_OWORD *)((char *)v325 + 8 * v300);
                        *uint64_t v308 = v305;
                        v308[1] = v306;
                        v308[2] = v307;
                        v308[3] = v304;
                        v301 += 32;
                        v300 += 8;
                        v302 -= 8;
                      }
                      while (v302);
                      uint64_t v170 = v325;
                      if (v326 == v169) {
                        goto LABEL_252;
                      }
                    }
                  }
                  int v171 = v169 - v68 + 6;
                  unint64_t v172 = v326 - v169;
                  uint64_t v173 = (int *)(v167 + 4 * v169);
                  do
                  {
                    uint64_t v174 = *v173++;
                    *((void *)v170 + v171++) = v174;
                    --v172;
                  }
                  while (v172);
                  goto LABEL_252;
                }
                *(void *)v343 = operator new(0x40uLL);
                *(_OWORD *)&v343[8] = xmmword_18112A870;
                strcpy(*(char **)v343, "Strides parameter size must equal the dimension of the input.");
                uint64_t v38 = MILToMLIRRewriter::notifyFailure((uint64_t)v332, (uint64_t)v331, v343);
LABEL_493:
                if ((v343[23] & 0x80000000) != 0) {
                  operator delete(*(void **)v343);
                }
                int v97 = v325;
LABEL_142:
                operator delete(v97);
                goto LABEL_143;
              }
            }
          }
LABEL_252:
          v343[23] = 8;
          strcpy(v343, "pad_type");
          MIL::IROperation::TryGetParameterValue();
          if ((v343[23] & 0x80000000) != 0) {
            operator delete(*(void **)v343);
          }
          MIL::IRValue::GetScalar<std::string>();
          if ((v343[23] & 0x80000000) == 0)
          {
            float v175 = v343;
            switch(v343[23])
            {
              case 4:
                int v176 = *(_DWORD *)v343;
                goto LABEL_260;
              case 5:
                BOOL v179 = *(_DWORD *)v343 == 1768710518 && v343[4] == 100;
                if (!v179) {
                  goto LABEL_519;
                }
                goto LABEL_290;
              case 6:
                goto LABEL_273;
              case 0xA:
                if (*(void *)v343 != 0x776F6C5F656D6173 || *(unsigned __int16 *)&v343[8] != 29285) {
                  goto LABEL_519;
                }
                goto LABEL_284;
              default:
                goto LABEL_519;
            }
          }
          switch(*(void *)&v343[8])
          {
            case 4:
              int v176 = **(_DWORD **)v343;
LABEL_260:
              if (v176 != 1701667187) {
                goto LABEL_519;
              }
              int v177 = 0;
              unsigned int v178 = 2;
              goto LABEL_291;
            case 5:
              if (**(_DWORD **)v343 != 1768710518 || *(unsigned char *)(*(void *)v343 + 4) != 100) {
                goto LABEL_519;
              }
LABEL_290:
              int v177 = 0;
              unsigned int v178 = 1;
              goto LABEL_291;
            case 6:
              float v175 = *(unsigned char **)v343;
LABEL_273:
              int v181 = *(_DWORD *)v175;
              int v182 = *((unsigned __int16 *)v175 + 2);
              if (v181 != 1953723747 || v182 != 28015) {
                goto LABEL_519;
              }
              unsigned int v342 = 0;
              int v177 = 1;
              goto LABEL_292;
            case 0xALL:
              if (**(void **)v343 != 0x776F6C5F656D6173 || *(_WORD *)(*(void *)v343 + 8) != 29285) {
                goto LABEL_519;
              }
LABEL_284:
              int v177 = 0;
              unsigned int v178 = 4;
LABEL_291:
              unsigned int v342 = v178;
LABEL_292:
              uint64_t v186 = operator new(0x40uLL);
              v341[1] = v186 + 4;
              v341[2] = v186 + 4;
              *uint64_t v186 = 0u;
              v186[1] = 0u;
              v186[2] = 0u;
              v186[3] = 0u;
              v341[0] = v186;
              if (!v177) {
                goto LABEL_343;
              }
              HIBYTE(v340) = 3;
              LODWORD(__p) = 6578544;
              uint64_t v187 = v348;
              if (!(void)v348) {
                goto LABEL_329;
              }
              long long v188 = &v348;
              do
              {
                uint64_t v189 = (uint64_t *)v187;
                unint64_t v190 = v188;
                long long v192 = (const void *)(v187 + 32);
                uint64_t v191 = *(const void **)(v187 + 32);
                unint64_t v193 = *(unsigned __int8 *)(v187 + 55);
                int v194 = (char)v193;
                if ((v193 & 0x80u) != 0) {
                  unint64_t v193 = v189[5];
                }
                if (v194 >= 0) {
                  unsigned int v195 = v192;
                }
                else {
                  unsigned int v195 = v191;
                }
                if (v193 >= 3) {
                  size_t v196 = 3;
                }
                else {
                  size_t v196 = v193;
                }
                BOOL v197 = v193 < 3;
                int v198 = memcmp(v195, &__p, v196);
                if (v198) {
                  BOOL v197 = v198 < 0;
                }
                if (v197) {
                  uint64_t v199 = v189 + 1;
                }
                else {
                  uint64_t v199 = v189;
                }
                if (v197) {
                  long long v188 = v190;
                }
                else {
                  long long v188 = (long long *)v189;
                }
                uint64_t v187 = *v199;
              }
              while (v187);
              if (v188 == &v348) {
                goto LABEL_329;
              }
              BOOL v200 = v190 + 2;
              if (v197) {
                uint64_t v201 = v190;
              }
              else {
                uint64_t v201 = (long long *)v189;
              }
              if (!v197) {
                BOOL v200 = v192;
              }
              unint64_t v202 = *((unsigned __int8 *)v188 + 55);
              int v203 = (char)v202;
              int v205 = (const void *)*((void *)v201 + 4);
              unint64_t v204 = *((void *)v201 + 5);
              if ((v202 & 0x80u) != 0) {
                unint64_t v202 = v204;
              }
              if (v203 >= 0) {
                int v206 = v200;
              }
              else {
                int v206 = v205;
              }
              if (v202 >= 3) {
                size_t v207 = 3;
              }
              else {
                size_t v207 = v202;
              }
              BOOL v208 = v202 > 3;
              int v209 = memcmp(&__p, v206, v207);
              BOOL v210 = v209 < 0;
              if (!v209) {
                BOOL v210 = v208;
              }
              if (v210)
              {
LABEL_329:
                std::string __p = operator new(0x30uLL);
                long long v340 = xmmword_181129D90;
                strcpy((char *)__p, "Could not find parameter with name 'pad'.");
                uint64_t v211 = MILToMLIRRewriter::notifyFailure((uint64_t)v332, (uint64_t)v331, (const std::string::value_type *)&__p);
                goto LABEL_330;
              }
              if (v197) {
                uint64_t v213 = v190;
              }
              else {
                uint64_t v213 = (long long *)v189;
              }
              if (*((void *)v213 + 8) - *((void *)v213 + 7) != 16)
              {
                std::string __p = operator new(0x28uLL);
                long long v340 = xmmword_181129D80;
                strcpy((char *)__p, "Unexpected argument size for 'pad'");
                uint64_t v211 = MILToMLIRRewriter::notifyFailure((uint64_t)v332, (uint64_t)v331, (const std::string::value_type *)&__p);
LABEL_330:
                uint64_t v38 = v211;
                if ((SHIBYTE(v340) & 0x80000000) == 0) {
                  goto LABEL_492;
                }
                uint64_t v212 = __p;
LABEL_491:
                operator delete(v212);
LABEL_492:
                operator delete(v186);
                goto LABEL_493;
              }
              HIBYTE(v340) = 3;
              LODWORD(__p) = 6578544;
              uint64_t v214 = MIL::IROperation::TryGetParameterValue();
              if (SHIBYTE(v340) < 0) {
                operator delete(__p);
              }
              (*(void (**)(uint64_t))(*(void *)v214 + 40))(v214);
              uint64_t v215 = MIL::IRTensorValue::GetDataView<int>();
              if (!v216) {
                goto LABEL_343;
              }
              if (v216 >= 8)
              {
                unint64_t v217 = 0;
                int v309 = 8 - 2 * v327;
                if (v309 + (int)v216 - 1 >= v309 && !((v216 - 1) >> 32))
                {
                  unint64_t v217 = v216 & 0xFFFFFFFFFFFFFFF8;
                  uint64_t v310 = v215 + 16;
                  unint64_t v311 = v216 & 0xFFFFFFFFFFFFFFF8;
                  do
                  {
                    long long v312 = *(_OWORD *)(v310 - 16);
                    *(void *)&long long v313 = (int)v312;
                    *((void *)&v313 + 1) = SDWORD1(v312);
                    long long v314 = v313;
                    *(void *)&long long v313 = SDWORD2(v312);
                    *((void *)&v313 + 1) = SHIDWORD(v312);
                    long long v315 = v313;
                    *(void *)&long long v313 = (int)*(_OWORD *)v310;
                    *((void *)&v313 + 1) = (int)HIDWORD(*(void *)v310);
                    long long v316 = v313;
                    *(void *)&long long v313 = (int)*(void *)(v310 + 8);
                    *((void *)&v313 + 1) = (int)HIDWORD(*(_OWORD *)v310);
                    v317 = (_OWORD *)((char *)v186 + 8 * v309);
                    _OWORD *v317 = v314;
                    v317[1] = v315;
                    v317[2] = v316;
                    v317[3] = v313;
                    v310 += 32;
                    v309 += 8;
                    v311 -= 8;
                  }
                  while (v311);
                  if (v216 == v217)
                  {
LABEL_343:
                    int v222 = operator new(0x20uLL);
                    *(void *)&long long v340 = v222 + 2;
                    *((void *)&v340 + 1) = v222 + 2;
                    *int v222 = v328[1];
                    v222[1] = v328[0];
                    std::string __p = v222;
                    uint64_t v223 = (*(uint64_t (**)(const MIL::IROperation *))(*(void *)v331 + 56))(v331);
                    if (*(char *)(v223 + 23) < 0)
                    {
                      std::string::__init_copy_ctor_external(&v338, *(const std::string::value_type **)v223, *(void *)(v223 + 8));
                    }
                    else
                    {
                      long long v224 = *(_OWORD *)v223;
                      v338.__r_.__value_.__r.__words[2] = *(void *)(v223 + 16);
                      *(_OWORD *)&v338.__r_.__value_.__l.__data_ = v224;
                    }
                    __int16 v337 = 0;
                    HIBYTE(v336[2]) = 9;
                    strcpy((char *)v336, "ceil_mode");
                    uint64_t v225 = v348;
                    if ((void)v348)
                    {
                      uint64_t v226 = &v348;
                      do
                      {
                        BOOL v227 = (long long *)v225;
                        BOOL v228 = v226;
                        int v230 = (const void *)(v225 + 32);
                        BOOL v229 = *(const void **)(v225 + 32);
                        unint64_t v231 = *(unsigned __int8 *)(v225 + 55);
                        int v232 = (char)v231;
                        if ((v231 & 0x80u) != 0) {
                          unint64_t v231 = *((void *)v227 + 5);
                        }
                        if (v232 >= 0) {
                          BOOL v233 = v230;
                        }
                        else {
                          BOOL v233 = v229;
                        }
                        if (v231 >= 9) {
                          size_t v234 = 9;
                        }
                        else {
                          size_t v234 = v231;
                        }
                        BOOL v235 = v231 < 9;
                        int v236 = memcmp(v233, v336, v234);
                        if (v236) {
                          BOOL v235 = v236 < 0;
                        }
                        if (v235) {
                          unint64_t v237 = (long long *)((char *)v227 + 8);
                        }
                        else {
                          unint64_t v237 = v227;
                        }
                        if (v235) {
                          uint64_t v226 = v228;
                        }
                        else {
                          uint64_t v226 = v227;
                        }
                        uint64_t v225 = *(void *)v237;
                      }
                      while (v225);
                      if (v226 != &v348)
                      {
                        uint64_t v238 = v228 + 2;
                        if (v235) {
                          uint64_t v239 = v228;
                        }
                        else {
                          uint64_t v239 = v227;
                        }
                        if (!v235) {
                          uint64_t v238 = v230;
                        }
                        unint64_t v240 = *((unsigned __int8 *)v226 + 55);
                        int v241 = (char)v240;
                        unint64_t v243 = (const void *)*((void *)v239 + 4);
                        unint64_t v242 = *((void *)v239 + 5);
                        if ((v240 & 0x80u) != 0) {
                          unint64_t v240 = v242;
                        }
                        if (v241 >= 0) {
                          long long v244 = v238;
                        }
                        else {
                          long long v244 = v243;
                        }
                        if (v240 >= 9) {
                          size_t v245 = 9;
                        }
                        else {
                          size_t v245 = v240;
                        }
                        BOOL v246 = v240 > 9;
                        int v247 = memcmp(v336, v244, v245);
                        BOOL v248 = v247 < 0;
                        if (!v247) {
                          BOOL v248 = v246;
                        }
                        if (!v248)
                        {
                          unint64_t v249 = v235 ? v228 : v227;
                          if (*((void *)v249 + 8) - *((void *)v249 + 7) == 16)
                          {
                            HIBYTE(v336[2]) = 9;
                            strcpy((char *)v336, "ceil_mode");
                            uint64_t v250 = MIL::IROperation::TryGetParameterValue();
                            if (SHIBYTE(v336[2]) < 0) {
                              operator delete(v336[0]);
                            }
                            (*(void (**)(uint64_t))(*(void *)v250 + 40))(v250);
                            uint64_t v251 = (unsigned char *)MIL::IRTensorValue::GetDataView<BOOL>();
                            if (!v252)
                            {
                              exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                              std::runtime_error::runtime_error(exception, "index out of bounds");
                              exception->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x1E4FBA4B8] + 16);
                              __cxa_throw(exception, (struct type_info *)off_1E4FBE4C0, MEMORY[0x1E4FBA1B8]);
                            }
                            LOBYTE(v337) = *v251;
                          }
                        }
                      }
                    }
                    if ((v338.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      int64_t size = HIBYTE(v338.__r_.__value_.__r.__words[2]);
                    }
                    else {
                      int64_t size = v338.__r_.__value_.__l.__size_;
                    }
                    if ((v338.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      int v254 = &v338;
                    }
                    else {
                      int v254 = (std::string *)v338.__r_.__value_.__r.__words[0];
                    }
                    unint64_t v255 = (char *)v254 + size;
                    if (size <= 7) {
                      goto LABEL_463;
                    }
                    uint64_t v256 = size;
                    uint64_t v257 = v254;
                    while (1)
                    {
                      unint64_t v258 = memchr(v257, 97, v256 - 7);
                      if (!v258)
                      {
LABEL_401:
                        int64_t v260 = size;
                        uint64_t v261 = v254;
                        goto LABEL_402;
                      }
                      uint64_t v259 = (char *)v258;
                      if (*v258 == 0x6C6F6F705F677661) {
                        break;
                      }
                      uint64_t v257 = (std::string *)((char *)v258 + 1);
                      uint64_t v256 = v255 - (v259 + 1);
                      if (v256 < 8) {
                        goto LABEL_401;
                      }
                    }
                    int64_t v260 = size;
                    uint64_t v261 = v254;
                    if (v259 != v255)
                    {
                      int64_t v260 = size;
                      uint64_t v261 = v254;
                      if (v259 - (char *)v254 != -1)
                      {
                        uint64_t v263 = (char *)operator new(0x20uLL);
                        strcpy(v263, "exclude_padding_from_average");
                        qmemcpy(v328, "ing_from_averageexclude_padding_", sizeof(v328));
                        uint64_t v264 = v348;
                        if (!(void)v348) {
                          goto LABEL_444;
                        }
                        char v265 = &v348;
                        do
                        {
                          uint64_t v266 = (uint64_t *)v264;
                          long long v267 = v265;
                          long long v269 = (const void *)(v264 + 32);
                          uint64_t v268 = *(const void **)(v264 + 32);
                          unint64_t v270 = *(unsigned __int8 *)(v264 + 55);
                          int v271 = (char)v270;
                          if ((v270 & 0x80u) != 0) {
                            unint64_t v270 = v266[5];
                          }
                          if (v271 >= 0) {
                            unint64_t v272 = v269;
                          }
                          else {
                            unint64_t v272 = v268;
                          }
                          if (v270 >= 0x1C) {
                            size_t v273 = 28;
                          }
                          else {
                            size_t v273 = v270;
                          }
                          BOOL v274 = v270 < 0x1C;
                          int v275 = memcmp(v272, v263, v273);
                          if (v275) {
                            BOOL v274 = v275 < 0;
                          }
                          if (v274) {
                            uint64_t v276 = v266 + 1;
                          }
                          else {
                            uint64_t v276 = v266;
                          }
                          if (v274) {
                            char v265 = v267;
                          }
                          else {
                            char v265 = (long long *)v266;
                          }
                          uint64_t v264 = *v276;
                        }
                        while (v264);
                        if (v265 == &v348) {
                          goto LABEL_444;
                        }
                        long long v277 = v267 + 2;
                        if (v274) {
                          v278 = v267;
                        }
                        else {
                          v278 = (long long *)v266;
                        }
                        if (!v274) {
                          long long v277 = v269;
                        }
                        unint64_t v279 = *((unsigned __int8 *)v265 + 55);
                        int v280 = (char)v279;
                        uint64_t v282 = (const void *)*((void *)v278 + 4);
                        unint64_t v281 = *((void *)v278 + 5);
                        if ((v279 & 0x80u) != 0) {
                          unint64_t v279 = v281;
                        }
                        if (v280 >= 0) {
                          uint64_t v283 = v277;
                        }
                        else {
                          uint64_t v283 = v282;
                        }
                        if (v279 >= 0x1C) {
                          size_t v284 = 28;
                        }
                        else {
                          size_t v284 = v279;
                        }
                        BOOL v285 = v279 > 0x1C;
                        int v286 = memcmp(v263, v283, v284);
                        BOOL v287 = v286 < 0;
                        if (!v286) {
                          BOOL v287 = v285;
                        }
                        if (v287)
                        {
LABEL_444:
                          operator delete(v263);
                        }
                        else
                        {
                          operator delete(v263);
                          if (v274) {
                            uint64_t v318 = v267;
                          }
                          else {
                            uint64_t v318 = (long long *)v266;
                          }
                          if (*((void *)v318 + 8) - *((void *)v318 + 7) == 16)
                          {
                            uint64_t v319 = operator new(0x20uLL);
                            v336[0] = v319;
                            *(_OWORD *)&v336[1] = xmmword_181129E90;
                            _OWORD *v319 = v328[1];
                            *(_OWORD *)((char *)v319 + 12) = v328[0];
                            *((unsigned char *)v319 + 28) = 0;
                            uint64_t v320 = MIL::IROperation::TryGetParameterValue();
                            if (SHIBYTE(v336[2]) < 0) {
                              operator delete(v336[0]);
                            }
                            (*(void (**)(uint64_t))(*(void *)v320 + 40))(v320);
                            unint64_t v321 = (unsigned char *)MIL::IRTensorValue::GetDataView<BOOL>();
                            if (!v322)
                            {
                              uint64_t v324 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                              std::runtime_error::runtime_error(v324, "index out of bounds");
                              v324->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x1E4FBA4B8] + 16);
                              __cxa_throw(v324, (struct type_info *)off_1E4FBE4C0, MEMORY[0x1E4FBA1B8]);
                            }
                            BOOL v288 = *v321 != 0;
                            goto LABEL_446;
                          }
                        }
                        BOOL v288 = 0;
LABEL_446:
                        HIBYTE(v337) = !v288;
                        v336[0] = (void *)MILToMLIR::vecToAttr(v330, &__s2);
                        uint64_t v335 = MILToMLIR::vecToAttr(v330, __s1);
                        uint64_t v334 = MILToMLIR::vecToAttr(v330, &__p);
                        uint64_t v333 = MILToMLIR::vecToAttr(v330, v341);
                        uint64_t v289 = mlir::OpBuilder::create<mlir::mps::PoolAvgOp,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle &,mlir::DenseIntElementsAttr,BOOL &,BOOL &>((mlir::UnitAttr **)v330, v329, v349, (uint64_t *)v336, &v335, &v334, &v342, &v333, (char *)&v337, (char *)&v337 + 1);
                        (*(void (**)(void **__return_ptr))(*(void *)v331 + 200))(v336);
                        if (!*(_DWORD *)(v289 + 36)) {
                          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                        }
                        MILToMLIRRewriter::setValue((uint64_t)v332, (long long *)v336[0], v289 - 16);
                        long long v290 = (void **)v336[0];
                        if (!v336[0]) {
                          goto LABEL_487;
                        }
                        uint64_t v291 = (void **)v336[1];
                        uint64_t v292 = v336[0];
                        if (v336[1] == v336[0]) {
                          goto LABEL_486;
                        }
                        do
                        {
                          if (*((char *)v291 - 1) < 0) {
                            operator delete(*(v291 - 3));
                          }
                          v291 -= 3;
                        }
                        while (v291 != v290);
                        goto LABEL_485;
                      }
                    }
                    while (1)
                    {
LABEL_402:
                      int v262 = (char *)memchr(v261, 109, v260 - 7);
                      if (!v262) {
                        goto LABEL_463;
                      }
                      if (*(void *)v262 == 0x6C6F6F705F78616DLL) {
                        break;
                      }
                      uint64_t v261 = (std::string *)(v262 + 1);
                      int64_t v260 = v255 - (char *)v261;
                      if (v255 - (char *)v261 <= 7) {
                        goto LABEL_463;
                      }
                    }
                    if (v262 == v255 || v262 - (char *)v254 == -1)
                    {
LABEL_463:
                      if (size < 7) {
                        goto LABEL_481;
                      }
                      unint64_t v295 = v254;
                      while (1)
                      {
                        unint64_t v296 = (char *)memchr(v295, 108, size - 6);
                        if (!v296) {
                          goto LABEL_481;
                        }
                        if (*(_DWORD *)v296 == 1885287020 && *(_DWORD *)(v296 + 3) == 1819242352) {
                          break;
                        }
                        unint64_t v295 = (std::string *)(v296 + 1);
                        int64_t size = v255 - (char *)v295;
                        if (v255 - (char *)v295 < 7) {
                          goto LABEL_481;
                        }
                      }
                      if (v296 == v255 || v296 - (char *)v254 == -1)
                      {
LABEL_481:
                        v336[0] = operator new(0x20uLL);
                        *(_OWORD *)&v336[1] = xmmword_181129E30;
                        strcpy((char *)v336[0], "Unknown pooling type op.");
                        uint64_t v38 = MILToMLIRRewriter::notifyFailure((uint64_t)v332, (uint64_t)v331, (const std::string::value_type *)v336);
                        if (SHIBYTE(v336[2]) < 0) {
                          operator delete(v336[0]);
                        }
                        goto LABEL_488;
                      }
                      v336[0] = (void *)MILToMLIR::vecToAttr(v330, &__s2);
                      uint64_t v335 = MILToMLIR::vecToAttr(v330, __s1);
                      uint64_t v334 = MILToMLIR::vecToAttr(v330, &__p);
                      uint64_t v333 = MILToMLIR::vecToAttr(v330, v341);
                      uint64_t v298 = mlir::OpBuilder::create<mlir::mps::PoolL2NormOp,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle &,mlir::DenseIntElementsAttr,BOOL &,BOOL &>((mlir::UnitAttr **)v330, v329, v349, (uint64_t *)v336, &v335, &v334, &v342, &v333, (char *)&v337, (char *)&v337 + 1);
                      (*(void (**)(void **__return_ptr))(*(void *)v331 + 200))(v336);
                      if (!*(_DWORD *)(v298 + 36)) {
                        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                      }
                      MILToMLIRRewriter::setValue((uint64_t)v332, (long long *)v336[0], v298 - 16);
                      long long v290 = (void **)v336[0];
                      if (!v336[0])
                      {
LABEL_487:
                        uint64_t v38 = 1;
LABEL_488:
                        if (SHIBYTE(v338.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(v338.__r_.__value_.__l.__data_);
                        }
                        uint64_t v212 = v222;
                        goto LABEL_491;
                      }
                      int v299 = (void **)v336[1];
                      uint64_t v292 = v336[0];
                      if (v336[1] == v336[0])
                      {
LABEL_486:
                        v336[1] = v290;
                        operator delete(v292);
                        goto LABEL_487;
                      }
                      do
                      {
                        if (*((char *)v299 - 1) < 0) {
                          operator delete(*(v299 - 3));
                        }
                        v299 -= 3;
                      }
                      while (v299 != v290);
                    }
                    else
                    {
                      v336[0] = (void *)MILToMLIR::vecToAttr(v330, &__s2);
                      uint64_t v335 = MILToMLIR::vecToAttr(v330, __s1);
                      uint64_t v334 = MILToMLIR::vecToAttr(v330, &__p);
                      uint64_t v333 = MILToMLIR::vecToAttr(v330, v341);
                      uint64_t v293 = mlir::OpBuilder::create<mlir::mps::PoolMaxOp,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle &,mlir::DenseIntElementsAttr,BOOL &,BOOL &>((uint64_t *)v330, v329, v349, (uint64_t *)v336, &v335, &v334, &v342, &v333, (char *)&v337, (char *)&v337 + 1);
                      (*(void (**)(void **__return_ptr))(*(void *)v331 + 200))(v336);
                      if (!*(_DWORD *)(v293 + 36)) {
                        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                      }
                      MILToMLIRRewriter::setValue((uint64_t)v332, (long long *)v336[0], v293 - 16);
                      long long v290 = (void **)v336[0];
                      if (!v336[0]) {
                        goto LABEL_487;
                      }
                      uint64_t v294 = (void **)v336[1];
                      uint64_t v292 = v336[0];
                      if (v336[1] == v336[0]) {
                        goto LABEL_486;
                      }
                      do
                      {
                        if (*((char *)v294 - 1) < 0) {
                          operator delete(*(v294 - 3));
                        }
                        v294 -= 3;
                      }
                      while (v294 != v290);
                    }
LABEL_485:
                    uint64_t v292 = v336[0];
                    goto LABEL_486;
                  }
                }
              }
              else
              {
                unint64_t v217 = 0;
              }
              unint64_t v218 = v216 - v217;
              int v219 = v217 - 2 * v68 + 12;
              id v220 = (int *)(v215 + 4 * v217);
              do
              {
                uint64_t v221 = *v220++;
                *((void *)v186 + v219++) = v221;
                --v218;
              }
              while (v218);
              goto LABEL_343;
            default:
LABEL_519:
              __assert_rtn("matchAndRewriteGenericPool", "MILToMLIRRewritePool.mm", 122, "0 && \"Unknown padding style\"");
          }
        }
        *(void *)__s1 = operator new(0x28uLL);
        *(_OWORD *)&__s1[8] = xmmword_1811286F0;
        strcpy(*(char **)__s1, "Unexpected argument size for 'pad_type'");
        uint64_t v96 = MILToMLIRRewriter::notifyFailure((uint64_t)v332, (uint64_t)v331, __s1);
      }
      else
      {
        *(void *)__s1 = operator new(0x48uLL);
        *(_OWORD *)&__s1[8] = xmmword_18112A860;
        strcpy(*(char **)__s1, "kernel_sizes parameter size must equal the dimension of the input.");
        uint64_t v96 = MILToMLIRRewriter::notifyFailure((uint64_t)v332, (uint64_t)v331, __s1);
      }
LABEL_140:
      uint64_t v38 = v96;
      if ((__s1[23] & 0x80000000) != 0)
      {
        int v97 = *(void **)__s1;
        goto LABEL_142;
      }
LABEL_143:
      uint64_t v62 = (uint64_t *)v70;
LABEL_89:
      operator delete(v62);
      goto LABEL_90;
    }
    uint64_t __s2 = (char *)operator new(0x38uLL);
    long long v346 = xmmword_18112A850;
    strcpy(__s2, "Pooling is only supported for inputs of rank 3, 4, or 5");
    uint64_t v61 = MILToMLIRRewriter::notifyFailure((uint64_t)v332, (uint64_t)v331, (const std::string::value_type *)&__s2);
  }
  else
  {
    uint64_t __s2 = (char *)operator new(0x28uLL);
    long long v346 = xmmword_181128700;
    strcpy(__s2, "Unexpected argument size for 'x'");
    uint64_t v61 = MILToMLIRRewriter::notifyFailure((uint64_t)v332, (uint64_t)v331, (const std::string::value_type *)&__s2);
  }
LABEL_87:
  uint64_t v38 = v61;
  if (SHIBYTE(v346) < 0)
  {
    uint64_t v62 = (uint64_t *)__s2;
    goto LABEL_89;
  }
LABEL_90:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v347, (char *)v348);
  return v38;
}

void sub_180D6F9B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  __cxa_free_exception(v46);
  if (a39 < 0) {
    operator delete(__p);
  }
  operator delete(v48);
  operator delete(v47);
  if (*(char *)(v49 - 177) < 0)
  {
    operator delete(*(void **)(v49 - 200));
    uint64_t v52 = *(void **)(v49 - 176);
    if (v52) {
      goto LABEL_5;
    }
  }
  else
  {
    uint64_t v52 = *(void **)(v49 - 176);
    if (v52)
    {
LABEL_5:
      operator delete(v52);
      size_t v51 = *(void **)(v49 - 152);
      if (!v51)
      {
LABEL_10:
        std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy(v49 - 128, *(char **)(v49 - 120));
        _Unwind_Resume(a1);
      }
LABEL_9:
      operator delete(v51);
      goto LABEL_10;
    }
  }
  size_t v51 = *(void **)(v49 - 152);
  if (!v51) {
    goto LABEL_10;
  }
  goto LABEL_9;
}

void MILToMLIR::PoolingPattern::~PoolingPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t mlir::OpBuilder::create<mlir::mps::PoolAvgOp,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle &,mlir::DenseIntElementsAttr,BOOL &,BOOL &>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, unsigned int *a7, uint64_t *a8, char *a9, char *a10)
{
  v34[38] = *MEMORY[0x1E4F143B8];
  uint64_t v28 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v28);
  uint64_t v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_average", (const unsigned __int8 *)0x13, Context);
  if (!v20)
  {
    __int16 v32 = 1283;
    v31[2] = (uint64_t)"mps.pooling_average";
    v31[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v30 = 259;
    llvm::operator+(v31, (uint64_t *)&v29, (uint64_t)v33);
    llvm::report_fatal_error((llvm::Twine *)v33, 1);
  }
  mlir::OperationState::OperationState(v34, a2, v19);
  mlir::mps::PoolAvgOp::build(a1, (uint64_t)v34, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10);
  uint64_t v21 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v34);
  if (!v21)
  {
    uint64_t v24 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v25 = 662;
    uint64_t v26 = "Casting.h";
    uint8x8_t v27 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v22 = llvm::DefaultDoCastIfPossible<mlir::mps::PoolAvgOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PoolAvgOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v21);
  if (!v22)
  {
    uint64_t v24 = "result && \"builder didn't return the right type\"";
    int v25 = 497;
    uint64_t v26 = "Builders.h";
    uint8x8_t v27 = "create";
LABEL_8:
    __assert_rtn(v27, v26, v25, v24);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v34);
  return v22;
}

void sub_180D70058(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D70070(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t MILToMLIR::vecToAttr(mlir::Builder *a1, void *a2)
{
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  uint64_t v4 = (uint64_t)(a2[1] - *a2) >> 3;
  uint64_t v5 = operator new(8uLL);
  *uint64_t v5 = v4;
  uint64_t v6 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)v5, 1, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v6)) {
    goto LABEL_8;
  }
  if (v6)
  {
    uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v6);
    if (!InterfaceFor)
    {
      unint64_t v8 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v9 = 98;
      unint64_t v10 = "InterfaceSupport.h";
      unint64_t v11 = "Interface";
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t InterfaceFor = 0;
  }
  uint64_t v12 = mlir::DenseElementsAttr::getFromRawBuffer(v6, InterfaceFor, *a2, a2[1] - *a2, 8, 1, 0);
  if ((mlir::DenseIntElementsAttr::classof(v12) & 1) == 0)
  {
LABEL_8:
    unint64_t v8 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v9 = 566;
    unint64_t v10 = "Casting.h";
    unint64_t v11 = "cast";
LABEL_9:
    __assert_rtn(v11, v10, v9, v8);
  }
  operator delete(v5);
  return v12;
}

void sub_180D70184(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180D70198(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::PoolMaxOp,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle &,mlir::DenseIntElementsAttr,BOOL &,BOOL &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, unsigned int *a7, uint64_t *a8, char *a9, char *a10)
{
  v34[38] = *MEMORY[0x1E4F143B8];
  uint64_t v28 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v28);
  uint64_t v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_max", (const unsigned __int8 *)0xF, Context);
  if (!v20)
  {
    __int16 v32 = 1283;
    v31[2] = (uint64_t)"mps.pooling_max";
    v31[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v30 = 259;
    llvm::operator+(v31, (uint64_t *)&v29, (uint64_t)v33);
    llvm::report_fatal_error((llvm::Twine *)v33, 1);
  }
  mlir::OperationState::OperationState(v34, a2, v19);
  mlir::mps::PoolMaxOp::build(a1, (uint64_t)v34, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10);
  uint64_t v21 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v34);
  if (!v21)
  {
    uint64_t v24 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v25 = 662;
    uint64_t v26 = "Casting.h";
    uint8x8_t v27 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v22 = llvm::DefaultDoCastIfPossible<mlir::mps::PoolMaxOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PoolMaxOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v21);
  if (!v22)
  {
    uint64_t v24 = "result && \"builder didn't return the right type\"";
    int v25 = 497;
    uint64_t v26 = "Builders.h";
    uint8x8_t v27 = "create";
LABEL_8:
    __assert_rtn(v27, v26, v25, v24);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v34);
  return v22;
}

void sub_180D7036C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D70384(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::PoolL2NormOp,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle &,mlir::DenseIntElementsAttr,BOOL &,BOOL &>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, unsigned int *a7, uint64_t *a8, char *a9, char *a10)
{
  v34[38] = *MEMORY[0x1E4F143B8];
  uint64_t v28 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v28);
  uint64_t v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_l2_norm", (const unsigned __int8 *)0x13, Context);
  if (!v20)
  {
    __int16 v32 = 1283;
    v31[2] = (uint64_t)"mps.pooling_l2_norm";
    v31[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v30 = 259;
    llvm::operator+(v31, (uint64_t *)&v29, (uint64_t)v33);
    llvm::report_fatal_error((llvm::Twine *)v33, 1);
  }
  mlir::OperationState::OperationState(v34, a2, v19);
  mlir::mps::PoolL2NormOp::build(a1, (uint64_t)v34, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10);
  uint64_t v21 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v34);
  if (!v21)
  {
    uint64_t v24 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v25 = 662;
    uint64_t v26 = "Casting.h";
    uint8x8_t v27 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v22 = llvm::DefaultDoCastIfPossible<mlir::mps::PoolL2NormOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PoolL2NormOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v21);
  if (!v22)
  {
    uint64_t v24 = "result && \"builder didn't return the right type\"";
    int v25 = 497;
    uint64_t v26 = "Builders.h";
    uint8x8_t v27 = "create";
LABEL_8:
    __assert_rtn(v27, v26, v25, v24);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v34);
  return v22;
}

void sub_180D70558(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D70570(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::PoolAvgOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PoolAvgOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 19
      && *AttrData == 0x6C6F6F702E73706DLL
      && AttrData[1] == 0x726576615F676E69
      && *(void *)((char *)AttrData + 11) == 0x656761726576615FLL)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.pooling_average";
      v9[3] = 19;
      uint64_t v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::PoolAvgOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::PoolMaxOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PoolMaxOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 15 && *AttrData == 0x6C6F6F702E73706DLL && *(void *)((char *)AttrData + 7) == 0x78616D5F676E696CLL)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.pooling_max";
      v8[3] = 15;
      uint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::PoolMaxOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::PoolL2NormOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PoolL2NormOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 19
      && *AttrData == 0x6C6F6F702E73706DLL
      && AttrData[1] == 0x6E5F326C5F676E69
      && *(void *)((char *)AttrData + 11) == 0x6D726F6E5F326C5FLL)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.pooling_l2_norm";
      v9[3] = 19;
      __int16 v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::PoolL2NormOp,void>::id)
  {
    return 0;
  }
  return result;
}

void GPU::StencilOpHandler::_createNDArrayMultiaryKernel(GPU::StencilOpHandler *this)
{
  uint64_t v103 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(*((void *)this + 3) + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    *(void *)&long long v99 = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v99);
    if (v65 == 11 && *AttrData == 0x6E6574732E73706DLL && *(void *)((char *)AttrData + 3) == 0x6C69636E6574732ELL)
    {
      __int16 v98 = 1283;
      *(void *)&long long v96 = "classof on '";
      *(void *)&long long v97 = "mps.stencil";
      *((void *)&v97 + 1) = 11;
      *(void *)&long long v93 = "' failed due to the operation not being registered";
      __int16 v95 = 259;
      llvm::operator+((uint64_t *)&v96, (uint64_t *)&v93, (uint64_t)&v99);
      llvm::report_fatal_error((llvm::Twine *)&v99, 1);
    }
LABEL_130:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::StencilOp,void>::id) {
    goto LABEL_130;
  }
  uint64_t v92 = *((void *)this + 3);
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v92);
  unint64_t StaticType = GPURegionRuntime::getStaticType(*((void *)this + 2), Input);
  if (!*(void *)StaticType) {
    __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
  }
  if (*(_UNKNOWN **)(*(void *)StaticType + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  *(void *)&long long v99 = StaticType;
  uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v99);
  unint64_t v6 = v5;
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v92);
  unint64_t v8 = GPURegionRuntime::getStaticType(*((void *)this + 2), Filter);
  if (!*(void *)v8) {
    __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
  }
  if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  *(void *)&long long v99 = v8;
  __int16 v9 = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v99);
  unint64_t v11 = v10;
  uint64_t Offsets = mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v92);
  uint64_t v91 = v12;
  uint64_t Strides = mlir::mps::PoolMaxGradientOp::getStrides((mlir::mps::PoolMaxGradientOp *)&v92);
  uint64_t FastmathAttr = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v92);
  uint64_t ExplicitPadding = mlir::mps::StencilOp::getExplicitPadding((mlir::mps::StencilOp *)&v92);
  uint64_t v87 = v13;
  long long v96 = 0u;
  long long v97 = 0u;
  long long v93 = xmmword_18112A8D0;
  long long v94 = unk_18112A8E0;
  long long v84 = xmmword_18112A8D0;
  long long v85 = unk_18112A8E0;
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v99, Strides, 0);
  uint64_t v14 = Strides;
  uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&KernelSizes, v14, NumElements);
  int v16 = 0;
  while (1)
  {
    BOOL v17 = (void *)v99 == KernelSizes && BYTE8(v99) == v82;
    if (v17 && (void)v100 == v83) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v99, (llvm::APInt *)&v78);
    if (v16 == 4)
    {
      if (MTLReportFailureTypeEnabled()) {
        MTLReportFailure();
      }
    }
    unsigned int v18 = v79;
    if (v79 < 0x41)
    {
      *((void *)&v93 + 3 - v16++) = v78;
      goto LABEL_9;
    }
    unsigned int v19 = v18 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v78);
    char v20 = v78;
    if (v19 <= 0x40)
    {
      *((void *)&v93 + 3 - v16++) = *v78;
LABEL_24:
      MEMORY[0x1852FDE40]();
      goto LABEL_9;
    }
    *((void *)&v93 + 3 - v16++) = -1;
    if (v20) {
      goto LABEL_24;
    }
LABEL_9:
    *(void *)&long long v100 = v100 + 1;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v99, FastmathAttr, 0);
  uint64_t v21 = FastmathAttr;
  uint64_t v22 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&FastmathAttr);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&KernelSizes, v21, v22);
  int v23 = 0;
  while (1)
  {
    BOOL v24 = (void *)v99 == KernelSizes && BYTE8(v99) == v82;
    if (v24 && (void)v100 == v83) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v99, (llvm::APInt *)&v78);
    if (v23 == 4 && MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    unsigned int v25 = v79;
    if (v79 < 0x41)
    {
      *((void *)&v84 + 3 - v23++) = v78;
      goto LABEL_27;
    }
    unsigned int v26 = v25 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v78);
    uint8x8_t v27 = v78;
    if (v26 <= 0x40)
    {
      *((void *)&v84 + 3 - v23++) = *v78;
LABEL_42:
      MEMORY[0x1852FDE40]();
      goto LABEL_27;
    }
    *((void *)&v84 + 3 - v23++) = -1;
    if (v27) {
      goto LABEL_42;
    }
LABEL_27:
    *(void *)&long long v100 = v100 + 1;
  }
  if (v11 < 4) {
    __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
  }
  uint64_t v29 = *v9;
  uint64_t v28 = v9[1];
  uint64_t v31 = v9[2];
  uint64_t v30 = v9[3];
  long long v101 = 0u;
  long long v102 = 0u;
  long long v99 = 0u;
  long long v100 = 0u;
  uint64_t v32 = (v29 - 1) * *((void *)&v85 + 1) + 1;
  uint64_t v33 = (v28 - 1) * v85 + 1;
  uint64_t v34 = (v31 - 1) * *((void *)&v84 + 1) + 1;
  uint64_t v70 = (v30 - 1) * v84 + 1;
  switch(mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v92))
  {
    case 0u:
      goto LABEL_97;
    case 2u:
    case 4u:
      if (v6 <= 3) {
        __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
      }
      uint64_t v35 = *(void *)(Value + 8 * (v6 - 4)) % *((void *)&v94 + 1);
      if (!v35) {
        uint64_t v35 = *((void *)&v94 + 1);
      }
      unint64_t v36 = (v32 - v35) & ~((v32 - v35) >> 63);
      *(void *)&long long v99 = v36 >> 1;
      if (mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v92) == 4) {
        *(void *)&long long v99 = v36 - (v36 >> 1);
      }
      unint64_t v37 = *(void *)(Value + 8 * v6 - 24) % (unint64_t)v94;
      if (!v37) {
        unint64_t v37 = v94;
      }
      unint64_t v38 = (v33 - v37) & ~((uint64_t)(v33 - v37) >> 63);
      *(void *)&long long v100 = v38 >> 1;
      if (mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v92) == 4) {
        *(void *)&long long v100 = v38 - (v38 >> 1);
      }
      uint64_t v39 = *(void *)(Value + 8 * v6 - 16) % *((void *)&v93 + 1);
      if (!v39) {
        uint64_t v39 = *((void *)&v93 + 1);
      }
      unint64_t v40 = (v34 - v39) & ~((v34 - v39) >> 63);
      *(void *)&long long v101 = v40 >> 1;
      if (mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v92) == 4) {
        *(void *)&long long v101 = v40 - (v40 >> 1);
      }
      unint64_t v41 = *(void *)(Value + 8 * v6 - 8) % (unint64_t)v93;
      if (!v41) {
        unint64_t v41 = v93;
      }
      unint64_t v42 = (v70 - v41) & ~((uint64_t)(v70 - v41) >> 63);
      *(void *)&long long v102 = v42 >> 1;
      if (mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v92) == 4) {
        *(void *)&long long v102 = v42 - (v42 >> 1);
      }
      goto LABEL_62;
    case 3u:
      if (!(_BYTE)v91 && MTLReportFailureTypeEnabled()) {
        MTLReportFailure();
      }
      mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&KernelSizes, Offsets, 0);
      uint64_t v53 = Offsets;
      uint64_t v54 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Offsets);
      mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v78, v53, v54);
      int v55 = 0;
      break;
    default:
      goto LABEL_62;
  }
  while (2)
  {
    BOOL v56 = KernelSizes == v78 && v82 == v79;
    if (!v56 || v83 != v80)
    {
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&KernelSizes, (llvm::APInt *)&v76);
      if (v55 == 4 && MTLReportFailureTypeEnabled()) {
        MTLReportFailure();
      }
      unsigned int v57 = v77;
      if (v77 < 0x41)
      {
        *((void *)&v96 + 3 - v55++) = v76;
      }
      else
      {
        unsigned int v58 = v57 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v76);
        int v59 = v76;
        if (v58 <= 0x40)
        {
          *((void *)&v96 + 3 - v55++) = *v76;
        }
        else
        {
          *((void *)&v96 + 3 - v55++) = -1;
          if (!v59) {
            goto LABEL_81;
          }
        }
        MEMORY[0x1852FDE40]();
      }
LABEL_81:
      ++v83;
      continue;
    }
    break;
  }
LABEL_97:
  if (!(_BYTE)v87 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&KernelSizes, ExplicitPadding, 0);
  uint64_t v60 = ExplicitPadding;
  uint64_t v61 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&ExplicitPadding);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v78, v60, v61);
  for (uint64_t i = 0; ; ++i)
  {
    BOOL v63 = KernelSizes == v78 && v82 == v79;
    if (v63 && v83 == v80) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&KernelSizes, (llvm::APInt *)&v76);
    if (i == 8 && MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    *((void *)&v99 + i) = llvm::APInt::getSExtValue((llvm::APInt *)&v76);
    if (v77 >= 0x41 && v76) {
      MEMORY[0x1852FDE40](v76, 0x1000C8000313F17);
    }
    ++v83;
  }
LABEL_62:
  if (mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v92) != 3)
  {
    if (v32 >= 0) {
      uint64_t v43 = v32;
    }
    else {
      uint64_t v43 = v32 + 1;
    }
    uint64_t v44 = (v43 >> 1) - v99;
    if (v33 >= 0) {
      uint64_t v45 = v33;
    }
    else {
      uint64_t v45 = v33 + 1;
    }
    *(void *)&long long v97 = (v45 >> 1) - v100;
    *((void *)&v97 + 1) = v44;
    if (v34 >= 0) {
      uint64_t v46 = v34;
    }
    else {
      uint64_t v46 = v34 + 1;
    }
    *(void *)&long long v96 = v70 / 2 - v102;
    *((void *)&v96 + 1) = (v46 >> 1) - v101;
  }
  id v47 = objc_alloc(MEMORY[0x1E4F358B8]);
  BOOL v48 = [*(id *)(*((void *)this + 2) + 48) metalDevice];
  uint64_t v49 = (void *)[v47 initWithDevice:v48];

  v75[0] = v96;
  v75[1] = v97;
  [v49 setStencilOffsets:v75];
  v74[0] = v93;
  v74[1] = v94;
  [v49 setStencilStrides:v74];
  v73[0] = v84;
  v73[1] = v85;
  [v49 setStencilDilationRates:v73];
  unsigned int WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v92);
  if (WeightsLayout > 5)
  {
    uint64_t v67 = "0 && \"Unsupported reductionMode\"";
    int v68 = 33;
    int v69 = "mlirToMpsReductionMode";
    goto LABEL_129;
  }
  [v49 setReductionMode:dword_18112A974[WeightsLayout]];
  unsigned int PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v92);
  if (PaddingStyle >= 7)
  {
    uint64_t v67 = "0 && \"Unsupported paddingMode\"";
    int v68 = 56;
    int v69 = "mlirToMpsStencilPadMode";
LABEL_129:
    __assert_rtn(v69, "GPUStencilOps.mm", v68, v67);
  }
  [v49 setPaddingMode:dword_18112A98C[PaddingStyle]];
  KernelSizes = (void *)mlir::mps::ColToImOp::getKernelSizes((mlir::mps::ColToImOp *)&v92);
  double ValueAsDouble = mlir::FloatAttr::getValueAsDouble((mlir::FloatAttr *)&KernelSizes);
  *(float *)&double ValueAsDouble = ValueAsDouble;
  [v49 setPaddingConstant:ValueAsDouble];
  objc_storeStrong((id *)this + 1, v49);
  objc_msgSend(*((id *)this + 1), "setOptions:", objc_msgSend(*((id *)this + 1), "options") | 1);
}

void sub_180D713F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t llvm::APInt::getSExtValue(llvm::APInt *this)
{
  unsigned int v1 = *((_DWORD *)this + 2);
  if (v1 > 0x40)
  {
    uint64_t v3 = *(void *)this;
    if ((*(void *)(*(void *)this + 8 * ((v1 - 1) >> 6)) >> (v1 - 1)))
    {
      if (v1 - llvm::APInt::countLeadingOnesSlowCase(this) + 1 < 0x41) {
        return *(void *)v3;
      }
    }
    else if (v1 - llvm::APInt::countLeadingZerosSlowCase(this) + 1 < 0x41)
    {
      return *(void *)v3;
    }
    __assert_rtn("getSExtValue", "APInt.h", 1510, "getSignificantBits() <= 64 && \"Too many bits for int64_t\"");
  }
  if (!v1) {
    __assert_rtn("SignExtend64", "MathExtras.h", 461, "B > 0 && \"Bit width can't be 0.\"");
  }
  return (uint64_t)(*(void *)this << -(char)v1) >> -(char)v1;
}

void GPU::MultiaryKernelOpHandler<GPU::StencilOpHandler,mlir::mps::StencilOp,MPSNDArrayStencilKernel,2ul>::encodeNDArrayOp(uint64_t a1, void *a2, void *a3)
{
  id v51 = a3;
  if (!*(unsigned char *)(a1 + 40)) {
    GPU::StencilOpHandler::_createNDArrayMultiaryKernel((GPU::StencilOpHandler *)a1);
  }
  unint64_t v5 = objc_msgSend(v51, "objectAtIndexedSubscript:", 0, v51);
  unint64_t v6 = [v5 mpsndarray];

  if (!v6 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  id v7 = v6;
  uint64_t v8 = *(void *)(a1 + 24);
  uint64_t v9 = *(void *)(v8 + 48);
  unint64_t v10 = *(void **)(v9 + 16);
  if (v10 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v59[0] = *(void *)(v9 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v59);
    if (v49 == 11 && *AttrData == 0x6E6574732E73706DLL && *(void *)((char *)AttrData + 3) == 0x6C69636E6574732ELL)
    {
      __int16 v58 = 1283;
      v55[0] = (uint64_t)"classof on '";
      BOOL v56 = "mps.stencil";
      uint64_t v57 = 11;
      v53[0] = (uint64_t)"' failed due to the operation not being registered";
      __int16 v54 = 259;
      llvm::operator+(v55, v53, (uint64_t)v59);
      llvm::report_fatal_error((llvm::Twine *)v59, 1);
    }
LABEL_70:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v10 != &mlir::detail::TypeIDResolver<mlir::mps::StencilOp,void>::id) {
    goto LABEL_70;
  }
  if (!*(void *)(a1 + 32))
  {
    BOOL v17 = [MEMORY[0x1E4F1CA48] arrayWithCapacity:2];
    if ((*(unsigned char *)(v8 + 46) & 0x80) != 0)
    {
      if (!*(_DWORD *)(v8 + 68))
      {
LABEL_52:
        uint64_t v44 = "Index < this->size() && \"Invalid index!\"";
        int v45 = 443;
        uint64_t v46 = "ArrayRef.h";
        id v47 = "operator[]";
LABEL_53:
        __assert_rtn(v47, v46, v45, v44);
      }
      uint64_t v25 = *(void *)(a1 + 16);
      v59[0] = *(void *)(*(void *)(v8 + 72) + 24);
      v55[0] = *((void *)mlir::Value::getParentRegion((mlir::Value *)v59) + 2);
      unsigned int v26 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v25 + 88), v55);
      if (v26
        && (v53[0] = v59[0],
            (uint8x8_t v27 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v26 + 3, v53)) != 0))
      {
        id v28 = (id)v27[3];
      }
      else
      {
        id v28 = 0;
      }
      uint64_t v32 = [v28 mpsndarray];

      if (!v32 && MTLReportFailureTypeEnabled()) {
        MTLReportFailure();
      }
      [v17 addObject:v32];

      if ((*(unsigned char *)(v8 + 46) & 0x80) != 0)
      {
        if (*(_DWORD *)(v8 + 68) >= 2u)
        {
          uint64_t v33 = *(void *)(a1 + 16);
          v59[0] = *(void *)(*(void *)(v8 + 72) + 56);
          v55[0] = *((void *)mlir::Value::getParentRegion((mlir::Value *)v59) + 2);
          uint64_t v34 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v33 + 88), v55);
          if (v34
            && (v53[0] = v59[0],
                (uint64_t v35 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v34 + 3, v53)) != 0))
          {
            id v36 = (id)v35[3];
          }
          else
          {
            id v36 = 0;
          }
          unint64_t v37 = [v36 mpsndarray];

          if (!v37 && MTLReportFailureTypeEnabled()) {
            MTLReportFailure();
          }
          [v17 addObject:v37];

          id v22 = 0;
          id v23 = *(id *)(a1 + 8);
          BOOL v24 = (void *)a2[9];
          if (!v24) {
            goto LABEL_42;
          }
          goto LABEL_44;
        }
        goto LABEL_52;
      }
    }
    uint64_t v44 = "hasOperandStorage && \"expected operation to have operand storage\"";
    int v45 = 960;
    uint64_t v46 = "Operation.h";
    id v47 = "getOperandStorage";
    goto LABEL_53;
  }
  uint64_t v11 = *(void *)(mlir::Block::getParentOp(*(mlir::Block **)(v8 + 16)) + 48);
  if (*(_UNKNOWN **)(v11 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v59[0] = *(void *)(v11 + 8);
    uint64_t v12 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v59);
    if (v13 == 13 && *v12 == 0x6974732E7873706DLL && *(void *)((char *)v12 + 5) == 0x6465686374697473)
    {
      __int16 v58 = 1283;
      v55[0] = (uint64_t)"classof on '";
      BOOL v56 = "mpsx.stitched";
      uint64_t v57 = 13;
      v53[0] = (uint64_t)"' failed due to the operation not being registered";
      __int16 v54 = 259;
      llvm::operator+(v55, v53, (uint64_t)v59);
      llvm::report_fatal_error((llvm::Twine *)v59, 1);
    }
  }
  uint64_t v15 = *(void *)(mlir::Block::getParentOp(*(mlir::Block **)(*(void *)(a1 + 24) + 16)) + 48);
  int v16 = *(void **)(v15 + 16);
  if (v16 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v59[0] = *(void *)(v15 + 8);
    uint64_t v29 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v59);
    if (v30 == 13 && *v29 == 0x6974732E7873706DLL && *(void *)((char *)v29 + 5) == 0x6465686374697473)
    {
      __int16 v58 = 1283;
      v55[0] = (uint64_t)"classof on '";
      BOOL v56 = "mpsx.stitched";
      uint64_t v57 = 13;
      v59[0] = v55;
      v59[2] = "' failed due to the operation not being registered";
      __int16 v60 = 770;
      llvm::report_fatal_error((llvm::Twine *)v59, 1);
    }
  }
  else if (v16 == &mlir::detail::TypeIDResolver<mlir::mpsx::StitchedOp,void>::id)
  {
    goto LABEL_15;
  }
  if (MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
LABEL_15:
  BOOL v17 = GPU::MPSGraphKernelDAG::getNDArraysForPlaceholders(*(GPU::MPSGraphKernelDAG **)(a1 + 32), *(GPURegionRuntime **)(a1 + 16));
  uint64_t v18 = *(void *)(a1 + 32);
  unsigned int v19 = *(void **)(v18 + 120);
  if (!v19)
  {
    if (!*(void *)(v18 + 96) && MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    uint64_t v20 = [objc_alloc(MEMORY[0x1E4F35608]) initWithKernelDAG:v18 + 80 finalOp:*(void *)(*(void *)(v18 + 96) + 32)];
    uint64_t v21 = *(void **)(v18 + 120);
    *(void *)(v18 + 120) = v20;

    unsigned int v19 = *(void **)(v18 + 120);
  }
  id v22 = v19;
  id v23 = *(id *)(a1 + 8);
  BOOL v24 = (void *)a2[9];
  if (!v24)
  {
LABEL_42:
    uint64_t v38 = [objc_alloc(MEMORY[0x1E4F35528]) initWithCommandBuffer:a2[1] withDispatchType:0];
    uint64_t v39 = (void *)a2[9];
    a2[9] = v38;

    unint64_t v40 = (void *)a2[11];
    BOOL v24 = (void *)a2[9];
    if (v40)
    {
      uint64_t v41 = [v40 wrapComputeEncoder:a2[9]];
      unint64_t v42 = (void *)a2[9];
      a2[9] = v41;

      BOOL v24 = (void *)a2[9];
    }
  }
LABEL_44:
  if (a2[10])
  {
    objc_msgSend(v24, "setLabel:");
    BOOL v24 = (void *)a2[9];
  }
  id v43 = v24;
  [v23 encodeToMPSCommandEncoder:v43 commandBuffer:a2[1] sourceArrays:v17 resultState:0 destinationArray:v7 kernelDAGObject:v22];
}

void sub_180D71C28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  _Unwind_Resume(a1);
}

void sub_180D71C40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  _Unwind_Resume(a1);
}

uint64_t GPU::StencilOpHandler::kernelDAGOp(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 24) + 48);
  uint64_t v3 = *(void **)(v2 + 16);
  if (v3 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v16[0] = *(void *)(v2 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v16);
    if (v10 == 11 && *AttrData == 0x6E6574732E73706DLL && *(void *)((char *)AttrData + 3) == 0x6C69636E6574732ELL)
    {
      __int16 v15 = 1283;
      v14[0] = (uint64_t)"classof on '";
      v14[2] = (uint64_t)"mps.stencil";
      v14[3] = 11;
      uint64_t v12 = "' failed due to the operation not being registered";
      __int16 v13 = 259;
      llvm::operator+(v14, (uint64_t *)&v12, (uint64_t)v16);
      llvm::report_fatal_error((llvm::Twine *)v16, 1);
    }
LABEL_11:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v3 != &mlir::detail::TypeIDResolver<mlir::mps::StencilOp,void>::id) {
    goto LABEL_11;
  }
  v16[0] = *(void *)(a1 + 24);
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)v16);
  GPU::MPSGraphKernelDAG::getBaseTensorFromDataMap(a2, Input, 0);
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)v16);
  GPU::MPSGraphKernelDAG::getBaseTensorFromDataMap(a2, Filter, 0);
  uint64_t result = MPSKernelDAG::binaryCoreOp();
  *(void *)(a2 + 104) = *(void *)(a1 + 24);
  return result;
}

void GPU::StencilOpHandler::~StencilOpHandler(GPU::StencilOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);

  JUMPOUT(0x1852FDE70);
}

void GPU::MultiaryKernelOpHandler<GPU::StencilOpHandler,mlir::mps::StencilOp,MPSNDArrayStencilKernel,2ul>::~MultiaryKernelOpHandler(GPU::BaseOpHandler *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(a1);

  JUMPOUT(0x1852FDE70);
}

void sub_180D72160(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_180D721F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D724B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  _Unwind_Resume(a1);
}

uint64_t MPSSymbolTable::getLocationByInsertingOp<mlir::mps::SampleGridOp>(uint64_t a1, mlir::StringAttr **a2, uint64_t a3, unsigned int a4, void *a5)
{
  id v9 = a5;
  __int16 v28 = 260;
  v27[0] = a3;
  uint64_t StringAttr = mlir::Builder::getStringAttr(a2, (mlir::MLIRContext *)v27);
  uint64_t v11 = mlir::FileLineColLoc::get(StringAttr, a4, 0);
  if (!v11) {
    __assert_rtn("Location", "Location.h", 66, "loc && \"location should never be null.\"");
  }
  if (!v9)
  {
    HIBYTE(v26) = 15;
    qmemcpy(&__dst, "mps.sample_grid", 15);
    int v16 = &__dst.i8[15];
    goto LABEL_13;
  }
  uint64_t v12 = (const char *)[v9 UTF8String];
  size_t v13 = strlen(v12);
  if (v13 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v14 = v13;
  if (v13 >= 0x17)
  {
    uint64_t v17 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17) {
      uint64_t v17 = v13 | 7;
    }
    uint64_t v18 = v17 + 1;
    p_dst = (int8x16_t *)operator new(v17 + 1);
    __dst.i64[1] = v14;
    unint64_t v26 = v18 | 0x8000000000000000;
    __dst.i64[0] = (uint64_t)p_dst;
  }
  else
  {
    HIBYTE(v26) = v13;
    p_dst = &__dst;
    if (!v13) {
      goto LABEL_12;
    }
  }
  memmove(p_dst, v12, v14);
LABEL_12:
  int v16 = &p_dst->i8[v14];
LABEL_13:
  __int8 *v16 = 0;
  MPSSymbolTable::insertOpInSymbolTable(a1, &__dst, &__p);
  p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  char v20 = 1;
  HIBYTE(v28) = 1;
  if (p_p->__r_.__value_.__s.__data_[0])
  {
    v27[0] = p_p;
    char v20 = 3;
  }
  LOBYTE(v28) = v20;
  uint64_t v21 = mlir::Builder::getStringAttr(a2, (mlir::MLIRContext *)v27);
  uint64_t v22 = mlir::NameLoc::get(v21, v11);
  if (!v22) {
    __assert_rtn("Location", "Location.h", 66, "loc && \"location should never be null.\"");
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v26) & 0x80000000) == 0) {
      goto LABEL_20;
    }
LABEL_22:
    operator delete((void *)__dst.i64[0]);
    goto LABEL_20;
  }
  if (SHIBYTE(v26) < 0) {
    goto LABEL_22;
  }
LABEL_20:

  return v22;
}

void sub_180D72724(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if ((a21 & 0x80000000) == 0)
  {

    _Unwind_Resume(a1);
  }
  operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_180D72788(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D72B20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  _Unwind_Resume(a1);
}

void sub_180D72D28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_180D72FCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_180D731B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

EmitterObjC::Conv2DOpHandler *EmitterObjC::Conv2DOpHandler::Conv2DOpHandler(EmitterObjC::Conv2DOpHandler *this, id *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *(void *)this = &unk_1EC996D40;
  if (!a3) {
    __assert_rtn("dyn_cast", "Casting.h", 662, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
  }
  v103[0] = llvm::DefaultDoCastIfPossible<mlir::mps::Conv2DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::Conv2DOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)a3);
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)v103);
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)v103);
  uint64_t v5 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v103);
  uint64_t Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)v103);
  uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)v103);
  uint64_t Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)v103);
  Groups = mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)v103);
  int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)v103);
  long long v85 = Groups;
  uint64_t v86 = v5;
  uint64_t v83 = Filter;
  if (StorageType == 1)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v97, Strides, 0);
    uint64_t v16 = Strides;
    uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v94, v16, NumElements);
    unsigned int v18 = 0;
    uint64_t v11 = -1;
    uint64_t v88 = -1;
    while (1)
    {
      BOOL v19 = v97 == v94 && v98 == v95;
      if (v19 && v99 == v96) {
        break;
      }
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v97, (llvm::APInt *)&__p);
      int v20 = __p.__r_.__value_.__r.__words[1];
      if (LODWORD(__p.__r_.__value_.__r.__words[1]) < 0x41)
      {
        std::string::size_type v21 = __p.__r_.__value_.__r.__words[0];
LABEL_43:
        uint64_t v22 = v21;
        switch(v18)
        {
          case 0u:
            if (v21 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
              goto LABEL_52;
            }
            goto LABEL_55;
          case 1u:
            goto LABEL_56;
          case 2u:
            uint64_t v22 = v11;
            uint64_t v88 = v21;
            break;
          case 3u:
            if (v21 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
              goto LABEL_52;
            }
            goto LABEL_55;
          default:
            goto LABEL_51;
        }
        goto LABEL_56;
      }
      if (v20 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
      {
        std::string::size_type v21 = *(void *)__p.__r_.__value_.__l.__data_;
        if (v18 <= 3) {
          goto LABEL_43;
        }
      }
      else
      {
        std::string::size_type v21 = -1;
        if (v18 <= 3) {
          goto LABEL_43;
        }
      }
LABEL_51:
      if (MTLReportFailureTypeEnabled())
      {
LABEL_52:
        MTLReportFailure();
        uint64_t v22 = v11;
      }
      else
      {
LABEL_55:
        uint64_t v22 = v11;
      }
LABEL_56:
      if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41 && __p.__r_.__value_.__r.__words[0]) {
        MEMORY[0x1852FDE40](__p.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
      }
      ++v99;
      ++v18;
      uint64_t v11 = v22;
    }
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v97, InputAttributeNames, 0);
    uint64_t v37 = InputAttributeNames;
    uint64_t v38 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v94, v37, v38);
    unsigned int v39 = 0;
    uint64_t v23 = -1;
    uint64_t v24 = -1;
    while (1)
    {
      BOOL v40 = v97 == v94 && v98 == v95;
      if (v40 && v99 == v96) {
        break;
      }
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v97, (llvm::APInt *)&__p);
      int v41 = __p.__r_.__value_.__r.__words[1];
      if (LODWORD(__p.__r_.__value_.__r.__words[1]) < 0x41)
      {
        std::string::size_type v42 = __p.__r_.__value_.__r.__words[0];
LABEL_104:
        uint64_t v43 = v42;
        switch(v39)
        {
          case 0u:
            if (v42 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
              goto LABEL_113;
            }
            goto LABEL_116;
          case 1u:
            goto LABEL_117;
          case 2u:
            uint64_t v43 = v23;
            uint64_t v24 = v42;
            break;
          case 3u:
            if (v42 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
              goto LABEL_113;
            }
            goto LABEL_116;
          default:
            goto LABEL_112;
        }
        goto LABEL_117;
      }
      if (v41 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
      {
        std::string::size_type v42 = *(void *)__p.__r_.__value_.__l.__data_;
        if (v39 <= 3) {
          goto LABEL_104;
        }
      }
      else
      {
        std::string::size_type v42 = -1;
        if (v39 <= 3) {
          goto LABEL_104;
        }
      }
LABEL_112:
      if (MTLReportFailureTypeEnabled())
      {
LABEL_113:
        MTLReportFailure();
        uint64_t v43 = v23;
      }
      else
      {
LABEL_116:
        uint64_t v43 = v23;
      }
LABEL_117:
      if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41 && __p.__r_.__value_.__r.__words[0]) {
        MEMORY[0x1852FDE40](__p.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
      }
      ++v99;
      ++v39;
      uint64_t v23 = v43;
    }
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v97, Rewriter, 0);
    uint64_t v51 = Rewriter;
    uint64_t v52 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v94, v51, v52);
    int v53 = 0;
    uint64_t v25 = -1;
    uint64_t v26 = -1;
    uint64_t v27 = -1;
    uint64_t v28 = -1;
    while (1)
    {
      BOOL v54 = v97 == v94 && v98 == v95;
      if (v54 && v99 == v96) {
        goto LABEL_64;
      }
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v97, (llvm::APInt *)&__p);
      unsigned int v55 = __p.__r_.__value_.__r.__words[1];
      if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41)
      {
        if (v55 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
        {
          std::string::size_type v56 = *(void *)__p.__r_.__value_.__l.__data_;
          int v57 = v53 - 2;
        }
        else
        {
          std::string::size_type v56 = -1;
          int v57 = v53 - 2;
          if ((v53 - 2) > 3)
          {
LABEL_169:
            if (v55 >= 0x41)
            {
LABEL_170:
              if (__p.__r_.__value_.__r.__words[0]) {
                MEMORY[0x1852FDE40](__p.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
              }
            }
            goto LABEL_149;
          }
        }
      }
      else
      {
        std::string::size_type v56 = __p.__r_.__value_.__r.__words[0];
        int v57 = v53 - 2;
        if ((v53 - 2) > 3) {
          goto LABEL_169;
        }
      }
      switch(v57)
      {
        case 0:
          uint64_t v26 = v56;
          if (v55 >= 0x41) {
            goto LABEL_170;
          }
          break;
        case 1:
          uint64_t v25 = v56;
          if (v55 >= 0x41) {
            goto LABEL_170;
          }
          break;
        case 2:
          uint64_t v28 = v56;
          goto LABEL_169;
        case 3:
          uint64_t v27 = v56;
          if (v55 >= 0x41) {
            goto LABEL_170;
          }
          break;
        default:
          goto LABEL_169;
      }
LABEL_149:
      ++v99;
      ++v53;
    }
  }
  if (StorageType)
  {
    if (MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    uint64_t v11 = -1;
    uint64_t v88 = -1;
    uint64_t v23 = -1;
    uint64_t v24 = -1;
    uint64_t v25 = -1;
    uint64_t v26 = -1;
    uint64_t v27 = -1;
    uint64_t v28 = -1;
LABEL_64:
    uint64_t v29 = "MPSGraphTensorNamedDataLayoutNHWC";
    goto LABEL_175;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v97, Strides, 0);
  uint64_t v8 = Strides;
  uint64_t v9 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v94, v8, v9);
  unsigned int v10 = 0;
  uint64_t v11 = -1;
  uint64_t v88 = -1;
  while (1)
  {
    BOOL v12 = v97 == v94 && v98 == v95;
    if (v12 && v99 == v96) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v97, (llvm::APInt *)&__p);
    int v13 = __p.__r_.__value_.__r.__words[1];
    if (LODWORD(__p.__r_.__value_.__r.__words[1]) < 0x41)
    {
      std::string::size_type v14 = __p.__r_.__value_.__r.__words[0];
LABEL_14:
      uint64_t v15 = v14;
      switch(v10)
      {
        case 0u:
          if (v14 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
            goto LABEL_23;
          }
          goto LABEL_25;
        case 1u:
          if (v14 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
            goto LABEL_23;
          }
          goto LABEL_25;
        case 2u:
          goto LABEL_26;
        case 3u:
          uint64_t v15 = v11;
          uint64_t v88 = v14;
          if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41) {
            goto LABEL_27;
          }
          break;
        default:
          goto LABEL_22;
      }
      goto LABEL_5;
    }
    if (v13 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
    {
      std::string::size_type v14 = *(void *)__p.__r_.__value_.__l.__data_;
      if (v10 <= 3) {
        goto LABEL_14;
      }
    }
    else
    {
      std::string::size_type v14 = -1;
      if (v10 <= 3) {
        goto LABEL_14;
      }
    }
LABEL_22:
    if (MTLReportFailureTypeEnabled())
    {
LABEL_23:
      MTLReportFailure();
      uint64_t v15 = v11;
    }
    else
    {
LABEL_25:
      uint64_t v15 = v11;
    }
LABEL_26:
    if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41)
    {
LABEL_27:
      if (__p.__r_.__value_.__r.__words[0]) {
        MEMORY[0x1852FDE40](__p.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
      }
    }
LABEL_5:
    ++v99;
    ++v10;
    uint64_t v11 = v15;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v97, InputAttributeNames, 0);
  uint64_t v30 = InputAttributeNames;
  uint64_t v31 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v94, v30, v31);
  unsigned int v32 = 0;
  uint64_t v23 = -1;
  uint64_t v24 = -1;
  while (1)
  {
    BOOL v33 = v97 == v94 && v98 == v95;
    if (v33 && v99 == v96) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v97, (llvm::APInt *)&__p);
    int v34 = __p.__r_.__value_.__r.__words[1];
    if (LODWORD(__p.__r_.__value_.__r.__words[1]) < 0x41)
    {
      std::string::size_type v35 = __p.__r_.__value_.__r.__words[0];
LABEL_75:
      uint64_t v36 = v35;
      switch(v32)
      {
        case 0u:
          if (v35 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
            goto LABEL_84;
          }
          goto LABEL_86;
        case 1u:
          if (v35 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
            goto LABEL_84;
          }
          goto LABEL_86;
        case 2u:
          goto LABEL_87;
        case 3u:
          uint64_t v36 = v23;
          uint64_t v24 = v35;
          if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41) {
            goto LABEL_88;
          }
          break;
        default:
          goto LABEL_83;
      }
      goto LABEL_66;
    }
    if (v34 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
    {
      std::string::size_type v35 = *(void *)__p.__r_.__value_.__l.__data_;
      if (v32 <= 3) {
        goto LABEL_75;
      }
    }
    else
    {
      std::string::size_type v35 = -1;
      if (v32 <= 3) {
        goto LABEL_75;
      }
    }
LABEL_83:
    if (MTLReportFailureTypeEnabled())
    {
LABEL_84:
      MTLReportFailure();
      uint64_t v36 = v23;
    }
    else
    {
LABEL_86:
      uint64_t v36 = v23;
    }
LABEL_87:
    if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41)
    {
LABEL_88:
      if (__p.__r_.__value_.__r.__words[0]) {
        MEMORY[0x1852FDE40](__p.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
      }
    }
LABEL_66:
    ++v99;
    ++v32;
    uint64_t v23 = v36;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v97, Rewriter, 0);
  uint64_t v44 = Rewriter;
  uint64_t v45 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v94, v44, v45);
  int v46 = 0;
  uint64_t v25 = -1;
  uint64_t v26 = -1;
  uint64_t v27 = -1;
  uint64_t v28 = -1;
  while (1)
  {
    BOOL v47 = v97 == v94 && v98 == v95;
    if (v47 && v99 == v96) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v97, (llvm::APInt *)&__p);
    unsigned int v48 = __p.__r_.__value_.__r.__words[1];
    if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41)
    {
      if (v48 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
      {
        std::string::size_type v49 = *(void *)__p.__r_.__value_.__l.__data_;
        int v50 = v46 - 4;
      }
      else
      {
        std::string::size_type v49 = -1;
        int v50 = v46 - 4;
        if ((v46 - 4) > 3)
        {
LABEL_143:
          if (v48 >= 0x41)
          {
LABEL_144:
            if (__p.__r_.__value_.__r.__words[0]) {
              MEMORY[0x1852FDE40](__p.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
            }
          }
          goto LABEL_123;
        }
      }
    }
    else
    {
      std::string::size_type v49 = __p.__r_.__value_.__r.__words[0];
      int v50 = v46 - 4;
      if ((v46 - 4) > 3) {
        goto LABEL_143;
      }
    }
    switch(v50)
    {
      case 0:
        uint64_t v26 = v49;
        if (v48 >= 0x41) {
          goto LABEL_144;
        }
        break;
      case 1:
        uint64_t v25 = v49;
        if (v48 >= 0x41) {
          goto LABEL_144;
        }
        break;
      case 2:
        uint64_t v28 = v49;
        goto LABEL_143;
      case 3:
        uint64_t v27 = v49;
        if (v48 >= 0x41) {
          goto LABEL_144;
        }
        break;
      default:
        goto LABEL_143;
    }
LABEL_123:
    ++v99;
    ++v46;
  }
  uint64_t v29 = "MPSGraphTensorNamedDataLayoutNCHW";
LABEL_175:
  BOOL v81 = this;
  unsigned __int8 v82 = v29;
  __int16 v58 = NSString;
  (*((void (**)(uint64_t **__return_ptr))*a2 + 4))(&v97);
  if (v99 >= 0) {
    int v59 = &v97;
  }
  else {
    int v59 = (void **)v97;
  }
  unsigned int PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)v103);
  if (PaddingStyle >= 5)
  {
    if (MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    uint64_t v61 = 0;
  }
  else
  {
    uint64_t v61 = off_1E4FC11A0[PaddingStyle];
  }
  int WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)v103);
  if (WeightsLayout == 2)
  {
    BOOL v63 = "MPSGraphTensorNamedDataLayoutOIHW";
  }
  else if (WeightsLayout == 3)
  {
    BOOL v63 = "MPSGraphTensorNamedDataLayoutHWIO";
  }
  else
  {
    if (MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    BOOL v63 = 0;
  }
  objc_msgSend(v58, "stringWithFormat:", @"\n    MPSGraphConvolution2DOpDescriptor *%sConvDescriptor = \n    [MPSGraphConvolution2DOpDescriptor descriptorWithStrideInX:%ld\n                                                     strideInY:%ld\n                                               dilationRateInX:%ld\n                                               dilationRateInY:%ld\n                                                        groups:%ld\n                                                   paddingLeft:%ld\n                                                  paddingRight:%ld\n                                                    paddingTop:%ld\n                                                 paddingBottom:%ld\n                                                  paddingStyle:%s\n                                                    dataLayout:%s\n                                                 weightsLayout:%s];\n    ",
    v59,
    v88,
    v11,
    v24,
    v23,
    v85,
    v28,
    v27,
    v26,
    v25,
    v61,
    v82,
  uint64_t v64 = v63);
  if (SHIBYTE(v99) < 0) {
    operator delete(v97);
  }
  uint64_t v65 = [a2[27] stringByAppendingString:v64];
  id v66 = a2[27];
  a2[27] = (id)v65;

  uint64_t v67 = NSString;
  int v68 = &v97;
  (*((void (**)(uint64_t **__return_ptr, id *, uint64_t))*a2 + 4))(&v97, a2, v86);
  if (v99 < 0) {
    int v68 = (void **)v97;
  }
  uint64_t v93 = Input;
  long long v94 = &v93;
  int v69 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)(a2 + 32), &v93, (uint64_t)&std::piecewise_construct, &v94);
  uint64_t v70 = v69 + 3;
  if (*((char *)v69 + 47) < 0) {
    uint64_t v70 = (void *)*v70;
  }
  uint64_t v92 = v83;
  long long v94 = &v92;
  uint64_t v71 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)(a2 + 32), &v92, (uint64_t)&std::piecewise_construct, &v94);
  __int16 v72 = v71 + 3;
  if (*((char *)v71 + 47) < 0) {
    __int16 v72 = (void *)*v72;
  }
  (*((void (**)(uint64_t **__return_ptr, id *, uint64_t))*a2 + 4))(&v94, a2, v86);
  int v73 = SHIBYTE(v96);
  char v74 = v94;
  char v90 = 0;
  LOBYTE(v89) = 0;
  EmitObjC::emitTensorName((uint64_t)a2, v86, (uint64_t)&v89, &__p);
  unint64_t v75 = &v94;
  if (v73 < 0) {
    unint64_t v75 = (uint64_t **)v74;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  objc_msgSend(v67, "stringWithFormat:", @"\n    MPSGraphTensor *%s = \n    [graph convolution2DWithSourceTensor:%s\n                           weightsTensor:%s\n                              descriptor:%sConvDescriptor\n                                    name:%s];\n    ",
    v68,
    v70,
    v72,
    v75,
  unsigned int v77 = p_p);
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v90 & 0x80000000) == 0) {
      goto LABEL_207;
    }
LABEL_211:
    operator delete(v89);
    if (SHIBYTE(v96) < 0) {
      goto LABEL_212;
    }
LABEL_208:
    if ((SHIBYTE(v99) & 0x80000000) == 0) {
      goto LABEL_209;
    }
LABEL_213:
    operator delete(v97);
    goto LABEL_209;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (v90 < 0) {
    goto LABEL_211;
  }
LABEL_207:
  if ((SHIBYTE(v96) & 0x80000000) == 0) {
    goto LABEL_208;
  }
LABEL_212:
  operator delete(v94);
  if (SHIBYTE(v99) < 0) {
    goto LABEL_213;
  }
LABEL_209:
  uint64_t v78 = [a2[27] stringByAppendingString:v77];
  id v79 = a2[27];
  a2[27] = (id)v78;

  return v81;
}

void sub_180D740F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D74104(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  if (a41 < 0)
  {
    operator delete(__p);
    if (a35 < 0)
    {
LABEL_5:
      operator delete(a30);
      if ((*(char *)(v42 - 161) & 0x80000000) == 0) {
        goto LABEL_6;
      }
      goto LABEL_9;
    }
  }
  else if (a35 < 0)
  {
    goto LABEL_5;
  }
  if ((*(char *)(v42 - 161) & 0x80000000) == 0)
  {
LABEL_6:
    if (*(char *)(v42 - 129) < 0) {
      goto LABEL_7;
    }
    goto LABEL_10;
  }
LABEL_9:
  operator delete(*(void **)(v42 - 184));
  if (*(char *)(v42 - 129) < 0)
  {
LABEL_7:
    operator delete(*(void **)(v42 - 152));

    _Unwind_Resume(a1);
  }
LABEL_10:

  _Unwind_Resume(a1);
}

void sub_180D741C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,int a34)
{
  if (*(char *)(v34 - 129) < 0)
  {
    operator delete(*(void **)(v34 - 152));
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

EmitterObjC::Conv2DDataGradientOpHandler *EmitterObjC::Conv2DDataGradientOpHandler::Conv2DDataGradientOpHandler(EmitterObjC::Conv2DDataGradientOpHandler *this, id *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *(void *)this = &unk_1EC997340;
  if (!a3) {
    __assert_rtn("dyn_cast", "Casting.h", 662, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
  }
  v108[0] = llvm::DefaultDoCastIfPossible<mlir::mps::Conv2DDataGradientOp,mlir::Operation *,llvm::CastInfo<mlir::mps::Conv2DDataGradientOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)a3);
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)v108);
  uint64_t SplitSizes = mlir::mps::SplitOp::getSplitSizes((mlir::mps::SplitOp *)v108);
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)v108);
  uint64_t v6 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v108);
  uint64_t Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)v108);
  uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)v108);
  uint64_t Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)v108);
  Groups = mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)v108);
  int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)v108);
  int v89 = Groups;
  uint64_t v90 = v6;
  uint64_t v86 = SplitSizes;
  uint64_t v87 = Filter;
  if (StorageType == 1)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v102, Strides, 0);
    uint64_t v17 = Strides;
    uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v99, v17, NumElements);
    unsigned int v19 = 0;
    uint64_t v12 = -1;
    uint64_t v92 = -1;
    while (1)
    {
      BOOL v20 = v102 == v99 && v103 == v100;
      if (v20 && v104 == v101) {
        break;
      }
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v102, (llvm::APInt *)&__p);
      int v21 = __p.__r_.__value_.__r.__words[1];
      if (LODWORD(__p.__r_.__value_.__r.__words[1]) < 0x41)
      {
        std::string::size_type v22 = __p.__r_.__value_.__r.__words[0];
LABEL_43:
        uint64_t v23 = v22;
        switch(v19)
        {
          case 0u:
            if (v22 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
              goto LABEL_52;
            }
            goto LABEL_55;
          case 1u:
            goto LABEL_56;
          case 2u:
            uint64_t v23 = v12;
            uint64_t v92 = v22;
            break;
          case 3u:
            if (v22 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
              goto LABEL_52;
            }
            goto LABEL_55;
          default:
            goto LABEL_51;
        }
        goto LABEL_56;
      }
      if (v21 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
      {
        std::string::size_type v22 = *(void *)__p.__r_.__value_.__l.__data_;
        if (v19 <= 3) {
          goto LABEL_43;
        }
      }
      else
      {
        std::string::size_type v22 = -1;
        if (v19 <= 3) {
          goto LABEL_43;
        }
      }
LABEL_51:
      if (MTLReportFailureTypeEnabled())
      {
LABEL_52:
        MTLReportFailure();
        uint64_t v23 = v12;
      }
      else
      {
LABEL_55:
        uint64_t v23 = v12;
      }
LABEL_56:
      if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41 && __p.__r_.__value_.__r.__words[0]) {
        MEMORY[0x1852FDE40](__p.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
      }
      ++v104;
      ++v19;
      uint64_t v12 = v23;
    }
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v102, InputAttributeNames, 0);
    uint64_t v38 = InputAttributeNames;
    uint64_t v39 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v99, v38, v39);
    unsigned int v40 = 0;
    uint64_t v24 = -1;
    uint64_t v25 = -1;
    while (1)
    {
      BOOL v41 = v102 == v99 && v103 == v100;
      if (v41 && v104 == v101) {
        break;
      }
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v102, (llvm::APInt *)&__p);
      int v42 = __p.__r_.__value_.__r.__words[1];
      if (LODWORD(__p.__r_.__value_.__r.__words[1]) < 0x41)
      {
        std::string::size_type v43 = __p.__r_.__value_.__r.__words[0];
LABEL_104:
        uint64_t v44 = v43;
        switch(v40)
        {
          case 0u:
            if (v43 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
              goto LABEL_113;
            }
            goto LABEL_116;
          case 1u:
            goto LABEL_117;
          case 2u:
            uint64_t v44 = v24;
            uint64_t v25 = v43;
            break;
          case 3u:
            if (v43 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
              goto LABEL_113;
            }
            goto LABEL_116;
          default:
            goto LABEL_112;
        }
        goto LABEL_117;
      }
      if (v42 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
      {
        std::string::size_type v43 = *(void *)__p.__r_.__value_.__l.__data_;
        if (v40 <= 3) {
          goto LABEL_104;
        }
      }
      else
      {
        std::string::size_type v43 = -1;
        if (v40 <= 3) {
          goto LABEL_104;
        }
      }
LABEL_112:
      if (MTLReportFailureTypeEnabled())
      {
LABEL_113:
        MTLReportFailure();
        uint64_t v44 = v24;
      }
      else
      {
LABEL_116:
        uint64_t v44 = v24;
      }
LABEL_117:
      if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41 && __p.__r_.__value_.__r.__words[0]) {
        MEMORY[0x1852FDE40](__p.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
      }
      ++v104;
      ++v40;
      uint64_t v24 = v44;
    }
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v102, Rewriter, 0);
    uint64_t v52 = Rewriter;
    uint64_t v53 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v99, v52, v53);
    int v54 = 0;
    uint64_t v26 = -1;
    uint64_t v27 = -1;
    uint64_t v28 = -1;
    uint64_t v29 = -1;
    while (1)
    {
      BOOL v55 = v102 == v99 && v103 == v100;
      if (v55 && v104 == v101) {
        goto LABEL_64;
      }
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v102, (llvm::APInt *)&__p);
      unsigned int v56 = __p.__r_.__value_.__r.__words[1];
      if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41)
      {
        if (v56 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
        {
          std::string::size_type v57 = *(void *)__p.__r_.__value_.__l.__data_;
          int v58 = v54 - 2;
        }
        else
        {
          std::string::size_type v57 = -1;
          int v58 = v54 - 2;
          if ((v54 - 2) > 3)
          {
LABEL_169:
            if (v56 >= 0x41)
            {
LABEL_170:
              if (__p.__r_.__value_.__r.__words[0]) {
                MEMORY[0x1852FDE40](__p.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
              }
            }
            goto LABEL_149;
          }
        }
      }
      else
      {
        std::string::size_type v57 = __p.__r_.__value_.__r.__words[0];
        int v58 = v54 - 2;
        if ((v54 - 2) > 3) {
          goto LABEL_169;
        }
      }
      switch(v58)
      {
        case 0:
          uint64_t v27 = v57;
          if (v56 >= 0x41) {
            goto LABEL_170;
          }
          break;
        case 1:
          uint64_t v26 = v57;
          if (v56 >= 0x41) {
            goto LABEL_170;
          }
          break;
        case 2:
          uint64_t v29 = v57;
          goto LABEL_169;
        case 3:
          uint64_t v28 = v57;
          if (v56 >= 0x41) {
            goto LABEL_170;
          }
          break;
        default:
          goto LABEL_169;
      }
LABEL_149:
      ++v104;
      ++v54;
    }
  }
  if (StorageType)
  {
    if (MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    uint64_t v12 = -1;
    uint64_t v92 = -1;
    uint64_t v24 = -1;
    uint64_t v25 = -1;
    uint64_t v26 = -1;
    uint64_t v27 = -1;
    uint64_t v28 = -1;
    uint64_t v29 = -1;
LABEL_64:
    uint64_t v30 = "MPSGraphTensorNamedDataLayoutNHWC";
    goto LABEL_175;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v102, Strides, 0);
  uint64_t v9 = Strides;
  uint64_t v10 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v99, v9, v10);
  unsigned int v11 = 0;
  uint64_t v12 = -1;
  uint64_t v92 = -1;
  while (1)
  {
    BOOL v13 = v102 == v99 && v103 == v100;
    if (v13 && v104 == v101) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v102, (llvm::APInt *)&__p);
    int v14 = __p.__r_.__value_.__r.__words[1];
    if (LODWORD(__p.__r_.__value_.__r.__words[1]) < 0x41)
    {
      std::string::size_type v15 = __p.__r_.__value_.__r.__words[0];
LABEL_14:
      uint64_t v16 = v15;
      switch(v11)
      {
        case 0u:
          if (v15 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
            goto LABEL_23;
          }
          goto LABEL_25;
        case 1u:
          if (v15 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
            goto LABEL_23;
          }
          goto LABEL_25;
        case 2u:
          goto LABEL_26;
        case 3u:
          uint64_t v16 = v12;
          uint64_t v92 = v15;
          if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41) {
            goto LABEL_27;
          }
          break;
        default:
          goto LABEL_22;
      }
      goto LABEL_5;
    }
    if (v14 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
    {
      std::string::size_type v15 = *(void *)__p.__r_.__value_.__l.__data_;
      if (v11 <= 3) {
        goto LABEL_14;
      }
    }
    else
    {
      std::string::size_type v15 = -1;
      if (v11 <= 3) {
        goto LABEL_14;
      }
    }
LABEL_22:
    if (MTLReportFailureTypeEnabled())
    {
LABEL_23:
      MTLReportFailure();
      uint64_t v16 = v12;
    }
    else
    {
LABEL_25:
      uint64_t v16 = v12;
    }
LABEL_26:
    if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41)
    {
LABEL_27:
      if (__p.__r_.__value_.__r.__words[0]) {
        MEMORY[0x1852FDE40](__p.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
      }
    }
LABEL_5:
    ++v104;
    ++v11;
    uint64_t v12 = v16;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v102, InputAttributeNames, 0);
  uint64_t v31 = InputAttributeNames;
  uint64_t v32 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v99, v31, v32);
  unsigned int v33 = 0;
  uint64_t v24 = -1;
  uint64_t v25 = -1;
  while (1)
  {
    BOOL v34 = v102 == v99 && v103 == v100;
    if (v34 && v104 == v101) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v102, (llvm::APInt *)&__p);
    int v35 = __p.__r_.__value_.__r.__words[1];
    if (LODWORD(__p.__r_.__value_.__r.__words[1]) < 0x41)
    {
      std::string::size_type v36 = __p.__r_.__value_.__r.__words[0];
LABEL_75:
      uint64_t v37 = v36;
      switch(v33)
      {
        case 0u:
          if (v36 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
            goto LABEL_84;
          }
          goto LABEL_86;
        case 1u:
          if (v36 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0) {
            goto LABEL_84;
          }
          goto LABEL_86;
        case 2u:
          goto LABEL_87;
        case 3u:
          uint64_t v37 = v24;
          uint64_t v25 = v36;
          if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41) {
            goto LABEL_88;
          }
          break;
        default:
          goto LABEL_83;
      }
      goto LABEL_66;
    }
    if (v35 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
    {
      std::string::size_type v36 = *(void *)__p.__r_.__value_.__l.__data_;
      if (v33 <= 3) {
        goto LABEL_75;
      }
    }
    else
    {
      std::string::size_type v36 = -1;
      if (v33 <= 3) {
        goto LABEL_75;
      }
    }
LABEL_83:
    if (MTLReportFailureTypeEnabled())
    {
LABEL_84:
      MTLReportFailure();
      uint64_t v37 = v24;
    }
    else
    {
LABEL_86:
      uint64_t v37 = v24;
    }
LABEL_87:
    if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41)
    {
LABEL_88:
      if (__p.__r_.__value_.__r.__words[0]) {
        MEMORY[0x1852FDE40](__p.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
      }
    }
LABEL_66:
    ++v104;
    ++v33;
    uint64_t v24 = v37;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v102, Rewriter, 0);
  uint64_t v45 = Rewriter;
  uint64_t v46 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v99, v45, v46);
  int v47 = 0;
  uint64_t v26 = -1;
  uint64_t v27 = -1;
  uint64_t v28 = -1;
  uint64_t v29 = -1;
  while (1)
  {
    BOOL v48 = v102 == v99 && v103 == v100;
    if (v48 && v104 == v101) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v102, (llvm::APInt *)&__p);
    unsigned int v49 = __p.__r_.__value_.__r.__words[1];
    if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41)
    {
      if (v49 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
      {
        std::string::size_type v50 = *(void *)__p.__r_.__value_.__l.__data_;
        int v51 = v47 - 4;
      }
      else
      {
        std::string::size_type v50 = -1;
        int v51 = v47 - 4;
        if ((v47 - 4) > 3)
        {
LABEL_143:
          if (v49 >= 0x41)
          {
LABEL_144:
            if (__p.__r_.__value_.__r.__words[0]) {
              MEMORY[0x1852FDE40](__p.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
            }
          }
          goto LABEL_123;
        }
      }
    }
    else
    {
      std::string::size_type v50 = __p.__r_.__value_.__r.__words[0];
      int v51 = v47 - 4;
      if ((v47 - 4) > 3) {
        goto LABEL_143;
      }
    }
    switch(v51)
    {
      case 0:
        uint64_t v27 = v50;
        if (v49 >= 0x41) {
          goto LABEL_144;
        }
        break;
      case 1:
        uint64_t v26 = v50;
        if (v49 >= 0x41) {
          goto LABEL_144;
        }
        break;
      case 2:
        uint64_t v29 = v50;
        goto LABEL_143;
      case 3:
        uint64_t v28 = v50;
        if (v49 >= 0x41) {
          goto LABEL_144;
        }
        break;
      default:
        goto LABEL_143;
    }
LABEL_123:
    ++v104;
    ++v47;
  }
  uint64_t v30 = "MPSGraphTensorNamedDataLayoutNCHW";
LABEL_175:
  long long v84 = this;
  long long v85 = v30;
  int v59 = NSString;
  (*((void (**)(uint64_t **__return_ptr))*a2 + 4))(&v102);
  if (v104 >= 0) {
    __int16 v60 = &v102;
  }
  else {
    __int16 v60 = (void **)v102;
  }
  unsigned int PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)v108);
  if (PaddingStyle >= 5)
  {
    if (MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    uint64_t v62 = 0;
  }
  else
  {
    uint64_t v62 = off_1E4FC11A0[PaddingStyle];
  }
  int WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)v108);
  if (WeightsLayout == 2)
  {
    uint64_t v64 = "MPSGraphTensorNamedDataLayoutOIHW";
  }
  else if (WeightsLayout == 3)
  {
    uint64_t v64 = "MPSGraphTensorNamedDataLayoutHWIO";
  }
  else
  {
    if (MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    uint64_t v64 = 0;
  }
  objc_msgSend(v59, "stringWithFormat:", @"\n    MPSGraphConvolution2DOpDescriptor *%sConvDescriptor = \n    [MPSGraphConvolution2DOpDescriptor descriptorWithStrideInX:%ld\n                                                     strideInY:%ld\n                                               dilationRateInX:%ld\n                                               dilationRateInY:%ld\n                                                        groups:%ld\n                                                   paddingLeft:%ld\n                                                  paddingRight:%ld\n                                                    paddingTop:%ld\n                                                 paddingBottom:%ld\n                                                  paddingStyle:%s\n                                                    dataLayout:%s\n                                                 weightsLayout:%s];\n    ",
    v60,
    v92,
    v12,
    v25,
    v24,
    v89,
    v29,
    v28,
    v27,
    v26,
    v62,
    v85,
  uint64_t v65 = v64);
  if (SHIBYTE(v104) < 0) {
    operator delete(v102);
  }
  uint64_t v66 = [a2[27] stringByAppendingString:v65];
  id v67 = a2[27];
  a2[27] = (id)v66;

  int v68 = NSString;
  int v69 = &v102;
  (*((void (**)(uint64_t **__return_ptr, id *, uint64_t))*a2 + 4))(&v102, a2, v90);
  if (v104 < 0) {
    int v69 = (void **)v102;
  }
  uint64_t v98 = Input;
  uint64_t v99 = &v98;
  uint64_t v70 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)(a2 + 32), &v98, (uint64_t)&std::piecewise_construct, &v99);
  uint64_t v71 = v70 + 3;
  if (*((char *)v70 + 47) < 0) {
    uint64_t v71 = (void *)*v71;
  }
  uint64_t v97 = v87;
  uint64_t v99 = &v97;
  __int16 v72 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)(a2 + 32), &v97, (uint64_t)&std::piecewise_construct, &v99);
  int v73 = v72 + 3;
  if (*((char *)v72 + 47) < 0) {
    int v73 = (void *)*v73;
  }
  uint64_t v96 = v86;
  uint64_t v99 = &v96;
  char v74 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)(a2 + 32), &v96, (uint64_t)&std::piecewise_construct, &v99);
  unint64_t v75 = v74 + 3;
  if (*((char *)v74 + 47) < 0) {
    unint64_t v75 = (void *)*v75;
  }
  (*((void (**)(uint64_t **__return_ptr, id *, uint64_t))*a2 + 4))(&v99, a2, v90);
  int v76 = SHIBYTE(v101);
  unsigned int v77 = v99;
  char v94 = 0;
  LOBYTE(v93) = 0;
  EmitObjC::emitTensorName((uint64_t)a2, v90, (uint64_t)&v93, &__p);
  uint64_t v78 = &v99;
  if (v76 < 0) {
    uint64_t v78 = (uint64_t **)v77;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  objc_msgSend(v68, "stringWithFormat:", @"\n    MPSGraphTensor *%s = \n    [graph convolutionTranspose2DWithSourceTensor:%s\n                                    weightsTensor:%s\n                                outputShapeTensor:%s\n                                       descriptor:%sConvDescriptor\n                                             name:%s];\n    ",
    v69,
    v71,
    v73,
    v75,
    v78,
  uint64_t v80 = p_p);
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v94 & 0x80000000) == 0) {
      goto LABEL_209;
    }
LABEL_213:
    operator delete(v93);
    if (SHIBYTE(v101) < 0) {
      goto LABEL_214;
    }
LABEL_210:
    if ((SHIBYTE(v104) & 0x80000000) == 0) {
      goto LABEL_211;
    }
LABEL_215:
    operator delete(v102);
    goto LABEL_211;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (v94 < 0) {
    goto LABEL_213;
  }
LABEL_209:
  if ((SHIBYTE(v101) & 0x80000000) == 0) {
    goto LABEL_210;
  }
LABEL_214:
  operator delete(v99);
  if (SHIBYTE(v104) < 0) {
    goto LABEL_215;
  }
LABEL_211:
  uint64_t v81 = [a2[27] stringByAppendingString:v80];
  id v82 = a2[27];
  a2[27] = (id)v81;

  return v84;
}

void sub_180D751D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D751E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  if (a42 < 0)
  {
    operator delete(__p);
    if (a36 < 0)
    {
LABEL_5:
      operator delete(a31);
      if ((*(char *)(v43 - 161) & 0x80000000) == 0) {
        goto LABEL_6;
      }
      goto LABEL_9;
    }
  }
  else if (a36 < 0)
  {
    goto LABEL_5;
  }
  if ((*(char *)(v43 - 161) & 0x80000000) == 0)
  {
LABEL_6:
    if (*(char *)(v43 - 129) < 0) {
      goto LABEL_7;
    }
    goto LABEL_10;
  }
LABEL_9:
  operator delete(*(void **)(v43 - 184));
  if (*(char *)(v43 - 129) < 0)
  {
LABEL_7:
    operator delete(*(void **)(v43 - 152));

    _Unwind_Resume(a1);
  }
LABEL_10:

  _Unwind_Resume(a1);
}

void sub_180D752BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,int a35)
{
  if (*(char *)(v35 - 129) < 0)
  {
    operator delete(*(void **)(v35 - 152));
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

EmitterObjC::DepthwiseConv3DOpHandler *EmitterObjC::DepthwiseConv3DOpHandler::DepthwiseConv3DOpHandler(EmitterObjC::DepthwiseConv3DOpHandler *this, id *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *(void *)this = &unk_1EC997298;
  uint64_t v3 = *((void *)a3 + 6);
  uint64_t v4 = *(void **)(v3 + 16);
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v61[0] = *(void **)(v3 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v61);
    if (v40 == 21)
    {
      BOOL v41 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      if (v41 && *(void *)((char *)AttrData + 13) == 0x64335F766E6F635FLL)
      {
        __int16 v60 = 1283;
        v57[0] = "classof on '";
        int v58 = "mps.depthwise_conv_3d";
        uint64_t v59 = 21;
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)"' failed due to the operation not being registered";
        __int16 v56 = 259;
        llvm::operator+((uint64_t *)v57, (uint64_t *)&__p, (uint64_t)v61);
        llvm::report_fatal_error((llvm::Twine *)v61, 1);
      }
    }
LABEL_50:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id) {
    goto LABEL_50;
  }
  int v54 = a3;
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v54);
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v54);
  uint64_t v7 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v54);
  uint64_t Strides = (uint64_t *)mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v54);
  uint64_t InputAttributeNames = (uint64_t *)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v54);
  uint64_t Rewriter = (uint64_t *)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v54);
  uint64_t ChannelAxis = mlir::mps::DepthwiseConv3DDataGradientOp::getChannelAxis((mlir::mps::DepthwiseConv3DDataGradientOp *)&v54);
  uint64_t v45 = NSString;
  (*((void (**)(void **__return_ptr, id *, uint64_t))*a2 + 4))(v61, a2, v7);
  if (v62 >= 0) {
    uint64_t v9 = v61;
  }
  else {
    uint64_t v9 = (void **)v61[0];
  }
  uint64_t v10 = mlir::Attribute::cast<mlir::ElementsAttr>(&Strides);
  uint64_t v12 = EmitterObjC::elementsAttrToObjcArray((uint64_t)v10, v11);
  BOOL v13 = mlir::Attribute::cast<mlir::ElementsAttr>(&InputAttributeNames);
  std::string::size_type v15 = EmitterObjC::elementsAttrToObjcArray((uint64_t)v13, v14);
  uint64_t v16 = mlir::Attribute::cast<mlir::ElementsAttr>(&Rewriter);
  unsigned int v18 = EmitterObjC::elementsAttrToObjcArray((uint64_t)v16, v17);
  unsigned int PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v54);
  if (PaddingStyle >= 5)
  {
    if (MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    BOOL v20 = 0;
  }
  else
  {
    BOOL v20 = off_1E4FC11A0[PaddingStyle];
  }
  (*((void (**)(void **__return_ptr, id *, uint64_t))*a2 + 4))(v57, a2, v7);
  if (SHIBYTE(v58) >= 0) {
    int v21 = v57;
  }
  else {
    int v21 = (void **)v57[0];
  }
  objc_msgSend(v45, "stringWithFormat:", @"\n    MPSGraphDepthwiseConvolution3DOpDescriptor *%sDWConvDescriptor = \n    [MPSGraphDepthwiseConvolution3DOpDescriptor descriptorWithStrides:%@\n                                                        dilationRates:%@\n                                                        paddingValues:%@\n                                                         paddingStyle:%s];\n    %sDWConvDescriptor.channelDimensionIndex = %d;\n    ",
    v9,
    v12,
    v15,
    v18,
    v20,
    v21,
  uint64_t v22 = ChannelAxis);
  if (SHIBYTE(v58) < 0)
  {
    operator delete(v57[0]);

    if ((v62 & 0x80000000) == 0) {
      goto LABEL_17;
    }
  }
  else
  {

    if ((v62 & 0x80000000) == 0) {
      goto LABEL_17;
    }
  }
  operator delete(v61[0]);
LABEL_17:
  uint64_t v46 = (void *)v22;
  uint64_t v23 = [a2[27] stringByAppendingString:v22];
  id v24 = a2[27];
  a2[27] = (id)v23;

  uint64_t v25 = NSString;
  (*((void (**)(void **__return_ptr, id *, uint64_t))*a2 + 4))(v61, a2, v7);
  if (v62 >= 0) {
    uint64_t v26 = v61;
  }
  else {
    uint64_t v26 = (void **)v61[0];
  }
  uint64_t v50 = Input;
  v57[0] = &v50;
  uint64_t v27 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)(a2 + 32), &v50, (uint64_t)&std::piecewise_construct, v57);
  uint64_t v28 = v27 + 3;
  if (*((char *)v27 + 47) < 0) {
    uint64_t v28 = (void *)*v28;
  }
  uint64_t v49 = Filter;
  v57[0] = &v49;
  uint64_t v29 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)(a2 + 32), &v49, (uint64_t)&std::piecewise_construct, v57);
  uint64_t v30 = v29 + 3;
  if (*((char *)v29 + 47) < 0) {
    uint64_t v30 = (void *)*v30;
  }
  (*((void (**)(void **__return_ptr, id *, uint64_t))*a2 + 4))(v57, a2, v7);
  int v31 = SHIBYTE(v58);
  uint64_t v32 = v57[0];
  char v48 = 0;
  LOBYTE(v47) = 0;
  EmitObjC::emitTensorName((uint64_t)a2, v7, (uint64_t)&v47, &__p);
  unsigned int v33 = v57;
  if (v31 < 0) {
    unsigned int v33 = (void **)v32;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  objc_msgSend(v25, "stringWithFormat:", @"\n    MPSGraphTensor *%s = \n    [graph depthwiseConvolution3DWithSourceTensor:%s\n                                    weightsTensor:%s\n                                       descriptor:%sDWConvDescriptor\n                                             name:%s];\n    ",
    v26,
    v28,
    v30,
    v33,
  uint64_t v35 = p_p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((v48 & 0x80000000) == 0)
    {
LABEL_31:
      if ((SHIBYTE(v58) & 0x80000000) == 0) {
        goto LABEL_32;
      }
LABEL_38:
      operator delete(v57[0]);
      if ((v62 & 0x80000000) == 0) {
        goto LABEL_33;
      }
LABEL_39:
      operator delete(v61[0]);
      goto LABEL_33;
    }
  }
  else if ((v48 & 0x80000000) == 0)
  {
    goto LABEL_31;
  }
  operator delete(v47);
  if (SHIBYTE(v58) < 0) {
    goto LABEL_38;
  }
LABEL_32:
  if (v62 < 0) {
    goto LABEL_39;
  }
LABEL_33:
  uint64_t v36 = [a2[27] stringByAppendingString:v35];
  id v37 = a2[27];
  a2[27] = (id)v36;

  return this;
}

void sub_180D758F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  _Unwind_Resume(a1);
}

void sub_180D759B8(_Unwind_Exception *a1)
{
  if (*(char *)(v4 - 145) < 0) {
    operator delete(*(void **)(v4 - 168));
  }

  if (*(char *)(v4 - 105) < 0) {
    operator delete(*(void **)(v4 - 128));
  }
  _Unwind_Resume(a1);
}

id EmitterObjC::elementsAttrToObjcArray(uint64_t a1, uint64_t a2)
{
  uint64_t v16[4] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = v16;
  uint64_t v15 = 0x400000000;
  *(float *)&double v2 = mlir::getIntValues<long long>(a1, a2, (uint64_t)&v14, 1);
  uint64_t v3 = v15;
  if (v15)
  {
    uint64_t v4 = (char *)v14;
    uint64_t v5 = objc_msgSend(@"@[", "stringByAppendingFormat:", @"@%ld", v2, *(void *)v14);
    uint64_t v6 = (void *)v5;
    if (v3 == 1)
    {
      uint64_t v7 = (__CFString *)v5;
    }
    else
    {
      uint64_t v8 = (uint64_t *)(v4 + 8);
      uint64_t v9 = 8 * v3 - 8;
      do
      {
        uint64_t v10 = *v8;
        uint64_t v11 = [v6 stringByAppendingString:@", "];

        objc_msgSend(v11, "stringByAppendingFormat:", @"@%ld", v10);
        uint64_t v7 = (__CFString *)objc_claimAutoreleasedReturnValue();

        ++v8;
        uint64_t v6 = v7;
        v9 -= 8;
      }
      while (v9);
    }
  }
  else
  {
    uint64_t v7 = @"@[";
  }
  uint64_t v12 = [(__CFString *)v7 stringByAppendingString:@"]"];

  if (v14 != v16) {
    free(v14);
  }

  return v12;
}

{
  double v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  void *v6;
  __CFString *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v14;
  uint64_t v15;
  void v16[5];
  uint64_t vars8;

  uint64_t v16[4] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = v16;
  uint64_t v15 = 0x400000000;
  *(float *)&double v2 = mlir::getIntValues<long long>(a1, a2, (uint64_t)&v14, 1);
  uint64_t v3 = v15;
  if (v15)
  {
    uint64_t v4 = (char *)v14;
    uint64_t v5 = objc_msgSend(@"@[", "stringByAppendingFormat:", @"@%ld", v2, *(void *)v14);
    uint64_t v6 = (void *)v5;
    if (v3 == 1)
    {
      uint64_t v7 = (__CFString *)v5;
    }
    else
    {
      uint64_t v8 = (uint64_t *)(v4 + 8);
      uint64_t v9 = 8 * v3 - 8;
      do
      {
        uint64_t v10 = *v8;
        uint64_t v11 = [v6 stringByAppendingString:@", "];

        objc_msgSend(v11, "stringByAppendingFormat:", @"@%ld", v10);
        uint64_t v7 = (__CFString *)objc_claimAutoreleasedReturnValue();

        ++v8;
        uint64_t v6 = v7;
        v9 -= 8;
      }
      while (v9);
    }
  }
  else
  {
    uint64_t v7 = @"@[";
  }
  uint64_t v12 = [(__CFString *)v7 stringByAppendingString:@"]"];

  if (v14 != v16) {
    free(v14);
  }

  return v12;
}

void sub_180D75B98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  if (a10 != v10)
  {
    free(a10);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void __mpsGraphLazyInit(void)
{
  if (__mpsGraphLazyInit(void)::once != -1) {
    dispatch_once_f(&__mpsGraphLazyInit(void)::once, 0, (dispatch_function_t)static_init);
  }
}

uint64_t static_init(uint64_t result)
{
  unsigned int v1 = &dword_18102515C;
  unint64_t v2 = ((char *)&OBJC_CLASS_METHODS_MPSGraph - (char *)&dword_18102515C) >> 2;
  if (v2)
  {
    if (v2 <= 1) {
      int64_t v3 = 1;
    }
    else {
      int64_t v3 = ((char *)&OBJC_CLASS_METHODS_MPSGraph - (char *)&dword_18102515C) >> 2;
    }
    do
    {
      unsigned int v4 = *v1++;
      uint64_t result = ((uint64_t (*)(uint64_t))((char *)&dword_180159000 + v4))(result);
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t MILToMLIR::SingleGateRNNPattern::matchAndRewrite(MILToMLIR::SingleGateRNNPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v111 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v6 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "initial_h");
  OptionalArguint64_t Value = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "bias");
  uint64_t v100 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "weight_ih");
  uint64_t v7 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "weight_hh");
  uint64_t v8 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 160))(a2);
  v99[0] = 0;
  v99[1] = 0;
  uint64_t v98 = v99;
  uint64_t v9 = v8 + 1;
  uint64_t v10 = *v8;
  if (*v8 != (const void **)(v8 + 1))
  {
    do
    {
      std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&v98, (uint64_t *)v99, v10 + 4, (uint64_t)(v10 + 4));
      BOOL v20 = (const void **)v10[1];
      if (v20)
      {
        do
        {
          int v21 = (const void ***)v20;
          BOOL v20 = (const void **)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          int v21 = (const void ***)v10[2];
          BOOL v40 = *v21 == v10;
          uint64_t v10 = (const void **)v21;
        }
        while (!v40);
      }
      uint64_t v10 = (const void **)v21;
    }
    while (v21 != v9);
  }
  char v110 = 9;
  strcpy((char *)__p, "direction");
  MIL::IROperation::TryGetParameterValue();
  MIL::IRValue::GetScalar<std::string>();
  if (v110 < 0) {
    operator delete(__p[0]);
  }
  char v110 = 10;
  strcpy((char *)__p, "activation");
  MIL::IROperation::TryGetParameterValue();
  MIL::IRValue::GetScalar<std::string>();
  if (v110 < 0) {
    operator delete(__p[0]);
  }
  char v110 = 15;
  strcpy((char *)__p, "output_sequence");
  MIL::IROperation::TryGetParameterValue();
  int v11 = MIL::IRValue::GetScalar<BOOL>();
  if (v110 < 0) {
    operator delete(__p[0]);
  }
  uint64_t v94 = 0;
  uint64_t v12 = operator new(4uLL);
  *uint64_t v12 = 1;
  __p[0] = (void *)1;
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 18), 0x20u, 1);
  uint64_t v14 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)__p, 1, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v14)) {
    goto LABEL_101;
  }
  if (v14)
  {
    uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v14);
    if (!InterfaceFor)
    {
      uint64_t v16 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v17 = 98;
      unsigned int v18 = "InterfaceSupport.h";
      unsigned int v19 = "Interface";
      goto LABEL_105;
    }
  }
  else
  {
    uint64_t InterfaceFor = 0;
  }
  uint64_t v22 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v14, InterfaceFor, v12, 4, 4, 1, 1);
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)v22))
  {
LABEL_101:
    uint64_t v16 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v17 = 566;
    unsigned int v18 = "Casting.h";
    unsigned int v19 = "cast";
    goto LABEL_105;
  }
  __p[0] = v22;
  uint64_t v23 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)__p);
  if (!*((_DWORD *)v23 + 9))
  {
    uint64_t v16 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    int v17 = 984;
    unsigned int v18 = "Operation.h";
    unsigned int v19 = "getOpResultImpl";
LABEL_105:
    __assert_rtn(v19, v18, v17, v16);
  }
  uint64_t v94 = (uint64_t)v23 - 16;
  operator delete(v12);
  id v24 = (void *)(*(void *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v24)
  {
    uint64_t v83 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v84 = 650;
    long long v85 = "Casting.h";
    uint64_t v86 = "dyn_cast";
    goto LABEL_108;
  }
  if (!*(void *)v24)
  {
    uint64_t v83 = "abstractType && \"Malformed type storage object.\"";
    int v84 = 160;
    long long v85 = "TypeSupport.h";
    uint64_t v86 = "getAbstractType";
LABEL_108:
    __assert_rtn(v86, v85, v84, v83);
  }
  if (*(_UNKNOWN **)(*(void *)v24 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    id v24 = 0;
  }
  __p[0] = v24;
  uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)__p);
  if (v26 <= 1) {
    __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
  }
  uint64_t v27 = *(void *)(Value + 8);
  if (v27 == 1)
  {
    uint64_t v28 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue, &v94);
    if (!*(_DWORD *)(v28 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    Arguint64_t Value = v28 - 16;
  }
  LOBYTE(__p[0]) = 0;
  LOBYTE(v108[0]) = 1;
  uint64_t v29 = mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value &,mlir::Value &,BOOL,BOOL>(a3 + 18, LocationForOp, &ArgValue, &v100, (unsigned __int8 *)__p, (unsigned __int8 *)v108);
  uint64_t v93 = v29;
  if (!*(_DWORD *)(v29 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v92 = v29 - 16;
  if (OptionalArgValue)
  {
    uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(OptionalArgValue);
    if (!*(_DWORD *)(v93 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    if (ElementTypeOrSelf != mlir::getElementTypeOrSelf(v93 - 16))
    {
      if (!*(_DWORD *)(v93 + 36)
        || (uint64_t v31 = mlir::getElementTypeOrSelf(v93 - 16),
            __p[0] = (void *)mlir::TypeAttr::get(v31),
            uint64_t v32 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, &OptionalArgValue, (uint64_t *)__p), !*((_DWORD *)v32 + 9)))
      {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
      OptionalArguint64_t Value = (uint64_t)v32 - 16;
    }
    uint64_t v33 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::mps::MatMulOp &,mlir::Value &>(a3 + 18, LocationForOp, (uint64_t)&v93, &OptionalArgValue);
    if (!*(_DWORD *)(v33 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v92 = v33 - 16;
  }
  if (v27 == 1)
  {
    BOOL v34 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &v92, &v94);
    if (!*((_DWORD *)v34 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v92 = (uint64_t)v34 - 16;
  }
  if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v91, v95.__r_.__value_.__l.__data_, v95.__r_.__value_.__l.__size_);
  }
  else {
    std::string v91 = v95;
  }
  unsigned int v35 = MILToMLIR::activationStringToAttr((uint64_t)&v91, 1u);
  if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v91.__r_.__value_.__l.__data_);
    int v36 = v97;
    if ((v97 & 0x80000000) == 0) {
      goto LABEL_47;
    }
LABEL_50:
    if (v96[1] != (void *)7) {
      goto LABEL_65;
    }
    id v37 = (void **)v96[0];
    goto LABEL_52;
  }
  int v36 = v97;
  if (v97 < 0) {
    goto LABEL_50;
  }
LABEL_47:
  if (v36 != 7) {
    goto LABEL_65;
  }
  id v37 = v96;
LABEL_52:
  int v38 = *(_DWORD *)v37;
  int v39 = *(_DWORD *)((char *)v37 + 3);
  BOOL v40 = v38 == 1702258034 && v39 == 1702064741;
  if (!v40) {
    goto LABEL_65;
  }
  BOOL v41 = operator new(4uLL);
  _DWORD *v41 = 0;
  __p[0] = (void *)1;
  uint64_t v42 = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 18), 0x20u, 1);
  uint64_t v43 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)__p, 1, v42, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v43)) {
    goto LABEL_123;
  }
  if (v43)
  {
    uint64_t v44 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v43);
    if (!v44)
    {
      uint64_t v45 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v46 = 98;
      int v47 = "InterfaceSupport.h";
      char v48 = "Interface";
      goto LABEL_124;
    }
  }
  else
  {
    uint64_t v44 = 0;
  }
  uint64_t v49 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v43, v44, v41, 4, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v49) & 1) == 0)
  {
LABEL_123:
    uint64_t v45 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v46 = 566;
    int v47 = "Casting.h";
    char v48 = "cast";
LABEL_124:
    __assert_rtn(v48, v47, v46, v45);
  }
  v108[0] = v49;
  __p[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, v108);
  uint64_t v50 = mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &v92, (uint64_t)__p);
  if (!*(_DWORD *)(v50 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v92 = v50 - 16;
  operator delete(v41);
LABEL_65:
  char v103 = (mlir::GenericProgramPoint *)LocationForOp;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v103);
  uint64_t v52 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.singlegate_rnn", (const unsigned __int8 *)0x12, Context);
  if (!v53)
  {
    __int16 v107 = 1283;
    v106[2] = (uint64_t)"mps.singlegate_rnn";
    v106[3] = 18;
                       "been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-"
                       "dependent-whats-up-with-dialects-management";
    __int16 v105 = 259;
    llvm::operator+(v106, v104, (uint64_t)v108);
    llvm::report_fatal_error((llvm::Twine *)v108, 1);
  }
  mlir::OperationState::OperationState(__p, LocationForOp, v52);
  mlir::mps::SingleGateRNNOp::build(a3 + 18, (uint64_t)__p, v92, v7, v35, 0, v6, 0);
  int v54 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)__p);
  if (!v54)
  {
    uint64_t v87 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v88 = 662;
    int v89 = "Casting.h";
    uint64_t v90 = "dyn_cast";
    goto LABEL_114;
  }
  uint64_t v55 = llvm::DefaultDoCastIfPossible<mlir::mps::SingleGateRNNOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SingleGateRNNOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v54);
  if (!v55)
  {
    uint64_t v87 = "result && \"builder didn't return the right type\"";
    int v88 = 497;
    int v89 = "Builders.h";
    uint64_t v90 = "create";
LABEL_114:
    __assert_rtn(v90, v89, v88, v87);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)__p);
  if (!*(_DWORD *)(v55 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v56 = v55 - 16;
  v106[0] = v55 - 16;
  LODWORD(__p[0]) = 0;
  LODWORD(v108[0]) = -1;
  LODWORD(v103) = 1;
  uint64_t v57 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,int>((mlir::mps::ConstantOp *)(a3 + 18), LocationForOp, v106, (unsigned int *)__p, (unsigned int *)v108, (unsigned int *)&v103);
  if (!*(_DWORD *)(v57 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  v104[0] = v57 - 16;
  int v58 = operator new(4uLL);
  *int v58 = 0;
  __p[0] = (void *)1;
  uint64_t v59 = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 18), 0x20u, 1);
  __int16 v60 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)__p, 1, v59, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v60)) {
    goto LABEL_102;
  }
  if (v60)
  {
    uint64_t v61 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v60);
    if (!v61)
    {
      char v62 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v63 = 98;
      uint64_t v64 = "InterfaceSupport.h";
      uint64_t v65 = "Interface";
      goto LABEL_103;
    }
  }
  else
  {
    uint64_t v61 = 0;
  }
  uint64_t v66 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v60, v61, v58, 4, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v66) & 1) == 0)
  {
LABEL_102:
    char v62 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v63 = 566;
    uint64_t v64 = "Casting.h";
    uint64_t v65 = "cast";
LABEL_103:
    __assert_rtn(v65, v64, v63, v62);
  }
  __p[0] = v66;
  char v103 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)__p);
  id v67 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, v104, &v103);
  if (!*((_DWORD *)v67 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  if (v11) {
    uint64_t v68 = v56;
  }
  else {
    uint64_t v68 = v104[0];
  }
  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(__p, a2);
  int v69 = (uint64_t *)__p[0];
  uint64_t v70 = (char *)operator new(8uLL);
  *(void *)uint64_t v70 = v68;
  uint64_t v71 = (char *)(a3 + 8);
  v108[0] = v69;
  __int16 v72 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v71, (uint64_t)v69, (uint64_t)&std::piecewise_construct, (long long **)v108);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v72 + 5, v70, v70 + 8, 1uLL);
  operator delete(v70);
  int v73 = (void **)__p[0];
  if (__p[0])
  {
    char v74 = (void **)__p[1];
    unint64_t v75 = __p[0];
    if (__p[1] != __p[0])
    {
      do
      {
        if (*((char *)v74 - 1) < 0) {
          operator delete(*(v74 - 3));
        }
        v74 -= 3;
      }
      while (v74 != v73);
      unint64_t v75 = __p[0];
    }
    __p[1] = v73;
    operator delete(v75);
  }
  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(__p, a2);
  int v76 = (char *)__p[0];
  unsigned int v77 = (char *)operator new(8uLL);
  *(void *)unsigned int v77 = (char *)v67 - 16;
  v108[0] = (uint64_t *)(v76 + 24);
  uint64_t v78 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v71, (uint64_t)(v76 + 24), (uint64_t)&std::piecewise_construct, (long long **)v108);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v78 + 5, v77, v77 + 8, 1uLL);
  operator delete(v77);
  id v79 = (void **)__p[0];
  if (__p[0])
  {
    uint64_t v80 = (void **)__p[1];
    uint64_t v81 = __p[0];
    if (__p[1] != __p[0])
    {
      do
      {
        if (*((char *)v80 - 1) < 0) {
          operator delete(*(v80 - 3));
        }
        v80 -= 3;
      }
      while (v80 != v79);
      uint64_t v81 = __p[0];
    }
    __p[1] = v79;
    operator delete(v81);
  }
  operator delete(v58);
  if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v95.__r_.__value_.__l.__data_);
    if ((v97 & 0x80000000) == 0) {
      goto LABEL_98;
    }
LABEL_100:
    operator delete(v96[0]);
    goto LABEL_98;
  }
  if (v97 < 0) {
    goto LABEL_100;
  }
LABEL_98:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v98, v99[0]);
  return 1;
}

void sub_180D76954(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28,char *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a28, a29);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v24[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.squeeze", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.squeeze";
    v21[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  mlir::mps::SqueezeOp::build((uint64_t)a1, (uint64_t)v24, *a3, *a4);
  int v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    uint64_t v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v15 = 662;
    uint64_t v16 = "Casting.h";
    int v17 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::SqueezeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SqueezeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    uint64_t v14 = "result && \"builder didn't return the right type\"";
    int v15 = 497;
    uint64_t v16 = "Builders.h";
    int v17 = "create";
LABEL_8:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180D76C54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D76C6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::AddOp,mlir::mps::MatMulOp &,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  v24[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.add";
    v21[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(void *)a3 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *(void *)a3 - 16, *a4);
  int v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    uint64_t v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v15 = 662;
    uint64_t v16 = "Casting.h";
    int v17 = "dyn_cast";
    goto LABEL_10;
  }
  uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::AddOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AddOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    uint64_t v14 = "result && \"builder didn't return the right type\"";
    int v15 = 497;
    uint64_t v16 = "Builders.h";
    int v17 = "create";
LABEL_10:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180D76E2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D76E44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t MILToMLIR::activationStringToAttr(uint64_t a1, unsigned __int8 a2)
{
  unint64_t v2 = (int *)a1;
  int v3 = *(char *)(a1 + 23);
  if (v3 < 0)
  {
    uint64_t result = 0;
    uint64_t v5 = *((void *)v2 + 1);
    switch(v5)
    {
      case 4:
        uint64_t v6 = *(int **)v2;
        if (*v6 == 1970038130)
        {
LABEL_21:
          uint64_t result = 1;
        }
        else
        {
          if (*v6 != 1752064372) {
            goto LABEL_47;
          }
          uint64_t result = 2;
        }
        break;
      case 6:
        int v11 = *(int **)v2;
        int v12 = *v11;
        int v13 = *((unsigned __int16 *)v11 + 2);
        if (v12 != 1701734764 || v13 != 29281) {
          goto LABEL_47;
        }
        uint64_t result = 0;
        break;
      case 7:
        if (**(_DWORD **)v2 == 1835493747 && *(_DWORD *)(*(void *)v2 + 3) == 1684631405)
        {
LABEL_42:
          uint64_t result = 3;
        }
        else
        {
          if (v5 == 12) {
            goto LABEL_33;
          }
LABEL_20:
          uint64_t result = 0;
        }
        break;
      case 11:
        uint64_t v19 = **(void **)v2 ^ 0x745F64656C616373 | *(void *)(*(void *)v2 + 3) ^ 0x686E61745F64656CLL;
        if (((v19 == 0) & a2) != 0) {
          uint64_t result = 2;
        }
        else {
          uint64_t result = 5;
        }
        if (v19) {
LABEL_47:
        }
          uint64_t result = 0;
        break;
      case 12:
LABEL_33:
        unint64_t v2 = *(int **)v2;
LABEL_34:
        unint64_t v16 = 0x686172645F736967;
        unint64_t v17 = bswap64(*(void *)v2);
        if (v17 == 0x686172645F736967 && (unint64_t v16 = 1836018020, v17 = bswap32(v2[2]), v17 == 1836018020))
        {
          int v18 = 0;
        }
        else if (v17 < v16)
        {
          int v18 = -1;
        }
        else
        {
          int v18 = 1;
        }
        uint64_t result = 4 * (v18 == 0);
        break;
      default:
        return result;
    }
  }
  else
  {
    uint64_t result = 0;
    switch((char)v3)
    {
      case 4:
        if (*v2 == 1970038130) {
          goto LABEL_21;
        }
        if (*v2 != 1752064372) {
          goto LABEL_20;
        }
        uint64_t result = 2;
        break;
      case 7:
        int v7 = *v2;
        int v8 = *(int *)((char *)v2 + 3);
        if (v7 != 1835493747 || v8 != 1684631405) {
          goto LABEL_20;
        }
        goto LABEL_42;
      case 11:
        uint64_t v10 = *(void *)v2 ^ 0x745F64656C616373 | *(void *)((char *)v2 + 3) ^ 0x686E61745F64656CLL;
        if (((v10 == 0) & a2) != 0) {
          uint64_t result = 2;
        }
        else {
          uint64_t result = 5;
        }
        if (v10) {
          goto LABEL_20;
        }
        return result;
      case 12:
        goto LABEL_34;
      default:
        return result;
    }
  }
  return result;
}

uint64_t mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,int>(mlir::mps::ConstantOp *a1, uint64_t a2, uint64_t *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6)
{
  v28[38] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.slice", (const unsigned __int8 *)9, Context);
  if (!v14)
  {
    __int16 v26 = 1283;
    v25[2] = (uint64_t)"mps.slice";
    v25[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v28, a2, v13);
  mlir::mps::SliceOp::build(a1, v28, *a3, *a4, *a5, *a6);
  int v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v28);
  if (!v15)
  {
    int v18 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v19 = 662;
    __int16 v20 = "Casting.h";
    int v21 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v16 = llvm::DefaultDoCastIfPossible<mlir::mps::SliceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SliceOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
  if (!v16)
  {
    int v18 = "result && \"builder didn't return the right type\"";
    int v19 = 497;
    __int16 v20 = "Builders.h";
    int v21 = "create";
LABEL_8:
    __assert_rtn(v21, v20, v19, v18);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v28);
  return v16;
}

void sub_180D772B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D772CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t MILToMLIR::LSTMPattern::matchAndRewrite(MILToMLIR::LSTMPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v233 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v221 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "initial_h");
  uint64_t v220 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "initial_c");
  OptionalArguint64_t Value = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "bias");
  uint64_t v218 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "weight_ih");
  uint64_t v217 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "weight_hh");
  uint64_t v216 = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "peephole");
  uint64_t v215 = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "clip");
  uint64_t v6 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 160))(a2);
  v214[0] = 0;
  v214[1] = 0;
  uint64_t v213 = v214;
  int v7 = v6 + 1;
  int v8 = *v6;
  if (*v6 != (const void **)(v6 + 1))
  {
    do
    {
      std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&v213, (uint64_t *)v214, v8 + 4, (uint64_t)(v8 + 4));
      int v12 = (const void **)v8[1];
      if (v12)
      {
        do
        {
          uint64_t v13 = (const void ***)v12;
          int v12 = (const void **)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          uint64_t v13 = (const void ***)v8[2];
          BOOL v16 = *v13 == v8;
          int v8 = (const void **)v13;
        }
        while (!v16);
      }
      int v8 = (const void **)v13;
    }
    while (v13 != v7);
  }
  HIBYTE(v231[2]) = 9;
  strcpy((char *)v231, "direction");
  MIL::IROperation::TryGetParameterValue();
  MIL::IRValue::GetScalar<std::string>();
  if (SHIBYTE(v231[2]) < 0) {
    operator delete(v231[0]);
  }
  HIBYTE(v231[2]) = 10;
  strcpy((char *)v231, "activation");
  MIL::IROperation::TryGetParameterValue();
  MIL::IRValue::GetScalar<std::string>();
  if (SHIBYTE(v231[2]) < 0) {
    operator delete(v231[0]);
  }
  HIBYTE(v231[2]) = 20;
  strcpy((char *)v231, "recurrent_activation");
  MIL::IROperation::TryGetParameterValue();
  MIL::IRValue::GetScalar<std::string>();
  if (SHIBYTE(v231[2]) < 0) {
    operator delete(v231[0]);
  }
  HIBYTE(v231[2]) = 15;
  strcpy((char *)v231, "cell_activation");
  MIL::IROperation::TryGetParameterValue();
  MIL::IRValue::GetScalar<std::string>();
  if (SHIBYTE(v231[2]) < 0) {
    operator delete(v231[0]);
  }
  HIBYTE(v231[2]) = 15;
  strcpy((char *)v231, "output_sequence");
  MIL::IROperation::TryGetParameterValue();
  char v181 = MIL::IRValue::GetScalar<BOOL>();
  if (SHIBYTE(v231[2]) < 0)
  {
    operator delete(v231[0]);
    uint64_t v9 = (uint64_t *)(a3 + 18);
    int v10 = v212;
    if ((v212 & 0x80000000) == 0)
    {
LABEL_12:
      if (v10 == 13)
      {
        int v11 = (void **)&v210;
LABEL_24:
        char v14 = *v11;
        uint64_t v15 = *(uint64_t *)((char *)v11 + 5);
        BOOL v16 = v14 == (void *)0x7463657269646962 && v15 == 0x6C616E6F69746365;
        int v17 = v16;
        int __p = v17;
        goto LABEL_32;
      }
      goto LABEL_31;
    }
  }
  else
  {
    uint64_t v9 = (uint64_t *)(a3 + 18);
    int v10 = v212;
    if ((v212 & 0x80000000) == 0) {
      goto LABEL_12;
    }
  }
  if (v211 == 13)
  {
    int v11 = v210;
    goto LABEL_24;
  }
LABEL_31:
  int __p = 0;
LABEL_32:
  uint64_t v205 = 0;
  uint64_t v206 = 0;
  uint64_t v203 = 0;
  uint64_t v204 = 0;
  uint64_t v202 = 0;
  uint64_t v18 = mlir::IntegerType::get(*v9, 0x20u, 1u);
  int v19 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v18, 0);
  v231[0] = (uint64_t *)mlir::mps::getConstantAttr<int>(v19, 0);
  __int16 v20 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v9, LocationForOp, v231);
  if (!*((_DWORD *)v20 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v201 = (uint64_t)v20 - 16;
  uint64_t v21 = mlir::IntegerType::get(*v9, 0x20u, 1u);
  uint64_t v22 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v21, 0);
  v231[0] = (uint64_t *)mlir::mps::getConstantAttr<int>(v22, -1);
  uint64_t v23 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v9, LocationForOp, v231);
  if (!*((_DWORD *)v23 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v199 = 0;
  uint64_t v200 = (uint64_t)v23 - 16;
  uint64_t v198 = 0;
  __int16 v24 = operator new(4uLL);
  *__int16 v24 = 0;
  v231[0] = (uint64_t *)1;
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)v9, 0x20u, 1);
  __int16 v26 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)v231, 1, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v26)) {
    goto LABEL_223;
  }
  if (v26)
  {
    uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v26);
    if (!InterfaceFor)
    {
      uint64_t v28 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v29 = 98;
      uint64_t v30 = "InterfaceSupport.h";
      uint64_t v31 = "Interface";
      goto LABEL_230;
    }
  }
  else
  {
    uint64_t InterfaceFor = 0;
  }
  uint64_t v32 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v26, InterfaceFor, v24, 4, 4, 1, 1);
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)v32))
  {
LABEL_223:
    uint64_t v28 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v29 = 566;
    uint64_t v30 = "Casting.h";
    uint64_t v31 = "cast";
    goto LABEL_230;
  }
  v231[0] = v32;
  uint64_t v33 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v9, LocationForOp, v231);
  if (!*((_DWORD *)v33 + 9))
  {
    uint64_t v28 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    int v29 = 984;
    uint64_t v30 = "Operation.h";
    uint64_t v31 = "getOpResultImpl";
LABEL_230:
    __assert_rtn(v31, v30, v29, v28);
  }
  uint64_t v199 = (uint64_t)v33 - 16;
  *__int16 v24 = 1;
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v26)) {
    goto LABEL_224;
  }
  if (v26)
  {
    uint64_t v34 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v26);
    if (!v34)
    {
      unsigned int v35 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v36 = 98;
      id v37 = "InterfaceSupport.h";
      int v38 = "Interface";
      goto LABEL_232;
    }
  }
  else
  {
    uint64_t v34 = 0;
  }
  int v39 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v26, v34, v24, 4, 4, 1, 1);
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)v39))
  {
LABEL_224:
    unsigned int v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v36 = 566;
    id v37 = "Casting.h";
    int v38 = "cast";
    goto LABEL_232;
  }
  v231[0] = v39;
  BOOL v40 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v9, LocationForOp, v231);
  if (!*((_DWORD *)v40 + 9))
  {
    unsigned int v35 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    int v36 = 984;
    id v37 = "Operation.h";
    int v38 = "getOpResultImpl";
LABEL_232:
    __assert_rtn(v38, v37, v36, v35);
  }
  uint64_t v198 = (uint64_t)v40 - 16;
  operator delete(v24);
  BOOL v41 = (uint64_t *)(*(void *)(v217 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v41)
  {
    BOOL v164 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v165 = 650;
    uint64_t v166 = "Casting.h";
    uint64_t v167 = "dyn_cast";
    goto LABEL_235;
  }
  if (!*v41)
  {
    BOOL v164 = "abstractType && \"Malformed type storage object.\"";
    int v165 = 160;
    uint64_t v166 = "TypeSupport.h";
    uint64_t v167 = "getAbstractType";
LABEL_235:
    __assert_rtn(v167, v166, v165, v164);
  }
  if (*(_UNKNOWN **)(*v41 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    BOOL v41 = 0;
  }
  v231[0] = v41;
  uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v231);
  uint64_t v180 = 0;
  uint64_t v44 = 0;
  uint64_t v197 = 0;
  if (!__p) {
    goto LABEL_81;
  }
  if (v43 <= 1) {
    __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
  }
  uint64_t v44 = *(void *)(Value + 8);
  uint64_t v197 = v44;
  uint64_t v45 = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "bias_back");
  uint64_t v46 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "weight_ih_back");
  uint64_t v205 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "weight_hh_back");
  uint64_t v180 = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "peephole_back");
  uint64_t v204 = v180;
  uint64_t v47 = v218;
  char v48 = (uint64_t *)operator new(0x10uLL);
  v231[1] = v48 + 2;
  v231[2] = v48 + 2;
  uint64_t *v48 = v47;
  v48[1] = v46;
  v231[0] = v48;
  __src[0] = 0;
  uint64_t v49 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>((mlir::UnitAttr **)v9, LocationForOp, (uint64_t *)v231, &v201, __src);
  if (!*(_DWORD *)(v49 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v218 = v49 - 16;
  if (!OptionalArgValue)
  {
LABEL_78:
    char v54 = 1;
    uint64_t v55 = v231[0];
    if (!v231[0]) {
      goto LABEL_80;
    }
    goto LABEL_79;
  }
  if (v45)
  {
    *(void *)std::vector<int> __src = OptionalArgValue;
    *(void *)&__src[8] = v45;
    uint64_t v50 = (uint64_t)v231[2];
    uint64_t v45 = (uint64_t)v231[0];
    if ((uint64_t *)((char *)v231[2] - (char *)v231[0]) >= (uint64_t *)0x10)
    {
      int64_t v56 = (char *)v231[1] - (char *)v231[0];
      if ((uint64_t *)((char *)v231[1] - (char *)v231[0]) > (uint64_t *)0xF)
      {
        *(_OWORD *)v231[0] = *(_OWORD *)__src;
        size_t v53 = 16;
      }
      else
      {
        uint64_t v57 = &__src[v56];
        if (v231[1] != v231[0])
        {
          memcpy(v231[0], __src, (char *)v231[1] - (char *)v231[0]);
          uint64_t v45 = (uint64_t)v231[1];
        }
        size_t v53 = 16 - v56;
        memcpy((void *)v45, v57, v53);
      }
    }
    else
    {
      if (v231[0])
      {
        v231[1] = v231[0];
        operator delete(v231[0]);
        uint64_t v50 = 0;
        memset(v231, 0, 24);
      }
      uint64_t v51 = v50 >> 2;
      if ((unint64_t)(v50 >> 2) <= 2) {
        uint64_t v51 = 2;
      }
      if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v52 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v52 = v51;
      }
      if (v52 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v45 = (uint64_t)operator new(8 * v52);
      v231[0] = (uint64_t *)v45;
      v231[2] = (uint64_t *)(v45 + 8 * v52);
      *(_OWORD *)uint64_t v45 = *(_OWORD *)__src;
      size_t v53 = 16;
    }
    v231[1] = (uint64_t *)(v45 + v53);
    __src[0] = 0;
    uint64_t v58 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>((mlir::UnitAttr **)v9, LocationForOp, (uint64_t *)v231, &v201, __src);
    if (!*(_DWORD *)(v58 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    OptionalArguint64_t Value = v58 - 16;
    goto LABEL_78;
  }
  *(void *)std::vector<int> __src = operator new(0x50uLL);
  *(_OWORD *)&__src[8] = xmmword_18112AA40;
  uint64_t v45 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __src);
  if ((__src[23] & 0x80000000) != 0) {
    operator delete(*(void **)__src);
  }
  char v54 = 0;
  uint64_t v55 = v231[0];
  if (v231[0])
  {
LABEL_79:
    v231[1] = v55;
    operator delete(v55);
  }
LABEL_80:
  if ((v54 & 1) == 0) {
    goto LABEL_211;
  }
LABEL_81:
  uint64_t v59 = (uint64_t *)(*(void *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v59)
  {
    uint64_t v168 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v169 = 650;
    uint64_t v170 = "Casting.h";
    int v171 = "dyn_cast";
    goto LABEL_240;
  }
  if (!*v59)
  {
    uint64_t v168 = "abstractType && \"Malformed type storage object.\"";
    int v169 = 160;
    uint64_t v170 = "TypeSupport.h";
    int v171 = "getAbstractType";
LABEL_240:
    __assert_rtn(v171, v170, v169, v168);
  }
  if (*(_UNKNOWN **)(*v59 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    uint64_t v59 = 0;
  }
  v231[0] = v59;
  uint64_t v60 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v231);
  if (v61 <= 1) {
    __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
  }
  uint64_t v62 = *(void *)(v60 + 8);
  if (v62 == 1)
  {
    uint64_t v63 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)v9, LocationForOp, &ArgValue, &v198);
    if (!*(_DWORD *)(v63 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    Arguint64_t Value = v63 - 16;
  }
  LOBYTE(v231[0]) = 0;
  __src[0] = 1;
  uint64_t v64 = mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value &,mlir::Value &,BOOL,BOOL>((mlir::BoolAttr **)v9, LocationForOp, &ArgValue, &v218, (unsigned __int8 *)v231, __src);
  if (!*(_DWORD *)(v64 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v195 = v64 - 16;
  uint64_t v196 = v64 - 16;
  if (OptionalArgValue)
  {
    uint64_t v65 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)v9, LocationForOp, &v196, &OptionalArgValue);
    if (!*((_DWORD *)v65 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v195 = (uint64_t)v65 - 16;
  }
  if (v62 == 1)
  {
    uint64_t v66 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)v9, LocationForOp, &v195, &v198);
    if (!*((_DWORD *)v66 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v195 = (uint64_t)v66 - 16;
  }
  if (v212 < 0)
  {
    if (v211 != 7) {
      goto LABEL_105;
    }
    id v67 = v210;
  }
  else
  {
    if (v212 != 7) {
      goto LABEL_105;
    }
    id v67 = (void **)&v210;
  }
  int v68 = *(_DWORD *)v67;
  int v69 = *(_DWORD *)((char *)v67 + 3);
  if (v68 != 1702258034 || v69 != 1702064741)
  {
LABEL_105:
    if (!__p) {
      goto LABEL_114;
    }
    goto LABEL_106;
  }
  uint64_t v163 = mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)v9, LocationForOp, &v195, &v199);
  if (!*(_DWORD *)(v163 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v195 = v163 - 16;
  if (__p)
  {
LABEL_106:
    LODWORD(v226) = -1;
    v231[0] = (uint64_t *)(4 * v44);
    *(void *)std::vector<int> __src = 4 * v44;
    uint64_t v71 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,long long,long long>((mlir::mps::ConstantOp *)v9, LocationForOp, &v195, (unsigned int *)&v226, (unsigned int *)v231, (unsigned int *)__src);
    if (!*(_DWORD *)(v71 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v206 = v71 - 16;
    uint64_t v72 = mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)v9, LocationForOp, &v206, &v199);
    if (!*(_DWORD *)(v72 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v206 = v72 - 16;
    *(_DWORD *)std::vector<int> __src = -1;
    LODWORD(v226) = 0;
    v231[0] = (uint64_t *)(4 * v44);
    uint64_t v73 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,long long>((mlir::mps::ConstantOp *)v9, LocationForOp, &v195, (unsigned int *)__src, (unsigned int *)&v226, (unsigned int *)v231);
    if (!*(_DWORD *)(v73 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v195 = v73 - 16;
    LODWORD(v231[0]) = -1;
    uint64_t v74 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,long long &,long long &>((mlir::mps::ConstantOp *)v9, LocationForOp, &v221, (unsigned int *)v231, (unsigned int *)&v197, (unsigned int *)&v197);
    if (!*(_DWORD *)(v74 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v203 = v74 - 16;
    LODWORD(v231[0]) = -1;
    uint64_t v75 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,long long &,long long &>((mlir::mps::ConstantOp *)v9, LocationForOp, &v220, (unsigned int *)v231, (unsigned int *)&v197, (unsigned int *)&v197);
    if (!*(_DWORD *)(v75 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v202 = v75 - 16;
    LODWORD(v231[0]) = -1;
    *(_DWORD *)std::vector<int> __src = 0;
    uint64_t v76 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,long long &>((mlir::mps::ConstantOp *)v9, LocationForOp, &v221, (unsigned int *)v231, (unsigned int *)__src, (unsigned int *)&v197);
    if (!*(_DWORD *)(v76 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v221 = v76 - 16;
    LODWORD(v231[0]) = -1;
    *(_DWORD *)std::vector<int> __src = 0;
    uint64_t v77 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,long long &>((mlir::mps::ConstantOp *)v9, LocationForOp, &v220, (unsigned int *)v231, (unsigned int *)__src, (unsigned int *)&v197);
    if (!*(_DWORD *)(v77 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v220 = v77 - 16;
  }
LABEL_114:
  if (SHIBYTE(v209.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v193, v209.__r_.__value_.__l.__data_, v209.__r_.__value_.__l.__size_);
  }
  else {
    std::string v193 = v209;
  }
  unsigned int v78 = MILToMLIR::activationStringToAttr((uint64_t)&v193, 1u);
  unsigned int v79 = v78;
  if (SHIBYTE(v193.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v193.__r_.__value_.__l.__data_);
    unsigned int v194 = v79;
    if ((SHIBYTE(v208.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_119;
    }
  }
  else
  {
    unsigned int v194 = v78;
    if ((SHIBYTE(v208.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_119:
      std::string v191 = v208;
      goto LABEL_122;
    }
  }
  std::string::__init_copy_ctor_external(&v191, v208.__r_.__value_.__l.__data_, v208.__r_.__value_.__l.__size_);
LABEL_122:
  unsigned int v80 = MILToMLIR::activationStringToAttr((uint64_t)&v191, 1u);
  unsigned int v81 = v80;
  if (SHIBYTE(v191.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v191.__r_.__value_.__l.__data_);
    unsigned int v192 = v81;
    if ((SHIBYTE(v207.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_124;
    }
  }
  else
  {
    unsigned int v192 = v80;
    if ((SHIBYTE(v207.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_124:
      std::string v189 = v207;
      goto LABEL_127;
    }
  }
  std::string::__init_copy_ctor_external(&v189, v207.__r_.__value_.__l.__data_, v207.__r_.__value_.__l.__size_);
LABEL_127:
  unsigned int v82 = MILToMLIR::activationStringToAttr((uint64_t)&v189, 1u);
  unsigned int v83 = v82;
  if (SHIBYTE(v189.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v189.__r_.__value_.__l.__data_);
    unsigned int v190 = v83;
    uint64_t v84 = v216;
    if (!v216) {
      goto LABEL_155;
    }
  }
  else
  {
    unsigned int v190 = v82;
    uint64_t v84 = v216;
    if (!v216) {
      goto LABEL_155;
    }
  }
  long long v85 = (uint64_t *)(*(void *)(v84 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v85)
  {
    unint64_t v172 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v173 = 650;
    uint64_t v174 = "Casting.h";
    float v175 = "dyn_cast";
    goto LABEL_254;
  }
  if (!*v85)
  {
    unint64_t v172 = "abstractType && \"Malformed type storage object.\"";
    int v173 = 160;
    uint64_t v174 = "TypeSupport.h";
    float v175 = "getAbstractType";
LABEL_254:
    __assert_rtn(v175, v174, v173, v172);
  }
  if (*(_UNKNOWN **)(*v85 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    long long v85 = 0;
  }
  v231[0] = v85;
  uint64_t v86 = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v231);
  if (!v87) {
    __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
  }
  uint64_t v88 = *v86;
  v231[0] = (uint64_t *)(*(void *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
  uint64_t Context = (mlir::Float32Type *)mlir::Attribute::getContext((mlir::Attribute *)v231);
  uint64_t v91 = mlir::Float32Type::get(Context, v90);
  v231[0] = (uint64_t *)1;
  uint64_t v92 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v231, 1, v91, 0);
  v231[0] = (uint64_t *)mlir::mps::getConstantAttr<int>(v92, 0);
  uint64_t v93 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v9, LocationForOp, v231);
  if (!*((_DWORD *)v93 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v94 = operator new(4uLL);
  *uint64_t v94 = (int)v88 / 3;
  v231[0] = (uint64_t *)1;
  uint64_t v95 = mlir::Builder::getIntegerType((mlir::Builder *)v9, 0x20u, 1);
  uint64_t v96 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)v231, 1, v95, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v96)) {
    goto LABEL_236;
  }
  if (v96)
  {
    uint64_t v97 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v96);
    if (!v97)
    {
      uint64_t v98 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v99 = 98;
      uint64_t v100 = "InterfaceSupport.h";
      uint64_t v101 = "Interface";
      goto LABEL_237;
    }
  }
  else
  {
    uint64_t v97 = 0;
  }
  long long v102 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v96, v97, v94, 4, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v102) & 1) == 0)
  {
LABEL_236:
    uint64_t v98 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v99 = 566;
    uint64_t v100 = "Casting.h";
    uint64_t v101 = "cast";
LABEL_237:
    __assert_rtn(v101, v100, v99, v98);
  }
  v231[0] = v102;
  char v103 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v9, LocationForOp, v231);
  uint64_t v223 = LocationForOp;
  uint64_t v104 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v223);
  uint64_t v105 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.broadcast_to", (const unsigned __int8 *)0x10, v104);
  if (!v106)
  {
    __int16 v230 = 1283;
    BOOL v228 = "mps.broadcast_to";
    uint64_t v229 = 16;
                       "been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-"
                       "dependent-whats-up-with-dialects-management";
    __int16 v225 = 259;
    llvm::operator+((uint64_t *)&v226, v224, (uint64_t)__src);
    llvm::report_fatal_error((llvm::Twine *)__src, 1);
  }
  mlir::OperationState::OperationState(v231, LocationForOp, v105);
  if (!*((_DWORD *)v103 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::BroadcastToOp::build((uint64_t)v9, (uint64_t)v231, (uint64_t)v93 - 16, (uint64_t)v103 - 16);
  __int16 v107 = mlir::OpBuilder::create((mlir::OpBuilder *)v9, (const mlir::OperationState *)v231);
  if (!v107)
  {
    int v176 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v177 = 662;
    unsigned int v178 = "Casting.h";
    BOOL v179 = "dyn_cast";
    goto LABEL_261;
  }
  uint64_t v108 = llvm::DefaultDoCastIfPossible<mlir::mps::BroadcastToOp,mlir::Operation *,llvm::CastInfo<mlir::mps::BroadcastToOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v107);
  if (!v108)
  {
    int v176 = "result && \"builder didn't return the right type\"";
    int v177 = 497;
    unsigned int v178 = "Builders.h";
    BOOL v179 = "create";
LABEL_261:
    __assert_rtn(v179, v178, v177, v176);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v231);
  if (!*(_DWORD *)(v108 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v109 = (uint64_t *)operator new(0x10uLL);
  v231[1] = v109 + 2;
  v231[2] = v109 + 2;
  uint64_t *v109 = v84;
  v109[1] = v108 - 16;
  v231[0] = v109;
  __src[0] = 0;
  uint64_t v110 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>((mlir::UnitAttr **)v9, LocationForOp, (uint64_t *)v231, &v201, __src);
  if (!*(_DWORD *)(v110 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v216 = v110 - 16;
  if (__p)
  {
    *v231[0] = v180;
    __src[0] = 0;
    uint64_t v111 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>((mlir::UnitAttr **)v9, LocationForOp, (uint64_t *)v231, &v201, __src);
    if (!*(_DWORD *)(v111 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v204 = v111 - 16;
  }
  if (v231[0])
  {
    v231[1] = v231[0];
    operator delete(v231[0]);
  }
  operator delete(v94);
LABEL_155:
  LODWORD(v231[0]) = 2;
  __src[0] = 0;
  uint64_t v112 = mlir::OpBuilder::create<mlir::mps::LSTMOp,mlir::Value &,mlir::Value &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::LSTMGateLayout,BOOL,mlir::Value &,mlir::Value &,decltype(nullptr),mlir::Value &,mlir::Value &>((mlir::UnitAttr **)v9, LocationForOp, &v195, &v217, &v192, &v192, &v190, &v192, &v194, (unsigned int *)v231, __src, &v221, &v220, &v216, (BOOL *)&v215);
  int v113 = *(_DWORD *)(v112 + 36);
  if (!v113) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v114 = v112 - 16;
  v224[0] = v112 - 16;
  if (v113 == 1) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v223 = v112 - 32;
  LODWORD(v231[0]) = 0;
  *(_DWORD *)std::vector<int> __src = -1;
  LODWORD(v226) = 1;
  uint64_t v115 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,int>((mlir::mps::ConstantOp *)v9, LocationForOp, v224, (unsigned int *)v231, (unsigned int *)__src, (unsigned int *)&v226);
  if (!*(_DWORD *)(v115 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v188 = v115 - 16;
  LODWORD(v231[0]) = 0;
  *(_DWORD *)std::vector<int> __src = -1;
  LODWORD(v226) = 1;
  uint64_t v116 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,int>((mlir::mps::ConstantOp *)v9, LocationForOp, &v223, (unsigned int *)v231, (unsigned int *)__src, (unsigned int *)&v226);
  if (!*(_DWORD *)(v116 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v187 = v116 - 16;
  if ((v181 & 1) == 0)
  {
    uint64_t v114 = v188;
    v224[0] = v188;
  }
  if (__p)
  {
    LODWORD(v231[0]) = 2;
    __src[0] = 0;
    uint64_t v117 = mlir::OpBuilder::create<mlir::mps::LSTMOp,mlir::Value &,mlir::Value &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::LSTMGateLayout,BOOL,mlir::Value &,mlir::Value &,decltype(nullptr),mlir::Value &,mlir::Value &>((mlir::UnitAttr **)v9, LocationForOp, &v206, &v205, &v192, &v192, &v190, &v192, &v194, (unsigned int *)v231, __src, &v203, &v202, &v204, (BOOL *)&v215);
    int v118 = *(_DWORD *)(v117 + 36);
    if (!v118) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v186 = v117 - 16;
    if (v118 == 1) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v185 = v117 - 32;
    LODWORD(v231[0]) = 0;
    *(_DWORD *)std::vector<int> __src = -1;
    LODWORD(v226) = 1;
    uint64_t v119 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,int>((mlir::mps::ConstantOp *)v9, LocationForOp, &v186, (unsigned int *)v231, (unsigned int *)__src, (unsigned int *)&v226);
    if (!*(_DWORD *)(v119 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    LODWORD(v231[0]) = 0;
    *(_DWORD *)std::vector<int> __src = -1;
    LODWORD(v226) = 1;
    uint64_t v120 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,int>((mlir::mps::ConstantOp *)v9, LocationForOp, &v185, (unsigned int *)v231, (unsigned int *)__src, (unsigned int *)&v226);
    if (!*(_DWORD *)(v120 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v121 = v119 - 16;
    uint64_t v122 = v121;
    if (v181)
    {
      uint64_t v123 = mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)v9, LocationForOp, &v186, &v199);
      if (!*(_DWORD *)(v123 + 36)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
      uint64_t v122 = v123 - 16;
    }
    uint64_t v186 = v122;
    int v124 = (uint64_t *)operator new(0x10uLL);
    v231[1] = v124 + 2;
    v231[2] = v124 + 2;
    *int v124 = v114;
    v124[1] = v122;
    v231[0] = v124;
    uint64_t v125 = v188;
    uint64_t v126 = operator new(0x10uLL);
    *(void *)&__src[8] = v126 + 2;
    *(void *)&__src[16] = v126 + 2;
    *uint64_t v126 = v125;
    v126[1] = v121;
    *(void *)std::vector<int> __src = v126;
    uint64_t v127 = v187;
    size_t v128 = operator new(0x10uLL);
    BOOL v227 = (mlir::GenericProgramPoint *)(v128 + 2);
    BOOL v228 = (const char *)(v128 + 2);
    *size_t v128 = v127;
    v128[1] = v120 - 16;
    uint64_t v226 = (mlir::GenericProgramPoint *)v128;
    unsigned __int8 v184 = 0;
    uint64_t v129 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>((mlir::UnitAttr **)v9, LocationForOp, (uint64_t *)v231, &v200, &v184);
    if (!*(_DWORD *)(v129 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v114 = v129 - 16;
    v224[0] = v129 - 16;
    unsigned __int8 v184 = 0;
    uint64_t v130 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>((mlir::UnitAttr **)v9, LocationForOp, (uint64_t *)__src, &v200, &v184);
    if (!*(_DWORD *)(v130 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v188 = v130 - 16;
    unsigned __int8 v184 = 0;
    uint64_t v131 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>((mlir::UnitAttr **)v9, LocationForOp, (uint64_t *)&v226, &v200, &v184);
    if (!*(_DWORD *)(v131 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v187 = v131 - 16;
    if (v226)
    {
      BOOL v227 = v226;
      operator delete(v226);
    }
    if (*(void *)__src)
    {
      *(void *)&__src[8] = *(void *)__src;
      operator delete(*(void **)__src);
    }
    if (v231[0])
    {
      v231[1] = v231[0];
      operator delete(v231[0]);
    }
  }
  int v132 = operator new(4uLL);
  *int v132 = 0;
  v231[0] = (uint64_t *)1;
  uint64_t v133 = mlir::Builder::getIntegerType((mlir::Builder *)v9, 0x20u, 1);
  unint64_t v134 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)v231, 1, v133, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v134)) {
    goto LABEL_225;
  }
  if (v134)
  {
    uint64_t v135 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v134);
    if (!v135)
    {
      long long v136 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v137 = 98;
      long long v138 = "InterfaceSupport.h";
      long long v139 = "Interface";
      goto LABEL_226;
    }
  }
  else
  {
    uint64_t v135 = 0;
  }
  unint64_t v140 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v134, v135, v132, 4, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v140) & 1) == 0)
  {
LABEL_225:
    long long v136 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v137 = 566;
    long long v138 = "Casting.h";
    long long v139 = "cast";
LABEL_226:
    __assert_rtn(v139, v138, v137, v136);
  }
  v231[0] = v140;
  uint64_t v226 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v9, LocationForOp, v231);
  uint64_t v141 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::mps::ConstantOp &>((mlir::OpBuilder *)v9, LocationForOp, &v188, &v226);
  if (!*((_DWORD *)v141 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v142 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::mps::ConstantOp &>((mlir::OpBuilder *)v9, LocationForOp, &v187, &v226);
  if (!*((_DWORD *)v142 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  __pa = v132;
  (*(void (**)(uint64_t **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(v231, a2);
  int v143 = v231[0];
  uint64_t v144 = (char *)operator new(8uLL);
  *(void *)uint64_t v144 = v114;
  unint64_t v145 = (char *)(a3 + 8);
  *(void *)std::vector<int> __src = v143;
  unint64_t v146 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v145, (uint64_t)v143, (uint64_t)&std::piecewise_construct, (long long **)__src);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v146 + 5, v144, v144 + 8, 1uLL);
  operator delete(v144);
  int v147 = v231[0];
  if (v231[0])
  {
    uint64_t v148 = v231[1];
    size_t v149 = v231[0];
    if (v231[1] != v231[0])
    {
      do
      {
        if (*((char *)v148 - 1) < 0) {
          operator delete((void *)*(v148 - 3));
        }
        v148 -= 3;
      }
      while (v148 != v147);
      size_t v149 = v231[0];
    }
    v231[1] = v147;
    operator delete(v149);
  }
  (*(void (**)(uint64_t **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(v231, a2);
  BOOL v150 = v231[0];
  int v151 = (char *)operator new(8uLL);
  *(void *)int v151 = (char *)v141 - 16;
  *(void *)std::vector<int> __src = v150 + 3;
  BOOL v152 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v145, (uint64_t)(v150 + 3), (uint64_t)&std::piecewise_construct, (long long **)__src);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v152 + 5, v151, v151 + 8, 1uLL);
  operator delete(v151);
  uint64_t v153 = v231[0];
  if (v231[0])
  {
    unint64_t v154 = v231[1];
    uint64_t v155 = v231[0];
    if (v231[1] != v231[0])
    {
      do
      {
        if (*((char *)v154 - 1) < 0) {
          operator delete((void *)*(v154 - 3));
        }
        v154 -= 3;
      }
      while (v154 != v153);
      uint64_t v155 = v231[0];
    }
    v231[1] = v153;
    operator delete(v155);
  }
  (*(void (**)(uint64_t **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(v231, a2);
  unint64_t v156 = v231[0];
  int v157 = (char *)operator new(8uLL);
  *(void *)int v157 = (char *)v142 - 16;
  *(void *)std::vector<int> __src = v156 + 6;
  unint64_t v158 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v145, (uint64_t)(v156 + 6), (uint64_t)&std::piecewise_construct, (long long **)__src);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v158 + 5, v157, v157 + 8, 1uLL);
  operator delete(v157);
  unint64_t v159 = v231[0];
  if (v231[0])
  {
    unint64_t v160 = v231[1];
    size_t v161 = v231[0];
    if (v231[1] != v231[0])
    {
      do
      {
        if (*((char *)v160 - 1) < 0) {
          operator delete((void *)*(v160 - 3));
        }
        v160 -= 3;
      }
      while (v160 != v159);
      size_t v161 = v231[0];
    }
    v231[1] = v159;
    operator delete(v161);
  }
  operator delete(__pa);
  uint64_t v45 = 1;
LABEL_211:
  if (SHIBYTE(v207.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v207.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v208.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_213:
      if ((SHIBYTE(v209.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_214;
      }
LABEL_218:
      operator delete(v209.__r_.__value_.__l.__data_);
      if ((v212 & 0x80000000) == 0) {
        goto LABEL_215;
      }
LABEL_219:
      operator delete(v210);
      goto LABEL_215;
    }
  }
  else if ((SHIBYTE(v208.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_213;
  }
  operator delete(v208.__r_.__value_.__l.__data_);
  if (SHIBYTE(v209.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_218;
  }
LABEL_214:
  if (v212 < 0) {
    goto LABEL_219;
  }
LABEL_215:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v213, v214[0]);
  return v45;
}

void sub_180D79210(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,uint64_t a56,int a57,__int16 a58,char a59,char a60,uint64_t a61,uint64_t a62,int a63)
{
  if (*(char *)(v75 - 121) < 0) {
    operator delete(*(void **)(v75 - 144));
  }
  uint64_t v77 = (void *)STACK[0x250];
  if (STACK[0x250])
  {
    STACK[0x258] = (unint64_t)v77;
    operator delete(v77);
  }
  if (a54 < 0) {
    operator delete(v74[12]);
  }
  if (a60 < 0) {
    operator delete(v74[15]);
  }
  if (a66 < 0) {
    operator delete(v74[18]);
  }
  if (a72 < 0)
  {
    operator delete(a67);
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a73, a74);
    _Unwind_Resume(a1);
  }
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a73, a74);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,long long,long long>(mlir::mps::ConstantOp *a1, uint64_t a2, uint64_t *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6)
{
  v28[38] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.slice", (const unsigned __int8 *)9, Context);
  if (!v14)
  {
    __int16 v26 = 1283;
    v25[2] = (uint64_t)"mps.slice";
    v25[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v28, a2, v13);
  mlir::mps::SliceOp::build(a1, v28, *a3, *a4, *a5, *a6);
  uint64_t v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v28);
  if (!v15)
  {
    uint64_t v18 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v19 = 662;
    __int16 v20 = "Casting.h";
    uint64_t v21 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v16 = llvm::DefaultDoCastIfPossible<mlir::mps::SliceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SliceOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
  if (!v16)
  {
    uint64_t v18 = "result && \"builder didn't return the right type\"";
    int v19 = 497;
    __int16 v20 = "Builders.h";
    uint64_t v21 = "create";
LABEL_8:
    __assert_rtn(v21, v20, v19, v18);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v28);
  return v16;
}

void sub_180D796E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D796FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,long long>(mlir::mps::ConstantOp *a1, uint64_t a2, uint64_t *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6)
{
  v28[38] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.slice", (const unsigned __int8 *)9, Context);
  if (!v14)
  {
    __int16 v26 = 1283;
    v25[2] = (uint64_t)"mps.slice";
    v25[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v28, a2, v13);
  mlir::mps::SliceOp::build(a1, v28, *a3, *a4, *a5, *a6);
  uint64_t v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v28);
  if (!v15)
  {
    uint64_t v18 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v19 = 662;
    __int16 v20 = "Casting.h";
    uint64_t v21 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v16 = llvm::DefaultDoCastIfPossible<mlir::mps::SliceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SliceOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
  if (!v16)
  {
    uint64_t v18 = "result && \"builder didn't return the right type\"";
    int v19 = 497;
    __int16 v20 = "Builders.h";
    uint64_t v21 = "create";
LABEL_8:
    __assert_rtn(v21, v20, v19, v18);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v28);
  return v16;
}

void sub_180D798A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D798BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,long long &,long long &>(mlir::mps::ConstantOp *a1, uint64_t a2, uint64_t *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6)
{
  v28[38] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.slice", (const unsigned __int8 *)9, Context);
  if (!v14)
  {
    __int16 v26 = 1283;
    v25[2] = (uint64_t)"mps.slice";
    v25[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v28, a2, v13);
  mlir::mps::SliceOp::build(a1, v28, *a3, *a4, *a5, *a6);
  uint64_t v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v28);
  if (!v15)
  {
    uint64_t v18 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v19 = 662;
    __int16 v20 = "Casting.h";
    uint64_t v21 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v16 = llvm::DefaultDoCastIfPossible<mlir::mps::SliceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SliceOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
  if (!v16)
  {
    uint64_t v18 = "result && \"builder didn't return the right type\"";
    int v19 = 497;
    __int16 v20 = "Builders.h";
    uint64_t v21 = "create";
LABEL_8:
    __assert_rtn(v21, v20, v19, v18);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v28);
  return v16;
}

void sub_180D79A64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D79A7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,long long &>(mlir::mps::ConstantOp *a1, uint64_t a2, uint64_t *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6)
{
  v28[38] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.slice", (const unsigned __int8 *)9, Context);
  if (!v14)
  {
    __int16 v26 = 1283;
    v25[2] = (uint64_t)"mps.slice";
    v25[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v28, a2, v13);
  mlir::mps::SliceOp::build(a1, v28, *a3, *a4, *a5, *a6);
  uint64_t v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v28);
  if (!v15)
  {
    uint64_t v18 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v19 = 662;
    __int16 v20 = "Casting.h";
    uint64_t v21 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v16 = llvm::DefaultDoCastIfPossible<mlir::mps::SliceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SliceOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
  if (!v16)
  {
    uint64_t v18 = "result && \"builder didn't return the right type\"";
    int v19 = 497;
    __int16 v20 = "Builders.h";
    uint64_t v21 = "create";
LABEL_8:
    __assert_rtn(v21, v20, v19, v18);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v28);
  return v16;
}

void sub_180D79C24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180D79C3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::LSTMOp,mlir::Value &,mlir::Value &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::LSTMGateLayout,BOOL,mlir::Value &,mlir::Value &,decltype(nullptr),mlir::Value &,mlir::Value &>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned int *a5, unsigned int *a6, unsigned int *a7, unsigned int *a8, unsigned int *a9, unsigned int *a10, char *a11, uint64_t *a12, uint64_t *a13, uint64_t *a14, BOOL *a15)
{
  v39[38] = *MEMORY[0x1E4F143B8];
  uint64_t v33 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v33);
  uint64_t v24 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.lstm", (const unsigned __int8 *)8, Context);
  if (!v25)
  {
    __int16 v37 = 1283;
    v36[2] = (uint64_t)"mps.lstm";
    v36[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v35 = 259;
    llvm::operator+(v36, (uint64_t *)&v34, (uint64_t)v38);
    llvm::report_fatal_error((llvm::Twine *)v38, 1);
  }
  mlir::OperationState::OperationState(v39, a2, v24);
  mlir::mps::LSTMOp::build(a1, (uint64_t)v39, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, *a11, *a12, *a13, 0, *a14, *a15);
  __int16 v26 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v39);
  if (!v26)
  {
    int v29 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v30 = 662;
    uint64_t v31 = "Casting.h";
    uint64_t v32 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v27 = llvm::DefaultDoCastIfPossible<mlir::mps::LSTMOp,mlir::Operation *,llvm::CastInfo<mlir::mps::LSTMOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v26);
  if (!v27)
  {
    int v29 = "result && \"builder didn't return the right type\"";
    int v30 = 497;
    uint64_t v31 = "Builders.h";
    uint64_t v32 = "create";
LABEL_8:
    __assert_rtn(v32, v31, v30, v29);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v39);
  return v27;
}

void sub_180D79E3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
}

void sub_180D79E54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
}

uint64_t MILToMLIR::GRUPattern::matchAndRewrite(MILToMLIR::GRUPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v160 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v157 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "initial_h");
  OptionalArguint64_t Value = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "bias");
  uint64_t v155 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "weight_ih");
  uint64_t v154 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "weight_hh");
  uint64_t v6 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 160))(a2);
  v153[0] = 0;
  v153[1] = 0;
  BOOL v152 = v153;
  int v7 = v6 + 1;
  int v8 = *v6;
  if (*v6 != (const void **)(v6 + 1))
  {
    do
    {
      std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&v152, (uint64_t *)v153, v8 + 4, (uint64_t)(v8 + 4));
      int v12 = (const void **)v8[1];
      if (v12)
      {
        do
        {
          uint64_t v13 = (const void ***)v12;
          int v12 = (const void **)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          uint64_t v13 = (const void ***)v8[2];
          BOOL v16 = *v13 == v8;
          int v8 = (const void **)v13;
        }
        while (!v16);
      }
      int v8 = (const void **)v13;
    }
    while (v13 != v7);
  }
  v148[31] = 9;
  MIL::IROperation::TryGetParameterValue();
  MIL::IRValue::GetScalar<std::string>();
  strcpy(&v148[7], "\ndirection");
  strcpy((char *)&v147, "activation");
  MIL::IROperation::TryGetParameterValue();
  MIL::IRValue::GetScalar<std::string>();
  strcpy((char *)v146, "recurrent_activation");
  MIL::IROperation::TryGetParameterValue();
  MIL::IRValue::GetScalar<std::string>();
  HIBYTE(v146[2]) = 15;
  strcpy((char *)v146, "output_sequence");
  MIL::IROperation::TryGetParameterValue();
  char v9 = MIL::IRValue::GetScalar<BOOL>();
  int v10 = (uint64_t *)(a3 + 18);
  if (v151 < 0)
  {
    if (v150 == 13)
    {
      int v11 = v149;
      goto LABEL_14;
    }
  }
  else if (v151 == 13)
  {
    int v11 = (void **)&v149;
LABEL_14:
    char v14 = *v11;
    uint64_t v15 = *(uint64_t *)((char *)v11 + 5);
    BOOL v16 = v14 == (void *)0x7463657269646962 && v15 == 0x6C616E6F69746365;
    int v17 = v16;
    int v127 = v17;
    goto LABEL_22;
  }
  int v127 = 0;
LABEL_22:
  uint64_t v144 = 0;
  uint64_t v145 = 0;
  uint64_t v143 = 0;
  uint64_t v18 = mlir::IntegerType::get(*v10, 0x20u, 1u);
  int v19 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v18, 0);
  v146[0] = (uint64_t *)mlir::mps::getConstantAttr<int>(v19, 0);
  __int16 v20 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v10, LocationForOp, v146);
  if (!*((_DWORD *)v20 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v142 = (uint64_t)v20 - 16;
  uint64_t v21 = mlir::IntegerType::get(*v10, 0x20u, 1u);
  uint64_t v22 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v21, 0);
  v146[0] = (uint64_t *)mlir::mps::getConstantAttr<int>(v22, -1);
  uint64_t v23 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v10, LocationForOp, v146);
  if (!*((_DWORD *)v23 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v141 = (uint64_t)v23 - 16;
  uint64_t v139 = 0;
  uint64_t v140 = 0;
  uint64_t v24 = operator new(4uLL);
  *uint64_t v24 = 0;
  v146[0] = (uint64_t *)1;
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)v10, 0x20u, 1);
  __int16 v26 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)v146, 1, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v26)) {
    goto LABEL_162;
  }
  if (v26)
  {
    uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v26);
    if (!InterfaceFor)
    {
      uint64_t v28 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v29 = 98;
      int v30 = "InterfaceSupport.h";
      uint64_t v31 = "Interface";
      goto LABEL_169;
    }
  }
  else
  {
    uint64_t InterfaceFor = 0;
  }
  uint64_t v32 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v26, InterfaceFor, v24, 4, 4, 1, 1);
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)v32))
  {
LABEL_162:
    uint64_t v28 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v29 = 566;
    int v30 = "Casting.h";
    uint64_t v31 = "cast";
    goto LABEL_169;
  }
  v146[0] = v32;
  uint64_t v33 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v10, LocationForOp, v146);
  if (!*((_DWORD *)v33 + 9))
  {
    uint64_t v28 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    int v29 = 984;
    int v30 = "Operation.h";
    uint64_t v31 = "getOpResultImpl";
LABEL_169:
    __assert_rtn(v31, v30, v29, v28);
  }
  uint64_t v140 = (uint64_t)v33 - 16;
  *uint64_t v24 = 1;
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v26)) {
    goto LABEL_163;
  }
  if (v26)
  {
    uint64_t v34 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v26);
    if (!v34)
    {
      __int16 v35 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v36 = 98;
      __int16 v37 = "InterfaceSupport.h";
      int v38 = "Interface";
      goto LABEL_171;
    }
  }
  else
  {
    uint64_t v34 = 0;
  }
  int v39 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v26, v34, v24, 4, 4, 1, 1);
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)v39))
  {
LABEL_163:
    __int16 v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v36 = 566;
    __int16 v37 = "Casting.h";
    int v38 = "cast";
    goto LABEL_171;
  }
  v146[0] = v39;
  BOOL v40 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v10, LocationForOp, v146);
  if (!*((_DWORD *)v40 + 9))
  {
    __int16 v35 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    int v36 = 984;
    __int16 v37 = "Operation.h";
    int v38 = "getOpResultImpl";
LABEL_171:
    __assert_rtn(v38, v37, v36, v35);
  }
  uint64_t v139 = (uint64_t)v40 - 16;
  operator delete(v24);
  BOOL v41 = (uint64_t *)(*(void *)(v154 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v41)
  {
    uint64_t v119 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v120 = 650;
    uint64_t v121 = "Casting.h";
    uint64_t v122 = "dyn_cast";
    goto LABEL_174;
  }
  if (!*v41)
  {
    uint64_t v119 = "abstractType && \"Malformed type storage object.\"";
    int v120 = 160;
    uint64_t v121 = "TypeSupport.h";
    uint64_t v122 = "getAbstractType";
LABEL_174:
    __assert_rtn(v122, v121, v120, v119);
  }
  if (*(_UNKNOWN **)(*v41 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    BOOL v41 = 0;
  }
  v146[0] = v41;
  uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v146);
  uint64_t v44 = 0;
  uint64_t v138 = 0;
  if (!v127) {
    goto LABEL_71;
  }
  if (v43 <= 1) {
    __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
  }
  uint64_t v44 = *(void *)(Value + 8);
  uint64_t v138 = v44;
  uint64_t v45 = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "bias_back");
  uint64_t v46 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "weight_ih_back");
  char v47 = v9;
  uint64_t v144 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "weight_hh_back");
  uint64_t v48 = v155;
  uint64_t v49 = (uint64_t *)operator new(0x10uLL);
  v146[1] = v49 + 2;
  v146[2] = v49 + 2;
  uint64_t *v49 = v48;
  v49[1] = v46;
  v146[0] = v49;
  __src[0] = 0;
  uint64_t v50 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>((mlir::UnitAttr **)v10, LocationForOp, (uint64_t *)v146, &v142, __src);
  if (!*(_DWORD *)(v50 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  char v9 = v47;
  uint64_t v155 = v50 - 16;
  if (!OptionalArgValue)
  {
LABEL_68:
    char v54 = 1;
    uint64_t v55 = v146[0];
    if (!v146[0]) {
      goto LABEL_70;
    }
    goto LABEL_69;
  }
  if (v45)
  {
    *(void *)std::vector<int> __src = OptionalArgValue;
    *(void *)&__src[8] = v45;
    uint64_t v51 = (uint64_t)v146[2];
    uint64_t v45 = (uint64_t)v146[0];
    if ((uint64_t *)((char *)v146[2] - (char *)v146[0]) >= (uint64_t *)0x10)
    {
      int64_t v56 = (char *)v146[1] - (char *)v146[0];
      if ((uint64_t *)((char *)v146[1] - (char *)v146[0]) <= (uint64_t *)0xF)
      {
        uint64_t v57 = &__src[v56];
        if (v146[1] != v146[0])
        {
          memcpy(v146[0], __src, (char *)v146[1] - (char *)v146[0]);
          uint64_t v45 = (uint64_t)v146[1];
        }
        size_t v58 = 16 - v56;
        memcpy((void *)v45, v57, v58);
        goto LABEL_66;
      }
    }
    else
    {
      if (v146[0])
      {
        v146[1] = v146[0];
        operator delete(v146[0]);
        uint64_t v51 = 0;
        memset(v146, 0, sizeof(v146));
      }
      uint64_t v52 = v51 >> 2;
      if ((unint64_t)(v51 >> 2) <= 2) {
        uint64_t v52 = 2;
      }
      if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v53 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v53 = v52;
      }
      if (v53 >> 61) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v45 = (uint64_t)operator new(8 * v53);
      v146[0] = (uint64_t *)v45;
      v146[2] = (uint64_t *)(v45 + 8 * v53);
    }
    *(_OWORD *)uint64_t v45 = *(_OWORD *)__src;
    size_t v58 = 16;
LABEL_66:
    v146[1] = (uint64_t *)(v45 + v58);
    __src[0] = 0;
    uint64_t v59 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>((mlir::UnitAttr **)v10, LocationForOp, (uint64_t *)v146, &v142, __src);
    if (!*(_DWORD *)(v59 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    OptionalArguint64_t Value = v59 - 16;
    goto LABEL_68;
  }
  *(void *)std::vector<int> __src = operator new(0x50uLL);
  *(_OWORD *)&__src[8] = xmmword_18112AA40;
  uint64_t v45 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __src);
  if ((__src[23] & 0x80000000) != 0) {
    operator delete(*(void **)__src);
  }
  char v54 = 0;
  uint64_t v55 = v146[0];
  if (v146[0])
  {
LABEL_69:
    v146[1] = v55;
    operator delete(v55);
  }
LABEL_70:
  if ((v54 & 1) == 0) {
    goto LABEL_152;
  }
LABEL_71:
  uint64_t v60 = (uint64_t *)(*(void *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v60)
  {
    uint64_t v123 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v124 = 650;
    uint64_t v125 = "Casting.h";
    uint64_t v126 = "dyn_cast";
    goto LABEL_177;
  }
  if (!*v60)
  {
    uint64_t v123 = "abstractType && \"Malformed type storage object.\"";
    int v124 = 160;
    uint64_t v125 = "TypeSupport.h";
    uint64_t v126 = "getAbstractType";
LABEL_177:
    __assert_rtn(v126, v125, v124, v123);
  }
  if (*(_UNKNOWN **)(*v60 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    uint64_t v60 = 0;
  }
  v146[0] = v60;
  uint64_t v61 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v146);
  if (v62 <= 1) {
    __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
  }
  uint64_t v63 = *(void *)(v61 + 8);
  if (v63 == 1)
  {
    uint64_t v64 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)v10, LocationForOp, &ArgValue, &v139);
    if (!*(_DWORD *)(v64 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    Arguint64_t Value = v64 - 16;
  }
  LOBYTE(v146[0]) = 0;
  __src[0] = 1;
  uint64_t v65 = mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value &,mlir::Value &,BOOL,BOOL>((mlir::BoolAttr **)v10, LocationForOp, &ArgValue, &v155, (unsigned __int8 *)v146, __src);
  if (!*(_DWORD *)(v65 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v136 = v65 - 16;
  uint64_t v137 = v65 - 16;
  if (OptionalArgValue)
  {
    uint64_t v66 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)v10, LocationForOp, &v137, &OptionalArgValue);
    if (!*((_DWORD *)v66 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v136 = (uint64_t)v66 - 16;
  }
  if (v63 == 1)
  {
    id v67 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)v10, LocationForOp, &v136, &v139);
    if (!*((_DWORD *)v67 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v136 = (uint64_t)v67 - 16;
  }
  if (v151 < 0)
  {
    if (v150 != 7) {
      goto LABEL_95;
    }
    int v68 = v149;
  }
  else
  {
    if (v151 != 7) {
      goto LABEL_95;
    }
    int v68 = (void **)&v149;
  }
  int v69 = *(_DWORD *)v68;
  int v70 = *(_DWORD *)((char *)v68 + 3);
  if (v69 != 1702258034 || v70 != 1702064741)
  {
LABEL_95:
    if (!v127) {
      goto LABEL_102;
    }
    goto LABEL_96;
  }
  uint64_t v118 = mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)v10, LocationForOp, &v136, &v140);
  if (!*(_DWORD *)(v118 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v136 = v118 - 16;
  if (v127)
  {
LABEL_96:
    LODWORD(v131) = -1;
    uint64_t v72 = (uint64_t *)(4 * v44);
    v146[0] = v72;
    *(void *)std::vector<int> __src = v72;
    uint64_t v73 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,long long,long long>((mlir::mps::ConstantOp *)v10, LocationForOp, &v136, (unsigned int *)&v131, (unsigned int *)v146, (unsigned int *)__src);
    if (!*(_DWORD *)(v73 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v145 = v73 - 16;
    uint64_t v74 = mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)v10, LocationForOp, &v145, &v140);
    if (!*(_DWORD *)(v74 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    *(_DWORD *)std::vector<int> __src = -1;
    LODWORD(v131) = 0;
    uint64_t v145 = v74 - 16;
    v146[0] = v72;
    uint64_t v75 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,long long>((mlir::mps::ConstantOp *)v10, LocationForOp, &v136, (unsigned int *)__src, (unsigned int *)&v131, (unsigned int *)v146);
    if (!*(_DWORD *)(v75 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v136 = v75 - 16;
    LODWORD(v146[0]) = -1;
    uint64_t v76 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,long long &,long long &>((mlir::mps::ConstantOp *)v10, LocationForOp, &v157, (unsigned int *)v146, (unsigned int *)&v138, (unsigned int *)&v138);
    if (!*(_DWORD *)(v76 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v143 = v76 - 16;
    LODWORD(v146[0]) = -1;
    *(_DWORD *)std::vector<int> __src = 0;
    uint64_t v77 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,long long &>((mlir::mps::ConstantOp *)v10, LocationForOp, &v157, (unsigned int *)v146, (unsigned int *)__src, (unsigned int *)&v138);
    if (!*(_DWORD *)(v77 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v157 = v77 - 16;
  }
LABEL_102:
  if ((v148[31] & 0x80000000) != 0) {
    std::string::__init_copy_ctor_external(&v134, *(const std::string::value_type **)&v148[8], *(std::string::size_type *)&v148[16]);
  }
  else {
    std::string v134 = *(std::string *)&v148[8];
  }
  unsigned int v78 = MILToMLIR::activationStringToAttr((uint64_t)&v134, 0);
  unsigned int v79 = v78;
  if (SHIBYTE(v134.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v134.__r_.__value_.__l.__data_);
    unsigned int v135 = v79;
    if ((v148[7] & 0x80000000) == 0) {
      goto LABEL_107;
    }
  }
  else
  {
    unsigned int v135 = v78;
    if ((v148[7] & 0x80000000) == 0)
    {
LABEL_107:
      *(_OWORD *)&v132.__r_.__value_.__l.__data_ = v147;
      v132.__r_.__value_.__r.__words[2] = *(void *)v148;
      goto LABEL_110;
    }
  }
  std::string::__init_copy_ctor_external(&v132, (const std::string::value_type *)v147, *((std::string::size_type *)&v147 + 1));
LABEL_110:
  unsigned int v80 = MILToMLIR::activationStringToAttr((uint64_t)&v132, 0);
  if (SHIBYTE(v132.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v132.__r_.__value_.__l.__data_);
  }
  unsigned int v133 = v80;
  LODWORD(v146[0]) = 2;
  __src[0] = 0;
  LOBYTE(v131) = 0;
  LOBYTE(v130) = 0;
  uint64_t v81 = mlir::OpBuilder::create<mlir::mps::GRUOp,mlir::Value &,mlir::Value &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::GRUGateLayout,BOOL,BOOL,BOOL,mlir::Value &,decltype(nullptr),decltype(nullptr)>((mlir::UnitAttr **)v10, LocationForOp, &v136, &v154, &v133, &v133, &v135, (unsigned int *)v146, __src, (char *)&v131, (unsigned __int8 *)&v130, &v157);
  if (!*(_DWORD *)(v81 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v82 = v81 - 16;
  uint64_t v131 = v81 - 16;
  LODWORD(v146[0]) = 0;
  *(_DWORD *)std::vector<int> __src = -1;
  LODWORD(v129) = 1;
  uint64_t v83 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,int>((mlir::mps::ConstantOp *)v10, LocationForOp, &v131, (unsigned int *)v146, (unsigned int *)__src, (unsigned int *)&v129);
  if (!*(_DWORD *)(v83 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v130 = v83 - 16;
  if ((v9 & 1) == 0)
  {
    uint64_t v131 = v83 - 16;
    uint64_t v82 = v83 - 16;
  }
  if (v127)
  {
    LODWORD(v146[0]) = 2;
    __src[0] = 0;
    LOBYTE(v129) = 0;
    LOBYTE(v128) = 1;
    uint64_t v84 = mlir::OpBuilder::create<mlir::mps::GRUOp,mlir::Value &,mlir::Value &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::GRUGateLayout,BOOL,BOOL,BOOL,mlir::Value &,decltype(nullptr),decltype(nullptr)>((mlir::UnitAttr **)v10, LocationForOp, &v145, &v144, &v133, &v133, &v135, (unsigned int *)v146, __src, (char *)&v129, (unsigned __int8 *)&v128, &v143);
    if (!*(_DWORD *)(v84 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v129 = (mlir::GenericProgramPoint *)(v84 - 16);
    LODWORD(v146[0]) = 0;
    *(_DWORD *)std::vector<int> __src = -1;
    unsigned int v128 = 1;
    uint64_t v85 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,int>((mlir::mps::ConstantOp *)v10, LocationForOp, (uint64_t *)&v129, (unsigned int *)v146, (unsigned int *)__src, &v128);
    if (!*(_DWORD *)(v85 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v86 = v85 - 16;
    uint64_t v87 = (mlir::GenericProgramPoint *)(v85 - 16);
    if (v9)
    {
      uint64_t v88 = mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)v10, LocationForOp, (uint64_t *)&v129, &v140);
      if (!*(_DWORD *)(v88 + 36)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
      uint64_t v87 = (mlir::GenericProgramPoint *)(v88 - 16);
    }
    uint64_t v129 = v87;
    int v89 = (uint64_t *)operator new(0x10uLL);
    v146[1] = v89 + 2;
    v146[2] = v89 + 2;
    uint64_t *v89 = v82;
    v89[1] = (uint64_t)v87;
    v146[0] = v89;
    uint64_t v90 = v130;
    uint64_t v91 = operator new(0x10uLL);
    *(void *)&__src[8] = v91 + 2;
    *(void *)&__src[16] = v91 + 2;
    void *v91 = v90;
    v91[1] = v86;
    *(void *)std::vector<int> __src = v91;
    LOBYTE(v128) = 0;
    uint64_t v92 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>((mlir::UnitAttr **)v10, LocationForOp, (uint64_t *)v146, &v141, (unsigned __int8 *)&v128);
    if (!*(_DWORD *)(v92 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v82 = v92 - 16;
    uint64_t v131 = v92 - 16;
    LOBYTE(v128) = 0;
    uint64_t v93 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>((mlir::UnitAttr **)v10, LocationForOp, (uint64_t *)__src, &v141, (unsigned __int8 *)&v128);
    if (!*(_DWORD *)(v93 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v130 = v93 - 16;
    if (*(void *)__src)
    {
      *(void *)&__src[8] = *(void *)__src;
      operator delete(*(void **)__src);
    }
    if (v146[0])
    {
      v146[1] = v146[0];
      operator delete(v146[0]);
    }
  }
  (*(void (**)(uint64_t **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(v146, a2);
  uint64_t v94 = v146[0];
  uint64_t v95 = (char *)operator new(8uLL);
  *(void *)uint64_t v95 = v82;
  uint64_t v96 = (char *)(a3 + 8);
  *(void *)std::vector<int> __src = v94;
  uint64_t v97 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v94, (uint64_t)&std::piecewise_construct, (long long **)__src);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v97 + 5, v95, v95 + 8, 1uLL);
  operator delete(v95);
  uint64_t v98 = v146[0];
  if (v146[0])
  {
    int v99 = v146[1];
    uint64_t v100 = v146[0];
    if (v146[1] != v146[0])
    {
      do
      {
        if (*((char *)v99 - 1) < 0) {
          operator delete((void *)*(v99 - 3));
        }
        v99 -= 3;
      }
      while (v99 != v98);
      uint64_t v100 = v146[0];
    }
    v146[1] = v98;
    operator delete(v100);
  }
  uint64_t v101 = operator new(4uLL);
  *uint64_t v101 = 0;
  v146[0] = (uint64_t *)1;
  uint64_t v102 = mlir::Builder::getIntegerType((mlir::Builder *)v10, 0x20u, 1);
  char v103 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)v146, 1, v102, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v103)) {
    goto LABEL_164;
  }
  if (v103)
  {
    uint64_t v104 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v103);
    if (!v104)
    {
      uint64_t v105 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v106 = 98;
      __int16 v107 = "InterfaceSupport.h";
      uint64_t v108 = "Interface";
      goto LABEL_165;
    }
  }
  else
  {
    uint64_t v104 = 0;
  }
  uint64_t v109 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v103, v104, v101, 4, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v109) & 1) == 0)
  {
LABEL_164:
    uint64_t v105 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v106 = 566;
    __int16 v107 = "Casting.h";
    uint64_t v108 = "cast";
LABEL_165:
    __assert_rtn(v108, v107, v106, v105);
  }
  v146[0] = v109;
  uint64_t v129 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v10, LocationForOp, v146);
  uint64_t v110 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::mps::ConstantOp &>((mlir::OpBuilder *)v10, LocationForOp, &v130, &v129);
  if (!*((_DWORD *)v110 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  (*(void (**)(uint64_t **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(v146, a2);
  uint64_t v111 = v146[0];
  uint64_t v112 = (char *)operator new(8uLL);
  *(void *)uint64_t v112 = (char *)v110 - 16;
  *(void *)std::vector<int> __src = v111 + 3;
  int v113 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v96, (uint64_t)(v111 + 3), (uint64_t)&std::piecewise_construct, (long long **)__src);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v113 + 5, v112, v112 + 8, 1uLL);
  operator delete(v112);
  uint64_t v114 = v146[0];
  if (v146[0])
  {
    uint64_t v115 = v146[1];
    uint64_t v116 = v146[0];
    if (v146[1] != v146[0])
    {
      do
      {
        if (*((char *)v115 - 1) < 0) {
          operator delete((void *)*(v115 - 3));
        }
        v115 -= 3;
      }
      while (v115 != v114);
      uint64_t v116 = v146[0];
    }
    v146[1] = v114;
    operator delete(v116);
  }
  operator delete(v101);
  uint64_t v45 = 1;
LABEL_152:
  if ((v148[7] & 0x80000000) == 0)
  {
    if ((v148[31] & 0x80000000) == 0) {
      goto LABEL_154;
    }
LABEL_157:
    operator delete(*(void **)&v148[8]);
    if ((v151 & 0x80000000) == 0) {
      goto LABEL_155;
    }
LABEL_158:
    operator delete(v149);
    goto LABEL_155;
  }
  operator delete((void *)v147);
  if ((v148[31] & 0x80000000) != 0) {
    goto LABEL_157;
  }
LABEL_154:
  if (v151 < 0) {
    goto LABEL_158;
  }
LABEL_155:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v152, v153[0]);
  return v45;
}

void sub_180D7B318(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  if (*(char *)(v44 - 105) < 0) {
    operator delete(*(void **)(v43 + 200));
  }
  uint64_t v46 = *(void **)(v43 + 40);
  if (v46)
  {
    *(void *)(v43 + 48) = v46;
    operator delete(v46);
  }
  if (a43 < 0) {
    operator delete(*(void **)(v43 + 64));
  }
  if (*(char *)(v44 - 217) < 0) {
    operator delete(*(void **)(v43 + 88));
  }
  if (*(char *)(v44 - 193) < 0) {
    operator delete(*(void **)(v43 + 112));
  }
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy(v44 - 192, *(char **)(v43 + 144));
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::GRUOp,mlir::Value &,mlir::Value &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::GRUGateLayout,BOOL,BOOL,BOOL,mlir::Value &,decltype(nullptr),decltype(nullptr)>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned int *a5, unsigned int *a6, unsigned int *a7, unsigned int *a8, char *a9, char *a10, unsigned __int8 *a11, uint64_t *a12)
{
  v36[38] = *MEMORY[0x1E4F143B8];
  uint64_t v30 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v30);
  uint64_t v21 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.gru", (const unsigned __int8 *)7, Context);
  if (!v22)
  {
    __int16 v34 = 1283;
    void v33[2] = (uint64_t)"mps.gru";
    v33[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v32 = 259;
    llvm::operator+(v33, (uint64_t *)&v31, (uint64_t)v35);
    llvm::report_fatal_error((llvm::Twine *)v35, 1);
  }
  mlir::OperationState::OperationState(v36, a2, v21);
  mlir::mps::GRUOp::build(a1, (uint64_t)v36, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, *a11, *a12, 0, 0);
  uint64_t v23 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v36);
  if (!v23)
  {
    __int16 v26 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v27 = 662;
    uint64_t v28 = "Casting.h";
    int v29 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v24 = llvm::DefaultDoCastIfPossible<mlir::mps::GRUOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GRUOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v23);
  if (!v24)
  {
    __int16 v26 = "result && \"builder didn't return the right type\"";
    int v27 = 497;
    uint64_t v28 = "Builders.h";
    int v29 = "create";
LABEL_8:
    __assert_rtn(v29, v28, v27, v26);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v36);
  return v24;
}

void sub_180D7B6E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
}

void sub_180D7B700(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
}

void MILToMLIR::SingleGateRNNPattern::~SingleGateRNNPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::LSTMPattern::~LSTMPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void MILToMLIR::GRUPattern::~GRUPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SingleGateRNNOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SingleGateRNNOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  unint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 18
      && *(void *)AttrData == 0x676E69732E73706DLL
      && *(void *)(AttrData + 8) == 0x725F65746167656CLL
      && *(_WORD *)(AttrData + 16) == 28270)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.singlegate_rnn";
      v9[3] = 18;
      int v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SingleGateRNNOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::BroadcastToOp,mlir::Operation *,llvm::CastInfo<mlir::mps::BroadcastToOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  unint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 16 && *AttrData == 0x616F72622E73706DLL && AttrData[1] == 0x6F745F7473616364)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.broadcast_to";
      v8[3] = 16;
      uint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::BroadcastToOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::LSTMOp,mlir::Operation *,llvm::CastInfo<mlir::mps::LSTMOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  unint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x6D74736C2E73706DLL)
    {
      __int16 v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.lstm";
      v7[3] = 8;
      uint64_t v5 = "' failed due to the operation not being registered";
      __int16 v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::LSTMOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::GRUOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GRUOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  unint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1970431790)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.gru";
      v8[3] = 7;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::GRUOp,void>::id)
  {
    return 0;
  }
  return result;
}

void sub_180D7BE48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D7BFFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D7C230(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D7C818(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,uint64_t a47,char a48)
{
  operator delete(v50);
  operator delete(v49);
  operator delete(v48);
  operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_180D7CA0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D7D000(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,uint64_t a47,char a48)
{
  operator delete(v50);
  operator delete(v49);
  operator delete(v48);
  operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_180D7D268(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D7D4C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t GPU::ScatterGenericOpHandler<mlir::mps::ScatterOp>::ScatterGenericOpHandler(uint64_t a1, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  uint64_t v5 = GPU::BaseOpHandler::BaseOpHandler((GPU::BaseOpHandler *)a1, a2, a3, a4);
  *(void *)uint64_t v5 = &unk_1EC9A0728;
  *((void *)v5 + 15) = 0;
  uint64_t v6 = *(void *)(*((void *)v5 + 3) + 48);
  __int16 v7 = *(void **)(v6 + 16);
  if (v7 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v25[0] = *(void *)(v6 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v25);
    if (v18 == 11 && *AttrData == 0x746163732E73706DLL && *(void *)((char *)AttrData + 3) == 0x726574746163732ELL)
    {
      __int16 v24 = 1283;
      v23[0] = (uint64_t)"classof on '";
      v23[2] = (uint64_t)"mps.scatter";
      v23[3] = 11;
      uint64_t v21 = "' failed due to the operation not being registered";
      __int16 v22 = 259;
      llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
      llvm::report_fatal_error((llvm::Twine *)v25, 1);
    }
LABEL_11:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::mps::ScatterOp,void>::id) {
    goto LABEL_11;
  }
  uint64_t v20 = *((void *)v5 + 3);
  id v8 = objc_alloc(MEMORY[0x1E4F358A0]);
  __int16 v9 = objc_msgSend(*(id *)(*(void *)(a1 + 16) + 48), "metalDevice", v20);
  v25[0] = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v20);
  uint64_t v10 = [v8 initWithDevice:v9 operation:mlir::AffineExpr::getKind((mlir::AffineExpr *)v25)];
  int v11 = *(void **)(a1 + 8);
  *(void *)(a1 + 8) = v10;

  id v12 = objc_alloc(MEMORY[0x1E4F35770]);
  uint64_t v13 = [*(id *)(*(void *)(a1 + 16) + 48) metalDevice];
  uint64_t v14 = [v12 initWithDevice:v13];
  uint64_t v15 = *(void **)(a1 + 120);
  *(void *)(a1 + 120) = v14;

  objc_msgSend(*(id *)(a1 + 8), "setOptions:", objc_msgSend(*(id *)(a1 + 8), "options") | 1);
  objc_msgSend(*(id *)(a1 + 120), "setOptions:", objc_msgSend(*(id *)(a1 + 120), "options") | 1);
  return a1;
}

void sub_180D7D74C(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)v1);
  _Unwind_Resume(a1);
}

void sub_180D7D770(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)v1);
  _Unwind_Resume(a1);
}

void GPU::ScatterOpHandler::encodeNDArrayOp(GPU::ScatterOpHandler *this, GPU::EncodeDescriptor *a2, NSArray *a3)
{
  v133[3] = *MEMORY[0x1E4F143B8];
  int v124 = a3;
  uint64_t v5 = *(void *)(*((void *)this + 3) + 48);
  uint64_t v6 = *(void **)(v5 + 16);
  if (v6 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v132[0] = *(void *)(v5 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v132);
    if (v117 == 11 && *AttrData == 0x746163732E73706DLL && *(void *)((char *)AttrData + 3) == 0x726574746163732ELL)
    {
      __int16 v131 = 1283;
      v130[0] = (uint64_t)"classof on '";
      v130[2] = (uint64_t)"mps.scatter";
      v130[3] = 11;
      unsigned int v128 = "' failed due to the operation not being registered";
      __int16 v129 = 259;
      llvm::operator+(v130, (uint64_t *)&v128, (uint64_t)v132);
      llvm::report_fatal_error((llvm::Twine *)v132, 1);
    }
LABEL_158:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v6 != &mlir::detail::TypeIDResolver<mlir::mps::ScatterOp,void>::id) {
    goto LABEL_158;
  }
  uint64_t v127 = *((void *)this + 3);
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v127);
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v127);
  uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v127);
  uint64_t v10 = (int8x8_t *)*((void *)this + 2);
  v132[0] = Input;
  ParentRegion = mlir::Value::getParentRegion((mlir::Value *)v132);
  int8x8_t v12 = v10[12];
  if (!*(void *)&v12) {
    goto LABEL_44;
  }
  unint64_t v13 = *((void *)ParentRegion + 2);
  unint64_t v14 = 0x9DDFEA08EB382D69 * (((8 * v13) + 8) ^ HIDWORD(v13));
  unint64_t v15 = 0x9DDFEA08EB382D69 * (HIDWORD(v13) ^ (v14 >> 47) ^ v14);
  unint64_t v16 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
  uint8x8_t v17 = (uint8x8_t)vcnt_s8(v12);
  v17.i16[0] = vaddlv_u8(v17);
  if (v17.u32[0] > 1uLL)
  {
    unint64_t v18 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
    if (v16 >= *(void *)&v12) {
      unint64_t v18 = v16 % *(void *)&v12;
    }
  }
  else
  {
    unint64_t v18 = v16 & (*(void *)&v12 - 1);
  }
  int v19 = *(void **)(*(void *)&v10[11] + 8 * v18);
  if (!v19) {
    goto LABEL_44;
  }
  uint64_t v20 = (void *)*v19;
  if (!v20) {
    goto LABEL_44;
  }
  if (v17.u32[0] < 2uLL)
  {
    uint64_t v21 = *(void *)&v12 - 1;
    while (1)
    {
      uint64_t v23 = v20[1];
      if (v23 == v16)
      {
        if (v20[2] == v13) {
          goto LABEL_24;
        }
      }
      else if ((v23 & v21) != v18)
      {
        goto LABEL_44;
      }
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        goto LABEL_44;
      }
    }
  }
  while (1)
  {
    unint64_t v22 = v20[1];
    if (v22 == v16) {
      break;
    }
    if (v22 >= *(void *)&v12) {
      v22 %= *(void *)&v12;
    }
    if (v22 != v18) {
      goto LABEL_44;
    }
LABEL_13:
    uint64_t v20 = (void *)*v20;
    if (!v20) {
      goto LABEL_44;
    }
  }
  if (v20[2] != v13) {
    goto LABEL_13;
  }
LABEL_24:
  int8x8_t v24 = (int8x8_t)v20[4];
  if (v24)
  {
    unint64_t v25 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v132[0])) + 8) ^ HIDWORD(v132[0]));
    unint64_t v26 = 0x9DDFEA08EB382D69 * (HIDWORD(v132[0]) ^ (v25 >> 47) ^ v25);
    unint64_t v27 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
    uint8x8_t v28 = (uint8x8_t)vcnt_s8(v24);
    v28.i16[0] = vaddlv_u8(v28);
    if (v28.u32[0] > 1uLL)
    {
      unint64_t v29 = v27;
      if (v27 >= *(void *)&v24) {
        unint64_t v29 = v27 % *(void *)&v24;
      }
    }
    else
    {
      unint64_t v29 = v27 & (*(void *)&v24 - 1);
    }
    uint64_t v30 = *(uint64_t ****)(v20[3] + 8 * v29);
    if (v30)
    {
      uint64_t v31 = *v30;
      if (v31)
      {
        if (v28.u32[0] < 2uLL)
        {
          uint64_t v32 = *(void *)&v24 - 1;
          while (1)
          {
            __int16 v35 = v31[1];
            if (v35 == (uint64_t *)v27)
            {
              if (v31[2] == (uint64_t *)v132[0]) {
                goto LABEL_146;
              }
            }
            else if (((unint64_t)v35 & v32) != v29)
            {
              goto LABEL_44;
            }
            uint64_t v33 = 0;
            uint64_t v31 = (uint64_t **)*v31;
            if (!v31) {
              goto LABEL_45;
            }
          }
        }
        while (1)
        {
          unint64_t v34 = (unint64_t)v31[1];
          if (v34 == v27)
          {
            if (v31[2] == (uint64_t *)v132[0])
            {
LABEL_146:
              uint64_t v33 = v31[3];
              goto LABEL_45;
            }
          }
          else
          {
            if (v34 >= *(void *)&v24) {
              v34 %= *(void *)&v24;
            }
            if (v34 != v29) {
              break;
            }
          }
          uint64_t v33 = 0;
          uint64_t v31 = (uint64_t **)*v31;
          if (!v31) {
            goto LABEL_45;
          }
        }
      }
    }
  }
LABEL_44:
  uint64_t v33 = 0;
LABEL_45:
  uint64_t v125 = [v33 mpsndarray];

  int v36 = (int8x8_t *)*((void *)this + 2);
  v132[0] = Filter;
  __int16 v37 = mlir::Value::getParentRegion((mlir::Value *)v132);
  int8x8_t v38 = v36[12];
  if (!*(void *)&v38) {
    goto LABEL_86;
  }
  unint64_t v39 = *((void *)v37 + 2);
  unint64_t v40 = 0x9DDFEA08EB382D69 * (((8 * v39) + 8) ^ HIDWORD(v39));
  unint64_t v41 = 0x9DDFEA08EB382D69 * (HIDWORD(v39) ^ (v40 >> 47) ^ v40);
  unint64_t v42 = 0x9DDFEA08EB382D69 * (v41 ^ (v41 >> 47));
  uint8x8_t v43 = (uint8x8_t)vcnt_s8(v38);
  v43.i16[0] = vaddlv_u8(v43);
  if (v43.u32[0] > 1uLL)
  {
    unint64_t v44 = 0x9DDFEA08EB382D69 * (v41 ^ (v41 >> 47));
    if (v42 >= *(void *)&v38) {
      unint64_t v44 = v42 % *(void *)&v38;
    }
  }
  else
  {
    unint64_t v44 = v42 & (*(void *)&v38 - 1);
  }
  uint64_t v45 = *(void **)(*(void *)&v36[11] + 8 * v44);
  if (!v45) {
    goto LABEL_86;
  }
  uint64_t v46 = (void *)*v45;
  if (!v46) {
    goto LABEL_86;
  }
  if (v43.u32[0] < 2uLL)
  {
    uint64_t v47 = *(void *)&v38 - 1;
    while (1)
    {
      uint64_t v49 = v46[1];
      if (v49 == v42)
      {
        if (v46[2] == v39) {
          goto LABEL_66;
        }
      }
      else if ((v49 & v47) != v44)
      {
        goto LABEL_86;
      }
      uint64_t v46 = (void *)*v46;
      if (!v46) {
        goto LABEL_86;
      }
    }
  }
  while (2)
  {
    unint64_t v48 = v46[1];
    if (v48 != v42)
    {
      if (v48 >= *(void *)&v38) {
        v48 %= *(void *)&v38;
      }
      if (v48 != v44) {
        goto LABEL_86;
      }
      goto LABEL_55;
    }
    if (v46[2] != v39)
    {
LABEL_55:
      uint64_t v46 = (void *)*v46;
      if (!v46) {
        goto LABEL_86;
      }
      continue;
    }
    break;
  }
LABEL_66:
  int8x8_t v50 = (int8x8_t)v46[4];
  if (v50)
  {
    unint64_t v51 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v132[0])) + 8) ^ HIDWORD(v132[0]));
    unint64_t v52 = 0x9DDFEA08EB382D69 * (HIDWORD(v132[0]) ^ (v51 >> 47) ^ v51);
    unint64_t v53 = 0x9DDFEA08EB382D69 * (v52 ^ (v52 >> 47));
    uint8x8_t v54 = (uint8x8_t)vcnt_s8(v50);
    v54.i16[0] = vaddlv_u8(v54);
    if (v54.u32[0] > 1uLL)
    {
      unint64_t v55 = v53;
      if (v53 >= *(void *)&v50) {
        unint64_t v55 = v53 % *(void *)&v50;
      }
    }
    else
    {
      unint64_t v55 = v53 & (*(void *)&v50 - 1);
    }
    int64_t v56 = *(uint64_t ****)(v46[3] + 8 * v55);
    if (v56)
    {
      uint64_t v57 = *v56;
      if (v57)
      {
        if (v54.u32[0] < 2uLL)
        {
          uint64_t v58 = *(void *)&v50 - 1;
          while (1)
          {
            uint64_t v61 = v57[1];
            if (v61 == (uint64_t *)v53)
            {
              if (v57[2] == (uint64_t *)v132[0]) {
                goto LABEL_147;
              }
            }
            else if (((unint64_t)v61 & v58) != v55)
            {
              goto LABEL_86;
            }
            uint64_t v59 = 0;
            uint64_t v57 = (uint64_t **)*v57;
            if (!v57) {
              goto LABEL_87;
            }
          }
        }
        while (1)
        {
          unint64_t v60 = (unint64_t)v57[1];
          if (v60 == v53)
          {
            if (v57[2] == (uint64_t *)v132[0])
            {
LABEL_147:
              uint64_t v59 = v57[3];
              goto LABEL_87;
            }
          }
          else
          {
            if (v60 >= *(void *)&v50) {
              v60 %= *(void *)&v50;
            }
            if (v60 != v55) {
              break;
            }
          }
          uint64_t v59 = 0;
          uint64_t v57 = (uint64_t **)*v57;
          if (!v57) {
            goto LABEL_87;
          }
        }
      }
    }
  }
LABEL_86:
  uint64_t v59 = 0;
LABEL_87:
  uint64_t v126 = [v59 mpsndarray];

  unint64_t v62 = (int8x8_t *)*((void *)this + 2);
  v132[0] = Bias;
  uint64_t v63 = mlir::Value::getParentRegion((mlir::Value *)v132);
  int8x8_t v64 = v62[12];
  if (!*(void *)&v64) {
    goto LABEL_128;
  }
  unint64_t v65 = *((void *)v63 + 2);
  unint64_t v66 = 0x9DDFEA08EB382D69 * (((8 * v65) + 8) ^ HIDWORD(v65));
  unint64_t v67 = 0x9DDFEA08EB382D69 * (HIDWORD(v65) ^ (v66 >> 47) ^ v66);
  unint64_t v68 = 0x9DDFEA08EB382D69 * (v67 ^ (v67 >> 47));
  uint8x8_t v69 = (uint8x8_t)vcnt_s8(v64);
  v69.i16[0] = vaddlv_u8(v69);
  if (v69.u32[0] > 1uLL)
  {
    unint64_t v70 = 0x9DDFEA08EB382D69 * (v67 ^ (v67 >> 47));
    if (v68 >= *(void *)&v64) {
      unint64_t v70 = v68 % *(void *)&v64;
    }
  }
  else
  {
    unint64_t v70 = v68 & (*(void *)&v64 - 1);
  }
  uint64_t v71 = *(void **)(*(void *)&v62[11] + 8 * v70);
  if (!v71) {
    goto LABEL_128;
  }
  uint64_t v72 = (void *)*v71;
  if (!v72) {
    goto LABEL_128;
  }
  if (v69.u32[0] < 2uLL)
  {
    uint64_t v73 = *(void *)&v64 - 1;
    while (1)
    {
      uint64_t v75 = v72[1];
      if (v75 == v68)
      {
        if (v72[2] == v65) {
          goto LABEL_108;
        }
      }
      else if ((v75 & v73) != v70)
      {
        goto LABEL_128;
      }
      uint64_t v72 = (void *)*v72;
      if (!v72) {
        goto LABEL_128;
      }
    }
  }
  while (1)
  {
    unint64_t v74 = v72[1];
    if (v74 == v68) {
      break;
    }
    if (v74 >= *(void *)&v64) {
      v74 %= *(void *)&v64;
    }
    if (v74 != v70) {
      goto LABEL_128;
    }
LABEL_97:
    uint64_t v72 = (void *)*v72;
    if (!v72) {
      goto LABEL_128;
    }
  }
  if (v72[2] != v65) {
    goto LABEL_97;
  }
LABEL_108:
  int8x8_t v76 = (int8x8_t)v72[4];
  if (!*(void *)&v76) {
    goto LABEL_128;
  }
  unint64_t v77 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v132[0])) + 8) ^ HIDWORD(v132[0]));
  unint64_t v78 = 0x9DDFEA08EB382D69 * (HIDWORD(v132[0]) ^ (v77 >> 47) ^ v77);
  unint64_t v79 = 0x9DDFEA08EB382D69 * (v78 ^ (v78 >> 47));
  uint8x8_t v80 = (uint8x8_t)vcnt_s8(v76);
  v80.i16[0] = vaddlv_u8(v80);
  if (v80.u32[0] > 1uLL)
  {
    unint64_t v81 = v79;
    if (v79 >= *(void *)&v76) {
      unint64_t v81 = v79 % *(void *)&v76;
    }
  }
  else
  {
    unint64_t v81 = v79 & (*(void *)&v76 - 1);
  }
  uint64_t v82 = *(uint64_t ****)(v72[3] + 8 * v81);
  if (!v82 || (uint64_t v83 = *v82) == 0)
  {
LABEL_128:
    uint64_t v85 = 0;
    goto LABEL_129;
  }
  if (v80.u32[0] < 2uLL)
  {
    uint64_t v84 = *(void *)&v76 - 1;
    while (1)
    {
      uint64_t v87 = v83[1];
      if (v87 == (uint64_t *)v79)
      {
        if (v83[2] == (uint64_t *)v132[0]) {
          goto LABEL_148;
        }
      }
      else if (((unint64_t)v87 & v84) != v81)
      {
        goto LABEL_128;
      }
      uint64_t v85 = 0;
      uint64_t v83 = (uint64_t **)*v83;
      if (!v83) {
        goto LABEL_129;
      }
    }
  }
  while (1)
  {
    unint64_t v86 = (unint64_t)v83[1];
    if (v86 == v79) {
      break;
    }
    if (v86 >= *(void *)&v76) {
      v86 %= *(void *)&v76;
    }
    if (v86 != v81) {
      goto LABEL_128;
    }
LABEL_118:
    uint64_t v85 = 0;
    uint64_t v83 = (uint64_t **)*v83;
    if (!v83) {
      goto LABEL_129;
    }
  }
  if (v83[2] != (uint64_t *)v132[0]) {
    goto LABEL_118;
  }
LABEL_148:
  uint64_t v85 = v83[3];
LABEL_129:
  uint64_t v88 = [v85 mpsndarray];

  int v120 = [(NSArray *)v124 objectAtIndexedSubscript:0];
  uint64_t v122 = [v120 mpsndarray];
  if ((!v122 || !v125 || !v126 || !v88) && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  uint64_t v123 = [v88 descriptor];
  uint64_t v121 = [v126 descriptor];
  uint64_t v89 = [v121 numberOfDimensions];
  Sparseuint64_t Shape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v127);
  uint64_t Axis = RuntimeUtils::getAxis(SparseShape, v89);
  uint64_t v119 = [v123 getShape];
  uint64_t v92 = RuntimeUtils::expandShape(v119, 1, 1);
  uint64_t v93 = RuntimeUtils::expandShape(v92, 0, Axis);

  id v94 = *((id *)this + 15);
  uint64_t v95 = (void *)*((void *)a2 + 9);
  if (!v95)
  {
    uint64_t v96 = [objc_alloc(MEMORY[0x1E4F35528]) initWithCommandBuffer:*((void *)a2 + 1) withDispatchType:0];
    uint64_t v97 = (void *)*((void *)a2 + 9);
    *((void *)a2 + 9) = v96;

    uint64_t v98 = (void *)*((void *)a2 + 11);
    uint64_t v95 = (void *)*((void *)a2 + 9);
    if (v98)
    {
      uint64_t v99 = [v98 wrapComputeEncoder:*((void *)a2 + 9)];
      uint64_t v100 = (void *)*((void *)a2 + 9);
      *((void *)a2 + 9) = v99;

      uint64_t v95 = (void *)*((void *)a2 + 9);
    }
  }
  if (*((void *)a2 + 10))
  {
    objc_msgSend(v95, "setLabel:");
    uint64_t v95 = (void *)*((void *)a2 + 9);
  }
  id v101 = v95;
  uint64_t v102 = [v94 reshapeWithCommandEncoder:v101 commandBuffer:*((void *)a2 + 1) sourceArray:v88 shape:v93 destinationArray:0];

  if (!v102)
  {
    char v103 = objc_msgSend(MEMORY[0x1E4F35720], "descriptorWithDataType:shape:", objc_msgSend(v88, "dataType"), v93);
    [v103 setPreferPackedRows:1];
    uint64_t v102 = [MEMORY[0x1E4F35988] temporaryNDArrayWithCommandBuffer:*((void *)a2 + 1) descriptor:v103];
    uint64_t v104 = GPU::EncodeDescriptor::getcomputeEncoder(a2);
    id v105 = (id)[v94 reshapeWithCommandEncoder:v104 commandBuffer:*((void *)a2 + 1) sourceArray:v88 shape:v93 destinationArray:v102];
  }
  id v106 = *((id *)this + 1);
  [v106 setBatchDimensions:Axis];
  __int16 v107 = (void *)*((void *)a2 + 9);
  if (!v107)
  {
    uint64_t v108 = [objc_alloc(MEMORY[0x1E4F35528]) initWithCommandBuffer:*((void *)a2 + 1) withDispatchType:0];
    uint64_t v109 = (void *)*((void *)a2 + 9);
    *((void *)a2 + 9) = v108;

    uint64_t v110 = (void *)*((void *)a2 + 11);
    __int16 v107 = (void *)*((void *)a2 + 9);
    if (v110)
    {
      uint64_t v111 = [v110 wrapComputeEncoder:*((void *)a2 + 9)];
      uint64_t v112 = (void *)*((void *)a2 + 9);
      *((void *)a2 + 9) = v111;

      __int16 v107 = (void *)*((void *)a2 + 9);
    }
  }
  if (*((void *)a2 + 10))
  {
    objc_msgSend(v107, "setLabel:");
    __int16 v107 = (void *)*((void *)a2 + 9);
  }
  id v113 = v107;
  uint64_t v114 = *((void *)a2 + 1);
  v133[0] = v125;
  v133[1] = v126;
  v133[2] = v102;
  uint64_t v115 = [MEMORY[0x1E4F1C978] arrayWithObjects:v133 count:3];
  [v106 encodeToMPSCommandEncoder:v113 commandBuffer:v114 sourceArrays:v115 destinationArray:v122];
}

void sub_180D7E320(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, uint64_t a14, void *a15, void *a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t GPU::ScatterGenericOpHandler<mlir::mps::ScatterAlongAxisOp>::ScatterGenericOpHandler(uint64_t a1, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  uint64_t v5 = GPU::BaseOpHandler::BaseOpHandler((GPU::BaseOpHandler *)a1, a2, a3, a4);
  *(void *)uint64_t v5 = &unk_1EC9A06D8;
  *((void *)v5 + 15) = 0;
  uint64_t v6 = *(void *)(*((void *)v5 + 3) + 48);
  __int16 v7 = *(void **)(v6 + 16);
  if (v7 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v26[0] = *(void *)(v6 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v26);
    if (v18 == 22
      && *AttrData == 0x746163732E73706DLL
      && AttrData[1] == 0x6E6F6C615F726574
      && *(void *)((char *)AttrData + 14) == 0x736978615F676E6FLL)
    {
      __int16 v25 = 1283;
      v24[0] = (uint64_t)"classof on '";
      v24[2] = (uint64_t)"mps.scatter_along_axis";
      v24[3] = 22;
      unint64_t v22 = "' failed due to the operation not being registered";
      __int16 v23 = 259;
      llvm::operator+(v24, (uint64_t *)&v22, (uint64_t)v26);
      llvm::report_fatal_error((llvm::Twine *)v26, 1);
    }
LABEL_14:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::mps::ScatterAlongAxisOp,void>::id) {
    goto LABEL_14;
  }
  uint64_t v21 = *((void *)v5 + 3);
  id v8 = objc_alloc(MEMORY[0x1E4F358A0]);
  __int16 v9 = objc_msgSend(*(id *)(*(void *)(a1 + 16) + 48), "metalDevice", v21);
  v26[0] = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v21);
  uint64_t v10 = [v8 initWithDevice:v9 operation:mlir::AffineExpr::getKind((mlir::AffineExpr *)v26)];
  int v11 = *(void **)(a1 + 8);
  *(void *)(a1 + 8) = v10;

  id v12 = objc_alloc(MEMORY[0x1E4F35770]);
  unint64_t v13 = [*(id *)(*(void *)(a1 + 16) + 48) metalDevice];
  uint64_t v14 = [v12 initWithDevice:v13];
  unint64_t v15 = *(void **)(a1 + 120);
  *(void *)(a1 + 120) = v14;

  objc_msgSend(*(id *)(a1 + 8), "setOptions:", objc_msgSend(*(id *)(a1 + 8), "options") | 1);
  objc_msgSend(*(id *)(a1 + 120), "setOptions:", objc_msgSend(*(id *)(a1 + 120), "options") | 1);
  return a1;
}

void sub_180D7E6B8(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)v1);
  _Unwind_Resume(a1);
}

void sub_180D7E6DC(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)v1);
  _Unwind_Resume(a1);
}

void GPU::ScatterAlongAxisOpHandler::encodeNDArrayOp(GPU::ScatterAlongAxisOpHandler *this, GPU::EncodeDescriptor *a2, NSArray *a3)
{
  v173[3] = *MEMORY[0x1E4F143B8];
  unint64_t v158 = a3;
  uint64_t v166 = this;
  uint64_t v5 = *(void *)(*((void *)this + 3) + 48);
  uint64_t v6 = *(void **)(v5 + 16);
  if (v6 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v172[0] = *(void *)(v5 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v172);
    if (v153 == 22)
    {
      BOOL v154 = *AttrData == 0x746163732E73706DLL && AttrData[1] == 0x6E6F6C615F726574;
      if (v154 && *(void *)((char *)AttrData + 14) == 0x736978615F676E6FLL)
      {
        __int16 v171 = 1283;
        v170[0] = (uint64_t)"classof on '";
        v170[2] = (uint64_t)"mps.scatter_along_axis";
        v170[3] = 22;
        uint64_t v168 = "' failed due to the operation not being registered";
        __int16 v169 = 259;
        llvm::operator+(v170, (uint64_t *)&v168, (uint64_t)v172);
        llvm::report_fatal_error((llvm::Twine *)v172, 1);
      }
    }
LABEL_186:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v6 != &mlir::detail::TypeIDResolver<mlir::mps::ScatterAlongAxisOp,void>::id) {
    goto LABEL_186;
  }
  uint64_t v167 = *((void *)this + 3);
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v167);
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v167);
  uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v167);
  uint64_t v10 = (int8x8_t *)*((void *)v166 + 2);
  v172[0] = Input;
  ParentRegion = mlir::Value::getParentRegion((mlir::Value *)v172);
  int8x8_t v12 = v10[12];
  if (!*(void *)&v12) {
    goto LABEL_44;
  }
  unint64_t v13 = *((void *)ParentRegion + 2);
  unint64_t v14 = 0x9DDFEA08EB382D69 * (((8 * v13) + 8) ^ HIDWORD(v13));
  unint64_t v15 = 0x9DDFEA08EB382D69 * (HIDWORD(v13) ^ (v14 >> 47) ^ v14);
  unint64_t v16 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
  uint8x8_t v17 = (uint8x8_t)vcnt_s8(v12);
  v17.i16[0] = vaddlv_u8(v17);
  if (v17.u32[0] > 1uLL)
  {
    unint64_t v18 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
    if (v16 >= *(void *)&v12) {
      unint64_t v18 = v16 % *(void *)&v12;
    }
  }
  else
  {
    unint64_t v18 = v16 & (*(void *)&v12 - 1);
  }
  int v19 = *(void **)(*(void *)&v10[11] + 8 * v18);
  if (!v19) {
    goto LABEL_44;
  }
  uint64_t v20 = (void *)*v19;
  if (!v20) {
    goto LABEL_44;
  }
  if (v17.u32[0] < 2uLL)
  {
    uint64_t v21 = *(void *)&v12 - 1;
    while (1)
    {
      uint64_t v23 = v20[1];
      if (v23 == v16)
      {
        if (v20[2] == v13) {
          goto LABEL_24;
        }
      }
      else if ((v23 & v21) != v18)
      {
        goto LABEL_44;
      }
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        goto LABEL_44;
      }
    }
  }
  while (1)
  {
    unint64_t v22 = v20[1];
    if (v22 == v16) {
      break;
    }
    if (v22 >= *(void *)&v12) {
      v22 %= *(void *)&v12;
    }
    if (v22 != v18) {
      goto LABEL_44;
    }
LABEL_13:
    uint64_t v20 = (void *)*v20;
    if (!v20) {
      goto LABEL_44;
    }
  }
  if (v20[2] != v13) {
    goto LABEL_13;
  }
LABEL_24:
  int8x8_t v24 = (int8x8_t)v20[4];
  if (v24)
  {
    unint64_t v25 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v172[0])) + 8) ^ HIDWORD(v172[0]));
    unint64_t v26 = 0x9DDFEA08EB382D69 * (HIDWORD(v172[0]) ^ (v25 >> 47) ^ v25);
    unint64_t v27 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
    uint8x8_t v28 = (uint8x8_t)vcnt_s8(v24);
    v28.i16[0] = vaddlv_u8(v28);
    if (v28.u32[0] > 1uLL)
    {
      unint64_t v29 = v27;
      if (v27 >= *(void *)&v24) {
        unint64_t v29 = v27 % *(void *)&v24;
      }
    }
    else
    {
      unint64_t v29 = v27 & (*(void *)&v24 - 1);
    }
    uint64_t v30 = *(uint64_t ****)(v20[3] + 8 * v29);
    if (v30)
    {
      uint64_t v31 = *v30;
      if (v31)
      {
        if (v28.u32[0] < 2uLL)
        {
          uint64_t v32 = *(void *)&v24 - 1;
          while (1)
          {
            __int16 v35 = v31[1];
            if (v35 == (uint64_t *)v27)
            {
              if (v31[2] == (uint64_t *)v172[0]) {
                goto LABEL_171;
              }
            }
            else if (((unint64_t)v35 & v32) != v29)
            {
              goto LABEL_44;
            }
            uint64_t v33 = 0;
            uint64_t v31 = (uint64_t **)*v31;
            if (!v31) {
              goto LABEL_45;
            }
          }
        }
        while (1)
        {
          unint64_t v34 = (unint64_t)v31[1];
          if (v34 == v27)
          {
            if (v31[2] == (uint64_t *)v172[0])
            {
LABEL_171:
              uint64_t v33 = v31[3];
              goto LABEL_45;
            }
          }
          else
          {
            if (v34 >= *(void *)&v24) {
              v34 %= *(void *)&v24;
            }
            if (v34 != v29) {
              break;
            }
          }
          uint64_t v33 = 0;
          uint64_t v31 = (uint64_t **)*v31;
          if (!v31) {
            goto LABEL_45;
          }
        }
      }
    }
  }
LABEL_44:
  uint64_t v33 = 0;
LABEL_45:
  int v36 = [v33 mpsndarray];

  __int16 v37 = (int8x8_t *)*((void *)v166 + 2);
  v172[0] = Filter;
  int8x8_t v38 = mlir::Value::getParentRegion((mlir::Value *)v172);
  int8x8_t v39 = v37[12];
  if (!*(void *)&v39) {
    goto LABEL_86;
  }
  unint64_t v40 = *((void *)v38 + 2);
  unint64_t v41 = 0x9DDFEA08EB382D69 * (((8 * v40) + 8) ^ HIDWORD(v40));
  unint64_t v42 = 0x9DDFEA08EB382D69 * (HIDWORD(v40) ^ (v41 >> 47) ^ v41);
  unint64_t v43 = 0x9DDFEA08EB382D69 * (v42 ^ (v42 >> 47));
  uint8x8_t v44 = (uint8x8_t)vcnt_s8(v39);
  v44.i16[0] = vaddlv_u8(v44);
  if (v44.u32[0] > 1uLL)
  {
    unint64_t v45 = 0x9DDFEA08EB382D69 * (v42 ^ (v42 >> 47));
    if (v43 >= *(void *)&v39) {
      unint64_t v45 = v43 % *(void *)&v39;
    }
  }
  else
  {
    unint64_t v45 = v43 & (*(void *)&v39 - 1);
  }
  uint64_t v46 = *(void **)(*(void *)&v37[11] + 8 * v45);
  if (!v46) {
    goto LABEL_86;
  }
  uint64_t v47 = (void *)*v46;
  if (!v47) {
    goto LABEL_86;
  }
  if (v44.u32[0] < 2uLL)
  {
    uint64_t v48 = *(void *)&v39 - 1;
    while (1)
    {
      uint64_t v50 = v47[1];
      if (v50 == v43)
      {
        if (v47[2] == v40) {
          goto LABEL_66;
        }
      }
      else if ((v50 & v48) != v45)
      {
        goto LABEL_86;
      }
      uint64_t v47 = (void *)*v47;
      if (!v47) {
        goto LABEL_86;
      }
    }
  }
  while (2)
  {
    unint64_t v49 = v47[1];
    if (v49 != v43)
    {
      if (v49 >= *(void *)&v39) {
        v49 %= *(void *)&v39;
      }
      if (v49 != v45) {
        goto LABEL_86;
      }
      goto LABEL_55;
    }
    if (v47[2] != v40)
    {
LABEL_55:
      uint64_t v47 = (void *)*v47;
      if (!v47) {
        goto LABEL_86;
      }
      continue;
    }
    break;
  }
LABEL_66:
  int8x8_t v51 = (int8x8_t)v47[4];
  if (v51)
  {
    unint64_t v52 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v172[0])) + 8) ^ HIDWORD(v172[0]));
    unint64_t v53 = 0x9DDFEA08EB382D69 * (HIDWORD(v172[0]) ^ (v52 >> 47) ^ v52);
    unint64_t v54 = 0x9DDFEA08EB382D69 * (v53 ^ (v53 >> 47));
    uint8x8_t v55 = (uint8x8_t)vcnt_s8(v51);
    v55.i16[0] = vaddlv_u8(v55);
    if (v55.u32[0] > 1uLL)
    {
      unint64_t v56 = v54;
      if (v54 >= *(void *)&v51) {
        unint64_t v56 = v54 % *(void *)&v51;
      }
    }
    else
    {
      unint64_t v56 = v54 & (*(void *)&v51 - 1);
    }
    uint64_t v57 = *(uint64_t ****)(v47[3] + 8 * v56);
    if (v57)
    {
      uint64_t v58 = *v57;
      if (v58)
      {
        if (v55.u32[0] < 2uLL)
        {
          uint64_t v59 = *(void *)&v51 - 1;
          while (1)
          {
            unint64_t v62 = v58[1];
            if (v62 == (uint64_t *)v54)
            {
              if (v58[2] == (uint64_t *)v172[0]) {
                goto LABEL_172;
              }
            }
            else if (((unint64_t)v62 & v59) != v56)
            {
              goto LABEL_86;
            }
            unint64_t v60 = 0;
            uint64_t v58 = (uint64_t **)*v58;
            if (!v58) {
              goto LABEL_87;
            }
          }
        }
        while (1)
        {
          unint64_t v61 = (unint64_t)v58[1];
          if (v61 == v54)
          {
            if (v58[2] == (uint64_t *)v172[0])
            {
LABEL_172:
              unint64_t v60 = v58[3];
              goto LABEL_87;
            }
          }
          else
          {
            if (v61 >= *(void *)&v51) {
              v61 %= *(void *)&v51;
            }
            if (v61 != v56) {
              break;
            }
          }
          unint64_t v60 = 0;
          uint64_t v58 = (uint64_t **)*v58;
          if (!v58) {
            goto LABEL_87;
          }
        }
      }
    }
  }
LABEL_86:
  unint64_t v60 = 0;
LABEL_87:
  uint64_t v63 = [v60 mpsndarray];

  int8x8_t v64 = (int8x8_t *)*((void *)v166 + 2);
  v172[0] = Bias;
  unint64_t v65 = mlir::Value::getParentRegion((mlir::Value *)v172);
  int8x8_t v66 = v64[12];
  if (!*(void *)&v66) {
    goto LABEL_128;
  }
  unint64_t v67 = *((void *)v65 + 2);
  unint64_t v68 = 0x9DDFEA08EB382D69 * (((8 * v67) + 8) ^ HIDWORD(v67));
  unint64_t v69 = 0x9DDFEA08EB382D69 * (HIDWORD(v67) ^ (v68 >> 47) ^ v68);
  unint64_t v70 = 0x9DDFEA08EB382D69 * (v69 ^ (v69 >> 47));
  uint8x8_t v71 = (uint8x8_t)vcnt_s8(v66);
  v71.i16[0] = vaddlv_u8(v71);
  if (v71.u32[0] > 1uLL)
  {
    unint64_t v72 = 0x9DDFEA08EB382D69 * (v69 ^ (v69 >> 47));
    if (v70 >= *(void *)&v66) {
      unint64_t v72 = v70 % *(void *)&v66;
    }
  }
  else
  {
    unint64_t v72 = v70 & (*(void *)&v66 - 1);
  }
  uint64_t v73 = *(void **)(*(void *)&v64[11] + 8 * v72);
  if (!v73) {
    goto LABEL_128;
  }
  unint64_t v74 = (void *)*v73;
  if (!v74) {
    goto LABEL_128;
  }
  if (v71.u32[0] < 2uLL)
  {
    uint64_t v75 = *(void *)&v66 - 1;
    while (1)
    {
      uint64_t v77 = v74[1];
      if (v77 == v70)
      {
        if (v74[2] == v67) {
          goto LABEL_108;
        }
      }
      else if ((v77 & v75) != v72)
      {
        goto LABEL_128;
      }
      unint64_t v74 = (void *)*v74;
      if (!v74) {
        goto LABEL_128;
      }
    }
  }
  while (1)
  {
    unint64_t v76 = v74[1];
    if (v76 == v70) {
      break;
    }
    if (v76 >= *(void *)&v66) {
      v76 %= *(void *)&v66;
    }
    if (v76 != v72) {
      goto LABEL_128;
    }
LABEL_97:
    unint64_t v74 = (void *)*v74;
    if (!v74) {
      goto LABEL_128;
    }
  }
  if (v74[2] != v67) {
    goto LABEL_97;
  }
LABEL_108:
  int8x8_t v78 = (int8x8_t)v74[4];
  if (!*(void *)&v78) {
    goto LABEL_128;
  }
  unint64_t v79 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v172[0])) + 8) ^ HIDWORD(v172[0]));
  unint64_t v80 = 0x9DDFEA08EB382D69 * (HIDWORD(v172[0]) ^ (v79 >> 47) ^ v79);
  unint64_t v81 = 0x9DDFEA08EB382D69 * (v80 ^ (v80 >> 47));
  uint8x8_t v82 = (uint8x8_t)vcnt_s8(v78);
  v82.i16[0] = vaddlv_u8(v82);
  if (v82.u32[0] > 1uLL)
  {
    unint64_t v83 = v81;
    if (v81 >= *(void *)&v78) {
      unint64_t v83 = v81 % *(void *)&v78;
    }
  }
  else
  {
    unint64_t v83 = v81 & (*(void *)&v78 - 1);
  }
  uint64_t v84 = *(uint64_t ****)(v74[3] + 8 * v83);
  if (!v84 || (uint64_t v85 = *v84) == 0)
  {
LABEL_128:
    uint64_t v87 = 0;
    goto LABEL_129;
  }
  if (v82.u32[0] < 2uLL)
  {
    uint64_t v86 = *(void *)&v78 - 1;
    while (1)
    {
      uint64_t v89 = v85[1];
      if (v89 == (uint64_t *)v81)
      {
        if (v85[2] == (uint64_t *)v172[0]) {
          goto LABEL_173;
        }
      }
      else if (((unint64_t)v89 & v86) != v83)
      {
        goto LABEL_128;
      }
      uint64_t v87 = 0;
      uint64_t v85 = (uint64_t **)*v85;
      if (!v85) {
        goto LABEL_129;
      }
    }
  }
  while (1)
  {
    unint64_t v88 = (unint64_t)v85[1];
    if (v88 == v81) {
      break;
    }
    if (v88 >= *(void *)&v78) {
      v88 %= *(void *)&v78;
    }
    if (v88 != v83) {
      goto LABEL_128;
    }
LABEL_118:
    uint64_t v87 = 0;
    uint64_t v85 = (uint64_t **)*v85;
    if (!v85) {
      goto LABEL_129;
    }
  }
  if (v85[2] != (uint64_t *)v172[0]) {
    goto LABEL_118;
  }
LABEL_173:
  uint64_t v87 = v85[3];
LABEL_129:
  BOOL v164 = [v87 mpsndarray];

  unint64_t v156 = [(NSArray *)v158 objectAtIndexedSubscript:0];
  uint64_t v90 = [v156 mpsndarray];
  if ((!v90 || !v36 || !v63 || !v164) && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  unint64_t v159 = [v36 descriptor];
  size_t v161 = [v63 descriptor];
  BOOL v162 = [v164 descriptor];
  uint64_t v160 = [v90 descriptor];
  uint64_t v157 = [v160 numberOfDimensions];
  uint64_t v91 = [v161 numberOfDimensions];
  Sparseuint64_t Shape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v167);
  uint64_t v93 = v91 + ~RuntimeUtils::getAxis(SparseShape, v91);
  if (v93)
  {
    [v159 transposeDimension:0 withDimension:v93];
    [v161 transposeDimension:0 withDimension:v93];
    [v162 transposeDimension:0 withDimension:v93];
    [v160 transposeDimension:0 withDimension:v93];
    uint64_t v94 = *((void *)a2 + 1);
    uint64_t v95 = (void *)*((void *)a2 + 9);
    if (!v95)
    {
      uint64_t v96 = [objc_alloc(MEMORY[0x1E4F35528]) initWithCommandBuffer:*((void *)a2 + 1) withDispatchType:0];
      uint64_t v97 = (void *)*((void *)a2 + 9);
      *((void *)a2 + 9) = v96;

      uint64_t v98 = (void *)*((void *)a2 + 11);
      uint64_t v95 = (void *)*((void *)a2 + 9);
      if (v98)
      {
        uint64_t v99 = [v98 wrapComputeEncoder:*((void *)a2 + 9)];
        uint64_t v100 = (void *)*((void *)a2 + 9);
        *((void *)a2 + 9) = v99;

        uint64_t v95 = (void *)*((void *)a2 + 9);
      }
    }
    if (*((void *)a2 + 10))
    {
      objc_msgSend(v95, "setLabel:");
      uint64_t v95 = (void *)*((void *)a2 + 9);
    }
    id v101 = v95;
    int v165 = [v36 safeArrayViewWithCommandBuffer:v94 computeEncoder:v101 descriptor:v159 aliasing:1];

    uint64_t v102 = *((void *)a2 + 1);
    char v103 = (void *)*((void *)a2 + 9);
    if (!v103)
    {
      uint64_t v104 = [objc_alloc(MEMORY[0x1E4F35528]) initWithCommandBuffer:*((void *)a2 + 1) withDispatchType:0];
      id v105 = (void *)*((void *)a2 + 9);
      *((void *)a2 + 9) = v104;

      id v106 = (void *)*((void *)a2 + 11);
      char v103 = (void *)*((void *)a2 + 9);
      if (v106)
      {
        uint64_t v107 = [v106 wrapComputeEncoder:*((void *)a2 + 9)];
        uint64_t v108 = (void *)*((void *)a2 + 9);
        *((void *)a2 + 9) = v107;

        char v103 = (void *)*((void *)a2 + 9);
      }
    }
    if (*((void *)a2 + 10))
    {
      objc_msgSend(v103, "setLabel:");
      char v103 = (void *)*((void *)a2 + 9);
    }
    id v109 = v103;
    uint64_t v163 = [v63 safeArrayViewWithCommandBuffer:v102 computeEncoder:v109 descriptor:v161 aliasing:1];

    if (*((unsigned char *)v90 + (int)*MEMORY[0x1E4F359C0])) {
      objc_msgSend(v90, "setReadCount:", objc_msgSend(v90, "readCount") + 1);
    }
    uint64_t v110 = *((void *)a2 + 1);
    uint64_t v111 = (void *)*((void *)a2 + 9);
    if (!v111)
    {
      uint64_t v112 = [objc_alloc(MEMORY[0x1E4F35528]) initWithCommandBuffer:*((void *)a2 + 1) withDispatchType:0];
      id v113 = (void *)*((void *)a2 + 9);
      *((void *)a2 + 9) = v112;

      uint64_t v114 = (void *)*((void *)a2 + 11);
      uint64_t v111 = (void *)*((void *)a2 + 9);
      if (v114)
      {
        uint64_t v115 = [v114 wrapComputeEncoder:*((void *)a2 + 9)];
        uint64_t v116 = (void *)*((void *)a2 + 9);
        *((void *)a2 + 9) = v115;

        uint64_t v111 = (void *)*((void *)a2 + 9);
      }
    }
    if (*((void *)a2 + 10))
    {
      objc_msgSend(v111, "setLabel:");
      uint64_t v111 = (void *)*((void *)a2 + 9);
    }
    id v117 = v111;
    uint64_t v118 = [v90 safeArrayViewWithCommandBuffer:v110 computeEncoder:v117 descriptor:v160 aliasing:1];

    uint64_t v90 = (void *)v118;
  }
  else
  {
    uint64_t v163 = v63;
    int v165 = v36;
  }
  uint64_t v119 = [v162 getShape];
  int v120 = RuntimeUtils::expandShape(v119, [v119 count], 1);
  uint64_t v121 = *((void *)a2 + 1);
  uint64_t v122 = (void *)*((void *)a2 + 9);
  if (!v122)
  {
    uint64_t v123 = [objc_alloc(MEMORY[0x1E4F35528]) initWithCommandBuffer:*((void *)a2 + 1) withDispatchType:0];
    int v124 = (void *)*((void *)a2 + 9);
    *((void *)a2 + 9) = v123;

    uint64_t v125 = (void *)*((void *)a2 + 11);
    uint64_t v122 = (void *)*((void *)a2 + 9);
    if (v125)
    {
      uint64_t v126 = [v125 wrapComputeEncoder:*((void *)a2 + 9)];
      uint64_t v127 = (void *)*((void *)a2 + 9);
      *((void *)a2 + 9) = v126;

      uint64_t v122 = (void *)*((void *)a2 + 9);
    }
  }
  if (*((void *)a2 + 10))
  {
    objc_msgSend(v122, "setLabel:");
    uint64_t v122 = (void *)*((void *)a2 + 9);
  }
  id v128 = v122;
  __int16 v129 = [v164 safeArrayViewWithCommandBuffer:v121 computeEncoder:v128 descriptor:v162 aliasing:1];

  id v130 = *((id *)v166 + 15);
  __int16 v131 = (void *)*((void *)a2 + 9);
  if (!v131)
  {
    uint64_t v132 = [objc_alloc(MEMORY[0x1E4F35528]) initWithCommandBuffer:*((void *)a2 + 1) withDispatchType:0];
    unsigned int v133 = (void *)*((void *)a2 + 9);
    *((void *)a2 + 9) = v132;

    std::string v134 = (void *)*((void *)a2 + 11);
    __int16 v131 = (void *)*((void *)a2 + 9);
    if (v134)
    {
      uint64_t v135 = [v134 wrapComputeEncoder:*((void *)a2 + 9)];
      uint64_t v136 = (void *)*((void *)a2 + 9);
      *((void *)a2 + 9) = v135;

      __int16 v131 = (void *)*((void *)a2 + 9);
    }
  }
  if (*((void *)a2 + 10))
  {
    objc_msgSend(v131, "setLabel:");
    __int16 v131 = (void *)*((void *)a2 + 9);
  }
  id v137 = v131;
  uint64_t v138 = [v130 reshapeWithCommandEncoder:v137 commandBuffer:*((void *)a2 + 1) sourceArray:v129 shape:v120 destinationArray:0];

  if (!v138)
  {
    uint64_t v139 = objc_msgSend(MEMORY[0x1E4F35720], "descriptorWithDataType:shape:", objc_msgSend(v164, "dataType"), v120);
    [v139 setPreferPackedRows:1];
    uint64_t v138 = [MEMORY[0x1E4F35988] temporaryNDArrayWithCommandBuffer:*((void *)a2 + 1) descriptor:v139];
    uint64_t v140 = GPU::EncodeDescriptor::getcomputeEncoder(a2);
    id v141 = (id)[v130 reshapeWithCommandEncoder:v140 commandBuffer:*((void *)a2 + 1) sourceArray:v164 shape:v120 destinationArray:v138];
  }
  id v142 = *((id *)v166 + 1);
  [v142 setBatchDimensions:v157 - 1];
  uint64_t v143 = (void *)*((void *)a2 + 9);
  if (!v143)
  {
    uint64_t v144 = [objc_alloc(MEMORY[0x1E4F35528]) initWithCommandBuffer:*((void *)a2 + 1) withDispatchType:0];
    uint64_t v145 = (void *)*((void *)a2 + 9);
    *((void *)a2 + 9) = v144;

    unint64_t v146 = (void *)*((void *)a2 + 11);
    uint64_t v143 = (void *)*((void *)a2 + 9);
    if (v146)
    {
      uint64_t v147 = [v146 wrapComputeEncoder:*((void *)a2 + 9)];
      uint64_t v148 = (void *)*((void *)a2 + 9);
      *((void *)a2 + 9) = v147;

      uint64_t v143 = (void *)*((void *)a2 + 9);
    }
  }
  if (*((void *)a2 + 10))
  {
    objc_msgSend(v143, "setLabel:");
    uint64_t v143 = (void *)*((void *)a2 + 9);
  }
  id v149 = v143;
  uint64_t v150 = *((void *)a2 + 1);
  v173[0] = v165;
  v173[1] = v163;
  v173[2] = v138;
  char v151 = [MEMORY[0x1E4F1C978] arrayWithObjects:v173 count:3];
  [v142 encodeToMPSCommandEncoder:v149 commandBuffer:v150 sourceArrays:v151 destinationArray:v90];
}

void sub_180D7F638(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, _Unwind_Exception *exception_object)
{
  _Unwind_Resume(a1);
}

uint64_t GPU::ScatterGenericOpHandler<mlir::mps::ScatterNDOp>::ScatterGenericOpHandler(uint64_t a1, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  uint64_t v5 = GPU::BaseOpHandler::BaseOpHandler((GPU::BaseOpHandler *)a1, a2, a3, a4);
  *(void *)uint64_t v5 = &unk_1EC9A0688;
  *((void *)v5 + 15) = 0;
  uint64_t v6 = *(void *)(*((void *)v5 + 3) + 48);
  __int16 v7 = *(void **)(v6 + 16);
  if (v7 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v25[0] = *(void *)(v6 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v25);
    if (v18 == 14 && *AttrData == 0x746163732E73706DLL && *(void *)((char *)AttrData + 6) == 0x646E5F7265747461)
    {
      __int16 v24 = 1283;
      v23[0] = (uint64_t)"classof on '";
      v23[2] = (uint64_t)"mps.scatter_nd";
      v23[3] = 14;
      uint64_t v21 = "' failed due to the operation not being registered";
      __int16 v22 = 259;
      llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
      llvm::report_fatal_error((llvm::Twine *)v25, 1);
    }
LABEL_11:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::mps::ScatterNDOp,void>::id) {
    goto LABEL_11;
  }
  uint64_t v20 = *((void *)v5 + 3);
  id v8 = objc_alloc(MEMORY[0x1E4F358A0]);
  __int16 v9 = objc_msgSend(*(id *)(*(void *)(a1 + 16) + 48), "metalDevice", v20);
  v25[0] = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v20);
  uint64_t v10 = [v8 initWithDevice:v9 operation:mlir::AffineExpr::getKind((mlir::AffineExpr *)v25)];
  int v11 = *(void **)(a1 + 8);
  *(void *)(a1 + 8) = v10;

  id v12 = objc_alloc(MEMORY[0x1E4F35770]);
  unint64_t v13 = [*(id *)(*(void *)(a1 + 16) + 48) metalDevice];
  uint64_t v14 = [v12 initWithDevice:v13];
  unint64_t v15 = *(void **)(a1 + 120);
  *(void *)(a1 + 120) = v14;

  objc_msgSend(*(id *)(a1 + 8), "setOptions:", objc_msgSend(*(id *)(a1 + 8), "options") | 1);
  objc_msgSend(*(id *)(a1 + 120), "setOptions:", objc_msgSend(*(id *)(a1 + 120), "options") | 1);
  return a1;
}

void sub_180D7FA04(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)v1);
  _Unwind_Resume(a1);
}

void sub_180D7FA28(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)v1);
  _Unwind_Resume(a1);
}

void GPU::ScatterNDOpHandler::encodeNDArrayOp(GPU::ScatterNDOpHandler *this, GPU::EncodeDescriptor *a2, NSArray *a3)
{
  v113[3] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a3;
  uint64_t v6 = *(void *)(*((void *)this + 3) + 48);
  __int16 v7 = *(void **)(v6 + 16);
  if (v7 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v112[0] = *(void *)(v6 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v112);
    if (v105 == 14 && *AttrData == 0x746163732E73706DLL && *(void *)((char *)AttrData + 6) == 0x646E5F7265747461)
    {
      __int16 v111 = 1283;
      v110[0] = (uint64_t)"classof on '";
      v110[2] = (uint64_t)"mps.scatter_nd";
      v110[3] = 14;
      uint64_t v108 = "' failed due to the operation not being registered";
      __int16 v109 = 259;
      llvm::operator+(v110, (uint64_t *)&v108, (uint64_t)v112);
      llvm::report_fatal_error((llvm::Twine *)v112, 1);
    }
LABEL_151:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::mps::ScatterNDOp,void>::id) {
    goto LABEL_151;
  }
  uint64_t v107 = *((void *)this + 3);
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v107);
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v107);
  uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v107);
  int v11 = (int8x8_t *)*((void *)this + 2);
  v112[0] = Input;
  ParentRegion = mlir::Value::getParentRegion((mlir::Value *)v112);
  int8x8_t v13 = v11[12];
  if (!*(void *)&v13) {
    goto LABEL_44;
  }
  unint64_t v14 = *((void *)ParentRegion + 2);
  unint64_t v15 = 0x9DDFEA08EB382D69 * (((8 * v14) + 8) ^ HIDWORD(v14));
  unint64_t v16 = 0x9DDFEA08EB382D69 * (HIDWORD(v14) ^ (v15 >> 47) ^ v15);
  unint64_t v17 = 0x9DDFEA08EB382D69 * (v16 ^ (v16 >> 47));
  uint8x8_t v18 = (uint8x8_t)vcnt_s8(v13);
  v18.i16[0] = vaddlv_u8(v18);
  if (v18.u32[0] > 1uLL)
  {
    unint64_t v19 = 0x9DDFEA08EB382D69 * (v16 ^ (v16 >> 47));
    if (v17 >= *(void *)&v13) {
      unint64_t v19 = v17 % *(void *)&v13;
    }
  }
  else
  {
    unint64_t v19 = v17 & (*(void *)&v13 - 1);
  }
  uint64_t v20 = *(void **)(*(void *)&v11[11] + 8 * v19);
  if (!v20) {
    goto LABEL_44;
  }
  uint64_t v21 = (void *)*v20;
  if (!v21) {
    goto LABEL_44;
  }
  if (v18.u32[0] < 2uLL)
  {
    uint64_t v22 = *(void *)&v13 - 1;
    while (1)
    {
      uint64_t v24 = v21[1];
      if (v24 == v17)
      {
        if (v21[2] == v14) {
          goto LABEL_24;
        }
      }
      else if ((v24 & v22) != v19)
      {
        goto LABEL_44;
      }
      uint64_t v21 = (void *)*v21;
      if (!v21) {
        goto LABEL_44;
      }
    }
  }
  while (1)
  {
    unint64_t v23 = v21[1];
    if (v23 == v17) {
      break;
    }
    if (v23 >= *(void *)&v13) {
      v23 %= *(void *)&v13;
    }
    if (v23 != v19) {
      goto LABEL_44;
    }
LABEL_13:
    uint64_t v21 = (void *)*v21;
    if (!v21) {
      goto LABEL_44;
    }
  }
  if (v21[2] != v14) {
    goto LABEL_13;
  }
LABEL_24:
  int8x8_t v25 = (int8x8_t)v21[4];
  if (v25)
  {
    unint64_t v26 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v112[0])) + 8) ^ HIDWORD(v112[0]));
    unint64_t v27 = 0x9DDFEA08EB382D69 * (HIDWORD(v112[0]) ^ (v26 >> 47) ^ v26);
    unint64_t v28 = 0x9DDFEA08EB382D69 * (v27 ^ (v27 >> 47));
    uint8x8_t v29 = (uint8x8_t)vcnt_s8(v25);
    v29.i16[0] = vaddlv_u8(v29);
    if (v29.u32[0] > 1uLL)
    {
      unint64_t v30 = v28;
      if (v28 >= *(void *)&v25) {
        unint64_t v30 = v28 % *(void *)&v25;
      }
    }
    else
    {
      unint64_t v30 = v28 & (*(void *)&v25 - 1);
    }
    uint64_t v31 = *(uint64_t ****)(v21[3] + 8 * v30);
    if (v31)
    {
      uint64_t v32 = *v31;
      if (v32)
      {
        if (v29.u32[0] < 2uLL)
        {
          uint64_t v33 = *(void *)&v25 - 1;
          while (1)
          {
            int v36 = v32[1];
            if (v36 == (uint64_t *)v28)
            {
              if (v32[2] == (uint64_t *)v112[0]) {
                goto LABEL_139;
              }
            }
            else if (((unint64_t)v36 & v33) != v30)
            {
              goto LABEL_44;
            }
            unint64_t v34 = 0;
            uint64_t v32 = (uint64_t **)*v32;
            if (!v32) {
              goto LABEL_45;
            }
          }
        }
        while (1)
        {
          unint64_t v35 = (unint64_t)v32[1];
          if (v35 == v28)
          {
            if (v32[2] == (uint64_t *)v112[0])
            {
LABEL_139:
              unint64_t v34 = v32[3];
              goto LABEL_45;
            }
          }
          else
          {
            if (v35 >= *(void *)&v25) {
              v35 %= *(void *)&v25;
            }
            if (v35 != v30) {
              break;
            }
          }
          unint64_t v34 = 0;
          uint64_t v32 = (uint64_t **)*v32;
          if (!v32) {
            goto LABEL_45;
          }
        }
      }
    }
  }
LABEL_44:
  unint64_t v34 = 0;
LABEL_45:
  __int16 v37 = [v34 mpsndarray];

  int8x8_t v38 = (int8x8_t *)*((void *)this + 2);
  v112[0] = Filter;
  int8x8_t v39 = mlir::Value::getParentRegion((mlir::Value *)v112);
  int8x8_t v40 = v38[12];
  if (!*(void *)&v40) {
    goto LABEL_86;
  }
  unint64_t v41 = *((void *)v39 + 2);
  unint64_t v42 = 0x9DDFEA08EB382D69 * (((8 * v41) + 8) ^ HIDWORD(v41));
  unint64_t v43 = 0x9DDFEA08EB382D69 * (HIDWORD(v41) ^ (v42 >> 47) ^ v42);
  unint64_t v44 = 0x9DDFEA08EB382D69 * (v43 ^ (v43 >> 47));
  uint8x8_t v45 = (uint8x8_t)vcnt_s8(v40);
  v45.i16[0] = vaddlv_u8(v45);
  if (v45.u32[0] > 1uLL)
  {
    unint64_t v46 = 0x9DDFEA08EB382D69 * (v43 ^ (v43 >> 47));
    if (v44 >= *(void *)&v40) {
      unint64_t v46 = v44 % *(void *)&v40;
    }
  }
  else
  {
    unint64_t v46 = v44 & (*(void *)&v40 - 1);
  }
  uint64_t v47 = *(void **)(*(void *)&v38[11] + 8 * v46);
  if (!v47) {
    goto LABEL_86;
  }
  uint64_t v48 = (void *)*v47;
  if (!v48) {
    goto LABEL_86;
  }
  if (v45.u32[0] < 2uLL)
  {
    uint64_t v49 = *(void *)&v40 - 1;
    while (1)
    {
      uint64_t v51 = v48[1];
      if (v51 == v44)
      {
        if (v48[2] == v41) {
          goto LABEL_66;
        }
      }
      else if ((v51 & v49) != v46)
      {
        goto LABEL_86;
      }
      uint64_t v48 = (void *)*v48;
      if (!v48) {
        goto LABEL_86;
      }
    }
  }
  while (2)
  {
    unint64_t v50 = v48[1];
    if (v50 != v44)
    {
      if (v50 >= *(void *)&v40) {
        v50 %= *(void *)&v40;
      }
      if (v50 != v46) {
        goto LABEL_86;
      }
      goto LABEL_55;
    }
    if (v48[2] != v41)
    {
LABEL_55:
      uint64_t v48 = (void *)*v48;
      if (!v48) {
        goto LABEL_86;
      }
      continue;
    }
    break;
  }
LABEL_66:
  int8x8_t v52 = (int8x8_t)v48[4];
  if (v52)
  {
    unint64_t v53 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v112[0])) + 8) ^ HIDWORD(v112[0]));
    unint64_t v54 = 0x9DDFEA08EB382D69 * (HIDWORD(v112[0]) ^ (v53 >> 47) ^ v53);
    unint64_t v55 = 0x9DDFEA08EB382D69 * (v54 ^ (v54 >> 47));
    uint8x8_t v56 = (uint8x8_t)vcnt_s8(v52);
    v56.i16[0] = vaddlv_u8(v56);
    if (v56.u32[0] > 1uLL)
    {
      unint64_t v57 = v55;
      if (v55 >= *(void *)&v52) {
        unint64_t v57 = v55 % *(void *)&v52;
      }
    }
    else
    {
      unint64_t v57 = v55 & (*(void *)&v52 - 1);
    }
    uint64_t v58 = *(uint64_t ****)(v48[3] + 8 * v57);
    if (v58)
    {
      uint64_t v59 = *v58;
      if (v59)
      {
        if (v56.u32[0] < 2uLL)
        {
          uint64_t v60 = *(void *)&v52 - 1;
          while (1)
          {
            uint64_t v63 = v59[1];
            if (v63 == (uint64_t *)v55)
            {
              if (v59[2] == (uint64_t *)v112[0]) {
                goto LABEL_140;
              }
            }
            else if (((unint64_t)v63 & v60) != v57)
            {
              goto LABEL_86;
            }
            unint64_t v61 = 0;
            uint64_t v59 = (uint64_t **)*v59;
            if (!v59) {
              goto LABEL_87;
            }
          }
        }
        while (1)
        {
          unint64_t v62 = (unint64_t)v59[1];
          if (v62 == v55)
          {
            if (v59[2] == (uint64_t *)v112[0])
            {
LABEL_140:
              unint64_t v61 = v59[3];
              goto LABEL_87;
            }
          }
          else
          {
            if (v62 >= *(void *)&v52) {
              v62 %= *(void *)&v52;
            }
            if (v62 != v57) {
              break;
            }
          }
          unint64_t v61 = 0;
          uint64_t v59 = (uint64_t **)*v59;
          if (!v59) {
            goto LABEL_87;
          }
        }
      }
    }
  }
LABEL_86:
  unint64_t v61 = 0;
LABEL_87:
  int8x8_t v64 = [v61 mpsndarray];

  unint64_t v65 = (int8x8_t *)*((void *)this + 2);
  v112[0] = Bias;
  int8x8_t v66 = mlir::Value::getParentRegion((mlir::Value *)v112);
  int8x8_t v67 = v65[12];
  if (!*(void *)&v67) {
    goto LABEL_128;
  }
  unint64_t v68 = *((void *)v66 + 2);
  unint64_t v69 = 0x9DDFEA08EB382D69 * (((8 * v68) + 8) ^ HIDWORD(v68));
  unint64_t v70 = 0x9DDFEA08EB382D69 * (HIDWORD(v68) ^ (v69 >> 47) ^ v69);
  unint64_t v71 = 0x9DDFEA08EB382D69 * (v70 ^ (v70 >> 47));
  uint8x8_t v72 = (uint8x8_t)vcnt_s8(v67);
  v72.i16[0] = vaddlv_u8(v72);
  if (v72.u32[0] > 1uLL)
  {
    unint64_t v73 = 0x9DDFEA08EB382D69 * (v70 ^ (v70 >> 47));
    if (v71 >= *(void *)&v67) {
      unint64_t v73 = v71 % *(void *)&v67;
    }
  }
  else
  {
    unint64_t v73 = v71 & (*(void *)&v67 - 1);
  }
  unint64_t v74 = *(void **)(*(void *)&v65[11] + 8 * v73);
  if (!v74) {
    goto LABEL_128;
  }
  uint64_t v75 = (void *)*v74;
  if (!v75) {
    goto LABEL_128;
  }
  if (v72.u32[0] < 2uLL)
  {
    uint64_t v76 = *(void *)&v67 - 1;
    while (1)
    {
      uint64_t v78 = v75[1];
      if (v78 == v71)
      {
        if (v75[2] == v68) {
          goto LABEL_108;
        }
      }
      else if ((v78 & v76) != v73)
      {
        goto LABEL_128;
      }
      uint64_t v75 = (void *)*v75;
      if (!v75) {
        goto LABEL_128;
      }
    }
  }
  while (1)
  {
    unint64_t v77 = v75[1];
    if (v77 == v71) {
      break;
    }
    if (v77 >= *(void *)&v67) {
      v77 %= *(void *)&v67;
    }
    if (v77 != v73) {
      goto LABEL_128;
    }
LABEL_97:
    uint64_t v75 = (void *)*v75;
    if (!v75) {
      goto LABEL_128;
    }
  }
  if (v75[2] != v68) {
    goto LABEL_97;
  }
LABEL_108:
  int8x8_t v79 = (int8x8_t)v75[4];
  if (!*(void *)&v79) {
    goto LABEL_128;
  }
  unint64_t v80 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v112[0])) + 8) ^ HIDWORD(v112[0]));
  unint64_t v81 = 0x9DDFEA08EB382D69 * (HIDWORD(v112[0]) ^ (v80 >> 47) ^ v80);
  unint64_t v82 = 0x9DDFEA08EB382D69 * (v81 ^ (v81 >> 47));
  uint8x8_t v83 = (uint8x8_t)vcnt_s8(v79);
  v83.i16[0] = vaddlv_u8(v83);
  if (v83.u32[0] > 1uLL)
  {
    unint64_t v84 = v82;
    if (v82 >= *(void *)&v79) {
      unint64_t v84 = v82 % *(void *)&v79;
    }
  }
  else
  {
    unint64_t v84 = v82 & (*(void *)&v79 - 1);
  }
  uint64_t v85 = *(uint64_t ****)(v75[3] + 8 * v84);
  if (!v85 || (uint64_t v86 = *v85) == 0)
  {
LABEL_128:
    unint64_t v88 = 0;
    goto LABEL_129;
  }
  if (v83.u32[0] < 2uLL)
  {
    uint64_t v87 = *(void *)&v79 - 1;
    while (1)
    {
      uint64_t v90 = v86[1];
      if (v90 == (uint64_t *)v82)
      {
        if (v86[2] == (uint64_t *)v112[0]) {
          goto LABEL_141;
        }
      }
      else if (((unint64_t)v90 & v87) != v84)
      {
        goto LABEL_128;
      }
      unint64_t v88 = 0;
      uint64_t v86 = (uint64_t **)*v86;
      if (!v86) {
        goto LABEL_129;
      }
    }
  }
  while (1)
  {
    unint64_t v89 = (unint64_t)v86[1];
    if (v89 == v82) {
      break;
    }
    if (v89 >= *(void *)&v79) {
      v89 %= *(void *)&v79;
    }
    if (v89 != v84) {
      goto LABEL_128;
    }
LABEL_118:
    unint64_t v88 = 0;
    uint64_t v86 = (uint64_t **)*v86;
    if (!v86) {
      goto LABEL_129;
    }
  }
  if (v86[2] != (uint64_t *)v112[0]) {
    goto LABEL_118;
  }
LABEL_141:
  unint64_t v88 = v86[3];
LABEL_129:
  uint64_t v91 = [v88 mpsndarray];

  uint64_t v92 = [(NSArray *)v5 objectAtIndexedSubscript:0];
  uint64_t v93 = [v92 mpsndarray];
  if ((!v93 || !v37 || !v64 || !v91) && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  id v94 = *((id *)this + 1);
  [v94 setBatchDimensions:mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v107)];
  uint64_t v95 = (void *)*((void *)a2 + 9);
  if (!v95)
  {
    uint64_t v96 = [objc_alloc(MEMORY[0x1E4F35528]) initWithCommandBuffer:*((void *)a2 + 1) withDispatchType:0];
    uint64_t v97 = (void *)*((void *)a2 + 9);
    *((void *)a2 + 9) = v96;

    uint64_t v98 = (void *)*((void *)a2 + 11);
    uint64_t v95 = (void *)*((void *)a2 + 9);
    if (v98)
    {
      uint64_t v99 = [v98 wrapComputeEncoder:*((void *)a2 + 9)];
      uint64_t v100 = (void *)*((void *)a2 + 9);
      *((void *)a2 + 9) = v99;

      uint64_t v95 = (void *)*((void *)a2 + 9);
    }
  }
  if (*((void *)a2 + 10))
  {
    objc_msgSend(v95, "setLabel:");
    uint64_t v95 = (void *)*((void *)a2 + 9);
  }
  id v101 = v95;
  uint64_t v102 = *((void *)a2 + 1);
  v113[0] = v37;
  v113[1] = v64;
  v113[2] = v91;
  char v103 = [MEMORY[0x1E4F1C978] arrayWithObjects:v113 count:3];
  [v94 encodeToMPSCommandEncoder:v101 commandBuffer:v102 sourceArrays:v103 destinationArray:v93];
}

void sub_180D803E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GPU::ScatterOpHandler::~ScatterOpHandler(id *this)
{
  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)this);
}

{
  uint64_t vars8;

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)this);

  JUMPOUT(0x1852FDE70);
}

void GPU::ScatterAlongAxisOpHandler::~ScatterAlongAxisOpHandler(id *this)
{
  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)this);
}

{
  uint64_t vars8;

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)this);

  JUMPOUT(0x1852FDE70);
}

void GPU::ScatterNDOpHandler::~ScatterNDOpHandler(id *this)
{
  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)this);
}

{
  uint64_t vars8;

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)this);

  JUMPOUT(0x1852FDE70);
}

void GPU::ScatterGenericOpHandler<mlir::mps::ScatterOp>::~ScatterGenericOpHandler(id *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)a1);
}

{
  uint64_t vars8;

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)a1);

  JUMPOUT(0x1852FDE70);
}

void GPU::ScatterGenericOpHandler<mlir::mps::ScatterAlongAxisOp>::~ScatterGenericOpHandler(id *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)a1);
}

{
  uint64_t vars8;

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)a1);

  JUMPOUT(0x1852FDE70);
}

void GPU::ScatterGenericOpHandler<mlir::mps::ScatterNDOp>::~ScatterGenericOpHandler(id *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)a1);
}

{
  uint64_t vars8;

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)a1);

  JUMPOUT(0x1852FDE70);
}

uint64_t GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeSumOp,(MPSNDArrayScanOperation)0>::BaseCumulativeOpHandler(uint64_t a1, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  *(void *)GPU::BaseOpHandler::BaseOpHandler((GPU::BaseOpHandler *)a1, a2, a3, a4) = &unk_1EC99FC88;
  uint64_t v6 = *((void *)a3 + 6);
  __int16 v7 = *(void **)(v6 + 16);
  if (v7 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v23[0] = *(void *)(v6 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v23);
    if (v15 == 18
      && *(void *)AttrData == 0x756D75632E73706DLL
      && *(void *)(AttrData + 8) == 0x735F65766974616CLL
      && *(_WORD *)(AttrData + 16) == 28021)
    {
      __int16 v22 = 1283;
      v21[0] = (uint64_t)"classof on '";
      v21[2] = (uint64_t)"mps.cumulative_sum";
      v21[3] = 18;
      unint64_t v19 = "' failed due to the operation not being registered";
      __int16 v20 = 259;
      llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
      llvm::report_fatal_error((llvm::Twine *)v23, 1);
    }
LABEL_14:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeSumOp,void>::id) {
    goto LABEL_14;
  }
  uint8x8_t v18 = a3;
  id v8 = objc_alloc(MEMORY[0x1E4F35898]);
  __int16 v9 = objc_msgSend(*(id *)(*(void *)(a1 + 16) + 48), "metalDevice", a3);
  BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v18);
  uint64_t v11 = [v8 initWithDevice:v9 axis:0 operation:0 exclusive:InferredResultTypes reverse:mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v18)];
  id v12 = *(void **)(a1 + 8);
  *(void *)(a1 + 8) = v11;

  objc_msgSend(*(id *)(a1 + 8), "setOptions:", objc_msgSend(*(id *)(a1 + 8), "options") | 1);
  return a1;
}

void sub_180D809B8(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void sub_180D809D0(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

uint64_t GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeProductOp,(MPSNDArrayScanOperation)1>::BaseCumulativeOpHandler(uint64_t a1, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  *(void *)GPU::BaseOpHandler::BaseOpHandler((GPU::BaseOpHandler *)a1, a2, a3, a4) = &unk_1EC99FD78;
  uint64_t v6 = *((void *)a3 + 6);
  __int16 v7 = *(void **)(v6 + 16);
  if (v7 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v23[0] = *(void *)(v6 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v23);
    if (v15 == 22
      && *AttrData == 0x756D75632E73706DLL
      && AttrData[1] == 0x705F65766974616CLL
      && *(void *)((char *)AttrData + 14) == 0x746375646F72705FLL)
    {
      __int16 v22 = 1283;
      v21[0] = (uint64_t)"classof on '";
      v21[2] = (uint64_t)"mps.cumulative_product";
      v21[3] = 22;
      unint64_t v19 = "' failed due to the operation not being registered";
      __int16 v20 = 259;
      llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
      llvm::report_fatal_error((llvm::Twine *)v23, 1);
    }
LABEL_14:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeProductOp,void>::id) {
    goto LABEL_14;
  }
  uint8x8_t v18 = a3;
  id v8 = objc_alloc(MEMORY[0x1E4F35898]);
  __int16 v9 = objc_msgSend(*(id *)(*(void *)(a1 + 16) + 48), "metalDevice", a3);
  BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v18);
  uint64_t v11 = [v8 initWithDevice:v9 axis:0 operation:1 exclusive:InferredResultTypes reverse:mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v18)];
  id v12 = *(void **)(a1 + 8);
  *(void *)(a1 + 8) = v11;

  objc_msgSend(*(id *)(a1 + 8), "setOptions:", objc_msgSend(*(id *)(a1 + 8), "options") | 1);
  return a1;
}

void sub_180D80BC0(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void sub_180D80BD8(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

uint64_t GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeMaximumOp,(MPSNDArrayScanOperation)2>::BaseCumulativeOpHandler(uint64_t a1, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  *(void *)GPU::BaseOpHandler::BaseOpHandler((GPU::BaseOpHandler *)a1, a2, a3, a4) = &unk_1EC99FCD8;
  uint64_t v6 = *((void *)a3 + 6);
  __int16 v7 = *(void **)(v6 + 16);
  if (v7 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v23[0] = *(void *)(v6 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v23);
    if (v15 == 22
      && *AttrData == 0x756D75632E73706DLL
      && AttrData[1] == 0x6D5F65766974616CLL
      && *(void *)((char *)AttrData + 14) == 0x6D756D6978616D5FLL)
    {
      __int16 v22 = 1283;
      v21[0] = (uint64_t)"classof on '";
      v21[2] = (uint64_t)"mps.cumulative_maximum";
      v21[3] = 22;
      unint64_t v19 = "' failed due to the operation not being registered";
      __int16 v20 = 259;
      llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
      llvm::report_fatal_error((llvm::Twine *)v23, 1);
    }
LABEL_14:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeMaximumOp,void>::id) {
    goto LABEL_14;
  }
  uint8x8_t v18 = a3;
  id v8 = objc_alloc(MEMORY[0x1E4F35898]);
  __int16 v9 = objc_msgSend(*(id *)(*(void *)(a1 + 16) + 48), "metalDevice", a3);
  BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v18);
  uint64_t v11 = [v8 initWithDevice:v9 axis:0 operation:2 exclusive:InferredResultTypes reverse:mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v18)];
  id v12 = *(void **)(a1 + 8);
  *(void *)(a1 + 8) = v11;

  objc_msgSend(*(id *)(a1 + 8), "setOptions:", objc_msgSend(*(id *)(a1 + 8), "options") | 1);
  return a1;
}

void sub_180D80DC8(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void sub_180D80DE0(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

uint64_t GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeMinimumOp,(MPSNDArrayScanOperation)3>::BaseCumulativeOpHandler(uint64_t a1, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  *(void *)GPU::BaseOpHandler::BaseOpHandler((GPU::BaseOpHandler *)a1, a2, a3, a4) = &unk_1EC99FD28;
  uint64_t v6 = *((void *)a3 + 6);
  __int16 v7 = *(void **)(v6 + 16);
  if (v7 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v23[0] = *(void *)(v6 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v23);
    if (v15 == 22
      && *AttrData == 0x756D75632E73706DLL
      && AttrData[1] == 0x6D5F65766974616CLL
      && *(void *)((char *)AttrData + 14) == 0x6D756D696E696D5FLL)
    {
      __int16 v22 = 1283;
      v21[0] = (uint64_t)"classof on '";
      v21[2] = (uint64_t)"mps.cumulative_minimum";
      v21[3] = 22;
      unint64_t v19 = "' failed due to the operation not being registered";
      __int16 v20 = 259;
      llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
      llvm::report_fatal_error((llvm::Twine *)v23, 1);
    }
LABEL_14:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeMinimumOp,void>::id) {
    goto LABEL_14;
  }
  uint8x8_t v18 = a3;
  id v8 = objc_alloc(MEMORY[0x1E4F35898]);
  __int16 v9 = objc_msgSend(*(id *)(*(void *)(a1 + 16) + 48), "metalDevice", a3);
  BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v18);
  uint64_t v11 = [v8 initWithDevice:v9 axis:0 operation:3 exclusive:InferredResultTypes reverse:mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v18)];
  id v12 = *(void **)(a1 + 8);
  *(void *)(a1 + 8) = v11;

  objc_msgSend(*(id *)(a1 + 8), "setOptions:", objc_msgSend(*(id *)(a1 + 8), "options") | 1);
  return a1;
}

void sub_180D80FD0(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void sub_180D80FE8(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeSumOp,(MPSNDArrayScanOperation)0>::encodeNDArrayOp(uint64_t a1, GPU::EncodeDescriptor *a2, void *a3)
{
  v82[1] = *MEMORY[0x1E4F143B8];
  id v71 = a3;
  uint64_t v5 = *(void *)(*(void *)(a1 + 24) + 48);
  uint64_t v6 = *(void **)(v5 + 16);
  if (v6 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v80[0] = *(void *)(v5 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v80);
    if (v68 == 18)
    {
      BOOL v69 = *(void *)AttrData == 0x756D75632E73706DLL && *(void *)(AttrData + 8) == 0x735F65766974616CLL;
      if (v69 && *(_WORD *)(AttrData + 16) == 28021)
      {
        __int16 v79 = 1283;
        v76[0] = (uint64_t)"classof on '";
        unint64_t v77 = "mps.cumulative_sum";
        uint64_t v78 = 18;
        v74[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v75 = 259;
        llvm::operator+(v76, v74, (uint64_t)v80);
        llvm::report_fatal_error((llvm::Twine *)v80, 1);
      }
    }
LABEL_94:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v6 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeSumOp,void>::id) {
    goto LABEL_94;
  }
  uint64_t v73 = *(void *)(a1 + 24);
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v73);
  uint64_t Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v73);
  __int16 v9 = [v71 objectAtIndexedSubscript:0];
  uint64_t v10 = *(int8x8_t **)(a1 + 16);
  v80[0] = Input;
  ParentRegion = mlir::Value::getParentRegion((mlir::Value *)v80);
  int8x8_t v12 = v10[12];
  if (!*(void *)&v12) {
    goto LABEL_44;
  }
  unint64_t v13 = *((void *)ParentRegion + 2);
  unint64_t v14 = 0x9DDFEA08EB382D69 * (((8 * v13) + 8) ^ HIDWORD(v13));
  unint64_t v15 = 0x9DDFEA08EB382D69 * (HIDWORD(v13) ^ (v14 >> 47) ^ v14);
  unint64_t v16 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
  uint8x8_t v17 = (uint8x8_t)vcnt_s8(v12);
  v17.i16[0] = vaddlv_u8(v17);
  if (v17.u32[0] > 1uLL)
  {
    unint64_t v18 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
    if (v16 >= *(void *)&v12) {
      unint64_t v18 = v16 % *(void *)&v12;
    }
  }
  else
  {
    unint64_t v18 = v16 & (*(void *)&v12 - 1);
  }
  unint64_t v19 = *(void **)(*(void *)&v10[11] + 8 * v18);
  if (!v19) {
    goto LABEL_44;
  }
  __int16 v20 = (void *)*v19;
  if (!v20) {
    goto LABEL_44;
  }
  if (v17.u32[0] < 2uLL)
  {
    uint64_t v21 = *(void *)&v12 - 1;
    while (1)
    {
      uint64_t v23 = v20[1];
      if (v23 == v16)
      {
        if (v20[2] == v13) {
          goto LABEL_24;
        }
      }
      else if ((v23 & v21) != v18)
      {
        goto LABEL_44;
      }
      __int16 v20 = (void *)*v20;
      if (!v20) {
        goto LABEL_44;
      }
    }
  }
  while (1)
  {
    unint64_t v22 = v20[1];
    if (v22 == v16) {
      break;
    }
    if (v22 >= *(void *)&v12) {
      v22 %= *(void *)&v12;
    }
    if (v22 != v18) {
      goto LABEL_44;
    }
LABEL_13:
    __int16 v20 = (void *)*v20;
    if (!v20) {
      goto LABEL_44;
    }
  }
  if (v20[2] != v13) {
    goto LABEL_13;
  }
LABEL_24:
  int8x8_t v24 = (int8x8_t)v20[4];
  if (!*(void *)&v24) {
    goto LABEL_44;
  }
  unint64_t v25 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v80[0])) + 8) ^ HIDWORD(v80[0]));
  unint64_t v26 = 0x9DDFEA08EB382D69 * (HIDWORD(v80[0]) ^ (v25 >> 47) ^ v25);
  unint64_t v27 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
  uint8x8_t v28 = (uint8x8_t)vcnt_s8(v24);
  v28.i16[0] = vaddlv_u8(v28);
  if (v28.u32[0] > 1uLL)
  {
    unint64_t v29 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
    if (v27 >= *(void *)&v24) {
      unint64_t v29 = v27 % *(void *)&v24;
    }
  }
  else
  {
    unint64_t v29 = v27 & (*(void *)&v24 - 1);
  }
  unint64_t v30 = *(uint64_t ****)(v20[3] + 8 * v29);
  if (!v30 || (uint64_t v31 = *v30) == 0)
  {
LABEL_44:
    uint64_t v33 = 0;
    goto LABEL_45;
  }
  if (v28.u32[0] < 2uLL)
  {
    uint64_t v32 = *(void *)&v24 - 1;
    while (1)
    {
      unint64_t v35 = v31[1];
      if (v35 == (uint64_t *)v27)
      {
        if (v31[2] == (uint64_t *)v80[0]) {
          goto LABEL_76;
        }
      }
      else if (((unint64_t)v35 & v32) != v29)
      {
        goto LABEL_44;
      }
      uint64_t v33 = 0;
      uint64_t v31 = (uint64_t **)*v31;
      if (!v31) {
        goto LABEL_45;
      }
    }
  }
  while (1)
  {
    unint64_t v34 = (unint64_t)v31[1];
    if (v34 == v27) {
      break;
    }
    if (v34 >= *(void *)&v24) {
      v34 %= *(void *)&v24;
    }
    if (v34 != v29) {
      goto LABEL_44;
    }
LABEL_34:
    uint64_t v33 = 0;
    uint64_t v31 = (uint64_t **)*v31;
    if (!v31) {
      goto LABEL_45;
    }
  }
  if (v31[2] != (uint64_t *)v80[0]) {
    goto LABEL_34;
  }
LABEL_76:
  uint64_t v33 = v31[3];
LABEL_45:
  int v36 = objc_msgSend(v33, "mpsndarray", v71);
  __int16 v37 = [v9 mpsndarray];
  id v38 = *(id *)(a1 + 8);
  uint64_t Axis = RuntimeUtils::getAxis(*(void *)(a1 + 16), (uint64_t)a2, Filter, [v36 numberOfDimensions]);
  uint64_t v40 = [v36 numberOfDimensions];
  if (Axis >= 0) {
    uint64_t v41 = v40;
  }
  else {
    uint64_t v41 = 0;
  }
  [v38 setAxis:v41 + ~Axis];
  [v38 setExclusive:mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v73)];
  [v38 setReverse:mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v73)];
  if (*(void *)(a1 + 32))
  {
    uint64_t v42 = *(void *)(mlir::Block::getParentOp(*(mlir::Block **)(*(void *)(a1 + 24) + 16)) + 48);
    if (*(_UNKNOWN **)(v42 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v80[0] = *(void *)(v42 + 8);
      unint64_t v43 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v80);
      if (v44 == 13 && *v43 == 0x6974732E7873706DLL && *(void *)((char *)v43 + 5) == 0x6465686374697473)
      {
        __int16 v79 = 1283;
        v76[0] = (uint64_t)"classof on '";
        unint64_t v77 = "mpsx.stitched";
        uint64_t v78 = 13;
        v74[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v75 = 259;
        llvm::operator+(v76, v74, (uint64_t)v80);
        llvm::report_fatal_error((llvm::Twine *)v80, 1);
      }
    }
    uint64_t v46 = *(void *)(mlir::Block::getParentOp(*(mlir::Block **)(*(void *)(a1 + 24) + 16)) + 48);
    uint64_t v47 = *(void **)(v46 + 16);
    if (v47 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v80[0] = *(void *)(v46 + 8);
      int8x8_t v64 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v80);
      if (v65 == 13 && *v64 == 0x6974732E7873706DLL && *(void *)((char *)v64 + 5) == 0x6465686374697473)
      {
        __int16 v79 = 1283;
        v76[0] = (uint64_t)"classof on '";
        unint64_t v77 = "mpsx.stitched";
        uint64_t v78 = 13;
        v80[0] = v76;
        v80[2] = "' failed due to the operation not being registered";
        __int16 v81 = 770;
        llvm::report_fatal_error((llvm::Twine *)v80, 1);
      }
    }
    else if (v47 == &mlir::detail::TypeIDResolver<mlir::mpsx::StitchedOp,void>::id)
    {
      goto LABEL_57;
    }
    if (MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
LABEL_57:
    uint64_t v48 = GPU::MPSGraphKernelDAG::getNDArraysForPlaceholders(*(GPU::MPSGraphKernelDAG **)(a1 + 32), *(GPURegionRuntime **)(a1 + 16));
    uint64_t v49 = (void *)*((void *)a2 + 9);
    if (!v49)
    {
      uint64_t v50 = [objc_alloc(MEMORY[0x1E4F35528]) initWithCommandBuffer:*((void *)a2 + 1) withDispatchType:0];
      uint64_t v51 = (void *)*((void *)a2 + 9);
      *((void *)a2 + 9) = v50;

      int8x8_t v52 = (void *)*((void *)a2 + 11);
      uint64_t v49 = (void *)*((void *)a2 + 9);
      if (v52)
      {
        uint64_t v53 = [v52 wrapComputeEncoder:*((void *)a2 + 9)];
        unint64_t v54 = (void *)*((void *)a2 + 9);
        *((void *)a2 + 9) = v53;

        uint64_t v49 = (void *)*((void *)a2 + 9);
      }
    }
    if (*((void *)a2 + 10))
    {
      objc_msgSend(v49, "setLabel:");
      uint64_t v49 = (void *)*((void *)a2 + 9);
    }
    id v55 = v49;
    uint64_t v56 = *((void *)a2 + 1);
    uint64_t v57 = *(void *)(a1 + 32);
    uint64_t v58 = *(void **)(v57 + 120);
    if (!v58)
    {
      if (!*(void *)(v57 + 96) && MTLReportFailureTypeEnabled()) {
        MTLReportFailure();
      }
      uint64_t v59 = [objc_alloc(MEMORY[0x1E4F35608]) initWithKernelDAG:v57 + 80 finalOp:*(void *)(*(void *)(v57 + 96) + 32)];
      unint64_t v61 = *(void **)(v57 + 120);
      uint64_t v60 = (uint64_t *)(v57 + 120);
      *uint64_t v60 = v59;

      uint64_t v58 = (void *)*v60;
    }
    id v62 = v58;
    [v38 encodeToMPSCommandEncoder:v55 commandBuffer:v56 sourceArrays:v48 resultState:0 destinationArray:v37 kernelDAGObject:v62];
  }
  else
  {
    if (!v36 && MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    uint64_t v48 = GPU::EncodeDescriptor::getcomputeEncoder(a2);
    uint64_t v63 = *((void *)a2 + 1);
    v82[0] = v36;
    id v55 = [MEMORY[0x1E4F1C978] arrayWithObjects:v82 count:1];
    [v38 encodeToMPSCommandEncoder:v48 commandBuffer:v63 sourceArrays:v55 destinationArray:v37];
  }
}

void sub_180D817F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

uint64_t GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeSumOp,(MPSNDArrayScanOperation)0>::kernelDAGOp(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 24) + 48);
  int v3 = *(void **)(v2 + 16);
  if (v3 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v16[0] = *(void *)(v2 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v16);
    if (v9 == 18
      && *(void *)AttrData == 0x756D75632E73706DLL
      && *(void *)(AttrData + 8) == 0x735F65766974616CLL
      && *(_WORD *)(AttrData + 16) == 28021)
    {
      __int16 v15 = 1283;
      v14[0] = (uint64_t)"classof on '";
      v14[2] = (uint64_t)"mps.cumulative_sum";
      v14[3] = 18;
      int8x8_t v12 = "' failed due to the operation not being registered";
      __int16 v13 = 259;
      llvm::operator+(v14, (uint64_t *)&v12, (uint64_t)v16);
      llvm::report_fatal_error((llvm::Twine *)v16, 1);
    }
LABEL_14:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v3 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeSumOp,void>::id) {
    goto LABEL_14;
  }
  v16[0] = *(void *)(a1 + 24);
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)v16);
  GPU::MPSGraphKernelDAG::getBaseTensorFromDataMap(a2, Input, 0);
  uint64_t result = MPSKernelDAG::unaryCoreOp();
  *(void *)(a2 + 104) = *(void *)(a1 + 24);
  return result;
}

void GPU::CumulativeSumOpHandler::~CumulativeSumOpHandler(GPU::CumulativeSumOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);

  JUMPOUT(0x1852FDE70);
}

unint64_t GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeSumOp,(MPSNDArrayScanOperation)0>::getJITStaticOperandRepr(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  if (a4 == 1) {
    return GPU::BaseOpHandler::_getJITStaticOperandReprConstant(this, a2, a3, 1u);
  }
  else {
    return GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(this, a2, a3, a4);
  }
}

void GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeProductOp,(MPSNDArrayScanOperation)1>::encodeNDArrayOp(uint64_t a1, GPU::EncodeDescriptor *a2, void *a3)
{
  v82[1] = *MEMORY[0x1E4F143B8];
  id v71 = a3;
  uint64_t v5 = *(void *)(*(void *)(a1 + 24) + 48);
  uint64_t v6 = *(void **)(v5 + 16);
  if (v6 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v80[0] = *(void *)(v5 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v80);
    if (v68 == 22)
    {
      BOOL v69 = *AttrData == 0x756D75632E73706DLL && AttrData[1] == 0x705F65766974616CLL;
      if (v69 && *(void *)((char *)AttrData + 14) == 0x746375646F72705FLL)
      {
        __int16 v79 = 1283;
        v76[0] = (uint64_t)"classof on '";
        unint64_t v77 = "mps.cumulative_product";
        uint64_t v78 = 22;
        v74[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v75 = 259;
        llvm::operator+(v76, v74, (uint64_t)v80);
        llvm::report_fatal_error((llvm::Twine *)v80, 1);
      }
    }
LABEL_94:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v6 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeProductOp,void>::id) {
    goto LABEL_94;
  }
  uint64_t v73 = *(void *)(a1 + 24);
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v73);
  uint64_t Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v73);
  uint64_t v9 = [v71 objectAtIndexedSubscript:0];
  uint64_t v10 = *(int8x8_t **)(a1 + 16);
  v80[0] = Input;
  ParentRegion = mlir::Value::getParentRegion((mlir::Value *)v80);
  int8x8_t v12 = v10[12];
  if (!*(void *)&v12) {
    goto LABEL_44;
  }
  unint64_t v13 = *((void *)ParentRegion + 2);
  unint64_t v14 = 0x9DDFEA08EB382D69 * (((8 * v13) + 8) ^ HIDWORD(v13));
  unint64_t v15 = 0x9DDFEA08EB382D69 * (HIDWORD(v13) ^ (v14 >> 47) ^ v14);
  unint64_t v16 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
  uint8x8_t v17 = (uint8x8_t)vcnt_s8(v12);
  v17.i16[0] = vaddlv_u8(v17);
  if (v17.u32[0] > 1uLL)
  {
    unint64_t v18 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
    if (v16 >= *(void *)&v12) {
      unint64_t v18 = v16 % *(void *)&v12;
    }
  }
  else
  {
    unint64_t v18 = v16 & (*(void *)&v12 - 1);
  }
  unint64_t v19 = *(void **)(*(void *)&v10[11] + 8 * v18);
  if (!v19) {
    goto LABEL_44;
  }
  __int16 v20 = (void *)*v19;
  if (!v20) {
    goto LABEL_44;
  }
  if (v17.u32[0] < 2uLL)
  {
    uint64_t v21 = *(void *)&v12 - 1;
    while (1)
    {
      uint64_t v23 = v20[1];
      if (v23 == v16)
      {
        if (v20[2] == v13) {
          goto LABEL_24;
        }
      }
      else if ((v23 & v21) != v18)
      {
        goto LABEL_44;
      }
      __int16 v20 = (void *)*v20;
      if (!v20) {
        goto LABEL_44;
      }
    }
  }
  while (1)
  {
    unint64_t v22 = v20[1];
    if (v22 == v16) {
      break;
    }
    if (v22 >= *(void *)&v12) {
      v22 %= *(void *)&v12;
    }
    if (v22 != v18) {
      goto LABEL_44;
    }
LABEL_13:
    __int16 v20 = (void *)*v20;
    if (!v20) {
      goto LABEL_44;
    }
  }
  if (v20[2] != v13) {
    goto LABEL_13;
  }
LABEL_24:
  int8x8_t v24 = (int8x8_t)v20[4];
  if (!*(void *)&v24) {
    goto LABEL_44;
  }
  unint64_t v25 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v80[0])) + 8) ^ HIDWORD(v80[0]));
  unint64_t v26 = 0x9DDFEA08EB382D69 * (HIDWORD(v80[0]) ^ (v25 >> 47) ^ v25);
  unint64_t v27 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
  uint8x8_t v28 = (uint8x8_t)vcnt_s8(v24);
  v28.i16[0] = vaddlv_u8(v28);
  if (v28.u32[0] > 1uLL)
  {
    unint64_t v29 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
    if (v27 >= *(void *)&v24) {
      unint64_t v29 = v27 % *(void *)&v24;
    }
  }
  else
  {
    unint64_t v29 = v27 & (*(void *)&v24 - 1);
  }
  unint64_t v30 = *(uint64_t ****)(v20[3] + 8 * v29);
  if (!v30 || (uint64_t v31 = *v30) == 0)
  {
LABEL_44:
    uint64_t v33 = 0;
    goto LABEL_45;
  }
  if (v28.u32[0] < 2uLL)
  {
    uint64_t v32 = *(void *)&v24 - 1;
    while (1)
    {
      unint64_t v35 = v31[1];
      if (v35 == (uint64_t *)v27)
      {
        if (v31[2] == (uint64_t *)v80[0]) {
          goto LABEL_76;
        }
      }
      else if (((unint64_t)v35 & v32) != v29)
      {
        goto LABEL_44;
      }
      uint64_t v33 = 0;
      uint64_t v31 = (uint64_t **)*v31;
      if (!v31) {
        goto LABEL_45;
      }
    }
  }
  while (1)
  {
    unint64_t v34 = (unint64_t)v31[1];
    if (v34 == v27) {
      break;
    }
    if (v34 >= *(void *)&v24) {
      v34 %= *(void *)&v24;
    }
    if (v34 != v29) {
      goto LABEL_44;
    }
LABEL_34:
    uint64_t v33 = 0;
    uint64_t v31 = (uint64_t **)*v31;
    if (!v31) {
      goto LABEL_45;
    }
  }
  if (v31[2] != (uint64_t *)v80[0]) {
    goto LABEL_34;
  }
LABEL_76:
  uint64_t v33 = v31[3];
LABEL_45:
  int v36 = objc_msgSend(v33, "mpsndarray", v71);
  __int16 v37 = [v9 mpsndarray];
  id v38 = *(id *)(a1 + 8);
  uint64_t Axis = RuntimeUtils::getAxis(*(void *)(a1 + 16), (uint64_t)a2, Filter, [v36 numberOfDimensions]);
  uint64_t v40 = [v36 numberOfDimensions];
  if (Axis >= 0) {
    uint64_t v41 = v40;
  }
  else {
    uint64_t v41 = 0;
  }
  [v38 setAxis:v41 + ~Axis];
  [v38 setExclusive:mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v73)];
  [v38 setReverse:mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v73)];
  if (*(void *)(a1 + 32))
  {
    uint64_t v42 = *(void *)(mlir::Block::getParentOp(*(mlir::Block **)(*(void *)(a1 + 24) + 16)) + 48);
    if (*(_UNKNOWN **)(v42 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v80[0] = *(void *)(v42 + 8);
      unint64_t v43 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v80);
      if (v44 == 13 && *v43 == 0x6974732E7873706DLL && *(void *)((char *)v43 + 5) == 0x6465686374697473)
      {
        __int16 v79 = 1283;
        v76[0] = (uint64_t)"classof on '";
        unint64_t v77 = "mpsx.stitched";
        uint64_t v78 = 13;
        v74[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v75 = 259;
        llvm::operator+(v76, v74, (uint64_t)v80);
        llvm::report_fatal_error((llvm::Twine *)v80, 1);
      }
    }
    uint64_t v46 = *(void *)(mlir::Block::getParentOp(*(mlir::Block **)(*(void *)(a1 + 24) + 16)) + 48);
    uint64_t v47 = *(void **)(v46 + 16);
    if (v47 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v80[0] = *(void *)(v46 + 8);
      int8x8_t v64 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v80);
      if (v65 == 13 && *v64 == 0x6974732E7873706DLL && *(void *)((char *)v64 + 5) == 0x6465686374697473)
      {
        __int16 v79 = 1283;
        v76[0] = (uint64_t)"classof on '";
        unint64_t v77 = "mpsx.stitched";
        uint64_t v78 = 13;
        v80[0] = v76;
        v80[2] = "' failed due to the operation not being registered";
        __int16 v81 = 770;
        llvm::report_fatal_error((llvm::Twine *)v80, 1);
      }
    }
    else if (v47 == &mlir::detail::TypeIDResolver<mlir::mpsx::StitchedOp,void>::id)
    {
      goto LABEL_57;
    }
    if (MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
LABEL_57:
    uint64_t v48 = GPU::MPSGraphKernelDAG::getNDArraysForPlaceholders(*(GPU::MPSGraphKernelDAG **)(a1 + 32), *(GPURegionRuntime **)(a1 + 16));
    uint64_t v49 = (void *)*((void *)a2 + 9);
    if (!v49)
    {
      uint64_t v50 = [objc_alloc(MEMORY[0x1E4F35528]) initWithCommandBuffer:*((void *)a2 + 1) withDispatchType:0];
      uint64_t v51 = (void *)*((void *)a2 + 9);
      *((void *)a2 + 9) = v50;

      int8x8_t v52 = (void *)*((void *)a2 + 11);
      uint64_t v49 = (void *)*((void *)a2 + 9);
      if (v52)
      {
        uint64_t v53 = [v52 wrapComputeEncoder:*((void *)a2 + 9)];
        unint64_t v54 = (void *)*((void *)a2 + 9);
        *((void *)a2 + 9) = v53;

        uint64_t v49 = (void *)*((void *)a2 + 9);
      }
    }
    if (*((void *)a2 + 10))
    {
      objc_msgSend(v49, "setLabel:");
      uint64_t v49 = (void *)*((void *)a2 + 9);
    }
    id v55 = v49;
    uint64_t v56 = *((void *)a2 + 1);
    uint64_t v57 = *(void *)(a1 + 32);
    uint64_t v58 = *(void **)(v57 + 120);
    if (!v58)
    {
      if (!*(void *)(v57 + 96) && MTLReportFailureTypeEnabled()) {
        MTLReportFailure();
      }
      uint64_t v59 = [objc_alloc(MEMORY[0x1E4F35608]) initWithKernelDAG:v57 + 80 finalOp:*(void *)(*(void *)(v57 + 96) + 32)];
      unint64_t v61 = *(void **)(v57 + 120);
      uint64_t v60 = (uint64_t *)(v57 + 120);
      *uint64_t v60 = v59;

      uint64_t v58 = (void *)*v60;
    }
    id v62 = v58;
    [v38 encodeToMPSCommandEncoder:v55 commandBuffer:v56 sourceArrays:v48 resultState:0 destinationArray:v37 kernelDAGObject:v62];
  }
  else
  {
    if (!v36 && MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    uint64_t v48 = GPU::EncodeDescriptor::getcomputeEncoder(a2);
    uint64_t v63 = *((void *)a2 + 1);
    v82[0] = v36;
    id v55 = [MEMORY[0x1E4F1C978] arrayWithObjects:v82 count:1];
    [v38 encodeToMPSCommandEncoder:v48 commandBuffer:v63 sourceArrays:v55 destinationArray:v37];
  }
}

void sub_180D82274(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

uint64_t GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeProductOp,(MPSNDArrayScanOperation)1>::kernelDAGOp(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 24) + 48);
  int v3 = *(void **)(v2 + 16);
  if (v3 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v16[0] = *(void *)(v2 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v16);
    if (v9 == 22
      && *AttrData == 0x756D75632E73706DLL
      && AttrData[1] == 0x705F65766974616CLL
      && *(void *)((char *)AttrData + 14) == 0x746375646F72705FLL)
    {
      __int16 v15 = 1283;
      v14[0] = (uint64_t)"classof on '";
      v14[2] = (uint64_t)"mps.cumulative_product";
      v14[3] = 22;
      int8x8_t v12 = "' failed due to the operation not being registered";
      __int16 v13 = 259;
      llvm::operator+(v14, (uint64_t *)&v12, (uint64_t)v16);
      llvm::report_fatal_error((llvm::Twine *)v16, 1);
    }
LABEL_14:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v3 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeProductOp,void>::id) {
    goto LABEL_14;
  }
  v16[0] = *(void *)(a1 + 24);
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)v16);
  GPU::MPSGraphKernelDAG::getBaseTensorFromDataMap(a2, Input, 0);
  uint64_t result = MPSKernelDAG::unaryCoreOp();
  *(void *)(a2 + 104) = *(void *)(a1 + 24);
  return result;
}

void GPU::CumulativeProductOpHandler::~CumulativeProductOpHandler(GPU::CumulativeProductOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);

  JUMPOUT(0x1852FDE70);
}

unint64_t GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeProductOp,(MPSNDArrayScanOperation)1>::getJITStaticOperandRepr(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  if (a4 == 1) {
    return GPU::BaseOpHandler::_getJITStaticOperandReprConstant(this, a2, a3, 1u);
  }
  else {
    return GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(this, a2, a3, a4);
  }
}

void GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeMaximumOp,(MPSNDArrayScanOperation)2>::encodeNDArrayOp(uint64_t a1, GPU::EncodeDescriptor *a2, void *a3)
{
  v82[1] = *MEMORY[0x1E4F143B8];
  id v71 = a3;
  uint64_t v5 = *(void *)(*(void *)(a1 + 24) + 48);
  uint64_t v6 = *(void **)(v5 + 16);
  if (v6 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v80[0] = *(void *)(v5 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v80);
    if (v68 == 22)
    {
      BOOL v69 = *AttrData == 0x756D75632E73706DLL && AttrData[1] == 0x6D5F65766974616CLL;
      if (v69 && *(void *)((char *)AttrData + 14) == 0x6D756D6978616D5FLL)
      {
        __int16 v79 = 1283;
        v76[0] = (uint64_t)"classof on '";
        unint64_t v77 = "mps.cumulative_maximum";
        uint64_t v78 = 22;
        v74[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v75 = 259;
        llvm::operator+(v76, v74, (uint64_t)v80);
        llvm::report_fatal_error((llvm::Twine *)v80, 1);
      }
    }
LABEL_94:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v6 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeMaximumOp,void>::id) {
    goto LABEL_94;
  }
  uint64_t v73 = *(void *)(a1 + 24);
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v73);
  uint64_t Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v73);
  uint64_t v9 = [v71 objectAtIndexedSubscript:0];
  uint64_t v10 = *(int8x8_t **)(a1 + 16);
  v80[0] = Input;
  ParentRegion = mlir::Value::getParentRegion((mlir::Value *)v80);
  int8x8_t v12 = v10[12];
  if (!*(void *)&v12) {
    goto LABEL_44;
  }
  unint64_t v13 = *((void *)ParentRegion + 2);
  unint64_t v14 = 0x9DDFEA08EB382D69 * (((8 * v13) + 8) ^ HIDWORD(v13));
  unint64_t v15 = 0x9DDFEA08EB382D69 * (HIDWORD(v13) ^ (v14 >> 47) ^ v14);
  unint64_t v16 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
  uint8x8_t v17 = (uint8x8_t)vcnt_s8(v12);
  v17.i16[0] = vaddlv_u8(v17);
  if (v17.u32[0] > 1uLL)
  {
    unint64_t v18 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
    if (v16 >= *(void *)&v12) {
      unint64_t v18 = v16 % *(void *)&v12;
    }
  }
  else
  {
    unint64_t v18 = v16 & (*(void *)&v12 - 1);
  }
  unint64_t v19 = *(void **)(*(void *)&v10[11] + 8 * v18);
  if (!v19) {
    goto LABEL_44;
  }
  __int16 v20 = (void *)*v19;
  if (!v20) {
    goto LABEL_44;
  }
  if (v17.u32[0] < 2uLL)
  {
    uint64_t v21 = *(void *)&v12 - 1;
    while (1)
    {
      uint64_t v23 = v20[1];
      if (v23 == v16)
      {
        if (v20[2] == v13) {
          goto LABEL_24;
        }
      }
      else if ((v23 & v21) != v18)
      {
        goto LABEL_44;
      }
      __int16 v20 = (void *)*v20;
      if (!v20) {
        goto LABEL_44;
      }
    }
  }
  while (1)
  {
    unint64_t v22 = v20[1];
    if (v22 == v16) {
      break;
    }
    if (v22 >= *(void *)&v12) {
      v22 %= *(void *)&v12;
    }
    if (v22 != v18) {
      goto LABEL_44;
    }
LABEL_13:
    __int16 v20 = (void *)*v20;
    if (!v20) {
      goto LABEL_44;
    }
  }
  if (v20[2] != v13) {
    goto LABEL_13;
  }
LABEL_24:
  int8x8_t v24 = (int8x8_t)v20[4];
  if (!*(void *)&v24) {
    goto LABEL_44;
  }
  unint64_t v25 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v80[0])) + 8) ^ HIDWORD(v80[0]));
  unint64_t v26 = 0x9DDFEA08EB382D69 * (HIDWORD(v80[0]) ^ (v25 >> 47) ^ v25);
  unint64_t v27 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
  uint8x8_t v28 = (uint8x8_t)vcnt_s8(v24);
  v28.i16[0] = vaddlv_u8(v28);
  if (v28.u32[0] > 1uLL)
  {
    unint64_t v29 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
    if (v27 >= *(void *)&v24) {
      unint64_t v29 = v27 % *(void *)&v24;
    }
  }
  else
  {
    unint64_t v29 = v27 & (*(void *)&v24 - 1);
  }
  unint64_t v30 = *(uint64_t ****)(v20[3] + 8 * v29);
  if (!v30 || (uint64_t v31 = *v30) == 0)
  {
LABEL_44:
    uint64_t v33 = 0;
    goto LABEL_45;
  }
  if (v28.u32[0] < 2uLL)
  {
    uint64_t v32 = *(void *)&v24 - 1;
    while (1)
    {
      unint64_t v35 = v31[1];
      if (v35 == (uint64_t *)v27)
      {
        if (v31[2] == (uint64_t *)v80[0]) {
          goto LABEL_76;
        }
      }
      else if (((unint64_t)v35 & v32) != v29)
      {
        goto LABEL_44;
      }
      uint64_t v33 = 0;
      uint64_t v31 = (uint64_t **)*v31;
      if (!v31) {
        goto LABEL_45;
      }
    }
  }
  while (1)
  {
    unint64_t v34 = (unint64_t)v31[1];
    if (v34 == v27) {
      break;
    }
    if (v34 >= *(void *)&v24) {
      v34 %= *(void *)&v24;
    }
    if (v34 != v29) {
      goto LABEL_44;
    }
LABEL_34:
    uint64_t v33 = 0;
    uint64_t v31 = (uint64_t **)*v31;
    if (!v31) {
      goto LABEL_45;
    }
  }
  if (v31[2] != (uint64_t *)v80[0]) {
    goto LABEL_34;
  }
LABEL_76:
  uint64_t v33 = v31[3];
LABEL_45:
  int v36 = objc_msgSend(v33, "mpsndarray", v71);
  __int16 v37 = [v9 mpsndarray];
  id v38 = *(id *)(a1 + 8);
  uint64_t Axis = RuntimeUtils::getAxis(*(void *)(a1 + 16), (uint64_t)a2, Filter, [v36 numberOfDimensions]);
  uint64_t v40 = [v36 numberOfDimensions];
  if (Axis >= 0) {
    uint64_t v41 = v40;
  }
  else {
    uint64_t v41 = 0;
  }
  [v38 setAxis:v41 + ~Axis];
  [v38 setExclusive:mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v73)];
  [v38 setReverse:mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v73)];
  if (*(void *)(a1 + 32))
  {
    uint64_t v42 = *(void *)(mlir::Block::getParentOp(*(mlir::Block **)(*(void *)(a1 + 24) + 16)) + 48);
    if (*(_UNKNOWN **)(v42 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v80[0] = *(void *)(v42 + 8);
      unint64_t v43 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v80);
      if (v44 == 13 && *v43 == 0x6974732E7873706DLL && *(void *)((char *)v43 + 5) == 0x6465686374697473)
      {
        __int16 v79 = 1283;
        v76[0] = (uint64_t)"classof on '";
        unint64_t v77 = "mpsx.stitched";
        uint64_t v78 = 13;
        v74[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v75 = 259;
        llvm::operator+(v76, v74, (uint64_t)v80);
        llvm::report_fatal_error((llvm::Twine *)v80, 1);
      }
    }
    uint64_t v46 = *(void *)(mlir::Block::getParentOp(*(mlir::Block **)(*(void *)(a1 + 24) + 16)) + 48);
    uint64_t v47 = *(void **)(v46 + 16);
    if (v47 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v80[0] = *(void *)(v46 + 8);
      int8x8_t v64 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v80);
      if (v65 == 13 && *v64 == 0x6974732E7873706DLL && *(void *)((char *)v64 + 5) == 0x6465686374697473)
      {
        __int16 v79 = 1283;
        v76[0] = (uint64_t)"classof on '";
        unint64_t v77 = "mpsx.stitched";
        uint64_t v78 = 13;
        v80[0] = v76;
        v80[2] = "' failed due to the operation not being registered";
        __int16 v81 = 770;
        llvm::report_fatal_error((llvm::Twine *)v80, 1);
      }
    }
    else if (v47 == &mlir::detail::TypeIDResolver<mlir::mpsx::StitchedOp,void>::id)
    {
      goto LABEL_57;
    }
    if (MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
LABEL_57:
    uint64_t v48 = GPU::MPSGraphKernelDAG::getNDArraysForPlaceholders(*(GPU::MPSGraphKernelDAG **)(a1 + 32), *(GPURegionRuntime **)(a1 + 16));
    uint64_t v49 = (void *)*((void *)a2 + 9);
    if (!v49)
    {
      uint64_t v50 = [objc_alloc(MEMORY[0x1E4F35528]) initWithCommandBuffer:*((void *)a2 + 1) withDispatchType:0];
      uint64_t v51 = (void *)*((void *)a2 + 9);
      *((void *)a2 + 9) = v50;

      int8x8_t v52 = (void *)*((void *)a2 + 11);
      uint64_t v49 = (void *)*((void *)a2 + 9);
      if (v52)
      {
        uint64_t v53 = [v52 wrapComputeEncoder:*((void *)a2 + 9)];
        unint64_t v54 = (void *)*((void *)a2 + 9);
        *((void *)a2 + 9) = v53;

        uint64_t v49 = (void *)*((void *)a2 + 9);
      }
    }
    if (*((void *)a2 + 10))
    {
      objc_msgSend(v49, "setLabel:");
      uint64_t v49 = (void *)*((void *)a2 + 9);
    }
    id v55 = v49;
    uint64_t v56 = *((void *)a2 + 1);
    uint64_t v57 = *(void *)(a1 + 32);
    uint64_t v58 = *(void **)(v57 + 120);
    if (!v58)
    {
      if (!*(void *)(v57 + 96) && MTLReportFailureTypeEnabled()) {
        MTLReportFailure();
      }
      uint64_t v59 = [objc_alloc(MEMORY[0x1E4F35608]) initWithKernelDAG:v57 + 80 finalOp:*(void *)(*(void *)(v57 + 96) + 32)];
      unint64_t v61 = *(void **)(v57 + 120);
      uint64_t v60 = (uint64_t *)(v57 + 120);
      *uint64_t v60 = v59;

      uint64_t v58 = (void *)*v60;
    }
    id v62 = v58;
    [v38 encodeToMPSCommandEncoder:v55 commandBuffer:v56 sourceArrays:v48 resultState:0 destinationArray:v37 kernelDAGObject:v62];
  }
  else
  {
    if (!v36 && MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    uint64_t v48 = GPU::EncodeDescriptor::getcomputeEncoder(a2);
    uint64_t v63 = *((void *)a2 + 1);
    v82[0] = v36;
    id v55 = [MEMORY[0x1E4F1C978] arrayWithObjects:v82 count:1];
    [v38 encodeToMPSCommandEncoder:v48 commandBuffer:v63 sourceArrays:v55 destinationArray:v37];
  }
}

void sub_180D82CFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

uint64_t GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeMaximumOp,(MPSNDArrayScanOperation)2>::kernelDAGOp(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 24) + 48);
  int v3 = *(void **)(v2 + 16);
  if (v3 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v16[0] = *(void *)(v2 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v16);
    if (v9 == 22
      && *AttrData == 0x756D75632E73706DLL
      && AttrData[1] == 0x6D5F65766974616CLL
      && *(void *)((char *)AttrData + 14) == 0x6D756D6978616D5FLL)
    {
      __int16 v15 = 1283;
      v14[0] = (uint64_t)"classof on '";
      v14[2] = (uint64_t)"mps.cumulative_maximum";
      v14[3] = 22;
      int8x8_t v12 = "' failed due to the operation not being registered";
      __int16 v13 = 259;
      llvm::operator+(v14, (uint64_t *)&v12, (uint64_t)v16);
      llvm::report_fatal_error((llvm::Twine *)v16, 1);
    }
LABEL_14:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v3 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeMaximumOp,void>::id) {
    goto LABEL_14;
  }
  v16[0] = *(void *)(a1 + 24);
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)v16);
  GPU::MPSGraphKernelDAG::getBaseTensorFromDataMap(a2, Input, 0);
  uint64_t result = MPSKernelDAG::unaryCoreOp();
  *(void *)(a2 + 104) = *(void *)(a1 + 24);
  return result;
}

void GPU::CumulativeMaximumOpHandler::~CumulativeMaximumOpHandler(GPU::CumulativeMaximumOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);

  JUMPOUT(0x1852FDE70);
}

unint64_t GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeMaximumOp,(MPSNDArrayScanOperation)2>::getJITStaticOperandRepr(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  if (a4 == 1) {
    return GPU::BaseOpHandler::_getJITStaticOperandReprConstant(this, a2, a3, 1u);
  }
  else {
    return GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(this, a2, a3, a4);
  }
}

void GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeMinimumOp,(MPSNDArrayScanOperation)3>::encodeNDArrayOp(uint64_t a1, GPU::EncodeDescriptor *a2, void *a3)
{
  v82[1] = *MEMORY[0x1E4F143B8];
  id v71 = a3;
  uint64_t v5 = *(void *)(*(void *)(a1 + 24) + 48);
  uint64_t v6 = *(void **)(v5 + 16);
  if (v6 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v80[0] = *(void *)(v5 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v80);
    if (v68 == 22)
    {
      BOOL v69 = *AttrData == 0x756D75632E73706DLL && AttrData[1] == 0x6D5F65766974616CLL;
      if (v69 && *(void *)((char *)AttrData + 14) == 0x6D756D696E696D5FLL)
      {
        __int16 v79 = 1283;
        v76[0] = (uint64_t)"classof on '";
        unint64_t v77 = "mps.cumulative_minimum";
        uint64_t v78 = 22;
        v74[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v75 = 259;
        llvm::operator+(v76, v74, (uint64_t)v80);
        llvm::report_fatal_error((llvm::Twine *)v80, 1);
      }
    }
LABEL_94:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v6 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeMinimumOp,void>::id) {
    goto LABEL_94;
  }
  uint64_t v73 = *(void *)(a1 + 24);
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v73);
  uint64_t Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v73);
  uint64_t v9 = [v71 objectAtIndexedSubscript:0];
  uint64_t v10 = *(int8x8_t **)(a1 + 16);
  v80[0] = Input;
  ParentRegion = mlir::Value::getParentRegion((mlir::Value *)v80);
  int8x8_t v12 = v10[12];
  if (!*(void *)&v12) {
    goto LABEL_44;
  }
  unint64_t v13 = *((void *)ParentRegion + 2);
  unint64_t v14 = 0x9DDFEA08EB382D69 * (((8 * v13) + 8) ^ HIDWORD(v13));
  unint64_t v15 = 0x9DDFEA08EB382D69 * (HIDWORD(v13) ^ (v14 >> 47) ^ v14);
  unint64_t v16 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
  uint8x8_t v17 = (uint8x8_t)vcnt_s8(v12);
  v17.i16[0] = vaddlv_u8(v17);
  if (v17.u32[0] > 1uLL)
  {
    unint64_t v18 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
    if (v16 >= *(void *)&v12) {
      unint64_t v18 = v16 % *(void *)&v12;
    }
  }
  else
  {
    unint64_t v18 = v16 & (*(void *)&v12 - 1);
  }
  unint64_t v19 = *(void **)(*(void *)&v10[11] + 8 * v18);
  if (!v19) {
    goto LABEL_44;
  }
  __int16 v20 = (void *)*v19;
  if (!v20) {
    goto LABEL_44;
  }
  if (v17.u32[0] < 2uLL)
  {
    uint64_t v21 = *(void *)&v12 - 1;
    while (1)
    {
      uint64_t v23 = v20[1];
      if (v23 == v16)
      {
        if (v20[2] == v13) {
          goto LABEL_24;
        }
      }
      else if ((v23 & v21) != v18)
      {
        goto LABEL_44;
      }
      __int16 v20 = (void *)*v20;
      if (!v20) {
        goto LABEL_44;
      }
    }
  }
  while (1)
  {
    unint64_t v22 = v20[1];
    if (v22 == v16) {
      break;
    }
    if (v22 >= *(void *)&v12) {
      v22 %= *(void *)&v12;
    }
    if (v22 != v18) {
      goto LABEL_44;
    }
LABEL_13:
    __int16 v20 = (void *)*v20;
    if (!v20) {
      goto LABEL_44;
    }
  }
  if (v20[2] != v13) {
    goto LABEL_13;
  }
LABEL_24:
  int8x8_t v24 = (int8x8_t)v20[4];
  if (!*(void *)&v24) {
    goto LABEL_44;
  }
  unint64_t v25 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v80[0])) + 8) ^ HIDWORD(v80[0]));
  unint64_t v26 = 0x9DDFEA08EB382D69 * (HIDWORD(v80[0]) ^ (v25 >> 47) ^ v25);
  unint64_t v27 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
  uint8x8_t v28 = (uint8x8_t)vcnt_s8(v24);
  v28.i16[0] = vaddlv_u8(v28);
  if (v28.u32[0] > 1uLL)
  {
    unint64_t v29 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
    if (v27 >= *(void *)&v24) {
      unint64_t v29 = v27 % *(void *)&v24;
    }
  }
  else
  {
    unint64_t v29 = v27 & (*(void *)&v24 - 1);
  }
  unint64_t v30 = *(uint64_t ****)(v20[3] + 8 * v29);
  if (!v30 || (uint64_t v31 = *v30) == 0)
  {
LABEL_44:
    uint64_t v33 = 0;
    goto LABEL_45;
  }
  if (v28.u32[0] < 2uLL)
  {
    uint64_t v32 = *(void *)&v24 - 1;
    while (1)
    {
      unint64_t v35 = v31[1];
      if (v35 == (uint64_t *)v27)
      {
        if (v31[2] == (uint64_t *)v80[0]) {
          goto LABEL_76;
        }
      }
      else if (((unint64_t)v35 & v32) != v29)
      {
        goto LABEL_44;
      }
      uint64_t v33 = 0;
      uint64_t v31 = (uint64_t **)*v31;
      if (!v31) {
        goto LABEL_45;
      }
    }
  }
  while (1)
  {
    unint64_t v34 = (unint64_t)v31[1];
    if (v34 == v27) {
      break;
    }
    if (v34 >= *(void *)&v24) {
      v34 %= *(void *)&v24;
    }
    if (v34 != v29) {
      goto LABEL_44;
    }
LABEL_34:
    uint64_t v33 = 0;
    uint64_t v31 = (uint64_t **)*v31;
    if (!v31) {
      goto LABEL_45;
    }
  }
  if (v31[2] != (uint64_t *)v80[0]) {
    goto LABEL_34;
  }
LABEL_76:
  uint64_t v33 = v31[3];
LABEL_45:
  int v36 = objc_msgSend(v33, "mpsndarray", v71);
  __int16 v37 = [v9 mpsndarray];
  id v38 = *(id *)(a1 + 8);
  uint64_t Axis = RuntimeUtils::getAxis(*(void *)(a1 + 16), (uint64_t)a2, Filter, [v36 numberOfDimensions]);
  uint64_t v40 = [v36 numberOfDimensions];
  if (Axis >= 0) {
    uint64_t v41 = v40;
  }
  else {
    uint64_t v41 = 0;
  }
  [v38 setAxis:v41 + ~Axis];
  [v38 setExclusive:mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v73)];
  [v38 setReverse:mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v73)];
  if (*(void *)(a1 + 32))
  {
    uint64_t v42 = *(void *)(mlir::Block::getParentOp(*(mlir::Block **)(*(void *)(a1 + 24) + 16)) + 48);
    if (*(_UNKNOWN **)(v42 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v80[0] = *(void *)(v42 + 8);
      unint64_t v43 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v80);
      if (v44 == 13 && *v43 == 0x6974732E7873706DLL && *(void *)((char *)v43 + 5) == 0x6465686374697473)
      {
        __int16 v79 = 1283;
        v76[0] = (uint64_t)"classof on '";
        unint64_t v77 = "mpsx.stitched";
        uint64_t v78 = 13;
        v74[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v75 = 259;
        llvm::operator+(v76, v74, (uint64_t)v80);
        llvm::report_fatal_error((llvm::Twine *)v80, 1);
      }
    }
    uint64_t v46 = *(void *)(mlir::Block::getParentOp(*(mlir::Block **)(*(void *)(a1 + 24) + 16)) + 48);
    uint64_t v47 = *(void **)(v46 + 16);
    if (v47 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v80[0] = *(void *)(v46 + 8);
      int8x8_t v64 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v80);
      if (v65 == 13 && *v64 == 0x6974732E7873706DLL && *(void *)((char *)v64 + 5) == 0x6465686374697473)
      {
        __int16 v79 = 1283;
        v76[0] = (uint64_t)"classof on '";
        unint64_t v77 = "mpsx.stitched";
        uint64_t v78 = 13;
        v80[0] = v76;
        v80[2] = "' failed due to the operation not being registered";
        __int16 v81 = 770;
        llvm::report_fatal_error((llvm::Twine *)v80, 1);
      }
    }
    else if (v47 == &mlir::detail::TypeIDResolver<mlir::mpsx::StitchedOp,void>::id)
    {
      goto LABEL_57;
    }
    if (MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
LABEL_57:
    uint64_t v48 = GPU::MPSGraphKernelDAG::getNDArraysForPlaceholders(*(GPU::MPSGraphKernelDAG **)(a1 + 32), *(GPURegionRuntime **)(a1 + 16));
    uint64_t v49 = (void *)*((void *)a2 + 9);
    if (!v49)
    {
      uint64_t v50 = [objc_alloc(MEMORY[0x1E4F35528]) initWithCommandBuffer:*((void *)a2 + 1) withDispatchType:0];
      uint64_t v51 = (void *)*((void *)a2 + 9);
      *((void *)a2 + 9) = v50;

      int8x8_t v52 = (void *)*((void *)a2 + 11);
      uint64_t v49 = (void *)*((void *)a2 + 9);
      if (v52)
      {
        uint64_t v53 = [v52 wrapComputeEncoder:*((void *)a2 + 9)];
        unint64_t v54 = (void *)*((void *)a2 + 9);
        *((void *)a2 + 9) = v53;

        uint64_t v49 = (void *)*((void *)a2 + 9);
      }
    }
    if (*((void *)a2 + 10))
    {
      objc_msgSend(v49, "setLabel:");
      uint64_t v49 = (void *)*((void *)a2 + 9);
    }
    id v55 = v49;
    uint64_t v56 = *((void *)a2 + 1);
    uint64_t v57 = *(void *)(a1 + 32);
    uint64_t v58 = *(void **)(v57 + 120);
    if (!v58)
    {
      if (!*(void *)(v57 + 96) && MTLReportFailureTypeEnabled()) {
        MTLReportFailure();
      }
      uint64_t v59 = [objc_alloc(MEMORY[0x1E4F35608]) initWithKernelDAG:v57 + 80 finalOp:*(void *)(*(void *)(v57 + 96) + 32)];
      unint64_t v61 = *(void **)(v57 + 120);
      uint64_t v60 = (uint64_t *)(v57 + 120);
      *uint64_t v60 = v59;

      uint64_t v58 = (void *)*v60;
    }
    id v62 = v58;
    [v38 encodeToMPSCommandEncoder:v55 commandBuffer:v56 sourceArrays:v48 resultState:0 destinationArray:v37 kernelDAGObject:v62];
  }
  else
  {
    if (!v36 && MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    uint64_t v48 = GPU::EncodeDescriptor::getcomputeEncoder(a2);
    uint64_t v63 = *((void *)a2 + 1);
    v82[0] = v36;
    id v55 = [MEMORY[0x1E4F1C978] arrayWithObjects:v82 count:1];
    [v38 encodeToMPSCommandEncoder:v48 commandBuffer:v63 sourceArrays:v55 destinationArray:v37];
  }
}

void sub_180D83784(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

uint64_t GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeMinimumOp,(MPSNDArrayScanOperation)3>::kernelDAGOp(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 24) + 48);
  int v3 = *(void **)(v2 + 16);
  if (v3 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v16[0] = *(void *)(v2 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v16);
    if (v9 == 22
      && *AttrData == 0x756D75632E73706DLL
      && AttrData[1] == 0x6D5F65766974616CLL
      && *(void *)((char *)AttrData + 14) == 0x6D756D696E696D5FLL)
    {
      __int16 v15 = 1283;
      v14[0] = (uint64_t)"classof on '";
      v14[2] = (uint64_t)"mps.cumulative_minimum";
      v14[3] = 22;
      int8x8_t v12 = "' failed due to the operation not being registered";
      __int16 v13 = 259;
      llvm::operator+(v14, (uint64_t *)&v12, (uint64_t)v16);
      llvm::report_fatal_error((llvm::Twine *)v16, 1);
    }
LABEL_14:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v3 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeMinimumOp,void>::id) {
    goto LABEL_14;
  }
  v16[0] = *(void *)(a1 + 24);
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)v16);
  GPU::MPSGraphKernelDAG::getBaseTensorFromDataMap(a2, Input, 0);
  uint64_t result = MPSKernelDAG::unaryCoreOp();
  *(void *)(a2 + 104) = *(void *)(a1 + 24);
  return result;
}

void GPU::CumulativeMinimumOpHandler::~CumulativeMinimumOpHandler(GPU::CumulativeMinimumOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);

  JUMPOUT(0x1852FDE70);
}

unint64_t GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeMinimumOp,(MPSNDArrayScanOperation)3>::getJITStaticOperandRepr(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  if (a4 == 1) {
    return GPU::BaseOpHandler::_getJITStaticOperandReprConstant(this, a2, a3, 1u);
  }
  else {
    return GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(this, a2, a3, a4);
  }
}

void GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeSumOp,(MPSNDArrayScanOperation)0>::~BaseCumulativeOpHandler(GPU::BaseOpHandler *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(a1);

  JUMPOUT(0x1852FDE70);
}

void GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeProductOp,(MPSNDArrayScanOperation)1>::~BaseCumulativeOpHandler(GPU::BaseOpHandler *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(a1);

  JUMPOUT(0x1852FDE70);
}

void GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeMaximumOp,(MPSNDArrayScanOperation)2>::~BaseCumulativeOpHandler(GPU::BaseOpHandler *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(a1);

  JUMPOUT(0x1852FDE70);
}

void GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeMinimumOp,(MPSNDArrayScanOperation)3>::~BaseCumulativeOpHandler(GPU::BaseOpHandler *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(a1);

  JUMPOUT(0x1852FDE70);
}

GPU::TensorToMemrefOpHandler *GPU::TensorToMemrefOpHandler::TensorToMemrefOpHandler(GPU::TensorToMemrefOpHandler *this, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  *(void *)GPU::BaseOpHandler::BaseOpHandler(this, a2, a3, a4) = &unk_1EC9A07C8;
  id v6 = objc_alloc(MEMORY[0x1E4F35770]);
  __int16 v7 = [*(id *)(*((void *)this + 2) + 48) metalDevice];
  uint64_t v8 = [v6 initWithDevice:v7];
  uint64_t v9 = (void *)*((void *)this + 1);
  *((void *)this + 1) = v8;

  uint64_t v10 = *((void *)a3 + 6);
  uint64_t v11 = *(void **)(v10 + 16);
  if (v11 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v28[0] = *(void *)(v10 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v28);
    if (v19 == 26
      && *(void *)AttrData == 0x6E656D6563616C70
      && *(void *)(AttrData + 8) == 0x726F736E65742E74
      && *(void *)(AttrData + 16) == 0x726D656D5F6F745FLL
      && *(_WORD *)(AttrData + 24) == 26213)
    {
      __int16 v27 = 1283;
      v26[0] = (uint64_t)"classof on '";
      unint64_t v26[2] = (uint64_t)"placement.tensor_to_memref";
      v26[3] = 26;
      int8x8_t v24 = "' failed due to the operation not being registered";
      __int16 v25 = 259;
      llvm::operator+(v26, (uint64_t *)&v24, (uint64_t)v28);
      llvm::report_fatal_error((llvm::Twine *)v28, 1);
    }
    goto LABEL_23;
  }
  if (v11 != &mlir::detail::TypeIDResolver<mlir::placement::TensorToMemref,void>::id)
  {
LABEL_23:
    unint64_t v14 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v15 = 578;
    goto LABEL_8;
  }
  uint64_t v23 = a3;
  unint64_t v12 = *(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v23) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (!*(void *)v12)
  {
    unint64_t v14 = "abstractType && \"Malformed type storage object.\"";
    int v15 = 160;
    unint64_t v16 = "TypeSupport.h";
    uint8x8_t v17 = "getAbstractType";
    goto LABEL_9;
  }
  if (*(_UNKNOWN **)(*(void *)v12 + 136) != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
  {
    unint64_t v14 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v15 = 566;
LABEL_8:
    unint64_t v16 = "Casting.h";
    uint8x8_t v17 = "cast";
LABEL_9:
    __assert_rtn(v17, v16, v15, v14);
  }
  *((void *)this + 15) = getMemRefRowBytes(v12);
  *((void *)this + 16) = 0;
  return this;
}

void sub_180D83D04(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void sub_180D83D1C(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void sub_180D83D30(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

BOOL GPU::TensorToMemrefOpHandler::inputRequiresCopy(GPU::TensorToMemrefOpHandler *this, MPSGraphTensorData *a2)
{
  int v3 = a2;
  uint64_t v4 = [(MPSGraphTensorData *)v3 mpsndarray];
  if ((vminvq_u8((uint8x16_t)vceqq_s8(*(int8x16_t *)&v4[*MEMORY[0x1E4F359B0]], (int8x16_t)xmmword_18112ADB0)) & 0x80) != 0)
  {
    id v6 = [(MPSGraphTensorData *)v3 mpsndarray];
    __int16 v7 = (int32x4_t *)&v6[*MEMORY[0x1E4F359A8]];
    int32x4_t v16 = v7[1];
    int32x4_t v17 = v7[3];
    int32x4_t v14 = *v7;
    int32x4_t v15 = v7[2];
    uint64_t v8 = [(MPSGraphTensorData *)v3 mpsndarray];
    if ((vminvq_u32((uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vceqq_s32(v14, *(int32x4_t *)&v8[*MEMORY[0x1E4F359D8]]), (int8x16_t)vceqq_s32(v15, *(int32x4_t *)&v8[*MEMORY[0x1E4F359D8] + 32])), vandq_s8((int8x16_t)vceqq_s32(v16, *(int32x4_t *)&v8[*MEMORY[0x1E4F359D8] + 16]), (int8x16_t)vceqq_s32(v17, *(int32x4_t *)&v8[*MEMORY[0x1E4F359D8] + 48])))) & 0x80000000) != 0)
    {
      uint64_t v9 = [(MPSGraphTensorData *)v3 mpsndarray];
      BOOL v5 = (vminvq_u32((uint32x4_t)vceqzq_s32((int32x4_t)vorrq_s8(vorrq_s8(*(int8x16_t *)&v9[*MEMORY[0x1E4F359E0]], *(int8x16_t *)&v9[*MEMORY[0x1E4F359E0] + 32]), vorrq_s8(*(int8x16_t *)&v9[*MEMORY[0x1E4F359E0] + 16], *(int8x16_t *)&v9[*MEMORY[0x1E4F359E0] + 48])))) & 0x80000000) == 0;
    }
    else
    {
      BOOL v5 = 1;
    }
  }
  else
  {
    BOOL v5 = 1;
  }

  uint64_t v10 = [(MPSGraphTensorData *)v3 mpsndarray];
  char v11 = *(void *)&v10[*MEMORY[0x1E4F359D0]] != *((void *)this + 15) || v5;
  BOOL v12 = (v11 & 1) != 0 || *((void *)this + 16) == 0x4000;

  return v12;
}

void sub_180D83EFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D83F28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t GPU::TensorToMemrefOpHandler::setAlignBytes(uint64_t this, uint64_t a2)
{
  uint64_t v3 = this;
  if ((a2 & 0xFFFFFFFFFFFFBFFFLL) != 0 && (this = MTLReportFailureTypeEnabled(), this))
  {
    this = MTLReportFailure();
    *(void *)(v3 + 128) = a2;
  }
  else
  {
    *(void *)(v3 + 128) = a2;
  }
  return this;
}

void GPU::TensorToMemrefOpHandler::encodeOp(GPU::TensorToMemrefOpHandler *this, GPU::EncodeDescriptor *a2)
{
  v72[5] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(*((void *)this + 3) + 48);
  uint64_t v3 = *(void **)(v2 + 16);
  if (v3 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t __s2 = *(void **)(v2 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&__s2);
    if (v59 == 26)
    {
      BOOL v60 = *(void *)AttrData == 0x6E656D6563616C70 && *(void *)(AttrData + 8) == 0x726F736E65742E74;
      BOOL v61 = v60 && *(void *)(AttrData + 16) == 0x726D656D5F6F745FLL;
      if (v61 && *(_WORD *)(AttrData + 24) == 26213)
      {
        __int16 v68 = 1283;
        memptr[0] = "classof on '";
        memptr[2] = "placement.tensor_to_memref";
        memptr[3] = (void *)26;
        v65[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v66 = 259;
        llvm::operator+((uint64_t *)memptr, v65, (uint64_t)&__s2);
        llvm::report_fatal_error((llvm::Twine *)&__s2, 1);
      }
    }
LABEL_73:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v3 != &mlir::detail::TypeIDResolver<mlir::placement::TensorToMemref,void>::id) {
    goto LABEL_73;
  }
  int8x8_t v64 = (mlir::Operation *)*((void *)this + 3);
  unint64_t Input = (void *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v64);
  uint64_t Result = (void *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v64);
  uint64_t v8 = *((void *)this + 2);
  uint64_t __s2 = Input;
  memptr[0] = *((void **)mlir::Value::getParentRegion((mlir::Value *)&__s2) + 2);
  uint64_t v9 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v8 + 88), (uint64_t *)memptr);
  if (v9
    && (v65[0] = (uint64_t)__s2,
        (uint64_t v10 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v9 + 3, v65)) != 0))
  {
    char v11 = (MPSGraphTensorData *)(id)v10[3];
  }
  else
  {
    char v11 = 0;
  }
  uint64_t v12 = *((void *)this + 2);
  uint64_t __s2 = Result;
  memptr[0] = *((void **)mlir::Value::getParentRegion((mlir::Value *)&__s2) + 2);
  __int16 v13 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v12 + 88), (uint64_t *)memptr);
  if (v13
    && (v65[0] = (uint64_t)__s2,
        (int32x4_t v14 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v13 + 3, v65)) != 0))
  {
    id v63 = (id)v14[3];
  }
  else
  {
    id v63 = 0;
  }
  BOOL v15 = GPU::TensorToMemrefOpHandler::inputRequiresCopy(this, v11);
  if (v63) {
    char v16 = 1;
  }
  else {
    char v16 = v15;
  }
  if ((v16 & 1) == 0)
  {
    uint64_t v33 = [(MPSGraphTensorData *)v11 mpsndarray];
    objc_opt_class();
    char isKindOfClass = objc_opt_isKindOfClass();

    if (isKindOfClass)
    {
      unint64_t v35 = [(MPSGraphTensorData *)v11 mpsndarray];
      int v36 = v35;
      __int16 v37 = (void *)*Result;
      if (*Result)
      {
        int v38 = 0;
        do
        {
          ++v38;
          __int16 v37 = (void *)*v37;
        }
        while (v37);
        uint64_t v39 = v38;
      }
      else
      {
        uint64_t v39 = 0;
      }
      objc_msgSend(v35, "setReadCount:", objc_msgSend(v35, "readCount", v63) + v39);
    }
    BaseRuntime::setTensorDataToDataMap(*((void *)this + 2), Result, v11);
    goto LABEL_50;
  }
  if (mlir::placement::MemrefToTensor::getInterleaveAttr(&v64))
  {
    unsigned int Interleave = mlir::placement::MemrefToTensor::getInterleave(&v64);
    ANENextSupportedInterleaveuint64_t Value = mlir::getANENextSupportedInterleaveValue(Interleave);
    if (ANENextSupportedInterleaveValue != mlir::placement::MemrefToTensor::getInterleave(&v64))
    {
      if (MTLReportFailureTypeEnabled()) {
        MTLReportFailure();
      }
    }
  }
  uint64_t v19 = *(void *)(*((void *)this + 2) + 424);
  if (v19)
  {
    uint64_t v20 = *((void *)this + 3);
    uint64_t v21 = *(unsigned int *)(v19 + 136);
    if (v21 >= *(_DWORD *)(v19 + 140))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v19 + 128, (void *)(v19 + 144), v21 + 1, 8);
      *(void *)(*(void *)(v19 + 128) + 8 * *(unsigned int *)(v19 + 136)) = v20;
      unsigned int v22 = *(_DWORD *)(v19 + 136);
      if (v22 < *(_DWORD *)(v19 + 140)) {
        goto LABEL_22;
      }
    }
    else
    {
      *(void *)(*(void *)(v19 + 128) + 8 * v21) = v20;
      unsigned int v22 = *(_DWORD *)(v19 + 136);
      if (v22 < *(_DWORD *)(v19 + 140))
      {
LABEL_22:
        *(_DWORD *)(v19 + 136) = v22 + 1;
        goto LABEL_23;
      }
    }
    __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
  }
LABEL_23:
  uint64_t v23 = [(MPSGraphTensorData *)v11 mpsndarray];
  if (!v23 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  if (*((unsigned char *)v23 + (int)*MEMORY[0x1E4F359C0])) {
    objc_msgSend(v23, "setReadCount:", objc_msgSend(v23, "readCount") + 1);
  }
  mlir::placement::TensorToMemref::getOutputShapeBeforeInterleave(&v64, (uint64_t)&__s2);
  int8x8_t v24 = (void *)MEMORY[0x1E4F35720];
  uint64_t v25 = [v23 dataType];
  unint64_t v26 = getMPSShapeFromMLIR((uint64_t *)__s2, v71);
  __int16 v27 = [v24 descriptorWithDataType:v25 shape:v26];

  *(void *)((char *)v27 + (int)*MEMORY[0x1E4F35A10]) = *((void *)this + 15);
  if (*((void *)this + 16) == 0x4000)
  {
    memptr[0] = 0;
    size_t v29 = GPU::calculateNDArrayAllocationSize(v27, v28);
    if ((malloc_type_posix_memalign(memptr, *((void *)this + 16), v29, 0x91C3134BuLL) || !memptr[0])
      && MTLReportFailureTypeEnabled())
    {
      MTLReportFailure();
    }
    unint64_t v30 = [*(id *)(*((void *)this + 2) + 48) metalDevice];
    uint64_t v31 = (void *)[v30 newBufferWithBytesNoCopy:memptr[0] length:v29 options:0 deallocator:&__block_literal_global_1];

    uint64_t v32 = (void *)[objc_alloc(MEMORY[0x1E4F35690]) initWithBuffer:v31 descriptor:v27];
  }
  else
  {
    id v40 = objc_alloc(MEMORY[0x1E4F35690]);
    uint64_t v41 = [*(id *)(*((void *)this + 2) + 48) metalDevice];
    uint64_t v32 = (void *)[v40 initWithDevice:v41 descriptor:v27];
  }
  uint64_t v42 = (uint64_t **)(Input[1] & 0xFFFFFFFFFFFFFFF8);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v42))
  {
    uint64_t v44 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v45 = 566;
    uint64_t v46 = "Casting.h";
    uint64_t v47 = "cast";
LABEL_55:
    __assert_rtn(v47, v46, v45, v44);
  }
  if (v42)
  {
    uint64_t InterfaceFor = (void *)mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v42);
    if (!InterfaceFor)
    {
      uint64_t v44 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v45 = 98;
      uint64_t v46 = "InterfaceSupport.h";
      uint64_t v47 = "Interface";
      goto LABEL_55;
    }
  }
  else
  {
    uint64_t InterfaceFor = 0;
  }
  memptr[0] = v42;
  memptr[1] = InterfaceFor;
  uint64_t ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)memptr);
  if (v49 == v71 && !memcmp(ArgAttrsAttr, __s2, 8 * v71))
  {
    uint64_t v56 = (void *)*((void *)this + 1);
    uint64_t v51 = GPU::EncodeDescriptor::getcomputeEncoder(a2);
    uint64_t v57 = *((void *)a2 + 1);
    BOOL v69 = v23;
    uint64_t v53 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v69 count:1];
    [v56 encodeToMPSCommandEncoder:v51 commandBuffer:v57 sourceArrays:v53 destinationArray:v32];
  }
  else
  {
    uint64_t v50 = (void *)*((void *)this + 1);
    uint64_t v51 = GPU::EncodeDescriptor::getcomputeEncoder(a2);
    uint64_t v52 = *((void *)a2 + 1);
    uint64_t v53 = getMPSShapeFromMLIR((uint64_t *)__s2, v71);
    id v54 = (id)[v50 reshapeWithCommandEncoder:v51 commandBuffer:v52 sourceArray:v23 shape:v53 destinationArray:v32];
  }

  id v55 = [[MPSGraphTensorData alloc] initWithMPSNDArray:v32 device:*(void *)(*((void *)this + 2) + 48)];
  BaseRuntime::setTensorDataToDataMap(*((void *)this + 2), Result, v55);

  if (__s2 != v72) {
    free(__s2);
  }

LABEL_50:
}

void sub_180D846F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22)
{
  _Unwind_Resume(a1);
}

void ___ZN3GPU23TensorToMemrefOpHandler8encodeOpEPNS_16EncodeDescriptorE_block_invoke(int a1, void *a2)
{
}

GPU::MemrefToTensorOpHandler *GPU::MemrefToTensorOpHandler::MemrefToTensorOpHandler(GPU::MemrefToTensorOpHandler *this, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  *(void *)GPU::BaseOpHandler::BaseOpHandler(this, a2, a3, a4) = &unk_1EC99FF58;
  id v6 = objc_alloc(MEMORY[0x1E4F35770]);
  __int16 v7 = [*(id *)(*((void *)this + 2) + 48) metalDevice];
  uint64_t v8 = [v6 initWithDevice:v7];
  uint64_t v9 = (void *)*((void *)this + 1);
  *((void *)this + 1) = v8;

  uint64_t v10 = *((void *)a3 + 6);
  char v11 = *(void **)(v10 + 16);
  if (v11 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v28[0] = *(void *)(v10 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v28);
    if (v19 == 26
      && *(void *)AttrData == 0x6E656D6563616C70
      && *(void *)(AttrData + 8) == 0x6665726D656D2E74
      && *(void *)(AttrData + 16) == 0x736E65745F6F745FLL
      && *(_WORD *)(AttrData + 24) == 29295)
    {
      __int16 v27 = 1283;
      v26[0] = (uint64_t)"classof on '";
      unint64_t v26[2] = (uint64_t)"placement.memref_to_tensor";
      v26[3] = 26;
      int8x8_t v24 = "' failed due to the operation not being registered";
      __int16 v25 = 259;
      llvm::operator+(v26, (uint64_t *)&v24, (uint64_t)v28);
      llvm::report_fatal_error((llvm::Twine *)v28, 1);
    }
    goto LABEL_23;
  }
  if (v11 != &mlir::detail::TypeIDResolver<mlir::placement::MemrefToTensor,void>::id)
  {
LABEL_23:
    int32x4_t v14 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v15 = 578;
    goto LABEL_8;
  }
  uint64_t v23 = a3;
  unint64_t v12 = *(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v23) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (!*(void *)v12)
  {
    int32x4_t v14 = "abstractType && \"Malformed type storage object.\"";
    int v15 = 160;
    char v16 = "TypeSupport.h";
    int32x4_t v17 = "getAbstractType";
    goto LABEL_9;
  }
  if (*(_UNKNOWN **)(*(void *)v12 + 136) != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
  {
    int32x4_t v14 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v15 = 566;
LABEL_8:
    char v16 = "Casting.h";
    int32x4_t v17 = "cast";
LABEL_9:
    __assert_rtn(v17, v16, v15, v14);
  }
  *((void *)this + 15) = getMemRefRowBytes(v12);
  return this;
}

void sub_180D84A54(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void sub_180D84A6C(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void sub_180D84A80(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void GPU::MemrefToTensorOpHandler::encodeOp(GPU::MemrefToTensorOpHandler *this, void **a2)
{
  v54[5] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(*((void *)this + 3) + 48);
  uint64_t v3 = *(void **)(v2 + 16);
  if (v3 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t __s2 = *(void **)(v2 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&__s2);
    if (v43 == 26)
    {
      BOOL v44 = *(void *)AttrData == 0x6E656D6563616C70 && *(void *)(AttrData + 8) == 0x6665726D656D2E74;
      BOOL v45 = v44 && *(void *)(AttrData + 16) == 0x736E65745F6F745FLL;
      if (v45 && *(_WORD *)(AttrData + 24) == 29295)
      {
        __int16 v51 = 1283;
        v50[0] = (uint64_t)"classof on '";
        v50[2] = (uint64_t)"placement.memref_to_tensor";
        v50[3] = 26;
        v48[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v49 = 259;
        llvm::operator+(v50, v48, (uint64_t)&__s2);
        llvm::report_fatal_error((llvm::Twine *)&__s2, 1);
      }
    }
LABEL_61:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v3 != &mlir::detail::TypeIDResolver<mlir::placement::MemrefToTensor,void>::id) {
    goto LABEL_61;
  }
  uint64_t v47 = (mlir::Operation *)*((void *)this + 3);
  unint64_t Input = (void *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v47);
  uint64_t Result = (void *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v47);
  uint64_t v8 = *((void *)this + 2);
  uint64_t __s2 = Input;
  v50[0] = *((void *)mlir::Value::getParentRegion((mlir::Value *)&__s2) + 2);
  uint64_t v9 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v8 + 88), v50);
  if (v9
    && (v48[0] = (uint64_t)__s2,
        (uint64_t v10 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v9 + 3, v48)) != 0))
  {
    id v11 = (id)v10[3];
  }
  else
  {
    id v11 = 0;
  }
  uint64_t v12 = *((void *)this + 2);
  uint64_t __s2 = Result;
  v50[0] = *((void *)mlir::Value::getParentRegion((mlir::Value *)&__s2) + 2);
  __int16 v13 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v12 + 88), v50);
  if (v13)
  {
    v48[0] = (uint64_t)__s2;
    __int16 v13 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v13 + 3, v48);
    if (v13) {
      __int16 v13 = (id)v13[3];
    }
  }
  int32x4_t v14 = v13;
  if ([v14 iosurface])
  {
    int v15 = [v14 mpsndarray];
    BOOL v16 = *(void *)&v15[*MEMORY[0x1E4F359D0]] == *((void *)this + 15);

    if (v16)
    {
      int32x4_t v17 = [v11 mpsndarray];
      BOOL v18 = v17 == 0;

      if (v18) {
        goto LABEL_38;
      }
    }
  }
  else
  {
  }
  if (mlir::placement::MemrefToTensor::getInterleaveAttr(&v47))
  {
    unsigned int Interleave = mlir::placement::MemrefToTensor::getInterleave(&v47);
    ANENextSupportedInterleaveuint64_t Value = mlir::getANENextSupportedInterleaveValue(Interleave);
    if (ANENextSupportedInterleaveValue != mlir::placement::MemrefToTensor::getInterleave(&v47))
    {
      if (MTLReportFailureTypeEnabled()) {
        MTLReportFailure();
      }
    }
  }
  uint64_t v21 = *(void *)(*((void *)this + 2) + 424);
  if (v21)
  {
    uint64_t v22 = *((void *)this + 3);
    uint64_t v23 = *(unsigned int *)(v21 + 136);
    if (v23 >= *(_DWORD *)(v21 + 140))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v21 + 128, (void *)(v21 + 144), v23 + 1, 8);
      *(void *)(*(void *)(v21 + 128) + 8 * *(unsigned int *)(v21 + 136)) = v22;
      unsigned int v24 = *(_DWORD *)(v21 + 136);
      if (v24 < *(_DWORD *)(v21 + 140)) {
        goto LABEL_22;
      }
    }
    else
    {
      *(void *)(*(void *)(v21 + 128) + 8 * v23) = v22;
      unsigned int v24 = *(_DWORD *)(v21 + 136);
      if (v24 < *(_DWORD *)(v21 + 140))
      {
LABEL_22:
        *(_DWORD *)(v21 + 136) = v24 + 1;
        goto LABEL_23;
      }
    }
    __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
  }
LABEL_23:
  __int16 v25 = [v11 mpsndarray];
  if (!v25 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  mlir::placement::MemrefToTensor::getInputShapeAfterInterleave(&v47, &__s2);
  unint64_t v26 = (uint64_t **)(Result[1] & 0xFFFFFFFFFFFFFFF8);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v26))
  {
    uint8x8_t v28 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v29 = 566;
    unint64_t v30 = "Casting.h";
    uint64_t v31 = "cast";
LABEL_43:
    __assert_rtn(v31, v30, v29, v28);
  }
  if (v26)
  {
    uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v26);
    if (!InterfaceFor)
    {
      uint8x8_t v28 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v29 = 98;
      unint64_t v30 = "InterfaceSupport.h";
      uint64_t v31 = "Interface";
      goto LABEL_43;
    }
  }
  else
  {
    uint64_t InterfaceFor = 0;
  }
  v50[0] = (uint64_t)v26;
  v50[1] = InterfaceFor;
  uint64_t ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v50);
  if (v33 == v53 && !memcmp(ArgAttrsAttr, __s2, 8 * v53))
  {
    uint64_t v41 = (void *)*((void *)this + 2);
    unint64_t v34 = GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
    GPURegionRuntime::copyNDArrayToTarget(v41, v34, a2[1], (id *)this + 1, v25, v14, Result, 0);
  }
  else
  {
    unint64_t v34 = [v14 mpsndarray];
    if (!v34 && MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    if (*((unsigned char *)v25 + (int)*MEMORY[0x1E4F359C0])) {
      objc_msgSend(v25, "setReadCount:", objc_msgSend(v25, "readCount") + 1);
    }
    unint64_t v35 = (void *)*((void *)this + 1);
    int v36 = GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
    __int16 v37 = a2[1];
    int v38 = getMPSShapeFromMLIR((uint64_t **)(Result[1] & 0xFFFFFFFFFFFFFFF8));
    uint64_t v39 = adaptForMPS(v38);
    id v40 = (id)[v35 reshapeWithCommandEncoder:v36 commandBuffer:v37 sourceArray:v25 shape:v39 destinationArray:v34];
  }
  if (__s2 != v54) {
    free(__s2);
  }

LABEL_38:
}

void sub_180D85034(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21)
{
  _Unwind_Resume(a1);
}

void GPU::TensorToMemrefOpHandler::~TensorToMemrefOpHandler(GPU::TensorToMemrefOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);

  JUMPOUT(0x1852FDE70);
}

void GPU::MemrefToTensorOpHandler::~MemrefToTensorOpHandler(GPU::MemrefToTensorOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);

  JUMPOUT(0x1852FDE70);
}

void sub_180D851BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D85510(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  _Unwind_Resume(a1);
}

void sub_180D85554(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a19 < 0)
  {
    operator delete(__p);
    if ((a25 & 0x80000000) == 0)
    {
LABEL_3:

      if ((SHIBYTE(a13) & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else if ((a25 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a20);

  if ((SHIBYTE(a13) & 0x80000000) == 0)
  {
LABEL_4:

    _Unwind_Resume(a1);
  }
LABEL_7:
  JUMPOUT(0x180D855B8);
}

void sub_180D855A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    JUMPOUT(0x180D855B8);
  }
  JUMPOUT(0x180D85574);
}

void sub_180D85AE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40)
{
  _Unwind_Resume(a1);
}

void sub_180D86094(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40)
{
  _Unwind_Resume(a1);
}

void sub_180D86640(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40)
{
  _Unwind_Resume(a1);
}

void sub_180D8681C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D869A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D86B30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D86CB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D86E44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D86FC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D87158(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D872DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::CumulativeSumOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CumulativeSumOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 18
      && *(void *)AttrData == 0x756D75632E73706DLL
      && *(void *)(AttrData + 8) == 0x735F65766974616CLL
      && *(_WORD *)(AttrData + 16) == 28021)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.cumulative_sum";
      v9[3] = 18;
      __int16 v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeSumOp,void>::id)
  {
    return 0;
  }
  return result;
}

unint64_t GPU::ResizeOpHandler::getJITStaticOperandRepr(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  if (a4 == 1) {
    return GPU::BaseOpHandler::_getJITStaticOperandReprConstant(this, a2, a3, 1u);
  }
  else {
    return GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(this, a2, a3, a4);
  }
}

unint64_t GPU::ResizeGradientOpHandler::getJITStaticOperandRepr(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  if (a4 == 1) {
    return GPU::BaseOpHandler::_getJITStaticOperandReprConstant(this, a2, a3, 1u);
  }
  else {
    return GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(this, a2, a3, a4);
  }
}

void GPU::MultiaryKernelOpHandler<GPU::ResizeOpHandler,mlir::mps::ResizeOp,MPSNDArrayResample,1ul>::encodeNDArrayOp(uint64_t a1, GPU::EncodeDescriptor *a2, void *a3)
{
  uint64_t v149 = *MEMORY[0x1E4F143B8];
  id v116 = a3;
  if (!*(unsigned char *)(a1 + 40)) {
    GPU::MultiaryKernelOpHandler<GPU::ResizeOpHandler,mlir::mps::ResizeOp,MPSNDArrayResample,1ul>::_createNDArrayMultiaryKernel(a1);
  }
  uint64_t v4 = [v116 objectAtIndexedSubscript:0];
  BOOL v5 = [v4 mpsndarray];

  if (!v5 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  id v122 = v5;
  uint64_t v6 = *(void *)(*(void *)(a1 + 24) + 48);
  __int16 v7 = *(void **)(v6 + 16);
  if (v7 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    double v140 = *(double *)(v6 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v140);
    if (v109 == 10 && *(void *)AttrData == 0x697365722E73706DLL && *(_WORD *)(AttrData + 8) == 25978)
    {
      __int16 v139 = 1283;
      v136[0] = (uint64_t *)"classof on '";
      id v137 = "mps.resize";
      uint64_t v138 = 10;
      int __p = "' failed due to the operation not being registered";
      __int16 v135 = 259;
      llvm::operator+((uint64_t *)v136, (uint64_t *)&__p, (uint64_t)&v140);
      llvm::report_fatal_error((llvm::Twine *)&v140, 1);
    }
LABEL_158:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::mps::ResizeOp,void>::id) {
    goto LABEL_158;
  }
  id v130 = *(mlir::mps **)(a1 + 24);
  *(double *)&__int16 v8 = COERCE_DOUBLE(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v130));
  uint64_t v9 = *(void *)(a1 + 16);
  double v140 = *(double *)&v8;
  v136[0] = *((uint64_t **)mlir::Value::getParentRegion((mlir::Value *)&v140) + 2);
  __int16 v10 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v9 + 88), (uint64_t *)v136);
  if (v10
    && (int __p = *(void **)&v140,
        (id v11 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v10 + 3, (uint64_t *)&__p)) != 0))
  {
    id v12 = (id)v11[3];
  }
  else
  {
    id v12 = 0;
  }
  *(double *)&uint64_t v121 = [v12 mpsndarray];

  if ((!v122 || *(double *)&v121 == 0.0) && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  if (mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v130))
  {
    uint64_t v13 = *(void *)(a1 + 16);
    uint64_t Scale = mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v130);
    GPURegionRuntime::waitAndReadFPTensorData(v13, (uint64_t)a2, Scale, (int16x8_t **)&v140);
    double v15 = v141;
    double __src = v140;
  }
  else
  {
    double v15 = 0.0;
    double __src = 0.0;
  }
  if (mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v130))
  {
    uint64_t v17 = *(void *)(a1 + 16);
    uint64_t Offset = mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v130);
    GPURegionRuntime::waitAndReadFPTensorData(v17, (uint64_t)a2, Offset, (int16x8_t **)&v140);
    double v19 = v141;
    double v118 = v140;
    if (*(void *)(a1 + 8)) {
      goto LABEL_20;
    }
  }
  else
  {
    double v19 = 0.0;
    double v118 = 0.0;
    if (*(void *)(a1 + 8)) {
      goto LABEL_20;
    }
  }
  id v20 = objc_alloc(MEMORY[0x1E4F35880]);
  uint64_t v21 = [*(id *)(*(void *)(a1 + 16) + 48) metalDevice];
  uint64_t v22 = [v20 initWithDevice:v21];
  uint64_t v23 = *(void **)(a1 + 8);
  *(void *)(a1 + 8) = v22;

LABEL_20:
  unsigned int v24 = v130;
  uint64_t ResizeLayout = mlir::mps::getResizeLayout(v130, v16);
  unsigned int v26 = ResizeLayout;
  if ((ResizeLayout & 0xFF00000000) == 0)
  {
    v136[0] = (uint64_t *)mlir::Attribute::getContext((mlir::mps *)((char *)v24 + 24));
    v136[1] = 0;
    __int16 v27 = (const char *)*((void *)v24 + 2);
    mlir::GenericProgramPoint::~GenericProgramPoint(v24);
    id v137 = v27;
    uint64_t v138 = v28;
    double v140 = 0.0;
    double v141 = 0.0;
    LODWORD(v142) = 0;
    double v143 = 0.0;
    uint64_t v144 = 0;
    int v145 = 0;
    uint64_t v146 = 0;
    uint64_t v147 = 0;
    int v148 = 0;
    int __p = 0;
    unsigned int v133 = 0;
    std::string v134 = 0;
    if ((*((unsigned char *)v24 + 46) & 0x80) == 0)
    {
LABEL_64:
      uint64_t v58 = mlir::OpBuilder::clone(v136, v24, (mlir::IRMapping *)&v140);
      if (mlir::mps::inferTypes(v58, v59)) {
        mlir::verify(v58, (mlir::Operation *)1);
      }
      __assert_rtn("getLayoutHelper", "GPUResizeOps.mm", 81, "0 && \"failed to infer output types\"");
    }
    int v29 = 0;
    unint64_t v30 = 0;
    while (1)
    {
      if (v30 >= *((unsigned int *)v24 + 17)) {
        goto LABEL_64;
      }
      unint64_t v32 = *(void *)(*((void *)v24 + 9) + 32 * v30 + 24);
      int v124 = (char *)v32;
      uint64_t v127 = 0;
      if ((llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)&v140, (unint64_t *)&v124, &v127) & 1) == 0)
      {
        uint64_t v33 = (*(uint64_t (**)(uint64_t, GPU::EncodeDescriptor *, uint64_t **, unint64_t))(*(void *)a1 + 48))(a1, a2, v136, v30);
        uint64_t v131 = v33;
        int v124 = (char *)v32;
        uint64_t v127 = 0;
        char v34 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)&v140, (unint64_t *)&v124, &v127);
        unint64_t v35 = v127;
        if ((v34 & 1) == 0)
        {
          unint64_t v35 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)&v140, (uint64_t)&v124, (unint64_t *)&v124, v127);
          void *v35 = v124;
          v35[1] = 0;
        }
        v35[1] = v33;
        if (v32 != v131)
        {
          if (mlir::Value::getDefiningOp((mlir::Value *)&v131)) {
            break;
          }
        }
      }
LABEL_25:
      ++v30;
      if ((*((unsigned char *)v24 + 46) & 0x80) == 0) {
        goto LABEL_64;
      }
    }
    uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v131);
    uint64_t v37 = DefiningOp;
    if (v29 < v134)
    {
      *(void *)int v29 = DefiningOp;
      uint64_t v31 = v29 + 8;
    }
    else
    {
      int v38 = (char *)__p;
      int64_t v39 = v29 - (unsigned char *)__p;
      uint64_t v40 = (v29 - (unsigned char *)__p) >> 3;
      unint64_t v41 = v40 + 1;
      if ((unint64_t)(v40 + 1) >> 61) {
        std::vector<int>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v42 = v134 - (unsigned char *)__p;
      if ((v134 - (unsigned char *)__p) >> 2 > v41) {
        unint64_t v41 = v42 >> 2;
      }
      if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v43 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v43 = v41;
      }
      if (v43)
      {
        if (v43 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        BOOL v44 = operator new(8 * v43);
        BOOL v45 = (uint64_t *)&v44[8 * v40];
        *BOOL v45 = v37;
        uint64_t v31 = (char *)(v45 + 1);
        int64_t v46 = v29 - v38;
        if (v29 != v38)
        {
LABEL_42:
          unint64_t v47 = v46 - 8;
          if (v47 >= 0x168)
          {
            unint64_t v51 = (v29 - 8 - v38) & 0xFFFFFFFFFFFFFFF8;
            if (&v44[v39 - 8 - v51] > &v44[v39 - 8])
            {
              uint64_t v48 = v29;
            }
            else if (&v29[-v51 - 8] > v29 - 8)
            {
              uint64_t v48 = v29;
            }
            else if ((unint64_t)(v29 - v44 - v39) >= 0x20)
            {
              uint64_t v52 = (v47 >> 3) + 1;
              uint64_t v53 = 8 * (v52 & 0x3FFFFFFFFFFFFFFCLL);
              uint64_t v48 = &v29[-v53];
              BOOL v45 = (uint64_t *)((char *)v45 - v53);
              id v54 = &v44[v39 - 16];
              id v55 = v29 - 16;
              uint64_t v56 = v52 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v57 = *(_OWORD *)v55;
                *(v54 - 1) = *((_OWORD *)v55 - 1);
                *id v54 = v57;
                v54 -= 2;
                v55 -= 32;
                v56 -= 4;
              }
              while (v56);
              if (v52 == (v52 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_45:
                int v29 = (char *)__p;
                int __p = v45;
                unsigned int v133 = v31;
                std::string v134 = &v44[8 * v43];
                if (!v29) {
                  goto LABEL_24;
                }
                goto LABEL_49;
              }
            }
            else
            {
              uint64_t v48 = v29;
            }
          }
          else
          {
            uint64_t v48 = v29;
          }
          do
          {
            uint64_t v49 = *((void *)v48 - 1);
            v48 -= 8;
            *--BOOL v45 = v49;
          }
          while (v48 != v38);
          goto LABEL_45;
        }
      }
      else
      {
        BOOL v44 = 0;
        BOOL v45 = (uint64_t *)(8 * v40);
        uint64_t v50 = (uint64_t *)(8 * v40);
        *uint64_t v50 = v37;
        uint64_t v31 = (char *)(v50 + 1);
        int64_t v46 = v29 - v38;
        if (v29 != v38) {
          goto LABEL_42;
        }
      }
      int __p = v45;
      unsigned int v133 = v31;
      std::string v134 = &v44[8 * v43];
      if (v29) {
LABEL_49:
      }
        operator delete(v29);
    }
LABEL_24:
    unsigned int v133 = v31;
    int v29 = v31;
    goto LABEL_25;
  }
  id v115 = *(id *)(a1 + 8);
  BOOL v60 = (uint64_t *)v130;
  mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v130);
  uint64_t v112 = [(int16x8_t *)v121 descriptor];
  id v113 = [v122 descriptor];
  uint64_t v127 = 0;
  id v128 = 0;
  __int16 v129 = 0;
  int64_t v61 = *(void *)&v15 - *(void *)&__src;
  if (*(void *)&v15 != *(void *)&__src)
  {
    if (v61 < 0) {
      std::vector<long>::__throw_length_error[abi:ne180100]();
    }
    id v62 = operator new(*(void *)&v15 - *(void *)&__src);
    id v63 = (char *)v62 + 4 * (v61 >> 2);
    uint64_t v127 = v62;
    __int16 v129 = v63;
    id v117 = (char *)v62;
    memcpy(v62, *(const void **)&__src, v61);
    id v128 = v63;
    int v124 = 0;
    uint64_t v125 = 0;
    uint64_t v126 = 0;
    int64_t v64 = *(void *)&v19 - *(void *)&v118;
    if (*(void *)&v19 != *(void *)&v118) {
      goto LABEL_69;
    }
LABEL_72:
    __int16 v66 = 0;
    uint64_t v65 = 0;
    goto LABEL_73;
  }
  id v63 = 0;
  id v117 = 0;
  int v124 = 0;
  uint64_t v125 = 0;
  uint64_t v126 = 0;
  int64_t v64 = *(void *)&v19 - *(void *)&v118;
  if (*(void *)&v19 == *(void *)&v118) {
    goto LABEL_72;
  }
LABEL_69:
  if (v64 < 0) {
    std::vector<long>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v65 = (char *)operator new(v64);
  __int16 v66 = &v65[4 * (v64 >> 2)];
  int v124 = v65;
  uint64_t v126 = v66;
  memcpy(v65, *(const void **)&v118, v64);
  uint64_t v125 = v66;
LABEL_73:
  v136[0] = v60;
  id v67 = v115;
  id v68 = v112;
  id v120 = v113;
  uint64_t v114 = v68;
  if (v26 <= 6 && ((1 << v26) & 0x51) != 0) {
    goto LABEL_75;
  }
  if ((v26 & 0xFFFFFFFB) != 1)
  {
    if (MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
LABEL_75:
    [v68 sliceRangeForDimension:0];
    unint64_t v70 = v69;
    [v68 sliceRangeForDimension:1];
    unint64_t v72 = v71;
    [v120 sliceRangeForDimension:0];
    unint64_t v74 = v73;
    [v120 sliceRangeForDimension:1];
    unint64_t v76 = v75;
    unsigned int v111 = 0;
    if (v117 != v63) {
      goto LABEL_92;
    }
    goto LABEL_76;
  }
  [v68 sliceRangeForDimension:1];
  unint64_t v70 = v85;
  [v68 sliceRangeForDimension:2];
  unint64_t v72 = v86;
  [v120 sliceRangeForDimension:1];
  unint64_t v74 = v87;
  [v120 sliceRangeForDimension:2];
  unint64_t v76 = v88;
  unsigned int v111 = 1;
  if (v117 != v63) {
    goto LABEL_92;
  }
LABEL_76:
  if (v65 == v66)
  {
    BOOL IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)v136);
    BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)v136);
    int v79 = !IsSize || InferredResultTypes;
    if (v79) {
      float v80 = 0.0;
    }
    else {
      float v80 = (float)((float)((float)v76 / (float)v72) + -1.0) * 0.5;
    }
    if (v79) {
      float v81 = 0.0;
    }
    else {
      float v81 = (float)((float)((float)v74 / (float)v70) + -1.0) * 0.5;
    }
    if (InferredResultTypes) {
      float v82 = (float)(v76 - 1) / (float)(v72 - 1);
    }
    else {
      float v82 = (float)v76 / (float)v72;
    }
    if (InferredResultTypes) {
      float v83 = (float)(v74 - 1) / (float)(v70 - 1);
    }
    else {
      float v83 = (float)v74 / (float)v70;
    }
    unint64_t v84 = v117;
    goto LABEL_101;
  }
LABEL_92:
  if (v26 >= 7 || ((0x73u >> v26) & 1) == 0) {
    llvm::llvm_unreachable_internal((llvm *)"unhandled TensorDataLayout enum.", "../mlir-mps/third_party/mlir-apple/include/Dialect/MPS/Utils/MPSTypeUtils.h", (const char *)0x69);
  }
  uint64_t v89 = 8 * (int)v26;
  unint64_t v90 = *(void *)((char *)&unk_18112AF18 + v89);
  uint64_t v91 = *(void *)((char *)&unk_18112AF50 + v89);
  unint64_t v84 = v117;
  if (v117 != v63)
  {
    if (v90 >= (v63 - v117) >> 2 && MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    float v82 = *(float *)&v117[4 * v90];
    float v83 = *(float *)&v117[4 * v91];
    if (v65 != v66) {
      goto LABEL_97;
    }
LABEL_100:
    float v80 = 0.0;
    float v81 = 0.0;
    goto LABEL_101;
  }
  float v82 = 1.0;
  float v83 = 1.0;
  if (v65 == v66) {
    goto LABEL_100;
  }
LABEL_97:
  if (v90 >= (v66 - v65) >> 2 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  float v80 = *(float *)&v65[4 * v90];
  float v81 = *(float *)&v65[4 * v91];
LABEL_101:
  if ((mlir::mps::ResizeGradientOp::getNearestRoundingMode((mlir::mps::ResizeGradientOp *)v136) & 0xFF00000000) != 0)
  {
    uint64_t NearestRoundingMode = mlir::mps::ResizeGradientOp::getNearestRoundingMode((mlir::mps::ResizeGradientOp *)v136);
    if (NearestRoundingMode >= 6) {
      __assert_rtn("MPSGraphNearestRoundingModeToNDArrayNearestRoundingMode", "GPUResizeOps.mm", 50, "0 && \"Invalid nearest rounding mode\"");
    }
  }
  else
  {
    uint64_t NearestRoundingMode = 0;
  }
  double v140 = v83;
  double v141 = v82;
  double v142 = v81;
  double v143 = v80;
  [v67 setScaleTransform:&v140];
  uint64_t GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)v136);
  if (GateLayout >= 2) {
    __assert_rtn("MPSGraphResizeModeToNDArrayResampleMode", "GPUResizeOps.mm", 30, "0 && \"Invalid resize mode\"");
  }
  [v67 setResampleMode:GateLayout];
  [v67 setNearestMode:NearestRoundingMode];
  [v67 setDataFormat:v111];
  objc_msgSend(v67, "setOptions:", objc_msgSend(v67, "options") | 1);

  if (v65)
  {
    uint64_t v125 = v65;
    operator delete(v65);
  }
  if (v84)
  {
    id v128 = v84;
    operator delete(v84);
  }

  if (*(void *)(a1 + 32))
  {
    uint64_t v94 = *(void *)(mlir::Block::getParentOp(*(mlir::Block **)(*(void *)(a1 + 24) + 16)) + 48);
    if (*(_UNKNOWN **)(v94 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      double v140 = *(double *)(v94 + 8);
      uint64_t v95 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v140);
      if (v96 == 13 && *v95 == 0x6974732E7873706DLL && *(void *)((char *)v95 + 5) == 0x6465686374697473)
      {
        __int16 v139 = 1283;
        v136[0] = (uint64_t *)"classof on '";
        id v137 = "mpsx.stitched";
        uint64_t v138 = 13;
        int __p = "' failed due to the operation not being registered";
        __int16 v135 = 259;
        llvm::operator+((uint64_t *)v136, (uint64_t *)&__p, (uint64_t)&v140);
        llvm::report_fatal_error((llvm::Twine *)&v140, 1);
      }
    }
    uint64_t v98 = *(void *)(mlir::Block::getParentOp(*(mlir::Block **)(*(void *)(a1 + 24) + 16)) + 48);
    uint64_t v99 = *(void **)(v98 + 16);
    if (v99 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      double v140 = *(double *)(v98 + 8);
      uint64_t v105 = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v140);
      if (v106 == 13 && *v105 == 0x6974732E7873706DLL && *(void *)((char *)v105 + 5) == 0x6465686374697473)
      {
        __int16 v139 = 1283;
        v136[0] = (uint64_t *)"classof on '";
        id v137 = "mpsx.stitched";
        uint64_t v138 = 13;
        double v140 = COERCE_DOUBLE(v136);
        double v142 = COERCE_DOUBLE("' failed due to the operation not being registered");
        LOWORD(v144) = 770;
        llvm::report_fatal_error((llvm::Twine *)&v140, 1);
      }
    }
    else if (v99 == &mlir::detail::TypeIDResolver<mlir::mpsx::StitchedOp,void>::id)
    {
LABEL_119:
      uint64_t v100 = GPU::MPSGraphKernelDAG::getNDArraysForPlaceholders(*(GPU::MPSGraphKernelDAG **)(a1 + 32), *(GPURegionRuntime **)(a1 + 16));
      id v101 = GPU::EncodeDescriptor::getcomputeEncoder(a2);
      uint64_t v102 = *((void *)a2 + 1);
      char v103 = GPU::MPSGraphKernelDAG::getKernelDAGObject(*(GPU::MPSGraphKernelDAG **)(a1 + 32));
      [v67 encodeToMPSCommandEncoder:v101 commandBuffer:v102 sourceArrays:v100 resultState:0 destinationArray:v122 kernelDAGObject:v103];

      goto LABEL_121;
    }
    if (MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    goto LABEL_119;
  }
  uint64_t v100 = GPU::EncodeDescriptor::getcomputeEncoder(a2);
  uint64_t v104 = *((void *)a2 + 1);
  double v140 = *(double *)&v121;
  id v101 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v140 count:1];
  [v67 encodeToMPSCommandEncoder:v100 commandBuffer:v104 sourceArrays:v101 destinationArray:v122];
LABEL_121:

  if (v118 != 0.0) {
    operator delete(*(void **)&v118);
  }
  if (__src != 0.0) {
    operator delete(*(void **)&__src);
  }
}

void sub_180D885FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id a15, void *__p, void *a17, void *a18, uint64_t a19, uint64_t a20,void *a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33)
{
  _Unwind_Resume(a1);
}

uint64_t GPU::ResizeOpHandler::kernelDAGOp(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 24) + 48);
  uint64_t v3 = *(void **)(v2 + 16);
  if (v3 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v15[0] = *(void *)(v2 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v15);
    if (v9 == 10 && *(void *)AttrData == 0x697365722E73706DLL && *(_WORD *)(AttrData + 8) == 25978)
    {
      __int16 v14 = 1283;
      v13[0] = (uint64_t)"classof on '";
      v13[2] = (uint64_t)"mps.resize";
      v13[3] = 10;
      id v11 = "' failed due to the operation not being registered";
      __int16 v12 = 259;
      llvm::operator+(v13, (uint64_t *)&v11, (uint64_t)v15);
      llvm::report_fatal_error((llvm::Twine *)v15, 1);
    }
LABEL_11:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v3 != &mlir::detail::TypeIDResolver<mlir::mps::ResizeOp,void>::id) {
    goto LABEL_11;
  }
  v15[0] = *(void *)(a1 + 24);
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)v15);
  GPU::MPSGraphKernelDAG::getBaseTensorFromDataMap(a2, Input, 0);
  uint64_t result = MPSKernelDAG::unaryCoreOp();
  *(void *)(a2 + 104) = *(void *)(a1 + 24);
  return result;
}

void GPU::ResizeOpHandler::~ResizeOpHandler(GPU::ResizeOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);

  JUMPOUT(0x1852FDE70);
}

void GPU::MultiaryKernelOpHandler<GPU::ResizeGradientOpHandler,mlir::mps::ResizeGradientOp,MPSNDArrayResampleGradient,1ul>::encodeNDArrayOp(uint64_t a1, void **a2, void *a3)
{
  uint64_t v147 = *MEMORY[0x1E4F143B8];
  id v114 = a3;
  if (!*(unsigned char *)(a1 + 40)) {
    GPU::MultiaryKernelOpHandler<GPU::ResizeGradientOpHandler,mlir::mps::ResizeGradientOp,MPSNDArrayResampleGradient,1ul>::_createNDArrayMultiaryKernel(a1);
  }
  uint64_t v4 = [v114 objectAtIndexedSubscript:0];
  BOOL v5 = [v4 mpsndarray];

  uint64_t v106 = v5;
  if (!v5 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  id v115 = v5;
  uint64_t v6 = *(void *)(*(void *)(a1 + 24) + 48);
  __int16 v7 = *(void **)(v6 + 16);
  if (v7 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    double v138 = *(double *)(v6 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v138);
    if (v103 == 19)
    {
      BOOL v104 = *AttrData == 0x697365722E73706DLL && AttrData[1] == 0x69646172675F657ALL;
      if (v104 && *(void *)((char *)AttrData + 11) == 0x746E656964617267)
      {
        __int16 v134 = 1283;
        uint64_t Context = "classof on '";
        uint64_t v132 = "mps.resize_gradient";
        uint64_t v133 = 19;
        int __p = "' failed due to the operation not being registered";
        __int16 v129 = 259;
        llvm::operator+((uint64_t *)&Context, (uint64_t *)&__p, (uint64_t)&v138);
        llvm::report_fatal_error((llvm::Twine *)&v138, 1);
      }
    }
LABEL_149:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::mps::ResizeGradientOp,void>::id) {
    goto LABEL_149;
  }
  uint64_t v125 = *(mlir::mps **)(a1 + 24);
  *(double *)&__int16 v8 = COERCE_DOUBLE(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v125));
  mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v125);
  uint64_t v9 = *(void *)(a1 + 16);
  double v138 = *(double *)&v8;
  uint64_t Context = (const char *)*((void *)mlir::Value::getParentRegion((mlir::Value *)&v138) + 2);
  __int16 v10 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v9 + 88), (uint64_t *)&Context);
  if (v10
    && (int __p = *(void **)&v138,
        (id v11 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v10 + 3, (uint64_t *)&__p)) != 0))
  {
    id v12 = (id)v11[3];
  }
  else
  {
    id v12 = 0;
  }
  uint64_t v112 = [v12 mpsndarray];

  if ((!v115 || !v112) && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  if (mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v125))
  {
    uint64_t v13 = *(void *)(a1 + 16);
    uint64_t Scale = mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v125);
    GPURegionRuntime::waitAndReadFPTensorData(v13, (uint64_t)a2, Scale, (int16x8_t **)&v138);
    double v15 = v138;
    double v16 = v139;
  }
  else
  {
    double v16 = 0.0;
    double v15 = 0.0;
  }
  double __src = v15;
  if (mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v125))
  {
    uint64_t v18 = *(void *)(a1 + 16);
    uint64_t Offset = mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v125);
    GPURegionRuntime::waitAndReadFPTensorData(v18, (uint64_t)a2, Offset, (int16x8_t **)&v138);
    double v20 = v138;
    double v119 = v139;
  }
  else
  {
    double v119 = 0.0;
    double v20 = 0.0;
  }
  uint64_t v21 = v125;
  double v117 = v20;
  uint64_t ResizeLayout = mlir::mps::getResizeLayout(v125, v17);
  if ((ResizeLayout & 0xFF00000000) == 0)
  {
    uint64_t Context = (const char *)mlir::Attribute::getContext((mlir::mps *)((char *)v21 + 24));
    uint64_t v131 = 0;
    uint64_t v23 = (const char *)*((void *)v21 + 2);
    mlir::GenericProgramPoint::~GenericProgramPoint(v21);
    uint64_t v132 = v23;
    uint64_t v133 = v24;
    double v138 = 0.0;
    double v139 = 0.0;
    LODWORD(v140) = 0;
    double v141 = 0.0;
    uint64_t v142 = 0;
    int v143 = 0;
    uint64_t v144 = 0;
    uint64_t v145 = 0;
    int v146 = 0;
    int __p = 0;
    uint64_t v127 = 0;
    id v128 = 0;
    if ((*((unsigned char *)v21 + 46) & 0x80) == 0)
    {
LABEL_62:
      id v54 = mlir::OpBuilder::clone((uint64_t **)&Context, v21, (mlir::IRMapping *)&v138);
      if (mlir::mps::inferTypes(v54, v55)) {
        mlir::verify(v54, (mlir::Operation *)1);
      }
      __assert_rtn("getLayoutHelper", "GPUResizeOps.mm", 81, "0 && \"failed to infer output types\"");
    }
    __int16 v25 = 0;
    unint64_t v26 = 0;
    while (1)
    {
      if (v26 >= *((unsigned int *)v21 + 17)) {
        goto LABEL_62;
      }
      unint64_t v28 = *(void *)(*((void *)v21 + 9) + 32 * v26 + 24);
      unint64_t v136 = v28;
      id v137 = 0;
      if ((llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)&v138, &v136, &v137) & 1) == 0)
      {
        uint64_t v29 = (*(uint64_t (**)(uint64_t, void **, const char **, unint64_t))(*(void *)a1 + 48))(a1, a2, &Context, v26);
        uint64_t v135 = v29;
        unint64_t v136 = v28;
        id v137 = 0;
        char v30 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)&v138, &v136, &v137);
        uint64_t v31 = v137;
        if ((v30 & 1) == 0)
        {
          uint64_t v31 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)&v138, (uint64_t)&v136, &v136, v137);
          *uint64_t v31 = v136;
          v31[1] = 0;
        }
        v31[1] = v29;
        if (v28 != v135)
        {
          if (mlir::Value::getDefiningOp((mlir::Value *)&v135)) {
            break;
          }
        }
      }
LABEL_23:
      ++v26;
      if ((*((unsigned char *)v21 + 46) & 0x80) == 0) {
        goto LABEL_62;
      }
    }
    uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v135);
    uint64_t v33 = DefiningOp;
    if (v25 < v128)
    {
      *(void *)__int16 v25 = DefiningOp;
      __int16 v27 = v25 + 8;
    }
    else
    {
      char v34 = (char *)__p;
      int64_t v35 = v25 - (unsigned char *)__p;
      uint64_t v36 = (v25 - (unsigned char *)__p) >> 3;
      unint64_t v37 = v36 + 1;
      if ((unint64_t)(v36 + 1) >> 61) {
        std::vector<int>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v38 = v128 - (unsigned char *)__p;
      if ((v128 - (unsigned char *)__p) >> 2 > v37) {
        unint64_t v37 = v38 >> 2;
      }
      if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v39 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v39 = v37;
      }
      if (v39)
      {
        if (v39 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v40 = operator new(8 * v39);
        unint64_t v41 = (uint64_t *)&v40[8 * v36];
        uint64_t *v41 = v33;
        __int16 v27 = (char *)(v41 + 1);
        int64_t v42 = v25 - v34;
        if (v25 != v34)
        {
LABEL_40:
          unint64_t v43 = v42 - 8;
          if (v43 >= 0x168)
          {
            unint64_t v47 = (v25 - 8 - v34) & 0xFFFFFFFFFFFFFFF8;
            if (&v40[v35 - 8 - v47] > &v40[v35 - 8])
            {
              BOOL v44 = v25;
            }
            else if (&v25[-v47 - 8] > v25 - 8)
            {
              BOOL v44 = v25;
            }
            else if ((unint64_t)(v25 - v40 - v35) >= 0x20)
            {
              uint64_t v48 = (v43 >> 3) + 1;
              uint64_t v49 = 8 * (v48 & 0x3FFFFFFFFFFFFFFCLL);
              BOOL v44 = &v25[-v49];
              unint64_t v41 = (uint64_t *)((char *)v41 - v49);
              uint64_t v50 = &v40[v35 - 16];
              unint64_t v51 = v25 - 16;
              uint64_t v52 = v48 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v53 = *(_OWORD *)v51;
                *(v50 - 1) = *((_OWORD *)v51 - 1);
                *uint64_t v50 = v53;
                v50 -= 2;
                v51 -= 32;
                v52 -= 4;
              }
              while (v52);
              if (v48 == (v48 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_43:
                __int16 v25 = (char *)__p;
                int __p = v41;
                uint64_t v127 = v27;
                id v128 = &v40[8 * v39];
                if (!v25) {
                  goto LABEL_22;
                }
                goto LABEL_47;
              }
            }
            else
            {
              BOOL v44 = v25;
            }
          }
          else
          {
            BOOL v44 = v25;
          }
          do
          {
            uint64_t v45 = *((void *)v44 - 1);
            v44 -= 8;
            *--unint64_t v41 = v45;
          }
          while (v44 != v34);
          goto LABEL_43;
        }
      }
      else
      {
        uint64_t v40 = 0;
        unint64_t v41 = (uint64_t *)(8 * v36);
        int64_t v46 = (uint64_t *)(8 * v36);
        *int64_t v46 = v33;
        __int16 v27 = (char *)(v46 + 1);
        int64_t v42 = v25 - v34;
        if (v25 != v34) {
          goto LABEL_40;
        }
      }
      int __p = v41;
      uint64_t v127 = v27;
      id v128 = &v40[8 * v39];
      if (v25) {
LABEL_47:
      }
        operator delete(v25);
    }
LABEL_22:
    uint64_t v127 = v27;
    __int16 v25 = v27;
    goto LABEL_23;
  }
  unsigned int v121 = ResizeLayout;
  id v56 = v112;
  id v57 = v115;
  uint64_t v58 = v57;
  id v116 = v56;
  if (*((unsigned char *)v57 + (int)*MEMORY[0x1E4F359C0])) {
    objc_msgSend(v57, "setReadCount:", objc_msgSend(v57, "readCount") + 1);
  }
  uint64_t v59 = GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
  uint64_t v123 = RuntimeUtils::convertNDArrayLayout(ResizeLayout, 6u, v116, 0, 1, v59, a2[1]);

  if (!v123)
  {
    BOOL v60 = GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
    uint64_t v123 = RuntimeUtils::convertNDArrayLayout(ResizeLayout, 6u, v116, 0, 4, v60, a2[1]);
  }
  int64_t v61 = GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
  uint64_t v113 = RuntimeUtils::convertNDArrayLayout(ResizeLayout, 6u, v58, 0, 1, v61, a2[1]);

  id v62 = (int16x8_t *)v113;
  if (!v113)
  {
    id v63 = GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
    RuntimeUtils::convertNDArrayLayout(v121, 6u, v58, 0, 4, v63, a2[1]);
    *(double *)&id v62 = COERCE_DOUBLE(objc_claimAutoreleasedReturnValue());
  }
  id v111 = *(id *)(a1 + 8);
  int64_t v64 = v125;
  id v122 = v62;
  uint64_t v108 = [(int16x8_t *)v62 descriptor];
  uint64_t v109 = [v123 descriptor];
  uint64_t Context = 0;
  uint64_t v131 = 0;
  uint64_t v132 = 0;
  int64_t v65 = *(void *)&v16 - *(void *)&__src;
  if (*(void *)&v16 != *(void *)&__src)
  {
    if (v65 < 0) {
      std::vector<long>::__throw_length_error[abi:ne180100]();
    }
    __int16 v66 = (uint64_t *)operator new(*(void *)&v16 - *(void *)&__src);
    id v67 = (char *)v66 + 4 * (v65 >> 2);
    uint64_t Context = (const char *)v66;
    uint64_t v132 = v67;
    memcpy(v66, *(const void **)&__src, v65);
    uint64_t v131 = (uint64_t *)v67;
    int __p = 0;
    uint64_t v127 = 0;
    id v128 = 0;
    int64_t v68 = *(void *)&v119 - *(void *)&v117;
    if (*(void *)&v119 != *(void *)&v117) {
      goto LABEL_73;
    }
LABEL_76:
    unint64_t v70 = 0;
    unint64_t v69 = 0;
    goto LABEL_77;
  }
  id v67 = 0;
  __int16 v66 = 0;
  int __p = 0;
  uint64_t v127 = 0;
  id v128 = 0;
  int64_t v68 = *(void *)&v119 - *(void *)&v117;
  if (*(void *)&v119 == *(void *)&v117) {
    goto LABEL_76;
  }
LABEL_73:
  if (v68 < 0) {
    std::vector<long>::__throw_length_error[abi:ne180100]();
  }
  unint64_t v69 = (char *)operator new(v68);
  unint64_t v70 = &v69[4 * (v68 >> 2)];
  int __p = v69;
  id v128 = v70;
  memcpy(v69, *(const void **)&v117, v68);
  uint64_t v127 = v70;
LABEL_77:
  id v137 = v64;
  id v71 = v111;
  id v120 = v108;
  id v72 = v109;
  uint64_t v110 = v72;
  if (v121 <= 6 && ((1 << v121) & 0x51) != 0) {
    goto LABEL_79;
  }
  if ((v121 & 0xFFFFFFFB) != 1)
  {
    if (MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
LABEL_79:
    [v120 sliceRangeForDimension:0];
    unint64_t v74 = v73;
    [v120 sliceRangeForDimension:1];
    unint64_t v76 = v75;
    [v72 sliceRangeForDimension:0];
    unint64_t v78 = v77;
    [v72 sliceRangeForDimension:1];
    unint64_t v80 = v79;
    unsigned int v107 = 0;
    if (v66 != (uint64_t *)v67) {
      goto LABEL_95;
    }
    goto LABEL_80;
  }
  [v120 sliceRangeForDimension:1];
  unint64_t v74 = v88;
  [v120 sliceRangeForDimension:2];
  unint64_t v76 = v89;
  [v72 sliceRangeForDimension:1];
  unint64_t v78 = v90;
  [v72 sliceRangeForDimension:2];
  unint64_t v80 = v91;
  unsigned int v107 = 1;
  if (v66 != (uint64_t *)v67) {
    goto LABEL_95;
  }
LABEL_80:
  if (v69 == v70)
  {
    BOOL IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v137);
    BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v137);
    int v83 = !IsSize || InferredResultTypes;
    if (v83) {
      float v84 = 0.0;
    }
    else {
      float v84 = (float)((float)((float)v80 / (float)v76) + -1.0) * 0.5;
    }
    if (v83) {
      float v85 = 0.0;
    }
    else {
      float v85 = (float)((float)((float)v78 / (float)v74) + -1.0) * 0.5;
    }
    if (InferredResultTypes) {
      float v86 = (float)(v80 - 1) / (float)(v76 - 1);
    }
    else {
      float v86 = (float)v80 / (float)v76;
    }
    if (InferredResultTypes) {
      float v87 = (float)(v78 - 1) / (float)(v74 - 1);
    }
    else {
      float v87 = (float)v78 / (float)v74;
    }
    goto LABEL_104;
  }
LABEL_95:
  if (v121 >= 7 || ((0x73u >> v121) & 1) == 0) {
    llvm::llvm_unreachable_internal((llvm *)"unhandled TensorDataLayout enum.", "../mlir-mps/third_party/mlir-apple/include/Dialect/MPS/Utils/MPSTypeUtils.h", (const char *)0x69);
  }
  uint64_t v92 = 8 * (int)v121;
  unint64_t v93 = *(void *)((char *)&unk_18112AF18 + v92);
  uint64_t v94 = *(void *)((char *)&unk_18112AF50 + v92);
  if (v66 != (uint64_t *)v67)
  {
    if (v93 >= (v67 - (const char *)v66) >> 2 && MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    float v86 = *((float *)v66 + v93);
    float v87 = *((float *)v66 + v94);
    if (v69 != v70) {
      goto LABEL_100;
    }
LABEL_103:
    float v84 = 0.0;
    float v85 = 0.0;
    goto LABEL_104;
  }
  float v86 = 1.0;
  float v87 = 1.0;
  if (v69 == v70) {
    goto LABEL_103;
  }
LABEL_100:
  if (v93 >= (v70 - v69) >> 2 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  float v84 = *(float *)&v69[4 * v93];
  float v85 = *(float *)&v69[4 * v94];
LABEL_104:
  if ((mlir::mps::ResizeGradientOp::getNearestRoundingMode((mlir::mps::ResizeGradientOp *)&v137) & 0xFF00000000) != 0)
  {
    uint64_t NearestRoundingMode = mlir::mps::ResizeGradientOp::getNearestRoundingMode((mlir::mps::ResizeGradientOp *)&v137);
    if (NearestRoundingMode >= 6) {
      __assert_rtn("MPSGraphNearestRoundingModeToNDArrayNearestRoundingMode", "GPUResizeOps.mm", 50, "0 && \"Invalid nearest rounding mode\"");
    }
  }
  else
  {
    uint64_t NearestRoundingMode = 0;
  }
  double v138 = v87;
  double v139 = v86;
  double v140 = v85;
  double v141 = v84;
  [v71 setScaleTransform:&v138];
  uint64_t GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v137);
  if (GateLayout >= 2) {
    __assert_rtn("MPSGraphResizeModeToNDArrayResampleMode", "GPUResizeOps.mm", 30, "0 && \"Invalid resize mode\"");
  }
  [v71 setResampleMode:GateLayout];
  [v71 setNearestMode:NearestRoundingMode];
  [v71 setDataFormat:v107];
  objc_msgSend(v71, "setOptions:", objc_msgSend(v71, "options") | 1);

  if (v69)
  {
    uint64_t v127 = v69;
    operator delete(v69);
  }
  if (v66)
  {
    uint64_t v131 = v66;
    operator delete(v66);
  }

  if (v122->i8[*MEMORY[0x1E4F359C0]]) {
    [(int16x8_t *)v122 setReadCount:[(int16x8_t *)v122 readCount] + 1];
  }
  uint64_t v97 = GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
  uint64_t v98 = a2[1];
  double v138 = *(double *)&v122;
  uint64_t v99 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v138 count:1];
  objc_msgSend(v71, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:sourceGradient:gradientState:destinationArray:kernelDAGObject:", v97, v98, v99, v123, 0, v122, 0, v106);

  if (v113)
  {
    if (v122->i8[*MEMORY[0x1E4F359C0]]) {
      MPSDecrementReadCount((MPSTemporaryNDArray *)v122);
    }
  }
  else
  {
    uint64_t v100 = GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
    id v101 = RuntimeUtils::convertNDArrayLayout(6u, v121, v122, v58, 4, v100, a2[1]);
  }
  if (v117 != 0.0) {
    operator delete(*(void **)&v117);
  }
  if (__src != 0.0) {
    operator delete(*(void **)&__src);
  }
}

void sub_180D89944(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, id a18, void *a19, uint64_t a20,void *__p,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35)
{
  _Unwind_Resume(a1);
}

void GPU::ResizeGradientOpHandler::~ResizeGradientOpHandler(GPU::ResizeGradientOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);

  JUMPOUT(0x1852FDE70);
}

void GPU::MultiaryKernelOpHandler<GPU::ResizeOpHandler,mlir::mps::ResizeOp,MPSNDArrayResample,1ul>::_createNDArrayMultiaryKernel(uint64_t a1)
{
  id v2 = objc_alloc(MEMORY[0x1E4F35880]);
  uint64_t v3 = [*(id *)(*(void *)(a1 + 16) + 48) metalDevice];
  obint j = (id)[v2 initWithDevice:v3];

  objc_storeStrong((id *)(a1 + 8), obj);
  objc_msgSend(*(id *)(a1 + 8), "setOptions:", objc_msgSend(*(id *)(a1 + 8), "options") | 1);
}

void sub_180D89CC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  _Unwind_Resume(a1);
}

void sub_180D89CDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void GPU::MultiaryKernelOpHandler<GPU::ResizeOpHandler,mlir::mps::ResizeOp,MPSNDArrayResample,1ul>::~MultiaryKernelOpHandler(GPU::BaseOpHandler *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(a1);

  JUMPOUT(0x1852FDE70);
}

void GPU::MultiaryKernelOpHandler<GPU::ResizeGradientOpHandler,mlir::mps::ResizeGradientOp,MPSNDArrayResampleGradient,1ul>::_createNDArrayMultiaryKernel(uint64_t a1)
{
  id v2 = objc_alloc(MEMORY[0x1E4F35888]);
  uint64_t v3 = [*(id *)(*(void *)(a1 + 16) + 48) metalDevice];
  obint j = (id)[v2 initWithDevice:v3];

  objc_storeStrong((id *)(a1 + 8), obj);
  objc_msgSend(*(id *)(a1 + 8), "setOptions:", objc_msgSend(*(id *)(a1 + 8), "options") | 1);
}

void sub_180D89DCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  _Unwind_Resume(a1);
}

void sub_180D89DE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void GPU::MultiaryKernelOpHandler<GPU::ResizeGradientOpHandler,mlir::mps::ResizeGradientOp,MPSNDArrayResampleGradient,1ul>::~MultiaryKernelOpHandler(GPU::BaseOpHandler *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(a1);

  JUMPOUT(0x1852FDE70);
}

EmitterObjC::ReductionMeanOpHandler *EmitterObjC::ReductionMeanOpHandler::ReductionMeanOpHandler(EmitterObjC::ReductionMeanOpHandler *this, id *a2, mlir::Operation *a3)
{
  v61[4] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *(void *)this = &unk_1EC9971F0;
  if (!a3) {
    __assert_rtn("dyn_cast", "Casting.h", 662, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
  }
  uint64_t v57 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionMeanOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionMeanOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)a3);
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v57);
  uint64_t Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v57);
  uint64_t v7 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v57);
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&__p, "@[");
  uint64_t v59 = v61;
  uint64_t v60 = 0x400000000;
  uint64_t v51 = v7;
  if (mlir::matchConstantWithIntVector<long long>(Axes, (uint64_t)&v59))
  {
    std::string::size_type v8 = v60;
    if (!v60)
    {
      size_t v13 = 2;
      goto LABEL_61;
    }
    __dst.__r_.__value_.__r.__words[2] = 0x300000000000000;
    *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = 0x405B40uLL;
    std::to_string(&v54, *v59);
    if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v9 = &v54;
    }
    else {
      uint64_t v9 = (std::string *)v54.__r_.__value_.__r.__words[0];
    }
    if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v54.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v54.__r_.__value_.__l.__size_;
    }
    id v11 = std::string::append(&__dst, (const std::string::value_type *)v9, size);
    id v12 = (std::string *)v11->__r_.__value_.__r.__words[0];
    *(void *)uint64_t v58 = v11->__r_.__value_.__l.__size_;
    *(void *)&v58[7] = *(std::string::size_type *)((char *)&v11->__r_.__value_.__r.__words[1] + 7);
    size_t v13 = HIBYTE(v11->__r_.__value_.__r.__words[2]);
    v11->__r_.__value_.__r.__words[0] = 0;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v12;
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(void *)&v58[7];
    __p.__r_.__value_.__l.__size_ = *(void *)v58;
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = v13;
    if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v54.__r_.__value_.__l.__data_);
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_12:
        uint64_t v50 = Input;
        if (v60 < 2) {
          goto LABEL_60;
        }
LABEL_17:
        unint64_t v14 = 1;
        while (1)
        {
          int v15 = (char)v13;
          if ((v13 & 0x80u) != 0) {
            size_t v13 = __p.__r_.__value_.__l.__size_;
          }
          unint64_t v16 = v13 + 2;
          if (v13 + 2 > 0x7FFFFFFFFFFFFFF7) {
            std::string::__throw_length_error[abi:ne180100]();
          }
          if (v16 >= 0x17)
          {
            uint64_t v22 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v16 | 7) != 0x17) {
              uint64_t v22 = v16 | 7;
            }
            uint64_t v23 = v22 + 1;
            p_dst = operator new(v22 + 1);
            __dst.__r_.__value_.__l.__size_ = v13 + 2;
            __dst.__r_.__value_.__r.__words[2] = v23 | 0x8000000000000000;
            __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
          }
          else
          {
            memset(&__dst, 0, sizeof(__dst));
            p_dst = &__dst;
            *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v13 + 2;
            if (!v13)
            {
              strcpy((char *)&__dst, ", ");
              if ((v15 & 0x80000000) == 0) {
                goto LABEL_26;
              }
LABEL_40:
              operator delete(v12);
              goto LABEL_26;
            }
          }
          if (v15 >= 0) {
            p_p = &__p;
          }
          else {
            p_p = v12;
          }
          memmove(p_dst, p_p, v13);
          strcpy((char *)p_dst + v13, ", ");
          if (v15 < 0) {
            goto LABEL_40;
          }
LABEL_26:
          std::string __p = __dst;
          int v18 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            size_t v19 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
          }
          else {
            size_t v19 = __dst.__r_.__value_.__l.__size_;
          }
          unint64_t v20 = v19 + 1;
          if (v19 + 1 > 0x7FFFFFFFFFFFFFF7) {
            std::string::__throw_length_error[abi:ne180100]();
          }
          if (v20 >= 0x17)
          {
            uint64_t v25 = (v20 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v20 | 7) != 0x17) {
              uint64_t v25 = v20 | 7;
            }
            uint64_t v26 = v25 + 1;
            uint64_t v21 = (char *)operator new(v25 + 1);
            __dst.__r_.__value_.__l.__size_ = v19 + 1;
            __dst.__r_.__value_.__r.__words[2] = v26 | 0x8000000000000000;
            __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v21;
LABEL_44:
            if (v18 >= 0) {
              __int16 v27 = &__p;
            }
            else {
              __int16 v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            memmove(v21, v27, v19);
            goto LABEL_48;
          }
          memset(&__dst, 0, sizeof(__dst));
          uint64_t v21 = (char *)&__dst;
          *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v19 + 1;
          if (v19) {
            goto LABEL_44;
          }
LABEL_48:
          *(_WORD *)&v21[v19] = 64;
          if (v14 >= v60) {
            __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
          }
          std::to_string(&v54, v59[v14]);
          if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            unint64_t v28 = &v54;
          }
          else {
            unint64_t v28 = (std::string *)v54.__r_.__value_.__r.__words[0];
          }
          if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v29 = HIBYTE(v54.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v29 = v54.__r_.__value_.__l.__size_;
          }
          char v30 = std::string::append(&__dst, (const std::string::value_type *)v28, v29);
          id v12 = (std::string *)v30->__r_.__value_.__r.__words[0];
          *(void *)uint64_t v58 = v30->__r_.__value_.__l.__size_;
          *(void *)&v58[7] = *(std::string::size_type *)((char *)&v30->__r_.__value_.__r.__words[1] + 7);
          size_t v13 = HIBYTE(v30->__r_.__value_.__r.__words[2]);
          v30->__r_.__value_.__r.__words[0] = 0;
          v30->__r_.__value_.__l.__size_ = 0;
          v30->__r_.__value_.__r.__words[2] = 0;
          if (v18 < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v12;
          __p.__r_.__value_.__l.__size_ = *(void *)v58;
          *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(void *)&v58[7];
          *((unsigned char *)&__p.__r_.__value_.__s + 23) = v13;
          if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v54.__r_.__value_.__l.__data_);
            if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_19;
            }
LABEL_59:
            operator delete(__dst.__r_.__value_.__l.__data_);
            if (++v14 >= v60) {
              goto LABEL_60;
            }
          }
          else
          {
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              goto LABEL_59;
            }
LABEL_19:
            if (++v14 >= v60) {
              goto LABEL_60;
            }
          }
        }
      }
    }
    else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_12;
    }
    operator delete(__dst.__r_.__value_.__l.__data_);
    uint64_t v50 = Input;
    if (v60 < 2)
    {
LABEL_60:
      std::string::size_type v8 = __p.__r_.__value_.__l.__size_;
      uint64_t v7 = v51;
      uint64_t Input = v50;
LABEL_61:
      int v31 = (char)v13;
      if ((v13 & 0x80u) == 0) {
        size_t v32 = v13;
      }
      else {
        size_t v32 = v8;
      }
      unint64_t v33 = v32 + 1;
      if (v32 + 1 > 0x7FFFFFFFFFFFFFF7) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      if (v33 >= 0x17)
      {
        uint64_t v47 = (v33 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v33 | 7) != 0x17) {
          uint64_t v47 = v33 | 7;
        }
        uint64_t v48 = v47 + 1;
        char v34 = (char *)operator new(v47 + 1);
        __dst.__r_.__value_.__l.__size_ = v32 + 1;
        __dst.__r_.__value_.__r.__words[2] = v48 | 0x8000000000000000;
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v34;
      }
      else
      {
        memset(&__dst, 0, sizeof(__dst));
        char v34 = (char *)&__dst;
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v32 + 1;
        if (!v32)
        {
          LOWORD(__dst.__r_.__value_.__l.__data_) = 93;
          if ((v31 & 0x80000000) == 0)
          {
LABEL_68:
            std::string __p = __dst;
            goto LABEL_69;
          }
LABEL_96:
          operator delete(__p.__r_.__value_.__l.__data_);
          goto LABEL_68;
        }
      }
      if (v31 >= 0) {
        uint64_t v49 = &__p;
      }
      else {
        uint64_t v49 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v34, v49, v32);
      *(_WORD *)&v34[v32] = 93;
      if ((v31 & 0x80000000) == 0) {
        goto LABEL_68;
      }
      goto LABEL_96;
    }
    goto LABEL_17;
  }
LABEL_69:
  int64_t v35 = NSString;
  uint64_t v36 = &__dst;
  (*((void (**)(std::string *__return_ptr, id *, uint64_t))*a2 + 4))(&__dst, a2, v7);
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    uint64_t v36 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  *(void *)uint64_t v58 = Input;
  v54.__r_.__value_.__r.__words[0] = (std::string::size_type)v58;
  unint64_t v37 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)(a2 + 32), (uint64_t *)v58, (uint64_t)&std::piecewise_construct, &v54);
  uint64_t v38 = v37 + 3;
  if (*((char *)v37 + 47) < 0) {
    uint64_t v38 = (void *)*v38;
  }
  int v39 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  std::string::size_type v40 = __p.__r_.__value_.__r.__words[0];
  char v53 = 0;
  LOBYTE(v52) = 0;
  EmitObjC::emitTensorName((uint64_t)a2, v51, (uint64_t)&v52, &v54);
  unint64_t v41 = &__p;
  if (v39 < 0) {
    unint64_t v41 = (std::string *)v40;
  }
  if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int64_t v42 = &v54;
  }
  else {
    int64_t v42 = (std::string *)v54.__r_.__value_.__r.__words[0];
  }
  objc_msgSend(v35, "stringWithFormat:", @"\n    MPSGraphTensor *%s = \n    [graph meanOfTensor:%s\n                   axes:%s\n                   name:%s];\n    ",
    v36,
    v38,
    v41,
  unint64_t v43 = v42);
  if ((SHIBYTE(v54.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v53 & 0x80000000) == 0) {
      goto LABEL_80;
    }
LABEL_87:
    operator delete(v52);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_81;
    }
    goto LABEL_88;
  }
  operator delete(v54.__r_.__value_.__l.__data_);
  if (v53 < 0) {
    goto LABEL_87;
  }
LABEL_80:
  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_81;
  }
LABEL_88:
  operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_81:
  uint64_t v44 = [a2[27] stringByAppendingString:v43];
  id v45 = a2[27];
  a2[27] = (id)v44;

  if (v59 != v61) {
    free(v59);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return this;
}

void sub_180D8A504(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  unint64_t v43 = *(void **)(v41 - 144);
  if (v43 != a15) {
    free(v43);
  }
  if (a41 < 0) {
    operator delete(a36);
  }
  _Unwind_Resume(exception_object);
}

EmitterObjC::ReductionVarianceOpHandler *EmitterObjC::ReductionVarianceOpHandler::ReductionVarianceOpHandler(EmitterObjC::ReductionVarianceOpHandler *this, id *a2, mlir::Operation *a3)
{
  v61[4] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *(void *)this = &unk_1EC997328;
  if (!a3) {
    __assert_rtn("dyn_cast", "Casting.h", 662, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
  }
  uint64_t v57 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionVarianceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionVarianceOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)a3);
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v57);
  uint64_t Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v57);
  uint64_t v7 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v57);
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&__p, "@[");
  uint64_t v59 = v61;
  uint64_t v60 = 0x400000000;
  uint64_t v51 = v7;
  if (mlir::matchConstantWithIntVector<long long>(Axes, (uint64_t)&v59))
  {
    std::string::size_type v8 = v60;
    if (!v60)
    {
      size_t v13 = 2;
      goto LABEL_61;
    }
    __dst.__r_.__value_.__r.__words[2] = 0x300000000000000;
    *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = 0x405B40uLL;
    std::to_string(&v54, *v59);
    if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v9 = &v54;
    }
    else {
      uint64_t v9 = (std::string *)v54.__r_.__value_.__r.__words[0];
    }
    if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v54.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v54.__r_.__value_.__l.__size_;
    }
    id v11 = std::string::append(&__dst, (const std::string::value_type *)v9, size);
    id v12 = (std::string *)v11->__r_.__value_.__r.__words[0];
    *(void *)uint64_t v58 = v11->__r_.__value_.__l.__size_;
    *(void *)&v58[7] = *(std::string::size_type *)((char *)&v11->__r_.__value_.__r.__words[1] + 7);
    size_t v13 = HIBYTE(v11->__r_.__value_.__r.__words[2]);
    v11->__r_.__value_.__r.__words[0] = 0;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v12;
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(void *)&v58[7];
    __p.__r_.__value_.__l.__size_ = *(void *)v58;
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = v13;
    if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v54.__r_.__value_.__l.__data_);
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_12:
        uint64_t v50 = Input;
        if (v60 < 2) {
          goto LABEL_60;
        }
LABEL_17:
        unint64_t v14 = 1;
        while (1)
        {
          int v15 = (char)v13;
          if ((v13 & 0x80u) != 0) {
            size_t v13 = __p.__r_.__value_.__l.__size_;
          }
          unint64_t v16 = v13 + 2;
          if (v13 + 2 > 0x7FFFFFFFFFFFFFF7) {
            std::string::__throw_length_error[abi:ne180100]();
          }
          if (v16 >= 0x17)
          {
            uint64_t v22 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v16 | 7) != 0x17) {
              uint64_t v22 = v16 | 7;
            }
            uint64_t v23 = v22 + 1;
            p_dst = operator new(v22 + 1);
            __dst.__r_.__value_.__l.__size_ = v13 + 2;
            __dst.__r_.__value_.__r.__words[2] = v23 | 0x8000000000000000;
            __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
          }
          else
          {
            memset(&__dst, 0, sizeof(__dst));
            p_dst = &__dst;
            *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v13 + 2;
            if (!v13)
            {
              strcpy((char *)&__dst, ", ");
              if ((v15 & 0x80000000) == 0) {
                goto LABEL_26;
              }
LABEL_40:
              operator delete(v12);
              goto LABEL_26;
            }
          }
          if (v15 >= 0) {
            p_p = &__p;
          }
          else {
            p_p = v12;
          }
          memmove(p_dst, p_p, v13);
          strcpy((char *)p_dst + v13, ", ");
          if (v15 < 0) {
            goto LABEL_40;
          }
LABEL_26:
          std::string __p = __dst;
          int v18 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            size_t v19 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
          }
          else {
            size_t v19 = __dst.__r_.__value_.__l.__size_;
          }
          unint64_t v20 = v19 + 1;
          if (v19 + 1 > 0x7FFFFFFFFFFFFFF7) {
            std::string::__throw_length_error[abi:ne180100]();
          }
          if (v20 >= 0x17)
          {
            uint64_t v25 = (v20 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v20 | 7) != 0x17) {
              uint64_t v25 = v20 | 7;
            }
            uint64_t v26 = v25 + 1;
            uint64_t v21 = (char *)operator new(v25 + 1);
            __dst.__r_.__value_.__l.__size_ = v19 + 1;
            __dst.__r_.__value_.__r.__words[2] = v26 | 0x8000000000000000;
            __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v21;
LABEL_44:
            if (v18 >= 0) {
              __int16 v27 = &__p;
            }
            else {
              __int16 v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            memmove(v21, v27, v19);
            goto LABEL_48;
          }
          memset(&__dst, 0, sizeof(__dst));
          uint64_t v21 = (char *)&__dst;
          *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v19 + 1;
          if (v19) {
            goto LABEL_44;
          }
LABEL_48:
          *(_WORD *)&v21[v19] = 64;
          if (v14 >= v60) {
            __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
          }
          std::to_string(&v54, v59[v14]);
          if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            unint64_t v28 = &v54;
          }
          else {
            unint64_t v28 = (std::string *)v54.__r_.__value_.__r.__words[0];
          }
          if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v29 = HIBYTE(v54.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v29 = v54.__r_.__value_.__l.__size_;
          }
          char v30 = std::string::append(&__dst, (const std::string::value_type *)v28, v29);
          id v12 = (std::string *)v30->__r_.__value_.__r.__words[0];
          *(void *)uint64_t v58 = v30->__r_.__value_.__l.__size_;
          *(void *)&v58[7] = *(std::string::size_type *)((char *)&v30->__r_.__value_.__r.__words[1] + 7);
          size_t v13 = HIBYTE(v30->__r_.__value_.__r.__words[2]);
          v30->__r_.__value_.__r.__words[0] = 0;
          v30->__r_.__value_.__l.__size_ = 0;
          v30->__r_.__value_.__r.__words[2] = 0;
          if (v18 < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v12;
          __p.__r_.__value_.__l.__size_ = *(void *)v58;
          *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(void *)&v58[7];
          *((unsigned char *)&__p.__r_.__value_.__s + 23) = v13;
          if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v54.__r_.__value_.__l.__data_);
            if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_19;
            }
LABEL_59:
            operator delete(__dst.__r_.__value_.__l.__data_);
            if (++v14 >= v60) {
              goto LABEL_60;
            }
          }
          else
          {
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              goto LABEL_59;
            }
LABEL_19:
            if (++v14 >= v60) {
              goto LABEL_60;
            }
          }
        }
      }
    }
    else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_12;
    }
    operator delete(__dst.__r_.__value_.__l.__data_);
    uint64_t v50 = Input;
    if (v60 < 2)
    {
LABEL_60:
      std::string::size_type v8 = __p.__r_.__value_.__l.__size_;
      uint64_t v7 = v51;
      uint64_t Input = v50;
LABEL_61:
      int v31 = (char)v13;
      if ((v13 & 0x80u) == 0) {
        size_t v32 = v13;
      }
      else {
        size_t v32 = v8;
      }
      unint64_t v33 = v32 + 1;
      if (v32 + 1 > 0x7FFFFFFFFFFFFFF7) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      if (v33 >= 0x17)
      {
        uint64_t v47 = (v33 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v33 | 7) != 0x17) {
          uint64_t v47 = v33 | 7;
        }
        uint64_t v48 = v47 + 1;
        char v34 = (char *)operator new(v47 + 1);
        __dst.__r_.__value_.__l.__size_ = v32 + 1;
        __dst.__r_.__value_.__r.__words[2] = v48 | 0x8000000000000000;
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v34;
      }
      else
      {
        memset(&__dst, 0, sizeof(__dst));
        char v34 = (char *)&__dst;
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v32 + 1;
        if (!v32)
        {
          LOWORD(__dst.__r_.__value_.__l.__data_) = 93;
          if ((v31 & 0x80000000) == 0)
          {
LABEL_68:
            std::string __p = __dst;
            goto LABEL_69;
          }
LABEL_96:
          operator delete(__p.__r_.__value_.__l.__data_);
          goto LABEL_68;
        }
      }
      if (v31 >= 0) {
        uint64_t v49 = &__p;
      }
      else {
        uint64_t v49 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v34, v49, v32);
      *(_WORD *)&v34[v32] = 93;
      if ((v31 & 0x80000000) == 0) {
        goto LABEL_68;
      }
      goto LABEL_96;
    }
    goto LABEL_17;
  }
LABEL_69:
  int64_t v35 = NSString;
  uint64_t v36 = &__dst;
  (*((void (**)(std::string *__return_ptr, id *, uint64_t))*a2 + 4))(&__dst, a2, v7);
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    uint64_t v36 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  *(void *)uint64_t v58 = Input;
  v54.__r_.__value_.__r.__words[0] = (std::string::size_type)v58;
  unint64_t v37 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)(a2 + 32), (uint64_t *)v58, (uint64_t)&std::piecewise_construct, &v54);
  uint64_t v38 = v37 + 3;
  if (*((char *)v37 + 47) < 0) {
    uint64_t v38 = (void *)*v38;
  }
  int v39 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  std::string::size_type v40 = __p.__r_.__value_.__r.__words[0];
  char v53 = 0;
  LOBYTE(v52) = 0;
  EmitObjC::emitTensorName((uint64_t)a2, v51, (uint64_t)&v52, &v54);
  uint64_t v41 = &__p;
  if (v39 < 0) {
    uint64_t v41 = (std::string *)v40;
  }
  if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int64_t v42 = &v54;
  }
  else {
    int64_t v42 = (std::string *)v54.__r_.__value_.__r.__words[0];
  }
  objc_msgSend(v35, "stringWithFormat:", @"\n    MPSGraphTensor *%s = \n    [graph varianceOfTensor:%s\n                       axes:%s\n                       name:%s];\n    ",
    v36,
    v38,
    v41,
  unint64_t v43 = v42);
  if ((SHIBYTE(v54.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v53 & 0x80000000) == 0) {
      goto LABEL_80;
    }
LABEL_87:
    operator delete(v52);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_81;
    }
    goto LABEL_88;
  }
  operator delete(v54.__r_.__value_.__l.__data_);
  if (v53 < 0) {
    goto LABEL_87;
  }
LABEL_80:
  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_81;
  }
LABEL_88:
  operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_81:
  uint64_t v44 = [a2[27] stringByAppendingString:v43];
  id v45 = a2[27];
  a2[27] = (id)v44;

  if (v59 != v61) {
    free(v59);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return this;
}

void sub_180D8ACE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  unint64_t v43 = *(void **)(v41 - 144);
  if (v43 != a15) {
    free(v43);
  }
  if (a41 < 0) {
    operator delete(a36);
  }
  _Unwind_Resume(exception_object);
}

EmitterObjC::SoftmaxOpHandler *EmitterObjC::SoftmaxOpHandler::SoftmaxOpHandler(EmitterObjC::SoftmaxOpHandler *this, id *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *(void *)this = &unk_1EC996F08;
  if (!a3) {
    __assert_rtn("dyn_cast", "Casting.h", 662, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
  }
  uint64_t v28 = llvm::DefaultDoCastIfPossible<mlir::mps::SoftmaxOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SoftmaxOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)a3);
  uint64_t Input = (uint64_t **)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v28);
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v28);
  uint64_t v7 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v28);
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  std::string::size_type v29 = (uint64_t **)&v25;
  __p.__r_.__value_.__r.__words[0] = Filter;
  if (!Filter) {
    __assert_rtn("matchPattern", "Matchers.h", 402, "value");
  }
  uint64_t v8 = v7;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&__p);
  if (DefiningOp
    && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v29, DefiningOp)
    && (unint64_t SingleInt = mlir::getSingleIntValue<long long>((uint64_t)v25, v26), v11))
  {
    uint64_t v12 = SingleInt;
  }
  else
  {
    uint64_t v12 = -1;
  }
  size_t v13 = NSString;
  unint64_t v14 = &v25;
  (*((void (**)(void **__return_ptr, id *, uint64_t))*a2 + 4))(&v25, a2, v8);
  if (v27 < 0) {
    unint64_t v14 = v25;
  }
  std::string::size_type v29 = Input;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v29;
  int v15 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)(a2 + 32), (uint64_t *)&v29, (uint64_t)&std::piecewise_construct, &__p);
  unint64_t v16 = v15 + 3;
  if (*((char *)v15 + 47) < 0) {
    unint64_t v16 = (void *)*v16;
  }
  char v23 = 0;
  LOBYTE(v22) = 0;
  EmitObjC::emitTensorName((uint64_t)a2, v8, (uint64_t)&v22, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  objc_msgSend(v13, "stringWithFormat:", @"\n    MPSGraphTensor *%s = \n    [graph softMaxWithTensor:%s\n                        axis:%ld\n                        name:%s];\n    ",
    v14,
    v16,
    v12,
  int v18 = p_p);
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v23 & 0x80000000) == 0) {
      goto LABEL_17;
    }
LABEL_20:
    operator delete(v22);
    if ((v27 & 0x80000000) == 0) {
      goto LABEL_18;
    }
LABEL_21:
    operator delete(v25);
    goto LABEL_18;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (v23 < 0) {
    goto LABEL_20;
  }
LABEL_17:
  if (v27 < 0) {
    goto LABEL_21;
  }
LABEL_18:
  uint64_t v19 = [a2[27] stringByAppendingString:v18];
  id v20 = a2[27];
  a2[27] = (id)v19;

  return this;
}

void sub_180D8B05C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180D8B06C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a24 < 0)
  {
    operator delete(a19);
    if ((a18 & 0x80000000) == 0)
    {
LABEL_3:
      if (a30 < 0) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else if ((a18 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a13);
  if (a30 < 0)
  {
LABEL_4:
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
LABEL_7:
  _Unwind_Resume(exception_object);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReductionMeanOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionMeanOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  id v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 18
      && *(void *)AttrData == 0x756465722E73706DLL
      && *(void *)(AttrData + 8) == 0x656D5F6E6F697463
      && *(_WORD *)(AttrData + 16) == 28257)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.reduction_mean";
      v9[3] = 18;
      uint64_t v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionMeanOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReductionVarianceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionVarianceOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  id v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 22
      && *AttrData == 0x756465722E73706DLL
      && AttrData[1] == 0x61765F6E6F697463
      && *(void *)((char *)AttrData + 14) == 0x65636E6169726176)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.reduction_variance";
      v9[3] = 22;
      uint64_t v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionVarianceOp,void>::id)
  {
    return 0;
  }
  return result;
}

id *GPU::PermuteOpHandler::PermuteOpHandler(id *this, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  uint64_t v38[4] = *MEMORY[0x1E4F143B8];
  BOOL v5 = GPU::BaseOpHandler::BaseOpHandler((GPU::BaseOpHandler *)this, a2, a3, a4);
  *(_OWORD *)((char *)v5 + 120) = 0u;
  uint64_t v6 = (char *)v5 + 120;
  *(void *)BOOL v5 = &unk_1EC99DE58;
  *(_OWORD *)((char *)v5 + 136) = 0u;
  *(_OWORD *)((char *)v5 + 152) = 0u;
  *(_OWORD *)((char *)v5 + 168) = 0u;
  *(_OWORD *)((char *)v5 + 184) = 0u;
  *(_OWORD *)((char *)v5 + 200) = 0u;
  *(_OWORD *)((char *)v5 + 216) = 0u;
  *(_OWORD *)((char *)v5 + 232) = 0u;
  *(_OWORD *)((char *)v5 + 248) = 0u;
  *((void *)v5 + 33) = 0;
  id v7 = objc_alloc(MEMORY[0x1E4F35770]);
  __int16 v8 = [*((id *)this[2] + 6) metalDevice];
  uint64_t v9 = [v7 initWithDevice:v8];
  id v10 = this[1];
  this[1] = (id)v9;

  objc_msgSend(this[1], "setOptions:", objc_msgSend(this[1], "options") | 1);
  uint64_t v11 = *((void *)this[3] + 6);
  uint64_t v12 = *(void **)(v11 + 16);
  if (v12 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v36 = *(void **)(v11 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v36);
    if (v29 == 11 && *AttrData == 0x6D7265702E73706DLL && *(void *)((char *)AttrData + 3) == 0x6574756D7265702ELL)
    {
      __int16 v35 = 1283;
      v34[0] = (uint64_t)"classof on '";
      v34[2] = (uint64_t)"mps.permute";
      v34[3] = 11;
      size_t v32 = "' failed due to the operation not being registered";
      __int16 v33 = 259;
      llvm::operator+(v34, (uint64_t *)&v32, (uint64_t)&v36);
      llvm::report_fatal_error((llvm::Twine *)&v36, 1);
    }
LABEL_30:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v12 != &mlir::detail::TypeIDResolver<mlir::mps::PermuteOp,void>::id) {
    goto LABEL_30;
  }
  id v31 = this[3];
  uint64_t v36 = v38;
  uint64_t v37 = 0x400000000;
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v31);
  if (!mlir::matchConstantWithIntVector<long long>(Filter, (uint64_t)&v36)) {
    goto LABEL_18;
  }
  uint64_t v14 = v37;
  if (v37)
  {
    int v15 = v36;
    size_t v16 = 8 * v37;
    uint64_t v17 = (uint64_t *)operator new(v16);
    int v18 = &v17[v14];
    memcpy(v17, v15, v16);
    uint64_t v19 = *(void **)v6;
    if (!*(void *)v6) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  uint64_t v17 = 0;
  int v18 = 0;
  uint64_t v19 = *(void **)v6;
  if (*(void *)v6)
  {
LABEL_6:
    this[16] = v19;
    operator delete(v19);
    *(void *)uint64_t v6 = 0;
    *((void *)v6 + 1) = 0;
    *((void *)v6 + 2) = 0;
  }
LABEL_7:
  this[15] = v17;
  this[16] = v18;
  this[17] = v18;
  uint64_t v20 = (char *)v18 - (char *)v17;
  if (v18 != v17)
  {
    unint64_t v21 = v20 >> 3;
    uint64_t v22 = (v20 >> 3) - 1;
    do
    {
      uint64_t v24 = *v17++;
      uint64_t v23 = v24;
      if (v24 >= 0) {
        unint64_t v25 = v21;
      }
      else {
        unint64_t v25 = 0;
      }
      uint64_t v26 = v25 + ~v23;
      if ((v26 < 0 || v26 >= v21) && MTLReportFailureTypeEnabled()) {
        MTLReportFailure();
      }
      this[v26 + 18] = (id)v22--;
    }
    while (v22 != -1);
  }
LABEL_18:
  if (v36 != v38) {
    free(v36);
  }
  return this;
}

void sub_180D8B61C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  if (a20 == v22)
  {
    uint64_t v24 = *v21;
    if (!*v21) {
      goto LABEL_3;
    }
  }
  else
  {
    free(a20);
    uint64_t v24 = *v21;
    if (!*v21)
    {
LABEL_3:
      GPU::BaseOpHandler::~BaseOpHandler(v20);
      _Unwind_Resume(a1);
    }
  }
  *((void *)v20 + 16) = v24;
  operator delete(v24);
  GPU::BaseOpHandler::~BaseOpHandler(v20);
  _Unwind_Resume(a1);
}

unint64_t GPU::PermuteOpHandler::getJITStaticOperandRepr(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  if (a4 == 1) {
    return GPU::BaseOpHandler::_getJITStaticOperandReprConstant(this, a2, a3, 1u);
  }
  else {
    return GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(this, a2, a3, a4);
  }
}

void GPU::PermuteOpHandler::encodeOp(GPU::PermuteOpHandler *this, void **a2)
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  GPU::BaseOpHandler::_inferJITOutputTypes((uint64_t)this, (GPU::EncodeDescriptor *)a2);
  uint64_t v4 = *(void *)(*((void *)this + 3) + 48);
  BOOL v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v82[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v82);
    if (v71 == 11 && *AttrData == 0x6D7265702E73706DLL && *(void *)((char *)AttrData + 3) == 0x6574756D7265702ELL)
    {
      __int16 v81 = 1283;
      v80[0] = (uint64_t)"classof on '";
      v80[2] = (uint64_t)"mps.permute";
      v80[3] = 11;
      v78[0] = "' failed due to the operation not being registered";
      __int16 v79 = 259;
      llvm::operator+(v80, (uint64_t *)v78, (uint64_t)v82);
      llvm::report_fatal_error((llvm::Twine *)v82, 1);
    }
LABEL_80:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PermuteOp,void>::id) {
    goto LABEL_80;
  }
  uint64_t v77 = *((void *)this + 3);
  uint64_t Result = (void *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v77);
  uint64_t Input = (void *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v77);
  uint64_t v8 = *((void *)this + 2);
  v82[0] = Result;
  v80[0] = *((void *)mlir::Value::getParentRegion((mlir::Value *)v82) + 2);
  uint64_t v9 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v8 + 88), v80);
  if (v9
    && (v78[0] = v82[0],
        (id v10 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v9 + 3, (uint64_t *)v78)) != 0))
  {
    id v75 = (id)v10[3];
  }
  else
  {
    id v75 = 0;
  }
  uint64_t v11 = *((void *)this + 2);
  v82[0] = Input;
  v80[0] = *((void *)mlir::Value::getParentRegion((mlir::Value *)v82) + 2);
  uint64_t v12 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v11 + 88), v80);
  if (v12
    && (v78[0] = v82[0],
        (size_t v13 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v12 + 3, (uint64_t *)v78)) != 0))
  {
    id v14 = (id)v13[3];
  }
  else
  {
    id v14 = 0;
  }
  uint64_t v15 = [v14 mpsndarray];
  id v16 = *((id *)this + 1);
  v78[0] = v16;
  unint64_t v76 = (void *)v15;
  if (!v15 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  uint64_t v17 = (uint64_t *)*((void *)this + 15);
  int v18 = (uint64_t *)*((void *)this + 16);
  id v74 = v14;
  if (v17 == v18)
  {
    uint64_t v21 = *((void *)this + 2);
    uint64_t Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v77);
    GPURegionRuntime::waitAndReadIntTensorData(v21, (uint64_t)a2, Filter, (uint64_t)v82);
    uint64_t v20 = (uint64_t *)v82[0];
    uint64_t v19 = (uint64_t *)v82[1];
    uint64_t v17 = (uint64_t *)*((void *)this + 15);
    int v18 = (uint64_t *)*((void *)this + 16);
  }
  else
  {
    uint64_t v19 = 0;
    uint64_t v20 = 0;
  }
  std::string __p = v20;
  if (v17 == v18) {
    uint64_t v23 = v20;
  }
  else {
    uint64_t v23 = v17;
  }
  if (v17 == v18) {
    uint64_t v24 = v19;
  }
  else {
    uint64_t v24 = v18;
  }
  unint64_t StaticType = (uint64_t **)GPURegionRuntime::getStaticType(*((void *)this + 2), (uint64_t)Input);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(StaticType))
  {
    char v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    char v30 = "cast";
LABEL_71:
    __assert_rtn(v30, v29, v28, v27);
  }
  if (StaticType)
  {
    uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(StaticType);
    if (!InterfaceFor)
    {
      char v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v28 = 98;
      uint64_t v29 = "InterfaceSupport.h";
      char v30 = "Interface";
      goto LABEL_71;
    }
  }
  else
  {
    uint64_t InterfaceFor = 0;
  }
  v80[0] = (uint64_t)StaticType;
  v80[1] = InterfaceFor;
  v82[0] = v83;
  v82[1] = (void *)0x400000000;
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v80) & 1) == 0) {
    __assert_rtn("getRank", "BuiltinTypeInterfaces.h.inc", 156, "(*this).hasRank() && \"cannot query rank of unranked shaped type\"");
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v80);
  if (mlir::getPositiveAxes(v23, v24 - v23, v31, (uint64_t)v82, 0, 0, 0))
  {
    size_t v32 = (uint64_t *)v82[0];
    uint64_t v33 = LODWORD(v82[1]);
    uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v80);
    if (v33)
    {
      uint64_t v35 = 0;
      uint64_t v36 = 0;
      uint64_t v37 = 0;
      uint64_t v38 = &v32[v33];
      int64x2_t v39 = vdupq_n_s64(1uLL);
      while (1)
      {
        while (1)
        {
          if (*v32 > v36) {
            uint64_t v36 = *v32;
          }
          if (v37 == v36) {
            break;
          }
          ++v37;
          if (++v32 == v38) {
            goto LABEL_46;
          }
        }
        uint64_t v40 = ArgAttrsAttr + 8 * v35;
        uint64_t v41 = ArgAttrsAttr + 8 * v37;
        if (v40 != v41 + 8) {
          break;
        }
LABEL_45:
        uint64_t v36 = ++v37;
        uint64_t v35 = v37;
        if (++v32 == v38) {
          goto LABEL_46;
        }
      }
      unint64_t v42 = (v37 - v35) & 0x1FFFFFFFFFFFFFFFLL;
      if (v42 >= 3)
      {
        unint64_t v44 = v42 + 1;
        v40 += 8 * (v44 & 0x3FFFFFFFFFFFFFFCLL);
        id v45 = (int64x2_t *)(ArgAttrsAttr + 16 + 8 * v35);
        int64x2_t v46 = 0uLL;
        uint64_t v47 = v44 & 0x3FFFFFFFFFFFFFFCLL;
        int64x2_t v48 = 0uLL;
        do
        {
          int64x2_t v46 = vsubq_s64(v46, (int64x2_t)vmvnq_s8((int8x16_t)vceqq_s64(v45[-1], v39)));
          int64x2_t v48 = vsubq_s64(v48, (int64x2_t)vmvnq_s8((int8x16_t)vceqq_s64(*v45, v39)));
          v45 += 2;
          v47 -= 4;
        }
        while (v47);
        unint64_t v43 = vaddvq_s64(vaddq_s64(v48, v46));
        if (v44 == (v44 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_44;
        }
      }
      else
      {
        unint64_t v43 = 0;
      }
      uint64_t v49 = v40 - 8;
      do
      {
        uint64_t v50 = *(void *)(v49 + 8);
        v49 += 8;
        if (v50 != 1) {
          ++v43;
        }
      }
      while (v49 != v41);
LABEL_44:
      if (v43 > 1) {
        goto LABEL_48;
      }
      goto LABEL_45;
    }
LABEL_46:
    uint64_t v51 = (void *)*((void *)this + 2);
    uint64_t v52 = (uint64_t **)GPURegionRuntime::getStaticType((uint64_t)v51, (uint64_t)Result);
    char v53 = getMPSShapeFromMLIR(v52);
    GPU::encodeReshape((uint64_t *)Result, v51, a2, v16, v76, v53, v75);

    std::string v54 = v14;
    if (v82[0] != v83) {
      free(v82[0]);
    }
  }
  else
  {
LABEL_48:
    if (v82[0] != v83) {
      free(v82[0]);
    }
    id v55 = [v76 descriptor];
    id v56 = v55;
    std::string v54 = v14;
    if (*((void *)this + 15) == *((void *)this + 16))
    {
      [v55 numberOfDimensions];
      memset(v83, 0, sizeof(v83));
      *(_OWORD *)float v82 = 0u;
      uint64_t v57 = (char *)v19 - (char *)__p;
      if (v19 != __p)
      {
        unint64_t v58 = v57 >> 3;
        uint64_t v59 = (char *)((v57 >> 3) - 1);
        uint64_t v60 = __p;
        do
        {
          uint64_t v62 = *v60++;
          uint64_t v61 = v62;
          if (v62 >= 0) {
            unint64_t v63 = v58;
          }
          else {
            unint64_t v63 = 0;
          }
          uint64_t v64 = v63 + ~v61;
          if ((v64 < 0 || v64 >= v58) && MTLReportFailureTypeEnabled()) {
            MTLReportFailure();
          }
          v82[v64] = v59--;
        }
        while (v59 != (char *)-1);
      }
      [v56 permuteWithDimensionOrder:v82];
      std::string v54 = v74;
    }
    else
    {
      [v55 permuteWithDimensionOrder:(char *)this + 144];
    }
    int64_t v65 = a2[1];
    __int16 v66 = GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
    id v67 = [v76 safeArrayViewWithCommandBuffer:v65 computeEncoder:v66 descriptor:v56 aliasing:0];

    int64_t v68 = (void *)*((void *)this + 2);
    unint64_t v69 = GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
    GPURegionRuntime::copyNDArrayToTarget(v68, v69, a2[1], v78, v67, v75, (uint64_t *)Result, 0);
  }
  if (__p) {
    operator delete(__p);
  }
}

void sub_180D8BD84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, void *a12, void *a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25)
{
  _Unwind_Resume(a1);
}

id *GPU::TransposeOpHandler::TransposeOpHandler(id *this, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  v69[3] = *MEMORY[0x1E4F143B8];
  BOOL v5 = GPU::BaseOpHandler::BaseOpHandler((GPU::BaseOpHandler *)this, a2, a3, a4);
  *(void *)BOOL v5 = &unk_1EC99E918;
  *((unsigned char *)v5 + 120) = 0;
  *((unsigned char *)v5 + 128) = 0;
  *((unsigned char *)v5 + 136) = 0;
  *((unsigned char *)v5 + 144) = 0;
  id v6 = objc_alloc(MEMORY[0x1E4F35770]);
  id v7 = [*((id *)this[2] + 6) metalDevice];
  uint64_t v8 = [v6 initWithDevice:v7];
  id v9 = this[1];
  this[1] = (id)v8;

  objc_msgSend(this[1], "setOptions:", objc_msgSend(this[1], "options") | 1);
  uint64_t v10 = *((void *)this[3] + 6);
  uint64_t v11 = *(void **)(v10 + 16);
  if (v11 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    id v67 = *(void **)(v10 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v67);
    if (v38 == 13 && *AttrData == 0x6E6172742E73706DLL && *(void *)((char *)AttrData + 5) == 0x65736F70736E6172)
    {
      __int16 v66 = 1283;
      v65[0] = (uint64_t)"classof on '";
      v65[2] = (uint64_t)"mps.transpose";
      v65[3] = 13;
      unint64_t v63 = "' failed due to the operation not being registered";
      __int16 v64 = 259;
      llvm::operator+(v65, (uint64_t *)&v63, (uint64_t)&v67);
      llvm::report_fatal_error((llvm::Twine *)&v67, 1);
    }
LABEL_89:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v11 != &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id) {
    goto LABEL_89;
  }
  id v62 = this[3];
  v65[0] = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v62);
  if (!v65[0]) {
    __assert_rtn("matchPattern", "Matchers.h", 402, "value");
  }
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v65);
  if (DefiningOp)
  {
    {
      goto LABEL_6;
    }
    id v67 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ConstantLike<Empty>]";
    unint64_t v68 = 84;
    unint64_t v40 = llvm::StringRef::find((uint64_t *)&v67, "DesiredTypeName = ", 0x12uLL, 0);
    unint64_t v42 = (char *)v67;
    unint64_t v41 = v68;
    if (v68 >= v40) {
      unint64_t v43 = v40;
    }
    else {
      unint64_t v43 = v68;
    }
    unint64_t v44 = v68 - v43;
    id v45 = (char *)v67 + v43;
    id v67 = (char *)v67 + v43;
    v68 -= v43;
    if (v41 <= v40)
    {
      std::string v54 = "!Name.empty() && \"Unable to find the template parameter!\"";
      int v55 = 33;
    }
    else
    {
      if (v44 < 0x12)
      {
        std::string v54 = "size() >= N && \"Dropping more elements than exist\"";
        int v55 = 614;
        id v56 = "StringRef.h";
        uint64_t v57 = "drop_front";
        goto LABEL_94;
      }
      id v67 = v45 + 18;
      unint64_t v68 = v44 - 18;
      if (v44 != 18 && v42[v41 - 1] == 93)
      {
        if (v44 - 18 >= v44 - 19) {
          uint64_t v46 = v44 - 19;
        }
        else {
          uint64_t v46 = v44 - 18;
        }
        mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)(v45 + 18), v46);
LABEL_6:
        if (((*(uint64_t (**)(void, uint64_t))(**(void **)(DefiningOp + 48) + 32))(*(void *)(DefiningOp + 48), mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id) & 1) == 0)goto LABEL_21; {
        id v67 = v69;
        }
        unint64_t v68 = 0x100000000;
        if (!mlir::Operation::fold(DefiningOp, 0, 0, (uint64_t)&v67)) {
          __assert_rtn("match", "Matchers.h", 92, "succeeded(result) && \"expected ConstantLike op to be foldable\"");
        }
        if (v68)
        {
          uint64_t v13 = *(void *)v67;
          if ((*(void *)v67 & 4) != 0)
          {
            uint64_t v29 = "isa<T>(*this) && \"Invalid accessor called\"";
            int v30 = 156;
            uint64_t v31 = "PointerUnion.h";
            size_t v32 = "get";
          }
          else
          {
            id v14 = (uint64_t **)(v13 & 0xFFFFFFFFFFFFFFF8);
            if ((v13 & 0xFFFFFFFFFFFFFFF8) != 0)
            {
              if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor((uint64_t **)(v13 & 0xFFFFFFFFFFFFFFF8)))
              {
                id v14 = 0;
                uint64_t v16 = 0;
                uint64_t v17 = v67;
                if (v67 == v69) {
                  goto LABEL_18;
                }
                goto LABEL_17;
              }
              uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v14);
              if (InterfaceFor)
              {
                if (v14) {
                  uint64_t v16 = InterfaceFor;
                }
                else {
                  uint64_t v16 = 0;
                }
                uint64_t v17 = v67;
                if (v67 == v69)
                {
LABEL_18:
                  if (v14)
                  {
                    unint64_t SingleInt = mlir::getSingleIntValue<long long>((uint64_t)v14, v16);
                    if (v19)
                    {
                      this[15] = (id)SingleInt;
                      *((unsigned char *)this + 128) = 1;
                    }
                  }
                  goto LABEL_21;
                }
LABEL_17:
                free(v17);
                goto LABEL_18;
              }
              uint64_t v29 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
              int v30 = 98;
              uint64_t v31 = "InterfaceSupport.h";
              size_t v32 = "Interface";
            }
            else
            {
              uint64_t v29 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
              int v30 = 650;
              uint64_t v31 = "Casting.h";
              size_t v32 = "dyn_cast";
            }
          }
        }
        else
        {
          uint64_t v29 = "!empty()";
          int v30 = 303;
          uint64_t v31 = "SmallVector.h";
          size_t v32 = "front";
        }
        __assert_rtn(v32, v31, v30, v29);
      }
      std::string v54 = "Name.ends_with(\"]\") && \"Name doesn't end in the substitution key!\"";
      int v55 = 36;
    }
    id v56 = "TypeName.h";
    uint64_t v57 = "getTypeName";
LABEL_94:
    __assert_rtn(v57, v56, v55, v54);
  }
LABEL_21:
  v65[0] = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v62);
  if (!v65[0]) {
    __assert_rtn("matchPattern", "Matchers.h", 402, "value");
  }
  uint64_t v20 = mlir::Value::getDefiningOp((mlir::Value *)v65);
  if (v20)
  {
    {
      goto LABEL_24;
    }
    id v67 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ConstantLike<Empty>]";
    unint64_t v68 = 84;
    unint64_t v47 = llvm::StringRef::find((uint64_t *)&v67, "DesiredTypeName = ", 0x12uLL, 0);
    uint64_t v49 = (char *)v67;
    unint64_t v48 = v68;
    if (v68 >= v47) {
      unint64_t v50 = v47;
    }
    else {
      unint64_t v50 = v68;
    }
    unint64_t v51 = v68 - v50;
    uint64_t v52 = (char *)v67 + v50;
    id v67 = (char *)v67 + v50;
    v68 -= v50;
    if (v48 <= v47)
    {
      unint64_t v58 = "!Name.empty() && \"Unable to find the template parameter!\"";
      int v59 = 33;
    }
    else
    {
      if (v51 < 0x12)
      {
        unint64_t v58 = "size() >= N && \"Dropping more elements than exist\"";
        int v59 = 614;
        uint64_t v60 = "StringRef.h";
        uint64_t v61 = "drop_front";
        goto LABEL_99;
      }
      id v67 = v52 + 18;
      unint64_t v68 = v51 - 18;
      if (v51 != 18 && v49[v48 - 1] == 93)
      {
        if (v51 - 18 >= v51 - 19) {
          uint64_t v53 = v51 - 19;
        }
        else {
          uint64_t v53 = v51 - 18;
        }
        mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)(v52 + 18), v53);
LABEL_24:
        if (((*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id) & 1) == 0)return this; {
        id v67 = v69;
        }
        unint64_t v68 = 0x100000000;
        if (!mlir::Operation::fold(v20, 0, 0, (uint64_t)&v67)) {
          __assert_rtn("match", "Matchers.h", 92, "succeeded(result) && \"expected ConstantLike op to be foldable\"");
        }
        if (v68)
        {
          uint64_t v21 = *(void *)v67;
          if ((*(void *)v67 & 4) != 0)
          {
            uint64_t v33 = "isa<T>(*this) && \"Invalid accessor called\"";
            int v34 = 156;
            uint64_t v35 = "PointerUnion.h";
            uint64_t v36 = "get";
          }
          else
          {
            uint64_t v22 = (uint64_t **)(v21 & 0xFFFFFFFFFFFFFFF8);
            if ((v21 & 0xFFFFFFFFFFFFFFF8) != 0)
            {
              if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor((uint64_t **)(v21 & 0xFFFFFFFFFFFFFFF8)))
              {
                uint64_t v22 = 0;
                uint64_t v24 = 0;
                unint64_t v25 = v67;
                if (v67 == v69) {
                  goto LABEL_36;
                }
                goto LABEL_35;
              }
              uint64_t v23 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v22);
              if (v23)
              {
                if (v22) {
                  uint64_t v24 = v23;
                }
                else {
                  uint64_t v24 = 0;
                }
                unint64_t v25 = v67;
                if (v67 == v69) {
                  goto LABEL_36;
                }
LABEL_35:
                free(v25);
LABEL_36:
                if (v22)
                {
                  unint64_t v26 = mlir::getSingleIntValue<long long>((uint64_t)v22, v24);
                  if (v27)
                  {
                    this[17] = (id)v26;
                    *((unsigned char *)this + 144) = 1;
                  }
                }
                return this;
              }
              uint64_t v33 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
              int v34 = 98;
              uint64_t v35 = "InterfaceSupport.h";
              uint64_t v36 = "Interface";
            }
            else
            {
              uint64_t v33 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
              int v34 = 650;
              uint64_t v35 = "Casting.h";
              uint64_t v36 = "dyn_cast";
            }
          }
        }
        else
        {
          uint64_t v33 = "!empty()";
          int v34 = 303;
          uint64_t v35 = "SmallVector.h";
          uint64_t v36 = "front";
        }
        __assert_rtn(v36, v35, v34, v33);
      }
      unint64_t v58 = "Name.ends_with(\"]\") && \"Name doesn't end in the substitution key!\"";
      int v59 = 36;
    }
    uint64_t v60 = "TypeName.h";
    uint64_t v61 = "getTypeName";
LABEL_99:
    __assert_rtn(v61, v60, v59, v58);
  }
  return this;
}

void sub_180D8C600(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void sub_180D8C624(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;

  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void sub_180D8C640(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21)
{
  GPU::BaseOpHandler::~BaseOpHandler(v21);
  _Unwind_Resume(a1);
}

unint64_t GPU::TransposeOpHandler::getJITStaticOperandRepr(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  if (a4) {
    return GPU::BaseOpHandler::_getJITStaticOperandReprConstant(this, a2, a3, a4);
  }
  else {
    return GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(this, a2, a3, 0);
  }
}

void GPU::TransposeOpHandler::encodeOp(GPU::TransposeOpHandler *this, void **a2)
{
  v90[4] = *MEMORY[0x1E4F143B8];
  GPU::BaseOpHandler::_inferJITOutputTypes((uint64_t)this, (GPU::EncodeDescriptor *)a2);
  uint64_t v4 = *(void *)(*((void *)this + 3) + 48);
  BOOL v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    unint64_t v88 = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v88);
    if (v78 == 13 && *AttrData == 0x6E6172742E73706DLL && *(void *)((char *)AttrData + 5) == 0x65736F70736E6172)
    {
      __int16 v87 = 1283;
      v86[0] = (uint64_t)"classof on '";
      v86[2] = (uint64_t)"mps.transpose";
      v86[3] = 13;
      v84[0] = "' failed due to the operation not being registered";
      __int16 v85 = 259;
      llvm::operator+(v86, (uint64_t *)v84, (uint64_t)&v88);
      llvm::report_fatal_error((llvm::Twine *)&v88, 1);
    }
LABEL_84:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id) {
    goto LABEL_84;
  }
  uint64_t v83 = *((void *)this + 3);
  uint64_t Result = (void *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v83);
  uint64_t Input = (void *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v83);
  uint64_t v8 = *((void *)this + 2);
  unint64_t v88 = Result;
  v86[0] = *((void *)mlir::Value::getParentRegion((mlir::Value *)&v88) + 2);
  id v9 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v8 + 88), v86);
  if (v9
    && (v84[0] = v88,
        (uint64_t v10 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v9 + 3, (uint64_t *)v84)) != 0))
  {
    id v81 = (id)v10[3];
  }
  else
  {
    id v81 = 0;
  }
  uint64_t v11 = *((void *)this + 2);
  unint64_t v88 = Input;
  v86[0] = *((void *)mlir::Value::getParentRegion((mlir::Value *)&v88) + 2);
  uint64_t v12 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v11 + 88), v86);
  if (v12)
  {
    v84[0] = v88;
    uint64_t v12 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v12 + 3, (uint64_t *)v84);
    if (v12) {
      uint64_t v12 = (id)v12[3];
    }
  }
  uint64_t v13 = objc_msgSend(v12, "mpsndarray", v12);
  id v14 = *((id *)this + 1);
  v84[0] = v14;
  float v82 = (void *)v13;
  if (!v13 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  unint64_t StaticType = (uint64_t **)GPURegionRuntime::getStaticType(*((void *)this + 2), (uint64_t)Input);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(StaticType))
  {
    uint64_t v17 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v18 = 566;
    char v19 = "Casting.h";
    uint64_t v20 = "cast";
LABEL_73:
    __assert_rtn(v20, v19, v18, v17);
  }
  if (StaticType)
  {
    uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(StaticType);
    if (!InterfaceFor)
    {
      uint64_t v17 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v18 = 98;
      char v19 = "InterfaceSupport.h";
      uint64_t v20 = "Interface";
      goto LABEL_73;
    }
  }
  else
  {
    uint64_t InterfaceFor = 0;
  }
  v86[0] = (uint64_t)StaticType;
  v86[1] = InterfaceFor;
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86) & 1) == 0) {
    __assert_rtn("getRank", "BuiltinTypeInterfaces.h.inc", 156, "(*this).hasRank() && \"cannot query rank of unranked shaped type\"");
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v86);
  uint64_t v22 = v21;
  if (*((unsigned char *)this + 128))
  {
    Positiveuint64_t Axis = mlir::getPositiveAxis(*((void *)this + 15), v21);
  }
  else
  {
    uint64_t v24 = *((void *)this + 2);
    uint64_t Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v83);
    Positiveuint64_t Axis = RuntimeUtils::getAxis(v24, (uint64_t)a2, Filter, v22);
  }
  uint64_t v26 = PositiveAxis;
  if (*((unsigned char *)this + 144))
  {
    uint64_t Axis = mlir::getPositiveAxis(*((void *)this + 17), v22);
  }
  else
  {
    uint64_t v28 = *((void *)this + 2);
    uint64_t Bias = (void *)mlir::anec::GOC::getBias((mlir::anec::GOC *)&v83);
    uint64_t Axis = RuntimeUtils::getAxis(v28, (uint64_t)a2, Bias, v22);
  }
  uint64_t v30 = Axis;
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86) & 1) == 0) {
    __assert_rtn("getRank", "BuiltinTypeInterfaces.h.inc", 156, "(*this).hasRank() && \"cannot query rank of unranked shaped type\"");
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v86);
  unint64_t v32 = v31;
  unint64_t v88 = v90;
  uint64_t v89 = 0x400000000;
  if (!v31)
  {
    unint64_t v35 = 0;
    uint64_t v36 = (char *)v90;
    uint64_t v37 = v90;
    goto LABEL_38;
  }
  if (v31 < 5)
  {
    uint64_t v33 = 0;
    unint64_t v34 = v31;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v90, v31, 8);
    uint64_t v33 = v89;
    unint64_t v34 = v32 - v89;
    if (v32 == v89) {
      goto LABEL_31;
    }
  }
  bzero((char *)v88 + 8 * v33, 8 * v34);
LABEL_31:
  if (v32 > HIDWORD(v89)) {
    __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
  }
  LODWORD(v89) = v32;
  uint64_t v37 = (uint64_t *)v88;
  unint64_t v35 = v32;
  uint64_t v36 = (char *)v88 + 8 * v32;
  unint64_t v38 = (v35 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (v38 >= 3)
  {
    unint64_t v41 = v38 + 1;
    uint64_t v39 = (v38 + 1) & 0x3FFFFFFFFFFFFFFCLL;
    unint64_t v40 = (char *)v88 + 8 * v39;
    int64x2_t v42 = (int64x2_t)xmmword_1810FE2E0;
    unint64_t v43 = (int64x2_t *)((char *)v88 + 16);
    int64x2_t v44 = vdupq_n_s64(2uLL);
    int64x2_t v45 = vdupq_n_s64(4uLL);
    uint64_t v46 = v39;
    do
    {
      v43[-1] = v42;
      *unint64_t v43 = vaddq_s64(v42, v44);
      int64x2_t v42 = vaddq_s64(v42, v45);
      v43 += 2;
      v46 -= 4;
    }
    while (v46);
    if (v41 == v39) {
      goto LABEL_38;
    }
  }
  else
  {
    uint64_t v39 = 0;
    unint64_t v40 = (char *)v88;
  }
  do
  {
    *(void *)unint64_t v40 = v39;
    v40 += 8;
    ++v39;
  }
  while (v40 != v36);
LABEL_38:
  if (v26 >= v35 || v30 >= v35) {
    __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
  }
  uint64_t v47 = v37[v26];
  v37[v26] = v37[v30];
  v37[v30] = v47;
  uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v86);
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  uint64_t v51 = 0;
  int64x2_t v52 = vdupq_n_s64(1uLL);
  while (1)
  {
    while (1)
    {
      if (*v37 > v50) {
        uint64_t v50 = *v37;
      }
      if (v51 == v50) {
        break;
      }
      ++v51;
      if (++v37 == (uint64_t *)v36) {
        goto LABEL_57;
      }
    }
    uint64_t v53 = ArgAttrsAttr + 8 * v49;
    uint64_t v54 = ArgAttrsAttr + 8 * v51;
    if (v53 != v54 + 8) {
      break;
    }
LABEL_56:
    uint64_t v50 = ++v51;
    uint64_t v49 = v51;
    if (++v37 == (uint64_t *)v36)
    {
LABEL_57:
      __int16 v64 = (void *)*((void *)this + 2);
      int64_t v65 = (uint64_t **)GPURegionRuntime::getStaticType((uint64_t)v64, (uint64_t)Result);
      __int16 v66 = getMPSShapeFromMLIR(v65);
      GPU::encodeReshape((uint64_t *)Result, v64, a2, v14, v82, v66, v81);

      if (v88 != v90) {
        free(v88);
      }
      goto LABEL_68;
    }
  }
  unint64_t v55 = (v51 - v49) & 0x1FFFFFFFFFFFFFFFLL;
  if (v55 >= 3)
  {
    unint64_t v57 = v55 + 1;
    v53 += 8 * (v57 & 0x3FFFFFFFFFFFFFFCLL);
    unint64_t v58 = (int64x2_t *)(ArgAttrsAttr + 16 + 8 * v49);
    int64x2_t v59 = 0uLL;
    uint64_t v60 = v57 & 0x3FFFFFFFFFFFFFFCLL;
    int64x2_t v61 = 0uLL;
    do
    {
      int64x2_t v59 = vsubq_s64(v59, (int64x2_t)vmvnq_s8((int8x16_t)vceqq_s64(v58[-1], v52)));
      int64x2_t v61 = vsubq_s64(v61, (int64x2_t)vmvnq_s8((int8x16_t)vceqq_s64(*v58, v52)));
      v58 += 2;
      v60 -= 4;
    }
    while (v60);
    unint64_t v56 = vaddvq_s64(vaddq_s64(v61, v59));
    if (v57 == (v57 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_55;
    }
  }
  else
  {
    unint64_t v56 = 0;
  }
  uint64_t v62 = v53 - 8;
  do
  {
    uint64_t v63 = *(void *)(v62 + 8);
    v62 += 8;
    if (v63 != 1) {
      ++v56;
    }
  }
  while (v62 != v54);
LABEL_55:
  if (v56 <= 1) {
    goto LABEL_56;
  }
  if (v88 != v90) {
    free(v88);
  }
  id v67 = [v82 descriptor];
  unint64_t v68 = v67;
  if (v30 >= 0) {
    uint64_t v69 = v22;
  }
  else {
    uint64_t v69 = 0;
  }
  uint64_t v70 = v69 + ~v30;
  if (v26 >= 0) {
    uint64_t v71 = v22;
  }
  else {
    uint64_t v71 = 0;
  }
  [v67 transposeDimension:v71 + ~v26 withDimension:v70];
  id v72 = a2[1];
  unint64_t v73 = GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
  id v74 = [v82 safeArrayViewWithCommandBuffer:v72 computeEncoder:v73 descriptor:v68 aliasing:0];

  id v75 = (void *)*((void *)this + 2);
  unint64_t v76 = GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
  GPURegionRuntime::copyNDArrayToTarget(v75, v76, a2[1], v84, v74, v81, (uint64_t *)Result, 0);

  id v14 = v84[0];
LABEL_68:
}

void sub_180D8CE48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23)
{
  _Unwind_Resume(a1);
}

void GPU::PermuteOpHandler::~PermuteOpHandler(GPU::PermuteOpHandler *this)
{
  *(void *)this = &unk_1EC99DE58;
  id v2 = (void *)*((void *)this + 15);
  if (v2)
  {
    *((void *)this + 16) = v2;
    operator delete(v2);
  }

  GPU::BaseOpHandler::~BaseOpHandler(this);
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EC99DE58;
  id v2 = (void *)*((void *)this + 15);
  if (v2)
  {
    *((void *)this + 16) = v2;
    operator delete(v2);
  }
  GPU::BaseOpHandler::~BaseOpHandler(this);

  JUMPOUT(0x1852FDE70);
}

void GPU::TransposeOpHandler::~TransposeOpHandler(GPU::TransposeOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);

  JUMPOUT(0x1852FDE70);
}

id *GPU::ReinterpretCastOpHandler::ReinterpretCastOpHandler(id *this, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  *(void *)GPU::BaseOpHandler::BaseOpHandler((GPU::BaseOpHandler *)this, a2, a3, a4) = &unk_1EC9A0BD8;
  id v5 = objc_alloc(MEMORY[0x1E4F35770]);
  id v6 = [*((id *)this[2] + 6) metalDevice];
  uint64_t v7 = [v5 initWithDevice:v6];
  id v8 = this[1];
  this[1] = (id)v7;

  objc_msgSend(this[1], "setOptions:", objc_msgSend(this[1], "options") | 1);
  return this;
}

void sub_180D8D0CC(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void sub_180D8D0E4(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void GPU::ReinterpretCastOpHandler::encodeOp(id *this, void **a2)
{
  v71[1] = *MEMORY[0x1E4F143B8];
  GPU::BaseOpHandler::_inferJITOutputTypes((uint64_t)this, (GPU::EncodeDescriptor *)a2);
  id v54 = this[1];
  id v65 = v54;
  unint64_t v57 = this;
  uint64_t v4 = *((void *)this[3] + 6);
  id v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v70 = *(uint64_t **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v70);
    if (v50 == 20)
    {
      BOOL v51 = *(void *)AttrData == 0x6E6965722E73706DLL && *(void *)(AttrData + 8) == 0x5F74657270726574;
      if (v51 && *(_DWORD *)(AttrData + 16) == 1953718627)
      {
        __int16 v69 = 1283;
        v68[0] = (uint64_t)"classof on '";
        v68[2] = (uint64_t)"mps.reinterpret_cast";
        v68[3] = 20;
        v66[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v67 = 259;
        llvm::operator+(v68, v66, (uint64_t)&v70);
        llvm::report_fatal_error((llvm::Twine *)&v70, 1);
      }
    }
LABEL_60:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReinterpretCastOp,void>::id) {
    goto LABEL_60;
  }
  id v64 = this[3];
  uint64_t Result = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v64);
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v64);
  int MPSDataType = getMPSDataType((void *)(Result[1] & 0xFFFFFFFFFFFFFFF8));
  uint64_t v7 = v57[2];
  uint64_t v70 = Result;
  v68[0] = *((void *)mlir::Value::getParentRegion((mlir::Value *)&v70) + 2);
  id v8 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v7 + 11, v68);
  if (v8
    && (v66[0] = (uint64_t)v70,
        (id v9 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v8 + 3, v66)) != 0))
  {
    id v60 = (id)v9[3];
  }
  else
  {
    id v60 = 0;
  }
  uint64_t v10 = v57[2];
  uint64_t v70 = (uint64_t *)Input;
  v68[0] = *((void *)mlir::Value::getParentRegion((mlir::Value *)&v70) + 2);
  uint64_t v11 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v10 + 11, v68);
  if (v11)
  {
    v66[0] = (uint64_t)v70;
    uint64_t v11 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v11 + 3, v66);
    if (v11) {
      uint64_t v11 = (id)v11[3];
    }
  }
  id v59 = v11;
  [v11 dataType];
  if ([v59 dataType] == -2147483640 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  [v60 dataType];
  if ([v60 dataType] == -2147483640 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  int64x2_t v61 = [v59 mpsndarray];
  if (!v61 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  uint64_t v12 = [v59 mpsndarray];
  unint64_t v58 = [v12 descriptor];

  uint64_t v13 = a2[1];
  id v14 = GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
  uint64_t v15 = [v61 safeArrayViewWithCommandBuffer:v13 computeEncoder:v14 descriptor:v58 aliasing:1];

  if (!v15)
  {
    uint64_t v17 = (*(void (**)(id, uint64_t *, void *, void, void, uint64_t))(*(void *)v57[2] + 80))(v57[2], Result, a2[1], 0, 0, 1);

    id v60 = v17;
  }
  unsigned int v18 = (unsigned __int16)*(_DWORD *)&v58[*MEMORY[0x1E4F359E8]] >> 3;
  unsigned int v19 = (unsigned __int16)MPSDataType >> 3;
  uint64_t v20 = (int *)MEMORY[0x1E4F359B0];
  if (!v15) {
    goto LABEL_33;
  }
  if (v18 >= v19)
  {
    if (*(_OWORD *)&v58[*MEMORY[0x1E4F359F8]]) {
      BOOL v23 = v18 == v19;
    }
    else {
      BOOL v23 = 1;
    }
    int v22 = !v23;
  }
  else
  {
    if (*(_OWORD *)&v58[*MEMORY[0x1E4F359F8]]) {
      BOOL v21 = v18 == v19;
    }
    else {
      BOOL v21 = 1;
    }
    int v22 = !v21;
    if (*(_DWORD *)&v61[4 * (*(_OWORD *)&v58[*MEMORY[0x1E4F359F8]] & 0xF) + (int)*MEMORY[0x1E4F359E0]] % v19) {
      goto LABEL_33;
    }
  }
  if (!v22)
  {
    uint64_t v24 = (int *)MEMORY[0x1E4F359A0];
    unint64_t v25 = v15;
    goto LABEL_37;
  }
LABEL_33:
  v53[1] = v53;
  MEMORY[0x1F4188790](v16);
  uint64_t v29 = (char *)v53 - v28;
  if (v26)
  {
    uint64_t v30 = 0;
    unint64_t v31 = &v61[*MEMORY[0x1E4F359D8]];
    long long v33 = *((_OWORD *)v31 + 2);
    long long v32 = *((_OWORD *)v31 + 3);
    long long v35 = *(_OWORD *)v31;
    long long v34 = *((_OWORD *)v31 + 1);
    long long v36 = *(_OWORD *)&v61[*v20];
    do
    {
      long long v62 = v36;
      v63[0] = v35;
      v63[1] = v34;
      v63[2] = v33;
      v63[3] = v32;
      *(void *)&v29[8 * v30] = *((unsigned int *)v63 + (*(unsigned char *)((unint64_t)&v62 | v30 & 0xF) & 0xF));
      ++v30;
    }
    while (v26 != v30);
  }
  uint64_t v24 = v27;
  uint64_t v37 = objc_msgSend(MEMORY[0x1E4F35720], "descriptorWithDataType:dimensionCount:dimensionSizes:", *(unsigned int *)&v61[*v27]);
  unint64_t v25 = [MEMORY[0x1E4F35988] temporaryNDArrayWithCommandBuffer:a2[1] descriptor:v37];

  unint64_t v38 = GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
  uint64_t v39 = a2[1];
  v71[0] = v61;
  unint64_t v40 = [MEMORY[0x1E4F1C978] arrayWithObjects:v71 count:1];
  [v54 encodeToMPSCommandEncoder:v38 commandBuffer:v39 sourceArrays:v40 destinationArray:v25];

  if (!v25) {
    __assert_rtn("encodeOp", "GPUReinterpretCastOps.mm", 93, "reinterpretedNDArray");
  }
LABEL_37:
  *(_DWORD *)&v25[*v24] = MPSDataType;
  char v41 = *(_OWORD *)&v25[*v20];
  if (v18 > v19)
  {
    uint64_t v42 = 4 * (v41 & 0xF);
    uint64_t v43 = 4 * *(_OWORD *)&v25[*v20];
    *(_DWORD *)&v25[(int)*MEMORY[0x1E4F359A8] + v43] = *(_DWORD *)&v25[(int)*MEMORY[0x1E4F359A8] + v42] * (v18 / v19);
    *(_DWORD *)&v25[(int)*MEMORY[0x1E4F359D8] + v43] = *(_DWORD *)&v25[(int)*MEMORY[0x1E4F359D8] + v42] * (v18 / v19);
    int64x2_t v44 = &v25[*MEMORY[0x1E4F359E0]];
    unsigned int v45 = *(_DWORD *)&v44[v42] * (v18 / v19);
LABEL_41:
    *(_DWORD *)&v44[v43] = v45;
    goto LABEL_42;
  }
  if (v18 < v19)
  {
    uint64_t v46 = 4 * (v41 & 0xF);
    uint64_t v43 = 4 * *(_OWORD *)&v25[*v20];
    *(_DWORD *)&v25[(int)*MEMORY[0x1E4F359A8] + v43] = *(_DWORD *)&v25[(int)*MEMORY[0x1E4F359A8] + v46] / (v19 / v18);
    *(_DWORD *)&v25[(int)*MEMORY[0x1E4F359D8] + v43] = *(_DWORD *)&v25[(int)*MEMORY[0x1E4F359D8] + v46] / (v19 / v18);
    int64x2_t v44 = &v25[*MEMORY[0x1E4F359E0]];
    unsigned int v45 = *(_DWORD *)&v44[v46] / (v19 / v18);
    goto LABEL_41;
  }
LABEL_42:
  [v25 updateStrides];
  uint64_t v47 = v57[2];
  unint64_t v48 = GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
  GPURegionRuntime::copyNDArrayToTarget(v47, v48, a2[1], &v65, v25, v60, Result, 0);
}

void sub_180D8D928(_Unwind_Exception *a1)
{
  *(void *)(v1 - 384) = *(void *)(v1 - 232);
  _Unwind_Resume(a1);
}

void GPU::ReinterpretCastOpHandler::~ReinterpretCastOpHandler(GPU::ReinterpretCastOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);

  JUMPOUT(0x1852FDE70);
}

void lowerMILProgram()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  uint64_t v2 = 0;
  fillMILToMLIRRewritePatterns();
}

void sub_180D8DB68(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  MILToMLIRRewriter::~MILToMLIRRewriter((MILToMLIRRewriter *)va);
  std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::~vector[abi:ne180100]((void *)(v2 - 72));
  _Unwind_Resume(a1);
}

void sub_180D8DB84(_Unwind_Exception *a1)
{
  std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::~vector[abi:ne180100]((void *)(v1 - 72));
  _Unwind_Resume(a1);
}

void sub_180D8DB98(_Unwind_Exception *a1)
{
  std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::~vector[abi:ne180100]((void *)(v1 - 72));
  _Unwind_Resume(a1);
}

void fillMILToMLIRRewritePatterns()
{
}

void sub_180D95C24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(void))(*(void *)a10 + 8))();
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::~vector[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)*a1;
  if (*a1)
  {
    uint64_t v3 = (void *)a1[1];
    uint64_t v4 = (void *)*a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        void *v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void validateMILProgram(const __CFDictionary *a1)
{
  mlir::MLIRContext::MLIRContext(&v4, 0);
  uint64_t v1 = 0;
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  fillMILToMLIRRewritePatterns();
}

void sub_180D9621C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  MILToMLIRRewriter::~MILToMLIRRewriter((MILToMLIRRewriter *)&a9);
  if (*(char *)(v9 - 113) < 0)
  {
    operator delete(*(void **)(v9 - 136));
    std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::~vector[abi:ne180100]((void *)(v9 - 96));
    mlir::MLIRContext::~MLIRContext((mlir::MLIRContextImpl **)(v9 - 72));
    _Unwind_Resume(a1);
  }
  std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::~vector[abi:ne180100]((void *)(v9 - 96));
  mlir::MLIRContext::~MLIRContext((mlir::MLIRContextImpl **)(v9 - 72));
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<MILToMLIR::PoolingPattern,char const(&)[9]>()
{
}

void sub_180D96444(_Unwind_Exception *a1)
{
  operator delete(v2);
  MEMORY[0x1852FDE70](v1, 0x1093C402D7449D9);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<MILToMLIR::TensorBufferPattern,char const(&)[24]>()
{
}

void sub_180D96628(_Unwind_Exception *a1)
{
  operator delete(v2);
  MEMORY[0x1852FDE70](v1, 0x1093C402D7449D9);
  _Unwind_Resume(a1);
}

void anonymous namespace'::populateWithGenerated()
{
}

void sub_180DA0214(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void anonymous namespace'::BatchNormPattern::~BatchNormPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::BatchNormPattern::matchAndRewrite(_anonymous_namespace_::BatchNormPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v96 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t v6 = a3 + 18;
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v92 = ArgValue;
  uint64_t v91 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "mean");
  uint64_t v90 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "variance");
  OptionalArguint64_t Value = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "beta");
  __int16 v87 = 0;
  uint64_t v88 = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "gamma");
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
  if (!OptionalArgValue)
  {
    uint64_t v9 = mlir::Float32Type::get(*v6, v8);
    uint64_t Constant = 1;
    uint64_t v10 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&Constant, 1, v9, 0);
    uint64_t Constant = mlir::mps::getConstantAttr<float>(v10, 0.0);
    uint64_t v11 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)&Constant);
    if (!*((_DWORD *)v11 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    OptionalArguint64_t Value = (uint64_t)v11 - 16;
    if (!mlir::Type::isF32((mlir::Type *)&ElementTypeOrSelf))
    {
      uint64_t v12 = mlir::getElementTypeOrSelf(ArgValue);
      uint64_t Constant = mlir::TypeAttr::get(v12);
      uint64_t v13 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, &OptionalArgValue, &Constant);
      if (!*((_DWORD *)v13 + 9)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
      OptionalArguint64_t Value = (uint64_t)v13 - 16;
    }
  }
  if (!v88)
  {
    uint64_t v14 = mlir::Float32Type::get(*v6, v8);
    uint64_t Constant = 1;
    uint64_t v15 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&Constant, 1, v14, 0);
    uint64_t Constant = mlir::mps::getConstantAttr<float>(v15, 1.0);
    uint64_t v16 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)&Constant);
    if (!*((_DWORD *)v16 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v88 = (uint64_t)v16 - 16;
    if (!mlir::Type::isF32((mlir::Type *)&ElementTypeOrSelf))
    {
      uint64_t v17 = mlir::getElementTypeOrSelf(ArgValue);
      uint64_t Constant = mlir::TypeAttr::get(v17);
      unsigned int v18 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, &v88, &Constant);
      if (!*((_DWORD *)v18 + 9)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
      uint64_t v88 = (uint64_t)v18 - 16;
    }
  }
  int v95 = 1;
  unint64_t v94 = 0xFFFFFFFF00000001;
  long long v93 = xmmword_18110B730;
  unsigned int v19 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 160))(a2);
  v85[0] = 0;
  v85[1] = 0;
  uint64_t Constant = (uint64_t)v85;
  uint64_t v20 = v19 + 1;
  BOOL v21 = *v19;
  if (*v19 == (const void **)(v19 + 1)) {
    goto LABEL_53;
  }
  do
  {
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&Constant, (uint64_t *)v85, v21 + 4, (uint64_t)(v21 + 4));
    int v22 = (const void **)v21[1];
    if (v22)
    {
      do
      {
        BOOL v23 = (const void ***)v22;
        int v22 = (const void **)*v22;
      }
      while (v22);
    }
    else
    {
      do
      {
        BOOL v23 = (const void ***)v21[2];
        BOOL v24 = *v23 == v21;
        BOOL v21 = (const void **)v23;
      }
      while (!v24);
    }
    BOOL v21 = (const void **)v23;
  }
  while (v23 != v20);
  unint64_t v25 = v85[0];
  HIBYTE(v83) = 7;
  strcpy((char *)&__s2, "epsilon");
  if (!v85[0]) {
    goto LABEL_53;
  }
  uint64_t v26 = v85;
  do
  {
    char v27 = v25;
    uint64_t v28 = v26;
    uint64_t v30 = v25 + 32;
    uint64_t v29 = (char *)*((void *)v25 + 4);
    unint64_t v31 = v27[55];
    int v32 = (char)v31;
    if ((v31 & 0x80u) != 0) {
      unint64_t v31 = *((void *)v27 + 5);
    }
    if (v32 >= 0) {
      long long v33 = v30;
    }
    else {
      long long v33 = v29;
    }
    if (v31 >= 7) {
      size_t v34 = 7;
    }
    else {
      size_t v34 = v31;
    }
    BOOL v35 = v31 < 7;
    int v36 = memcmp(v33, &__s2, v34);
    if (v36) {
      BOOL v35 = v36 < 0;
    }
    uint64_t v37 = (char **)(v27 + 8);
    if (v35)
    {
      uint64_t v26 = v28;
    }
    else
    {
      uint64_t v37 = (char **)v27;
      uint64_t v26 = (char **)v27;
    }
    unint64_t v25 = *v37;
  }
  while (v25);
  if (v26 == v85) {
    goto LABEL_53;
  }
  unint64_t v38 = (char *)(v28 + 4);
  if (v35) {
    uint64_t v39 = v28;
  }
  else {
    uint64_t v39 = v27;
  }
  if (!v35) {
    unint64_t v38 = v30;
  }
  unint64_t v40 = *((unsigned __int8 *)v26 + 55);
  int v41 = (char)v40;
  uint64_t v43 = (char *)v39[4];
  unint64_t v42 = v39[5];
  if ((v40 & 0x80u) != 0) {
    unint64_t v40 = v42;
  }
  if (v41 >= 0) {
    int64x2_t v44 = v38;
  }
  else {
    int64x2_t v44 = v43;
  }
  if (v40 >= 7) {
    size_t v45 = 7;
  }
  else {
    size_t v45 = v40;
  }
  BOOL v46 = v40 > 7;
  int v47 = memcmp(&__s2, v44, v45);
  BOOL v48 = v47 < 0;
  if (!v47) {
    BOOL v48 = v46;
  }
  if (v48)
  {
LABEL_53:
    uint64_t __s2 = (char *)operator new(0x30uLL);
    long long v83 = xmmword_181129E50;
    strcpy(__s2, "Could not find parameter with name 'epsilon'.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
LABEL_54:
    if (SHIBYTE(v83) < 0) {
      operator delete(__s2);
    }
    uint64_t v49 = 0;
    goto LABEL_57;
  }
  if (v35) {
    BOOL v51 = v28;
  }
  else {
    BOOL v51 = v27;
  }
  if (v51[8] - v51[7] != 16)
  {
    uint64_t __s2 = (char *)operator new(0x28uLL);
    long long v83 = xmmword_18112B060;
    strcpy(__s2, "Unexpected argument size for 'epsilon'");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
    goto LABEL_54;
  }
  HIBYTE(v83) = 7;
  strcpy((char *)&__s2, "epsilon");
  Parameteruint64_t Value = MIL::IROperation::GetParameterValue();
  uint64_t v53 = (*(uint64_t (**)(uint64_t))(*(void *)ParameterValue + 40))(ParameterValue);
  if (SHIBYTE(v83) < 0) {
    operator delete(__s2);
  }
  if (!v53)
  {
    uint64_t __s2 = (char *)operator new(0x38uLL);
    long long v83 = xmmword_181129E70;
    strcpy(__s2, "Failed to materialize constant: value is not a tensor.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t *)&__s2);
    goto LABEL_54;
  }
  uint64_t v54 = (*(uint64_t (**)(uint64_t))(*(void *)v53 + 32))(v53);
  int v55 = (*(uint64_t (**)(uint64_t))(*(void *)v54 + 88))(v54);
  if (v55 == 4)
  {
    HIBYTE(v83) = 7;
    strcpy((char *)&__s2, "epsilon");
    MIL::IROperation::GetParameterValue();
    LOWORD(v81) = MIL::IRValue::GetScalar<MIL::Fp16>();
    MIL::Fp16::GetFloat((MIL::Fp16 *)&v81);
    F32FloatAttr = mlir::Builder::getF32FloatAttr(a3 + 18, v60, v59);
  }
  else
  {
    if (v55 != 5)
    {
      uint64_t __s2 = (char *)operator new(0x20uLL);
      long long v83 = xmmword_181129E90;
      strcpy(__s2, "Unexpected MIL element type.");
      MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t *)&__s2);
      goto LABEL_54;
    }
    HIBYTE(v83) = 7;
    strcpy((char *)&__s2, "epsilon");
    MIL::IROperation::GetParameterValue();
    MIL::IRValue::GetScalar<float>();
    F32FloatAttr = mlir::Builder::getF32FloatAttr(a3 + 18, v57, v56);
  }
  __int16 v87 = F32FloatAttr;
  if (SHIBYTE(v83) < 0) {
    operator delete(__s2);
  }
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) != 1)
  {
    uint64_t __s2 = (char *)operator new(0x40uLL);
    long long v83 = xmmword_181129DA0;
    strcpy(__s2, "The number of outputs does not match the number of results.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
    goto LABEL_54;
  }
  HIBYTE(v83) = 1;
  LOWORD(__s2) = 120;
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  if (SHIBYTE(v83) < 0) {
    operator delete(__s2);
  }
  long long v62 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(ParameterType);
  uint64_t v81 = 0;
  uint64_t v81 = MIL::IRTensorValueType::Rank(v62);
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 18), 0x20u, 1);
  id v64 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&v81, 1, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v64))
  {
    __int16 v66 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v67 = 566;
    unint64_t v68 = "Casting.h";
    __int16 v69 = "cast";
LABEL_105:
    __assert_rtn(v69, v68, v67, v66);
  }
  if (v64)
  {
    uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v64);
    if (!InterfaceFor)
    {
      __int16 v66 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v67 = 98;
      unint64_t v68 = "InterfaceSupport.h";
      __int16 v69 = "Interface";
      goto LABEL_105;
    }
  }
  else
  {
    uint64_t InterfaceFor = 0;
  }
  if (v81 == 3) {
    uint64_t v70 = &v94;
  }
  else {
    uint64_t v70 = (unint64_t *)&v93;
  }
  if (v81 == 3) {
    uint64_t v71 = 12;
  }
  else {
    uint64_t v71 = 16;
  }
  id v72 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v64, InterfaceFor, v70, v71, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v72) & 1) == 0) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  uint64_t __s2 = (char *)v72;
  unint64_t v80 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)&__s2);
  uint64_t __s2 = (char *)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>(a3 + 18, LocationForOp, &v91, &v80);
  __int16 v79 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>(a3 + 18, LocationForOp, &v90, &v80);
  uint64_t v78 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>(a3 + 18, LocationForOp, &v88, &v80);
  uint64_t v77 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>(a3 + 18, LocationForOp, &OptionalArgValue, &v80);
  uint64_t v73 = mlir::OpBuilder::create<mlir::mps::NormalizationOp,mlir::Value &,mlir::mps::ReshapeOp,mlir::mps::ReshapeOp,mlir::mps::ReshapeOp,mlir::mps::ReshapeOp,mlir::FloatAttr &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &v92, (uint64_t)&__s2, (uint64_t)&v79, (uint64_t)&v78, (uint64_t)&v77, (uint64_t *)&v87);
  (*(void (**)(char **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__s2, a2);
  if (!*(_DWORD *)(v73 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  MILToMLIRRewriter::setValue((uint64_t)a3, (long long *)__s2, v73 - 16);
  id v74 = __s2;
  if (__s2)
  {
    id v75 = (char *)v83;
    unint64_t v76 = (uint64_t *)__s2;
    if ((char *)v83 != __s2)
    {
      do
      {
        if (*(v75 - 1) < 0) {
          operator delete(*((void **)v75 - 3));
        }
        v75 -= 24;
      }
      while (v75 != v74);
      unint64_t v76 = (uint64_t *)__s2;
    }
    *(void *)&long long v83 = v74;
    operator delete(v76);
  }
  uint64_t v49 = 1;
LABEL_57:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&Constant, v85[0]);
  return v49;
}

void sub_180DA0E98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,char *a21)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::NormalizationOp,mlir::Value &,mlir::mps::ReshapeOp,mlir::mps::ReshapeOp,mlir::mps::ReshapeOp,mlir::mps::ReshapeOp,mlir::FloatAttr &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  v32[38] = *MEMORY[0x1E4F143B8];
  uint64_t v26 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v26);
  uint64_t v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.normalization", (const unsigned __int8 *)0x11, Context);
  if (!v18)
  {
    __int16 v30 = 1283;
    v29[2] = (uint64_t)"mps.normalization";
    v29[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v28 = 259;
    llvm::operator+(v29, (uint64_t *)&v27, (uint64_t)v31);
    llvm::report_fatal_error((llvm::Twine *)v31, 1);
  }
  mlir::OperationState::OperationState(v32, a2, v17);
  if (!*(_DWORD *)(*(void *)a4 + 36)
    || !*(_DWORD *)(*(void *)a5 + 36)
    || !*(_DWORD *)(*(void *)a6 + 36)
    || !*(_DWORD *)(*(void *)a7 + 36))
  {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::NormalizationOp::build((uint64_t)a1, (uint64_t)v32, *a3, *(void *)a4 - 16, *(void *)a5 - 16, *(void *)a6 - 16, *(void *)a7 - 16, *a8);
  unsigned int v19 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v32);
  if (!v19)
  {
    int v22 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v23 = 662;
    BOOL v24 = "Casting.h";
    unint64_t v25 = "dyn_cast";
    goto LABEL_13;
  }
  uint64_t v20 = llvm::DefaultDoCastIfPossible<mlir::mps::NormalizationOp,mlir::Operation *,llvm::CastInfo<mlir::mps::NormalizationOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v19);
  if (!v20)
  {
    int v22 = "result && \"builder didn't return the right type\"";
    int v23 = 497;
    BOOL v24 = "Builders.h";
    unint64_t v25 = "create";
LABEL_13:
    __assert_rtn(v25, v24, v23, v22);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v32);
  return v20;
}

void sub_180DA1164(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DA1178(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::NormalizationOp,mlir::Operation *,llvm::CastInfo<mlir::mps::NormalizationOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 17
      && *(void *)AttrData == 0x6D726F6E2E73706DLL
      && *(void *)(AttrData + 8) == 0x6F6974617A696C61
      && *(unsigned char *)(AttrData + 16) == 110)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.normalization";
      v9[3] = 17;
      uint64_t v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::NormalizationOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::BatchToSpacePattern::~BatchToSpacePattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::BatchToSpacePattern::matchAndRewrite(_anonymous_namespace_::BatchToSpacePattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v141 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v134 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "block_shape");
  uint64_t v6 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 160))(a2);
  v133[0] = 0;
  v133[1] = 0;
  uint64_t v132 = v133;
  uint64_t v7 = v6 + 1;
  __int16 v8 = *v6;
  if (*v6 == (const void **)(v6 + 1)) {
    goto LABEL_43;
  }
  do
  {
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&v132, (uint64_t *)v133, v8 + 4, (uint64_t)(v8 + 4));
    uint64_t v9 = (const void **)v8[1];
    if (v9)
    {
      do
      {
        __int16 v10 = (const void ***)v9;
        uint64_t v9 = (const void **)*v9;
      }
      while (v9);
    }
    else
    {
      do
      {
        __int16 v10 = (const void ***)v8[2];
        BOOL v11 = *v10 == v8;
        __int16 v8 = (const void **)v10;
      }
      while (!v11);
    }
    __int16 v8 = (const void **)v10;
  }
  while (v10 != v7);
  uint64_t v12 = v133[0];
  HIBYTE(v140) = 5;
  strcpy((char *)&__s2, "crops");
  if (!v133[0]) {
    goto LABEL_43;
  }
  uint64_t v13 = v133;
  do
  {
    uint64_t v14 = v12;
    uint64_t v15 = v13;
    uint64_t v17 = v12 + 32;
    uint64_t v16 = (char *)*((void *)v12 + 4);
    unint64_t v18 = v14[55];
    int v19 = (char)v18;
    if ((v18 & 0x80u) != 0) {
      unint64_t v18 = *((void *)v14 + 5);
    }
    if (v19 >= 0) {
      uint64_t v20 = v17;
    }
    else {
      uint64_t v20 = v16;
    }
    if (v18 >= 5) {
      size_t v21 = 5;
    }
    else {
      size_t v21 = v18;
    }
    BOOL v22 = v18 < 5;
    int v23 = memcmp(v20, &__s2, v21);
    if (v23) {
      BOOL v22 = v23 < 0;
    }
    BOOL v24 = (char **)(v14 + 8);
    if (v22)
    {
      uint64_t v13 = v15;
    }
    else
    {
      BOOL v24 = (char **)v14;
      uint64_t v13 = (char **)v14;
    }
    uint64_t v12 = *v24;
  }
  while (v12);
  if (v13 == v133) {
    goto LABEL_43;
  }
  unint64_t v25 = (char *)(v15 + 4);
  if (v22) {
    uint64_t v26 = v15;
  }
  else {
    uint64_t v26 = v14;
  }
  if (!v22) {
    unint64_t v25 = v17;
  }
  unint64_t v27 = *((unsigned __int8 *)v13 + 55);
  int v28 = (char)v27;
  __int16 v30 = (char *)v26[4];
  unint64_t v29 = v26[5];
  if ((v27 & 0x80u) != 0) {
    unint64_t v27 = v29;
  }
  if (v28 >= 0) {
    unint64_t v31 = v25;
  }
  else {
    unint64_t v31 = v30;
  }
  if (v27 >= 5) {
    size_t v32 = 5;
  }
  else {
    size_t v32 = v27;
  }
  BOOL v33 = v27 > 5;
  int v34 = memcmp(&__s2, v31, v32);
  BOOL v35 = v34 < 0;
  if (!v34) {
    BOOL v35 = v33;
  }
  if (v35)
  {
LABEL_43:
    uint64_t __s2 = (char *)operator new(0x30uLL);
    long long v140 = xmmword_18112B080;
    strcpy(__s2, "Could not find parameter with name 'crops'.");
    uint64_t v36 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
    goto LABEL_44;
  }
  if (v22) {
    unint64_t v40 = v15;
  }
  else {
    unint64_t v40 = v14;
  }
  if (v40[8] - v40[7] == 16)
  {
    HIBYTE(v140) = 5;
    strcpy((char *)&__s2, "crops");
    Parameteruint64_t Value = MIL::IROperation::TryGetParameterValue();
    if (SHIBYTE(v140) < 0) {
      operator delete(__s2);
    }
    (*(void (**)(uint64_t))(*(void *)ParameterValue + 40))(ParameterValue);
    uint64_t Data = MIL::IRTensorValue::GetDataView<int>();
    unint64_t v44 = v43;
    HIBYTE(v140) = 1;
    LOWORD(__s2) = 120;
    ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
    BOOL v46 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(ParameterType);
    uint64_t v47 = MIL::IRTensorValueType::Rank(v46);
    if (SHIBYTE(v140) < 0) {
      operator delete(__s2);
    }
    unint64_t v48 = v44 >> 1;
    if (v47 < (uint64_t)((v44 >> 1 << 32) + 0x100000000) >> 32)
    {
      uint64_t __s2 = (char *)operator new(0x40uLL);
      long long v140 = xmmword_181129DA0;
      strcpy(__s2, "Unexpected length for 'crops' or 'block_shape' or 'rank(x)'");
      uint64_t v37 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
      if ((SHIBYTE(v140) & 0x80000000) == 0) {
        goto LABEL_47;
      }
      unint64_t v38 = __s2;
      goto LABEL_46;
    }
    uint64_t v119 = Data;
    uint64_t v117 = v44 >> 1 << 32;
    if (v47 <= 0) {
      int v49 = 0;
    }
    else {
      int v49 = v47 - v48;
    }
    unint64_t __src = (int)(v44 >> 1);
    uint64_t v116 = __src;
    uint64_t __s2 = (char *)&v140 + 8;
    *(void *)&long long v140 = 0x100000000;
    llvm::SmallVectorImpl<long long>::append<long long const*,void>((uint64_t)&__s2, &__src, &v137);
    uint64_t v50 = __s2;
    uint64_t v51 = v140;
    unint64_t __src = *(void *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8;
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&__src);
    uint64_t v53 = mlir::IntegerType::get(Context, 0x20u, 1u);
    uint64_t v54 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)v50, v51, v53, 0);
    if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v54))
    {
      unint64_t v56 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      int v57 = 566;
      unint64_t v58 = "Casting.h";
      id v59 = "cast";
LABEL_132:
      __assert_rtn(v59, v58, v57, v56);
    }
    if (v54)
    {
      uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v54);
      if (!InterfaceFor)
      {
        unint64_t v56 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
        int v57 = 98;
        unint64_t v58 = "InterfaceSupport.h";
        id v59 = "Interface";
        goto LABEL_132;
      }
    }
    else
    {
      uint64_t InterfaceFor = 0;
    }
    id v130 = v54;
    uint64_t v131 = InterfaceFor;
    unint64_t __src = 0;
    id v137 = 0;
    double v138 = 0;
    if (v117)
    {
      if (v117 < 0) {
        std::vector<int>::__throw_length_error[abi:ne180100]();
      }
      float v60 = (int32x4_t *)operator new((4 * (v44 >> 1)) & 0x3FFFFFFFFLL);
      unint64_t __src = (unint64_t)v60;
      double v138 = &v60->i8[4 * v116];
      bzero(v60, (4 * (v44 >> 1)) & 0x3FFFFFFFFLL);
      double v118 = v60;
      int64x2_t v61 = &v60->i8[(4 * (v44 >> 1)) & 0x3FFFFFFFFLL];
      id v137 = v61;
    }
    else
    {
      int64x2_t v61 = 0;
      double v118 = 0;
    }
    std::string __p = (void *)(*(void *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
    uint64_t v62 = mlir::Attribute::getContext((mlir::Attribute *)&__p);
    uint64_t v63 = mlir::IntegerType::get(v62, 0x20u, 1u);
    id v64 = (uint64_t **)mlir::RankedTensorType::get(0, 0, v63, 0);
    if (v48)
    {
      unint64_t v65 = (v44 >> 1);
      if (v65 < 8)
      {
        unint64_t v66 = 0;
LABEL_78:
        unint64_t v75 = v65 - v66;
        unint64_t v76 = &v118->i32[v66];
        __int32 v77 = v66 - v48;
        do
        {
          *v76++ = v77++;
          --v75;
        }
        while (v75);
        goto LABEL_80;
      }
      uint64_t v67 = (v44 >> 1) & 7;
      unint64_t v66 = v65 - v67;
      int32x4_t v68 = vdupq_n_s32(v48);
      int32x4_t v69 = (int32x4_t)xmmword_1810FFF10;
      uint64_t v70 = v118 + 1;
      v71.i64[0] = 0x400000004;
      v71.i64[1] = 0x400000004;
      v72.i64[0] = 0x800000008;
      v72.i64[1] = 0x800000008;
      unint64_t v73 = v65 - v67;
      do
      {
        int32x4_t v74 = vsubq_s32(v69, v68);
        v70[-1] = v74;
        *uint64_t v70 = vaddq_s32(v74, v71);
        int32x4_t v69 = vaddq_s32(v69, v72);
        v70 += 2;
        v73 -= 8;
      }
      while (v73);
      if (v67) {
        goto LABEL_78;
      }
    }
LABEL_80:
    int64_t v78 = v61 - (char *)v118;
    __int16 v79 = v118;
    __int16 v129 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v130, v131, v118, v78, 4, 1, 1);
    uint64_t v80 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ShapedType &,mlir::DenseElementsAttr &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t *)&v130, &v129);
    if (!*(_DWORD *)(v80 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v128 = v80 - 16;
    if (mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v64))
    {
      if (v64)
      {
        uint64_t v81 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v64);
        if (!v81)
        {
          float v82 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
          int v83 = 98;
          uint64_t v84 = "InterfaceSupport.h";
          __int16 v85 = "Interface";
          goto LABEL_135;
        }
      }
      else
      {
        uint64_t v81 = 0;
      }
      LODWORD(v124) = 0;
      float v86 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v64, v81, &v124, 4, 4, 1, 1);
      if (mlir::DenseIntElementsAttr::classof((uint64_t)v86))
      {
        std::string __p = v86;
        __int16 v87 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)&__p);
        if (*((_DWORD *)v87 + 9))
        {
          uint64_t v127 = (uint64_t)v87 - 16;
          if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
          {
            LOBYTE(__p) = 0;
            uint64_t v88 = mlir::OpBuilder::create<mlir::mps::BatchToSpaceOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,BOOL>(a3 + 18, LocationForOp, &ArgValue, &v128, &v127, &v134, (unsigned __int8 *)&__p);
            if (!*((_DWORD *)v88 + 9)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
            uint64_t v124 = (uint64_t)v88 - 16;
            if (v117 >= 1)
            {
              unint64_t v89 = 0;
              uint64_t v90 = (int)(v44 >> 1);
              if (v116 <= 1) {
                uint64_t v90 = 1;
              }
              uint64_t v91 = 2 * v90;
              do
              {
                int v123 = 0;
                if (v44 <= v89)
                {
                  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                  std::runtime_error::runtime_error(exception, "index out of bounds");
                  exception->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x1E4FBA4B8] + 16);
                  __cxa_throw(exception, (struct type_info *)off_1E4FBE4C0, MEMORY[0x1E4FBA1B8]);
                }
                int v92 = *(_DWORD *)(v119 + 4 * v89);
                int v122 = 0;
                int v123 = v92;
                if (v44 <= v89 + 1)
                {
                  id v114 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                  std::runtime_error::runtime_error(v114, "index out of bounds");
                  v114->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x1E4FBA4B8] + 16);
                  __cxa_throw(v114, (struct type_info *)off_1E4FBE4C0, MEMORY[0x1E4FBA1B8]);
                }
                int v93 = *(_DWORD *)(v119 + 4 * v89 + 4);
                int v122 = v93;
                if (v92 > 0 || v93 >= 1)
                {
                  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v64))
                  {
                    int v106 = 566;
                    uint64_t v109 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
                    uint64_t v108 = "Casting.h";
                    unsigned int v107 = "cast";
LABEL_130:
                    __assert_rtn(v107, v108, v106, v109);
                  }
                  if (v64)
                  {
                    uint64_t v95 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v64);
                    if (!v95)
                    {
                      int v106 = 98;
                      unsigned int v107 = "Interface";
                      uint64_t v108 = "InterfaceSupport.h";
                      uint64_t v109 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
                      goto LABEL_130;
                    }
                  }
                  else
                  {
                    uint64_t v95 = 0;
                  }
                  int v120 = v49;
                  uint64_t v96 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v64, v95, &v120, 4, 4, 1, 1);
                  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v96) & 1) == 0)
                  {
                    int v102 = 566;
                    uint64_t v103 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
                    BOOL v104 = "Casting.h";
                    uint64_t v105 = "cast";
                    goto LABEL_129;
                  }
                  unsigned int v121 = v96;
                  uint64_t v97 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &v121);
                  if (!*((_DWORD *)v97 + 9))
                  {
                    int v102 = 984;
                    uint64_t v105 = "getOpResultImpl";
                    BOOL v104 = "Operation.h";
                    uint64_t v103 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
LABEL_129:
                    __assert_rtn(v105, v104, v102, v103);
                  }
                  std::string __p = (char *)v97 - 16;
                  uint64_t v98 = mlir::OpBuilder::create<mlir::mps::CropOp,mlir::Value &,mlir::Value &,int &,int &>((mlir::mps::ConstantOp *)(a3 + 18), LocationForOp, &v124, (uint64_t *)&__p, (unsigned int *)&v123, (unsigned int *)&v122);
                  if (!*(_DWORD *)(v98 + 36)) {
                    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                  }
                  uint64_t v124 = v98 - 16;
                }
                v89 += 2;
                ++v49;
              }
              while (v91 != v89);
            }
            (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
            MILToMLIRRewriter::setValue((uint64_t)a3, (long long *)__p, v124);
            uint64_t v99 = (void **)__p;
            if (__p)
            {
              uint64_t v100 = (void **)v126;
              id v101 = __p;
              if ((void *)v126 != __p)
              {
                do
                {
                  if (*((char *)v100 - 1) < 0) {
                    operator delete(*(v100 - 3));
                  }
                  v100 -= 3;
                }
                while (v100 != v99);
                id v101 = __p;
              }
              *(void *)&long long v126 = v99;
              operator delete(v101);
            }
            uint64_t v37 = 1;
            __int16 v79 = v118;
          }
          else
          {
            std::string __p = operator new(0x40uLL);
            long long v126 = xmmword_181129DA0;
            strcpy((char *)__p, "The number of outputs does not match the number of results.");
            uint64_t v37 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
            if (SHIBYTE(v126) < 0) {
              operator delete(__p);
            }
          }
          if (v79) {
            operator delete(v79);
          }
          if (__s2 != (char *)&v140 + 8) {
            free(__s2);
          }
          goto LABEL_47;
        }
        uint64_t v110 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
        int v111 = 984;
        uint64_t v112 = "Operation.h";
        uint64_t v113 = "getOpResultImpl";
      }
      else
      {
        uint64_t v110 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        int v111 = 566;
        uint64_t v112 = "Casting.h";
        uint64_t v113 = "cast";
      }
      __assert_rtn(v113, v112, v111, v110);
    }
    float v82 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v83 = 566;
    uint64_t v84 = "Casting.h";
    __int16 v85 = "cast";
LABEL_135:
    __assert_rtn(v85, v84, v83, v82);
  }
  uint64_t __s2 = (char *)operator new(0x28uLL);
  long long v140 = xmmword_18112B070;
  strcpy(__s2, "Unexpected argument size for 'crops'");
  uint64_t v36 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
LABEL_44:
  uint64_t v37 = v36;
  if (SHIBYTE(v140) < 0)
  {
    unint64_t v38 = __s2;
LABEL_46:
    operator delete(v38);
  }
LABEL_47:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v132, v133[0]);
  return v37;
}

void sub_180DA1F44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,char *a30)
{
  std::vector<std::string>::~vector[abi:ne180100](&a18);
  if (__p) {
    operator delete(__p);
  }
  size_t v32 = *(void **)(v30 + 24);
  if (v32 != a10) {
    free(v32);
  }
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a29, a30);
  _Unwind_Resume(a1);
}

void anonymous namespace'::CallPattern::~CallPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::CallPattern::matchAndRewrite(_anonymous_namespace_::CallPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  HIBYTE(__p[2]) = 8;
  strcpy((char *)__p, "function");
  MIL::IRObject::GetAttribute();
  MIL::IRValue::GetScalar<std::string>();
  uint64_t v5 = (*(uint64_t (**)(mlir::StringAttr *, void **))(*(void *)*a3 + 56))(*a3, v73);
  uint64_t v6 = (void *)v5;
  if (!v5)
  {
    __p[0] = operator new(0x30uLL);
    *(_OWORD *)&__p[1] = xmmword_181129E10;
    strcpy((char *)__p[0], "cannot find the function in the MIL program.");
    uint64_t v58 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
    if (SHIBYTE(__p[2]) < 0)
    {
      operator delete(__p[0]);
      if (((char)v74 & 0x80000000) == 0) {
        return v58;
      }
    }
    else if (((char)v74 & 0x80000000) == 0)
    {
      return v58;
    }
    goto LABEL_71;
  }
  uint64_t v64 = LocationForOp;
  uint64_t v70 = 0;
  int32x4_t v71 = 0;
  int32x4_t v72 = 0;
  uint64_t v7 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 128))(v5);
  unint64_t v65 = v6;
  uint64_t v9 = v7 + 1;
  __int16 v8 = (void *)*v7;
  if ((void *)*v7 != v7 + 1)
  {
    while (1)
    {
      BOOL v24 = (const char *)(v8 + 4);
      if (*((char *)v8 + 55) < 0) {
        BOOL v24 = *(const char **)v24;
      }
      Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, v24);
      uint64_t v26 = ArgValue;
      unint64_t v27 = v71;
      if (v71 >= v72)
      {
        int v28 = v70;
        int64_t v29 = v71 - (unsigned char *)v70;
        uint64_t v30 = (v71 - (unsigned char *)v70) >> 3;
        unint64_t v31 = v30 + 1;
        if ((unint64_t)(v30 + 1) >> 61) {
          std::vector<long>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v32 = v72 - (unsigned char *)v70;
        if ((v72 - (unsigned char *)v70) >> 2 > v31) {
          unint64_t v31 = v32 >> 2;
        }
        if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v33 = v31;
        }
        if (v33)
        {
          if (v33 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          int v34 = operator new(8 * v33);
          BOOL v35 = (uint64_t *)&v34[8 * v30];
          uint64_t *v35 = v26;
          uint64_t v10 = (uint64_t)(v35 + 1);
          int64_t v36 = v27 - v28;
          if (v27 != v28)
          {
LABEL_32:
            unint64_t v37 = v36 - 8;
            if (v37 < 0x58) {
              goto LABEL_89;
            }
            if ((unint64_t)(v27 - v34 - v29) < 0x20) {
              goto LABEL_89;
            }
            uint64_t v38 = (v37 >> 3) + 1;
            uint64_t v39 = 8 * (v38 & 0x3FFFFFFFFFFFFFFCLL);
            unint64_t v40 = &v27[-v39];
            BOOL v35 = (uint64_t *)((char *)v35 - v39);
            int v41 = &v34[8 * v30 - 16];
            unint64_t v42 = (long long *)(v27 - 16);
            uint64_t v43 = v38 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v44 = *v42;
              *(v41 - 1) = *(v42 - 1);
              _OWORD *v41 = v44;
              v41 -= 2;
              v42 -= 2;
              v43 -= 4;
            }
            while (v43);
            unint64_t v27 = v40;
            if (v38 != (v38 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_89:
              do
              {
                uint64_t v45 = *((void *)v27 - 1);
                v27 -= 8;
                *--BOOL v35 = v45;
              }
              while (v27 != v28);
            }
            unint64_t v27 = v70;
            uint64_t v70 = v35;
            int32x4_t v72 = &v34[8 * v33];
            if (!v27) {
              goto LABEL_43;
            }
LABEL_42:
            operator delete(v27);
            goto LABEL_43;
          }
        }
        else
        {
          int v34 = 0;
          BOOL v35 = (uint64_t *)(8 * v30);
          *(void *)(8 * v30) = v26;
          uint64_t v10 = 8 * v30 + 8;
          int64_t v36 = v27 - v28;
          if (v27 != v28) {
            goto LABEL_32;
          }
        }
        uint64_t v70 = v35;
        int32x4_t v72 = &v34[8 * v33];
        if (v27) {
          goto LABEL_42;
        }
      }
      else
      {
        *(void *)int32x4_t v71 = ArgValue;
        uint64_t v10 = (uint64_t)(v27 + 8);
      }
LABEL_43:
      int32x4_t v71 = (char *)v10;
      BOOL v46 = (void *)v8[1];
      if (v46)
      {
        do
        {
          uint64_t v47 = v46;
          BOOL v46 = (void *)*v46;
        }
        while (v46);
      }
      else
      {
        do
        {
          uint64_t v47 = (void *)v8[2];
          BOOL v48 = *v47 == (void)v8;
          __int16 v8 = v47;
        }
        while (!v48);
      }
      __int16 v8 = v47;
      if (v47 == v9) {
        goto LABEL_4;
      }
    }
  }
  uint64_t v10 = 0;
LABEL_4:
  uint64_t v67 = 0;
  *(void *)int32x4_t v68 = 0;
  uint64_t v69 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)v65 + 160))(__p);
  BOOL v11 = a3 + 18;
  uint64_t v13 = (const MIL::IRValueType **)__p[0];
  uint64_t v12 = (const MIL::IRValueType **)__p[1];
  if (__p[0] == __p[1])
  {
    uint64_t v14 = v64;
    if (!__p[0]) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  do
  {
    getMLIRTypes(*v13, *v11, (uint64_t *)&v81);
    std::vector<mlir::Type>::__insert_with_size[abi:ne180100]<std::__wrap_iter<mlir::Type*>,std::__wrap_iter<mlir::Type*>>((uint64_t)&v67, *(uint64_t *)v68, v81, v82, (v82 - v81) >> 3);
    if (v81)
    {
      float v82 = v81;
      operator delete(v81);
    }
    ++v13;
  }
  while (v13 != v12);
  uint64_t v13 = (const MIL::IRValueType **)__p[0];
  uint64_t v14 = v64;
  if (__p[0])
  {
LABEL_6:
    __p[1] = v13;
    operator delete(v13);
  }
LABEL_7:
  uint64_t v75 = v14;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v75);
  uint64_t v16 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.call", (const unsigned __int8 *)8, Context);
  if (!v17)
  {
    __int16 v80 = 1283;
    v79[2] = (uint64_t)"mps.call";
    v79[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v77 = 259;
    llvm::operator+(v79, (uint64_t *)&v76, (uint64_t)&v81);
    llvm::report_fatal_error((llvm::Twine *)&v81, 1);
  }
  mlir::OperationState::OperationState(__p, v14, v16);
  mlir::ValueRange::ValueRange((unint64_t *)&v81, (uint64_t)v67, (uint64_t)(*(void *)v68 - (void)v67) >> 3);
  unint64_t v18 = v70;
  mlir::ValueRange::ValueRange((unint64_t *)v79, (uint64_t)v70, (v10 - (uint64_t)v70) >> 3);
  if ((v74 & 0x80u) == 0) {
    int v19 = v73;
  }
  else {
    int v19 = (void **)v73[0];
  }
  if ((v74 & 0x80u) == 0) {
    uint64_t v20 = (mlir::MLIRContext *)v74;
  }
  else {
    uint64_t v20 = (mlir::MLIRContext *)v73[1];
  }
  mlir::mps::CallOp::build(v11, (uint64_t)__p, (uint64_t)v81, (uint64_t)v82, v79[0], v79[1], v19, v20, 0);
  size_t v21 = mlir::OpBuilder::create((mlir::OpBuilder *)v11, (const mlir::OperationState *)__p);
  if (!v21)
  {
    float v60 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v61 = 662;
    uint64_t v62 = "Casting.h";
    uint64_t v63 = "dyn_cast";
    goto LABEL_83;
  }
  uint64_t v22 = llvm::DefaultDoCastIfPossible<mlir::mps::CallOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CallOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v21);
  if (!v22)
  {
    float v60 = "result && \"builder didn't return the right type\"";
    int v61 = 497;
    uint64_t v62 = "Builders.h";
    uint64_t v63 = "create";
LABEL_83:
    __assert_rtn(v63, v62, v61, v60);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)__p);
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) != *(_DWORD *)(v22 + 36)) {
    __assert_rtn("matchAndRewrite", "MPSGraphMIL.mm", 1394, "milOp.GetNumOutputs() == callOp->getNumResults()");
  }
  for (unint64_t i = 0; i != (*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2); ++i)
  {
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(__p, a2);
    unint64_t v50 = *(unsigned int *)(v22 + 36);
    if (i >= v50) {
      __assert_rtn("operator[]", "STLExtras.h", 1281, "Index < size() && \"invalid index for value range\"");
    }
    uint64_t v51 = (char *)__p[0];
    if (v50) {
      uint64_t v52 = v22 - 16;
    }
    else {
      uint64_t v52 = 0;
    }
    uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v52, i);
    uint64_t v54 = (char *)operator new(8uLL);
    *(void *)uint64_t v54 = NextResultAtOffset;
    uint64_t v81 = &v51[24 * i];
    int v55 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v81, (uint64_t)&std::piecewise_construct, (long long **)&v81);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v55 + 5, v54, v54 + 8, 1uLL);
    operator delete(v54);
    unint64_t v56 = (void **)__p[0];
    if (__p[0])
    {
      int v57 = (void **)__p[1];
      int v49 = __p[0];
      if (__p[1] != __p[0])
      {
        do
        {
          if (*((char *)v57 - 1) < 0) {
            operator delete(*(v57 - 3));
          }
          v57 -= 3;
        }
        while (v57 != v56);
        int v49 = __p[0];
      }
      __p[1] = v56;
      operator delete(v49);
    }
  }
  if (v67)
  {
    *(void *)int32x4_t v68 = v67;
    operator delete(v67);
  }
  if (v18) {
    operator delete(v18);
  }
  uint64_t v58 = 1;
  if ((char)v74 < 0) {
LABEL_71:
  }
    operator delete(v73[0]);
  return v58;
}

void sub_180DA296C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, _Unwind_Exception *exception_objecta, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a37 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<mlir::Type>::__insert_with_size[abi:ne180100]<std::__wrap_iter<mlir::Type*>,std::__wrap_iter<mlir::Type*>>(uint64_t a1, uint64_t a2, char *__src, char *a4, uint64_t a5)
{
  unint64_t v5 = *(void *)a1;
  uint64_t v6 = a2 - *(void *)a1;
  uint64_t v7 = (char *)(*(void *)a1 + (v6 & 0xFFFFFFFFFFFFFFF8));
  uint64_t v8 = a5 - 1;
  if (a5 < 1) {
    return v7;
  }
  uint64_t v12 = v6 >> 3;
  uint64_t v14 = *(char **)(a1 + 8);
  uint64_t v13 = *(void *)(a1 + 16);
  if (a5 > (v13 - (uint64_t)v14) >> 3)
  {
    unint64_t v15 = a5 + ((uint64_t)&v14[-v5] >> 3);
    if (v15 >> 61) {
      std::vector<int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v16 = v13 - v5;
    if (v16 >> 2 > v15) {
      unint64_t v15 = v16 >> 2;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v15;
    }
    if (v17)
    {
      if (v17 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      unint64_t v18 = v17;
      int v19 = operator new(8 * v17);
      unint64_t v17 = v18;
      uint64_t v12 = v6 >> 3;
    }
    else
    {
      int v19 = 0;
    }
    uint64_t v32 = &v19[8 * v12];
    unint64_t v33 = &v32[8 * a5];
    int v34 = v32;
    BOOL v35 = __src;
    if ((v8 & 0x1FFFFFFFFFFFFFFFuLL) < 7) {
      goto LABEL_58;
    }
    int v34 = &v19[8 * v12];
    BOOL v35 = __src;
    if ((unint64_t)(&v19[v6 & 0xFFFFFFFFFFFFFFF8] - __src) < 0x20) {
      goto LABEL_58;
    }
    uint64_t v36 = (v8 & 0x1FFFFFFFFFFFFFFFLL) + 1;
    uint64_t v37 = 8 * (v36 & 0x3FFFFFFFFFFFFFFCLL);
    int v34 = &v32[v37];
    BOOL v35 = &__src[v37];
    uint64_t v38 = (long long *)(__src + 16);
    uint64_t v39 = &v19[8 * v12 + 16];
    uint64_t v40 = v36 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v41 = *v38;
      *(v39 - 1) = *(v38 - 1);
      *uint64_t v39 = v41;
      v38 += 2;
      v39 += 2;
      v40 -= 4;
    }
    while (v40);
    if (v36 != (v36 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_58:
      do
      {
        uint64_t v42 = *(void *)v35;
        v35 += 8;
        *(void *)int v34 = v42;
        v34 += 8;
      }
      while (v34 != v33);
    }
    uint64_t v43 = *(char **)a1;
    if (*(char **)a1 == v7)
    {
      uint64_t v47 = &v19[8 * v12];
      int v57 = &v19[8 * v17];
      size_t v58 = v14 - v7;
      if (v14 == v7) {
        goto LABEL_39;
      }
    }
    else
    {
      long long v44 = (char *)((v6 & 0xFFFFFFFFFFFFFFF8) + v5);
      unint64_t v45 = v44 - v43 - 8;
      BOOL v46 = v7;
      uint64_t v47 = &v19[8 * v12];
      if (v45 < 0x68) {
        goto LABEL_59;
      }
      BOOL v46 = v7;
      uint64_t v47 = &v19[8 * v12];
      if ((unint64_t)(v44 - &v19[v6 & 0xFFFFFFFFFFFFFFF8]) < 0x20) {
        goto LABEL_59;
      }
      uint64_t v48 = (v45 >> 3) + 1;
      uint64_t v49 = 8 * (v48 & 0x3FFFFFFFFFFFFFFCLL);
      BOOL v46 = &v7[-v49];
      uint64_t v47 = &v32[-v49];
      uint64_t v50 = 8 * v12 - 16;
      uint64_t v51 = &v19[v50];
      uint64_t v52 = (long long *)(v5 + v50);
      uint64_t v53 = v48 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v54 = *v52;
        *(v51 - 1) = *(v52 - 1);
        *uint64_t v51 = v54;
        v51 -= 2;
        v52 -= 2;
        v53 -= 4;
      }
      while (v53);
      if (v48 != (v48 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_59:
        do
        {
          uint64_t v55 = *((void *)v46 - 1);
          v46 -= 8;
          *((void *)v47 - 1) = v55;
          v47 -= 8;
        }
        while (v46 != v43);
      }
      unint64_t v56 = *(unsigned char **)(a1 + 8);
      int v57 = &v19[8 * v17];
      size_t v58 = v56 - v7;
      if (v56 == v7) {
        goto LABEL_39;
      }
    }
    memmove(v33, v7, v58);
LABEL_39:
    id v59 = *(void **)a1;
    *(void *)a1 = v47;
    *(void *)(a1 + 8) = &v33[v58];
    *(void *)(a1 + 16) = v57;
    if (v59) {
      operator delete(v59);
    }
    return v32;
  }
  uint64_t v20 = (v14 - v7) >> 3;
  if (v20 >= a5)
  {
    size_t v21 = &__src[8 * a5];
    int v23 = *(char **)(a1 + 8);
    goto LABEL_18;
  }
  size_t v21 = &__src[8 * v20];
  int64_t v22 = a4 - v21;
  if (a4 != v21)
  {
    int32x4_t v68 = &__src[8 * v20];
    memmove(*(void **)(a1 + 8), v68, a4 - v21);
    uint64_t v12 = v6 >> 3;
    size_t v21 = v68;
  }
  int v23 = &v14[v22];
  *(void *)(a1 + 8) = &v14[v22];
  if (v14 - v7 >= 1)
  {
LABEL_18:
    BOOL v24 = &v7[8 * a5];
    size_t v25 = v23 - v24;
    uint64_t v26 = (v23 - v24) >> 3;
    unint64_t v27 = &v23[-8 * a5];
    int v28 = v23;
    if (v27 < v14)
    {
      unint64_t v29 = (v6 & 0xFFFFFFFFFFFFFFF8) + v25;
      unint64_t v30 = v29 + v5 + 8;
      if ((unint64_t)v14 > v30) {
        unint64_t v30 = (unint64_t)v14;
      }
      unint64_t v31 = v30 + ~v5 - v29;
      if (v31 >= 0x58)
      {
        int v28 = v23;
        if ((unint64_t)&v24[-(v6 & 0xFFFFFFFFFFFFFFF8) - v5] >= 0x20)
        {
          uint64_t v60 = (v31 >> 3) + 1;
          uint64_t v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
          v27 += v61;
          int v28 = &v23[v61];
          uint64_t v62 = v23 + 16;
          uint64_t v63 = (long long *)(8 * v26 + 8 * v12 + v5 + 16);
          uint64_t v64 = v60 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v65 = *v63;
            *(v62 - 1) = *(v63 - 1);
            *uint64_t v62 = v65;
            v62 += 2;
            v63 += 2;
            v64 -= 4;
          }
          while (v64);
          if (v60 == (v60 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_49;
          }
        }
      }
      else
      {
        int v28 = v23;
      }
      do
      {
        uint64_t v66 = *(void *)v27;
        v27 += 8;
        *(void *)int v28 = v66;
        v28 += 8;
      }
      while (v27 < v14);
    }
LABEL_49:
    *(void *)(a1 + 8) = v28;
    if (v23 != v24) {
      memmove(&v23[-8 * v26], v7, v25);
    }
    if (v21 != __src) {
      memmove(v7, __src, v21 - __src);
    }
  }
  return v7;
}

void anonymous namespace'::CastPattern::~CastPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::CastPattern::matchAndRewrite(_anonymous_namespace_::CastPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  HIBYTE(v17) = 5;
  strcpy((char *)&__p, "dtype");
  MIL::IROperation::TryGetParameterValue();
  MIL::IRValue::GetScalar<std::string>();
  uint64_t MLIRElemType = MILToMLIRRewriter::getMLIRElemType((uint64_t)a3, (uint64_t)&v18);
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, &ArgValue, &MLIRElemType);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    uint64_t v8 = (char *)operator new(8uLL);
    *(void *)uint64_t v8 = (char *)v6 - 16;
    size_t v21 = v7;
    uint64_t v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v21);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      BOOL v11 = (void **)v17;
      uint64_t v12 = __p;
      if ((void *)v17 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v17 = v10;
      operator delete(v12);
    }
    uint64_t v13 = 1;
    if (v19 < 0) {
      goto LABEL_17;
    }
    return v13;
  }
  std::string __p = operator new(0x40uLL);
  long long v17 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v13 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v17) < 0)
  {
    operator delete(__p);
    if ((v19 & 0x80000000) == 0) {
      return v13;
    }
  }
  else if ((v19 & 0x80000000) == 0)
  {
    return v13;
  }
LABEL_17:
  operator delete(v18);
  return v13;
}

void sub_180DA31E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::ConcatPattern::~ConcatPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::ConcatPattern::matchAndRewrite(_anonymous_namespace_::ConcatPattern *this, const MIL::IROperation *a2, MILToMLIRRewriter *a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp((mlir::StringAttr **)a3, a2);
  MILToMLIRRewriter::getArgValues((int8x8_t *)a3, a2, "values", v27);
  strcpy(__p, "interleave");
  if (MIL::IROperation::TryGetParameterValue()) {
    unsigned __int8 v6 = MIL::IRValue::GetScalar<BOOL>();
  }
  else {
    unsigned __int8 v6 = 0;
  }
  unsigned __int8 v25 = v6;
  __p[23] = 4;
  strcpy(__p, "axis");
  Parameteruint64_t Value = (MIL::IRValue *)MIL::IROperation::GetParameterValue();
  uint64_t v8 = (MIL::IRValueType *)(*(uint64_t (**)(MIL::IRValue *))(*(void *)ParameterValue + 32))(ParameterValue);
  uint64_t v9 = MIL::IRValueType::AsTensorType(v8);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v9 + 88))(v9) == 11)
  {
    MIL::IRValue::AsTensor(ParameterValue);
    int v10 = *(_DWORD *)MIL::IRTensorValue::GetDataView<int>();
    uint64_t v11 = mlir::IntegerType::get(*((void *)a3 + 18), 0x20u, 1u);
    uint64_t v12 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v11, 0);
    *(void *)std::string __p = mlir::mps::getConstantAttr<int>(v12, v10);
    uint64_t v13 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((MILToMLIRRewriter *)((char *)a3 + 144), LocationForOp, (uint64_t **)__p);
    if (!*((_DWORD *)v13 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v24 = (uint64_t)v13 - 16;
    if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
    {
      uint64_t v14 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL &>((mlir::UnitAttr **)a3 + 18, LocationForOp, (uint64_t *)v27, &v24, &v25);
      (*(void (**)(unsigned char *__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(__p, a2);
      if (!*(_DWORD *)(v14 + 36)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
      unint64_t v15 = *(long long **)__p;
      uint64_t v16 = (char *)operator new(8uLL);
      *(void *)uint64_t v16 = v14 - 16;
      int v28 = v15;
      long long v17 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)a3 + 64, (uint64_t)v15, (uint64_t)&std::piecewise_construct, &v28);
      std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v17 + 5, v16, v16 + 8, 1uLL);
      operator delete(v16);
      uint64_t v18 = *(void *)__p;
      if (*(void *)__p)
      {
        uint64_t v19 = *(void *)&__p[8];
        uint64_t v20 = *(void **)__p;
        if (*(void *)&__p[8] != *(void *)__p)
        {
          do
          {
            if (*(char *)(v19 - 1) < 0) {
              operator delete(*(void **)(v19 - 24));
            }
            v19 -= 24;
          }
          while (v19 != v18);
          uint64_t v20 = *(void **)__p;
        }
        *(void *)&__p[8] = v18;
        operator delete(v20);
      }
      uint64_t v21 = 1;
      int64_t v22 = v27[0];
      if (!v27[0]) {
        return v21;
      }
LABEL_19:
      v27[1] = v22;
      operator delete(v22);
      return v21;
    }
    *(void *)std::string __p = operator new(0x40uLL);
    *(_OWORD *)&__p[8] = xmmword_181129DA0;
    strcpy(*(char **)__p, "The number of outputs does not match the number of results.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __p);
  }
  else
  {
    *(void *)std::string __p = operator new(0x20uLL);
    *(_OWORD *)&__p[8] = xmmword_181129E30;
    strcpy(*(char **)__p, "unexpected type for axis");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __p);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  uint64_t v21 = 0;
  int64_t v22 = v27[0];
  if (v27[0]) {
    goto LABEL_19;
  }
  return v21;
}

void sub_180DA3718(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18)
{
  if (a16 < 0)
  {
    operator delete(__p);
    uint64_t v19 = a17;
    if (!a17) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else
  {
    uint64_t v19 = a17;
    if (!a17) {
      goto LABEL_3;
    }
  }
  operator delete(v19);
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL &>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned __int8 *a5)
{
  v27[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.concat", (const unsigned __int8 *)0xA, Context);
  if (!v12)
  {
    __int16 v24 = 1283;
    v23[2] = (uint64_t)"mps.concat";
    v23[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v27, a2, v11);
  mlir::ValueRange::ValueRange(v26, *a3, (a3[1] - *a3) >> 3);
  mlir::mps::ConcatOp::build(a1, (uint64_t)v27, v26[0], v26[1], *a4, *a5);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v27);
  if (!v13)
  {
    uint64_t v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v17 = 662;
    uint64_t v18 = "Casting.h";
    uint64_t v19 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v14 = llvm::DefaultDoCastIfPossible<mlir::mps::ConcatOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ConcatOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    uint64_t v16 = "result && \"builder didn't return the right type\"";
    int v17 = 497;
    uint64_t v18 = "Builders.h";
    uint64_t v19 = "create";
LABEL_8:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v27);
  return v14;
}

void sub_180DA3958(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
}

void sub_180DA3970(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
}

void anonymous namespace'::ConstPattern::~ConstPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::ConstPattern::matchAndRewrite(_anonymous_namespace_::ConstPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  __p[23] = 3;
  strcpy(__p, "val");
  Attribute = (MIL::IRValue *)MIL::IRObject::GetAttribute();
  uint64_t v6 = (*(uint64_t (**)(MIL::IRValue *))(*(void *)Attribute + 40))(Attribute);
  if (!v6)
  {
    *(void *)std::string __p = operator new(0x28uLL);
    *(_OWORD *)&__p[8] = xmmword_181128700;
    uint64_t v9 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __p);
    if ((__p[23] & 0x80000000) == 0) {
      return v9;
    }
LABEL_85:
    operator delete(*(void **)__p);
    return v9;
  }
  uint64_t v7 = v6;
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 32))(v6);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v8 + 88))(v8) != 3)
  {
    if (!(*(unsigned int (**)(uint64_t))(*(void *)v7 + 80))(v7)) {
      goto LABEL_69;
    }
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 96))(v7);
    if (!v10) {
      goto LABEL_69;
    }
    uint64_t v11 = (void *)v10;
    (*(void (**)(void))(*(void *)*a3 + 40))();
    MIL::Blob::TryGetDataOffsetAndByteLength();
    if (!v67) {
      goto LABEL_69;
    }
    v61[23] = 4;
    strcpy(v61, "path");
    unint64_t v12 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&v62, (uint64_t *)v61, 4uLL);
    int8x8_t v13 = (int8x8_t)v11[1];
    if (v13)
    {
      unint64_t v14 = v12;
      uint8x8_t v15 = (uint8x8_t)vcnt_s8(v13);
      v15.i16[0] = vaddlv_u8(v15);
      if (v15.u32[0] > 1uLL)
      {
        unint64_t v16 = v12;
        if (v12 >= *(void *)&v13) {
          unint64_t v16 = v12 % *(void *)&v13;
        }
      }
      else
      {
        unint64_t v16 = (*(void *)&v13 - 1) & v12;
      }
      int v17 = *(uint64_t ***)(*v11 + 8 * v16);
      if (v17)
      {
        uint64_t v18 = *v17;
        if (*v17)
        {
          if (v61[23] >= 0) {
            uint64_t v19 = v61[23];
          }
          else {
            uint64_t v19 = *(void *)&v61[8];
          }
          if (v61[23] >= 0) {
            uint64_t v20 = v61;
          }
          else {
            uint64_t v20 = *(unsigned char **)v61;
          }
          if (v15.u32[0] < 2uLL)
          {
            uint64_t v21 = *(void *)&v13 - 1;
            while (1)
            {
              uint64_t v29 = v18[1];
              if (v14 == v29)
              {
                uint64_t v30 = *((unsigned __int8 *)v18 + 39);
                if ((v30 & 0x80u) == 0) {
                  uint64_t v31 = *((unsigned __int8 *)v18 + 39);
                }
                else {
                  uint64_t v31 = v18[3];
                }
                if (v31 == v19)
                {
                  if ((v30 & 0x80) != 0)
                  {
                    uint64_t v33 = v19;
                    int v34 = memcmp((const void *)v18[2], v20, v18[3]);
                    uint64_t v19 = v33;
                    if (!v34) {
                      goto LABEL_55;
                    }
                  }
                  else
                  {
                    if (!*((unsigned char *)v18 + 39)) {
                      goto LABEL_55;
                    }
                    uint64_t v32 = 0;
                    while (*((unsigned __int8 *)v18 + v32 + 16) == v20[v32])
                    {
                      if (v30 == ++v32) {
                        goto LABEL_55;
                      }
                    }
                  }
                }
              }
              else if ((v29 & v21) != v16)
              {
                goto LABEL_56;
              }
              __int16 v22 = 0;
              uint64_t v18 = (uint64_t *)*v18;
              if (!v18) {
                goto LABEL_57;
              }
            }
          }
          while (1)
          {
            unint64_t v23 = v18[1];
            if (v14 == v23)
            {
              uint64_t v24 = *((unsigned __int8 *)v18 + 39);
              if ((v24 & 0x80u) == 0) {
                uint64_t v25 = *((unsigned __int8 *)v18 + 39);
              }
              else {
                uint64_t v25 = v18[3];
              }
              if (v25 == v19)
              {
                if ((v24 & 0x80) != 0)
                {
                  uint64_t v27 = v19;
                  int v28 = memcmp((const void *)v18[2], v20, v18[3]);
                  uint64_t v19 = v27;
                  if (!v28)
                  {
LABEL_55:
                    __int16 v22 = v18;
                    goto LABEL_57;
                  }
                }
                else
                {
                  if (!*((unsigned char *)v18 + 39)) {
                    goto LABEL_55;
                  }
                  uint64_t v26 = 0;
                  while (*((unsigned __int8 *)v18 + v26 + 16) == v20[v26])
                  {
                    if (v24 == ++v26) {
                      goto LABEL_55;
                    }
                  }
                }
              }
            }
            else
            {
              if (v23 >= *(void *)&v13) {
                v23 %= *(void *)&v13;
              }
              if (v23 != v16) {
                break;
              }
            }
            __int16 v22 = 0;
            uint64_t v18 = (uint64_t *)*v18;
            if (!v18) {
              goto LABEL_57;
            }
          }
        }
      }
    }
LABEL_56:
    __int16 v22 = 0;
LABEL_57:
    if ((v61[23] & 0x80000000) != 0) {
      operator delete(*(void **)v61);
    }
    if (!v22 || !v22[5])
    {
LABEL_69:
      __p[0] = 0;
      char v59 = 0;
      goto LABEL_70;
    }
    MIL::IRValue::GetScalar<std::string>();
    memset(&v65, 0, sizeof(v65));
    std::string::size_type size = HIBYTE(v66.__r_.__value_.__r.__words[2]);
    if ((v66.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v36 = &v66;
    }
    else {
      uint64_t v36 = (std::string *)v66.__r_.__value_.__r.__words[0];
    }
    if ((v66.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v66.__r_.__value_.__l.__size_;
    }
    std::string::append[abi:ne180100]<char const*,0>(&v65.__pn_, v36, (std::string *)((char *)v36 + size));
    if (std::__fs::filesystem::path::__root_directory(&v65).__size_)
    {
      if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0) {
        std::string::__init_copy_ctor_external(&v64, v66.__r_.__value_.__l.__data_, v66.__r_.__value_.__l.__size_);
      }
      else {
        std::string v64 = v66;
      }
    }
    else
    {
      std::__fs::filesystem::__absolute((std::__fs::filesystem::path *)v61, &v65, 0);
      if ((v61[23] & 0x80000000) != 0)
      {
        std::string::__init_copy_ctor_external(&v64, *(const std::string::value_type **)v61, *(std::string::size_type *)&v61[8]);
        if ((v61[23] & 0x80000000) != 0) {
          operator delete(*(void **)v61);
        }
      }
      else
      {
        std::string v64 = *(std::string *)v61;
      }
    }
    unint64_t v45 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>(a3 + 13, (uint64_t)&v64);
    if (v45)
    {
      if (*((char *)v45 + 63) < 0) {
        std::string::__init_copy_ctor_external(&v62, (const std::string::value_type *)v45[5], v45[6]);
      }
      else {
        std::string v62 = *(std::string *)(v45 + 5);
      }
      char v63 = 1;
      if (SHIBYTE(v64.__r_.__value_.__r.__words[2]) < 0) {
        std::string::__init_copy_ctor_external((std::string *)v61, v64.__r_.__value_.__l.__data_, v64.__r_.__value_.__l.__size_);
      }
      else {
        *(std::string *)uint64_t v61 = v64;
      }
      char v46 = HIBYTE(v62.__r_.__value_.__r.__words[2]);
      if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)&v61[24], v62.__r_.__value_.__l.__data_, v62.__r_.__value_.__l.__size_);
        char v46 = HIBYTE(v62.__r_.__value_.__r.__words[2]);
      }
      else
      {
        *(std::string *)&char v61[24] = v62;
      }
      *(_OWORD *)std::string __p = *(_OWORD *)v61;
      *(void *)&__p[16] = *(void *)&v61[16];
      *(_OWORD *)unint64_t v56 = *(_OWORD *)&v61[24];
      uint64_t v57 = *(void *)&v61[40];
      uint64_t v58 = v68;
      char v59 = 1;
      if (v63 && v46 < 0) {
        operator delete(v62.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      __p[0] = 0;
      char v59 = 0;
    }
    if (SHIBYTE(v64.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v64.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v65.__pn_.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_110:
        if ((SHIBYTE(v66.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_111;
        }
        goto LABEL_115;
      }
    }
    else if ((SHIBYTE(v65.__pn_.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_110;
    }
    operator delete(v65.__pn_.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v66.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_111:
      if (!v59)
      {
LABEL_70:
        uint64_t v37 = MILToMLIRRewriter::materializeConstant((uint64_t)a3, Attribute, &LocationForOp);
        if (!v37)
        {
          *(void *)uint64_t v61 = operator new(0x20uLL);
          *(_OWORD *)&v61[8] = xmmword_181129D60;
          strcpy(*(char **)v61, "Failed to convert constant.");
          uint64_t v9 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, v61);
          if ((v61[23] & 0x80000000) != 0) {
            operator delete(*(void **)v61);
          }
          goto LABEL_82;
        }
LABEL_71:
        (*(void (**)(unsigned char *__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(v61, a2);
        uint64_t v38 = *(void *)v61;
        uint64_t v39 = (char *)operator new(8uLL);
        *(void *)uint64_t v39 = v37;
        v62.__r_.__value_.__r.__words[0] = v38;
        uint64_t v40 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), v38, (uint64_t)&std::piecewise_construct, (long long **)&v62);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v40 + 5, v39, v39 + 8, 1uLL);
        operator delete(v39);
        uint64_t v41 = *(void *)v61;
        if (*(void *)v61)
        {
          uint64_t v42 = *(void *)&v61[8];
          uint64_t v43 = *(void **)v61;
          if (*(void *)&v61[8] != *(void *)v61)
          {
            do
            {
              if (*(char *)(v42 - 1) < 0) {
                operator delete(*(void **)(v42 - 24));
              }
              v42 -= 24;
            }
            while (v42 != v41);
            uint64_t v43 = *(void **)v61;
          }
          *(void *)&v61[8] = v41;
          operator delete(v43);
        }
        uint64_t v9 = 1;
LABEL_82:
        if (!v59) {
          return v9;
        }
        if (SHIBYTE(v57) < 0)
        {
          operator delete(v56[0]);
          if ((__p[23] & 0x80000000) == 0) {
            return v9;
          }
        }
        else if ((__p[23] & 0x80000000) == 0)
        {
          return v9;
        }
        goto LABEL_85;
      }
LABEL_116:
      long long v47 = *((_OWORD *)a3 + 10);
      *(_OWORD *)uint64_t v61 = *((_OWORD *)a3 + 9);
      *(_OWORD *)&v61[16] = v47;
      uint64_t v48 = (const MIL::IRTensorValueType *)(*(uint64_t (**)(uint64_t))(*(void *)v7 + 32))(v7);
      uint64_t MLIRType = getMLIRType(v48, *(mlir::MLIRContext **)v61);
      if (!MLIRType)
      {
        *((unsigned char *)&v62.__r_.__value_.__s + 23) = 19;
        strcpy((char *)&v62, "Unexpected MIL type");
        uint64_t v9 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&v62);
        if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v62.__r_.__value_.__l.__data_);
        }
        goto LABEL_82;
      }
      if (*(void *)MLIRType)
      {
        if (*(_UNKNOWN **)(*(void *)MLIRType + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
        {
          v62.__r_.__value_.__r.__words[0] = MLIRType;
          uint64_t v50 = mlir::OpBuilder::create<mlir::mps::ReadDataFromFileOp,mlir::RankedTensorType &,std::string &,unsigned long long &,std::string &>((mlir::StringAttr **)v61, LocationForOp, (uint64_t *)&v62, (uint64_t)__p, &v58, (uint64_t)v56);
          if (!*((_DWORD *)v50 + 9)) {
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          }
          uint64_t v37 = (uint64_t)v50 - 16;
          goto LABEL_71;
        }
        uint64_t v51 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        int v52 = 566;
        uint64_t v53 = "Casting.h";
        long long v54 = "cast";
      }
      else
      {
        uint64_t v51 = "abstractType && \"Malformed type storage object.\"";
        int v52 = 160;
        uint64_t v53 = "TypeSupport.h";
        long long v54 = "getAbstractType";
      }
      __assert_rtn(v54, v53, v52, v51);
    }
LABEL_115:
    operator delete(v66.__r_.__value_.__l.__data_);
    if (!v59) {
      goto LABEL_70;
    }
    goto LABEL_116;
  }
  return 1;
}

void sub_180DA4328(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v45 - 137) < 0) {
    operator delete(*(void **)(v45 - 160));
  }
  if (*(char *)(v45 - 113) < 0) {
    operator delete(*(void **)(v45 - 136));
  }
  _Unwind_Resume(exception_object);
}

void sub_180DA4474(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReadDataFromFileOp,mlir::RankedTensorType &,std::string &,unsigned long long &,std::string &>(mlir::StringAttr **a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t *a5, uint64_t a6)
{
  v42[38] = *MEMORY[0x1E4F143B8];
  uint64_t v34 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v34);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.read_data_from_file", (const unsigned __int8 *)0x17, Context);
  if (!v14)
  {
    __int16 v40 = 1283;
    uint64_t v38 = "mps.read_data_from_file";
    uint64_t v39 = 23;
                      "een added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-de"
                      "pendent-whats-up-with-dialects-management";
    __int16 v36 = 259;
    llvm::operator+(v37, v35, (uint64_t)v41);
    llvm::report_fatal_error((llvm::Twine *)v41, 1);
  }
  mlir::OperationState::OperationState(v42, a2, v13);
  int v15 = *(char *)(a4 + 23);
  if (v15 >= 0) {
    uint64_t v16 = a4;
  }
  else {
    uint64_t v16 = *(void *)a4;
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(a4 + 23);
  }
  else {
    uint64_t v17 = *(void *)(a4 + 8);
  }
  int v18 = *(char *)(a6 + 23);
  if (v18 >= 0) {
    uint64_t v19 = a6;
  }
  else {
    uint64_t v19 = *(void *)a6;
  }
  if (v18 >= 0) {
    uint64_t v20 = *(unsigned __int8 *)(a6 + 23);
  }
  else {
    uint64_t v20 = *(void *)(a6 + 8);
  }
  mlir::mps::ReadDataFromFileOp::build(a1, (uint64_t)v42, *a3, v16, v17, *a5, v19, v20);
  uint64_t v21 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v42);
  __int16 v22 = v21;
  if (!v21)
  {
    uint64_t v26 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v27 = 662;
    int v28 = "Casting.h";
    uint64_t v29 = "dyn_cast";
    goto LABEL_31;
  }
  uint64_t v23 = *((void *)v21 + 6);
  uint64_t v24 = *(void **)(v23 + 16);
  if (v24 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v41[0] = *(void *)(v23 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
    if (v31 == 23
      && *AttrData == 0x646165722E73706DLL
      && AttrData[1] == 0x72665F617461645FLL
      && *(void *)((char *)AttrData + 15) == 0x656C69665F6D6F72)
    {
      __int16 v40 = 1283;
      v37[0] = (uint64_t)"classof on '";
      uint64_t v38 = "mps.read_data_from_file";
      uint64_t v39 = 23;
      v35[0] = (uint64_t)"' failed due to the operation not being registered";
      __int16 v36 = 259;
      llvm::operator+(v37, v35, (uint64_t)v41);
      llvm::report_fatal_error((llvm::Twine *)v41, 1);
    }
    goto LABEL_30;
  }
  if (v24 != &mlir::detail::TypeIDResolver<mlir::mps::ReadDataFromFileOp,void>::id)
  {
LABEL_30:
    uint64_t v26 = "result && \"builder didn't return the right type\"";
    int v27 = 497;
    int v28 = "Builders.h";
    uint64_t v29 = "create";
LABEL_31:
    __assert_rtn(v29, v28, v27, v26);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v42);
  return v22;
}

void sub_180DA4718(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DA4730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t std::optional<anonymous namespace'::ConstPattern::MutableConstantInfo>::~optional(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 56)) {
    return a1;
  }
  if (*(char *)(a1 + 47) < 0)
  {
    operator delete(*(void **)(a1 + 24));
    if ((*(char *)(a1 + 23) & 0x80000000) == 0) {
      return a1;
    }
  }
  else if ((*(char *)(a1 + 23) & 0x80000000) == 0)
  {
    return a1;
  }
  operator delete(*(void **)a1);
  return a1;
}

std::string *std::string::append[abi:ne180100]<char const*,0>(std::string *this, std::string *__src, std::string *a3)
{
  LODWORD(v6) = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  size_t v7 = (char *)a3 - (char *)__src;
  if ((v6 & 0x80000000) != 0)
  {
    if (a3 == __src) {
      return this;
    }
    std::string::size_type size = this->__r_.__value_.__l.__size_;
    unint64_t v11 = this->__r_.__value_.__r.__words[2];
    std::string::size_type v9 = (v11 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    uint64_t v10 = (std::string *)this->__r_.__value_.__r.__words[0];
    unint64_t v6 = HIBYTE(v11);
    if (this->__r_.__value_.__r.__words[0] > (unint64_t)__src) {
      goto LABEL_11;
    }
  }
  else
  {
    if (a3 == __src) {
      return this;
    }
    std::string::size_type size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    std::string::size_type v9 = 22;
    uint64_t v10 = this;
    if (this > __src)
    {
LABEL_11:
      if (v9 - size < v7)
      {
        std::string::__grow_by(this, v9, size + v7 - v9, size, size, 0, 0);
        this->__r_.__value_.__l.__size_ = size;
        uint64_t v13 = this;
        if ((*((unsigned char *)&this->__r_.__value_.__s + 23) & 0x80) == 0)
        {
LABEL_13:
          char v14 = (char *)v13 + size;
          if (v7 < 0x20)
          {
LABEL_14:
            int v15 = __src;
            goto LABEL_33;
          }
LABEL_17:
          uint64_t v16 = (char *)v13 + size;
          if ((unint64_t)((char *)v13 + size - (char *)__src) >= 0x20)
          {
            int v15 = (std::string *)((char *)__src + (v7 & 0xFFFFFFFFFFFFFFE0));
            v14 += v7 & 0xFFFFFFFFFFFFFFE0;
            uint64_t v21 = v16 + 16;
            __int16 v22 = &__src->__r_.__value_.__r.__words[2];
            unint64_t v23 = v7 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              long long v24 = *(_OWORD *)v22;
              *(v21 - 1) = *((_OWORD *)v22 - 1);
              *uint64_t v21 = v24;
              v21 += 2;
              v22 += 4;
              v23 -= 32;
            }
            while (v23);
            if (v7 == (v7 & 0xFFFFFFFFFFFFFFE0)) {
              goto LABEL_34;
            }
          }
          else
          {
            int v15 = __src;
          }
          do
          {
LABEL_33:
            std::string::value_type v25 = v15->__r_.__value_.__s.__data_[0];
            int v15 = (std::string *)((char *)v15 + 1);
            *v14++ = v25;
          }
          while (v15 != a3);
LABEL_34:
          *char v14 = 0;
          std::string::size_type v26 = size + v7;
          if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0) {
            this->__r_.__value_.__l.__size_ = v26;
          }
          else {
            *((unsigned char *)&this->__r_.__value_.__s + 23) = v26 & 0x7F;
          }
          return this;
        }
      }
      else
      {
        uint64_t v13 = this;
        if ((v6 & 0x80) == 0) {
          goto LABEL_13;
        }
      }
      uint64_t v13 = (std::string *)this->__r_.__value_.__r.__words[0];
      char v14 = (std::string::value_type *)(this->__r_.__value_.__r.__words[0] + size);
      if (v7 < 0x20) {
        goto LABEL_14;
      }
      goto LABEL_17;
    }
  }
  if ((std::string *)((char *)&v10->__r_.__value_.__l.__data_ + size + 1) <= __src) {
    goto LABEL_11;
  }
  if (v7 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v7 > 0x16)
  {
    uint64_t v17 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v17 = v7 | 7;
    }
    uint64_t v18 = v17 + 1;
    p_dst = (void **)operator new(v17 + 1);
    size_t v29 = v7;
    int64_t v30 = v18 | 0x8000000000000000;
    std::string __dst = p_dst;
  }
  else
  {
    HIBYTE(v30) = v7;
    p_dst = (void **)&__dst;
  }
  memcpy(p_dst, __src, v7);
  *((unsigned char *)p_dst + v7) = 0;
  if (v30 >= 0) {
    uint64_t v19 = (const std::string::value_type *)&__dst;
  }
  else {
    uint64_t v19 = (const std::string::value_type *)__dst;
  }
  if (v30 >= 0) {
    std::string::size_type v20 = HIBYTE(v30);
  }
  else {
    std::string::size_type v20 = v29;
  }
  std::string::append(this, v19, v20);
  if (SHIBYTE(v30) < 0) {
    operator delete(__dst);
  }
  return this;
}

void sub_180DA49D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::CumSumPattern::~CumSumPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::CumSumPattern::matchAndRewrite(_anonymous_namespace_::CumSumPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  strcpy(v38, "exclusive");
  MIL::IROperation::TryGetParameterValue();
  int v7 = MIL::IRValue::GetScalar<BOOL>();
  strcpy(v38, "reverse");
  MIL::IROperation::TryGetParameterValue();
  int v8 = MIL::IRValue::GetScalar<BOOL>();
  int v31 = 0;
  v38[23] = 4;
  strcpy(v38, "axis");
  if (MIL::IROperation::TryGetParameterValue()) {
    int v31 = MIL::IRValue::GetScalar<int>();
  }
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 18), 0x20u, 1);
  uint64_t v10 = (uint64_t **)mlir::RankedTensorType::get(0, 0, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v10)) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v10)
  {
    uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v10);
    if (!InterfaceFor) {
      __assert_rtn("Interface", "InterfaceSupport.h", 98, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
    }
  }
  else
  {
    uint64_t InterfaceFor = 0;
  }
  uint64_t v12 = mlir::DenseElementsAttr::getFromRawBuffer(v10, InterfaceFor, &v31, 4, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof(v12) & 1) == 0) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  *(void *)uint64_t v38 = v12;
  uint64_t v13 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)v38);
  if (!*((_DWORD *)v13 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v32 = LocationForOp;
    uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v32);
    uint64_t v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cumulative_sum", (const unsigned __int8 *)0x12, Context);
    if (!v16)
    {
      __int16 v36 = 1283;
      v35[2] = (uint64_t)"mps.cumulative_sum";
      v35[3] = 18;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v34 = 259;
      llvm::operator+(v35, (uint64_t *)&v33, (uint64_t)v37);
      llvm::report_fatal_error((llvm::Twine *)v37, 1);
    }
    mlir::OperationState::OperationState(v38, LocationForOp, v15);
    mlir::mps::CumulativeSumOp::build(a3 + 18, (uint64_t)v38, ArgValue, (uint64_t)v13 - 16, v7, v8);
    uint64_t v17 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)v38);
    if (v17)
    {
      uint64_t v18 = llvm::DefaultDoCastIfPossible<mlir::mps::CumulativeSumOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CumulativeSumOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v17);
      if (v18)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)v38);
        (*(void (**)(unsigned char *__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(v38, a2);
        if (!*(_DWORD *)(v18 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        uint64_t v19 = *(long long **)v38;
        std::string::size_type v20 = (char *)operator new(8uLL);
        *(void *)std::string::size_type v20 = v18 - 16;
        v37[0] = v19;
        uint64_t v21 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v19, (uint64_t)&std::piecewise_construct, v37);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v21 + 5, v20, v20 + 8, 1uLL);
        operator delete(v20);
        uint64_t v22 = *(void *)v38;
        if (*(void *)v38)
        {
          uint64_t v23 = *(void *)&v38[8];
          long long v24 = *(void **)v38;
          if (*(void *)&v38[8] != *(void *)v38)
          {
            do
            {
              if (*(char *)(v23 - 1) < 0) {
                operator delete(*(void **)(v23 - 24));
              }
              v23 -= 24;
            }
            while (v23 != v22);
            long long v24 = *(void **)v38;
          }
          *(void *)&v38[8] = v22;
          operator delete(v24);
        }
        return 1;
      }
      int v27 = "result && \"builder didn't return the right type\"";
      int v28 = 497;
      size_t v29 = "Builders.h";
      int64_t v30 = "create";
    }
    else
    {
      int v27 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v28 = 662;
      size_t v29 = "Casting.h";
      int64_t v30 = "dyn_cast";
    }
    __assert_rtn(v30, v29, v28, v27);
  }
  *(void *)uint64_t v38 = operator new(0x40uLL);
  *(_OWORD *)&v38[8] = xmmword_181129DA0;
  strcpy(*(char **)v38, "The number of outputs does not match the number of results.");
  uint64_t v25 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, v38);
  if ((v38[23] & 0x80000000) != 0) {
    operator delete(*(void **)v38);
  }
  return v25;
}

void sub_180DA500C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_180DA5020(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a32 < 0)
  {
    operator delete(*v32);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::EinsumPattern::~EinsumPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::EinsumPattern::matchAndRewrite(_anonymous_namespace_::EinsumPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  MILToMLIRRewriter::getArgValues((int8x8_t *)a3, a2, "values", &v25);
  if (v26 - (unsigned char *)v25 == 16)
  {
    uint64_t v6 = *(void *)v25;
    uint64_t v21 = *((void *)v25 + 1);
    uint64_t v22 = v6;
    LODWORD(__p) = -2;
    LODWORD(v27) = -3;
    int v7 = mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int,int>((mlir::mps::ConstantOp *)(a3 + 18), LocationForOp, &v22, (unsigned int *)&__p, (unsigned int *)&v27);
    if (!*((_DWORD *)v7 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v22 = (uint64_t)v7 - 16;
    LODWORD(__p) = -2;
    LODWORD(v27) = -3;
    int v8 = mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int,int>((mlir::mps::ConstantOp *)(a3 + 18), LocationForOp, &v21, (unsigned int *)&__p, (unsigned int *)&v27);
    if (!*((_DWORD *)v8 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v21 = (uint64_t)v8 - 16;
    LOBYTE(__p) = 0;
    LOBYTE(v27) = 0;
    uint64_t v9 = mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value &,mlir::Value &,BOOL,BOOL>(a3 + 18, LocationForOp, &v22, &v21, (unsigned __int8 *)&__p, (unsigned __int8 *)&v27);
    if (!*(_DWORD *)(v9 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v20 = v9 - 16;
    LODWORD(__p) = -2;
    LODWORD(v27) = -3;
    uint64_t v10 = mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int,int>((mlir::mps::ConstantOp *)(a3 + 18), LocationForOp, &v20, (unsigned int *)&__p, (unsigned int *)&v27);
    if (!*((_DWORD *)v10 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v20 = (uint64_t)v10 - 16;
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    unint64_t v11 = (long long *)__p;
    uint64_t v12 = v20;
    uint64_t v13 = (char *)operator new(8uLL);
    *(void *)uint64_t v13 = v12;
    int v27 = v11;
    char v14 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v11, (uint64_t)&std::piecewise_construct, &v27);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v14 + 5, v13, v13 + 8, 1uLL);
    operator delete(v13);
    uint64_t v15 = (void **)__p;
    if (__p)
    {
      char v16 = (void **)v24;
      uint64_t v17 = __p;
      if ((void *)v24 != __p)
      {
        do
        {
          if (*((char *)v16 - 1) < 0) {
            operator delete(*(v16 - 3));
          }
          v16 -= 3;
        }
        while (v16 != v15);
        uint64_t v17 = __p;
      }
      *(void *)&long long v24 = v15;
      operator delete(v17);
    }
    uint64_t v18 = 1;
  }
  else
  {
    std::string __p = operator new(0x20uLL);
    long long v24 = xmmword_181128710;
    strcpy((char *)__p, "Non-supported number of inputs.");
    uint64_t v18 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    if (SHIBYTE(v24) < 0) {
      operator delete(__p);
    }
  }
  if (v25)
  {
    std::string::size_type v26 = v25;
    operator delete(v25);
  }
  return v18;
}

void sub_180DA5484(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *__p, uint64_t a20)
{
  if (__p)
  {
    a20 = (uint64_t)__p;
    operator delete(__p);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void anonymous namespace'::GELUPattern::~GELUPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GELUPattern::matchAndRewrite(_anonymous_namespace_::GELUPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = (mlir::OpBuilder *)(a3 + 18);
    int v7 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 160))(a2);
    v82[0] = 0;
    v82[1] = 0;
    uint64_t v81 = v82;
    uint64_t v9 = v7 + 1;
    int v8 = *v7;
    if (*v7 == (const void **)(v7 + 1)) {
      goto LABEL_99;
    }
    do
    {
      std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&v81, (uint64_t *)v82, v8 + 4, (uint64_t)(v8 + 4));
      uint64_t v10 = (const void **)v8[1];
      if (v10)
      {
        do
        {
          unint64_t v11 = (const void ***)v10;
          uint64_t v10 = (const void **)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          unint64_t v11 = (const void ***)v8[2];
          BOOL v39 = *v11 == v8;
          int v8 = (const void **)v11;
        }
        while (!v39);
      }
      int v8 = (const void **)v11;
    }
    while (v11 != v9);
    uint64_t v13 = v82[0];
    HIBYTE(v93) = 4;
    strcpy((char *)&__p, "mode");
    if (!v82[0]) {
      goto LABEL_99;
    }
    char v14 = (mlir::OpBuilder *)(a3 + 18);
    uint64_t v15 = v82;
    do
    {
      char v16 = v13;
      uint64_t v17 = v15;
      uint64_t v19 = v13 + 32;
      uint64_t v18 = (char *)*((void *)v13 + 4);
      unint64_t v20 = v16[55];
      int v21 = (char)v20;
      if ((v20 & 0x80u) != 0) {
        unint64_t v20 = *((void *)v16 + 5);
      }
      if (v21 >= 0) {
        uint64_t v22 = v19;
      }
      else {
        uint64_t v22 = v18;
      }
      if (v20 >= 4) {
        size_t v23 = 4;
      }
      else {
        size_t v23 = v20;
      }
      BOOL v24 = v20 < 4;
      int v25 = memcmp(v22, &__p, v23);
      if (v25) {
        BOOL v24 = v25 < 0;
      }
      std::string::size_type v26 = (char **)(v16 + 8);
      if (v24)
      {
        uint64_t v15 = v17;
      }
      else
      {
        std::string::size_type v26 = (char **)v16;
        uint64_t v15 = (char **)v16;
      }
      uint64_t v13 = *v26;
    }
    while (v13);
    uint64_t v6 = (mlir::OpBuilder *)(a3 + 18);
    if (v15 == v82) {
      goto LABEL_99;
    }
    int v27 = (char *)(v17 + 4);
    if (v24) {
      int v28 = v17;
    }
    else {
      int v28 = v16;
    }
    if (!v24) {
      int v27 = v19;
    }
    unint64_t v29 = *((unsigned __int8 *)v15 + 55);
    int v30 = (char)v29;
    uint64_t v32 = (char *)v28[4];
    unint64_t v31 = v28[5];
    if ((v29 & 0x80u) != 0) {
      unint64_t v29 = v31;
    }
    if (v30 >= 0) {
      uint64_t v33 = v27;
    }
    else {
      uint64_t v33 = v32;
    }
    if (v29 >= 4) {
      size_t v34 = 4;
    }
    else {
      size_t v34 = v29;
    }
    BOOL v35 = v29 > 4;
    int v36 = memcmp(&__p, v33, v34);
    BOOL v37 = v36 < 0;
    if (!v36) {
      BOOL v37 = v35;
    }
    if (v37) {
      goto LABEL_99;
    }
    uint64_t v38 = v24 ? v17 : (char **)v16;
    if (v38[8] - v38[7] != 16) {
      goto LABEL_99;
    }
    HIBYTE(v93) = 4;
    strcpy((char *)&__p, "mode");
    MIL::IROperation::TryGetParameterValue();
    if (SHIBYTE(v93) < 0) {
      operator delete(__p);
    }
    MIL::IRValue::GetScalar<std::string>();
    if ((SHIBYTE(v93) & 0x80000000) == 0)
    {
      if (HIBYTE(v93) != 18)
      {
        if (HIBYTE(v93) != 21) {
          goto LABEL_99;
        }
        BOOL v39 = __p == (void *)0x5F44494F4D474953 && (void)v93 == 0x4D49584F52505041;
        if (!v39 || *(void *)((char *)&v93 + 5) != 0x4E4F4954414D4958) {
          goto LABEL_99;
        }
        goto LABEL_96;
      }
      if (__p != (void *)0x5050415F484E4154 || (void)v93 != 0x4954414D49584F52 || WORD4(v93) != 20047) {
        goto LABEL_99;
      }
LABEL_83:
      std::string __p = (void *)1;
      uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
      long long v47 = (void *)mlir::RankedTensorType::get((uint64_t)&__p, 1, ElementTypeOrSelf, 0);
      std::string __p = (void *)createConstantOpFromScalar(v14, LocationForOp, v47, 0.797884583);
      v91[0] = (long long *)createConstantOpFromScalar(v14, LocationForOp, v47, 0.0447149985);
      v87[0] = createConstantOpFromScalar(v14, LocationForOp, v47, 0.5);
      v85[0] = createConstantOpFromScalar(v14, LocationForOp, v47, 1.0);
      uint64_t v84 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)v14, LocationForOp, (uint64_t *)v91, &ArgValue);
      uint64_t v80 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::MultiplyOp&,mlir::Value &>((mlir::Float32Type **)v14, LocationForOp, (uint64_t)&v84, &ArgValue);
      __int16 v79 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)v14, LocationForOp, (uint64_t *)&__p, &ArgValue);
      uint64_t v78 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value &,mlir::mps::MultiplyOp &>((mlir::Float32Type **)v14, LocationForOp, v85, (uint64_t)&v80);
      uint64_t v77 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::MultiplyOp&,mlir::mps::AddOp &>((mlir::Float32Type **)v14, LocationForOp, (uint64_t)&v79, (uint64_t)&v78);
      uint64_t v76 = mlir::OpBuilder::create<mlir::mps::TanhOp,mlir::mps::MultiplyOp &>(v14, LocationForOp, (uint64_t)&v77);
      uint64_t v75 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value &,mlir::mps::TanhOp &>((mlir::Float32Type **)v14, LocationForOp, v85, (uint64_t)&v76);
      unsigned __int8 v74 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)v14, LocationForOp, v87, &ArgValue);
      uint64_t v48 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::MultiplyOp&,mlir::mps::AddOp &>((mlir::Float32Type **)v14, LocationForOp, (uint64_t)&v74, (uint64_t)&v75);
      if (!*(_DWORD *)(v48 + 36)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
      goto LABEL_97;
    }
    if ((void)v93 == 18)
    {
      uint64_t v41 = __p;
      if (*(void *)__p == 0x5050415F484E4154
        && *((void *)__p + 1) == 0x4954414D49584F52
        && *((_WORD *)__p + 8) == 20047)
      {
        operator delete(__p);
        goto LABEL_83;
      }
    }
    else
    {
      uint64_t v41 = __p;
      if ((void)v93 == 21)
      {
        BOOL v51 = *(void *)__p != 0x5F44494F4D474953
           || *((void *)__p + 1) != 0x4D49584F52505041
           || *(void *)((char *)__p + 13) != 0x4E4F4954414D4958;
        operator delete(__p);
        if (!v51)
        {
LABEL_96:
          std::string __p = (void *)1;
          uint64_t v52 = mlir::getElementTypeOrSelf(ArgValue);
          uint64_t v53 = (void *)mlir::RankedTensorType::get((uint64_t)&__p, 1, v52, 0);
          std::string __p = (void *)createConstantOpFromScalar(v14, LocationForOp, v53, 1.70200002);
          v91[0] = (long long *)mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)v14, LocationForOp, (uint64_t *)&__p, &ArgValue);
          v87[0] = mlir::OpBuilder::create<mlir::mps::SigmoidOp,mlir::mps::MultiplyOp &>(v14, LocationForOp, (uint64_t)v91);
          uint64_t v48 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value &,mlir::mps::SigmoidOp &>((mlir::Float32Type **)v14, LocationForOp, &ArgValue, (uint64_t)v87);
          if (!*(_DWORD *)(v48 + 36)) {
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          }
LABEL_97:
          uint64_t v54 = v48 - 16;
LABEL_105:
          (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
          std::string v62 = (long long *)__p;
          char v63 = (char *)operator new(8uLL);
          *(void *)char v63 = v54;
          v91[0] = v62;
          std::string v64 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v62, (uint64_t)&std::piecewise_construct, v91);
          std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v64 + 5, v63, v63 + 8, 1uLL);
          operator delete(v63);
          std::__fs::filesystem::path v65 = (void **)__p;
          if (__p)
          {
            std::string v66 = (void **)v93;
            char v67 = __p;
            if ((void *)v93 != __p)
            {
              do
              {
                if (*((char *)v66 - 1) < 0) {
                  operator delete(*(v66 - 3));
                }
                v66 -= 3;
              }
              while (v66 != v65);
              char v67 = __p;
            }
            *(void *)&long long v93 = v65;
            operator delete(v67);
          }
          std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v81, v82[0]);
          return 1;
        }
LABEL_99:
        uint64_t v84 = (mlir::GenericProgramPoint *)LocationForOp;
        uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v84);
        uint64_t v56 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.gelu", (const unsigned __int8 *)8, Context);
        if (!v57)
        {
          __int16 v90 = 1283;
          uint64_t v88 = "mps.gelu";
          uint64_t v89 = 8;
                            "sn't been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#register"
                            "ed-loaded-dependent-whats-up-with-dialects-management";
          __int16 v86 = 259;
          llvm::operator+(v87, v85, (uint64_t)v91);
          llvm::report_fatal_error((llvm::Twine *)v91, 1);
        }
        mlir::OperationState::OperationState(&__p, LocationForOp, v56);
        mlir::mps::ACosOp::build((uint64_t)v6, (uint64_t)&__p, ArgValue);
        uint64_t v58 = mlir::OpBuilder::create(v6, (const mlir::OperationState *)&__p);
        char v59 = v58;
        if (v58)
        {
          uint64_t v60 = *((void *)v58 + 6);
          uint64_t v61 = *(void **)(v60 + 16);
          if (v61 == &mlir::detail::TypeIDResolver<void,void>::id)
          {
            v91[0] = *(long long **)(v60 + 8);
            uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v91);
            if (v73 == 8 && *AttrData == 0x756C65672E73706DLL)
            {
              __int16 v90 = 1283;
              v87[0] = (uint64_t)"classof on '";
              uint64_t v88 = "mps.gelu";
              uint64_t v89 = 8;
              v85[0] = (uint64_t)"' failed due to the operation not being registered";
              __int16 v86 = 259;
              llvm::operator+(v87, v85, (uint64_t)v91);
              llvm::report_fatal_error((llvm::Twine *)v91, 1);
            }
          }
          else if (v61 == &mlir::detail::TypeIDResolver<mlir::mps::GeluOp,void>::id)
          {
            mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
            if (!*((_DWORD *)v59 + 9)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
            uint64_t v54 = (uint64_t)v59 - 16;
            goto LABEL_105;
          }
          uint64_t v68 = "result && \"builder didn't return the right type\"";
          int v69 = 497;
          uint64_t v70 = "Builders.h";
          int32x4_t v71 = "create";
        }
        else
        {
          uint64_t v68 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
          int v69 = 662;
          uint64_t v70 = "Casting.h";
          int32x4_t v71 = "dyn_cast";
        }
        __assert_rtn(v71, v70, v69, v68);
      }
    }
    operator delete(v41);
    goto LABEL_99;
  }
  std::string __p = operator new(0x40uLL);
  long long v93 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v93) < 0) {
    operator delete(__p);
  }
  return 0;
}

void sub_180DA5F58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, char *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::MultiplyOp&,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  v24[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.multiply";
    v21[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(void *)a3 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *(void *)a3 - 16, *a4);
  unint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    char v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v15 = 662;
    char v16 = "Casting.h";
    uint64_t v17 = "dyn_cast";
    goto LABEL_10;
  }
  uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    char v14 = "result && \"builder didn't return the right type\"";
    int v15 = 497;
    char v16 = "Builders.h";
    uint64_t v17 = "create";
LABEL_10:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180DA6234(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DA624C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value &,mlir::mps::MultiplyOp &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v24[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.add";
    v21[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(void *)a4 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *a3, *(void *)a4 - 16);
  unint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    char v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v15 = 662;
    char v16 = "Casting.h";
    uint64_t v17 = "dyn_cast";
    goto LABEL_10;
  }
  uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::AddOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AddOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    char v14 = "result && \"builder didn't return the right type\"";
    int v15 = 497;
    char v16 = "Builders.h";
    uint64_t v17 = "create";
LABEL_10:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180DA640C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DA6424(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::MultiplyOp&,mlir::mps::AddOp &>(mlir::Float32Type **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v24[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.multiply";
    v21[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(void *)a3 + 36) || !*(_DWORD *)(*(void *)a4 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *(void *)a3 - 16, *(void *)a4 - 16);
  unint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    char v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v15 = 662;
    char v16 = "Casting.h";
    uint64_t v17 = "dyn_cast";
    goto LABEL_11;
  }
  uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    char v14 = "result && \"builder didn't return the right type\"";
    int v15 = 497;
    char v16 = "Builders.h";
    uint64_t v17 = "create";
LABEL_11:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180DA65F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DA6608(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::TanhOp,mlir::mps::MultiplyOp &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.tanh", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.tanh";
    v19[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  if (!*(_DWORD *)(*(void *)a3 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *(void *)a3 - 16);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    char v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_10;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::TanhOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TanhOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    char v14 = "Builders.h";
    int v15 = "create";
LABEL_10:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180DA67C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DA67D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value &,mlir::mps::TanhOp &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v24[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.add";
    v21[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(void *)a4 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *a3, *(void *)a4 - 16);
  unint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    char v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v15 = 662;
    uint64_t v16 = "Casting.h";
    uint64_t v17 = "dyn_cast";
    goto LABEL_10;
  }
  uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::AddOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AddOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    char v14 = "result && \"builder didn't return the right type\"";
    int v15 = 497;
    uint64_t v16 = "Builders.h";
    uint64_t v17 = "create";
LABEL_10:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180DA6998(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DA69B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::SigmoidOp,mlir::mps::MultiplyOp &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sigmoid", (const unsigned __int8 *)0xB, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.sigmoid";
    v19[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  if (!*(_DWORD *)(*(void *)a3 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *(void *)a3 - 16);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    char v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_10;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::SigmoidOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SigmoidOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    char v14 = "Builders.h";
    int v15 = "create";
LABEL_10:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180DA6B68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DA6B80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value &,mlir::mps::SigmoidOp &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v24[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.multiply";
    v21[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(void *)a4 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *a3, *(void *)a4 - 16);
  unint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    char v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v15 = 662;
    uint64_t v16 = "Casting.h";
    uint64_t v17 = "dyn_cast";
    goto LABEL_10;
  }
  uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    char v14 = "result && \"builder didn't return the right type\"";
    int v15 = 497;
    uint64_t v16 = "Builders.h";
    uint64_t v17 = "create";
LABEL_10:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180DA6D40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DA6D58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::TanhOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TanhOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x686E61742E73706DLL)
    {
      __int16 v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.tanh";
      v7[3] = 8;
      unint64_t v5 = "' failed due to the operation not being registered";
      __int16 v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::TanhOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SigmoidOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SigmoidOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x6D6769732E73706DLL && *(void *)((char *)AttrData + 3) == 0x64696F6D6769732ELL)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.sigmoid";
      v8[3] = 11;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SigmoidOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::InnerProductPattern::~InnerProductPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::InnerProductPattern::matchAndRewrite(_anonymous_namespace_::InnerProductPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v26 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "weights");
  OptionalArguint64_t Value = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "bias");
  uint64_t v25 = OptionalArgValue;
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    LOBYTE(__p) = 0;
    LOBYTE(v28) = 1;
    uint64_t v7 = mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value &,mlir::Value &,BOOL,BOOL>(a3 + 18, LocationForOp, &ArgValue, &v26, (unsigned __int8 *)&__p, (unsigned __int8 *)&v28);
    uint64_t v22 = v7;
    if (OptionalArgValue)
    {
      uint64_t v8 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::mps::MatMulOp &,mlir::Value &>(a3 + 18, LocationForOp, (uint64_t)&v22, &v25);
      (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
      if (!*(_DWORD *)(v8 + 36)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
      __int16 v9 = (long long *)__p;
      char v10 = (char *)operator new(8uLL);
      *(void *)char v10 = v8 - 16;
      int v28 = v9;
      unint64_t v11 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v9, (uint64_t)&std::piecewise_construct, &v28);
      std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v11 + 5, v10, v10 + 8, 1uLL);
      operator delete(v10);
      uint64_t v12 = (void **)__p;
      if (!__p) {
        return 1;
      }
      int v13 = (void **)v24;
      char v14 = __p;
      if ((void *)v24 == __p)
      {
LABEL_20:
        *(void *)&long long v24 = v12;
        operator delete(v14);
        return 1;
      }
      do
      {
        if (*((char *)v13 - 1) < 0) {
          operator delete(*(v13 - 3));
        }
        v13 -= 3;
      }
      while (v13 != v12);
    }
    else
    {
      uint64_t v16 = v7;
      (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
      if (!*(_DWORD *)(v16 + 36)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
      uint64_t v17 = (long long *)__p;
      uint64_t v18 = (char *)operator new(8uLL);
      *(void *)uint64_t v18 = v16 - 16;
      int v28 = v17;
      uint64_t v19 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v17, (uint64_t)&std::piecewise_construct, &v28);
      std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v19 + 5, v18, v18 + 8, 1uLL);
      operator delete(v18);
      uint64_t v12 = (void **)__p;
      if (!__p) {
        return 1;
      }
      __int16 v20 = (void **)v24;
      char v14 = __p;
      if ((void *)v24 == __p) {
        goto LABEL_20;
      }
      do
      {
        if (*((char *)v20 - 1) < 0) {
          operator delete(*(v20 - 3));
        }
        v20 -= 3;
      }
      while (v20 != v12);
    }
    char v14 = __p;
    goto LABEL_20;
  }
  std::string __p = operator new(0x40uLL);
  long long v24 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v15 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v24) < 0) {
    operator delete(__p);
  }
  return v15;
}

void sub_180DA7368(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  operator delete(v16);
  std::vector<std::string>::~vector[abi:ne180100](&__p);
  _Unwind_Resume(a1);
}

void anonymous namespace'::InstanceNormPattern::~InstanceNormPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::InstanceNormPattern::matchAndRewrite(_anonymous_namespace_::InstanceNormPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  __int16 v6 = a3 + 18;
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v117[0] = ArgValue;
  OptionalArguint64_t Value = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "beta");
  id v114 = 0;
  uint64_t v115 = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "gamma");
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
  if (!OptionalArgValue)
  {
    uint64_t v9 = mlir::Float32Type::get(*v6, v8);
    uint64_t Constant = 1;
    char v10 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&Constant, 1, v9, 0);
    uint64_t Constant = mlir::mps::getConstantAttr<float>(v10, 0.0);
    unint64_t v11 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)&Constant);
    if (!*((_DWORD *)v11 + 9)) {
      goto LABEL_110;
    }
    OptionalArguint64_t Value = (uint64_t)v11 - 16;
    if (!mlir::Type::isF32((mlir::Type *)&ElementTypeOrSelf))
    {
      uint64_t v12 = mlir::getElementTypeOrSelf(ArgValue);
      uint64_t Constant = mlir::TypeAttr::get(v12);
      int v13 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, &OptionalArgValue, &Constant);
      if (!*((_DWORD *)v13 + 9)) {
        goto LABEL_110;
      }
      OptionalArguint64_t Value = (uint64_t)v13 - 16;
    }
  }
  if (v115) {
    goto LABEL_11;
  }
  uint64_t v14 = mlir::Float32Type::get(*v6, v8);
  uint64_t Constant = 1;
  uint64_t v15 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&Constant, 1, v14, 0);
  uint64_t Constant = mlir::mps::getConstantAttr<float>(v15, 1.0);
  uint64_t v16 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)&Constant);
  if (!*((_DWORD *)v16 + 9)) {
    goto LABEL_110;
  }
  uint64_t v115 = (uint64_t)v16 - 16;
  if (mlir::Type::isF32((mlir::Type *)&ElementTypeOrSelf)) {
    goto LABEL_11;
  }
  uint64_t v17 = mlir::getElementTypeOrSelf(ArgValue);
  uint64_t Constant = mlir::TypeAttr::get(v17);
  uint64_t v18 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, &v115, &Constant);
  if (!*((_DWORD *)v18 + 9)) {
LABEL_110:
  }
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  uint64_t v115 = (uint64_t)v18 - 16;
LABEL_11:
  uint64_t v19 = operator new(0xCuLL);
  *(void *)uint64_t v19 = 0xFFFFFFFF00000001;
  v19[2] = 1;
  __int16 v20 = operator new(0x10uLL);
  uint64_t v97 = a3 + 18;
  *__int16 v20 = xmmword_18110B730;
  int v21 = (char *)(v20 + 1);
  uint64_t v99 = v20;
  uint64_t v98 = (char *)operator new(4uLL);
  *(_DWORD *)uint64_t v98 = 2;
  uint64_t v22 = (char *)operator new(8uLL);
  *(void *)uint64_t v22 = 0x300000002;
  size_t v23 = v22 + 8;
  std::string __p = v22;
  long long v24 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 160))(a2);
  v112[0] = 0;
  v112[1] = 0;
  uint64_t Constant = (uint64_t)v112;
  uint64_t v26 = v24 + 1;
  uint64_t v25 = *v24;
  if (*v24 == (const void **)(v24 + 1)) {
    goto LABEL_53;
  }
  uint64_t v94 = (char *)(v19 + 3);
  do
  {
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&Constant, (uint64_t *)v112, v25 + 4, (uint64_t)(v25 + 4));
    int v27 = (const void **)v25[1];
    if (v27)
    {
      do
      {
        int v28 = (const void ***)v27;
        int v27 = (const void **)*v27;
      }
      while (v27);
    }
    else
    {
      do
      {
        int v28 = (const void ***)v25[2];
        BOOL v29 = *v28 == v25;
        uint64_t v25 = (const void **)v28;
      }
      while (!v29);
    }
    uint64_t v25 = (const void **)v28;
  }
  while (v28 != v26);
  uint64_t v95 = LocationForOp;
  int v30 = v112[0];
  HIBYTE(v110) = 7;
  strcpy((char *)&__s2, "epsilon");
  if (!v112[0]) {
    goto LABEL_53;
  }
  uint64_t v96 = v19;
  unint64_t v31 = v112;
  do
  {
    uint64_t v32 = v30;
    uint64_t v33 = v31;
    BOOL v35 = v30 + 32;
    size_t v34 = (char *)*((void *)v30 + 4);
    unint64_t v36 = v32[55];
    int v37 = (char)v36;
    if ((v36 & 0x80u) != 0) {
      unint64_t v36 = *((void *)v32 + 5);
    }
    if (v37 >= 0) {
      uint64_t v38 = v35;
    }
    else {
      uint64_t v38 = v34;
    }
    if (v36 >= 7) {
      size_t v39 = 7;
    }
    else {
      size_t v39 = v36;
    }
    BOOL v40 = v36 < 7;
    int v41 = memcmp(v38, &__s2, v39);
    if (v41) {
      BOOL v40 = v41 < 0;
    }
    uint64_t v42 = (char **)(v32 + 8);
    if (v40)
    {
      unint64_t v31 = v33;
    }
    else
    {
      uint64_t v42 = (char **)v32;
      unint64_t v31 = (char **)v32;
    }
    int v30 = *v42;
  }
  while (v30);
  if (v31 == v112) {
    goto LABEL_53;
  }
  uint64_t v43 = (char *)(v33 + 4);
  if (v40) {
    long long v44 = v33;
  }
  else {
    long long v44 = v32;
  }
  if (!v40) {
    uint64_t v43 = v35;
  }
  unint64_t v45 = *((unsigned __int8 *)v31 + 55);
  int v46 = (char)v45;
  uint64_t v48 = (char *)v44[4];
  unint64_t v47 = v44[5];
  if ((v45 & 0x80u) != 0) {
    unint64_t v45 = v47;
  }
  if (v46 >= 0) {
    uint64_t v49 = v43;
  }
  else {
    uint64_t v49 = v48;
  }
  if (v45 >= 7) {
    size_t v50 = 7;
  }
  else {
    size_t v50 = v45;
  }
  BOOL v51 = v45 > 7;
  int v52 = memcmp(&__s2, v49, v50);
  BOOL v53 = v52 < 0;
  if (!v52) {
    BOOL v53 = v51;
  }
  uint64_t v19 = v96;
  if (v53)
  {
LABEL_53:
    uint64_t __s2 = (char *)operator new(0x30uLL);
    long long v110 = xmmword_181129E50;
    strcpy(__s2, "Could not find parameter with name 'epsilon'.");
    uint64_t v55 = v98;
    uint64_t v54 = v99;
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
LABEL_54:
    if (SHIBYTE(v110) < 0) {
      operator delete(__s2);
    }
    uint64_t v56 = 0;
    goto LABEL_57;
  }
  if (v40) {
    uint64_t v58 = v33;
  }
  else {
    uint64_t v58 = v32;
  }
  if (v58[8] - v58[7] != 16)
  {
    uint64_t v55 = v98;
    uint64_t v54 = v99;
    uint64_t __s2 = (char *)operator new(0x28uLL);
    long long v110 = xmmword_18112B060;
    strcpy(__s2, "Unexpected argument size for 'epsilon'");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
    goto LABEL_54;
  }
  HIBYTE(v110) = 7;
  strcpy((char *)&__s2, "epsilon");
  uint64_t v55 = v98;
  uint64_t v54 = v99;
  Parameteruint64_t Value = MIL::IROperation::GetParameterValue();
  uint64_t v60 = (*(uint64_t (**)(uint64_t))(*(void *)ParameterValue + 40))(ParameterValue);
  if (SHIBYTE(v110) < 0) {
    operator delete(__s2);
  }
  if (!v60)
  {
    uint64_t __s2 = (char *)operator new(0x38uLL);
    long long v110 = xmmword_181129E70;
    strcpy(__s2, "Failed to materialize constant: value is not a tensor.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t *)&__s2);
    goto LABEL_54;
  }
  uint64_t v61 = (*(uint64_t (**)(uint64_t))(*(void *)v60 + 32))(v60);
  int v62 = (*(uint64_t (**)(uint64_t))(*(void *)v61 + 88))(v61);
  if (v62 == 4)
  {
    HIBYTE(v110) = 7;
    strcpy((char *)&__s2, "epsilon");
    MIL::IROperation::GetParameterValue();
    LOWORD(v108) = MIL::IRValue::GetScalar<MIL::Fp16>();
    MIL::Fp16::GetFloat((MIL::Fp16 *)&v108);
    F32FloatAttr = mlir::Builder::getF32FloatAttr(v97, v67, v66);
  }
  else
  {
    if (v62 != 5)
    {
      uint64_t __s2 = (char *)operator new(0x20uLL);
      long long v110 = xmmword_181129E90;
      strcpy(__s2, "Unexpected MIL element type.");
      MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t *)&__s2);
      goto LABEL_54;
    }
    HIBYTE(v110) = 7;
    strcpy((char *)&__s2, "epsilon");
    MIL::IROperation::GetParameterValue();
    MIL::IRValue::GetScalar<float>();
    F32FloatAttr = mlir::Builder::getF32FloatAttr(v97, v64, v63);
  }
  id v114 = F32FloatAttr;
  if (SHIBYTE(v110) < 0) {
    operator delete(__s2);
  }
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) != 1)
  {
    uint64_t __s2 = (char *)operator new(0x40uLL);
    long long v110 = xmmword_181129DA0;
    strcpy(__s2, "The number of outputs does not match the number of results.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
    goto LABEL_54;
  }
  HIBYTE(v110) = 1;
  LOWORD(__s2) = 120;
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  if (SHIBYTE(v110) < 0) {
    operator delete(__s2);
  }
  int v69 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(ParameterType);
  uint64_t v108 = 0;
  uint64_t v108 = MIL::IRTensorValueType::Rank(v69);
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)v97, 0x20u, 1);
  int32x4_t v71 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&v108, 1, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v71)) {
    goto LABEL_111;
  }
  if (v71)
  {
    uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v71);
    if (!InterfaceFor)
    {
      uint64_t v73 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v74 = 98;
      uint64_t v75 = "InterfaceSupport.h";
      uint64_t v76 = "Interface";
      goto LABEL_112;
    }
  }
  else
  {
    uint64_t InterfaceFor = 0;
  }
  if (v108 == 3) {
    uint64_t v77 = (char *)v96;
  }
  else {
    uint64_t v77 = (char *)v99;
  }
  uint64_t v78 = v94;
  if (v108 != 3) {
    uint64_t v78 = v21;
  }
  __int16 v79 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v71, InterfaceFor, v77, v78 - v77, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v79) & 1) == 0)
  {
LABEL_111:
    uint64_t v73 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v74 = 566;
    uint64_t v75 = "Casting.h";
    uint64_t v76 = "cast";
LABEL_112:
    __assert_rtn(v76, v75, v74, v73);
  }
  uint64_t __s2 = (char *)v79;
  unsigned int v107 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v97, v95, (uint64_t **)&__s2);
  uint64_t __s2 = (char *)(v108 - 2);
  uint64_t v80 = mlir::Builder::getIntegerType((mlir::Builder *)v97, 0x20u, 1);
  uint64_t v81 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&__s2, 1, v80, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v81)) {
    goto LABEL_113;
  }
  if (v81)
  {
    uint64_t v82 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v81);
    if (!v82)
    {
      uint64_t v83 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v84 = 98;
      __int16 v85 = "InterfaceSupport.h";
      __int16 v86 = "Interface";
      goto LABEL_114;
    }
  }
  else
  {
    uint64_t v82 = 0;
  }
  if (v108 == 3) {
    __int16 v87 = v98;
  }
  else {
    __int16 v87 = __p;
  }
  uint64_t v88 = v98 + 4;
  if (v108 != 3) {
    uint64_t v88 = v23;
  }
  uint64_t v89 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v81, v82, v87, v88 - v87, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v89) & 1) == 0)
  {
LABEL_113:
    uint64_t v83 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v84 = 566;
    __int16 v85 = "Casting.h";
    __int16 v86 = "cast";
LABEL_114:
    __assert_rtn(v86, v85, v84, v83);
  }
  uint64_t __s2 = (char *)v89;
  int v106 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v97, v95, (uint64_t **)&__s2);
  unsigned __int8 v105 = 1;
  uint64_t __s2 = (char *)mlir::OpBuilder::create<mlir::mps::ReductionMeanOp,mlir::Value &,mlir::mps::ConstantOp &,BOOL>(v97, v95, v117, (uint64_t)&v106, &v105);
  unsigned __int8 v103 = 1;
  uint64_t v104 = mlir::OpBuilder::create<mlir::mps::ReductionVarianceOp,mlir::Value &,mlir::mps::ConstantOp &,BOOL>(v97, v95, v117, (uint64_t)&v106, &v103);
  int v102 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>(v97, v95, &v115, &v107);
  id v101 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>(v97, v95, &OptionalArgValue, &v107);
  uint64_t v90 = mlir::OpBuilder::create<mlir::mps::NormalizationOp,mlir::Value &,mlir::mps::ReductionMeanOp,mlir::mps::ReductionVarianceOp,mlir::mps::ReshapeOp,mlir::mps::ReshapeOp,mlir::FloatAttr &>((mlir::OpBuilder *)v97, v95, v117, (uint64_t)&__s2, (uint64_t)&v104, (uint64_t)&v102, (uint64_t)&v101, (uint64_t *)&v114);
  (*(void (**)(char **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__s2, a2);
  if (!*(_DWORD *)(v90 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  MILToMLIRRewriter::setValue((uint64_t)a3, (long long *)__s2, v90 - 16);
  uint64_t v91 = __s2;
  if (__s2)
  {
    int v92 = (char *)v110;
    long long v93 = (uint64_t *)__s2;
    if ((char *)v110 != __s2)
    {
      do
      {
        if (*(v92 - 1) < 0) {
          operator delete(*((void **)v92 - 3));
        }
        v92 -= 24;
      }
      while (v92 != v91);
      long long v93 = (uint64_t *)__s2;
    }
    *(void *)&long long v110 = v91;
    operator delete(v93);
  }
  uint64_t v56 = 1;
LABEL_57:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&Constant, v112[0]);
  operator delete(__p);
  operator delete(v55);
  operator delete(v54);
  operator delete(v19);
  return v56;
}

void sub_180DA7F88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, void *a14, void *a15, void *__p, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,char a31,char *a32)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::NormalizationOp,mlir::Value &,mlir::mps::ReductionMeanOp,mlir::mps::ReductionVarianceOp,mlir::mps::ReshapeOp,mlir::mps::ReshapeOp,mlir::FloatAttr &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  v32[38] = *MEMORY[0x1E4F143B8];
  uint64_t v26 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v26);
  uint64_t v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.normalization", (const unsigned __int8 *)0x11, Context);
  if (!v18)
  {
    __int16 v30 = 1283;
    v29[2] = (uint64_t)"mps.normalization";
    v29[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v28 = 259;
    llvm::operator+(v29, (uint64_t *)&v27, (uint64_t)v31);
    llvm::report_fatal_error((llvm::Twine *)v31, 1);
  }
  mlir::OperationState::OperationState(v32, a2, v17);
  if (!*(_DWORD *)(*(void *)a4 + 36)
    || !*(_DWORD *)(*(void *)a5 + 36)
    || !*(_DWORD *)(*(void *)a6 + 36)
    || !*(_DWORD *)(*(void *)a7 + 36))
  {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::NormalizationOp::build((uint64_t)a1, (uint64_t)v32, *a3, *(void *)a4 - 16, *(void *)a5 - 16, *(void *)a6 - 16, *(void *)a7 - 16, *a8);
  uint64_t v19 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v32);
  if (!v19)
  {
    uint64_t v22 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v23 = 662;
    long long v24 = "Casting.h";
    uint64_t v25 = "dyn_cast";
    goto LABEL_13;
  }
  uint64_t v20 = llvm::DefaultDoCastIfPossible<mlir::mps::NormalizationOp,mlir::Operation *,llvm::CastInfo<mlir::mps::NormalizationOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v19);
  if (!v20)
  {
    uint64_t v22 = "result && \"builder didn't return the right type\"";
    int v23 = 497;
    long long v24 = "Builders.h";
    uint64_t v25 = "create";
LABEL_13:
    __assert_rtn(v25, v24, v23, v22);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v32);
  return v20;
}

void sub_180DA82AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DA82C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::ReductionMeanOp,mlir::Value &,mlir::mps::ConstantOp &,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t a4, unsigned __int8 *a5)
{
  v26[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_mean", (const unsigned __int8 *)0x12, Context);
  if (!v12)
  {
    __int16 v24 = 1283;
    v23[2] = (uint64_t)"mps.reduction_mean";
    v23[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v11);
  if (!*(_DWORD *)(*(void *)a4 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ReductionMeanOp::build(a1, (uint64_t)v26, *a3, *(void *)a4 - 16, *a5);
  int v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v26);
  if (!v13)
  {
    uint64_t v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v17 = 662;
    char v18 = "Casting.h";
    uint64_t v19 = "dyn_cast";
    goto LABEL_10;
  }
  uint64_t v14 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionMeanOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionMeanOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    uint64_t v16 = "result && \"builder didn't return the right type\"";
    int v17 = 497;
    char v18 = "Builders.h";
    uint64_t v19 = "create";
LABEL_10:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v14;
}

void sub_180DA8490(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DA84A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::ReductionVarianceOp,mlir::Value &,mlir::mps::ConstantOp &,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t a4, unsigned __int8 *a5)
{
  v26[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_variance", (const unsigned __int8 *)0x16, Context);
  if (!v12)
  {
    __int16 v24 = 1283;
    v23[2] = (uint64_t)"mps.reduction_variance";
    v23[3] = 22;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v11);
  if (!*(_DWORD *)(*(void *)a4 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ReductionVarianceOp::build(a1, (uint64_t)v26, *a3, *(void *)a4 - 16, *a5);
  int v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v26);
  if (!v13)
  {
    uint64_t v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v17 = 662;
    char v18 = "Casting.h";
    uint64_t v19 = "dyn_cast";
    goto LABEL_10;
  }
  uint64_t v14 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionVarianceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionVarianceOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    uint64_t v16 = "result && \"builder didn't return the right type\"";
    int v17 = 497;
    char v18 = "Builders.h";
    uint64_t v19 = "create";
LABEL_10:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v14;
}

void sub_180DA8678(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DA8690(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void anonymous namespace'::LayerNormPattern::~LayerNormPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::LayerNormPattern::matchAndRewrite(_anonymous_namespace_::LayerNormPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  __int16 v6 = a3 + 18;
  v130[0] = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "axes");
  OptionalArguint64_t Value = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "beta");
  long long v126 = 0;
  uint64_t v127 = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "gamma");
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v130[0]);
  if (!OptionalArgValue)
  {
    uint64_t v8 = mlir::Float32Type::get(*v6, v7);
    uint64_t Constant = 1;
    uint64_t v9 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&Constant, 1, v8, 0);
    uint64_t Constant = mlir::mps::getConstantAttr<float>(v9, 0.0);
    char v10 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)&Constant);
    if (!*((_DWORD *)v10 + 9)) {
      goto LABEL_141;
    }
    OptionalArguint64_t Value = (uint64_t)v10 - 16;
    if (!mlir::Type::isF32((mlir::Type *)&ElementTypeOrSelf))
    {
      uint64_t v11 = mlir::getElementTypeOrSelf(v130[0]);
      uint64_t Constant = mlir::TypeAttr::get(v11);
      char v12 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, &OptionalArgValue, &Constant);
      if (!*((_DWORD *)v12 + 9)) {
        goto LABEL_141;
      }
      OptionalArguint64_t Value = (uint64_t)v12 - 16;
    }
  }
  if (v127) {
    goto LABEL_11;
  }
  uint64_t v13 = mlir::Float32Type::get(*v6, v7);
  uint64_t Constant = 1;
  uint64_t v14 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&Constant, 1, v13, 0);
  uint64_t Constant = mlir::mps::getConstantAttr<float>(v14, 1.0);
  uint64_t v15 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t **)&Constant);
  if (!*((_DWORD *)v15 + 9)) {
    goto LABEL_141;
  }
  uint64_t v127 = (uint64_t)v15 - 16;
  if (mlir::Type::isF32((mlir::Type *)&ElementTypeOrSelf)) {
    goto LABEL_11;
  }
  uint64_t v16 = mlir::getElementTypeOrSelf(v130[0]);
  uint64_t Constant = mlir::TypeAttr::get(v16);
  int v17 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, &v127, &Constant);
  if (!*((_DWORD *)v17 + 9)) {
LABEL_141:
  }
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  uint64_t v127 = (uint64_t)v17 - 16;
LABEL_11:
  char v18 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 160))(a2);
  v124[0] = 0;
  v124[1] = 0;
  uint64_t Constant = (uint64_t)v124;
  uint64_t v20 = v18 + 1;
  uint64_t v19 = *v18;
  if (*v18 == (const void **)(v18 + 1)) {
    goto LABEL_53;
  }
  do
  {
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&Constant, (uint64_t *)v124, v19 + 4, (uint64_t)(v19 + 4));
    int v21 = (const void **)v19[1];
    if (v21)
    {
      do
      {
        __int16 v22 = (const void ***)v21;
        int v21 = (const void **)*v21;
      }
      while (v21);
    }
    else
    {
      do
      {
        __int16 v22 = (const void ***)v19[2];
        BOOL v23 = *v22 == v19;
        uint64_t v19 = (const void **)v22;
      }
      while (!v23);
    }
    uint64_t v19 = (const void **)v22;
  }
  while (v22 != v20);
  uint64_t v107 = LocationForOp;
  __int16 v24 = v124[0];
  HIBYTE(v122) = 7;
  strcpy((char *)&__s2, "epsilon");
  if (!v124[0]) {
    goto LABEL_53;
  }
  uint64_t v25 = v124;
  do
  {
    uint64_t v26 = v24;
    int v27 = v25;
    BOOL v29 = v24 + 32;
    __int16 v28 = (char *)*((void *)v24 + 4);
    unint64_t v30 = v26[55];
    int v31 = (char)v30;
    if ((v30 & 0x80u) != 0) {
      unint64_t v30 = *((void *)v26 + 5);
    }
    if (v31 >= 0) {
      uint64_t v32 = v29;
    }
    else {
      uint64_t v32 = v28;
    }
    if (v30 >= 7) {
      size_t v33 = 7;
    }
    else {
      size_t v33 = v30;
    }
    BOOL v34 = v30 < 7;
    int v35 = memcmp(v32, &__s2, v33);
    if (v35) {
      BOOL v34 = v35 < 0;
    }
    unint64_t v36 = (char **)(v26 + 8);
    if (v34)
    {
      uint64_t v25 = v27;
    }
    else
    {
      unint64_t v36 = (char **)v26;
      uint64_t v25 = (char **)v26;
    }
    __int16 v24 = *v36;
  }
  while (v24);
  if (v25 == v124) {
    goto LABEL_53;
  }
  int v37 = (char *)(v27 + 4);
  if (v34) {
    uint64_t v38 = v27;
  }
  else {
    uint64_t v38 = v26;
  }
  if (!v34) {
    int v37 = v29;
  }
  unint64_t v39 = *((unsigned __int8 *)v25 + 55);
  int v40 = (char)v39;
  uint64_t v42 = (char *)v38[4];
  unint64_t v41 = v38[5];
  if ((v39 & 0x80u) != 0) {
    unint64_t v39 = v41;
  }
  if (v40 >= 0) {
    uint64_t v43 = v37;
  }
  else {
    uint64_t v43 = v42;
  }
  if (v39 >= 7) {
    size_t v44 = 7;
  }
  else {
    size_t v44 = v39;
  }
  BOOL v45 = v39 > 7;
  int v46 = memcmp(&__s2, v43, v44);
  BOOL v47 = v46 < 0;
  if (!v46) {
    BOOL v47 = v45;
  }
  if (v47)
  {
LABEL_53:
    uint64_t __s2 = (char *)operator new(0x30uLL);
    long long v122 = xmmword_181129E50;
    strcpy(__s2, "Could not find parameter with name 'epsilon'.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
LABEL_54:
    if (SHIBYTE(v122) < 0) {
      operator delete(__s2);
    }
    uint64_t v48 = 0;
    goto LABEL_57;
  }
  if (v34) {
    size_t v50 = v27;
  }
  else {
    size_t v50 = v26;
  }
  if (v50[8] - v50[7] != 16)
  {
    uint64_t __s2 = (char *)operator new(0x28uLL);
    long long v122 = xmmword_18112B060;
    strcpy(__s2, "Unexpected argument size for 'epsilon'");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
    goto LABEL_54;
  }
  HIBYTE(v122) = 7;
  strcpy((char *)&__s2, "epsilon");
  Parameteruint64_t Value = MIL::IROperation::GetParameterValue();
  uint64_t v52 = (*(uint64_t (**)(uint64_t))(*(void *)ParameterValue + 40))(ParameterValue);
  if (SHIBYTE(v122) < 0) {
    operator delete(__s2);
  }
  uint64_t v53 = v107;
  if (!v52)
  {
    uint64_t __s2 = (char *)operator new(0x38uLL);
    long long v122 = xmmword_181129E70;
    strcpy(__s2, "Failed to materialize constant: value is not a tensor.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t *)&__s2);
    goto LABEL_54;
  }
  uint64_t v54 = (*(uint64_t (**)(uint64_t))(*(void *)v52 + 32))(v52);
  int v55 = (*(uint64_t (**)(uint64_t))(*(void *)v54 + 88))(v54);
  if (v55 == 4)
  {
    HIBYTE(v122) = 7;
    strcpy((char *)&__s2, "epsilon");
    MIL::IROperation::GetParameterValue();
    LOWORD(v117) = MIL::IRValue::GetScalar<MIL::Fp16>();
    MIL::Fp16::GetFloat((MIL::Fp16 *)&v117);
    F32FloatAttr = mlir::Builder::getF32FloatAttr(a3 + 18, v60, v59);
  }
  else
  {
    if (v55 != 5)
    {
      uint64_t __s2 = (char *)operator new(0x20uLL);
      long long v122 = xmmword_181129E90;
      strcpy(__s2, "Unexpected MIL element type.");
      MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t *)&__s2);
      goto LABEL_54;
    }
    HIBYTE(v122) = 7;
    strcpy((char *)&__s2, "epsilon");
    MIL::IROperation::GetParameterValue();
    MIL::IRValue::GetScalar<float>();
    F32FloatAttr = mlir::Builder::getF32FloatAttr(a3 + 18, v57, v56);
  }
  long long v126 = F32FloatAttr;
  if (SHIBYTE(v122) < 0) {
    operator delete(__s2);
  }
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) != 1)
  {
    uint64_t __s2 = (char *)operator new(0x40uLL);
    long long v122 = xmmword_181129DA0;
    strcpy(__s2, "The number of outputs does not match the number of results.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
    goto LABEL_54;
  }
  HIBYTE(v122) = 1;
  LOWORD(__s2) = 120;
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  if (SHIBYTE(v122) < 0) {
    operator delete(__s2);
  }
  int v62 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(ParameterType);
  unint64_t v120 = 0;
  unint64_t v120 = MIL::IRTensorValueType::Rank(v62);
  getMLIRShape(v62, (uint64_t)&__s2);
  unint64_t v63 = v120;
  double v118 = 0;
  uint64_t v119 = 0;
  uint64_t v117 = 0;
  if (v120)
  {
    if (v120 >> 62) {
      std::vector<int>::__throw_length_error[abi:ne180100]();
    }
    float v64 = (char *)operator new(4 * v120);
    std::__fs::filesystem::path v65 = &v64[4 * v63];
    uint64_t v117 = v64;
    uint64_t v119 = v65;
    memset_pattern16(v64, &xmmword_18112A9B0, 4 * v63);
    double v118 = v65;
  }
  else
  {
    std::__fs::filesystem::path v65 = 0;
    float v64 = 0;
  }
  HIBYTE(v116) = 4;
  strcpy((char *)&__p, "axes");
  uint64_t v66 = MIL::IROperation::GetParameterValue();
  (*(void (**)(uint64_t))(*(void *)v66 + 40))(v66);
  uint64_t Data = (int *)MIL::IRTensorValue::GetDataView<int>();
  if (v68)
  {
    int v69 = __s2;
    int v70 = v120;
    do
    {
      int v71 = *Data++;
      *(_DWORD *)&v64[4 * (v70 & (v71 >> 31)) + 4 * v71] = *(void *)&v69[8 * (v70 & (v71 >> 31)) + 8 * v71];
      --v68;
    }
    while (v68);
  }
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 18), 0x20u, 1);
  uint64_t v73 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&v120, 1, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v73))
  {
    uint64_t v75 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v76 = 566;
    uint64_t v77 = "Casting.h";
    uint64_t v78 = "cast";
LABEL_143:
    __assert_rtn(v78, v77, v76, v75);
  }
  if (v73)
  {
    uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v73);
    if (!InterfaceFor)
    {
      uint64_t v75 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v76 = 98;
      uint64_t v77 = "InterfaceSupport.h";
      uint64_t v78 = "Interface";
      goto LABEL_143;
    }
  }
  else
  {
    uint64_t InterfaceFor = 0;
  }
  __int16 v79 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v73, InterfaceFor, v64, v65 - v64, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v79) & 1) == 0) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  std::string __p = v79;
  uint64_t v80 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), v107, (uint64_t **)&__p);
  uint64_t v112 = v127;
  uint64_t v113 = v80;
  uint64_t v111 = OptionalArgValue;
  HIBYTE(v116) = 5;
  strcpy((char *)&__p, "gamma");
  uint64_t v81 = MIL::IROperation::TryGetParameterValue();
  if (SHIBYTE(v116) < 0) {
    operator delete(__p);
  }
  if (v81)
  {
    uint64_t v82 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>(a3 + 18, v107, &v127, &v113);
    if (!*((_DWORD *)v82 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    goto LABEL_109;
  }
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v73))
  {
    int v84 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v85 = 566;
    __int16 v86 = "Casting.h";
    __int16 v87 = "cast";
LABEL_147:
    __assert_rtn(v87, v86, v85, v84);
  }
  if (v73)
  {
    uint64_t v83 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v73);
    if (!v83)
    {
      int v84 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v85 = 98;
      __int16 v86 = "InterfaceSupport.h";
      __int16 v87 = "Interface";
      goto LABEL_147;
    }
  }
  else
  {
    uint64_t v83 = 0;
  }
  unint64_t v88 = v120;
  uint64_t v115 = 0;
  uint64_t v116 = 0;
  std::string __p = 0;
  if (v120)
  {
    if (v120 >> 62) {
      std::vector<int>::__throw_length_error[abi:ne180100]();
    }
    size_t v89 = 4 * v120;
    uint64_t v90 = (char *)operator new(4 * v120);
    unint64_t v88 = (unint64_t)&v90[4 * v88];
    memset_pattern16(v90, &xmmword_18112A9B0, v89);
    uint64_t v53 = v107;
  }
  else
  {
    uint64_t v90 = 0;
  }
  uint64_t v91 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v73, v83, v90, v88 - (void)v90, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v91) & 1) == 0) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  uint64_t v109 = v91;
  uint64_t v110 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), v53, &v109);
  if (v90) {
    operator delete(v90);
  }
  uint64_t v82 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>(a3 + 18, v53, &v127, &v110);
  if (!*((_DWORD *)v82 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
LABEL_109:
  uint64_t v112 = (uint64_t)v82 - 16;
  HIBYTE(v116) = 4;
  strcpy((char *)&__p, "beta");
  uint64_t v92 = MIL::IROperation::TryGetParameterValue();
  if (SHIBYTE(v116) < 0) {
    operator delete(__p);
  }
  if (!v92)
  {
    if (mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v73))
    {
      if (v73)
      {
        uint64_t v94 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v73);
        if (!v94)
        {
          uint64_t v95 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
          int v96 = 98;
          uint64_t v97 = "InterfaceSupport.h";
          uint64_t v98 = "Interface";
          goto LABEL_150;
        }
      }
      else
      {
        uint64_t v94 = 0;
      }
      unint64_t v99 = v120;
      uint64_t v115 = 0;
      uint64_t v116 = 0;
      std::string __p = 0;
      if (v120)
      {
        if (v120 >> 62) {
          std::vector<int>::__throw_length_error[abi:ne180100]();
        }
        size_t v100 = 4 * v120;
        id v101 = (char *)operator new(4 * v120);
        unint64_t v99 = (unint64_t)&v101[4 * v99];
        memset_pattern16(v101, &xmmword_18112A9B0, v100);
        uint64_t v53 = v107;
      }
      else
      {
        id v101 = 0;
      }
      int v102 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v73, v94, v101, v99 - (void)v101, 4, 1, 1);
      if ((mlir::DenseIntElementsAttr::classof((uint64_t)v102) & 1) == 0) {
        __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
      }
      uint64_t v109 = v102;
      uint64_t v110 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), v53, &v109);
      if (v101) {
        operator delete(v101);
      }
      long long v93 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>(a3 + 18, v53, &OptionalArgValue, &v110);
      if (!*((_DWORD *)v93 + 9)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
      goto LABEL_127;
    }
    uint64_t v95 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v96 = 566;
    uint64_t v97 = "Casting.h";
    uint64_t v98 = "cast";
LABEL_150:
    __assert_rtn(v98, v97, v96, v95);
  }
  long long v93 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>(a3 + 18, v53, &OptionalArgValue, &v113);
  if (!*((_DWORD *)v93 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
LABEL_127:
  uint64_t v111 = (uint64_t)v93 - 16;
  LOBYTE(v109) = 1;
  std::string __p = mlir::OpBuilder::create<mlir::mps::ReductionMeanOp,mlir::Value &,mlir::Value &,BOOL>(a3 + 18, v53, v130, &ArgValue, (unsigned __int8 *)&v109);
  unsigned __int8 v108 = 1;
  uint64_t v110 = mlir::OpBuilder::create<mlir::mps::ReductionVarianceOp,mlir::Value &,mlir::Value &,BOOL>(a3 + 18, v53, v130, &ArgValue, &v108);
  uint64_t v103 = mlir::OpBuilder::create<mlir::mps::NormalizationOp,mlir::Value &,mlir::mps::ReductionMeanOp,mlir::mps::ReductionVarianceOp,mlir::Value &,mlir::Value &,mlir::FloatAttr &>((mlir::OpBuilder *)(a3 + 18), v53, v130, (uint64_t)&__p, (uint64_t)&v110, &v112, &v111, (uint64_t *)&v126);
  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
  if (!*(_DWORD *)(v103 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  MILToMLIRRewriter::setValue((uint64_t)a3, (long long *)__p, v103 - 16);
  uint64_t v104 = (void **)__p;
  if (__p)
  {
    unsigned __int8 v105 = v115;
    int v106 = __p;
    if (v115 != __p)
    {
      do
      {
        if (*((char *)v105 - 1) < 0) {
          operator delete(*(v105 - 3));
        }
        v105 -= 3;
      }
      while (v105 != v104);
      int v106 = __p;
    }
    uint64_t v115 = v104;
    operator delete(v106);
  }
  if (v64) {
    operator delete(v64);
  }
  if (__s2)
  {
    *(void *)&long long v122 = __s2;
    operator delete(__s2);
  }
  uint64_t v48 = 1;
LABEL_57:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&Constant, v124[0]);
  return v48;
}

void sub_180DA95E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,char a33)
{
  if (__p) {
    operator delete(__p);
  }
  if (v33) {
    operator delete(v33);
  }
  if (a27)
  {
    operator delete(a27);
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a33, *(char **)(v34 + 8));
    _Unwind_Resume(a1);
  }
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a33, *(char **)(v34 + 8));
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::NormalizationOp,mlir::Value &,mlir::mps::ReductionMeanOp,mlir::mps::ReductionVarianceOp,mlir::Value &,mlir::Value &,mlir::FloatAttr &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t *a7, uint64_t *a8)
{
  v32[38] = *MEMORY[0x1E4F143B8];
  uint64_t v26 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v26);
  uint64_t v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.normalization", (const unsigned __int8 *)0x11, Context);
  if (!v18)
  {
    __int16 v30 = 1283;
    v29[2] = (uint64_t)"mps.normalization";
    v29[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v28 = 259;
    llvm::operator+(v29, (uint64_t *)&v27, (uint64_t)v31);
    llvm::report_fatal_error((llvm::Twine *)v31, 1);
  }
  mlir::OperationState::OperationState(v32, a2, v17);
  if (!*(_DWORD *)(*(void *)a4 + 36) || !*(_DWORD *)(*(void *)a5 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::NormalizationOp::build((uint64_t)a1, (uint64_t)v32, *a3, *(void *)a4 - 16, *(void *)a5 - 16, *a6, *a7, *a8);
  uint64_t v19 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v32);
  if (!v19)
  {
    __int16 v22 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v23 = 662;
    __int16 v24 = "Casting.h";
    uint64_t v25 = "dyn_cast";
    goto LABEL_11;
  }
  uint64_t v20 = llvm::DefaultDoCastIfPossible<mlir::mps::NormalizationOp,mlir::Operation *,llvm::CastInfo<mlir::mps::NormalizationOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v19);
  if (!v20)
  {
    __int16 v22 = "result && \"builder didn't return the right type\"";
    int v23 = 497;
    __int16 v24 = "Builders.h";
    uint64_t v25 = "create";
LABEL_11:
    __assert_rtn(v25, v24, v23, v22);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v32);
  return v20;
}

void sub_180DA9940(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DA9954(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::ReductionVarianceOp,mlir::Value &,mlir::Value &,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned __int8 *a5)
{
  v26[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_variance", (const unsigned __int8 *)0x16, Context);
  if (!v12)
  {
    __int16 v24 = 1283;
    v23[2] = (uint64_t)"mps.reduction_variance";
    v23[3] = 22;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v11);
  mlir::mps::ReductionVarianceOp::build(a1, (uint64_t)v26, *a3, *a4, *a5);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v26);
  if (!v13)
  {
    uint64_t v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v17 = 662;
    char v18 = "Casting.h";
    uint64_t v19 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v14 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionVarianceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionVarianceOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    uint64_t v16 = "result && \"builder didn't return the right type\"";
    int v17 = 497;
    char v18 = "Builders.h";
    uint64_t v19 = "create";
LABEL_8:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v14;
}

void sub_180DA9AF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DA9B0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void anonymous namespace'::LinearPattern::~LinearPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::LinearPattern::matchAndRewrite(_anonymous_namespace_::LinearPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v47 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "weight");
  OptionalArguint64_t Value = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "bias");
  uint64_t v46 = OptionalArgValue;
  HIBYTE(v45) = 1;
  LOWORD(__p) = 120;
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  uint64_t v8 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(ParameterType);
  uint64_t v9 = MIL::IRTensorValueType::Rank(v8);
  if (v9 == 1)
  {
    char v10 = operator new(4uLL);
    *char v10 = 0;
    std::string __p = (void *)1;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 18), 0x20u, 1);
    char v12 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&__p, 1, IntegerType, 0);
    if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v12)) {
      goto LABEL_38;
    }
    if (v12)
    {
      uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v12);
      if (!InterfaceFor)
      {
        uint64_t v14 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
        int v15 = 98;
        uint64_t v16 = "InterfaceSupport.h";
        int v17 = "Interface";
        goto LABEL_39;
      }
    }
    else
    {
      uint64_t InterfaceFor = 0;
    }
    char v18 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v12, InterfaceFor, v10, 4, 4, 1, 1);
    if ((mlir::DenseIntElementsAttr::classof((uint64_t)v18) & 1) == 0)
    {
LABEL_38:
      uint64_t v14 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      int v15 = 566;
      uint64_t v16 = "Casting.h";
      int v17 = "cast";
LABEL_39:
      __assert_rtn(v17, v16, v15, v14);
    }
    uint64_t v49 = v18;
    std::string __p = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &v49);
    uint64_t v19 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue, &__p);
    if (!*((_DWORD *)v19 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    Arguint64_t Value = (uint64_t)v19 - 16;
    operator delete(v10);
  }
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    LOBYTE(__p) = 0;
    LOBYTE(v49) = 1;
    uint64_t v20 = mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value &,mlir::Value &,BOOL,BOOL>(a3 + 18, LocationForOp, &ArgValue, &v47, (unsigned __int8 *)&__p, (unsigned __int8 *)&v49);
    if (*(_DWORD *)(v20 + 36))
    {
      uint64_t v43 = v20 - 16;
      if (v9 == 1)
      {
        int v21 = operator new(4uLL);
        *int v21 = -2;
        std::string __p = (void *)1;
        uint64_t v22 = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 18), 0x20u, 1);
        int v23 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&__p, 1, v22, 0);
        if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v23)) {
          goto LABEL_41;
        }
        if (v23)
        {
          uint64_t v24 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v23);
          if (!v24)
          {
            uint64_t v25 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            int v26 = 98;
            int v27 = "InterfaceSupport.h";
            __int16 v28 = "Interface";
            goto LABEL_42;
          }
        }
        else
        {
          uint64_t v24 = 0;
        }
        __int16 v30 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v23, v24, v21, 4, 4, 1, 1);
        if ((mlir::DenseIntElementsAttr::classof((uint64_t)v30) & 1) == 0)
        {
LABEL_41:
          uint64_t v25 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
          int v26 = 566;
          int v27 = "Casting.h";
          __int16 v28 = "cast";
LABEL_42:
          __assert_rtn(v28, v27, v26, v25);
        }
        uint64_t v49 = v30;
        std::string __p = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &v49);
        int v31 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &v43, &__p);
        if (!*((_DWORD *)v31 + 9)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        uint64_t v43 = (uint64_t)v31 - 16;
        operator delete(v21);
      }
      if (!OptionalArgValue) {
        goto LABEL_27;
      }
      uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v43);
      std::string __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
      size_t v33 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, &v46, (uint64_t *)&__p);
      if (*((_DWORD *)v33 + 9))
      {
        uint64_t v46 = (uint64_t)v33 - 16;
        uint64_t v34 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(a3 + 18, LocationForOp, &v43, &v46);
        if (*((_DWORD *)v34 + 9))
        {
          uint64_t v43 = (uint64_t)v34 - 16;
LABEL_27:
          (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
          uint64_t v36 = v43;
          int v35 = (uint64_t *)__p;
          int v37 = (char *)operator new(8uLL);
          *(void *)int v37 = v36;
          uint64_t v49 = v35;
          uint64_t v38 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v35, (uint64_t)&std::piecewise_construct, (long long **)&v49);
          std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v38 + 5, v37, v37 + 8, 1uLL);
          operator delete(v37);
          unint64_t v39 = (void **)__p;
          if (__p)
          {
            int v40 = (void **)v45;
            unint64_t v41 = __p;
            if ((void *)v45 != __p)
            {
              do
              {
                if (*((char *)v40 - 1) < 0) {
                  operator delete(*(v40 - 3));
                }
                v40 -= 3;
              }
              while (v40 != v39);
              unint64_t v41 = __p;
            }
            *(void *)&long long v45 = v39;
            operator delete(v41);
          }
          return 1;
        }
      }
    }
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  std::string __p = operator new(0x40uLL);
  long long v45 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v29 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v45) < 0) {
    operator delete(__p);
  }
  return v29;
}

void sub_180DAA168(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

void sub_180DAA1A4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180DAA1D4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180DAA1E8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180DAA1FC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180DAA210(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void anonymous namespace'::LocalResponseNormPattern::~LocalResponseNormPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::LocalResponseNormPattern::matchAndRewrite(_anonymous_namespace_::LocalResponseNormPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  v174[3] = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v157 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "size");
  uint64_t v148 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "alpha");
  uint64_t v156 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "beta");
  uint64_t v147 = a3;
  uint64_t v155 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "k");
  BYTE7(v169) = 1;
  LOWORD(__p) = 120;
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  uint64_t v7 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(ParameterType);
  uint64_t v150 = MIL::IRTensorValueType::Rank(v7);
  uint64_t v8 = (mlir::Builder *)(v147 + 18);
  uint64_t v154 = 0;
  if (v150 > 3)
  {
    uint64_t v154 = ArgValue;
  }
  else
  {
    uint64_t v9 = operator new(4uLL);
    _DWORD *v9 = 0;
    *(void *)&long long __p = 1;
    uint64_t IntegerType = mlir::Builder::getIntegerType(v8, 0x20u, 1);
    uint64_t v11 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&__p, 1, IntegerType, 0);
    if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v11)) {
      goto LABEL_107;
    }
    if (v11)
    {
      uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v11);
      if (!InterfaceFor)
      {
        uint64_t v13 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
        int v14 = 98;
        int v15 = "InterfaceSupport.h";
        uint64_t v16 = "Interface";
        goto LABEL_108;
      }
    }
    else
    {
      uint64_t InterfaceFor = 0;
    }
    int v17 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v11, InterfaceFor, v9, 4, 4, 1, 1);
    if ((mlir::DenseIntElementsAttr::classof((uint64_t)v17) & 1) == 0)
    {
LABEL_107:
      uint64_t v13 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      int v14 = 566;
      int v15 = "Casting.h";
      uint64_t v16 = "cast";
LABEL_108:
      __assert_rtn(v16, v15, v14, v13);
    }
    unint64_t v172 = v17;
    *(void *)&long long __p = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v8, LocationForOp, &v172);
    char v18 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::mps::ConstantOp &>(v8, LocationForOp, &ArgValue, &__p);
    if (!*((_DWORD *)v18 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v154 = (uint64_t)v18 - 16;
    operator delete(v9);
  }
  BYTE7(v169) = 4;
  strcpy((char *)&__p, "size");
  MIL::IROperation::TryGetParameterValue();
  int v19 = MIL::IRValue::GetScalar<int>();
  if (SBYTE7(v169) < 0) {
    operator delete((void *)__p);
  }
  int v20 = v19 & 1;
  if (v19 < 0) {
    int v20 = -v20;
  }
  *(void *)&long long __p = v19 - v20 + 1;
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
  uint64_t v22 = (void *)mlir::RankedTensorType::get((uint64_t)&__p, 1, ElementTypeOrSelf, 0);
  int MPSDataType = getMPSDataType(v22);
  uint64_t v24 = getConstantDataForScalar(MPSDataType, 1.0);
  uint64_t ConstantOp = createConstantOp(v8, LocationForOp, v24, v22, 1);

  uint64_t v153 = ConstantOp;
  int v26 = operator new(0xCuLL);
  *(void *)int v26 = 0x200000000;
  unint64_t v26[2] = 3;
  *(void *)&long long __p = 3;
  uint64_t v27 = mlir::Builder::getIntegerType(v8, 0x20u, 1);
  __int16 v28 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&__p, 1, v27, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v28)) {
    goto LABEL_102;
  }
  if (v28)
  {
    uint64_t v29 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v28);
    if (!v29)
    {
      __int16 v30 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v31 = 98;
      uint64_t v32 = "InterfaceSupport.h";
      size_t v33 = "Interface";
      goto LABEL_103;
    }
  }
  else
  {
    uint64_t v29 = 0;
  }
  uint64_t v34 = mlir::DenseElementsAttr::getFromRawBuffer(v28, v29, v26, 12, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof(v34) & 1) == 0)
  {
LABEL_102:
    __int16 v30 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v31 = 566;
    uint64_t v32 = "Casting.h";
    size_t v33 = "cast";
LABEL_103:
    __assert_rtn(v33, v32, v31, v30);
  }
  *(void *)&long long __p = v34;
  BOOL v152 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v8, LocationForOp, (uint64_t **)&__p);
  uint64_t v149 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::mps::ConstantOp &>(v8, LocationForOp, &v153, &v152);
  uint64_t v35 = mlir::OpBuilder::create<mlir::mps::SquareOp,mlir::Value &>(v8, LocationForOp, &v154);
  *(void *)&long long __p = 4;
  uint64_t v36 = mlir::Builder::getIntegerType(v8, 0x40u, 0);
  int v37 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&__p, 1, v36, 0);
  *(void *)&long long __p = 4;
  uint64_t v38 = mlir::Builder::getIntegerType(v8, 0x40u, 1);
  unint64_t v39 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&__p, 1, v38, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v39))
  {
    unint64_t v41 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v42 = 566;
    uint64_t v43 = "Casting.h";
    size_t v44 = "cast";
LABEL_110:
    __assert_rtn(v44, v43, v42, v41);
  }
  if (v39)
  {
    uint64_t v40 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v39);
    if (!v40)
    {
      unint64_t v41 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v42 = 98;
      uint64_t v43 = "InterfaceSupport.h";
      size_t v44 = "Interface";
      goto LABEL_110;
    }
  }
  else
  {
    uint64_t v40 = 0;
  }
  long long __p = 0u;
  long long v169 = 0u;
  uint64_t v45 = mlir::DenseElementsAttr::getFromRawBuffer(v39, v40, &__p, 32, 8, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof(v45) & 1) == 0) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v37))
  {
    uint64_t v47 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v48 = 566;
    uint64_t v49 = "Casting.h";
    size_t v50 = "cast";
LABEL_113:
    __assert_rtn(v50, v49, v48, v47);
  }
  if (v37)
  {
    uint64_t v46 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v37);
    if (!v46)
    {
      uint64_t v47 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v48 = 98;
      uint64_t v49 = "InterfaceSupport.h";
      size_t v50 = "Interface";
      goto LABEL_113;
    }
  }
  else
  {
    uint64_t v46 = 0;
  }
  long long __p = xmmword_18112B290;
  long long v169 = unk_18112B2A0;
  uint64_t v51 = mlir::DenseElementsAttr::getFromRawBuffer(v37, v46, &__p, 32, 8, 1, 0);
  if ((mlir::DenseIntElementsAttr::classof(v51) & 1) == 0) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v37))
  {
    uint64_t v53 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v54 = 566;
    int v55 = "Casting.h";
    uint64_t v56 = "cast";
LABEL_116:
    __assert_rtn(v56, v55, v54, v53);
  }
  if (v37)
  {
    uint64_t v52 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v37);
    if (!v52)
    {
      uint64_t v53 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v54 = 98;
      int v55 = "InterfaceSupport.h";
      uint64_t v56 = "Interface";
      goto LABEL_116;
    }
  }
  else
  {
    uint64_t v52 = 0;
  }
  long long __p = xmmword_18112B290;
  long long v169 = unk_18112B2A0;
  uint64_t v57 = mlir::DenseElementsAttr::getFromRawBuffer(v37, v52, &__p, 32, 8, 1, 0);
  if ((mlir::DenseIntElementsAttr::classof(v57) & 1) == 0) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  *(void *)&long long __p = 8;
  uint64_t v58 = mlir::Builder::getIntegerType(v8, 0x40u, 0);
  char v59 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&__p, 1, v58, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v59))
  {
    uint64_t v61 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v62 = 566;
    unint64_t v63 = "Casting.h";
    float v64 = "cast";
LABEL_119:
    __assert_rtn(v64, v63, v62, v61);
  }
  if (v59)
  {
    uint64_t v60 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v59);
    if (!v60)
    {
      uint64_t v61 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v62 = 98;
      unint64_t v63 = "InterfaceSupport.h";
      float v64 = "Interface";
      goto LABEL_119;
    }
  }
  else
  {
    uint64_t v60 = 0;
  }
  long long v170 = 0u;
  long long v171 = 0u;
  long long __p = 0u;
  long long v169 = 0u;
  uint64_t v65 = mlir::DenseElementsAttr::getFromRawBuffer(v59, v60, &__p, 64, 8, 1, 0);
  if ((mlir::DenseIntElementsAttr::classof(v65) & 1) == 0) {
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  uint64_t v66 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)&__p, 0.0);
  float v67 = llvm::APFloatBase::IEEEsingle(v66);
  llvm::APFloat::Storage::Storage(&v166, &__p, v67);
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&__p);
  uint64_t v159 = LocationForOp;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v159);
  uint64_t v69 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.stencil", (const unsigned __int8 *)0xB, Context);
  if (!v70)
  {
    __int16 v165 = 1283;
    uint64_t v163 = "mps.stencil";
    uint64_t v164 = 11;
                       "been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-"
                       "dependent-whats-up-with-dialects-management";
    __int16 v161 = 259;
    llvm::operator+(v162, v160, (uint64_t)&v172);
    llvm::report_fatal_error((llvm::Twine *)&v172, 1);
  }
  mlir::OperationState::OperationState(&__p, LocationForOp, v69);
  if (!*(_DWORD *)(v35 + 36) || !*((_DWORD *)v149 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v145 = v26;
  int32x4_t v72 = v166;
  int v146 = llvm::APFloatBase::PPCDoubleDouble(v71);
  if (v146 == v72)
  {
    uint64_t v73 = v145;
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v173, (const llvm::detail::DoubleAPFloat *)&v166);
  }
  else
  {
    uint64_t v73 = v145;
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)&v173, (const llvm::detail::IEEEFloat *)&v166);
  }
  mlir::mps::StencilOp::build((mlir::Float32Type **)v8, (uint64_t)&__p, v35 - 16, (uint64_t)v149 - 16, v45, v51, v57, v65, (uint64_t)&v172, 2u, 4u, 2u);
  if (v146 == v173) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v174);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v173);
  }
  int v74 = mlir::OpBuilder::create(v8, (const mlir::OperationState *)&__p);
  if (!v74)
  {
    unsigned int v121 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v122 = 662;
    int v123 = "Casting.h";
    uint64_t v124 = "dyn_cast";
    goto LABEL_124;
  }
  uint64_t v75 = llvm::DefaultDoCastIfPossible<mlir::mps::StencilOp,mlir::Operation *,llvm::CastInfo<mlir::mps::StencilOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v74);
  if (!v75)
  {
    unsigned int v121 = "result && \"builder didn't return the right type\"";
    int v122 = 497;
    int v123 = "Builders.h";
    uint64_t v124 = "create";
LABEL_124:
    __assert_rtn(v124, v123, v122, v121);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
  uint64_t v76 = mlir::getElementTypeOrSelf(v148);
  *(void *)&long long __p = mlir::TypeAttr::get(v76);
  uint64_t v77 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>((mlir::UnknownLoc **)v8, LocationForOp, &v157, (uint64_t *)&__p);
  uint64_t v159 = LocationForOp;
  uint64_t v78 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v159);
  uint64_t v79 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.divide", (const unsigned __int8 *)0xA, v78);
  if (!v80)
  {
    __int16 v165 = 1283;
    uint64_t v163 = "mps.divide";
    uint64_t v164 = 10;
                       "been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-"
                       "dependent-whats-up-with-dialects-management";
    __int16 v161 = 259;
    llvm::operator+(v162, v160, (uint64_t)&v172);
    llvm::report_fatal_error((llvm::Twine *)&v172, 1);
  }
  mlir::OperationState::OperationState(&__p, LocationForOp, v79);
  if (!*((_DWORD *)v77 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ATan2Op::build((mlir::Float32Type **)v8, (uint64_t)&__p, v148, (uint64_t)v77 - 16);
  uint64_t v81 = mlir::OpBuilder::create(v8, (const mlir::OperationState *)&__p);
  if (!v81)
  {
    uint64_t v125 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v126 = 662;
    uint64_t v127 = "Casting.h";
    uint64_t v128 = "dyn_cast";
    goto LABEL_129;
  }
  uint64_t v82 = llvm::DefaultDoCastIfPossible<mlir::mps::DivideOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DivideOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v81);
  if (!v82)
  {
    uint64_t v125 = "result && \"builder didn't return the right type\"";
    int v126 = 497;
    uint64_t v127 = "Builders.h";
    uint64_t v128 = "create";
LABEL_129:
    __assert_rtn(v128, v127, v126, v125);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
  uint64_t v159 = LocationForOp;
  uint64_t v83 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v159);
  uint64_t v84 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, v83);
  if (!v85)
  {
    __int16 v165 = 1283;
    uint64_t v163 = "mps.multiply";
    uint64_t v164 = 12;
                       "been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-"
                       "dependent-whats-up-with-dialects-management";
    __int16 v161 = 259;
    llvm::operator+(v162, v160, (uint64_t)&v172);
    llvm::report_fatal_error((llvm::Twine *)&v172, 1);
  }
  mlir::OperationState::OperationState(&__p, LocationForOp, v84);
  if (!*(_DWORD *)(v82 + 36) || !*(_DWORD *)(v75 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ATan2Op::build((mlir::Float32Type **)v8, (uint64_t)&__p, v82 - 16, v75 - 16);
  __int16 v86 = mlir::OpBuilder::create(v8, (const mlir::OperationState *)&__p);
  if (!v86)
  {
    __int16 v129 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v130 = 662;
    uint64_t v131 = "Casting.h";
    uint64_t v132 = "dyn_cast";
    goto LABEL_133;
  }
  uint64_t v87 = llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v86);
  if (!v87)
  {
    __int16 v129 = "result && \"builder didn't return the right type\"";
    int v130 = 497;
    uint64_t v131 = "Builders.h";
    uint64_t v132 = "create";
LABEL_133:
    __assert_rtn(v132, v131, v130, v129);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
  uint64_t v151 = v87;
  uint64_t v88 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value &,mlir::mps::MultiplyOp &>((mlir::Float32Type **)v8, LocationForOp, &v155, (uint64_t)&v151);
  uint64_t v89 = mlir::OpBuilder::create<mlir::mps::NegativeOp,mlir::Value &>(v8, LocationForOp, &v156);
  uint64_t v159 = LocationForOp;
  uint64_t v90 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v159);
  uint64_t v91 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.power", (const unsigned __int8 *)9, v90);
  if (!v92)
  {
    __int16 v165 = 1283;
    uint64_t v163 = "mps.power";
    uint64_t v164 = 9;
                       "been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-"
                       "dependent-whats-up-with-dialects-management";
    __int16 v161 = 259;
    llvm::operator+(v162, v160, (uint64_t)&v172);
    llvm::report_fatal_error((llvm::Twine *)&v172, 1);
  }
  mlir::OperationState::OperationState(&__p, LocationForOp, v91);
  if (!*(_DWORD *)(v88 + 36) || !*(_DWORD *)(v89 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ATan2Op::build((mlir::Float32Type **)v8, (uint64_t)&__p, v88 - 16, v89 - 16);
  long long v93 = mlir::OpBuilder::create(v8, (const mlir::OperationState *)&__p);
  if (!v93)
  {
    uint64_t v133 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v134 = 662;
    uint64_t v135 = "Casting.h";
    unint64_t v136 = "dyn_cast";
    goto LABEL_137;
  }
  uint64_t v94 = llvm::DefaultDoCastIfPossible<mlir::mps::PowerOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PowerOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v93);
  if (!v94)
  {
    uint64_t v133 = "result && \"builder didn't return the right type\"";
    int v134 = 497;
    uint64_t v135 = "Builders.h";
    unint64_t v136 = "create";
LABEL_137:
    __assert_rtn(v136, v135, v134, v133);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
  uint64_t v159 = LocationForOp;
  uint64_t v95 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v159);
  uint64_t v96 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, v95);
  if (!v97)
  {
    __int16 v165 = 1283;
    uint64_t v163 = "mps.multiply";
    uint64_t v164 = 12;
                       "been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-"
                       "dependent-whats-up-with-dialects-management";
    __int16 v161 = 259;
    llvm::operator+(v162, v160, (uint64_t)&v172);
    llvm::report_fatal_error((llvm::Twine *)&v172, 1);
  }
  mlir::OperationState::OperationState(&__p, LocationForOp, v96);
  if (!*(_DWORD *)(v94 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ATan2Op::build((mlir::Float32Type **)v8, (uint64_t)&__p, v94 - 16, v154);
  uint64_t v98 = mlir::OpBuilder::create(v8, (const mlir::OperationState *)&__p);
  if (!v98)
  {
    id v137 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v138 = 662;
    double v139 = "Casting.h";
    long long v140 = "dyn_cast";
    goto LABEL_142;
  }
  uint64_t v99 = llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v98);
  if (!v99)
  {
    id v137 = "result && \"builder didn't return the right type\"";
    int v138 = 497;
    double v139 = "Builders.h";
    long long v140 = "create";
LABEL_142:
    __assert_rtn(v140, v139, v138, v137);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
  if (v150 <= 3)
  {
    size_t v100 = operator new(4uLL);
    *size_t v100 = 0;
    *(void *)&long long __p = 1;
    uint64_t v101 = mlir::Builder::getIntegerType(v8, 0x20u, 1);
    int v102 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&__p, 1, v101, 0);
    if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v102)) {
      goto LABEL_143;
    }
    if (v102)
    {
      uint64_t v103 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v102);
      if (!v103)
      {
        uint64_t v104 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
        int v105 = 98;
        int v106 = "InterfaceSupport.h";
        uint64_t v107 = "Interface";
        goto LABEL_144;
      }
    }
    else
    {
      uint64_t v103 = 0;
    }
    uint64_t v108 = mlir::DenseElementsAttr::getFromRawBuffer(v102, v103, v100, 4, 4, 1, 1);
    if ((mlir::DenseIntElementsAttr::classof(v108) & 1) == 0)
    {
LABEL_143:
      uint64_t v104 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      int v105 = 566;
      int v106 = "Casting.h";
      uint64_t v107 = "cast";
LABEL_144:
      __assert_rtn(v107, v106, v105, v104);
    }
    *(void *)&long long __p = v108;
    uint64_t v109 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v8, LocationForOp, (uint64_t **)&__p);
    uint64_t v159 = LocationForOp;
    uint64_t v110 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v159);
    uint64_t v111 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.squeeze", (const unsigned __int8 *)0xB, v110);
    if (!v112)
    {
      __int16 v165 = 1283;
      uint64_t v163 = "mps.squeeze";
      uint64_t v164 = 11;
                         "t been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loa"
                         "ded-dependent-whats-up-with-dialects-management";
      __int16 v161 = 259;
      llvm::operator+(v162, v160, (uint64_t)&v172);
      llvm::report_fatal_error((llvm::Twine *)&v172, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v111);
    if (!*(_DWORD *)(v99 + 36) || !*((_DWORD *)v109 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    mlir::mps::SqueezeOp::build((uint64_t)v8, (uint64_t)&__p, v99 - 16, (uint64_t)v109 - 16);
    uint64_t v113 = mlir::OpBuilder::create(v8, (const mlir::OperationState *)&__p);
    if (v113)
    {
      uint64_t v99 = llvm::DefaultDoCastIfPossible<mlir::mps::SqueezeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SqueezeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v113);
      if (v99)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        if (!*(_DWORD *)(v99 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        operator delete(v100);
        goto LABEL_90;
      }
      uint64_t v141 = "result && \"builder didn't return the right type\"";
      int v142 = 497;
      int v143 = "Builders.h";
      uint64_t v144 = "create";
    }
    else
    {
      uint64_t v141 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v142 = 662;
      int v143 = "Casting.h";
      uint64_t v144 = "dyn_cast";
    }
    __assert_rtn(v144, v143, v142, v141);
  }
  if (!*(_DWORD *)(v99 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
LABEL_90:
  (*(void (**)(long long *__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
  id v114 = (uint64_t *)__p;
  uint64_t v115 = (char *)operator new(8uLL);
  *(void *)uint64_t v115 = v99 - 16;
  unint64_t v172 = v114;
  uint64_t v116 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(v147 + 8), (uint64_t)v114, (uint64_t)&std::piecewise_construct, (long long **)&v172);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v116 + 5, v115, v115 + 8, 1uLL);
  operator delete(v115);
  uint64_t v117 = __p;
  if ((void)__p)
  {
    uint64_t v118 = *((void *)&__p + 1);
    uint64_t v119 = (void *)__p;
    if (*((void *)&__p + 1) != (void)__p)
    {
      do
      {
        if (*(char *)(v118 - 1) < 0) {
          operator delete(*(void **)(v118 - 24));
        }
        v118 -= 24;
      }
      while (v118 != v117);
      uint64_t v119 = (void *)__p;
    }
    *((void *)&__p + 1) = v117;
    operator delete(v119);
  }
  if (v146 == v166) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)&v167);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v166);
  }
  operator delete(v73);
  return 1;
}

void sub_180DAB5BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,void *__p,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  llvm::APFloat::~APFloat((llvm::APFloat *)&a41);
  operator delete(v50);
  _Unwind_Resume(a1);
}

void sub_180DAB7A0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180DAB7B4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180DAB7EC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180DAB800(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180DAB814(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180DAB828(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180DAB83C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180DAB86C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a45);
  llvm::APFloat::~APFloat((llvm::APFloat *)&a41);
  operator delete(v45);
  _Unwind_Resume(a1);
}

void sub_180DAB890(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::SquareOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.square", (const unsigned __int8 *)0xA, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.square";
    v19[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    char v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    int v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::SquareOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SquareOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    char v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    int v14 = "Builders.h";
    int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180DABA18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DABA30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SquareOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SquareOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 10 && *(void *)AttrData == 0x617571732E73706DLL && *(_WORD *)(AttrData + 8) == 25970)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.square";
      v8[3] = 10;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SquareOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::StencilOp,mlir::Operation *,llvm::CastInfo<mlir::mps::StencilOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x6E6574732E73706DLL && *(void *)((char *)AttrData + 3) == 0x6C69636E6574732ELL)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.stencil";
      v8[3] = 11;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::StencilOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::PowerOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PowerOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 9 && *(void *)AttrData == 0x65776F702E73706DLL && *(unsigned char *)(AttrData + 8) == 114)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.power";
      v8[3] = 9;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::PowerOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::MatMulPattern::~MatMulPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::MatMulPattern::matchAndRewrite(_anonymous_namespace_::MatMulPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  __p[38] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v74 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) != 1)
  {
    __p[0] = operator new(0x40uLL);
    *(_OWORD *)&__p[1] = xmmword_181129DA0;
    strcpy((char *)__p[0], "The number of outputs does not match the number of results.");
    uint64_t v15 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
    return v15;
  }
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  __int16 v7 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(ParameterType);
  uint64_t v8 = MIL::IRTensorValueType::Rank(v7);
  __int16 v9 = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  uint64_t v10 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(v9);
  uint64_t v11 = MIL::IRTensorValueType::Rank(v10);
  strcpy((char *)__p, "transpose_x");
  Parameteruint64_t Value = MIL::IROperation::TryGetParameterValue();
  HIBYTE(__p[2]) = 11;
  strcpy((char *)__p, "transpose_y");
  uint64_t v13 = MIL::IROperation::TryGetParameterValue();
  int v14 = 0;
  if (ParameterValue && v8 != 1) {
    int v14 = (mlir::MLIRContext *)MIL::IRValue::GetScalar<BOOL>();
  }
  uint64_t v16 = 0;
  if (v13 && v11 != 1) {
    uint64_t v16 = (mlir::MLIRContext *)MIL::IRValue::GetScalar<BOOL>();
  }
  if (v8 == 1)
  {
    int v17 = operator new(4uLL);
    _DWORD *v17 = 0;
    __p[0] = (void *)1;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 18), 0x20u, 1);
    int v19 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)__p, 1, IntegerType, 0);
    if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v19)) {
      goto LABEL_61;
    }
    if (v19)
    {
      uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v19);
      if (!InterfaceFor)
      {
        int v21 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
        int v22 = 98;
        int v23 = "InterfaceSupport.h";
        uint64_t v24 = "Interface";
        goto LABEL_62;
      }
    }
    else
    {
      uint64_t InterfaceFor = 0;
    }
    uint64_t v25 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v19, InterfaceFor, v17, 4, 4, 1, 1);
    if ((mlir::DenseIntElementsAttr::classof((uint64_t)v25) & 1) == 0)
    {
LABEL_61:
      int v21 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      int v22 = 566;
      int v23 = "Casting.h";
      uint64_t v24 = "cast";
LABEL_62:
      __assert_rtn(v24, v23, v22, v21);
    }
    v81[0] = v25;
    __p[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, v81);
    int v26 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue, __p);
    if (!*((_DWORD *)v26 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    Arguint64_t Value = (uint64_t)v26 - 16;
    operator delete(v17);
  }
  if (v11 == 1)
  {
    uint64_t v27 = operator new(4uLL);
    _DWORD *v27 = 1;
    __p[0] = (void *)1;
    uint64_t v28 = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 18), 0x20u, 1);
    uint64_t v29 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)__p, 1, v28, 0);
    if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v29)) {
      goto LABEL_63;
    }
    if (v29)
    {
      uint64_t v30 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v29);
      if (!v30)
      {
        int v31 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
        int v32 = 98;
        size_t v33 = "InterfaceSupport.h";
        uint64_t v34 = "Interface";
        goto LABEL_64;
      }
    }
    else
    {
      uint64_t v30 = 0;
    }
    uint64_t v35 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v29, v30, v27, 4, 4, 1, 1);
    if ((mlir::DenseIntElementsAttr::classof((uint64_t)v35) & 1) == 0)
    {
LABEL_63:
      int v31 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      int v32 = 566;
      size_t v33 = "Casting.h";
      uint64_t v34 = "cast";
LABEL_64:
      __assert_rtn(v34, v33, v32, v31);
    }
    v81[0] = v35;
    __p[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, v81);
    uint64_t v36 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &v74, __p);
    if (!*((_DWORD *)v36 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v74 = (uint64_t)v36 - 16;
    operator delete(v27);
  }
  uint64_t v76 = LocationForOp;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v76);
  uint64_t v38 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.matmul", (const unsigned __int8 *)0xA, Context);
  if (!v39)
  {
    __int16 v80 = 1283;
    v79[2] = (uint64_t)"mps.matmul";
    v79[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v78 = 259;
    llvm::operator+(v79, (uint64_t *)&v77, (uint64_t)v81);
    llvm::report_fatal_error((llvm::Twine *)v81, 1);
  }
  mlir::OperationState::OperationState(__p, LocationForOp, v38);
  mlir::mps::MatMulOp::build(a3 + 18, (uint64_t)__p, ArgValue, v74, v14, v16);
  uint64_t v40 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)__p);
  if (!v40)
  {
    char v70 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v71 = 662;
    int32x4_t v72 = "Casting.h";
    uint64_t v73 = "dyn_cast";
    goto LABEL_68;
  }
  uint64_t v41 = llvm::DefaultDoCastIfPossible<mlir::mps::MatMulOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MatMulOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v40);
  if (!v41)
  {
    char v70 = "result && \"builder didn't return the right type\"";
    int v71 = 497;
    int32x4_t v72 = "Builders.h";
    uint64_t v73 = "create";
LABEL_68:
    __assert_rtn(v73, v72, v71, v70);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)__p);
  if (!*(_DWORD *)(v41 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  v79[0] = v41 - 16;
  if (v8 == 1)
  {
    int v42 = operator new(4uLL);
    *int v42 = -2;
    __p[0] = (void *)1;
    uint64_t v43 = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 18), 0x20u, 1);
    size_t v44 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)__p, 1, v43, 0);
    if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v44)) {
      goto LABEL_70;
    }
    if (v44)
    {
      uint64_t v45 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v44);
      if (!v45)
      {
        uint64_t v46 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
        int v47 = 98;
        int v48 = "InterfaceSupport.h";
        uint64_t v49 = "Interface";
        goto LABEL_71;
      }
    }
    else
    {
      uint64_t v45 = 0;
    }
    size_t v50 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v44, v45, v42, 4, 4, 1, 1);
    if ((mlir::DenseIntElementsAttr::classof((uint64_t)v50) & 1) == 0)
    {
LABEL_70:
      uint64_t v46 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      int v47 = 566;
      int v48 = "Casting.h";
      uint64_t v49 = "cast";
LABEL_71:
      __assert_rtn(v49, v48, v47, v46);
    }
    v81[0] = v50;
    __p[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, v81);
    uint64_t v51 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, v79, __p);
    if (!*((_DWORD *)v51 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    v79[0] = (uint64_t)v51 - 16;
    operator delete(v42);
  }
  if (v11 == 1)
  {
    uint64_t v52 = operator new(4uLL);
    *uint64_t v52 = -1;
    __p[0] = (void *)1;
    uint64_t v53 = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 18), 0x20u, 1);
    int v54 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)__p, 1, v53, 0);
    if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v54)) {
      goto LABEL_72;
    }
    if (v54)
    {
      uint64_t v55 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v54);
      if (!v55)
      {
        uint64_t v56 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
        int v57 = 98;
        uint64_t v58 = "InterfaceSupport.h";
        char v59 = "Interface";
        goto LABEL_73;
      }
    }
    else
    {
      uint64_t v55 = 0;
    }
    uint64_t v60 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v54, v55, v52, 4, 4, 1, 1);
    if ((mlir::DenseIntElementsAttr::classof((uint64_t)v60) & 1) == 0)
    {
LABEL_72:
      uint64_t v56 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      int v57 = 566;
      uint64_t v58 = "Casting.h";
      char v59 = "cast";
LABEL_73:
      __assert_rtn(v59, v58, v57, v56);
    }
    v81[0] = v60;
    __p[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, v81);
    uint64_t v61 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, v79, __p);
    if (!*((_DWORD *)v61 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    v79[0] = (uint64_t)v61 - 16;
    operator delete(v52);
  }
  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(__p, a2);
  int v62 = (uint64_t *)__p[0];
  uint64_t v63 = v79[0];
  float v64 = (char *)operator new(8uLL);
  *(void *)float v64 = v63;
  v81[0] = v62;
  uint64_t v65 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v62, (uint64_t)&std::piecewise_construct, (long long **)v81);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v65 + 5, v64, v64 + 8, 1uLL);
  operator delete(v64);
  uint64_t v66 = (void **)__p[0];
  if (__p[0])
  {
    float v67 = (void **)__p[1];
    uint64_t v68 = __p[0];
    if (__p[1] != __p[0])
    {
      do
      {
        if (*((char *)v67 - 1) < 0) {
          operator delete(*(v67 - 3));
        }
        v67 -= 3;
      }
      while (v67 != v66);
      uint64_t v68 = __p[0];
    }
    __p[1] = v66;
    operator delete(v68);
  }
  return 1;
}

void sub_180DAC784(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27)
{
}

void sub_180DAC798(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180DAC7AC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180DAC7C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_180DAC7D4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180DAC7E8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180DAC7FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a32 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(void *a1, uint64_t *a2)
{
  uint64_t v2 = a1[1] - *a1;
  uint64_t v3 = v2 >> 3;
  unint64_t v4 = (v2 >> 3) + 1;
  if (v4 >> 61) {
    std::vector<int>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = a1[2] - *a1;
  if (v7 >> 2 > v4) {
    unint64_t v4 = v7 >> 2;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v8 = v4;
  }
  if (v8)
  {
    if (v8 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    __int16 v9 = (char *)operator new(8 * v8);
  }
  else
  {
    __int16 v9 = 0;
  }
  uint64_t v10 = &v9[8 * v3];
  uint64_t v11 = &v9[8 * v8];
  uint64_t v12 = *a2;
  *a2 = 0;
  *(void *)uint64_t v10 = v12;
  uint64_t v13 = v10 + 8;
  int v14 = (char *)*a1;
  uint64_t v15 = (char *)a1[1];
  if (v15 == (char *)*a1)
  {
    *a1 = v10;
    a1[1] = v13;
    a1[2] = v11;
  }
  else
  {
    unint64_t v16 = (unint64_t)&v15[-*a1 - 8];
    if (v16 < 0x78 || &v15[-(v16 & 0xFFFFFFFFFFFFFFF8) - 8] < v10 && &v9[v2 - (v16 & 0xFFFFFFFFFFFFFFF8) - 8] < v15) {
      goto LABEL_31;
    }
    uint64_t v17 = (v16 >> 3) + 1;
    uint64_t v18 = 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
    v10 -= v18;
    int v19 = &v15[-v18];
    __int16 v20 = v15 - 16;
    int v21 = &v9[8 * v3 - 16];
    uint64_t v22 = v17 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v24 = *((_OWORD *)v20 - 1);
      long long v23 = *(_OWORD *)v20;
      *((_OWORD *)v20 - 1) = 0uLL;
      *(_OWORD *)__int16 v20 = 0uLL;
      *((_OWORD *)v21 - 1) = v24;
      *(_OWORD *)int v21 = v23;
      v20 -= 32;
      v21 -= 32;
      v22 -= 4;
    }
    while (v22);
    uint64_t v15 = v19;
    if (v17 != (v17 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_31:
      do
      {
        uint64_t v25 = *((void *)v15 - 1);
        v15 -= 8;
        *(void *)uint64_t v15 = 0;
        *((void *)v10 - 1) = v25;
        v10 -= 8;
      }
      while (v15 != v14);
    }
    uint64_t v15 = (char *)*a1;
    int v26 = (char *)a1[1];
    *a1 = v10;
    a1[1] = v13;
    a1[2] = v11;
    while (v26 != v15)
    {
      uint64_t v28 = *((void *)v26 - 1);
      v26 -= 8;
      uint64_t v27 = v28;
      *(void *)int v26 = 0;
      if (v28) {
        (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
      }
    }
  }
  if (v15) {
    operator delete(v15);
  }
  return v13;
}

void anonymous namespace'::PReLUPattern::~PReLUPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::PReLUPattern::matchAndRewrite(_anonymous_namespace_::PReLUPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v123 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v110 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "alpha");
  __int16 v6 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 160))(a2);
  v109[0] = 0;
  v109[1] = 0;
  uint64_t v108 = v109;
  unint64_t v8 = v6 + 1;
  uint64_t v7 = *v6;
  if (*v6 != (const void **)(v6 + 1))
  {
    do
    {
      std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&v108, (uint64_t *)v109, v7 + 4, (uint64_t)(v7 + 4));
      uint64_t v15 = (const void **)v7[1];
      if (v15)
      {
        do
        {
          unint64_t v16 = (const void ***)v15;
          uint64_t v15 = (const void **)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          unint64_t v16 = (const void ***)v7[2];
          BOOL v17 = *v16 == v7;
          uint64_t v7 = (const void **)v16;
        }
        while (!v17);
      }
      uint64_t v7 = (const void **)v16;
    }
    while (v16 != v8);
  }
  char v122 = 1;
  LOWORD(__p) = 120;
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  if (v122 < 0) {
    operator delete(__p);
  }
  uint64_t v10 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(ParameterType);
  uint64_t v11 = MIL::IRTensorValueType::Rank(v10);
  uint64_t v12 = (int *)operator new(0x10uLL);
  uint64_t v13 = v12;
  uint64_t v102 = LocationForOp;
  uint64_t v103 = a3;
  uint64_t v101 = a2;
  int v105 = v12;
  int v106 = v12;
  uint64_t v107 = v12 + 4;
  if (v11 > 2)
  {
    uint64_t v14 = 0;
    while (1)
    {
      int v19 = ~v14;
      if (v13 >= v107) {
        break;
      }
      *uint64_t v13 = v19;
      uint64_t v18 = v13 + 1;
LABEL_14:
      int v106 = v18;
      uint64_t v13 = v18;
      BOOL v17 = v14++ == v11 - 3;
      if (v17) {
        goto LABEL_43;
      }
    }
    __int16 v20 = (int *)v105;
    int64_t v21 = (char *)v13 - (unsigned char *)v105;
    uint64_t v22 = ((char *)v13 - (unsigned char *)v105) >> 2;
    unint64_t v23 = v22 + 1;
    if ((unint64_t)(v22 + 1) >> 62) {
      std::vector<int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v24 = (char *)v107 - (unsigned char *)v105;
    if (((char *)v107 - (unsigned char *)v105) >> 1 > v23) {
      unint64_t v23 = v24 >> 1;
    }
    if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v25 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v25 = v23;
    }
    if (v25)
    {
      if (v25 >> 62) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      int v26 = operator new(4 * v25);
      uint64_t v27 = (int *)&v26[4 * v22];
      int *v27 = v19;
      uint64_t v18 = v27 + 1;
      int64_t v28 = (char *)v13 - (char *)v20;
      if (v13 == v20) {
        goto LABEL_30;
      }
    }
    else
    {
      int v26 = 0;
      uint64_t v27 = (int *)(4 * v22);
      *(_DWORD *)(4 * v22) = v19;
      uint64_t v18 = (int *)(4 * v22 + 4);
      int64_t v28 = (char *)v13 - (char *)v20;
      if (v13 == v20) {
        goto LABEL_30;
      }
    }
    unint64_t v29 = v28 - 4;
    if (v29 >= 0xBC)
    {
      unint64_t v32 = ((char *)(v13 - 1) - (char *)v20) & 0xFFFFFFFFFFFFFFFCLL;
      if (&v26[v21 - 4 - v32] > &v26[v21 - 4])
      {
        uint64_t v30 = v13;
      }
      else if ((int *)((char *)v13 - v32 - 4) > v13 - 1)
      {
        uint64_t v30 = v13;
      }
      else if ((unint64_t)((char *)v13 - v26 - v21) >= 0x20)
      {
        uint64_t v33 = (v29 >> 2) + 1;
        uint64_t v34 = 4 * (v33 & 0x7FFFFFFFFFFFFFF8);
        uint64_t v30 = &v13[v34 / 0xFFFFFFFFFFFFFFFCLL];
        uint64_t v27 = (int *)((char *)v27 - v34);
        uint64_t v35 = &v26[4 * v22 - 16];
        uint64_t v36 = v13 - 4;
        uint64_t v37 = v33 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v38 = *(_OWORD *)v36;
          *(v35 - 1) = *((_OWORD *)v36 - 1);
          _OWORD *v35 = v38;
          v35 -= 2;
          v36 -= 8;
          v37 -= 8;
        }
        while (v37);
        if (v33 == (v33 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_30:
          int v105 = v27;
          int v106 = v18;
          uint64_t v107 = (int *)&v26[4 * v25];
          if (v20) {
            operator delete(v20);
          }
          goto LABEL_14;
        }
      }
      else
      {
        uint64_t v30 = v13;
      }
    }
    else
    {
      uint64_t v30 = v13;
    }
    do
    {
      int v31 = *--v30;
      *--uint64_t v27 = v31;
    }
    while (v30 != v20);
    goto LABEL_30;
  }
  uint64_t v18 = v12;
LABEL_43:
  if (v11 >= 2)
  {
    uint64_t v40 = v102;
    char v39 = v103;
    if (v18 < v107)
    {
      int *v18 = 0;
      uint64_t v41 = (uint64_t)(v18 + 1);
LABEL_68:
      int v106 = (unsigned char *)v41;
      uint64_t v18 = (int *)v41;
      goto LABEL_69;
    }
    int v42 = (int *)v105;
    int64_t v43 = (char *)v18 - (unsigned char *)v105;
    uint64_t v44 = ((char *)v18 - (unsigned char *)v105) >> 2;
    unint64_t v45 = v44 + 1;
    if ((unint64_t)(v44 + 1) >> 62) {
      std::vector<int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v46 = (char *)v107 - (unsigned char *)v105;
    if (((char *)v107 - (unsigned char *)v105) >> 1 > v45) {
      unint64_t v45 = v46 >> 1;
    }
    if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v47 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v47 = v45;
    }
    if (v47)
    {
      if (v47 >> 62) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      int v48 = operator new(4 * v47);
      uint64_t v49 = &v48[4 * v44];
      size_t v50 = &v48[4 * v47];
      _DWORD *v49 = 0;
      uint64_t v41 = (uint64_t)(v49 + 1);
      int64_t v51 = (char *)v18 - (char *)v42;
      if (v18 == v42) {
        goto LABEL_66;
      }
    }
    else
    {
      int v48 = 0;
      uint64_t v49 = (_DWORD *)(4 * v44);
      size_t v50 = 0;
      *(_DWORD *)(4 * v44) = 0;
      uint64_t v41 = 4 * v44 + 4;
      int64_t v51 = (char *)v18 - (char *)v42;
      if (v18 == v42) {
        goto LABEL_66;
      }
    }
    unint64_t v52 = v51 - 4;
    if (v52 >= 0x2C)
    {
      if ((unint64_t)((char *)v18 - v48 - v43) >= 0x20)
      {
        uint64_t v54 = (v52 >> 2) + 1;
        uint64_t v55 = 4 * (v54 & 0x7FFFFFFFFFFFFFF8);
        uint64_t v53 = &v18[v55 / 0xFFFFFFFFFFFFFFFCLL];
        uint64_t v49 = (_DWORD *)((char *)v49 - v55);
        uint64_t v56 = &v48[4 * v44 - 16];
        int v57 = (long long *)(v18 - 4);
        uint64_t v58 = v54 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v59 = *v57;
          *(v56 - 1) = *(v57 - 1);
          *uint64_t v56 = v59;
          v56 -= 2;
          v57 -= 2;
          v58 -= 8;
        }
        while (v58);
        if (v54 == (v54 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_66:
          int v105 = v49;
          int v106 = (unsigned char *)v41;
          uint64_t v107 = (int *)v50;
          if (v42) {
            operator delete(v42);
          }
          goto LABEL_68;
        }
      }
      else
      {
        uint64_t v53 = v18;
      }
    }
    else
    {
      uint64_t v53 = v18;
    }
    do
    {
      int v60 = *--v53;
      *--uint64_t v49 = v60;
    }
    while (v53 != v42);
    goto LABEL_66;
  }
  uint64_t v40 = v102;
  char v39 = v103;
LABEL_69:
  long long __p = (void *)(((char *)v18 - (unsigned char *)v105) >> 2);
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(v39 + 18), 0x20u, 1);
  int v62 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&__p, 1, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v62)) {
    goto LABEL_98;
  }
  if (v62)
  {
    uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v62);
    if (!InterfaceFor)
    {
      float v64 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v65 = 98;
      uint64_t v66 = "InterfaceSupport.h";
      float v67 = "Interface";
      goto LABEL_99;
    }
  }
  else
  {
    uint64_t InterfaceFor = 0;
  }
  uint64_t v68 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v62, InterfaceFor, v105, v106 - (unsigned char *)v105, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v68) & 1) == 0)
  {
LABEL_98:
    float v64 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v65 = 566;
    uint64_t v66 = "Casting.h";
    float v67 = "cast";
LABEL_99:
    __assert_rtn(v67, v66, v65, v64);
  }
  long long __p = v68;
  uint64_t v104 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(v39 + 18), v40, (uint64_t **)&__p);
  uint64_t v69 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(v39 + 18), v40, &v110, &v104);
  if (!*((_DWORD *)v69 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v110 = (uint64_t)v69 - 16;
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
  long long __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
  int v71 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(v39 + 18, v40, &v110, (uint64_t *)&__p);
  if (!*((_DWORD *)v71 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v110 = (uint64_t)v71 - 16;
  uint64_t v72 = mlir::getElementTypeOrSelf(ArgValue);
  long long __p = (void *)1;
  uint64_t v73 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&__p, 1, v72, 0);
  long long __p = (void *)mlir::mps::getConstantAttr<int>(v73, 0);
  uint64_t v74 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(v39 + 18), v40, (uint64_t **)&__p);
  uint64_t v112 = v40;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v112);
  uint64_t v76 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.greater_equal", (const unsigned __int8 *)0x11, Context);
  if (!v77)
  {
    __int16 v118 = 1283;
    uint64_t v116 = "mps.greater_equal";
    uint64_t v117 = 17;
                       "been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-"
                       "dependent-whats-up-with-dialects-management";
    __int16 v114 = 259;
    llvm::operator+(v115, v113, (uint64_t)v119);
    llvm::report_fatal_error((llvm::Twine *)v119, 1);
  }
  mlir::OperationState::OperationState(&__p, v40, v76);
  if (!*((_DWORD *)v74 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::EqualToOp::build((uint64_t)(v39 + 18), (uint64_t)&__p, ArgValue, (uint64_t)v74 - 16);
  __int16 v78 = mlir::OpBuilder::create((mlir::OpBuilder *)(v39 + 18), (const mlir::OperationState *)&__p);
  if (!v78)
  {
    long long v93 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v94 = 662;
    uint64_t v95 = "Casting.h";
    uint64_t v96 = "dyn_cast";
    goto LABEL_107;
  }
  uint64_t v79 = llvm::DefaultDoCastIfPossible<mlir::mps::GreaterThanOrEqualToOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GreaterThanOrEqualToOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v78);
  if (!v79)
  {
    long long v93 = "result && \"builder didn't return the right type\"";
    int v94 = 497;
    uint64_t v95 = "Builders.h";
    uint64_t v96 = "create";
LABEL_107:
    __assert_rtn(v96, v95, v94, v93);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
  __int16 v80 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>(v39 + 18, v40, &v110, &ArgValue);
  uint64_t v112 = v40;
  uint64_t v81 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v112);
  uint64_t v82 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.select", (const unsigned __int8 *)0xA, v81);
  if (!v83)
  {
    __int16 v118 = 1283;
    uint64_t v116 = "mps.select";
    uint64_t v117 = 10;
                       "been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-"
                       "dependent-whats-up-with-dialects-management";
    __int16 v114 = 259;
    llvm::operator+(v115, v113, (uint64_t)v119);
    llvm::report_fatal_error((llvm::Twine *)v119, 1);
  }
  mlir::OperationState::OperationState(&__p, v40, v82);
  if (!*(_DWORD *)(v79 + 36) || !*((_DWORD *)v80 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::SelectOp::build((uint64_t)(v39 + 18), (uint64_t)&__p, v79 - 16, ArgValue, (uint64_t)v80 - 16);
  uint64_t v84 = mlir::OpBuilder::create((mlir::OpBuilder *)(v39 + 18), (const mlir::OperationState *)&__p);
  if (!v84)
  {
    char v97 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v98 = 662;
    uint64_t v99 = "Casting.h";
    size_t v100 = "dyn_cast";
    goto LABEL_111;
  }
  uint64_t v85 = llvm::DefaultDoCastIfPossible<mlir::mps::SelectOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SelectOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v84);
  if (!v85)
  {
    char v97 = "result && \"builder didn't return the right type\"";
    int v98 = 497;
    uint64_t v99 = "Builders.h";
    size_t v100 = "create";
LABEL_111:
    __assert_rtn(v100, v99, v98, v97);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
  (*(void (**)(void **__return_ptr))(*(void *)v101 + 200))(&__p);
  if (!*(_DWORD *)(v85 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  __int16 v86 = (long long *)__p;
  uint64_t v87 = (char *)operator new(8uLL);
  *(void *)uint64_t v87 = v85 - 16;
  v119[0] = v86;
  uint64_t v88 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(v39 + 8), (uint64_t)v86, (uint64_t)&std::piecewise_construct, v119);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v88 + 5, v87, v87 + 8, 1uLL);
  operator delete(v87);
  uint64_t v89 = (void **)__p;
  if (__p)
  {
    uint64_t v90 = v121;
    uint64_t v91 = __p;
    if (v121 != __p)
    {
      do
      {
        if (*((char *)v90 - 1) < 0) {
          operator delete(*(v90 - 3));
        }
        v90 -= 3;
      }
      while (v90 != v89);
      uint64_t v91 = __p;
    }
    unsigned int v121 = v89;
    operator delete(v91);
  }
  if (v105)
  {
    int v106 = v105;
    operator delete(v105);
  }
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v108, v109[0]);
  return 1;
}

void sub_180DAD5B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, char a18, char *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (__p) {
    operator delete(__p);
  }
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a18, a19);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::GreaterThanOrEqualToOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GreaterThanOrEqualToOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 17
      && *(void *)AttrData == 0x616572672E73706DLL
      && *(void *)(AttrData + 8) == 0x617571655F726574
      && *(unsigned char *)(AttrData + 16) == 108)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.greater_equal";
      v9[3] = 17;
      uint64_t v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::GreaterThanOrEqualToOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::ReduceArgMinPattern::~ReduceArgMinPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::ReducePatternBase::matchAndRewrite(_anonymous_namespace_::ReducePatternBase *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  __int16 v6 = a3 + 18;
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t v35 = LocationForOp;
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
  if (*((unsigned char *)this + 33))
  {
    BOOL isF16 = mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf);
    if (isF16)
    {
      uint64_t v10 = mlir::Float32Type::get(*v6, v8);
      *(void *)long long __p = mlir::TypeAttr::get(v10);
      uint64_t v11 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(v6, LocationForOp, &ArgValue, (uint64_t *)__p);
      if (!*((_DWORD *)v11 + 9)) {
        goto LABEL_35;
      }
      Arguint64_t Value = (uint64_t)v11 - 16;
    }
    if (mlir::Type::isInteger((mlir::Type *)&ElementTypeOrSelf, 8)
      || mlir::Type::isInteger((mlir::Type *)&ElementTypeOrSelf, 16))
    {
      BOOL isSignedInteger = mlir::Type::isSignedInteger((mlir::Type *)&ElementTypeOrSelf);
      uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)v6, 0x20u, isSignedInteger);
      *(void *)long long __p = mlir::TypeAttr::get(IntegerType);
      uint64_t v14 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(v6, LocationForOp, &ArgValue, (uint64_t *)__p);
      if (!*((_DWORD *)v14 + 9)) {
        goto LABEL_35;
      }
      Arguint64_t Value = (uint64_t)v14 - 16;
      BOOL isF16 = 1;
    }
  }
  else
  {
    BOOL isF16 = 0;
  }
  if (*((unsigned char *)this + 32)) {
    uint64_t v15 = "axis";
  }
  else {
    uint64_t v15 = "axes";
  }
  OptionalArguint64_t Value = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, v15);
  __p[23] = 9;
  strcpy(__p, "keep_dims");
  Parameteruint64_t Value = MIL::IROperation::TryGetParameterValue();
  uint64_t v18 = ParameterValue;
  if ((__p[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)__p);
    if (v18) {
      goto LABEL_15;
    }
  }
  else if (ParameterValue)
  {
LABEL_15:
    uint64_t v19 = MIL::IRValue::GetScalar<BOOL>();
    goto LABEL_18;
  }
  uint64_t v19 = 1;
LABEL_18:
  uint64_t v31 = (*(uint64_t (**)(_anonymous_namespace_::ReducePatternBase *, mlir::Float32Type **, uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)this + 24))(this, v6, ArgValue, OptionalArgValue, v19, &v35);
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    if (!isF16 || *((unsigned char *)this + 32)) {
      goto LABEL_23;
    }
    uint64_t v20 = v35;
    *(void *)long long __p = mlir::TypeAttr::get(ElementTypeOrSelf);
    int64_t v21 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(v6, v20, &v31, (uint64_t *)__p);
    if (*((_DWORD *)v21 + 9))
    {
      uint64_t v31 = (uint64_t)v21 - 16;
LABEL_23:
      (*(void (**)(unsigned char *__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(__p, a2);
      uint64_t v23 = v31;
      uint64_t v22 = *(long long **)__p;
      uint64_t v24 = (char *)operator new(8uLL);
      *(void *)uint64_t v24 = v23;
      uint64_t v36 = v22;
      unint64_t v25 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v22, (uint64_t)&std::piecewise_construct, &v36);
      std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v25 + 5, v24, v24 + 8, 1uLL);
      operator delete(v24);
      uint64_t v26 = *(void *)__p;
      if (*(void *)__p)
      {
        uint64_t v27 = *(void *)&__p[8];
        int64_t v28 = *(void **)__p;
        if (*(void *)&__p[8] != *(void *)__p)
        {
          do
          {
            if (*(char *)(v27 - 1) < 0) {
              operator delete(*(void **)(v27 - 24));
            }
            v27 -= 24;
          }
          while (v27 != v26);
          int64_t v28 = *(void **)__p;
        }
        *(void *)&__p[8] = v26;
        operator delete(v28);
      }
      return 1;
    }
LABEL_35:
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  *(void *)long long __p = operator new(0x40uLL);
  *(_OWORD *)&__p[8] = xmmword_181129DA0;
  strcpy(*(char **)__p, "The number of outputs does not match the number of results.");
  uint64_t v29 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __p);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  return v29;
}

void sub_180DADC48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t anonymous namespace'::OneToOneReducePattern<mlir::mps::ReductionArgMinOp>::lower(uint64_t a1, mlir::UnitAttr **a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6)
{
  v27[38] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *a6;
  uint64_t v21 = *a6;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v21);
  uint64_t v12 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_argmin", (const unsigned __int8 *)0x14, Context);
  if (!v13)
  {
    __int16 v25 = 1283;
    v24[2] = (uint64_t)"mps.reduction_argmin";
    v24[3] = 20;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v23 = 259;
    llvm::operator+(v24, (uint64_t *)&v22, (uint64_t)v26);
    llvm::report_fatal_error((llvm::Twine *)v26, 1);
  }
  mlir::OperationState::OperationState(v27, v10, v12);
  mlir::mps::ReductionArgMinOp::build(a2, (uint64_t)v27, a3, a4, a5);
  uint64_t v14 = mlir::OpBuilder::create((mlir::OpBuilder *)a2, (const mlir::OperationState *)v27);
  if (!v14)
  {
    BOOL v17 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v18 = 662;
    uint64_t v19 = "Casting.h";
    uint64_t v20 = "dyn_cast";
    goto LABEL_9;
  }
  uint64_t v15 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionArgMinOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionArgMinOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v14);
  if (!v15)
  {
    BOOL v17 = "result && \"builder didn't return the right type\"";
    int v18 = 497;
    uint64_t v19 = "Builders.h";
    uint64_t v20 = "create";
LABEL_9:
    __assert_rtn(v20, v19, v18, v17);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v27);
  if (!*(_DWORD *)(v15 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  return v15 - 16;
}

void sub_180DADE44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DADE58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

_anonymous_namespace_::ReducePatternBase *anonymous namespace'::ReducePatternBase::ReducePatternBase(_anonymous_namespace_::ReducePatternBase *this, const char *__s, char a3, char a4)
{
  size_t v8 = strlen(__s);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v9 = v8;
  if (v8 >= 0x17)
  {
    uint64_t v12 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v12 = v8 | 7;
    }
    uint64_t v13 = v12 + 1;
    p_dst = (long long *)operator new(v12 + 1);
    *((void *)&__dst + 1) = v9;
    unint64_t v17 = v13 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
LABEL_9:
    memcpy(p_dst, __s, v9);
    *((unsigned char *)p_dst + v9) = 0;
    *(void *)this = &unk_1EC995CF0;
    uint64_t v11 = (std::string *)((char *)this + 8);
    if ((SHIBYTE(v17) & 0x80000000) == 0) {
      goto LABEL_5;
    }
LABEL_10:
    uint64_t v14 = (void *)__dst;
    std::string::__init_copy_ctor_external(v11, (const std::string::value_type *)__dst, *((std::string::size_type *)&__dst + 1));
    operator delete(v14);
    goto LABEL_11;
  }
  HIBYTE(v17) = v8;
  p_dst = &__dst;
  if (v8) {
    goto LABEL_9;
  }
  LOBYTE(__dst) = 0;
  *(void *)this = &unk_1EC995CF0;
  uint64_t v11 = (std::string *)((char *)this + 8);
  if (SHIBYTE(v17) < 0) {
    goto LABEL_10;
  }
LABEL_5:
  *(_OWORD *)&v11->__r_.__value_.__l.__data_ = __dst;
  v11->__r_.__value_.__r.__words[2] = v17;
LABEL_11:
  *(void *)this = &unk_1EC998C00;
  *((unsigned char *)this + 32) = a4;
  *((unsigned char *)this + 33) = a3;
  return this;
}

void sub_180DADFD8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReductionArgMinOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionArgMinOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 20
      && *(void *)AttrData == 0x756465722E73706DLL
      && *(void *)(AttrData + 8) == 0x72615F6E6F697463
      && *(_DWORD *)(AttrData + 16) == 1852403047)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.reduction_argmin";
      v9[3] = 20;
      uint64_t v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionArgMinOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::ReduceArgMaxPattern::~ReduceArgMaxPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::OneToOneReducePattern<mlir::mps::ReductionArgMaxOp>::lower(uint64_t a1, mlir::UnitAttr **a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6)
{
  v27[38] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *a6;
  uint64_t v21 = *a6;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v21);
  uint64_t v12 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_argmax", (const unsigned __int8 *)0x14, Context);
  if (!v13)
  {
    __int16 v25 = 1283;
    v24[2] = (uint64_t)"mps.reduction_argmax";
    v24[3] = 20;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v23 = 259;
    llvm::operator+(v24, (uint64_t *)&v22, (uint64_t)v26);
    llvm::report_fatal_error((llvm::Twine *)v26, 1);
  }
  mlir::OperationState::OperationState(v27, v10, v12);
  mlir::mps::ReductionArgMaxOp::build(a2, (uint64_t)v27, a3, a4, a5);
  uint64_t v14 = mlir::OpBuilder::create((mlir::OpBuilder *)a2, (const mlir::OperationState *)v27);
  if (!v14)
  {
    unint64_t v17 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v18 = 662;
    uint64_t v19 = "Casting.h";
    uint64_t v20 = "dyn_cast";
    goto LABEL_9;
  }
  uint64_t v15 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionArgMaxOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionArgMaxOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v14);
  if (!v15)
  {
    unint64_t v17 = "result && \"builder didn't return the right type\"";
    int v18 = 497;
    uint64_t v19 = "Builders.h";
    uint64_t v20 = "create";
LABEL_9:
    __assert_rtn(v20, v19, v18, v17);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v27);
  if (!*(_DWORD *)(v15 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  return v15 - 16;
}

void sub_180DAE37C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DAE390(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReductionArgMaxOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionArgMaxOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 20
      && *(void *)AttrData == 0x756465722E73706DLL
      && *(void *)(AttrData + 8) == 0x72615F6E6F697463
      && *(_DWORD *)(AttrData + 16) == 2019650919)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.reduction_argmax";
      v9[3] = 20;
      uint64_t v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionArgMaxOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::ReduceL1NormPattern::~ReduceL1NormPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::ReduceL1NormPattern::lower(uint64_t a1, mlir::OpBuilder *a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6)
{
  v29[38] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = a3;
  uint64_t v10 = mlir::OpBuilder::create<mlir::mps::AbsoluteOp,mlir::Value &>(a2, *a6, &v22);
  uint64_t v11 = *a6;
  uint64_t v23 = v11;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v23);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_sum", (const unsigned __int8 *)0x11, Context);
  if (!v14)
  {
    __int16 v27 = 1283;
    unint64_t v26[2] = (uint64_t)"mps.reduction_sum";
    v26[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v25 = 259;
    llvm::operator+(v26, (uint64_t *)&v24, (uint64_t)v28);
    llvm::report_fatal_error((llvm::Twine *)v28, 1);
  }
  mlir::OperationState::OperationState(v29, v11, v13);
  if (!*(_DWORD *)(v10 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ReductionSumOp::build((mlir::UnitAttr **)a2, (uint64_t)v29, v10 - 16, a4, a5);
  uint64_t v15 = mlir::OpBuilder::create(a2, (const mlir::OperationState *)v29);
  if (!v15)
  {
    int v18 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v19 = 662;
    uint64_t v20 = "Casting.h";
    uint64_t v21 = "dyn_cast";
    goto LABEL_11;
  }
  uint64_t v16 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionSumOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionSumOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
  if (!v16)
  {
    int v18 = "result && \"builder didn't return the right type\"";
    int v19 = 497;
    uint64_t v20 = "Builders.h";
    uint64_t v21 = "create";
LABEL_11:
    __assert_rtn(v21, v20, v19, v18);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  if (!*(_DWORD *)(v16 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  return v16 - 16;
}

void sub_180DAE774(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DAE788(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReductionSumOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionSumOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 17
      && *(void *)AttrData == 0x756465722E73706DLL
      && *(void *)(AttrData + 8) == 0x75735F6E6F697463
      && *(unsigned char *)(AttrData + 16) == 109)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.reduction_sum";
      v9[3] = 17;
      uint64_t v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionSumOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::ReduceL2NormPattern::~ReduceL2NormPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::ReduceL2NormPattern::lower(uint64_t a1, mlir::OpBuilder *a2, uint64_t a3, uint64_t a4, unsigned __int8 a5, uint64_t *a6)
{
  v30[38] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = a4;
  uint64_t v23 = a3;
  unsigned __int8 v21 = a5;
  uint64_t v20 = mlir::OpBuilder::create<mlir::mps::SquareOp,mlir::Value &>(a2, *a6, &v23);
  uint64_t v8 = mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::mps::SquareOp &,mlir::Value &,BOOL &>((mlir::UnitAttr **)a2, *a6, (uint64_t)&v20, &v22, &v21);
  uint64_t v9 = *a6;
  uint64_t v24 = v9;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.square_root", (const unsigned __int8 *)0xF, Context);
  if (!v12)
  {
    __int16 v28 = 1283;
    v27[2] = (uint64_t)"mps.square_root";
    v27[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v30, v9, v11);
  if (!*(_DWORD *)(v8 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ACosOp::build((uint64_t)a2, (uint64_t)v30, v8 - 16);
  uint64_t v13 = mlir::OpBuilder::create(a2, (const mlir::OperationState *)v30);
  if (!v13)
  {
    uint64_t v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v17 = 662;
    int v18 = "Casting.h";
    int v19 = "dyn_cast";
    goto LABEL_11;
  }
  uint64_t v14 = llvm::DefaultDoCastIfPossible<mlir::mps::SquareRootOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SquareRootOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    uint64_t v16 = "result && \"builder didn't return the right type\"";
    int v17 = 497;
    int v18 = "Builders.h";
    int v19 = "create";
LABEL_11:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  if (!*(_DWORD *)(v14 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  return v14 - 16;
}

void sub_180DAEB70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
}

void sub_180DAEB84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::mps::SquareOp &,mlir::Value &,BOOL &>(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned __int8 *a5)
{
  v26[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_sum", (const unsigned __int8 *)0x11, Context);
  if (!v12)
  {
    __int16 v24 = 1283;
    v23[2] = (uint64_t)"mps.reduction_sum";
    v23[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v11);
  if (!*(_DWORD *)(*(void *)a3 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ReductionSumOp::build(a1, (uint64_t)v26, *(void *)a3 - 16, *a4, *a5);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v26);
  if (!v13)
  {
    uint64_t v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v17 = 662;
    int v18 = "Casting.h";
    int v19 = "dyn_cast";
    goto LABEL_10;
  }
  uint64_t v14 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionSumOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionSumOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    uint64_t v16 = "result && \"builder didn't return the right type\"";
    int v17 = 497;
    int v18 = "Builders.h";
    int v19 = "create";
LABEL_10:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v14;
}

void sub_180DAED58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DAED70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SquareRootOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SquareRootOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 15 && *AttrData == 0x617571732E73706DLL && *(void *)((char *)AttrData + 7) == 0x746F6F725F657261)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.square_root";
      v8[3] = 15;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SquareRootOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::ReduceLogSumExpPattern::~ReduceLogSumExpPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

char *anonymous namespace'::OneToOneReducePattern<mlir::mps::ReductionLogSumExpOp>::lower(uint64_t a1, mlir::UnitAttr **a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6)
{
  v35[38] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *a6;
  uint64_t v27 = *a6;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v27);
  uint64_t v12 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_logsumexp", (const unsigned __int8 *)0x17, Context);
  if (!v13)
  {
    __int16 v33 = 1283;
    uint64_t v31 = "mps.reduction_logsumexp";
    uint64_t v32 = 23;
                      "een added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-de"
                      "pendent-whats-up-with-dialects-management";
    __int16 v29 = 259;
    llvm::operator+(v30, v28, (uint64_t)v34);
    llvm::report_fatal_error((llvm::Twine *)v34, 1);
  }
  mlir::OperationState::OperationState(v35, v10, v12);
  mlir::mps::ReductionLogSumExpOp::build(a2, (uint64_t)v35, a3, a4, a5);
  uint64_t v14 = mlir::OpBuilder::create((mlir::OpBuilder *)a2, (const mlir::OperationState *)v35);
  uint64_t v15 = v14;
  if (!v14)
  {
    int v19 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v20 = 662;
    unsigned __int8 v21 = "Casting.h";
    __int16 v22 = "dyn_cast";
    goto LABEL_21;
  }
  uint64_t v16 = *((void *)v14 + 6);
  int v17 = *(void **)(v16 + 16);
  if (v17 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v34[0] = *(void *)(v16 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v34);
    if (v24 == 23)
    {
      BOOL v25 = *AttrData == 0x756465722E73706DLL && AttrData[1] == 0x6F6C5F6E6F697463;
      if (v25 && *(void *)((char *)AttrData + 15) == 0x7078656D7573676FLL)
      {
        __int16 v33 = 1283;
        v30[0] = (uint64_t)"classof on '";
        uint64_t v31 = "mps.reduction_logsumexp";
        uint64_t v32 = 23;
        v28[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v29 = 259;
        llvm::operator+(v30, v28, (uint64_t)v34);
        llvm::report_fatal_error((llvm::Twine *)v34, 1);
      }
    }
    goto LABEL_20;
  }
  if (v17 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionLogSumExpOp,void>::id)
  {
LABEL_20:
    int v19 = "result && \"builder didn't return the right type\"";
    int v20 = 497;
    unsigned __int8 v21 = "Builders.h";
    __int16 v22 = "create";
LABEL_21:
    __assert_rtn(v22, v21, v20, v19);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v35);
  if (!*((_DWORD *)v15 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  return (char *)v15 - 16;
}

void sub_180DAF1D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DAF1E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void anonymous namespace'::ReduceLogSumPattern::~ReduceLogSumPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::ReduceLogSumPattern::lower(uint64_t a1, mlir::UnitAttr **a2, uint64_t a3, uint64_t a4, unsigned __int8 a5, uint64_t *a6)
{
  v29[38] = *MEMORY[0x1E4F143B8];
  uint64_t v21 = a4;
  uint64_t v22 = a3;
  unsigned __int8 v20 = a5;
  uint64_t v8 = mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::Value &,mlir::Value &,BOOL &>(a2, *a6, &v22, &v21, &v20);
  uint64_t v9 = *a6;
  uint64_t v23 = v9;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v23);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.logarithm", (const unsigned __int8 *)0xD, Context);
  if (!v12)
  {
    __int16 v27 = 1283;
    unint64_t v26[2] = (uint64_t)"mps.logarithm";
    v26[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v25 = 259;
    llvm::operator+(v26, (uint64_t *)&v24, (uint64_t)v28);
    llvm::report_fatal_error((llvm::Twine *)v28, 1);
  }
  mlir::OperationState::OperationState(v29, v9, v11);
  if (!*((_DWORD *)v8 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ACosOp::build((uint64_t)a2, (uint64_t)v29, (uint64_t)v8 - 16);
  char v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a2, (const mlir::OperationState *)v29);
  if (!v13)
  {
    uint64_t v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v17 = 662;
    int v18 = "Casting.h";
    int v19 = "dyn_cast";
    goto LABEL_11;
  }
  uint64_t v14 = llvm::DefaultDoCastIfPossible<mlir::mps::LogarithmOp,mlir::Operation *,llvm::CastInfo<mlir::mps::LogarithmOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    uint64_t v16 = "result && \"builder didn't return the right type\"";
    int v17 = 497;
    int v18 = "Builders.h";
    int v19 = "create";
LABEL_11:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  if (!*(_DWORD *)(v14 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  return v14 - 16;
}

void sub_180DAF4BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
}

void sub_180DAF4D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
}

void anonymous namespace'::ReduceMaxPattern::~ReduceMaxPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::OneToOneReducePattern<mlir::mps::ReductionMaxOp>::lower(uint64_t a1, mlir::UnitAttr **a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6)
{
  v27[38] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *a6;
  uint64_t v21 = *a6;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v21);
  uint64_t v12 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_max", (const unsigned __int8 *)0x11, Context);
  if (!v13)
  {
    __int16 v25 = 1283;
    v24[2] = (uint64_t)"mps.reduction_max";
    v24[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v23 = 259;
    llvm::operator+(v24, (uint64_t *)&v22, (uint64_t)v26);
    llvm::report_fatal_error((llvm::Twine *)v26, 1);
  }
  mlir::OperationState::OperationState(v27, v10, v12);
  mlir::mps::ReductionMaxOp::build(a2, (uint64_t)v27, a3, a4, a5, 0);
  uint64_t v14 = mlir::OpBuilder::create((mlir::OpBuilder *)a2, (const mlir::OperationState *)v27);
  if (!v14)
  {
    int v17 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v18 = 662;
    int v19 = "Casting.h";
    unsigned __int8 v20 = "dyn_cast";
    goto LABEL_9;
  }
  uint64_t v15 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionMaxOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionMaxOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v14);
  if (!v15)
  {
    int v17 = "result && \"builder didn't return the right type\"";
    int v18 = 497;
    int v19 = "Builders.h";
    unsigned __int8 v20 = "create";
LABEL_9:
    __assert_rtn(v20, v19, v18, v17);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v27);
  if (!*(_DWORD *)(v15 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  return v15 - 16;
}

void sub_180DAF774(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DAF788(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void anonymous namespace'::ReduceMeanPattern::~ReduceMeanPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::OneToOneReducePattern<mlir::mps::ReductionMeanOp>::lower(uint64_t a1, mlir::UnitAttr **a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6)
{
  v27[38] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *a6;
  uint64_t v21 = *a6;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v21);
  uint64_t v12 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_mean", (const unsigned __int8 *)0x12, Context);
  if (!v13)
  {
    __int16 v25 = 1283;
    v24[2] = (uint64_t)"mps.reduction_mean";
    v24[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v23 = 259;
    llvm::operator+(v24, (uint64_t *)&v22, (uint64_t)v26);
    llvm::report_fatal_error((llvm::Twine *)v26, 1);
  }
  mlir::OperationState::OperationState(v27, v10, v12);
  mlir::mps::ReductionMeanOp::build(a2, (uint64_t)v27, a3, a4, a5);
  uint64_t v14 = mlir::OpBuilder::create((mlir::OpBuilder *)a2, (const mlir::OperationState *)v27);
  if (!v14)
  {
    int v17 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v18 = 662;
    int v19 = "Casting.h";
    unsigned __int8 v20 = "dyn_cast";
    goto LABEL_9;
  }
  uint64_t v15 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionMeanOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionMeanOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v14);
  if (!v15)
  {
    int v17 = "result && \"builder didn't return the right type\"";
    int v18 = 497;
    int v19 = "Builders.h";
    unsigned __int8 v20 = "create";
LABEL_9:
    __assert_rtn(v20, v19, v18, v17);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v27);
  if (!*(_DWORD *)(v15 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  return v15 - 16;
}

void sub_180DAFA28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DAFA3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void anonymous namespace'::ReduceMinPattern::~ReduceMinPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::OneToOneReducePattern<mlir::mps::ReductionMinOp>::lower(uint64_t a1, mlir::UnitAttr **a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6)
{
  v27[38] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *a6;
  uint64_t v21 = *a6;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v21);
  uint64_t v12 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_min", (const unsigned __int8 *)0x11, Context);
  if (!v13)
  {
    __int16 v25 = 1283;
    v24[2] = (uint64_t)"mps.reduction_min";
    v24[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v23 = 259;
    llvm::operator+(v24, (uint64_t *)&v22, (uint64_t)v26);
    llvm::report_fatal_error((llvm::Twine *)v26, 1);
  }
  mlir::OperationState::OperationState(v27, v10, v12);
  mlir::mps::ReductionMinOp::build(a2, (uint64_t)v27, a3, a4, a5, 0);
  uint64_t v14 = mlir::OpBuilder::create((mlir::OpBuilder *)a2, (const mlir::OperationState *)v27);
  if (!v14)
  {
    int v17 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v18 = 662;
    int v19 = "Casting.h";
    unsigned __int8 v20 = "dyn_cast";
    goto LABEL_9;
  }
  uint64_t v15 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionMinOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionMinOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v14);
  if (!v15)
  {
    int v17 = "result && \"builder didn't return the right type\"";
    int v18 = 497;
    int v19 = "Builders.h";
    unsigned __int8 v20 = "create";
LABEL_9:
    __assert_rtn(v20, v19, v18, v17);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v27);
  if (!*(_DWORD *)(v15 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  return v15 - 16;
}

void sub_180DAFCE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DAFCF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void anonymous namespace'::ReduceProdPattern::~ReduceProdPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::OneToOneReducePattern<mlir::mps::ReductionProdOp>::lower(uint64_t a1, mlir::UnitAttr **a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6)
{
  v27[38] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *a6;
  uint64_t v21 = *a6;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v21);
  uint64_t v12 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_prod", (const unsigned __int8 *)0x12, Context);
  if (!v13)
  {
    __int16 v25 = 1283;
    v24[2] = (uint64_t)"mps.reduction_prod";
    v24[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v23 = 259;
    llvm::operator+(v24, (uint64_t *)&v22, (uint64_t)v26);
    llvm::report_fatal_error((llvm::Twine *)v26, 1);
  }
  mlir::OperationState::OperationState(v27, v10, v12);
  mlir::mps::ReductionProdOp::build(a2, (uint64_t)v27, a3, a4, a5);
  uint64_t v14 = mlir::OpBuilder::create((mlir::OpBuilder *)a2, (const mlir::OperationState *)v27);
  if (!v14)
  {
    int v17 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v18 = 662;
    int v19 = "Casting.h";
    unsigned __int8 v20 = "dyn_cast";
    goto LABEL_9;
  }
  uint64_t v15 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionProdOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionProdOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v14);
  if (!v15)
  {
    int v17 = "result && \"builder didn't return the right type\"";
    int v18 = 497;
    int v19 = "Builders.h";
    unsigned __int8 v20 = "create";
LABEL_9:
    __assert_rtn(v20, v19, v18, v17);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v27);
  if (!*(_DWORD *)(v15 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  return v15 - 16;
}

void sub_180DAFF94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DAFFA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReductionProdOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionProdOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 18
      && *(void *)AttrData == 0x756465722E73706DLL
      && *(void *)(AttrData + 8) == 0x72705F6E6F697463
      && *(_WORD *)(AttrData + 16) == 25711)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.reduction_prod";
      v9[3] = 18;
      __int16 v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionProdOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::ReduceSumPattern::~ReduceSumPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

char *anonymous namespace'::OneToOneReducePattern<mlir::mps::ReductionSumOp>::lower(uint64_t a1, mlir::UnitAttr **a2, uint64_t a3, uint64_t a4, unsigned __int8 a5, uint64_t *a6)
{
  uint64_t v10 = a3;
  uint64_t v9 = a4;
  unsigned __int8 v8 = a5;
  __int16 v6 = mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::Value &,mlir::Value &,BOOL &>(a2, *a6, &v10, &v9, &v8);
  if (!*((_DWORD *)v6 + 9)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  return (char *)v6 - 16;
}

void anonymous namespace'::ReduceSumSquarePattern::~ReduceSumSquarePattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::ReduceSumSquarePattern::lower(uint64_t a1, mlir::OpBuilder *a2, uint64_t a3, uint64_t a4, unsigned __int8 a5, uint64_t *a6)
{
  uint64_t v12 = a4;
  uint64_t v13 = a3;
  unsigned __int8 v11 = a5;
  uint64_t v10 = mlir::OpBuilder::create<mlir::mps::SquareOp,mlir::Value &>(a2, *a6, &v13);
  uint64_t v8 = mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::mps::SquareOp &,mlir::Value &,BOOL &>((mlir::UnitAttr **)a2, *a6, (uint64_t)&v10, &v12, &v11);
  if (!*(_DWORD *)(v8 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  return v8 - 16;
}

void anonymous namespace'::ReshapePattern::~ReshapePattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::ReshapePattern::matchAndRewrite(_anonymous_namespace_::ReshapePattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t v151 = 0;
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  HIBYTE(v150) = 5;
  strcpy((char *)&ElementTypeOrSelf, "shape");
  uint64_t v131 = a2;
  Parameteruint64_t Value = (MIL::IRValue *)MIL::IROperation::TryGetParameterValue();
  __int16 v129 = (mlir::Builder *)(a3 + 18);
  int v130 = (int8x8_t *)a3;
  if (!ParameterValue) {
    goto LABEL_157;
  }
  HIBYTE(v148) = 1;
  LOWORD(v146) = 120;
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  uint64_t v7 = MIL::IRValueType::AsTensorType(ParameterType);
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 96))(v7);
  uint64_t ElementTypeOrSelf = 0;
  long long v150 = 0uLL;
  uint64_t v10 = *(const void **)v8;
  uint64_t v9 = *(void *)(v8 + 8);
  int64_t v11 = v9 - *(void *)v8;
  if (v9 == *(void *)v8)
  {
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    if (SHIBYTE(v148) < 0) {
LABEL_5:
    }
      operator delete(v146);
  }
  else
  {
    if (v11 < 0) {
      std::vector<int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = (char *)operator new(v9 - *(void *)v8);
    uint64_t v13 = &v12[8 * (v11 >> 3)];
    uint64_t ElementTypeOrSelf = v12;
    *((void *)&v150 + 1) = v13;
    memcpy(v12, v10, v11);
    *(void *)&long long v150 = v13;
    if (SHIBYTE(v148) < 0) {
      goto LABEL_5;
    }
  }
  int v146 = 0;
  uint64_t v147 = 0;
  uint64_t v148 = 0;
  uint64_t v14 = MIL::IRValue::AsTensor(ParameterValue);
  MEMORY[0x1852FD6B0](v144, v14);
  uint64_t v15 = MIL::IRValue::AsTensor(ParameterValue);
  MEMORY[0x1852FD6C0](v142, v15);
  uint64_t v16 = MIL::IRValue::AsTensor(ParameterValue);
  MEMORY[0x1852FD6A0](v140, v16);
  uint64_t v132 = v12;
  uint64_t v133 = v13;
  if (LOBYTE(v144[0]))
  {
    unint64_t v17 = v145;
    if (v145)
    {
      unint64_t v18 = 0;
      int v19 = (char *)v147;
      while (1)
      {
        int v21 = *(_DWORD *)(v144[1] + 4 * v18);
        if (v19 >= v148) {
          break;
        }
        *(_DWORD *)int v19 = v21;
        uint64_t v20 = (uint64_t)(v19 + 4);
LABEL_10:
        uint64_t v147 = (long long *)v20;
        ++v18;
        int v19 = (char *)v20;
        if (v18 >= v17) {
          goto LABEL_104;
        }
      }
      uint64_t v22 = v146;
      uint64_t v23 = (v19 - (char *)v146) >> 2;
      unint64_t v24 = v23 + 1;
      if ((unint64_t)(v23 + 1) >> 62) {
        std::vector<int>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v25 = v148 - (char *)v146;
      if ((v148 - (char *)v146) >> 1 > v24) {
        unint64_t v24 = v25 >> 1;
      }
      if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v26 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v26 = v24;
      }
      if (v26)
      {
        if (v26 >> 62) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        __int16 v27 = operator new(4 * v26);
        __int16 v28 = (long long *)&v27[4 * v23];
        *(_DWORD *)__int16 v28 = v21;
        uint64_t v20 = (uint64_t)v28 + 4;
        int64_t v29 = v19 - (char *)v22;
        if (v19 == (char *)v22) {
          goto LABEL_26;
        }
      }
      else
      {
        __int16 v27 = 0;
        __int16 v28 = (long long *)(4 * v23);
        *(_DWORD *)(4 * v23) = v21;
        uint64_t v20 = 4 * v23 + 4;
        int64_t v29 = v19 - (char *)v22;
        if (v19 == (char *)v22) {
          goto LABEL_26;
        }
      }
      unint64_t v30 = v29 - 4;
      if (v30 >= 0xBC)
      {
        unint64_t v33 = (v19 - 4 - (char *)v22) & 0xFFFFFFFFFFFFFFFCLL;
        if (&v27[v19 - (char *)v22 - 4 - v33] > &v27[v19 - (char *)v22 - 4])
        {
          uint64_t v31 = (long long *)v19;
        }
        else if (&v19[-v33 - 4] > v19 - 4)
        {
          uint64_t v31 = (long long *)v19;
        }
        else if ((unint64_t)((char *)v22 - v27) >= 0x20)
        {
          uint64_t v34 = (v30 >> 2) + 1;
          uint64_t v35 = 4 * (v34 & 0x7FFFFFFFFFFFFFF8);
          uint64_t v31 = (long long *)&v19[-v35];
          __int16 v28 = (long long *)((char *)v28 - v35);
          uint64_t v36 = &v27[4 * v23 - 16];
          uint64_t v37 = v19 - 16;
          uint64_t v38 = v34 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            long long v39 = *(_OWORD *)v37;
            *(v36 - 1) = *((_OWORD *)v37 - 1);
            *uint64_t v36 = v39;
            v36 -= 2;
            v37 -= 32;
            v38 -= 8;
          }
          while (v38);
          if (v34 == (v34 & 0x7FFFFFFFFFFFFFF8))
          {
LABEL_26:
            int v146 = v28;
            uint64_t v147 = (long long *)v20;
            uint64_t v148 = &v27[4 * v26];
            if (v22)
            {
              operator delete(v22);
              unint64_t v17 = v145;
            }
            goto LABEL_10;
          }
        }
        else
        {
          uint64_t v31 = (long long *)v19;
        }
      }
      else
      {
        uint64_t v31 = (long long *)v19;
      }
      do
      {
        int v32 = *((_DWORD *)v31 - 1);
        uint64_t v31 = (long long *)((char *)v31 - 4);
        *((_DWORD *)v28 - 1) = v32;
        __int16 v28 = (long long *)((char *)v28 - 4);
      }
      while (v31 != v22);
      goto LABEL_26;
    }
    goto LABEL_104;
  }
  if (!LOBYTE(v142[0]))
  {
    if (!LOBYTE(v140[0])) {
      goto LABEL_104;
    }
    unint64_t v63 = v141;
    if (!v141) {
      goto LABEL_104;
    }
    unint64_t v64 = 0;
    int v65 = (char *)v147;
    while (1)
    {
      int v67 = *(char *)(v140[1] + v64);
      if (v65 >= v148) {
        break;
      }
      *(_DWORD *)int v65 = v67;
      uint64_t v66 = (uint64_t)(v65 + 4);
LABEL_76:
      uint64_t v147 = (long long *)v66;
      ++v64;
      int v65 = (char *)v66;
      if (v64 >= v63) {
        goto LABEL_104;
      }
    }
    uint64_t v68 = v146;
    uint64_t v69 = (v65 - (char *)v146) >> 2;
    unint64_t v70 = v69 + 1;
    if ((unint64_t)(v69 + 1) >> 62) {
      std::vector<int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v71 = v148 - (char *)v146;
    if ((v148 - (char *)v146) >> 1 > v70) {
      unint64_t v70 = v71 >> 1;
    }
    if ((unint64_t)v71 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v72 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v72 = v70;
    }
    if (v72)
    {
      if (v72 >> 62) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v73 = operator new(4 * v72);
      uint64_t v74 = (long long *)&v73[4 * v69];
      *(_DWORD *)uint64_t v74 = v67;
      uint64_t v66 = (uint64_t)v74 + 4;
      int64_t v75 = v65 - (char *)v68;
      if (v65 == (char *)v68) {
        goto LABEL_92;
      }
    }
    else
    {
      uint64_t v73 = 0;
      uint64_t v74 = (long long *)(4 * v69);
      *(_DWORD *)(4 * v69) = v67;
      uint64_t v66 = 4 * v69 + 4;
      int64_t v75 = v65 - (char *)v68;
      if (v65 == (char *)v68) {
        goto LABEL_92;
      }
    }
    unint64_t v76 = v75 - 4;
    if (v76 >= 0xBC)
    {
      unint64_t v79 = (v65 - 4 - (char *)v68) & 0xFFFFFFFFFFFFFFFCLL;
      if (&v73[v65 - (char *)v68 - 4 - v79] > &v73[v65 - (char *)v68 - 4])
      {
        char v77 = (long long *)v65;
      }
      else if (&v65[-v79 - 4] > v65 - 4)
      {
        char v77 = (long long *)v65;
      }
      else if ((unint64_t)((char *)v68 - v73) >= 0x20)
      {
        uint64_t v80 = (v76 >> 2) + 1;
        uint64_t v81 = 4 * (v80 & 0x7FFFFFFFFFFFFFF8);
        char v77 = (long long *)&v65[-v81];
        uint64_t v74 = (long long *)((char *)v74 - v81);
        uint64_t v82 = &v73[4 * v69 - 16];
        char v83 = v65 - 16;
        uint64_t v84 = v80 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v85 = *(_OWORD *)v83;
          *(v82 - 1) = *((_OWORD *)v83 - 1);
          *uint64_t v82 = v85;
          v82 -= 2;
          v83 -= 32;
          v84 -= 8;
        }
        while (v84);
        if (v80 == (v80 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_92:
          int v146 = v74;
          uint64_t v147 = (long long *)v66;
          uint64_t v148 = &v73[4 * v72];
          if (v68)
          {
            operator delete(v68);
            unint64_t v63 = v141;
          }
          goto LABEL_76;
        }
      }
      else
      {
        char v77 = (long long *)v65;
      }
    }
    else
    {
      char v77 = (long long *)v65;
    }
    do
    {
      int v78 = *((_DWORD *)v77 - 1);
      char v77 = (long long *)((char *)v77 - 4);
      *((_DWORD *)v74 - 1) = v78;
      uint64_t v74 = (long long *)((char *)v74 - 4);
    }
    while (v77 != v68);
    goto LABEL_92;
  }
  unint64_t v40 = v143;
  if (v143)
  {
    unint64_t v41 = 0;
    int v42 = (char *)v147;
    while (1)
    {
      int v44 = *(__int16 *)(v142[1] + 2 * v41);
      if (v42 >= v148) {
        break;
      }
      *(_DWORD *)int v42 = v44;
      uint64_t v43 = (uint64_t)(v42 + 4);
LABEL_44:
      uint64_t v147 = (long long *)v43;
      ++v41;
      int v42 = (char *)v43;
      if (v41 >= v40) {
        goto LABEL_104;
      }
    }
    unint64_t v45 = v146;
    uint64_t v46 = (v42 - (char *)v146) >> 2;
    unint64_t v47 = v46 + 1;
    if ((unint64_t)(v46 + 1) >> 62) {
      std::vector<int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v48 = v148 - (char *)v146;
    if ((v148 - (char *)v146) >> 1 > v47) {
      unint64_t v47 = v48 >> 1;
    }
    if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v49 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v49 = v47;
    }
    if (v49)
    {
      if (v49 >> 62) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      size_t v50 = operator new(4 * v49);
      int64_t v51 = (long long *)&v50[4 * v46];
      *(_DWORD *)int64_t v51 = v44;
      uint64_t v43 = (uint64_t)v51 + 4;
      int64_t v52 = v42 - (char *)v45;
      if (v42 == (char *)v45) {
        goto LABEL_60;
      }
    }
    else
    {
      size_t v50 = 0;
      int64_t v51 = (long long *)(4 * v46);
      *(_DWORD *)(4 * v46) = v44;
      uint64_t v43 = 4 * v46 + 4;
      int64_t v52 = v42 - (char *)v45;
      if (v42 == (char *)v45) {
        goto LABEL_60;
      }
    }
    unint64_t v53 = v52 - 4;
    if (v53 >= 0xBC)
    {
      unint64_t v56 = (v42 - 4 - (char *)v45) & 0xFFFFFFFFFFFFFFFCLL;
      if (&v50[v42 - (char *)v45 - 4 - v56] > &v50[v42 - (char *)v45 - 4])
      {
        uint64_t v54 = (long long *)v42;
      }
      else if (&v42[-v56 - 4] > v42 - 4)
      {
        uint64_t v54 = (long long *)v42;
      }
      else if ((unint64_t)((char *)v45 - v50) >= 0x20)
      {
        uint64_t v57 = (v53 >> 2) + 1;
        uint64_t v58 = 4 * (v57 & 0x7FFFFFFFFFFFFFF8);
        uint64_t v54 = (long long *)&v42[-v58];
        int64_t v51 = (long long *)((char *)v51 - v58);
        long long v59 = &v50[4 * v46 - 16];
        int v60 = v42 - 16;
        uint64_t v61 = v57 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v62 = *(_OWORD *)v60;
          *(v59 - 1) = *((_OWORD *)v60 - 1);
          _OWORD *v59 = v62;
          v59 -= 2;
          v60 -= 32;
          v61 -= 8;
        }
        while (v61);
        if (v57 == (v57 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_60:
          int v146 = v51;
          uint64_t v147 = (long long *)v43;
          uint64_t v148 = &v50[4 * v49];
          if (v45)
          {
            operator delete(v45);
            unint64_t v40 = v143;
          }
          goto LABEL_44;
        }
      }
      else
      {
        uint64_t v54 = (long long *)v42;
      }
    }
    else
    {
      uint64_t v54 = (long long *)v42;
    }
    do
    {
      int v55 = *((_DWORD *)v54 - 1);
      uint64_t v54 = (long long *)((char *)v54 - 4);
      *((_DWORD *)v51 - 1) = v55;
      int64_t v51 = (long long *)((char *)v51 - 4);
    }
    while (v54 != v45);
    goto LABEL_60;
  }
LABEL_104:
  id v137 = 0;
  int v138 = 0;
  double v139 = 0;
  __int16 v86 = v146;
  uint64_t v87 = (char *)v147 - (char *)v146;
  if (v147 == v146) {
    goto LABEL_141;
  }
  if (v87 < 0) {
    std::vector<int>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v88 = (char *)operator new((char *)v147 - (char *)v146);
  char v89 = 0;
  unint64_t v90 = 0;
  unint64_t v91 = v87 >> 2;
  id v137 = v88;
  int v138 = v88;
  double v139 = &v88[4 * (v87 >> 2)];
  uint64_t v134 = (v133 - v132) >> 3;
  while (1)
  {
    unint64_t v92 = ~v90;
    uint64_t v87 = *((unsigned int *)v86 + v91 + ~v90);
    if (v87)
    {
      int v94 = (char *)v137;
      unint64_t v93 = (unint64_t)v138;
      uint64_t v95 = v139;
      if (v138 >= v139) {
        goto LABEL_122;
      }
      goto LABEL_111;
    }
    if ((uint64_t)(v134 + v92) >= 0) {
      break;
    }
    uint64_t v87 = 1;
    char v89 = 1;
    int v94 = (char *)v137;
    unint64_t v93 = (unint64_t)v138;
    uint64_t v95 = v139;
    if (v138 >= v139)
    {
LABEL_122:
      uint64_t v101 = (uint64_t)(v93 - (void)v94) >> 2;
      unint64_t v102 = v101 + 1;
      if ((unint64_t)(v101 + 1) >> 62) {
        std::vector<int>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v103 = v95 - v94;
      if (v103 >> 1 > v102) {
        unint64_t v102 = v103 >> 1;
      }
      if ((unint64_t)v103 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v104 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v104 = v102;
      }
      if (v104)
      {
        if (v104 >> 62) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        int v105 = (char *)operator new(4 * v104);
        int v106 = &v105[4 * v104];
        *(_DWORD *)int v105 = v87;
        uint64_t v107 = v105 + 4;
        if ((char *)v93 != v94) {
LABEL_131:
        }
          memmove(v107, v94, v93 - (void)v94);
      }
      else
      {
        int v105 = (char *)operator new(4uLL);
        int v106 = v105 + 4;
        *(_DWORD *)int v105 = v87;
        uint64_t v107 = v105 + 4;
        if ((char *)v93 != v94) {
          goto LABEL_131;
        }
      }
      id v137 = v105;
      int v138 = &v107[4 * v101];
      double v139 = v106;
      if (v94) {
        operator delete(v94);
      }
      goto LABEL_108;
    }
LABEL_111:
    if (v94 == (char *)v93)
    {
      *(_DWORD *)int v94 = v87;
      int v138 = v94 + 4;
    }
    else
    {
      uint64_t v96 = (int *)(v93 - 4);
      char v97 = (char *)v93;
      if (v93 >= 4)
      {
        do
        {
          int v98 = *v96++;
          *(_DWORD *)char v97 = v98;
          v97 += 4;
        }
        while ((unint64_t)v96 < v93);
      }
      int v138 = v97;
      if ((char *)v93 != v94 + 4) {
        memmove((void *)(v93 - 4 * ((uint64_t)(v93 - (void)(v94 + 4)) >> 2)), v94, v93 - (void)(v94 + 4));
      }
      *(_DWORD *)int v94 = v87;
    }
LABEL_108:
    ++v90;
    __int16 v86 = v146;
    unint64_t v91 = ((char *)v147 - (char *)v146) >> 2;
    if (v90 >= v91)
    {
      if (v89)
      {
        long long __p = (void *)((v138 - (unsigned char *)v137) >> 2);
        uint64_t IntegerType = mlir::Builder::getIntegerType(v129, 0x20u, 1);
        uint64_t v109 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&__p, 1, IntegerType, 0);
        uint64_t v99 = v132;
        if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v109)) {
          goto LABEL_175;
        }
        if (v109)
        {
          uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v109);
          if (!InterfaceFor)
          {
            uint64_t v111 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            int v112 = 98;
            uint64_t v113 = "InterfaceSupport.h";
            __int16 v114 = "Interface";
            goto LABEL_178;
          }
        }
        else
        {
          uint64_t InterfaceFor = 0;
        }
        uint64_t v87 = mlir::DenseElementsAttr::getFromRawBuffer(v109, InterfaceFor, v137, v138 - (unsigned char *)v137, 4, 1, 1);
        if (mlir::DenseIntElementsAttr::classof(v87))
        {
          long long __p = (void *)v87;
          uint64_t v117 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v129, LocationForOp, (uint64_t **)&__p);
          if (*((_DWORD *)v117 + 9))
          {
            char v116 = 0;
            uint64_t v115 = (char *)v117 - 16;
            uint64_t v151 = (uint64_t)v117 - 16;
            goto LABEL_149;
          }
          uint64_t v111 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
          int v112 = 984;
          uint64_t v113 = "Operation.h";
          __int16 v114 = "getOpResultImpl";
        }
        else
        {
LABEL_175:
          uint64_t v111 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
          int v112 = 566;
          uint64_t v113 = "Casting.h";
          __int16 v114 = "cast";
        }
LABEL_178:
        __assert_rtn(v114, v113, v112, v111);
      }
LABEL_141:
      uint64_t v115 = 0;
      char v116 = 0;
      uint64_t v99 = v132;
      goto LABEL_149;
    }
  }
  uint64_t v99 = v132;
  uint64_t v100 = (*(uint64_t (**)(void))(**(void **)&v132[8 * v134 + 8 * v92] + 16))(*(void *)&v132[8 * v134 + 8 * v92]);
  if (v100)
  {
    uint64_t v87 = (*(uint64_t (**)(uint64_t))(*(void *)v100 + 48))(v100);
    char v89 = 1;
    int v94 = (char *)v137;
    unint64_t v93 = (unint64_t)v138;
    uint64_t v95 = v139;
    if (v138 >= v139) {
      goto LABEL_122;
    }
    goto LABEL_111;
  }
  long long __p = operator new(0x38uLL);
  long long v136 = xmmword_181129E70;
  strcpy((char *)__p, "reshape with 0 (copy from input) targeting an unknown ");
  uint64_t v87 = MILToMLIRRewriter::notifyFailure((uint64_t)v130, (uint64_t)v131, (const std::string::value_type *)&__p);
  if (SHIBYTE(v136) < 0) {
    operator delete(__p);
  }
  uint64_t v115 = 0;
  char v116 = 1;
LABEL_149:
  if (v137)
  {
    int v138 = (char *)v137;
    operator delete(v137);
  }
  if (v146)
  {
    uint64_t v147 = v146;
    operator delete(v146);
  }
  if (v99) {
    operator delete(v99);
  }
  if ((v116 & 1) == 0)
  {
    if (!v115)
    {
LABEL_157:
      uint64_t v151 = MILToMLIRRewriter::getArgValue(v130, v131, "shape");
      uint64_t ElementTypeOrSelf = (char *)mlir::getElementTypeOrSelf(v151);
      if (!mlir::Type::isSignedInteger((mlir::Type *)&ElementTypeOrSelf, 32))
      {
        uint64_t v118 = mlir::Builder::getIntegerType(v129, 0x20u, 1);
        uint64_t ElementTypeOrSelf = (char *)mlir::TypeAttr::get(v118);
        uint64_t v119 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>((mlir::UnknownLoc **)v129, LocationForOp, &v151, (uint64_t *)&ElementTypeOrSelf);
        if (!*((_DWORD *)v119 + 9)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        uint64_t v151 = (uint64_t)v119 - 16;
      }
    }
    if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)v131 + 192))(v131) == 1)
    {
      unint64_t v120 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,mlir::Value&>((mlir::UnitAttr **)v129, LocationForOp, &ArgValue, &v151);
      (*(void (**)(char **__return_ptr, const MIL::IROperation *))(*(void *)v131 + 200))(&ElementTypeOrSelf, v131);
      if (!*((_DWORD *)v120 + 9)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
      unsigned int v121 = (long long *)ElementTypeOrSelf;
      char v122 = (char *)operator new(8uLL);
      *(void *)char v122 = (char *)v120 - 16;
      int v146 = v121;
      uint64_t v123 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)&v130[8], (uint64_t)v121, (uint64_t)&std::piecewise_construct, &v146);
      std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v123 + 5, v122, v122 + 8, 1uLL);
      operator delete(v122);
      uint64_t v124 = ElementTypeOrSelf;
      if (ElementTypeOrSelf)
      {
        uint64_t v125 = (char *)v150;
        int v126 = ElementTypeOrSelf;
        if ((char *)v150 != ElementTypeOrSelf)
        {
          do
          {
            if (*(v125 - 1) < 0) {
              operator delete(*((void **)v125 - 3));
            }
            v125 -= 24;
          }
          while (v125 != v124);
          int v126 = ElementTypeOrSelf;
        }
        *(void *)&long long v150 = v124;
        operator delete(v126);
      }
      return 1;
    }
    else
    {
      uint64_t ElementTypeOrSelf = (char *)operator new(0x40uLL);
      long long v150 = xmmword_181129DA0;
      strcpy(ElementTypeOrSelf, "The number of outputs does not match the number of results.");
      uint64_t v87 = MILToMLIRRewriter::notifyFailure((uint64_t)v130, (uint64_t)v131, (const std::string::value_type *)&ElementTypeOrSelf);
      if (SHIBYTE(v150) < 0) {
        operator delete(ElementTypeOrSelf);
      }
    }
  }
  return v87;
}

void sub_180DB1154(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a21)
  {
    operator delete(a21);
    unint64_t v24 = *(void **)(v22 - 152);
    if (!v24)
    {
LABEL_5:
      if (!a13) {
        goto LABEL_6;
      }
      goto LABEL_9;
    }
  }
  else
  {
    unint64_t v24 = *(void **)(v22 - 152);
    if (!v24) {
      goto LABEL_5;
    }
  }
  *(void *)(v22 - 144) = v24;
  operator delete(v24);
  if (!a13) {
LABEL_6:
  }
    _Unwind_Resume(exception_object);
LABEL_9:
  operator delete(a13);
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::SpaceToBatchPattern::~SpaceToBatchPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::SpaceToBatchPattern::matchAndRewrite(_anonymous_namespace_::SpaceToBatchPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  v140[1] = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v134 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "block_shape");
  __int16 v6 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 160))(a2);
  v133[0] = 0;
  v133[1] = 0;
  uint64_t v132 = v133;
  uint64_t v8 = v6 + 1;
  uint64_t v7 = *v6;
  if (*v6 == (const void **)(v6 + 1)) {
    goto LABEL_43;
  }
  do
  {
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&v132, (uint64_t *)v133, v7 + 4, (uint64_t)(v7 + 4));
    uint64_t v9 = (const void **)v7[1];
    if (v9)
    {
      do
      {
        uint64_t v10 = (const void ***)v9;
        uint64_t v9 = (const void **)*v9;
      }
      while (v9);
    }
    else
    {
      do
      {
        uint64_t v10 = (const void ***)v7[2];
        BOOL v11 = *v10 == v7;
        uint64_t v7 = (const void **)v10;
      }
      while (!v11);
    }
    uint64_t v7 = (const void **)v10;
  }
  while (v10 != v8);
  uint64_t v117 = LocationForOp;
  uint64_t v118 = (mlir::OpBuilder *)(a3 + 18);
  uint64_t v12 = v133[0];
  __s2[23] = 8;
  strcpy(__s2, "paddings");
  if (!v133[0]) {
    goto LABEL_43;
  }
  uint64_t v13 = v133;
  do
  {
    uint64_t v14 = v12;
    uint64_t v15 = v13;
    unint64_t v17 = v12 + 32;
    uint64_t v16 = (char *)*((void *)v12 + 4);
    unint64_t v18 = v14[55];
    int v19 = (char)v18;
    if ((v18 & 0x80u) != 0) {
      unint64_t v18 = *((void *)v14 + 5);
    }
    if (v19 >= 0) {
      uint64_t v20 = v17;
    }
    else {
      uint64_t v20 = v16;
    }
    if (v18 >= 8) {
      size_t v21 = 8;
    }
    else {
      size_t v21 = v18;
    }
    BOOL v22 = v18 < 8;
    int v23 = memcmp(v20, __s2, v21);
    if (v23) {
      BOOL v22 = v23 < 0;
    }
    unint64_t v24 = (char **)(v14 + 8);
    if (v22)
    {
      uint64_t v13 = v15;
    }
    else
    {
      unint64_t v24 = (char **)v14;
      uint64_t v13 = (char **)v14;
    }
    uint64_t v12 = *v24;
  }
  while (v12);
  if (v13 == v133) {
    goto LABEL_43;
  }
  uint64_t v25 = (char *)(v15 + 4);
  if (v22) {
    unint64_t v26 = v15;
  }
  else {
    unint64_t v26 = v14;
  }
  if (!v22) {
    uint64_t v25 = v17;
  }
  unint64_t v27 = *((unsigned __int8 *)v13 + 55);
  int v28 = (char)v27;
  unint64_t v30 = (char *)v26[4];
  unint64_t v29 = v26[5];
  if ((v27 & 0x80u) != 0) {
    unint64_t v27 = v29;
  }
  if (v28 >= 0) {
    uint64_t v31 = v25;
  }
  else {
    uint64_t v31 = v30;
  }
  if (v27 >= 8) {
    size_t v32 = 8;
  }
  else {
    size_t v32 = v27;
  }
  BOOL v33 = v27 > 8;
  int v34 = memcmp(__s2, v31, v32);
  BOOL v35 = v34 < 0;
  if (!v34) {
    BOOL v35 = v33;
  }
  if (v35)
  {
LABEL_43:
    *(void *)uint64_t __s2 = operator new(0x30uLL);
    *(_OWORD *)&__s2[8] = xmmword_181129DC0;
    strcpy(*(char **)__s2, "Could not find parameter with name 'paddings'.");
    uint64_t v36 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
    goto LABEL_44;
  }
  if (v22) {
    long long v39 = v15;
  }
  else {
    long long v39 = v14;
  }
  if (v39[8] - v39[7] != 16)
  {
    *(void *)uint64_t __s2 = operator new(0x28uLL);
    *(_OWORD *)&__s2[8] = xmmword_1811286F0;
    strcpy(*(char **)__s2, "Unexpected argument size for 'paddings'");
    uint64_t v36 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
    goto LABEL_44;
  }
  __s2[23] = 8;
  strcpy(__s2, "paddings");
  Parameteruint64_t Value = MIL::IROperation::TryGetParameterValue();
  if ((__s2[23] & 0x80000000) != 0) {
    operator delete(*(void **)__s2);
  }
  (*(void (**)(uint64_t))(*(void *)ParameterValue + 40))(ParameterValue);
  uint64_t Data = MIL::IRTensorValue::GetDataView<int>();
  uint64_t v43 = v42;
  __s2[23] = 11;
  strcpy(__s2, "block_shape");
  uint64_t v44 = MIL::IROperation::TryGetParameterValue();
  if ((__s2[23] & 0x80000000) != 0) {
    operator delete(*(void **)__s2);
  }
  (*(void (**)(uint64_t))(*(void *)v44 + 40))(v44);
  MIL::IRTensorValue::GetDataView<int>();
  uint64_t v46 = v45;
  __s2[23] = 1;
  strcpy(__s2, "x");
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  uint64_t v48 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(ParameterType);
  uint64_t v49 = MIL::IRTensorValueType::Rank(v48);
  if ((__s2[23] & 0x80000000) != 0) {
    operator delete(*(void **)__s2);
  }
  int v50 = 2 * v46;
  if (v43 != 2 * v46)
  {
    *(void *)uint64_t __s2 = operator new(0x38uLL);
    *(_OWORD *)&__s2[8] = xmmword_181129E00;
    strcpy(*(char **)__s2, "Unexpected length for 'paddings' or 'block_shape'");
    uint64_t v36 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
LABEL_44:
    uint64_t v37 = v36;
    if ((__s2[23] & 0x80000000) != 0) {
      operator delete(*(void **)__s2);
    }
    goto LABEL_46;
  }
  *(void *)uint64_t __s2 = (int)v46;
  int v138 = v140;
  uint64_t v139 = 0x100000000;
  llvm::SmallVectorImpl<long long>::append<long long const*,void>((uint64_t)&v138, __s2, &__s2[8]);
  uint64_t v51 = (uint64_t)v138;
  uint64_t v52 = v139;
  *(void *)uint64_t __s2 = *(void *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8;
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)__s2);
  uint64_t v54 = mlir::IntegerType::get(Context, 0x20u, 1u);
  int v55 = (uint64_t **)mlir::RankedTensorType::get(v51, v52, v54, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v55))
  {
    uint64_t v57 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v58 = 566;
    long long v59 = "Casting.h";
    int v60 = "cast";
LABEL_133:
    __assert_rtn(v60, v59, v58, v57);
  }
  if (v55)
  {
    uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v55);
    if (!InterfaceFor)
    {
      uint64_t v57 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v58 = 98;
      long long v59 = "InterfaceSupport.h";
      int v60 = "Interface";
      goto LABEL_133;
    }
  }
  else
  {
    uint64_t InterfaceFor = 0;
  }
  int v130 = v55;
  uint64_t v131 = InterfaceFor;
  uint64_t v127 = 0;
  uint64_t v128 = 0;
  __int16 v129 = 0;
  if (v46 << 32)
  {
    if (v46 << 32 < 0) {
      std::vector<int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v61 = (int32x4_t *)operator new((4 * v46) & 0x3FFFFFFFFLL);
    uint64_t v127 = v61;
    __int16 v129 = &v61->i8[4 * (int)v46];
    bzero(v61, (4 * v46) & 0x3FFFFFFFFLL);
    uint64_t v115 = &v61->i8[(4 * v46) & 0x3FFFFFFFFLL];
    uint64_t v128 = v115;
  }
  else
  {
    uint64_t v115 = 0;
    uint64_t v61 = 0;
  }
  if (v46)
  {
    if (v46 < 8uLL)
    {
      unint64_t v62 = 0;
LABEL_75:
      unint64_t v70 = v46 - v62;
      uint64_t v71 = &v61->i32[v62];
      __int32 v72 = v62 - v46;
      do
      {
        *v71++ = v72++;
        --v70;
      }
      while (v70);
      goto LABEL_77;
    }
    unint64_t v62 = v46 - (unint64_t)(v46 & 7);
    int32x4_t v63 = vdupq_n_s32(v46);
    int32x4_t v64 = (int32x4_t)xmmword_1810FFF10;
    int v65 = v61 + 1;
    v66.i64[0] = 0x400000004;
    v66.i64[1] = 0x400000004;
    v67.i64[0] = 0x800000008;
    v67.i64[1] = 0x800000008;
    unint64_t v68 = v62;
    do
    {
      int32x4_t v69 = vsubq_s32(v64, v63);
      v65[-1] = v69;
      int32x4_t *v65 = vaddq_s32(v69, v66);
      int32x4_t v64 = vaddq_s32(v64, v67);
      v65 += 2;
      v68 -= 8;
    }
    while (v68);
    if ((v46 & 7) != 0) {
      goto LABEL_75;
    }
  }
LABEL_77:
  *(void *)uint64_t __s2 = *(void *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8;
  char v116 = v61;
  uint64_t v73 = mlir::Attribute::getContext((mlir::Attribute *)__s2);
  uint64_t v74 = mlir::IntegerType::get(v73, 0x20u, 1u);
  __int16 v114 = (uint64_t **)mlir::RankedTensorType::get(0, 0, v74, 0);
  __src.__begin_ = (std::vector<int>::pointer)v49;
  __src.__end_ = (std::vector<int>::pointer)2;
  *(void *)uint64_t __s2 = &__s2[16];
  *(void *)&__s2[8] = 0x200000000;
  llvm::SmallVectorImpl<long long>::append<long long const*,void>((uint64_t)__s2, &__src, &__src.__end_cap_);
  uint64_t v75 = *(void *)__s2;
  uint64_t v76 = *(unsigned int *)&__s2[8];
  __src.__begin_ = (std::vector<int>::pointer)(*(void *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v77 = mlir::Attribute::getContext((mlir::Attribute *)&__src);
  uint64_t v78 = mlir::IntegerType::get(v77, 0x20u, 1u);
  unint64_t v79 = (uint64_t **)mlir::RankedTensorType::get(v75, v76, v78, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v79))
  {
    uint64_t v81 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v82 = 566;
    char v83 = "Casting.h";
    uint64_t v84 = "cast";
LABEL_135:
    __assert_rtn(v84, v83, v82, v81);
  }
  if (v79)
  {
    uint64_t v80 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v79);
    if (!v80)
    {
      uint64_t v81 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v82 = 98;
      char v83 = "InterfaceSupport.h";
      uint64_t v84 = "Interface";
      goto LABEL_135;
    }
  }
  else
  {
    uint64_t v80 = 0;
  }
  uint64_t v125 = v79;
  uint64_t v126 = v80;
  memset(&__src, 0, sizeof(__src));
  __x[0] = 0;
  if (v49) {
    std::vector<int>::__append(&__src, 2 * v49, __x);
  }
  if ((int)v46 >= 1)
  {
    uint64_t v85 = 0;
    char v86 = 0;
    if (v49 <= 0) {
      uint64_t v87 = 0;
    }
    else {
      uint64_t v87 = 2 * (v49 - (int)v46);
    }
    std::vector<int>::pointer begin = __src.__begin_;
    if (v50 <= 1) {
      uint64_t v89 = 1;
    }
    else {
      uint64_t v89 = v50;
    }
    unint64_t v90 = &__src.__begin_[v87];
    do
    {
      while (1)
      {
        if (v43 == v85)
        {
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "index out of bounds");
          exception->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x1E4FBA4B8] + 16);
          __cxa_throw(exception, (struct type_info *)off_1E4FBE4C0, MEMORY[0x1E4FBA1B8]);
        }
        int v91 = *(_DWORD *)(Data + 4 * v85);
        if (v91 <= 0) {
          break;
        }
        v90[v85] = v91;
        char v86 = 1;
        BOOL v11 = v89 - 1 == v85++;
        if (v11) {
          goto LABEL_100;
        }
      }
      ++v85;
    }
    while (v89 != v85);
    if ((v86 & 1) == 0) {
      goto LABEL_103;
    }
LABEL_100:
    uint64_t v124 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v125, v126, begin, (char *)__src.__end_ - (char *)begin, 4, 1, 1);
    uint64_t v92 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ShapedType &,mlir::DenseElementsAttr &>(v118, v117, (uint64_t *)&v125, &v124);
    if (!*(_DWORD *)(v92 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v123 = v92 - 16;
    uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
    *(void *)__x = 1;
    int v94 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__x, 1, ElementTypeOrSelf, 0);
    *(void *)__x = mlir::mps::getConstantAttr<int>(v94, 0);
    char v122 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v118, v117, (uint64_t **)__x);
    __x[0] = 0;
    uint64_t v95 = mlir::OpBuilder::create<mlir::mps::PadOp,mlir::Value &,mlir::Value &,mlir::mps::ConstantOp &,mlir::mps::PaddingMode>((mlir::MLIRContext **)v118, v117, &ArgValue, &v123, (uint64_t)&v122, (unsigned int *)__x);
    if (!*(_DWORD *)(v95 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    Arguint64_t Value = v95 - 16;
  }
LABEL_103:
  uint64_t v124 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v130, v131, v61, v115 - (__int8 *)v61, 4, 1, 1);
  uint64_t v96 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ShapedType &,mlir::DenseElementsAttr &>(v118, v117, (uint64_t *)&v130, &v124);
  if (!*(_DWORD *)(v96 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  uint64_t v123 = v96 - 16;
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v114))
  {
    int v98 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v99 = 566;
    uint64_t v100 = "Casting.h";
    uint64_t v101 = "cast";
LABEL_138:
    __assert_rtn(v101, v100, v99, v98);
  }
  if (v114)
  {
    uint64_t v97 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v114);
    if (!v97)
    {
      int v98 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      int v99 = 98;
      uint64_t v100 = "InterfaceSupport.h";
      uint64_t v101 = "Interface";
      goto LABEL_138;
    }
  }
  else
  {
    uint64_t v97 = 0;
  }
  int v121 = 0;
  uint64_t v102 = mlir::DenseElementsAttr::getFromRawBuffer(v114, v97, &v121, 4, 4, 1, 1);
  if (!mlir::DenseIntElementsAttr::classof(v102))
  {
    uint64_t v109 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v110 = 566;
    uint64_t v111 = "Casting.h";
    int v112 = "cast";
    goto LABEL_141;
  }
  *(void *)__x = v102;
  uint64_t v103 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v118, v117, (uint64_t **)__x);
  if (!*((_DWORD *)v103 + 9))
  {
    uint64_t v109 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    int v110 = 984;
    uint64_t v111 = "Operation.h";
    int v112 = "getOpResultImpl";
LABEL_141:
    __assert_rtn(v112, v111, v110, v109);
  }
  char v122 = (mlir::GenericProgramPoint *)((char *)v103 - 16);
  LOBYTE(__x[0]) = 0;
  unint64_t v104 = mlir::OpBuilder::create<mlir::mps::SpaceToBatchOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,BOOL>((mlir::UnitAttr **)v118, v117, &ArgValue, &v123, (uint64_t *)&v122, &v134, (unsigned __int8 *)__x);
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    (*(void (**)(std::vector<int>::value_type *__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(__x, a2);
    if (!*((_DWORD *)v104 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    MILToMLIRRewriter::setValue((uint64_t)a3, *(long long **)__x, (uint64_t)v104 - 16);
    int v105 = *(long long **)__x;
    int v106 = v116;
    if (*(void *)__x)
    {
      uint64_t v107 = (long long *)v120;
      uint64_t v108 = *(long long **)__x;
      if ((void)v120 != *(void *)__x)
      {
        do
        {
          if (*((char *)v107 - 1) < 0) {
            operator delete(*((void **)v107 - 3));
          }
          uint64_t v107 = (long long *)((char *)v107 - 24);
        }
        while (v107 != v105);
        uint64_t v108 = *(long long **)__x;
      }
      *(void *)&long long v120 = v105;
      operator delete(v108);
    }
    uint64_t v37 = 1;
  }
  else
  {
    *(void *)__x = operator new(0x40uLL);
    long long v120 = xmmword_181129DA0;
    strcpy(*(char **)__x, "The number of outputs does not match the number of results.");
    int v106 = v116;
    uint64_t v37 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__x);
    if (SHIBYTE(v120) < 0) {
      operator delete(*(void **)__x);
    }
  }
  if (__src.__begin_)
  {
    __src.__end_ = __src.__begin_;
    operator delete(__src.__begin_);
  }
  if (*(unsigned char **)__s2 != &__s2[16]) {
    free(*(void **)__s2);
  }
  if (v106) {
    operator delete(v106);
  }
  if (v138 != v140) {
    free(v138);
  }
LABEL_46:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v132, v133[0]);
  return v37;
}

void sub_180DB2014(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *__p, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,char *a36)
{
  unint64_t v40 = *(void **)(v36 - 176);
  if (v40)
  {
    *(void *)(v36 - 168) = v40;
    operator delete(v40);
    uint64_t v37 = *(void **)(v36 - 152);
    if (v37 != a12)
    {
LABEL_7:
      free(v37);
      uint64_t v38 = __p;
      if (!__p) {
        goto LABEL_9;
      }
      goto LABEL_8;
    }
  }
  else
  {
    uint64_t v37 = *(void **)(v36 - 152);
    if (v37 != a12) {
      goto LABEL_7;
    }
  }
  uint64_t v38 = __p;
  if (!__p)
  {
LABEL_9:
    unint64_t v41 = *(void **)(v36 - 120);
    if (v41 != a14) {
      free(v41);
    }
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a35, a36);
    _Unwind_Resume(a1);
  }
LABEL_8:
  operator delete(v38);
  goto LABEL_9;
}

uint64_t mlir::OpBuilder::create<mlir::mps::PadOp,mlir::Value &,mlir::Value &,mlir::mps::ConstantOp &,mlir::mps::PaddingMode>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5, unsigned int *a6)
{
  v28[38] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pad", (const unsigned __int8 *)7, Context);
  if (!v14)
  {
    __int16 v26 = 1283;
    v25[2] = (uint64_t)"mps.pad";
    v25[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v28, a2, v13);
  if (!*(_DWORD *)(*(void *)a5 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::PadOp::build(a1, (uint64_t)v28, *a3, *a4, *(void *)a5 - 16, *a6);
  uint64_t v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v28);
  if (!v15)
  {
    unint64_t v18 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v19 = 662;
    uint64_t v20 = "Casting.h";
    size_t v21 = "dyn_cast";
    goto LABEL_10;
  }
  uint64_t v16 = llvm::DefaultDoCastIfPossible<mlir::mps::PadOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PadOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
  if (!v16)
  {
    unint64_t v18 = "result && \"builder didn't return the right type\"";
    int v19 = 497;
    uint64_t v20 = "Builders.h";
    size_t v21 = "create";
LABEL_10:
    __assert_rtn(v21, v20, v19, v18);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v28);
  return v16;
}

void sub_180DB23D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DB23E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void std::vector<int>::__append(std::vector<int> *this, std::vector<int>::size_type __n, std::vector<int>::const_reference __x)
{
  std::vector<int>::pointer end = this->__end_;
  uint64_t value = this->__end_cap_.__value_;
  uint64_t v8 = end;
  if (__n <= value - end)
  {
    if (__n)
    {
      std::vector<int>::size_type v16 = (__n - 1) & 0x3FFFFFFFFFFFFFFFLL;
      if (v16 < 0xF || end < __x + 1 && &end[__n] > __x) {
        goto LABEL_45;
      }
      std::vector<int>::size_type v17 = v16 + 1;
      uint64_t v8 = &end[v17 & 0x7FFFFFFFFFFFFFF8];
      float32x4_t v18 = vld1q_dup_f32((const float *)__x);
      int v19 = (float32x4_t *)(end + 4);
      uint64_t v20 = v17 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        v19[-1] = v18;
        *int v19 = v18;
        v19 += 2;
        v20 -= 8;
      }
      while (v20);
      if (v17 != (v17 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_45:
        do
          *v8++ = *__x;
        while (v8 != &end[__n]);
      }
      uint64_t v8 = &end[__n];
    }
    this->__end_ = v8;
  }
  else
  {
    std::vector<int>::pointer begin = this->__begin_;
    uint64_t v10 = (char *)end - (char *)this->__begin_;
    uint64_t v11 = v10 >> 2;
    unint64_t v12 = (v10 >> 2) + __n;
    if (v12 >> 62) {
      std::vector<int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v13 = (char *)value - (char *)begin;
    if (v13 >> 1 > v12) {
      unint64_t v12 = v13 >> 1;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v14 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v12;
    }
    if (v14)
    {
      if (v14 >> 62) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v15 = operator new(4 * v14);
    }
    else
    {
      uint64_t v15 = 0;
    }
    size_t v21 = (int *)&v15[4 * v11];
    uint64_t v22 = &v21[__n];
    std::vector<int>::size_type v23 = (__n - 1) & 0x3FFFFFFFFFFFFFFFLL;
    __int16 v24 = v21;
    if (v23 < 0x13) {
      goto LABEL_46;
    }
    if (v21 < __x + 1)
    {
      __int16 v24 = (int *)&v15[4 * v11];
      if (&v15[4 * __n + v10] > (unsigned char *)__x) {
        goto LABEL_46;
      }
    }
    std::vector<int>::size_type v25 = v23 + 1;
    __int16 v24 = &v21[v25 & 0x7FFFFFFFFFFFFFF8];
    float32x4_t v26 = vld1q_dup_f32((const float *)__x);
    unint64_t v27 = (float32x4_t *)&v15[4 * v11 + 16];
    uint64_t v28 = v25 & 0x7FFFFFFFFFFFFFF8;
    do
    {
      v27[-1] = v26;
      float32x4_t *v27 = v26;
      v27 += 2;
      v28 -= 8;
    }
    while (v28);
    if (v25 != (v25 & 0x7FFFFFFFFFFFFFF8))
    {
LABEL_46:
      do
        *v24++ = *__x;
      while (v24 != v22);
    }
    if (end != begin)
    {
      unint64_t v29 = (char *)end - (char *)begin - 4;
      if (v29 < 0x2C) {
        goto LABEL_47;
      }
      if ((unint64_t)((char *)end - &v15[v10]) < 0x20) {
        goto LABEL_47;
      }
      uint64_t v30 = (v29 >> 2) + 1;
      uint64_t v31 = 4 * (v30 & 0x7FFFFFFFFFFFFFF8);
      uint64_t v8 = &end[v31 / 0xFFFFFFFFFFFFFFFCLL];
      size_t v21 = (int *)((char *)v21 - v31);
      size_t v32 = &v15[4 * v11 - 16];
      BOOL v33 = (long long *)(end - 4);
      uint64_t v34 = v30 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        long long v35 = *v33;
        *(v32 - 1) = *(v33 - 1);
        *size_t v32 = v35;
        v32 -= 2;
        v33 -= 2;
        v34 -= 8;
      }
      while (v34);
      if (v30 != (v30 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_47:
        do
        {
          int v36 = *--v8;
          *--size_t v21 = v36;
        }
        while (v8 != begin);
      }
    }
    this->__begin_ = v21;
    this->__end_ = v22;
    this->__end_cap_.__value_ = (int *)&v15[4 * v14];
    if (begin)
    {
      operator delete(begin);
    }
  }
}

void anonymous namespace'::SqueezePattern::~SqueezePattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::SqueezePattern::matchAndRewrite(_anonymous_namespace_::SqueezePattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  OptionalArguint64_t Value = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "axes");
  uint64_t v24 = OptionalArgValue;
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    if (OptionalArgValue)
    {
      uint64_t v7 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue, &v24);
      if (!*(_DWORD *)(v7 + 36)) {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
LABEL_12:
      (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
      uint64_t v13 = (long long *)__p;
      unint64_t v14 = (char *)operator new(8uLL);
      *(void *)unint64_t v14 = v7 - 16;
      v30[0] = v13;
      uint64_t v15 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v13, (uint64_t)&std::piecewise_construct, v30);
      std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v15 + 5, v14, v14 + 8, 1uLL);
      operator delete(v14);
      std::vector<int>::size_type v16 = (void **)__p;
      if (__p)
      {
        std::vector<int>::size_type v17 = (void **)v32;
        float32x4_t v18 = __p;
        if ((void *)v32 != __p)
        {
          do
          {
            if (*((char *)v17 - 1) < 0) {
              operator delete(*(v17 - 3));
            }
            v17 -= 3;
          }
          while (v17 != v16);
          float32x4_t v18 = __p;
        }
        *(void *)&long long v32 = v16;
        operator delete(v18);
      }
      return 1;
    }
    uint64_t v25 = LocationForOp;
    uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v25);
    uint64_t v10 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.squeeze", (const unsigned __int8 *)0xB, Context);
    if (!v11)
    {
      __int16 v29 = 1283;
      v28[2] = (uint64_t)"mps.squeeze";
      v28[3] = 11;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v27 = 259;
      llvm::operator+(v28, (uint64_t *)&v26, (uint64_t)v30);
      llvm::report_fatal_error((llvm::Twine *)v30, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v10);
    mlir::mps::SqueezeOp::build((uint64_t)(a3 + 18), (uint64_t)&__p, (uint64_t)&ArgValue, 1, 0, 0);
    unint64_t v12 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    if (v12)
    {
      uint64_t v7 = llvm::DefaultDoCastIfPossible<mlir::mps::SqueezeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SqueezeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v12);
      if (v7)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        if (!*(_DWORD *)(v7 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        goto LABEL_12;
      }
      int v19 = "result && \"builder didn't return the right type\"";
      int v20 = 497;
      size_t v21 = "Builders.h";
      uint64_t v22 = "create";
    }
    else
    {
      int v19 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v20 = 662;
      size_t v21 = "Casting.h";
      uint64_t v22 = "dyn_cast";
    }
    __assert_rtn(v22, v21, v20, v19);
  }
  long long __p = operator new(0x40uLL);
  long long v32 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v32) < 0) {
    operator delete(__p);
  }
  return 0;
}

void sub_180DB2AD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
}

void sub_180DB2AE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28)
{
}

void sub_180DB2AF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter0::~GeneratedRewriter0(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter0::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter0 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v30 = ArgValue;
  uint64_t v29 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "alpha");
  uint64_t v31 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "beta");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
    long long __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
    uint64_t v28 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, &v29, (uint64_t *)&__p);
    uint64_t v8 = mlir::OpBuilder::create<mlir::mps::LeakyReluOp,mlir::Value &,mlir::mps::CastOp &>(a3 + 18, LocationForOp, &v30, (uint64_t)&v28);
    uint64_t v9 = mlir::getElementTypeOrSelf(ArgValue);
    long long __p = (void *)mlir::TypeAttr::get(v9);
    uint64_t v10 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, &v31, (uint64_t *)&__p);
    uint64_t v32 = LocationForOp;
    uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v32);
    uint64_t v12 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.minimum", (const unsigned __int8 *)0xB, Context);
    if (!v13)
    {
      __int16 v36 = 1283;
      v35[2] = (uint64_t)"mps.minimum";
      v35[3] = 11;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v34 = 259;
      llvm::operator+(v35, (uint64_t *)&v33, (uint64_t)v37);
      llvm::report_fatal_error((llvm::Twine *)v37, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v12);
    if (!*(_DWORD *)(v8 + 36) || !*((_DWORD *)v10 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    mlir::mps::ATan2Op::build(a3 + 18, (uint64_t)&__p, v8 - 16, (uint64_t)v10 - 16);
    unint64_t v14 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    if (v14)
    {
      uint64_t v15 = llvm::DefaultDoCastIfPossible<mlir::mps::MinimumOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MinimumOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v14);
      if (v15)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v15 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        std::vector<int>::size_type v16 = (long long *)__p;
        std::vector<int>::size_type v17 = (char *)operator new(8uLL);
        *(void *)std::vector<int>::size_type v17 = v15 - 16;
        v37[0] = v16;
        float32x4_t v18 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v16, (uint64_t)&std::piecewise_construct, v37);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v18 + 5, v17, v17 + 8, 1uLL);
        operator delete(v17);
        int v19 = (void **)__p;
        if (__p)
        {
          int v20 = (void **)v39;
          size_t v21 = __p;
          if ((void *)v39 != __p)
          {
            do
            {
              if (*((char *)v20 - 1) < 0) {
                operator delete(*(v20 - 3));
              }
              v20 -= 3;
            }
            while (v20 != v19);
            size_t v21 = __p;
          }
          *(void *)&long long v39 = v19;
          operator delete(v21);
        }
        return 1;
      }
      uint64_t v24 = "result && \"builder didn't return the right type\"";
      int v25 = 497;
      float32x4_t v26 = "Builders.h";
      __int16 v27 = "create";
    }
    else
    {
      uint64_t v24 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v25 = 662;
      float32x4_t v26 = "Casting.h";
      __int16 v27 = "dyn_cast";
    }
    __assert_rtn(v27, v26, v25, v24);
  }
  long long __p = operator new(0x40uLL);
  long long v39 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v22 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v39) < 0) {
    operator delete(__p);
  }
  return v22;
}

void sub_180DB3020(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180DB3078(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
}

void sub_180DB308C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::LeakyReluOp,mlir::Value &,mlir::mps::CastOp &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v24[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.leaky_relu", (const unsigned __int8 *)0xE, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.leaky_relu";
    v21[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(void *)a4 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *a3, *(void *)a4 - 16);
  char v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    unint64_t v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v15 = 662;
    std::vector<int>::size_type v16 = "Casting.h";
    std::vector<int>::size_type v17 = "dyn_cast";
    goto LABEL_10;
  }
  uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::LeakyReluOp,mlir::Operation *,llvm::CastInfo<mlir::mps::LeakyReluOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    unint64_t v14 = "result && \"builder didn't return the right type\"";
    int v15 = 497;
    std::vector<int>::size_type v16 = "Builders.h";
    std::vector<int>::size_type v17 = "create";
LABEL_10:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180DB324C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DB3264(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::LeakyReluOp,mlir::Operation *,llvm::CastInfo<mlir::mps::LeakyReluOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 14 && *AttrData == 0x6B61656C2E73706DLL && *(void *)((char *)AttrData + 6) == 0x756C65725F796B61)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.leaky_relu";
      v8[3] = 14;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::LeakyReluOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter1::~GeneratedRewriter1(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter1::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter1 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v26 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "alpha");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
    long long __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
    uint64_t v8 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, &v26, (uint64_t *)&__p);
    uint64_t v27 = LocationForOp;
    uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v27);
    uint64_t v10 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.elu", (const unsigned __int8 *)7, Context);
    if (!v11)
    {
      __int16 v31 = 1283;
      uint64_t v30[2] = (uint64_t)"mps.elu";
      v30[3] = 7;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v29 = 259;
      llvm::operator+(v30, (uint64_t *)&v28, (uint64_t)v32);
      llvm::report_fatal_error((llvm::Twine *)v32, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v10);
    if (!*((_DWORD *)v8 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    mlir::mps::ATan2Op::build(a3 + 18, (uint64_t)&__p, ArgValue, (uint64_t)v8 - 16);
    uint64_t v12 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    if (v12)
    {
      uint64_t v13 = llvm::DefaultDoCastIfPossible<mlir::mps::EluOp,mlir::Operation *,llvm::CastInfo<mlir::mps::EluOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v12);
      if (v13)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v13 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        unint64_t v14 = (long long *)__p;
        int v15 = (char *)operator new(8uLL);
        *(void *)int v15 = v13 - 16;
        v32[0] = v14;
        std::vector<int>::size_type v16 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v14, (uint64_t)&std::piecewise_construct, v32);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v16 + 5, v15, v15 + 8, 1uLL);
        operator delete(v15);
        std::vector<int>::size_type v17 = (void **)__p;
        if (__p)
        {
          uint64_t v18 = (void **)v34;
          int v19 = __p;
          if ((void *)v34 != __p)
          {
            do
            {
              if (*((char *)v18 - 1) < 0) {
                operator delete(*(v18 - 3));
              }
              v18 -= 3;
            }
            while (v18 != v17);
            int v19 = __p;
          }
          *(void *)&long long v34 = v17;
          operator delete(v19);
        }
        return 1;
      }
      __int16 v22 = "result && \"builder didn't return the right type\"";
      int v23 = 497;
      uint64_t v24 = "Builders.h";
      int v25 = "create";
    }
    else
    {
      __int16 v22 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v23 = 662;
      uint64_t v24 = "Casting.h";
      int v25 = "dyn_cast";
    }
    __assert_rtn(v25, v24, v23, v22);
  }
  long long __p = operator new(0x40uLL);
  long long v34 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v20 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v34) < 0) {
    operator delete(__p);
  }
  return v20;
}

void sub_180DB37D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180DB3844(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::EluOp,mlir::Operation *,llvm::CastInfo<mlir::mps::EluOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1970038062)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.elu";
      v8[3] = 7;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::EluOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter2::~GeneratedRewriter2(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter2::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter2 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::ErfOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    __int16 v7 = (long long *)__p;
    uint64_t v8 = (char *)operator new(8uLL);
    *(void *)uint64_t v8 = v6 - 16;
    uint64_t v18 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    long long __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DB3C34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ErfOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.erf", (const unsigned __int8 *)7, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.erf";
    v19[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  __int16 v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    uint64_t v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::ErfOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ErfOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    uint64_t v14 = "Builders.h";
    int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180DB3DE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DB3E00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ErfOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ErfOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1718773038)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.erf";
      v8[3] = 7;
      uint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ErfOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter3::~GeneratedRewriter3(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter3::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter3 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v21 = ArgValue;
  uint64_t v20 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "alpha");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
    long long __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
    std::vector<int>::size_type v17 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, &v20, (uint64_t *)&__p);
    uint64_t v8 = mlir::OpBuilder::create<mlir::mps::LeakyReluOp,mlir::Value &,mlir::mps::CastOp &>(a3 + 18, LocationForOp, &v21, (uint64_t)&v17);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v8 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    __int16 v9 = (long long *)__p;
    uint64_t v10 = (char *)operator new(8uLL);
    *(void *)uint64_t v10 = v8 - 16;
    __int16 v22 = v9;
    char v11 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v9, (uint64_t)&std::piecewise_construct, &v22);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v11 + 5, v10, v10 + 8, 1uLL);
    operator delete(v10);
    uint64_t v12 = (void **)__p;
    if (__p)
    {
      int v13 = (void **)v19;
      uint64_t v14 = __p;
      if ((void *)v19 != __p)
      {
        do
        {
          if (*((char *)v13 - 1) < 0) {
            operator delete(*(v13 - 3));
          }
          v13 -= 3;
        }
        while (v13 != v12);
        uint64_t v14 = __p;
      }
      *(void *)&long long v19 = v12;
      operator delete(v14);
    }
    return 1;
  }
  else
  {
    long long __p = operator new(0x40uLL);
    long long v19 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t v15 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    if (SHIBYTE(v19) < 0) {
      operator delete(__p);
    }
  }
  return v15;
}

void sub_180DB4218(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter4::~GeneratedRewriter4(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter4::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter4 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  Arguint64_t Value = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v30 = ArgValue;
  uint64_t v29 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "alpha");
  uint64_t v31 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "beta");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
    long long __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
    uint64_t v28 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, &v29, (uint64_t *)&__p);
    uint64_t v8 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value &,mlir::mps::CastOp &>(a3 + 18, LocationForOp, &v30, (uint64_t)&v28);
    uint64_t v9 = mlir::getElementTypeOrSelf(ArgValue);
    long long __p = (void *)mlir::TypeAttr::get(v9);
    uint64_t v10 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, &v31, (uint64_t *)&__p);
    uint64_t v32 = LocationForOp;
    uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v32);
    uint64_t v12 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, Context);
    if (!v13)
    {
      __int16 v36 = 1283;
      v35[2] = (uint64_t)"mps.add";
      v35[3] = 7;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v34 = 259;
      llvm::operator+(v35, (uint64_t *)&v33, (uint64_t)v37);
      llvm::report_fatal_error((llvm::Twine *)v37, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v12);
    if (!*(_DWORD *)(v8 + 36) || !*((_DWORD *)v10 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    mlir::mps::ATan2Op::build(a3 + 18, (uint64_t)&__p, v8 - 16, (uint64_t)v10 - 16);
    uint64_t v14 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    if (v14)
    {
      uint64_t v15 = llvm::DefaultDoCastIfPossible<mlir::mps::AddOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AddOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v14);
      if (v15)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v15 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        uint64_t v16 = (long long *)__p;
        std::vector<int>::size_type v17 = (char *)operator new(8uLL);
        *(void *)std::vector<int>::size_type v17 = v15 - 16;
        v37[0] = v16;
        __int16 v18 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v16, (uint64_t)&std::piecewise_construct, v37);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v18 + 5, v17, v17 + 8, 1uLL);
        operator delete(v17);
        long long v19 = (void **)__p;
        if (__p)
        {
          uint64_t v20 = (void **)v39;
          uint64_t v21 = __p;
          if ((void *)v39 != __p)
          {
            do
            {
              if (*((char *)v20 - 1) < 0) {
                operator delete(*(v20 - 3));
              }
              v20 -= 3;
            }
            while (v20 != v19);
            uint64_t v21 = __p;
          }
          *(void *)&long long v39 = v19;
          operator delete(v21);
        }
        return 1;
      }
      uint64_t v24 = "result && \"builder didn't return the right type\"";
      int v25 = 497;
      uint64_t v26 = "Builders.h";
      uint64_t v27 = "create";
    }
    else
    {
      uint64_t v24 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v25 = 662;
      uint64_t v26 = "Casting.h";
      uint64_t v27 = "dyn_cast";
    }
    __assert_rtn(v27, v26, v25, v24);
  }
  long long __p = operator new(0x40uLL);
  long long v39 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v22 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v39) < 0) {
    operator delete(__p);
  }
  return v22;
}