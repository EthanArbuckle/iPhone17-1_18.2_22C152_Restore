void *mlir::mps::anonymous namespace'::CanonicalizePadToConv2DOp<mlir::mps::Conv2DOp>::~CanonicalizePadToConv2DOp(void *a1)
{
  void *v2;
  void *v3;

  v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::mps::anonymous namespace'::CanonicalizePadToConv2DOp<mlir::mps::Conv2DOp>::~CanonicalizePadToConv2DOp(void *__p)
{
  v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::Conv2DOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::Conv2DOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::Conv2DOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizePadToConv2DOp<mlir::mps::Conv2DOp>::matchAndRewrite(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  v58 = a2;
  if (mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v58) == 4
    || mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v58) == 2)
  {
    v65 = "failed: convolution op already specifies TF_SAME or ONNX_SAME_LOWER padding";
    v67[8] = 259;
    v4 = v58;
    v62 = (void **)&v65;
    uint64_t v5 = a3[2];
    if (v5 && mlir::RewriterBase::Listener::classof(a3[2])) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void ***))(*(void *)v5 + 64))(v5, v4[3], llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::Conv2DOp &>(mlir::mps::Conv2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v62);
    }
    return 0;
  }
  v65 = *(char **)(v58[9] + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v65);
  if (DefiningOp
    && *(_UNKNOWN **)(*(void *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::PadOp,void>::id)
  {
    uint64_t DefiningOp = 0;
  }
  uint64_t v57 = DefiningOp;
  if (!v68) {
    return 0;
  }
  v62 = (void **)v64;
  uint64_t v63 = 0x600000000;
  unsigned int v8 = v66;
  if (v66)
  {
    if (v66 < 7)
    {
      v10 = (void **)v64;
      unsigned int v9 = v66;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v64, v66, 8);
      unsigned int v9 = v66;
      if (!v66)
      {
LABEL_18:
        LODWORD(v63) = v8;
        goto LABEL_19;
      }
      v10 = v62;
    }
    memcpy(v10, v65, 8 * v9);
    goto LABEL_18;
  }
LABEL_19:
  int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v58);
  if (StorageType == 1)
  {
    if (!v63) {
      goto LABEL_37;
    }
    unint64_t v13 = 0;
    uint64_t v14 = 8 * v63;
    while (v13 > 9 || ((1 << v13) & 0x303) == 0 || !v62[v13])
    {
      ++v13;
      v14 -= 8;
      if (!v14) {
        goto LABEL_37;
      }
    }
  }
  else
  {
    if (StorageType)
    {
      v15 = "failure: incompatible value for TensorDataLayout";
      goto LABEL_59;
    }
    if (!v63
      || !*v62 && (v63 == 1 || !v62[1] && (v63 == 2 || !v62[2] && (v63 == 3 || !v62[3]))))
    {
LABEL_37:
      if (mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v58))
      {
LABEL_47:
        *(_OWORD *)v60 = xmmword_18110B5E0;
        uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 1), 0x40u, 0);
        v28 = (void *)mlir::RankedTensorType::get((uint64_t)v60, 2, IntegerType, 0);
        v29 = v28;
        if (!v28) {
          goto LABEL_56;
        }
        uint64_t v30 = *v28;
        unint64_t v31 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v32 = *(unsigned int *)(v30 + 16);
        if (!v32) {
          goto LABEL_56;
        }
        v33 = *(void **)(v30 + 8);
        v34 = &v33[2 * v32];
        do
        {
          unint64_t v35 = v32 >> 1;
          v36 = &v33[2 * (v32 >> 1)];
          unint64_t v38 = *v36;
          v37 = v36 + 2;
          v32 += ~(v32 >> 1);
          if (v38 < v31) {
            v33 = v37;
          }
          else {
            unint64_t v32 = v35;
          }
        }
        while (v32);
        if (v33 != v34 && *v33 == v31) {
          uint64_t v39 = v33[1];
        }
        else {
LABEL_56:
        }
          uint64_t v39 = 0;
        uint64_t v6 = 1;
        v40 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v29, v39, v62, 8 * v63, 8, 1, 0);
        v41 = v58;
        Rewriter = (void **)v40;
        v60[0] = v58;
        uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v57);
        uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v58);
        Groups = mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)v60);
        uint64_t Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v58);
        uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v58);
        unsigned int v51 = 0;
        unsigned int v50 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v58);
        unsigned int WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v58);
        v42 = mlir::OpBuilder::create<mlir::mps::Conv2DOp,mlir::Value,mlir::Value,unsigned long long,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr&,mlir::mps::PaddingStyle,mlir::mps::TensorDataLayout,mlir::mps::TensorDataLayout>((mlir::Builder *)(a3 + 1), v41[3], &Input, &Filter, (uint64_t *)&Groups, &Strides, &InputAttributeNames, (uint64_t *)&Rewriter, &v51, &v50, &WeightsLayout);
        (*(void (**)(uint64_t *, void *, mlir::GenericProgramPoint *))(*a3 + 32))(a3, v41, v42);
        goto LABEL_63;
      }
      v60[0] = v61;
      v60[1] = (void *)0x600000000;
      Rewriter = (void **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v58);
      v16 = mlir::Attribute::cast<mlir::ElementsAttr>((uint64_t **)&Rewriter);
      mlir::getIntValues<unsigned long long>((uint64_t)v16, v17, (uint64_t)v60, 1);
      uint64_t v18 = LODWORD(v60[1]);
      v19 = (char *)v60[0];
      if (LODWORD(v60[1]))
      {
        v20 = v62;
        if (LODWORD(v60[1]) < 6
          || v62 < (void **)((char *)v60[0] + 8 * LODWORD(v60[1])) && v60[0] < &v62[LODWORD(v60[1])])
        {
          uint64_t v21 = 0;
LABEL_43:
          uint64_t v22 = v18 - v21;
          uint64_t v23 = v21;
          v24 = &v19[8 * v21];
          v25 = &v20[v23];
          do
          {
            uint64_t v26 = *(void *)v24;
            v24 += 8;
            *v25 = (char *)*v25 + v26;
            ++v25;
            --v22;
          }
          while (v22);
          goto LABEL_45;
        }
        uint64_t v21 = (uint64_t)v60[1] & 0xFFFFFFFC;
        v45 = (int64x2_t *)((char *)v60[0] + 16);
        v46 = (int64x2_t *)(v62 + 2);
        uint64_t v47 = v21;
        do
        {
          int64x2_t v48 = vaddq_s64(*v46, *v45);
          v46[-1] = vaddq_s64(v46[-1], v45[-1]);
          int64x2_t *v46 = v48;
          v45 += 2;
          v46 += 2;
          v47 -= 4;
        }
        while (v47);
        if (v21 != v18) {
          goto LABEL_43;
        }
      }
LABEL_45:
      if (v19 != (char *)v61) {
        free(v19);
      }
      goto LABEL_47;
    }
  }
  v15 = "failed: pad is specified along a batch or channel dimension";
LABEL_59:
  v61[8] = 259;
  v43 = v58;
  Rewriter = v60;
  v60[0] = (void *)v15;
  uint64_t v44 = a3[2];
  if (v44 && mlir::RewriterBase::Listener::classof(v44)) {
    uint64_t v6 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void ***))(*(void *)v44 + 64))(v44, v43[3], llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::Conv2DOp &>(mlir::mps::Conv2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &Rewriter);
  }
  else {
    uint64_t v6 = 0;
  }
LABEL_63:
  if (v62 != (void **)v64) {
    free(v62);
  }
  if (v68 && v65 != (char *)v67) {
    free(v65);
  }
  return v6;
}

void mlir::mps::anonymous namespace'::tryGetPaddingValues(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v12[6] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = a1;
  if (a1
    && !mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v9)
    && (Bias = (unint64_t *)mlir::anec::GOC::getBias((mlir::anec::GOC *)&v9), mlir::isConstantFPZero(Bias)))
  {
    __src = v12;
    uint64_t v11 = 0x600000000;
    uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v9);
    if (mlir::matchConstantWithIntVector<unsigned long long>(Filter, (uint64_t)&__src))
    {
      *(void *)a2 = a2 + 16;
      *(void *)(a2 + 8) = 0x600000000;
      int v5 = v11;
      char v6 = 1;
      if (v11 && &__src != (void **)a2)
      {
        if (__src == v12)
        {
          unsigned int v8 = v11;
          if (v11 < 7
            || (llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v11, 8),
                (unsigned int v8 = v11) != 0))
          {
            memcpy(*(void **)a2, __src, 8 * v8);
          }
          *(_DWORD *)(a2 + 8) = v5;
        }
        else
        {
          *(void *)a2 = __src;
          int v7 = HIDWORD(v11);
          *(_DWORD *)(a2 + 8) = v5;
          *(_DWORD *)(a2 + 12) = v7;
          __src = v12;
          HIDWORD(v11) = 0;
        }
        LODWORD(v11) = 0;
        char v6 = 1;
      }
    }
    else
    {
      char v6 = 0;
      *(unsigned char *)a2 = 0;
    }
    *(unsigned char *)(a2 + 64) = v6;
    if (__src != v12) {
      free(__src);
    }
  }
  else
  {
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 64) = 0;
  }
}

float mlir::getIntValues<unsigned long long>(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  v128[5] = *MEMORY[0x1E4F143B8];
  *(void *)&long long v122 = a1;
  *((void *)&v122 + 1) = a2;
  if (!mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v122) || a4) {
    unint64_t NumElements = mlir::ElementsAttr::getNumElements(v122, *((uint64_t *)&v122 + 1));
  }
  else {
    unint64_t NumElements = 1;
  }
  unint64_t v7 = *(unsigned int *)(a3 + 8);
  if (NumElements != v7)
  {
    if (NumElements >= v7)
    {
      if (NumElements > *(unsigned int *)(a3 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), NumElements, 8);
        unint64_t v7 = *(unsigned int *)(a3 + 8);
      }
      if (NumElements != v7) {
        bzero((void *)(*(void *)a3 + 8 * v7), 8 * (NumElements - v7));
      }
    }
    *(_DWORD *)(a3 + 8) = NumElements;
  }
  unsigned int v8 = *(uint64x2_t **)a3;
  long long v125 = v122;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v125);
  v10 = Type;
  if (!Type) {
    goto LABEL_21;
  }
  uint64_t v11 = *Type;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_21;
  }
  uint64_t v14 = *(void **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    uint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    uint64_t v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      uint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_21:
  }
    uint64_t v20 = 0;
  v124[0] = v10;
  v124[1] = v20;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v124);
  int v21 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v125);
  ElementsAttrRawData = (unsigned __int8 *)mlir::getElementsAttrRawData(v125);
  uint64_t v24 = v23;
  if (!v21 || a4)
  {
    uint64_t v26 = mlir::ElementsAttr::getNumElements(v125, *((uint64_t *)&v125 + 1));
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
    {
      if (v26 < 1) {
        return *(float *)v25.i32;
      }
      goto LABEL_28;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 8))
    {
      if (v26 < 1) {
        return *(float *)v25.i32;
      }
      goto LABEL_39;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16))
    {
      if (v26 < 1) {
        return *(float *)v25.i32;
      }
      if ((unint64_t)v26 >= 2)
      {
        unint64_t v32 = 0;
        unint64_t v31 = v26 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v21) {
            unint64_t v33 = 0;
          }
          else {
            unint64_t v33 = v32;
          }
          if (v21) {
            unint64_t v34 = 0;
          }
          else {
            unint64_t v34 = v32 + 1;
          }
          uint64_t v35 = *(unsigned __int16 *)&ElementsAttrRawData[2 * v34];
          v36 = &v8[v32 / 2];
          v36->i64[0] = *(unsigned __int16 *)&ElementsAttrRawData[2 * v33];
          v36->i64[1] = v35;
          v32 += 2;
        }
        while (v32 != v31);
        goto LABEL_280;
      }
      goto LABEL_48;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 16))
    {
      if (v26 < 1) {
        return *(float *)v25.i32;
      }
      goto LABEL_66;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32))
    {
      if (v26 < 1) {
        return *(float *)v25.i32;
      }
      goto LABEL_73;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 32))
    {
      if (v26 < 1) {
        return *(float *)v25.i32;
      }
      goto LABEL_89;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
    {
      if (v26 < 1) {
        return *(float *)v25.i32;
      }
      goto LABEL_105;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 64))
    {
      if (v26 < 1) {
        return *(float *)v25.i32;
      }
      goto LABEL_125;
    }
    if (mlir::Type::isF16((mlir::Type *)&OperandRange))
    {
      if (v26 < 1) {
        return *(float *)v25.i32;
      }
      goto LABEL_136;
    }
    if (mlir::Type::isF32((mlir::Type *)&OperandRange))
    {
      if (v26 < 1) {
        return *(float *)v25.i32;
      }
      goto LABEL_143;
    }
    if (mlir::Type::isF64((mlir::Type *)&OperandRange))
    {
      if (v26 < 1) {
        return *(float *)v25.i32;
      }
      goto LABEL_159;
    }
    if (mlir::Type::isBF16((mlir::Type *)&OperandRange))
    {
      if (v26 < 1) {
        return *(float *)v25.i32;
      }
      goto LABEL_174;
    }
    goto LABEL_176;
  }
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
  {
    uint64_t v26 = 1;
LABEL_28:
    for (uint64_t i = 0; i != v26; ++i)
    {
      if (v21) {
        uint64_t v28 = 0;
      }
      else {
        uint64_t v28 = i;
      }
      v8->i64[i] = ElementsAttrRawData[v28];
    }
    return *(float *)v25.i32;
  }
  if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 8))
  {
    uint64_t v26 = 1;
LABEL_39:
    for (uint64_t j = 0; j != v26; ++j)
    {
      if (v21) {
        uint64_t v30 = 0;
      }
      else {
        uint64_t v30 = j;
      }
      v8->i64[j] = (char)ElementsAttrRawData[v30];
    }
    return *(float *)v25.i32;
  }
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16))
  {
    uint64_t v26 = 1;
LABEL_48:
    unint64_t v31 = 0;
    do
    {
      if (v21) {
        unint64_t v112 = 0;
      }
      else {
        unint64_t v112 = v31;
      }
      v8->i64[v31++] = *(unsigned __int16 *)&ElementsAttrRawData[2 * v112];
LABEL_280:
      ;
    }
    while (v26 != v31);
    return *(float *)v25.i32;
  }
  if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 16))
  {
    uint64_t v26 = 1;
LABEL_66:
    if ((unint64_t)v26 >= 2)
    {
      unint64_t v39 = 0;
      unint64_t v37 = v26 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v21) {
          unint64_t v40 = 0;
        }
        else {
          unint64_t v40 = v39;
        }
        if (v21) {
          unint64_t v41 = 0;
        }
        else {
          unint64_t v41 = v39 + 1;
        }
        uint64_t v42 = *(__int16 *)&ElementsAttrRawData[2 * v41];
        v43 = &v8[v39 / 2];
        v43->i64[0] = *(__int16 *)&ElementsAttrRawData[2 * v40];
        v43->i64[1] = v42;
        v39 += 2;
      }
      while (v39 != v37);
      goto LABEL_286;
    }
    unint64_t v37 = 0;
    do
    {
      if (v21) {
        unint64_t v113 = 0;
      }
      else {
        unint64_t v113 = v37;
      }
      v8->i64[v37++] = *(__int16 *)&ElementsAttrRawData[2 * v113];
LABEL_286:
      ;
    }
    while (v26 != v37);
    return *(float *)v25.i32;
  }
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32))
  {
    uint64_t v26 = 1;
LABEL_73:
    if ((unint64_t)v26 >= 2)
    {
      unint64_t v45 = 0;
      unint64_t v38 = v26 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v21) {
          unint64_t v46 = 0;
        }
        else {
          unint64_t v46 = v45;
        }
        if (v21) {
          unint64_t v47 = 0;
        }
        else {
          unint64_t v47 = v45 + 1;
        }
        uint64_t v48 = *(unsigned int *)&ElementsAttrRawData[4 * v47];
        v49 = &v8[v45 / 2];
        v49->i64[0] = *(unsigned int *)&ElementsAttrRawData[4 * v46];
        v49->i64[1] = v48;
        v45 += 2;
      }
      while (v45 != v38);
      goto LABEL_292;
    }
    unint64_t v38 = 0;
    do
    {
      if (v21) {
        unint64_t v114 = 0;
      }
      else {
        unint64_t v114 = v38;
      }
      v8->i64[v38++] = *(unsigned int *)&ElementsAttrRawData[4 * v114];
LABEL_292:
      ;
    }
    while (v26 != v38);
    return *(float *)v25.i32;
  }
  if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 32))
  {
    uint64_t v26 = 1;
LABEL_89:
    if ((unint64_t)v26 >= 2)
    {
      unint64_t v52 = 0;
      unint64_t v44 = v26 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v21) {
          unint64_t v53 = 0;
        }
        else {
          unint64_t v53 = v52;
        }
        if (v21) {
          unint64_t v54 = 0;
        }
        else {
          unint64_t v54 = v52 + 1;
        }
        uint64_t v55 = *(int *)&ElementsAttrRawData[4 * v54];
        v56 = &v8[v52 / 2];
        v56->i64[0] = *(int *)&ElementsAttrRawData[4 * v53];
        v56->i64[1] = v55;
        v52 += 2;
      }
      while (v52 != v44);
      goto LABEL_298;
    }
    unint64_t v44 = 0;
    do
    {
      if (v21) {
        unint64_t v115 = 0;
      }
      else {
        unint64_t v115 = v44;
      }
      v8->i64[v44++] = *(int *)&ElementsAttrRawData[4 * v115];
LABEL_298:
      ;
    }
    while (v26 != v44);
    return *(float *)v25.i32;
  }
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
  {
    uint64_t v26 = 1;
LABEL_105:
    for (uint64_t k = 0; k != v26; ++k)
    {
      if (v21) {
        uint64_t v51 = 0;
      }
      else {
        uint64_t v51 = k;
      }
      v8->i64[k] = *(void *)&ElementsAttrRawData[8 * v51];
    }
    return *(float *)v25.i32;
  }
  if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 64))
  {
    uint64_t v26 = 1;
LABEL_125:
    for (uint64_t m = 0; m != v26; ++m)
    {
      if (v21) {
        uint64_t v58 = 0;
      }
      else {
        uint64_t v58 = m;
      }
      v8->i64[m] = *(void *)&ElementsAttrRawData[8 * v58];
    }
    return *(float *)v25.i32;
  }
  if (mlir::Type::isF16((mlir::Type *)&OperandRange))
  {
    uint64_t v26 = 1;
LABEL_136:
    if ((unint64_t)v26 >= 2)
    {
      unint64_t v61 = 0;
      unint64_t v59 = v26 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v21) {
          unint64_t v62 = 0;
        }
        else {
          unint64_t v62 = v61;
        }
        if (v21) {
          unint64_t v63 = 0;
        }
        else {
          unint64_t v63 = v61 + 1;
        }
        v25.i16[0] = *(_WORD *)&ElementsAttrRawData[2 * v62];
        unint64_t v64 = (unint64_t)*(short float *)&ElementsAttrRawData[2 * v63];
        v65 = &v8[v61 / 2];
        v65->i64[0] = (unint64_t)*(short float *)v25.i16;
        v65->i64[1] = v64;
        v61 += 2;
      }
      while (v61 != v59);
      goto LABEL_304;
    }
    unint64_t v59 = 0;
    do
    {
      if (v21) {
        unint64_t v116 = 0;
      }
      else {
        unint64_t v116 = v59;
      }
      v25.i16[0] = *(_WORD *)&ElementsAttrRawData[2 * v116];
      v8->i64[v59++] = (unint64_t)*(short float *)v25.i16;
LABEL_304:
      ;
    }
    while (v26 != v59);
    return *(float *)v25.i32;
  }
  if (mlir::Type::isF32((mlir::Type *)&OperandRange))
  {
    uint64_t v26 = 1;
LABEL_143:
    if ((unint64_t)v26 >= 2)
    {
      unint64_t v67 = 0;
      unint64_t v60 = v26 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v21) {
          unint64_t v68 = 0;
        }
        else {
          unint64_t v68 = v67;
        }
        if (v21) {
          unint64_t v69 = 0;
        }
        else {
          unint64_t v69 = v67 + 1;
        }
        v25.i32[0] = *(_DWORD *)&ElementsAttrRawData[4 * v68];
        unint64_t v70 = (unint64_t)*(float *)&ElementsAttrRawData[4 * v69];
        v71 = &v8[v67 / 2];
        v71->i64[0] = (unint64_t)*(float *)v25.i32;
        v71->i64[1] = v70;
        v67 += 2;
      }
      while (v67 != v60);
      goto LABEL_310;
    }
    unint64_t v60 = 0;
    do
    {
      if (v21) {
        unint64_t v117 = 0;
      }
      else {
        unint64_t v117 = v60;
      }
      v25.i32[0] = *(_DWORD *)&ElementsAttrRawData[4 * v117];
      v8->i64[v60++] = (unint64_t)*(float *)v25.i32;
LABEL_310:
      ;
    }
    while (v26 != v60);
    return *(float *)v25.i32;
  }
  if (mlir::Type::isF64((mlir::Type *)&OperandRange))
  {
    uint64_t v26 = 1;
LABEL_159:
    if ((unint64_t)v26 >= 2)
    {
      unint64_t v76 = 0;
      unint64_t v66 = v26 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v21) {
          unint64_t v77 = 0;
        }
        else {
          unint64_t v77 = v76;
        }
        if (v21) {
          unint64_t v78 = 0;
        }
        else {
          unint64_t v78 = v76 + 1;
        }
        v25.i64[0] = *(void *)&ElementsAttrRawData[8 * v77];
        unint64_t v79 = (unint64_t)*(double *)&ElementsAttrRawData[8 * v78];
        v80 = &v8[v76 / 2];
        v80->i64[0] = (unint64_t)*(double *)v25.i64;
        v80->i64[1] = v79;
        v76 += 2;
      }
      while (v76 != v66);
      goto LABEL_316;
    }
    unint64_t v66 = 0;
    do
    {
      if (v21) {
        unint64_t v118 = 0;
      }
      else {
        unint64_t v118 = v66;
      }
      v25.i64[0] = *(void *)&ElementsAttrRawData[8 * v118];
      v8->i64[v66++] = (unint64_t)*(double *)v25.i64;
LABEL_316:
      ;
    }
    while (v26 != v66);
    return *(float *)v25.i32;
  }
  uint64_t v26 = 1;
  if (!mlir::Type::isBF16((mlir::Type *)&OperandRange))
  {
LABEL_176:
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 1))
    {
      v121 = v8;
      if (v21) {
        unint64_t v73 = 1;
      }
      else {
        unint64_t v73 = v26;
      }
      v126 = v128;
      v25.i32[0] = 0;
      long long v127 = xmmword_1810FE310;
      if (v73)
      {
        if (v73 < 0x29)
        {
          uint64_t v75 = 0;
          v74 = v128;
        }
        else
        {
          llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v126, v128, v73, 1);
          v74 = v126;
          uint64_t v75 = v127;
        }
        if (v73 != v75)
        {
          bzero((char *)v74 + v75, v73 - v75);
          v74 = v126;
        }
        *(void *)&long long v127 = v73;
      }
      else
      {
        v74 = v128;
      }
      if (!v24)
      {
LABEL_268:
        if (v26 >= 1)
        {
          for (uint64_t n = 0; n != v26; ++n)
          {
            if (v21) {
              uint64_t v111 = 0;
            }
            else {
              uint64_t v111 = n;
            }
            v121->i64[n] = *((char *)v74 + v111);
          }
        }
        if (v74 != v128) {
          free(v74);
        }
        return *(float *)v25.i32;
      }
      v100 = (BOOL *)v74 + 3;
      v25.i32[0] = 0;
      while (1)
      {
        if (v73 >= 8) {
          uint64_t v101 = 8;
        }
        else {
          uint64_t v101 = v73;
        }
        if (!v101) {
          goto LABEL_238;
        }
        if (v73 >= 8) {
          uint64_t v102 = 8;
        }
        else {
          uint64_t v102 = v73;
        }
        unsigned int v103 = *ElementsAttrRawData;
        uint64x2_t v104 = (uint64x2_t)vdupq_n_s64(v102 - 1);
        int32x2_t v105 = vmovn_s64((int64x2_t)vcgeq_u64(v104, (uint64x2_t)xmmword_1810FE2E0));
        if (v105.i8[0]) {
          *(v100 - 3) = v103 & 1;
        }
        if (v105.i8[4]) {
          *(v100 - 2) = (v103 & 2) != 0;
        }
        uint64_t v106 = ((_BYTE)v102 + 1) & 0x1E;
        if (v106 == 2) {
          goto LABEL_238;
        }
        int32x2_t v107 = vmovn_s64((int64x2_t)vcgtq_u64(v104, (uint64x2_t)xmmword_1810FE320));
        if (v107.i8[0])
        {
          *(v100 - 1) = (v103 & 4) != 0;
          if (v107.i8[4]) {
            goto LABEL_256;
          }
        }
        else if (v107.i8[4])
        {
LABEL_256:
          BOOL *v100 = (v103 & 8) != 0;
          if (v106 == 4) {
            goto LABEL_238;
          }
          goto LABEL_257;
        }
        if (v106 == 4) {
          goto LABEL_238;
        }
LABEL_257:
        int32x2_t v108 = vmovn_s64((int64x2_t)vcgtq_u64(v104, (uint64x2_t)xmmword_1810FE330));
        if (v108.i8[0])
        {
          v100[1] = (v103 & 0x10) != 0;
          if ((v108.i8[4] & 1) == 0) {
            goto LABEL_259;
          }
        }
        else if ((v108.i8[4] & 1) == 0)
        {
LABEL_259:
          if (v106 != 6) {
            goto LABEL_263;
          }
          goto LABEL_238;
        }
        v100[2] = (v103 & 0x20) != 0;
        if (v106 != 6)
        {
LABEL_263:
          int32x2_t v109 = vmovn_s64((int64x2_t)vcgtq_u64(v104, (uint64x2_t)xmmword_1810FE340));
          if (v109.i8[0]) {
            v100[3] = (v103 & 0x40) != 0;
          }
          if (v109.i8[4]) {
            v100[4] = v103 >> 7;
          }
        }
LABEL_238:
        ++ElementsAttrRawData;
        v100 += 8;
        v73 -= 8;
        if (!--v24)
        {
          v74 = v126;
          goto LABEL_268;
        }
      }
    }
    mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange);
    unsigned int IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange);
    if (!v24) {
      return *(float *)v25.i32;
    }
    uint64_t v82 = 0;
    int v83 = ~(-1 << IntOrFloatBitWidth);
    v25.i32[0] = 0;
    unint64_t v84 = v26;
    unint64_t v85 = 8 / IntOrFloatBitWidth;
    while (1)
    {
      unint64_t v86 = v82 * v85;
      unint64_t v87 = v26 - v82 * v85;
      if (v87 >= v85) {
        unint64_t v87 = 8 / IntOrFloatBitWidth;
      }
      if (!v87) {
        goto LABEL_194;
      }
      unsigned int v88 = *ElementsAttrRawData;
      if (v84 >= v85) {
        unint64_t v89 = 8 / IntOrFloatBitWidth;
      }
      else {
        unint64_t v89 = v84;
      }
      uint64x2_t v90 = (uint64x2_t)vdupq_n_s64(v89 - 1);
      int32x2_t v91 = vmovn_s64((int64x2_t)vcgeq_u64(v90, (uint64x2_t)xmmword_1810FE2E0));
      if (v91.i8[0]) {
        v8->i64[v86] = v83 & v88;
      }
      if (v91.i8[4]) {
        v8->i64[v86 + 1] = (v88 >> IntOrFloatBitWidth) & v83;
      }
      uint64_t v92 = ((_BYTE)v89 + 1) & 0x1E;
      if (v92 == 2) {
        goto LABEL_194;
      }
      int32x2_t v93 = vmovn_s64((int64x2_t)vcgtq_u64(v90, (uint64x2_t)xmmword_1810FE320));
      if (v93.i8[0])
      {
        v8[1].i64[v86] = (v88 >> (2 * IntOrFloatBitWidth)) & v83;
        if (v93.i8[4]) {
          goto LABEL_211;
        }
      }
      else if (v93.i8[4])
      {
LABEL_211:
        v8[1].i64[v86 + 1] = (v88 >> (3 * IntOrFloatBitWidth)) & v83;
        if (v92 == 4) {
          goto LABEL_194;
        }
        goto LABEL_212;
      }
      if (v92 == 4) {
        goto LABEL_194;
      }
LABEL_212:
      int32x2_t v94 = vmovn_s64((int64x2_t)vcgtq_u64(v90, (uint64x2_t)xmmword_1810FE330));
      if (v94.i8[0])
      {
        v8[2].i64[v86] = (v88 >> (4 * IntOrFloatBitWidth)) & v83;
        if ((v94.i8[4] & 1) == 0) {
          goto LABEL_214;
        }
      }
      else if ((v94.i8[4] & 1) == 0)
      {
LABEL_214:
        if (v92 != 6) {
          goto LABEL_218;
        }
        goto LABEL_194;
      }
      v8[2].i64[v86 + 1] = (v88 >> (5 * IntOrFloatBitWidth)) & v83;
      if (v92 != 6)
      {
LABEL_218:
        int32x2_t v95 = vmovn_s64((int64x2_t)vcgtq_u64(v90, (uint64x2_t)xmmword_1810FE340));
        if (v95.i8[0]) {
          v8[3].i64[v86] = (v88 >> (6 * IntOrFloatBitWidth)) & v83;
        }
        if (v95.i8[4]) {
          v8[3].i64[v86 + 1] = (v88 >> (7 * IntOrFloatBitWidth)) & v83;
        }
      }
LABEL_194:
      ++v82;
      v84 -= v85;
      ++ElementsAttrRawData;
      if (!--v24) {
        return *(float *)v25.i32;
      }
    }
  }
LABEL_174:
  if ((unint64_t)v26 >= 2)
  {
    uint64_t v96 = 0;
    unint64_t v72 = v26 & 0xFFFFFFFFFFFFFFFELL;
    v97 = v8;
    do
    {
      if (v21) {
        uint64_t v98 = 0;
      }
      else {
        uint64_t v98 = v96;
      }
      if (v21) {
        uint64_t v99 = 0;
      }
      else {
        uint64_t v99 = v96 + 1;
      }
      v25.i16[0] = *(_WORD *)&ElementsAttrRawData[2 * v98];
      v25.i16[2] = *(_WORD *)&ElementsAttrRawData[2 * v99];
      uint64x2_t v25 = vcvtq_u64_f64(vcvtq_f64_f32((float32x2_t)vshl_n_s32(*(int32x2_t *)v25.i8, 0x10uLL)));
      *v97++ = v25;
      v96 += 2;
    }
    while (v96 != v72);
    goto LABEL_322;
  }
  unint64_t v72 = 0;
  do
  {
    if (v21) {
      unint64_t v119 = 0;
    }
    else {
      unint64_t v119 = v72;
    }
    v25.i32[0] = *(unsigned __int16 *)&ElementsAttrRawData[2 * v119] << 16;
    v8->i64[v72++] = (unint64_t)*(float *)v25.i32;
LABEL_322:
    ;
  }
  while (v26 != v72);
  return *(float *)v25.i32;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::Conv2DOp &>(mlir::mps::Conv2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t mlir::matchConstantWithIntVector<unsigned long long>(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  if (!a1) {
    return 0;
  }
  unsigned int v8 = (uint64_t **)&v9;
  uint64_t v11 = a1;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp) {
    return 0;
  }
  if (!mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v8, DefiningOp)) {
    return 0;
  }
  v7[0] = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v9);
  v7[1] = v4;
  if (*(_UNKNOWN **)(*(void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v7) + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id) {
    return 0;
  }
  uint64_t v5 = 1;
  mlir::getIntValues<unsigned long long>(v9, v10, a2, 1);
  return v5;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::Conv2DOp,mlir::Value,mlir::Value,unsigned long long,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr&,mlir::mps::PaddingStyle,mlir::mps::TensorDataLayout,mlir::mps::TensorDataLayout>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, unsigned int *a9, unsigned int *a10, unsigned int *a11)
{
  v30[38] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v25);
  uint64_t v20 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_2d", (const unsigned __int8 *)0xB, Context);
  if (!v21)
  {
    __int16 v29 = 1283;
    v28[2] = (uint64_t)"mps.conv_2d";
    v28[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v27 = 259;
    llvm::operator+(v28, (uint64_t *)&v26, (uint64_t)v30);
    llvm::report_fatal_error((llvm::Twine *)v30, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v20);
  mlir::mps::Conv2DOp::build(a1, (uint64_t)v30, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, *a11);
  uint64_t v22 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v30);
  if (*(_UNKNOWN **)(*((void *)v22 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id) {
    uint64_t v23 = v22;
  }
  else {
    uint64_t v23 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v23;
}

void *mlir::mps::anonymous namespace'::CanonicalizePadToConv2DOp<mlir::mps::DepthwiseConv2DOp>::~CanonicalizePadToConv2DOp(void *a1)
{
  v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::mps::anonymous namespace'::CanonicalizePadToConv2DOp<mlir::mps::DepthwiseConv2DOp>::~CanonicalizePadToConv2DOp(void *__p)
{
  v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::DepthwiseConv2DOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::DepthwiseConv2DOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::DepthwiseConv2DOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizePadToConv2DOp<mlir::mps::DepthwiseConv2DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  uint64_t v55 = a2;
  if (mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v55) == 4
    || mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v55) == 2)
  {
    unint64_t v62 = "failed: convolution op already specifies TF_SAME or ONNX_SAME_LOWER padding";
    v64[8] = 259;
    uint64_t v4 = v55;
    unint64_t v59 = &v62;
    uint64_t v5 = a3[2];
    if (v5 && mlir::RewriterBase::Listener::classof(a3[2])) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v5 + 64))(v5, *(void *)(v4 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DepthwiseConv2DOp &>(mlir::mps::DepthwiseConv2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v59);
    }
    return 0;
  }
  unint64_t v62 = *(char **)(*(void *)(v55 + 72) + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v62);
  if (DefiningOp
    && *(_UNKNOWN **)(*(void *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::PadOp,void>::id)
  {
    uint64_t DefiningOp = 0;
  }
  uint64_t v54 = DefiningOp;
  if (!v65) {
    return 0;
  }
  unint64_t v59 = v61;
  uint64_t v60 = 0x600000000;
  unsigned int v8 = v63;
  if (v63)
  {
    if (v63 < 7)
    {
      uint64_t v10 = v61;
      unsigned int v9 = v63;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v61, v63, 8);
      unsigned int v9 = v63;
      if (!v63)
      {
LABEL_18:
        LODWORD(v60) = v8;
        goto LABEL_19;
      }
      uint64_t v10 = v59;
    }
    memcpy(v10, v62, 8 * v9);
    goto LABEL_18;
  }
LABEL_19:
  int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v55);
  if (StorageType == 1)
  {
    if (!v60) {
      goto LABEL_37;
    }
    unint64_t v13 = 0;
    uint64_t v14 = 8 * v60;
    while (v13 > 9 || ((1 << v13) & 0x303) == 0 || !*((void *)v59 + v13))
    {
      ++v13;
      v14 -= 8;
      if (!v14) {
        goto LABEL_37;
      }
    }
  }
  else
  {
    if (StorageType)
    {
      v15 = "failure: incompatible value for TensorDataLayout";
      goto LABEL_59;
    }
    if (!v60
      || !*(void *)v59
      && (v60 == 1
       || !*((void *)v59 + 1)
       && (v60 == 2 || !*((void *)v59 + 2) && (v60 == 3 || !*((void *)v59 + 3)))))
    {
LABEL_37:
      if (mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v55))
      {
LABEL_47:
        *(_OWORD *)uint64_t v57 = xmmword_18110B5E0;
        uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 1), 0x40u, 0);
        uint64_t v28 = (void *)mlir::RankedTensorType::get((uint64_t)v57, 2, IntegerType, 0);
        __int16 v29 = v28;
        if (!v28) {
          goto LABEL_56;
        }
        uint64_t v30 = *v28;
        unint64_t v31 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v32 = *(unsigned int *)(v30 + 16);
        if (!v32) {
          goto LABEL_56;
        }
        unint64_t v33 = *(void **)(v30 + 8);
        unint64_t v34 = &v33[2 * v32];
        do
        {
          unint64_t v35 = v32 >> 1;
          v36 = &v33[2 * (v32 >> 1)];
          unint64_t v38 = *v36;
          unint64_t v37 = v36 + 2;
          v32 += ~(v32 >> 1);
          if (v38 < v31) {
            unint64_t v33 = v37;
          }
          else {
            unint64_t v32 = v35;
          }
        }
        while (v32);
        if (v33 != v34 && *v33 == v31) {
          uint64_t v39 = v33[1];
        }
        else {
LABEL_56:
        }
          uint64_t v39 = 0;
        uint64_t v6 = 1;
        Rewriter = (void **)mlir::DenseElementsAttr::getFromRawBuffer(v29, v39, v59, 8 * v60, 8, 1, 0);
        uint64_t v40 = v55;
        v57[0] = (void *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v54);
        uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v55);
        uint64_t Strides = mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v55);
        uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v55);
        unsigned int v50 = 0;
        unsigned int v49 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v55);
        unsigned int PaddingStyle = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v55);
        unint64_t v41 = mlir::OpBuilder::create<mlir::mps::DepthwiseConv2DOp,mlir::Value,mlir::Value,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr&,mlir::mps::PaddingStyle,mlir::mps::TensorDataLayout,mlir::mps::TensorDataLayout>((mlir::MLIRContext **)a3 + 1, *(void *)(v40 + 24), (uint64_t *)v57, &Filter, &Strides, &InputAttributeNames, (uint64_t *)&Rewriter, &v50, &v49, &PaddingStyle);
        (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a3 + 32))(a3, v40, v41);
        goto LABEL_63;
      }
      v57[0] = v58;
      v57[1] = (void *)0x600000000;
      Rewriter = (void **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v55);
      unint64_t v16 = mlir::Attribute::cast<mlir::ElementsAttr>((uint64_t **)&Rewriter);
      mlir::getIntValues<unsigned long long>((uint64_t)v16, v17, (uint64_t)v57, 1);
      uint64_t v18 = LODWORD(v57[1]);
      unint64_t v19 = (char *)v57[0];
      if (LODWORD(v57[1]))
      {
        uint64_t v20 = (char *)v59;
        if (LODWORD(v57[1]) < 6
          || v59 < (char *)v57[0] + 8 * LODWORD(v57[1]) && v57[0] < (char *)v59 + 8 * LODWORD(v57[1]))
        {
          uint64_t v21 = 0;
LABEL_43:
          uint64_t v22 = v18 - v21;
          uint64_t v23 = 8 * v21;
          uint64_t v24 = &v19[8 * v21];
          uint64_t v25 = &v20[v23];
          do
          {
            uint64_t v26 = *(void *)v24;
            v24 += 8;
            *(void *)v25 += v26;
            v25 += 8;
            --v22;
          }
          while (v22);
          goto LABEL_45;
        }
        uint64_t v21 = (uint64_t)v57[1] & 0xFFFFFFFC;
        unint64_t v44 = (int64x2_t *)((char *)v57[0] + 16);
        unint64_t v45 = (int64x2_t *)((char *)v59 + 16);
        uint64_t v46 = v21;
        do
        {
          int64x2_t v47 = vaddq_s64(*v45, *v44);
          v45[-1] = vaddq_s64(v45[-1], v44[-1]);
          int64x2_t *v45 = v47;
          v44 += 2;
          v45 += 2;
          v46 -= 4;
        }
        while (v46);
        if (v21 != v18) {
          goto LABEL_43;
        }
      }
LABEL_45:
      if (v19 != (char *)v58) {
        free(v19);
      }
      goto LABEL_47;
    }
  }
  v15 = "failed: pad is specified along a batch or channel dimension";
LABEL_59:
  v58[8] = 259;
  uint64_t v42 = v55;
  Rewriter = v57;
  v57[0] = (void *)v15;
  uint64_t v43 = a3[2];
  if (v43 && mlir::RewriterBase::Listener::classof(v43)) {
    uint64_t v6 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void ***))(*(void *)v43 + 64))(v43, *(void *)(v42 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DepthwiseConv2DOp &>(mlir::mps::DepthwiseConv2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &Rewriter);
  }
  else {
    uint64_t v6 = 0;
  }
LABEL_63:
  if (v59 != v61) {
    free(v59);
  }
  if (v65 && v62 != (char *)v64) {
    free(v62);
  }
  return v6;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DepthwiseConv2DOp &>(mlir::mps::DepthwiseConv2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::DepthwiseConv2DOp,mlir::Value,mlir::Value,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr&,mlir::mps::PaddingStyle,mlir::mps::TensorDataLayout,mlir::mps::TensorDataLayout>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, unsigned int *a8, unsigned int *a9, unsigned int *a10)
{
  v29[38] = *MEMORY[0x1E4F143B8];
  uint64_t v24 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  uint64_t v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_2d", (const unsigned __int8 *)0x15, Context);
  if (!v20)
  {
    __int16 v28 = 1283;
    v27[2] = (uint64_t)"mps.depthwise_conv_2d";
    v27[3] = 21;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v29, a2, v19);
  mlir::mps::DepthwiseConv2DOp::build(a1, (uint64_t)v29, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10);
  uint64_t v21 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v29);
  if (*(_UNKNOWN **)(*((void *)v21 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id) {
    uint64_t v22 = v21;
  }
  else {
    uint64_t v22 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  return v22;
}

void mlir::mps::anonymous namespace'::CanonicalizePadToConv3DOp::~CanonicalizePadToConv3DOp(mlir::mps::_anonymous_namespace_::CanonicalizePadToConv3DOp *this)
{
  v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::DepthwiseConv3DOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::DepthwiseConv3DOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::DepthwiseConv3DOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizePadToConv3DOp::matchAndRewrite(uint64_t a1, uint64_t a2, void *a3)
{
  v81[1] = *MEMORY[0x1E4F143B8];
  uint64_t v70 = a2;
  if (mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v70) == 4
    || mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v70) == 2)
  {
    unint64_t v77 = "failed: convolution op already specifies TF_SAME or ONNX_SAME_LOWER padding";
    v79[8] = 259;
    uint64_t v4 = v70;
    __dst = &v77;
    uint64_t v5 = a3[2];
    if (v5 && mlir::RewriterBase::Listener::classof(v5)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v5 + 64))(v5, *(void *)(v4 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DepthwiseConv3DOp &>(mlir::mps::DepthwiseConv3DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &__dst);
    }
    return 0;
  }
  unint64_t v77 = *(char **)(*(void *)(v70 + 72) + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v77);
  if (DefiningOp
    && *(_UNKNOWN **)(*(void *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::PadOp,void>::id)
  {
    uint64_t DefiningOp = 0;
  }
  uint64_t v69 = DefiningOp;
  if (!v80) {
    return 0;
  }
  __dst = v76;
  unint64_t v75 = 0x600000000;
  unsigned int v8 = v78;
  if (!v78) {
    goto LABEL_23;
  }
  unsigned int v9 = v76;
  unsigned int v10 = v78;
  if (v78 >= 7)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v76, v78, 8);
    unsigned int v10 = v78;
    if (!v78) {
      goto LABEL_15;
    }
    unsigned int v9 = __dst;
  }
  memcpy(v9, v77, 8 * v10);
LABEL_15:
  LODWORD(v75) = v8;
  if (!*(void *)__dst)
  {
    if (v8 != 1)
    {
      if (*((void *)__dst + 1)) {
        goto LABEL_16;
      }
      if (v8 != 2)
      {
        if (*((void *)__dst + 2)) {
          goto LABEL_16;
        }
        if (v8 != 3)
        {
          if (*((void *)__dst + 3)) {
            goto LABEL_16;
          }
          if (v8 >= 7)
          {
            unsigned int v50 = v8;
            do
            {
              uint64_t v55 = (char *)__dst;
              v71 = v73;
              uint64_t v72 = 0x600000000;
              size_t v56 = 8 * v50 - 8;
              if (v56 < 0x31)
              {
                uint64_t v57 = 0;
                uint64_t v58 = v73;
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v73, (uint64_t)v56 >> 3, 8);
                uint64_t v57 = v72;
                uint64_t v58 = v71;
              }
              unint64_t v59 = v55 + 8;
              size_t v60 = v56 >> 3;
              memcpy(&v58[4 * v57], v59, v56);
              unint64_t v61 = v71;
              unint64_t v62 = v72 + (v56 >> 3);
              LODWORD(v72) = v72 + v60;
              if (v71 != v73)
              {
                if (__dst != v76)
                {
                  free(__dst);
                  unint64_t v61 = v71;
                  LODWORD(v62) = v72;
                }
                __dst = v61;
                unint64_t v75 = __PAIR64__(HIDWORD(v72), v62);
                v71 = v73;
                HIDWORD(v72) = 0;
                goto LABEL_90;
              }
              uint64_t v63 = v75;
              if (v75 >= v62)
              {
                if (v62) {
                  memmove(__dst, v73, 8 * v62);
                }
                goto LABEL_89;
              }
              if (HIDWORD(v75) >= v62)
              {
                if (v75)
                {
                  memmove(__dst, v73, 8 * v75);
                  goto LABEL_87;
                }
              }
              else
              {
                LODWORD(v75) = 0;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v76, v62, 8);
              }
              uint64_t v63 = 0;
LABEL_87:
              if (v63 != v72) {
                memcpy((char *)__dst + 8 * v63, (char *)v71 + 8 * v63, 8 * v72 - 8 * v63);
              }
LABEL_89:
              LODWORD(v75) = v62;
LABEL_90:
              LODWORD(v72) = 0;
              if (v71 != v73)
              {
                free(v71);
                LODWORD(v62) = v75;
              }
              unsigned int v50 = v62;
            }
            while (v62 > 6);
          }
        }
      }
    }
LABEL_23:
    if (mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v70))
    {
LABEL_43:
      v81[0] = 6;
      uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 1), 0x40u, 0);
      v36 = (void *)mlir::RankedTensorType::get((uint64_t)v81, 1, IntegerType, 0);
      unint64_t v37 = v36;
      if (!v36) {
        goto LABEL_52;
      }
      uint64_t v38 = *v36;
      unint64_t v39 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v40 = *(unsigned int *)(v38 + 16);
      if (!v40) {
        goto LABEL_52;
      }
      unint64_t v41 = *(void **)(v38 + 8);
      uint64_t v42 = &v41[2 * v40];
      do
      {
        unint64_t v43 = v40 >> 1;
        unint64_t v44 = &v41[2 * (v40 >> 1)];
        unint64_t v46 = *v44;
        unint64_t v45 = v44 + 2;
        v40 += ~(v40 >> 1);
        if (v46 < v39) {
          unint64_t v41 = v45;
        }
        else {
          unint64_t v40 = v43;
        }
      }
      while (v40);
      if (v41 != v42 && *v41 == v39) {
        uint64_t v47 = v41[1];
      }
      else {
LABEL_52:
      }
        uint64_t v47 = 0;
      uint64_t v6 = 1;
      v71 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v37, v47, __dst, 8 * v75, 8, 1, 0);
      uint64_t v48 = v70;
      v81[0] = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v69);
      uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v70);
      uint64_t Strides = mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v70);
      uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v70);
      unsigned int v65 = 0;
      int ChannelAxis = mlir::mps::DepthwiseConv3DDataGradientOp::getChannelAxis((mlir::mps::DepthwiseConv3DDataGradientOp *)&v70);
      unsigned int v49 = mlir::OpBuilder::create<mlir::mps::DepthwiseConv3DOp,mlir::Value,mlir::Value,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr&,mlir::mps::PaddingStyle,int>((mlir::Builder *)(a3 + 1), *(void *)(v48 + 24), v81, &Filter, &Strides, &InputAttributeNames, (uint64_t *)&v71, &v65, &ChannelAxis);
      (*(void (**)(void *, uint64_t, mlir::GenericProgramPoint *))(*a3 + 32))(a3, v48, v49);
      goto LABEL_54;
    }
    v71 = v73;
    uint64_t v72 = 0x600000000;
    Rewriter = (uint64_t *)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v70);
    uint64_t v15 = (uint64_t)Rewriter;
    if (!Rewriter) {
      goto LABEL_33;
    }
    uint64_t v16 = *Rewriter;
    unint64_t v17 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v18 = *(unsigned int *)(v16 + 16);
    if (!v18) {
      goto LABEL_33;
    }
    uint64_t v19 = *(void **)(v16 + 8);
    char v20 = &v19[2 * v18];
    do
    {
      unint64_t v21 = v18 >> 1;
      uint64_t v22 = &v19[2 * (v18 >> 1)];
      unint64_t v24 = *v22;
      uint64_t v23 = v22 + 2;
      v18 += ~(v18 >> 1);
      if (v24 < v17) {
        uint64_t v19 = v23;
      }
      else {
        unint64_t v18 = v21;
      }
    }
    while (v18);
    if (v19 != v20 && *v19 == v17) {
      uint64_t v25 = v19[1];
    }
    else {
LABEL_33:
    }
      uint64_t v25 = 0;
    mlir::getIntValues<unsigned long long>(v15, v25, (uint64_t)&v71, 1);
    uint64_t v26 = v72;
    __int16 v27 = (char *)v71;
    if (v72)
    {
      __int16 v28 = (char *)__dst;
      if (v72 < 6
        || __dst < (char *)v71 + 8 * v72 && v71 < (char *)__dst + 8 * v72)
      {
        uint64_t v29 = 0;
LABEL_39:
        uint64_t v30 = v26 - v29;
        uint64_t v31 = 8 * v29;
        unint64_t v32 = &v27[8 * v29];
        unint64_t v33 = &v28[v31];
        do
        {
          uint64_t v34 = *(void *)v32;
          v32 += 8;
          *(void *)v33 += v34;
          v33 += 8;
          --v30;
        }
        while (v30);
        goto LABEL_41;
      }
      uint64_t v29 = v72 & 0xFFFFFFFC;
      uint64_t v51 = (int64x2_t *)((char *)v71 + 16);
      unint64_t v52 = (int64x2_t *)((char *)__dst + 16);
      uint64_t v53 = v29;
      do
      {
        int64x2_t v54 = vaddq_s64(*v52, *v51);
        v52[-1] = vaddq_s64(v52[-1], v51[-1]);
        *unint64_t v52 = v54;
        v51 += 2;
        v52 += 2;
        v53 -= 4;
      }
      while (v53);
      if (v29 != v26) {
        goto LABEL_39;
      }
    }
LABEL_41:
    if (v27 != (char *)v73) {
      free(v27);
    }
    goto LABEL_43;
  }
LABEL_16:
  v71 = "failed: pad is specified along a batch or channel dimension";
  v73[8] = 259;
  uint64_t v11 = v70;
  v81[0] = (uint64_t)&v71;
  uint64_t v12 = a3[2];
  if (v12 && mlir::RewriterBase::Listener::classof(v12)) {
    uint64_t v6 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(void *)v12 + 64))(v12, *(void *)(v11 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DepthwiseConv3DOp &>(mlir::mps::DepthwiseConv3DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v81);
  }
  else {
    uint64_t v6 = 0;
  }
LABEL_54:
  if (__dst != v76) {
    free(__dst);
  }
  if (v80 && v77 != (char *)v79) {
    free(v77);
  }
  return v6;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DepthwiseConv3DOp &>(mlir::mps::DepthwiseConv3DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::DepthwiseConv3DOp,mlir::Value,mlir::Value,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr&,mlir::mps::PaddingStyle,int>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, unsigned int *a8, int *a9)
{
  v28[38] = *MEMORY[0x1E4F143B8];
  uint64_t v23 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v23);
  uint64_t v18 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_3d", (const unsigned __int8 *)0x15, Context);
  if (!v19)
  {
    __int16 v27 = 1283;
    v26[2] = (uint64_t)"mps.depthwise_conv_3d";
    v26[3] = 21;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v25 = 259;
    llvm::operator+(v26, (uint64_t *)&v24, (uint64_t)v28);
    llvm::report_fatal_error((llvm::Twine *)v28, 1);
  }
  mlir::OperationState::OperationState(v28, a2, v18);
  mlir::mps::DepthwiseConv3DOp::build(a1, (uint64_t)v28, *a3, *a4, *a5, *a6, *a7, *a8, *a9);
  char v20 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v28);
  if (*(_UNKNOWN **)(*((void *)v20 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id) {
    unint64_t v21 = v20;
  }
  else {
    unint64_t v21 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v28);
  return v21;
}

void *mlir::mps::anonymous namespace'::CanonicalizePadToPoolOp<mlir::mps::PoolAvgOp>::~CanonicalizePadToPoolOp(void *a1)
{
  v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::mps::anonymous namespace'::CanonicalizePadToPoolOp<mlir::mps::PoolAvgOp>::~CanonicalizePadToPoolOp(void *__p)
{
  v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::PoolAvgOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::PoolAvgOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::PoolAvgOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizePadToPoolOp<mlir::mps::PoolAvgOp>::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::UnknownLoc **a3)
{
  v86[1] = *MEMORY[0x1E4F143B8];
  uint64_t v75 = a2;
  if (mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v75) == 4
    || mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v75) == 2)
  {
    uint64_t v4 = "failed: pooling op already specifies TF_SAME or ONNX_SAME_LOWER padding";
LABEL_4:
    uint64_t v82 = (char *)v4;
    v84[8] = 259;
    uint64_t v5 = v75;
    __dst = &v82;
    uint64_t v6 = (uint64_t)a3[2];
    if (v6 && mlir::RewriterBase::Listener::classof(v6)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v6 + 64))(v6, *(void *)(v5 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolAvgOp &>(mlir::mps::PoolAvgOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &__dst);
    }
    return 0;
  }
  if (mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v75)
    && !mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v75))
  {
    uint64_t v4 = "failed: pooling op ceil_mode && !include_zero_pad";
    goto LABEL_4;
  }
  uint64_t v82 = *(char **)(*(void *)(v75 + 72) + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v82);
  if (DefiningOp
    && *(_UNKNOWN **)(*(void *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::PadOp,void>::id)
  {
    uint64_t DefiningOp = 0;
  }
  uint64_t v74 = DefiningOp;
  if (!v85) {
    return 0;
  }
  __dst = v81;
  unint64_t v80 = 0x600000000;
  unint64_t v9 = v83;
  if (v83)
  {
    unsigned int v10 = v81;
    unsigned int v11 = v83;
    if (v83 >= 7)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v81, v83, 8);
      unsigned int v11 = v83;
      if (!v83) {
        goto LABEL_18;
      }
      unsigned int v10 = __dst;
    }
    memcpy(v10, v82, 8 * v11);
LABEL_18:
    LODWORD(v80) = v9;
    if (v9 < 9) {
      goto LABEL_47;
    }
    unint64_t v12 = 0;
    uint64_t v13 = 8 * v9;
    uint64_t v14 = (char *)__dst + 8 * v9;
    do
    {
      if (v12 <= 7 && *((void *)__dst + v12))
      {
        unint64_t v76 = "failed: pooling can only pad 4 dimensions";
        v78[8] = 259;
        uint64_t v15 = v75;
        v86[0] = (uint64_t)&v76;
        uint64_t v16 = (uint64_t)a3[2];
        if (v16 && mlir::RewriterBase::Listener::classof(v16)) {
          uint64_t v7 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(void *)v16 + 64))(v16, *(void *)(v15 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolAvgOp &>(mlir::mps::PoolAvgOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v86);
        }
        else {
          uint64_t v7 = 0;
        }
        goto LABEL_95;
      }
      ++v12;
      v13 -= 8;
    }
    while (v13);
    unint64_t v76 = v78;
    uint64_t v77 = 0x600000000;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v78, 8uLL, 8);
    uint64_t v18 = (char *)v76 + 8 * v77;
    long long v19 = *((_OWORD *)v14 - 4);
    long long v20 = *((_OWORD *)v14 - 3);
    long long v21 = *((_OWORD *)v14 - 1);
    v18[2] = *((_OWORD *)v14 - 2);
    v18[3] = v21;
    *uint64_t v18 = v19;
    v18[1] = v20;
    unint64_t v9 = (v77 + 8);
    LODWORD(v77) = v77 + 8;
    uint64_t v22 = v76;
    if (v76 != v78)
    {
      if (__dst != v81)
      {
        free(__dst);
        uint64_t v22 = v76;
        LODWORD(v9) = v77;
      }
      __dst = v22;
      unint64_t v80 = __PAIR64__(HIDWORD(v77), v9);
      unint64_t v76 = v78;
      HIDWORD(v77) = 0;
      goto LABEL_45;
    }
    uint64_t v23 = v80;
    if (v80 >= v9)
    {
      if (v9) {
        memmove(__dst, v78, 8 * v9);
      }
      goto LABEL_44;
    }
    if (HIDWORD(v80) >= v9)
    {
      if (v80)
      {
        memmove(__dst, v78, 8 * v80);
        goto LABEL_42;
      }
    }
    else
    {
      LODWORD(v80) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v81, v9, 8);
    }
    uint64_t v23 = 0;
LABEL_42:
    if (v23 != v77) {
      memcpy((char *)__dst + 8 * v23, (char *)v76 + 8 * v23, 8 * v77 - 8 * v23);
    }
LABEL_44:
    LODWORD(v80) = v9;
LABEL_45:
    LODWORD(v77) = 0;
    if (v76 != v78)
    {
      free(v76);
      LODWORD(v9) = v80;
    }
LABEL_47:
    if (v9 > 7) {
      goto LABEL_49;
    }
  }
  llvm::SmallVectorImpl<long long>::insert((uint64_t)&__dst, (uint64_t)__dst, (8 - v9), 0);
LABEL_49:
  if (mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v75))
  {
LABEL_84:
    v86[0] = 8;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 1), 0x40u, 0);
    uint64_t v48 = (void *)mlir::RankedTensorType::get((uint64_t)v86, 1, IntegerType, 0);
    unsigned int v49 = v48;
    if (!v48) {
      goto LABEL_93;
    }
    uint64_t v50 = *v48;
    unint64_t v51 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v52 = *(unsigned int *)(v50 + 16);
    if (!v52) {
      goto LABEL_93;
    }
    uint64_t v53 = *(void **)(v50 + 8);
    int64x2_t v54 = &v53[2 * v52];
    do
    {
      unint64_t v55 = v52 >> 1;
      size_t v56 = &v53[2 * (v52 >> 1)];
      unint64_t v58 = *v56;
      uint64_t v57 = v56 + 2;
      v52 += ~(v52 >> 1);
      if (v58 < v51) {
        uint64_t v53 = v57;
      }
      else {
        unint64_t v52 = v55;
      }
    }
    while (v52);
    if (v53 != v54 && *v53 == v51) {
      uint64_t v59 = v53[1];
    }
    else {
LABEL_93:
    }
      uint64_t v59 = 0;
    uint64_t v7 = 1;
    unint64_t v76 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v49, v59, __dst, 8 * v80, 8, 1, 0);
    uint64_t v60 = v75;
    v86[0] = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v74);
    uint64_t WindowSizes = mlir::mps::PoolAvgGradientOp::getWindowSizes((mlir::mps::PoolAvgGradientOp *)&v75);
    uint64_t Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v75);
    uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v75);
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v75 + 24));
    uint64_t v70 = mlir::mps::PaddingStyleAttr::get(Context, 0);
    uint64_t FastmathAttr = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v75);
    unint64_t v62 = (mlir::UnitAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v75 + 24));
    uint64_t v68 = mlir::UnitAttr::get(v62, v63);
    unint64_t v64 = mlir::OpBuilder::create<mlir::mps::PoolAvgOp,mlir::Value,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyleAttr,mlir::DenseIntElementsAttr&,mlir::UnitAttr,mlir::UnitAttr>(a3 + 1, *(void *)(v60 + 24), v86, &WindowSizes, &Strides, &InputAttributeNames, &v70, (uint64_t *)&v76, &FastmathAttr, &v68);
    (*((void (**)(mlir::UnknownLoc **, uint64_t, mlir::GenericProgramPoint *))*a3 + 4))(a3, v60, v64);
LABEL_95:
    if (__dst != v81) {
      free(__dst);
    }
    if (v85 && v82 != (char *)v84) {
      free(v82);
    }
    return v7;
  }
  unint64_t v76 = v78;
  uint64_t v77 = 0x600000000;
  Offsets = (uint64_t *)mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v75);
  if (v25)
  {
    uint64_t v7 = (uint64_t)Offsets;
    if (!Offsets) {
      goto LABEL_60;
    }
    uint64_t v26 = *Offsets;
    unint64_t v27 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v28 = *(unsigned int *)(v26 + 16);
    if (!v28) {
      goto LABEL_60;
    }
    uint64_t v29 = *(void **)(v26 + 8);
    uint64_t v30 = &v29[2 * v28];
    do
    {
      unint64_t v31 = v28 >> 1;
      unint64_t v32 = &v29[2 * (v28 >> 1)];
      unint64_t v34 = *v32;
      unint64_t v33 = v32 + 2;
      v28 += ~(v28 >> 1);
      if (v34 < v27) {
        uint64_t v29 = v33;
      }
      else {
        unint64_t v28 = v31;
      }
    }
    while (v28);
    if (v29 != v30 && *v29 == v27) {
      uint64_t v35 = v29[1];
    }
    else {
LABEL_60:
    }
      uint64_t v35 = 0;
    int v36 = 1;
    mlir::getIntValues<unsigned long long>(v7, v35, (uint64_t)&v76, 1);
    unint64_t v37 = (char *)v76;
    unsigned int v38 = v77;
    if (!v77)
    {
LABEL_81:
      if (v37 != (char *)v78) {
        free(v37);
      }
      if (!v36) {
        goto LABEL_95;
      }
      goto LABEL_84;
    }
    uint64_t v39 = 0;
    while (!*(void *)((char *)v76 + v39))
    {
      v39 += 8;
      if (8 * v77 == v39) {
        goto LABEL_68;
      }
    }
    if (!mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v75))
    {
      uint64_t v7 = mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolAvgOp &>((uint64_t)a3, &v75, "failed: unable to merge existing explicit padding as include_zero_pad is not set");
      int v36 = 0;
      unint64_t v37 = (char *)v76;
      goto LABEL_81;
    }
    unsigned int v38 = v77;
    unint64_t v37 = (char *)v76;
LABEL_68:
    if (v38)
    {
      unint64_t v40 = __dst;
      if (v38 >= 6)
      {
        uint64_t v42 = 8 * v38;
        if (__dst >= &v37[v42] || v37 >= (char *)__dst + v42)
        {
          unint64_t v43 = 0;
          uint64_t v41 = v38 & 0xFFFFFFFC;
          uint64_t v44 = v42 & 0x7FFFFFFE0;
          do
          {
            unint64_t v45 = (int64x2_t *)&v40[v43 / 8];
            int64x2_t v46 = vaddq_s64(*(int64x2_t *)&v40[v43 / 8 + 2], *(int64x2_t *)&v37[v43 + 16]);
            int64x2_t *v45 = vaddq_s64(*(int64x2_t *)&v40[v43 / 8], *(int64x2_t *)&v37[v43]);
            v45[1] = v46;
            v43 += 32;
          }
          while (v44 != v43);
          if (v41 == v38) {
            goto LABEL_80;
          }
        }
        else
        {
          uint64_t v41 = 0;
        }
      }
      else
      {
        uint64_t v41 = 0;
      }
      do
      {
        v40[v41] += *(void *)&v37[8 * v41];
        ++v41;
      }
      while (v38 != v41);
    }
LABEL_80:
    int v36 = 1;
    goto LABEL_81;
  }
  uint64_t v65 = std::__throw_bad_optional_access[abi:nn180100]();
  return mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolAvgOp &>(v65, v66, v67);
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolAvgOp &>(uint64_t a1, uint64_t *a2, unsigned char *a3)
{
  char v3 = 1;
  char v9 = 1;
  if (*a3)
  {
    uint64_t v7 = a3;
    char v3 = 3;
  }
  char v8 = v3;
  uint64_t v4 = *a2;
  unsigned int v10 = &v7;
  uint64_t v5 = *(void *)(a1 + 16);
  if (!v5) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16));
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v5 + 64))(v5, *(void *)(v4 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolAvgOp &>(mlir::mps::PoolAvgOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v10);
  }
  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolAvgOp &>(mlir::mps::PoolAvgOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::PoolAvgOp,mlir::Value,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyleAttr,mlir::DenseIntElementsAttr&,mlir::UnitAttr,mlir::UnitAttr>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10)
{
  v29[38] = *MEMORY[0x1E4F143B8];
  uint64_t v24 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  uint64_t v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_average", (const unsigned __int8 *)0x13, Context);
  if (!v20)
  {
    __int16 v28 = 1283;
    v27[2] = (uint64_t)"mps.pooling_average";
    v27[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v29, a2, v19);
  mlir::mps::PoolAvgOp::build(a1, (uint64_t)v29, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10);
  long long v21 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v29);
  if (*(_UNKNOWN **)(*((void *)v21 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::PoolAvgOp,void>::id) {
    uint64_t v22 = v21;
  }
  else {
    uint64_t v22 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  return v22;
}

void *mlir::mps::anonymous namespace'::CanonicalizePadToPoolOp<mlir::mps::PoolL2NormOp>::~CanonicalizePadToPoolOp(void *a1)
{
  v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  char v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::mps::anonymous namespace'::CanonicalizePadToPoolOp<mlir::mps::PoolL2NormOp>::~CanonicalizePadToPoolOp(void *__p)
{
  v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  char v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::PoolL2NormOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::PoolL2NormOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::PoolL2NormOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizePadToPoolOp<mlir::mps::PoolL2NormOp>::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::UnknownLoc **a3)
{
  v86[1] = *MEMORY[0x1E4F143B8];
  uint64_t v75 = a2;
  if (mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v75) == 4
    || mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v75) == 2)
  {
    uint64_t v4 = "failed: pooling op already specifies TF_SAME or ONNX_SAME_LOWER padding";
LABEL_4:
    uint64_t v82 = (char *)v4;
    v84[8] = 259;
    uint64_t v5 = v75;
    __dst = &v82;
    uint64_t v6 = (uint64_t)a3[2];
    if (v6 && mlir::RewriterBase::Listener::classof(v6)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v6 + 64))(v6, *(void *)(v5 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(mlir::mps::PoolL2NormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &__dst);
    }
    return 0;
  }
  if (mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v75)
    && !mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v75))
  {
    uint64_t v4 = "failed: pooling op ceil_mode && !include_zero_pad";
    goto LABEL_4;
  }
  uint64_t v82 = *(char **)(*(void *)(v75 + 72) + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v82);
  if (DefiningOp
    && *(_UNKNOWN **)(*(void *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::PadOp,void>::id)
  {
    uint64_t DefiningOp = 0;
  }
  uint64_t v74 = DefiningOp;
  if (!v85) {
    return 0;
  }
  __dst = v81;
  unint64_t v80 = 0x600000000;
  unint64_t v9 = v83;
  if (v83)
  {
    unsigned int v10 = v81;
    unsigned int v11 = v83;
    if (v83 >= 7)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v81, v83, 8);
      unsigned int v11 = v83;
      if (!v83) {
        goto LABEL_18;
      }
      unsigned int v10 = __dst;
    }
    memcpy(v10, v82, 8 * v11);
LABEL_18:
    LODWORD(v80) = v9;
    if (v9 < 9) {
      goto LABEL_47;
    }
    unint64_t v12 = 0;
    uint64_t v13 = 8 * v9;
    uint64_t v14 = (char *)__dst + 8 * v9;
    do
    {
      if (v12 <= 7 && *((void *)__dst + v12))
      {
        unint64_t v76 = "failed: pooling can only pad 4 dimensions";
        v78[8] = 259;
        uint64_t v15 = v75;
        v86[0] = (uint64_t)&v76;
        uint64_t v16 = (uint64_t)a3[2];
        if (v16 && mlir::RewriterBase::Listener::classof(v16)) {
          uint64_t v7 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(void *)v16 + 64))(v16, *(void *)(v15 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(mlir::mps::PoolL2NormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v86);
        }
        else {
          uint64_t v7 = 0;
        }
        goto LABEL_95;
      }
      ++v12;
      v13 -= 8;
    }
    while (v13);
    unint64_t v76 = v78;
    uint64_t v77 = 0x600000000;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v78, 8uLL, 8);
    uint64_t v18 = (char *)v76 + 8 * v77;
    long long v19 = *((_OWORD *)v14 - 4);
    long long v20 = *((_OWORD *)v14 - 3);
    long long v21 = *((_OWORD *)v14 - 1);
    v18[2] = *((_OWORD *)v14 - 2);
    v18[3] = v21;
    *uint64_t v18 = v19;
    v18[1] = v20;
    unint64_t v9 = (v77 + 8);
    LODWORD(v77) = v77 + 8;
    uint64_t v22 = v76;
    if (v76 != v78)
    {
      if (__dst != v81)
      {
        free(__dst);
        uint64_t v22 = v76;
        LODWORD(v9) = v77;
      }
      __dst = v22;
      unint64_t v80 = __PAIR64__(HIDWORD(v77), v9);
      unint64_t v76 = v78;
      HIDWORD(v77) = 0;
      goto LABEL_45;
    }
    uint64_t v23 = v80;
    if (v80 >= v9)
    {
      if (v9) {
        memmove(__dst, v78, 8 * v9);
      }
      goto LABEL_44;
    }
    if (HIDWORD(v80) >= v9)
    {
      if (v80)
      {
        memmove(__dst, v78, 8 * v80);
        goto LABEL_42;
      }
    }
    else
    {
      LODWORD(v80) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v81, v9, 8);
    }
    uint64_t v23 = 0;
LABEL_42:
    if (v23 != v77) {
      memcpy((char *)__dst + 8 * v23, (char *)v76 + 8 * v23, 8 * v77 - 8 * v23);
    }
LABEL_44:
    LODWORD(v80) = v9;
LABEL_45:
    LODWORD(v77) = 0;
    if (v76 != v78)
    {
      free(v76);
      LODWORD(v9) = v80;
    }
LABEL_47:
    if (v9 > 7) {
      goto LABEL_49;
    }
  }
  llvm::SmallVectorImpl<long long>::insert((uint64_t)&__dst, (uint64_t)__dst, (8 - v9), 0);
LABEL_49:
  if (mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v75))
  {
LABEL_84:
    v86[0] = 8;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 1), 0x40u, 0);
    uint64_t v48 = (void *)mlir::RankedTensorType::get((uint64_t)v86, 1, IntegerType, 0);
    unsigned int v49 = v48;
    if (!v48) {
      goto LABEL_93;
    }
    uint64_t v50 = *v48;
    unint64_t v51 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v52 = *(unsigned int *)(v50 + 16);
    if (!v52) {
      goto LABEL_93;
    }
    uint64_t v53 = *(void **)(v50 + 8);
    int64x2_t v54 = &v53[2 * v52];
    do
    {
      unint64_t v55 = v52 >> 1;
      size_t v56 = &v53[2 * (v52 >> 1)];
      unint64_t v58 = *v56;
      uint64_t v57 = v56 + 2;
      v52 += ~(v52 >> 1);
      if (v58 < v51) {
        uint64_t v53 = v57;
      }
      else {
        unint64_t v52 = v55;
      }
    }
    while (v52);
    if (v53 != v54 && *v53 == v51) {
      uint64_t v59 = v53[1];
    }
    else {
LABEL_93:
    }
      uint64_t v59 = 0;
    uint64_t v7 = 1;
    unint64_t v76 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v49, v59, __dst, 8 * v80, 8, 1, 0);
    uint64_t v60 = v75;
    v86[0] = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v74);
    uint64_t WindowSizes = mlir::mps::PoolAvgGradientOp::getWindowSizes((mlir::mps::PoolAvgGradientOp *)&v75);
    uint64_t Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v75);
    uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v75);
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v75 + 24));
    uint64_t v70 = mlir::mps::PaddingStyleAttr::get(Context, 0);
    uint64_t FastmathAttr = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v75);
    unint64_t v62 = (mlir::UnitAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v75 + 24));
    uint64_t v68 = mlir::UnitAttr::get(v62, v63);
    unint64_t v64 = mlir::OpBuilder::create<mlir::mps::PoolL2NormOp,mlir::Value,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyleAttr,mlir::DenseIntElementsAttr&,mlir::UnitAttr,mlir::UnitAttr>(a3 + 1, *(void *)(v60 + 24), v86, &WindowSizes, &Strides, &InputAttributeNames, &v70, (uint64_t *)&v76, &FastmathAttr, &v68);
    (*((void (**)(mlir::UnknownLoc **, uint64_t, mlir::GenericProgramPoint *))*a3 + 4))(a3, v60, v64);
LABEL_95:
    if (__dst != v81) {
      free(__dst);
    }
    if (v85 && v82 != (char *)v84) {
      free(v82);
    }
    return v7;
  }
  unint64_t v76 = v78;
  uint64_t v77 = 0x600000000;
  Offsets = (uint64_t *)mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v75);
  if (v25)
  {
    uint64_t v7 = (uint64_t)Offsets;
    if (!Offsets) {
      goto LABEL_60;
    }
    uint64_t v26 = *Offsets;
    unint64_t v27 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v28 = *(unsigned int *)(v26 + 16);
    if (!v28) {
      goto LABEL_60;
    }
    uint64_t v29 = *(void **)(v26 + 8);
    uint64_t v30 = &v29[2 * v28];
    do
    {
      unint64_t v31 = v28 >> 1;
      unint64_t v32 = &v29[2 * (v28 >> 1)];
      unint64_t v34 = *v32;
      unint64_t v33 = v32 + 2;
      v28 += ~(v28 >> 1);
      if (v34 < v27) {
        uint64_t v29 = v33;
      }
      else {
        unint64_t v28 = v31;
      }
    }
    while (v28);
    if (v29 != v30 && *v29 == v27) {
      uint64_t v35 = v29[1];
    }
    else {
LABEL_60:
    }
      uint64_t v35 = 0;
    int v36 = 1;
    mlir::getIntValues<unsigned long long>(v7, v35, (uint64_t)&v76, 1);
    unint64_t v37 = (char *)v76;
    unsigned int v38 = v77;
    if (!v77)
    {
LABEL_81:
      if (v37 != (char *)v78) {
        free(v37);
      }
      if (!v36) {
        goto LABEL_95;
      }
      goto LABEL_84;
    }
    uint64_t v39 = 0;
    while (!*(void *)((char *)v76 + v39))
    {
      v39 += 8;
      if (8 * v77 == v39) {
        goto LABEL_68;
      }
    }
    if (!mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v75))
    {
      uint64_t v7 = mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>((uint64_t)a3, &v75, "failed: unable to merge existing explicit padding as include_zero_pad is not set");
      int v36 = 0;
      unint64_t v37 = (char *)v76;
      goto LABEL_81;
    }
    unsigned int v38 = v77;
    unint64_t v37 = (char *)v76;
LABEL_68:
    if (v38)
    {
      unint64_t v40 = __dst;
      if (v38 >= 6)
      {
        uint64_t v42 = 8 * v38;
        if (__dst >= &v37[v42] || v37 >= (char *)__dst + v42)
        {
          unint64_t v43 = 0;
          uint64_t v41 = v38 & 0xFFFFFFFC;
          uint64_t v44 = v42 & 0x7FFFFFFE0;
          do
          {
            unint64_t v45 = (int64x2_t *)&v40[v43 / 8];
            int64x2_t v46 = vaddq_s64(*(int64x2_t *)&v40[v43 / 8 + 2], *(int64x2_t *)&v37[v43 + 16]);
            int64x2_t *v45 = vaddq_s64(*(int64x2_t *)&v40[v43 / 8], *(int64x2_t *)&v37[v43]);
            v45[1] = v46;
            v43 += 32;
          }
          while (v44 != v43);
          if (v41 == v38) {
            goto LABEL_80;
          }
        }
        else
        {
          uint64_t v41 = 0;
        }
      }
      else
      {
        uint64_t v41 = 0;
      }
      do
      {
        v40[v41] += *(void *)&v37[8 * v41];
        ++v41;
      }
      while (v38 != v41);
    }
LABEL_80:
    int v36 = 1;
    goto LABEL_81;
  }
  uint64_t v65 = std::__throw_bad_optional_access[abi:nn180100]();
  return mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(v65, v66, v67);
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(uint64_t a1, uint64_t *a2, unsigned char *a3)
{
  char v3 = 1;
  char v9 = 1;
  if (*a3)
  {
    uint64_t v7 = a3;
    char v3 = 3;
  }
  char v8 = v3;
  uint64_t v4 = *a2;
  unsigned int v10 = &v7;
  uint64_t v5 = *(void *)(a1 + 16);
  if (!v5) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16));
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v5 + 64))(v5, *(void *)(v4 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(mlir::mps::PoolL2NormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v10);
  }
  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(mlir::mps::PoolL2NormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::PoolL2NormOp,mlir::Value,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyleAttr,mlir::DenseIntElementsAttr&,mlir::UnitAttr,mlir::UnitAttr>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10)
{
  v29[38] = *MEMORY[0x1E4F143B8];
  uint64_t v24 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  uint64_t v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_l2_norm", (const unsigned __int8 *)0x13, Context);
  if (!v20)
  {
    __int16 v28 = 1283;
    v27[2] = (uint64_t)"mps.pooling_l2_norm";
    v27[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v29, a2, v19);
  mlir::mps::PoolL2NormOp::build(a1, (uint64_t)v29, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10);
  long long v21 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v29);
  if (*(_UNKNOWN **)(*((void *)v21 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::PoolL2NormOp,void>::id) {
    uint64_t v22 = v21;
  }
  else {
    uint64_t v22 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  return v22;
}

void mlir::mps::anonymous namespace'::CanonicalizeConv2DWithConstantOperands::~CanonicalizeConv2DWithConstantOperands(mlir::mps::_anonymous_namespace_::CanonicalizeConv2DWithConstantOperands *this)
{
  v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  char v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  char v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeConv2DWithConstantOperands::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v13[1] = 0;
  uint64_t v14 = a2;
  v13[0] = 0;
  v12[0] = 0;
  v12[1] = 0;
  unsigned int v11 = (uint64_t **)v13;
  v9[0] = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v14);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v9);
  if (!DefiningOp || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v11, DefiningOp)) {
    return 0;
  }
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v14);
  unsigned int v10 = (uint64_t **)v12;
  v9[0] = Filter;
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)v9);
  if (!result) {
    return result;
  }
  if (!mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v10, result)
    || (mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v13) & 1) != 0
    || (mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v12) & 1) != 0)
  {
    return 0;
  }
  uint64_t v7 = v14;
  if (v14) {
    uint64_t InterfaceFor = mlir::OpInterface<mlir::ConvertOpLayoutInterface,mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits>::getInterfaceFor(v14);
  }
  else {
    uint64_t InterfaceFor = 0;
  }
  v9[0] = v7;
  v9[1] = InterfaceFor;
  return mlir::ConvertOpLayoutInterface::convertLayout((uint64_t)v9, 1, 1, a3);
}

uint64_t mlir::OpInterface<mlir::ConvertOpLayoutInterface,mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits>::getInterfaceFor(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  v2 = *(void **)(v1 + 16);
  BOOL v3 = v2 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 48);
  }
  if (v3)
  {
    uint64_t v22 = *(void *)(v1 + 8);
    uint64_t result = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v22);
    if (result)
    {
      uint64_t v20 = result;
      uint64_t v21 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v20 + 104))(v20, v21, v1);
    }
  }
  else
  {
    unint64_t v6 = v4 | v1 & 0xFFFFFFFFFFFFFF00;
    unint64_t v7 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
    unint64_t v8 = *(unsigned int *)(v6 + 40);
    if (!v8) {
      goto LABEL_14;
    }
    char v9 = *(void **)(v6 + 32);
    unsigned int v10 = &v9[2 * v8];
    do
    {
      unint64_t v11 = v8 >> 1;
      unint64_t v12 = &v9[2 * (v8 >> 1)];
      unint64_t v14 = *v12;
      uint64_t v13 = v12 + 2;
      v8 += ~(v8 >> 1);
      if (v14 < v7) {
        char v9 = v13;
      }
      else {
        unint64_t v8 = v11;
      }
    }
    while (v8);
    if (v9 == v10 || *v9 != v7 || (uint64_t result = v9[1]) == 0)
    {
LABEL_14:
      uint64_t v16 = *(void *)(v6 + 24);
      uint64_t v17 = *(void *)(a1 + 48);
      uint64_t v18 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
      uint64_t v19 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v16 + 104);
      return v19(v16, v18, v17);
    }
  }
  return result;
}

uint64_t mlir::TypeID::get<mlir::ConvertOpLayoutInterface>()
{
  unint64_t v0 = 0x1E8EB8000uLL;
  {
    unint64_t v0 = 0x1E8EB8000;
    if (v2)
    {
      unsigned int v10 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConvertOpLayoutInterface]";
      unint64_t v11 = 80;
      unint64_t v3 = llvm::StringRef::find((uint64_t *)&v10, "DesiredTypeName = ", 0x12uLL, 0);
      if (v11 >= v3) {
        unint64_t v4 = v3;
      }
      else {
        unint64_t v4 = v11;
      }
      uint64_t v5 = &v10[v4];
      unint64_t v6 = v11 - v4;
      if (v11 - v4 >= 0x12) {
        uint64_t v7 = 18;
      }
      else {
        uint64_t v7 = v11 - v4;
      }
      unint64_t v8 = v6 - v7;
      if (v8 >= v8 - 1) {
        uint64_t v9 = v8 - 1;
      }
      else {
        uint64_t v9 = v8;
      }
      mlir::detail::TypeIDResolver<mlir::ConvertOpLayoutInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v5[v7], v9);
      unint64_t v0 = 0x1E8EB8000;
    }
  }
  return *(void *)(v0 + 1912);
}

void mlir::mps::anonymous namespace'::CanonicalizeMatMulTransposes::~CanonicalizeMatMulTransposes(mlir::mps::_anonymous_namespace_::CanonicalizeMatMulTransposes *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::MatMulOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::MatMulOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::MatMulOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeMatMulTransposes::matchAndRewrite(uint64_t a1, uint64_t *a2, mlir::BoolAttr **a3)
{
  uint64_t v21 = a2;
  uint64_t Input = (mlir::GenericProgramPoint *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v21);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Input);
  if (!DefiningOp
    || *(_UNKNOWN **)(*(void *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id)
  {
    uint64_t Input = (mlir::GenericProgramPoint *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v21);
    uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&Input);
    if (!result) {
      return result;
    }
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id) {
      return 0;
    }
  }
  uint64_t Input = (mlir::GenericProgramPoint *)v21;
  uint64_t v19 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v21);
  uint64_t v6 = mlir::Value::getDefiningOp((mlir::Value *)&v19);
  if (v6)
  {
    uint64_t v7 = *(void **)(*(void *)(v6 + 48) + 16);
    BOOL v8 = v7 == &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id;
    uint64_t v9 = v7 == &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id ? v6 : 0;
    uint64_t v20 = v9;
    {
      uint64_t v10 = v21[3];
      uint64_t v19 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v20);
      uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&Input);
      BOOL IsNegated = !mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&Input);
      BOOL TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&Input);
      uint64_t Input = mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value,mlir::Value,BOOL,BOOL>(a3 + 1, v10, &v19, &Filter, (unsigned __int8 *)&IsNegated, (unsigned __int8 *)&TransposeRhs);
    }
  }
  uint64_t v19 = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v21);
  uint64_t v11 = mlir::Value::getDefiningOp((mlir::Value *)&v19);
  if (v11)
  {
    unint64_t v12 = *(void **)(*(void *)(v11 + 48) + 16);
    BOOL v13 = v12 == &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id;
    if (v12 == &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id) {
      uint64_t v14 = v11;
    }
    else {
      uint64_t v14 = 0;
    }
    uint64_t v20 = v14;
    {
      uint64_t v15 = v21[3];
      uint64_t v19 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&Input);
      uint64_t Filter = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v20);
      BOOL IsNegated = mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&Input);
      BOOL TransposeRhs = !mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&Input);
      uint64_t Input = mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value,mlir::Value,BOOL,BOOL>(a3 + 1, v15, &v19, &Filter, (unsigned __int8 *)&IsNegated, (unsigned __int8 *)&TransposeRhs);
    }
  }
  if (Input == (mlir::GenericProgramPoint *)v21) {
    return 0;
  }
  (*((void (**)(mlir::BoolAttr **))*a3 + 4))(a3);
  return 1;
}

BOOL mlir::mps::anonymous namespace'::CanonicalizeMatMulTransposes::checkCompatibleTranspose(uint64_t a1)
{
  v33[1] = *MEMORY[0x1E4F143B8];
  uint64_t v27 = 0;
  uint64_t v28 = a1;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  uint64_t v24 = 0;
  uint64_t Filter = (uint64_t *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v28);
  v29[0] = &v26;
  Bias = Filter;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Bias);
  if (!DefiningOp) {
    return 0;
  }
  if (!mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)v29, DefiningOp)) {
    return 0;
  }
  v23[0] = (uint64_t **)&v24;
  Bias = (uint64_t *)mlir::anec::GOC::getBias((mlir::anec::GOC *)&v28);
  uint64_t v3 = mlir::Value::getDefiningOp((mlir::Value *)&Bias);
  if (!v3 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(v23, v3)) {
    return 0;
  }
  unint64_t v4 = (uint64_t **)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v28) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v4) {
    goto LABEL_14;
  }
  uint64_t v5 = *v4;
  unint64_t v6 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v7 = *((unsigned int *)v5 + 4);
  if (!v7) {
    goto LABEL_14;
  }
  BOOL v8 = (void *)v5[1];
  uint64_t v9 = &v8[2 * v7];
  do
  {
    unint64_t v10 = v7 >> 1;
    uint64_t v11 = &v8[2 * (v7 >> 1)];
    unint64_t v13 = *v11;
    unint64_t v12 = v11 + 2;
    v7 += ~(v7 >> 1);
    if (v13 < v6) {
      BOOL v8 = v12;
    }
    else {
      unint64_t v7 = v10;
    }
  }
  while (v7);
  if (v8 != v9 && *v8 == v6) {
    uint64_t v14 = (uint64_t **)v8[1];
  }
  else {
LABEL_14:
  }
    uint64_t v14 = 0;
  v23[0] = v4;
  v23[1] = v14;
  Bias = v33;
  uint64_t v32 = 0x100000000;
  mlir::getIntValues<long long>(v26, v27, (uint64_t)&Bias, 1);
  v29[0] = &v30;
  v29[1] = (void *)0x100000000;
  mlir::getIntValues<long long>(v24, v25, (uint64_t)v29, 1);
  uint64_t v15 = *(void *)v29[0];
  int v16 = v32;
  if (v32 >= HIDWORD(v32))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&Bias, v33, v32 + 1, 8);
    int v16 = v32;
  }
  Bias[v16] = v15;
  LODWORD(v32) = v32 + 1;
  std::__sort<std::__less<long long,long long> &,long long *>();
  if (*Bias == -2 && Bias[1] == -1)
  {
    BOOL v21 = 1;
  }
  else if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v23) {
         && (uint64_t v17 = *Bias, mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v23), v17 == v18 - 2))
  }
  {
    uint64_t v19 = Bias[1];
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v23);
    BOOL v21 = v19 == v20 - 1;
  }
  else
  {
    BOOL v21 = 0;
  }
  if (v29[0] != &v30) {
    free(v29[0]);
  }
  if (Bias != v33) {
    free(Bias);
  }
  return v21;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value,mlir::Value,BOOL,BOOL>(mlir::BoolAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned __int8 *a5, unsigned __int8 *a6)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.matmul", (const unsigned __int8 *)0xA, Context);
  if (!v14)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.matmul";
    v21[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::mps::MatMulOp::build(a1, (uint64_t)v23, *a3, *a4, (mlir::MLIRContext *)*a5, (mlir::MLIRContext *)*a6);
  uint64_t v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id) {
    int v16 = v15;
  }
  else {
    int v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

float mlir::getIntValues<long long>(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v9 = a1;
  uint64_t v10 = a2;
  if (!mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v9) || a4) {
    unint64_t NumElements = mlir::ElementsAttr::getNumElements(v9, v10);
  }
  else {
    unint64_t NumElements = 1;
  }
  unint64_t v7 = *(unsigned int *)(a3 + 8);
  if (NumElements != v7)
  {
    if (NumElements >= v7)
    {
      if (NumElements > *(unsigned int *)(a3 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), NumElements, 8);
        unint64_t v7 = *(unsigned int *)(a3 + 8);
      }
      if (NumElements != v7) {
        bzero((void *)(*(void *)a3 + 8 * v7), 8 * (NumElements - v7));
      }
    }
    *(_DWORD *)(a3 + 8) = NumElements;
  }
  return mlir::copyElementsAttrData<long long>(v9, v10, *(void *)a3, a4);
}

float mlir::copyElementsAttrData<long long>(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  v98[5] = *MEMORY[0x1E4F143B8];
  uint64_t v95 = a1;
  uint64_t v96 = a2;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v95);
  unint64_t v7 = Type;
  if (!Type) {
    goto LABEL_10;
  }
  uint64_t v8 = *Type;
  unint64_t v9 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v10 = *(unsigned int *)(v8 + 16);
  if (!v10) {
    goto LABEL_10;
  }
  uint64_t v11 = *(void **)(v8 + 8);
  unint64_t v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    char v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    uint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      uint64_t v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_10:
  }
    uint64_t v17 = 0;
  v94[0] = v7;
  v94[1] = v17;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v94);
  int v18 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v95);
  ElementsAttrRawData = (unsigned __int8 *)mlir::getElementsAttrRawData(v95);
  uint64_t v21 = v20;
  if (!v18 || a4)
  {
    int64_t NumElements = mlir::ElementsAttr::getNumElements(v95, v96);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
    {
      if (NumElements < 1) {
        return *(float *)v22.i32;
      }
      goto LABEL_17;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 8))
    {
      if (NumElements < 1) {
        return *(float *)v22.i32;
      }
      goto LABEL_28;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16))
    {
      if (NumElements < 1) {
        return *(float *)v22.i32;
      }
      if ((unint64_t)NumElements >= 2)
      {
        uint64_t v29 = 0;
        unint64_t v28 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v18) {
            uint64_t v30 = 0;
          }
          else {
            uint64_t v30 = v29;
          }
          if (v18) {
            uint64_t v31 = 0;
          }
          else {
            uint64_t v31 = v29 + 1;
          }
          uint64_t v32 = *(unsigned __int16 *)&ElementsAttrRawData[2 * v31];
          unint64_t v33 = (void *)(a3 + 8 * v29);
          void *v33 = *(unsigned __int16 *)&ElementsAttrRawData[2 * v30];
          v33[1] = v32;
          v29 += 2;
        }
        while (v29 != v28);
        goto LABEL_200;
      }
      goto LABEL_37;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 16))
    {
      if (NumElements < 1) {
        return *(float *)v22.i32;
      }
      goto LABEL_55;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32))
    {
      if (NumElements < 1) {
        return *(float *)v22.i32;
      }
      goto LABEL_62;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 32))
    {
      if (NumElements < 1) {
        return *(float *)v22.i32;
      }
      goto LABEL_78;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
    {
      if (NumElements < 1) {
        return *(float *)v22.i32;
      }
      goto LABEL_94;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 64))
    {
      if (NumElements < 1) {
        return *(float *)v22.i32;
      }
      goto LABEL_114;
    }
    if (mlir::Type::isF16((mlir::Type *)&OperandRange))
    {
      if (NumElements < 1) {
        return *(float *)v22.i32;
      }
      goto LABEL_125;
    }
    if (mlir::Type::isF32((mlir::Type *)&OperandRange))
    {
      if (NumElements < 1) {
        return *(float *)v22.i32;
      }
      goto LABEL_132;
    }
    if (mlir::Type::isF64((mlir::Type *)&OperandRange))
    {
      if (NumElements < 1) {
        return *(float *)v22.i32;
      }
      goto LABEL_148;
    }
    if (mlir::Type::isBF16((mlir::Type *)&OperandRange))
    {
      if (NumElements < 1) {
        return *(float *)v22.i32;
      }
      goto LABEL_163;
    }
LABEL_165:
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 1))
    {
      if (v18) {
        unint64_t v70 = 1;
      }
      else {
        unint64_t v70 = NumElements;
      }
      llvm::SmallVector<char,40u>::SmallVector((uint64_t)v97, v70);
      mlir::detail::unpackBooleanData(ElementsAttrRawData, v21, (uint64_t)v97[0], (unint64_t)v97[1]);
      v71 = (char *)v97[0];
      if (NumElements >= 1)
      {
        for (uint64_t i = 0; i != NumElements; ++i)
        {
          if (v18) {
            uint64_t v73 = 0;
          }
          else {
            uint64_t v73 = i;
          }
          *(void *)(a3 + 8 * i) = v71[v73];
        }
      }
      if (v71 != (char *)v98) {
        free(v71);
      }
    }
    else
    {
      mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange);
      unsigned int IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange);
      mlir::detail::unpackQuantizedData<long long>(ElementsAttrRawData, v21, a3, NumElements, IntOrFloatBitWidth);
    }
    return *(float *)v22.i32;
  }
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
  {
    int64_t NumElements = 1;
LABEL_17:
    for (uint64_t j = 0; j != NumElements; ++j)
    {
      if (v18) {
        uint64_t v25 = 0;
      }
      else {
        uint64_t v25 = j;
      }
      *(void *)(a3 + 8 * j) = ElementsAttrRawData[v25];
    }
    return *(float *)v22.i32;
  }
  if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 8))
  {
    int64_t NumElements = 1;
LABEL_28:
    for (uint64_t k = 0; k != NumElements; ++k)
    {
      if (v18) {
        uint64_t v27 = 0;
      }
      else {
        uint64_t v27 = k;
      }
      *(void *)(a3 + 8 * k) = (char)ElementsAttrRawData[v27];
    }
    return *(float *)v22.i32;
  }
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16))
  {
    int64_t NumElements = 1;
LABEL_37:
    unint64_t v28 = 0;
    do
    {
      if (v18) {
        unint64_t v84 = 0;
      }
      else {
        unint64_t v84 = v28;
      }
      *(void *)(a3 + 8 * v28++) = *(unsigned __int16 *)&ElementsAttrRawData[2 * v84];
LABEL_200:
      ;
    }
    while (NumElements != v28);
    return *(float *)v22.i32;
  }
  if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 16))
  {
    int64_t NumElements = 1;
LABEL_55:
    if ((unint64_t)NumElements >= 2)
    {
      uint64_t v36 = 0;
      unint64_t v34 = NumElements & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v18) {
          uint64_t v37 = 0;
        }
        else {
          uint64_t v37 = v36;
        }
        if (v18) {
          uint64_t v38 = 0;
        }
        else {
          uint64_t v38 = v36 + 1;
        }
        uint64_t v39 = *(__int16 *)&ElementsAttrRawData[2 * v38];
        unint64_t v40 = (void *)(a3 + 8 * v36);
        void *v40 = *(__int16 *)&ElementsAttrRawData[2 * v37];
        v40[1] = v39;
        v36 += 2;
      }
      while (v36 != v34);
      goto LABEL_206;
    }
    unint64_t v34 = 0;
    do
    {
      if (v18) {
        unint64_t v85 = 0;
      }
      else {
        unint64_t v85 = v34;
      }
      *(void *)(a3 + 8 * v34++) = *(__int16 *)&ElementsAttrRawData[2 * v85];
LABEL_206:
      ;
    }
    while (NumElements != v34);
    return *(float *)v22.i32;
  }
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32))
  {
    int64_t NumElements = 1;
LABEL_62:
    if ((unint64_t)NumElements >= 2)
    {
      uint64_t v42 = 0;
      unint64_t v35 = NumElements & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v18) {
          uint64_t v43 = 0;
        }
        else {
          uint64_t v43 = v42;
        }
        if (v18) {
          uint64_t v44 = 0;
        }
        else {
          uint64_t v44 = v42 + 1;
        }
        uint64_t v45 = *(unsigned int *)&ElementsAttrRawData[4 * v44];
        int64x2_t v46 = (void *)(a3 + 8 * v42);
        void *v46 = *(unsigned int *)&ElementsAttrRawData[4 * v43];
        v46[1] = v45;
        v42 += 2;
      }
      while (v42 != v35);
      goto LABEL_212;
    }
    unint64_t v35 = 0;
    do
    {
      if (v18) {
        unint64_t v86 = 0;
      }
      else {
        unint64_t v86 = v35;
      }
      *(void *)(a3 + 8 * v35++) = *(unsigned int *)&ElementsAttrRawData[4 * v86];
LABEL_212:
      ;
    }
    while (NumElements != v35);
    return *(float *)v22.i32;
  }
  if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 32))
  {
    int64_t NumElements = 1;
LABEL_78:
    if ((unint64_t)NumElements >= 2)
    {
      uint64_t v49 = 0;
      unint64_t v41 = NumElements & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v18) {
          uint64_t v50 = 0;
        }
        else {
          uint64_t v50 = v49;
        }
        if (v18) {
          uint64_t v51 = 0;
        }
        else {
          uint64_t v51 = v49 + 1;
        }
        uint64_t v52 = *(int *)&ElementsAttrRawData[4 * v51];
        uint64_t v53 = (void *)(a3 + 8 * v49);
        *uint64_t v53 = *(int *)&ElementsAttrRawData[4 * v50];
        v53[1] = v52;
        v49 += 2;
      }
      while (v49 != v41);
      goto LABEL_218;
    }
    unint64_t v41 = 0;
    do
    {
      if (v18) {
        unint64_t v87 = 0;
      }
      else {
        unint64_t v87 = v41;
      }
      *(void *)(a3 + 8 * v41++) = *(int *)&ElementsAttrRawData[4 * v87];
LABEL_218:
      ;
    }
    while (NumElements != v41);
    return *(float *)v22.i32;
  }
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
  {
    int64_t NumElements = 1;
LABEL_94:
    for (uint64_t m = 0; m != NumElements; ++m)
    {
      if (v18) {
        uint64_t v48 = 0;
      }
      else {
        uint64_t v48 = m;
      }
      *(void *)(a3 + 8 * m) = *(void *)&ElementsAttrRawData[8 * v48];
    }
    return *(float *)v22.i32;
  }
  if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 64))
  {
    int64_t NumElements = 1;
LABEL_114:
    for (uint64_t n = 0; n != NumElements; ++n)
    {
      if (v18) {
        uint64_t v55 = 0;
      }
      else {
        uint64_t v55 = n;
      }
      *(void *)(a3 + 8 * n) = *(void *)&ElementsAttrRawData[8 * v55];
    }
    return *(float *)v22.i32;
  }
  if (mlir::Type::isF16((mlir::Type *)&OperandRange))
  {
    int64_t NumElements = 1;
LABEL_125:
    if ((unint64_t)NumElements >= 2)
    {
      uint64_t v58 = 0;
      unint64_t v56 = NumElements & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v18) {
          uint64_t v59 = 0;
        }
        else {
          uint64_t v59 = v58;
        }
        if (v18) {
          uint64_t v60 = 0;
        }
        else {
          uint64_t v60 = v58 + 1;
        }
        v22.i16[0] = *(_WORD *)&ElementsAttrRawData[2 * v59];
        uint64_t v61 = (uint64_t)*(short float *)&ElementsAttrRawData[2 * v60];
        unint64_t v62 = (void *)(a3 + 8 * v58);
        *unint64_t v62 = (uint64_t)*(short float *)v22.i16;
        v62[1] = v61;
        v58 += 2;
      }
      while (v58 != v56);
      goto LABEL_224;
    }
    unint64_t v56 = 0;
    do
    {
      if (v18) {
        unint64_t v88 = 0;
      }
      else {
        unint64_t v88 = v56;
      }
      v22.i16[0] = *(_WORD *)&ElementsAttrRawData[2 * v88];
      *(void *)(a3 + 8 * v56++) = (uint64_t)*(short float *)v22.i16;
LABEL_224:
      ;
    }
    while (NumElements != v56);
    return *(float *)v22.i32;
  }
  if (mlir::Type::isF32((mlir::Type *)&OperandRange))
  {
    int64_t NumElements = 1;
LABEL_132:
    if ((unint64_t)NumElements >= 2)
    {
      uint64_t v64 = 0;
      unint64_t v57 = NumElements & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v18) {
          uint64_t v65 = 0;
        }
        else {
          uint64_t v65 = v64;
        }
        if (v18) {
          uint64_t v66 = 0;
        }
        else {
          uint64_t v66 = v64 + 1;
        }
        v22.i32[0] = *(_DWORD *)&ElementsAttrRawData[4 * v65];
        uint64_t v67 = (uint64_t)*(float *)&ElementsAttrRawData[4 * v66];
        uint64_t v68 = (void *)(a3 + 8 * v64);
        *uint64_t v68 = (uint64_t)*(float *)v22.i32;
        v68[1] = v67;
        v64 += 2;
      }
      while (v64 != v57);
      goto LABEL_230;
    }
    unint64_t v57 = 0;
    do
    {
      if (v18) {
        unint64_t v89 = 0;
      }
      else {
        unint64_t v89 = v57;
      }
      v22.i32[0] = *(_DWORD *)&ElementsAttrRawData[4 * v89];
      *(void *)(a3 + 8 * v57++) = (uint64_t)*(float *)v22.i32;
LABEL_230:
      ;
    }
    while (NumElements != v57);
    return *(float *)v22.i32;
  }
  if (mlir::Type::isF64((mlir::Type *)&OperandRange))
  {
    int64_t NumElements = 1;
LABEL_148:
    if ((unint64_t)NumElements >= 2)
    {
      uint64_t v74 = 0;
      unint64_t v63 = NumElements & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v18) {
          uint64_t v75 = 0;
        }
        else {
          uint64_t v75 = v74;
        }
        if (v18) {
          uint64_t v76 = 0;
        }
        else {
          uint64_t v76 = v74 + 1;
        }
        v22.i64[0] = *(void *)&ElementsAttrRawData[8 * v75];
        uint64_t v77 = (uint64_t)*(double *)&ElementsAttrRawData[8 * v76];
        unsigned int v78 = (void *)(a3 + 8 * v74);
        *unsigned int v78 = (uint64_t)*(double *)v22.i64;
        v78[1] = v77;
        v74 += 2;
      }
      while (v74 != v63);
      goto LABEL_236;
    }
    unint64_t v63 = 0;
    do
    {
      if (v18) {
        unint64_t v90 = 0;
      }
      else {
        unint64_t v90 = v63;
      }
      v22.i64[0] = *(void *)&ElementsAttrRawData[8 * v90];
      *(void *)(a3 + 8 * v63++) = (uint64_t)*(double *)v22.i64;
LABEL_236:
      ;
    }
    while (NumElements != v63);
    return *(float *)v22.i32;
  }
  int64_t NumElements = 1;
  if (!mlir::Type::isBF16((mlir::Type *)&OperandRange)) {
    goto LABEL_165;
  }
LABEL_163:
  if ((unint64_t)NumElements >= 2)
  {
    uint64_t v80 = 0;
    unint64_t v69 = NumElements & 0xFFFFFFFFFFFFFFFELL;
    v81 = (int64x2_t *)a3;
    do
    {
      if (v18) {
        uint64_t v82 = 0;
      }
      else {
        uint64_t v82 = v80;
      }
      if (v18) {
        uint64_t v83 = 0;
      }
      else {
        uint64_t v83 = v80 + 1;
      }
      v22.i16[0] = *(_WORD *)&ElementsAttrRawData[2 * v82];
      v22.i16[2] = *(_WORD *)&ElementsAttrRawData[2 * v83];
      int64x2_t v22 = vcvtq_s64_f64(vcvtq_f64_f32((float32x2_t)vshl_n_s32(*(int32x2_t *)v22.i8, 0x10uLL)));
      *v81++ = v22;
      v80 += 2;
    }
    while (v80 != v69);
    goto LABEL_238;
  }
  unint64_t v69 = 0;
  do
  {
    if (v18) {
      unint64_t v91 = 0;
    }
    else {
      unint64_t v91 = v69;
    }
    v22.i32[0] = *(unsigned __int16 *)&ElementsAttrRawData[2 * v91] << 16;
    *(void *)(a3 + 8 * v69++) = (uint64_t)*(float *)v22.i32;
LABEL_238:
    ;
  }
  while (NumElements != v69);
  return *(float *)v22.i32;
}

unsigned __int8 *mlir::detail::unpackQuantizedData<long long>(unsigned __int8 *result, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  if (a2)
  {
    uint64_t v5 = 0;
    int v6 = ~(-1 << a5);
    unint64_t v7 = a4;
    unint64_t v8 = 8 / a5;
    do
    {
      unint64_t v9 = v5 * v8;
      unint64_t v10 = a4 - v5 * v8;
      if (v10 >= v8) {
        unint64_t v10 = 8 / a5;
      }
      if (!v10) {
        goto LABEL_3;
      }
      unsigned int v11 = *result;
      if (v7 >= v8) {
        unint64_t v12 = 8 / a5;
      }
      else {
        unint64_t v12 = v7;
      }
      uint64x2_t v13 = (uint64x2_t)vdupq_n_s64(v12 - 1);
      int32x2_t v14 = vmovn_s64((int64x2_t)vcgeq_u64(v13, (uint64x2_t)xmmword_1810FE2E0));
      if (v14.i8[0]) {
        *(void *)(a3 + 8 * v9) = v6 & v11;
      }
      if (v14.i8[4]) {
        *(void *)(a3 + 8 * v9 + 8) = (v11 >> a5) & v6;
      }
      uint64_t v15 = ((_BYTE)v12 + 1) & 0x1E;
      if (v15 == 2) {
        goto LABEL_3;
      }
      int32x2_t v16 = vmovn_s64((int64x2_t)vcgtq_u64(v13, (uint64x2_t)xmmword_1810FE320));
      if (v16.i8[0])
      {
        *(void *)(a3 + 8 * v9 + 16) = (v11 >> (2 * a5)) & v6;
        if (v16.i8[4])
        {
LABEL_20:
          *(void *)(a3 + 8 * v9 + 24) = (v11 >> (3 * a5)) & v6;
          if (v15 == 4) {
            goto LABEL_3;
          }
          goto LABEL_21;
        }
      }
      else if (v16.i8[4])
      {
        goto LABEL_20;
      }
      if (v15 == 4) {
        goto LABEL_3;
      }
LABEL_21:
      int32x2_t v17 = vmovn_s64((int64x2_t)vcgtq_u64(v13, (uint64x2_t)xmmword_1810FE330));
      if (v17.i8[0])
      {
        *(void *)(a3 + 8 * v9 + 32) = (v11 >> (4 * a5)) & v6;
        if ((v17.i8[4] & 1) == 0)
        {
LABEL_23:
          if (v15 != 6) {
            goto LABEL_27;
          }
          goto LABEL_3;
        }
      }
      else if ((v17.i8[4] & 1) == 0)
      {
        goto LABEL_23;
      }
      *(void *)(a3 + 8 * v9 + 40) = (v11 >> (5 * a5)) & v6;
      if (v15 != 6)
      {
LABEL_27:
        int32x2_t v18 = vmovn_s64((int64x2_t)vcgtq_u64(v13, (uint64x2_t)xmmword_1810FE340));
        if (v18.i8[0]) {
          *(void *)(a3 + 8 * v9 + 48) = (v11 >> (6 * a5)) & v6;
        }
        if (v18.i8[4]) {
          *(void *)(a3 + 8 * v9 + 56) = (v11 >> (7 * a5)) & v6;
        }
      }
LABEL_3:
      ++v5;
      v7 -= v8;
      ++result;
      --a2;
    }
    while (a2);
  }
  return result;
}

void mlir::mps::anonymous namespace'::ReorderDequantPermute::~ReorderDequantPermute(mlir::mps::_anonymous_namespace_::ReorderDequantPermute *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::PermuteOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::PermuteOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::PermuteOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::ReorderDequantPermute::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v35[4] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 24);
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  v28[0] = &v31;
  v28[1] = &v30;
  uint64_t v29 = 0;
  uint64_t FastmathAttr = (mlir::GenericProgramPoint *)a2;
  if (*(_UNKNOWN **)(*(void *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::PermuteOp,void>::id) {
    return 0;
  }
  if ((*(unsigned char *)(a2 + 46) & 0x80) == 0) {
    return 0;
  }
  if (*(_DWORD *)(a2 + 68) != 2) {
    return 0;
  }
  LOBYTE(v27) = 1;
  __p = &v27;
  uint64_t v34 = (uint64_t)&FastmathAttr;
  mlir::detail::enumerateImpl<std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::DequantizeOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::PermuteOp,mlir::detail::op_matcher_with_bind<mlir::mps::DequantizeOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::DequantizeOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> & *)#1},0ul,1ul>(v28, (uint64_t)&__p);
  if (!(_BYTE)v27) {
    return 0;
  }
  uint64_t v29 = FastmathAttr;
  uint64_t v26 = v30;
  uint64_t v27 = v31;
  Value = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v26);
  uint64_t v8 = v7;
  uint64_t FastmathAttr = (mlir::GenericProgramPoint *)mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v27);
  if (FastmathAttr)
  {
    uint64_t NumElements = mlir::ElementsAttr::getNumElements((uint64_t)Value, v8);
    mlir::IntegerAttr::getValue(&FastmathAttr, (llvm::APInt *)&__p);
    if (v34 > 0x40)
    {
      uint64_t v10 = *(void *)__p;
      operator delete[](__p);
    }
    else
    {
      uint64_t v10 = (uint64_t)((void)__p << -(uint64_t)v34) >> -(uint64_t)v34;
    }
    __p = v35;
    uint64_t v34 = 0x400000000;
    mlir::getIntValues<long long>((uint64_t)Value, v8, (uint64_t)&__p, 1);
    uint64_t PositiveAxis = mlir::getPositiveAxis(v10, NumElements);
    if (v34)
    {
      uint64_t v12 = PositiveAxis;
      uint64_t v13 = 0;
      int32x2_t v14 = __p;
      uint64_t v15 = ((v34 - 1) & 0x1FFFFFFFFFFFFFFFLL) + 1;
      uint64_t v16 = 8 * v34;
      while (mlir::getPositiveAxis(v14[v13], NumElements) != v12)
      {
        ++v13;
        v16 -= 8;
        if (!v16)
        {
          uint64_t v13 = v15;
          break;
        }
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    uint64_t v17 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&FastmathAttr);
    int32x2_t v18 = (void *)mlir::IntegerAttr::get(v17, v13);
    if (__p != v35) {
      free(__p);
    }
    __p = v18;
    if (v18) {
      goto LABEL_22;
    }
  }
  else
  {
    __p = 0;
  }
  if ((mlir::mps::DequantizeOp::hasNDParams((mlir::mps::DequantizeOp *)&v27) & 1) == 0)
  {
LABEL_22:
    uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v27);
    uint64_t Bias = v30;
    uint64_t Filter = Input;
    uint64_t FastmathAttr = mlir::OpBuilder::create<mlir::mps::PermuteOp,mlir::Value,mlir::mps::ConstantOp>((mlir::OpBuilder *)(a3 + 8), v3, &Filter, &Bias);
    uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v27);
    uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v27);
    uint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v27);
    uint64_t FunctionType = mlir::func::FuncOp::getFunctionType((mlir::func::FuncOp *)&v27);
    uint64_t v21 = mlir::OpBuilder::create<mlir::mps::DequantizeOp,mlir::mps::PermuteOp &,mlir::Value,mlir::Value,mlir::Value,mlir::Type,mlir::IntegerAttr &>((mlir::UnknownLoc **)(a3 + 8), *(void *)(a2 + 24), &FastmathAttr, &Filter, &Bias, &SparseShape, &FunctionType, (uint64_t *)&__p);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, a2, v21);
    return 1;
  }
  return 0;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::PermuteOp,mlir::Value,mlir::mps::ConstantOp>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, void *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.permute", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    v17[2] = (uint64_t)"mps.permute";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::PermuteOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4 - 16);
  unsigned int v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::PermuteOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::DequantizeOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::PermuteOp,mlir::detail::op_matcher_with_bind<mlir::mps::DequantizeOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::DequantizeOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> & *)#1},0ul,1ul>(uint64_t **a1, uint64_t a2)
{
  unint64_t v4 = *a1;
  uint64_t v13 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v13);
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(void *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id
      && (*v4 ? (BOOL v7 = *v4 == DefiningOp) : (BOOL v7 = 1), v7))
    {
      uint64_t *v4 = DefiningOp;
      char v6 = 1;
    }
    else
    {
      char v6 = 0;
    }
  }
  char v8 = v6 & (**(unsigned char **)a2 != 0);
  if (!DefiningOp) {
    char v8 = 0;
  }
  **(unsigned char **)a2 = v8;
  uint64_t v9 = a1[1];
  uint64_t v13 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 56);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v13);
  if (result)
  {
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v9 || *v9 == result))
    {
      *uint64_t v9 = result;
      char v11 = 1;
    }
    else
    {
      char v11 = 0;
    }
  }
  char v12 = v11 & (**(unsigned char **)a2 != 0);
  if (!result) {
    char v12 = 0;
  }
  **(unsigned char **)a2 = v12;
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::DequantizeOp,mlir::mps::PermuteOp &,mlir::Value,mlir::Value,mlir::Value,mlir::Type,mlir::IntegerAttr &>(mlir::UnknownLoc **a1, uint64_t a2, void *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8)
{
  v27[38] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  uint64_t v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dequantize", (const unsigned __int8 *)0xE, Context);
  if (!v18)
  {
    __int16 v26 = 1283;
    v25[2] = (uint64_t)"mps.dequantize";
    v25[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v27, a2, v17);
  mlir::mps::DequantizeOp::build(a1, (uint64_t)v27, *a3 - 16, *a4, *a5, *a6, *a7, *a8);
  uint64_t v19 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v27);
  if (*(_UNKNOWN **)(*((void *)v19 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id) {
    uint64_t v20 = v19;
  }
  else {
    uint64_t v20 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v27);
  return v20;
}

void mlir::mps::anonymous namespace'::ReorderDequantTranspose::~ReorderDequantTranspose(mlir::mps::_anonymous_namespace_::ReorderDequantTranspose *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::TransposeOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::TransposeOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::TransposeOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::ReorderDequantTranspose::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::Float32Type **a3)
{
  uint64_t v3 = *(void *)(a2 + 24);
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  v31[0] = &v35;
  v31[1] = &v34;
  v31[2] = &v33;
  v37[0] = a2;
  if (*(_UNKNOWN **)(*(void *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id
    && (*(unsigned char *)(a2 + 46) & 0x80) != 0
    && *(_DWORD *)(a2 + 68) == 3)
  {
    LOBYTE(v36[0]) = 1;
    uint64_t v39 = v36;
    unint64_t v40 = v37;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::DequantizeOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::TransposeOp,mlir::detail::op_matcher_with_bind<mlir::mps::DequantizeOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::DequantizeOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> & *)#1},0ul,1ul,2ul>(v31, (uint64_t)&v39);
    if (LOBYTE(v36[0]))
    {
      uint64_t v32 = v37[0];
      uint64_t v29 = v33;
      uint64_t v30 = v34;
      uint64_t v28 = v35;
      if (mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v28)
        || (mlir::mps::DequantizeOp::hasNDParams((mlir::mps::DequantizeOp *)&v28) & 1) == 0)
      {
        uint64_t FastmathAttr = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v28);
        if (!FastmathAttr)
        {
LABEL_40:
          v37[0] = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v28);
          uint64_t v39 = mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>(a3 + 1, v3, v37, &v30, &v29);
          v37[0] = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v28);
          v36[0] = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v28);
          uint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v28);
          uint64_t FunctionType = mlir::func::FuncOp::getFunctionType((mlir::func::FuncOp *)&v28);
          uint64_t v25 = mlir::OpBuilder::create<mlir::mps::DequantizeOp,mlir::mps::PermuteOp &,mlir::Value,mlir::Value,mlir::Value,mlir::Type,mlir::IntegerAttr &>(a3 + 1, *(void *)(a2 + 24), &v39, v37, v36, &SparseShape, &FunctionType, &FastmathAttr);
          (*((void (**)(mlir::Float32Type **, uint64_t, mlir::GenericProgramPoint *))*a3 + 4))(a3, a2, v25);
          return 1;
        }
        uint64_t v6 = *(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v28) + 8);
        uint64_t v7 = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v28);
        Value = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v30);
        uint64_t v10 = v9;
        char v11 = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v29);
        uint64_t SparseShape = v7;
        v37[0] = (uint64_t)Value;
        v37[1] = v10;
        v36[0] = (uint64_t)v11;
        v36[1] = v12;
        mlir::IntegerAttr::getValue(&SparseShape, (llvm::APInt *)&v39);
        if (v40 > 0x40)
        {
          uint64_t PositiveAxis = *(void *)v39;
          operator delete[](v39);
        }
        else
        {
          uint64_t PositiveAxis = (uint64_t)((void)v39 << -(char)v40) >> -(char)v40;
        }
        mlir::ElementsAttr::getSplatValue<llvm::APInt>((mlir::BranchOpInterface *)v37, (llvm::APInt *)&v39);
        if (v40 > 0x40)
        {
          uint64_t v14 = *(void *)v39;
          operator delete[](v39);
        }
        else
        {
          uint64_t v14 = (uint64_t)((void)v39 << -(char)v40) >> -(char)v40;
        }
        mlir::ElementsAttr::getSplatValue<llvm::APInt>((mlir::BranchOpInterface *)v36, (llvm::APInt *)&v39);
        if (v40 > 0x40)
        {
          uint64_t v15 = *(void *)v39;
          operator delete[](v39);
        }
        else
        {
          uint64_t v15 = (uint64_t)((void)v39 << -(char)v40) >> -(char)v40;
        }
        if (((v14 ^ PositiveAxis) & 0x8000000000000000) == 0 && ((v15 ^ PositiveAxis) & 0x8000000000000000) == 0)
        {
LABEL_22:
          if (PositiveAxis == v14 || PositiveAxis == v15)
          {
            if (PositiveAxis == v14) {
              uint64_t v20 = v36;
            }
            else {
              uint64_t v20 = v37;
            }
            mlir::ElementsAttr::value_begin<mlir::IntegerAttr,void>((mlir::CallOpInterface *)v20, (uint64_t)&v39);
            if (BYTE1(v39)) {
              uint64_t v21 = 0;
            }
            else {
              uint64_t v21 = v41;
            }
            if ((_BYTE)v39) {
              uint64_t v22 = v40[v21];
            }
            else {
              uint64_t v22 = (*(uint64_t (**)(uint64_t *, uint64_t))(*v40 + 24))(v40, v21);
            }
            uint64_t v23 = v42(v22);
            if (!(_BYTE)v39)
            {
              __int16 v24 = v40;
              unint64_t v40 = 0;
              if (v24) {
                (*(void (**)(uint64_t *))(*v24 + 8))(v24);
              }
            }
            uint64_t FastmathAttr = v23;
          }
          else
          {
            uint64_t FastmathAttr = SparseShape;
          }
          goto LABEL_40;
        }
        uint64_t v39 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(v6 & 0xFFFFFFFFFFFFFFF8));
        unint64_t v40 = v16;
        if (v39 && mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v39))
        {
          mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v39);
          uint64_t v18 = v17;
          uint64_t PositiveAxis = mlir::getPositiveAxis(PositiveAxis, v17);
          uint64_t v14 = mlir::getPositiveAxis(v14, v18);
          uint64_t v15 = mlir::getPositiveAxis(v15, v18);
          goto LABEL_22;
        }
      }
    }
  }
  return 0;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, void *a4, void *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.transpose", (const unsigned __int8 *)0xD, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.transpose";
    v19[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::TransposeOp::build(a1, (uint64_t)v21, *a3, *a4 - 16, *a5 - 16);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::DequantizeOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::TransposeOp,mlir::detail::op_matcher_with_bind<mlir::mps::DequantizeOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::DequantizeOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> & *)#1},0ul,1ul,2ul>(uint64_t **a1, uint64_t a2)
{
  unint64_t v4 = *a1;
  uint64_t v17 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v17);
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(void *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id
      && (*v4 ? (BOOL v7 = *v4 == DefiningOp) : (BOOL v7 = 1), v7))
    {
      uint64_t *v4 = DefiningOp;
      char v6 = 1;
    }
    else
    {
      char v6 = 0;
    }
  }
  char v8 = v6 & (**(unsigned char **)a2 != 0);
  if (!DefiningOp) {
    char v8 = 0;
  }
  **(unsigned char **)a2 = v8;
  uint64_t v9 = a1[1];
  uint64_t v17 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 56);
  uint64_t v10 = mlir::Value::getDefiningOp((mlir::Value *)&v17);
  if (v10)
  {
    if (*(_UNKNOWN **)(*(void *)(v10 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v9 || *v9 == v10))
    {
      *uint64_t v9 = v10;
      char v11 = 1;
    }
    else
    {
      char v11 = 0;
    }
  }
  char v12 = v11 & (**(unsigned char **)a2 != 0);
  if (!v10) {
    char v12 = 0;
  }
  **(unsigned char **)a2 = v12;
  uint64_t v13 = a1[2];
  uint64_t v17 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 88);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v17);
  if (result)
  {
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v13 || *v13 == result))
    {
      *uint64_t v13 = result;
      char v15 = 1;
    }
    else
    {
      char v15 = 0;
    }
  }
  char v16 = v15 & (**(unsigned char **)a2 != 0);
  if (!result) {
    char v16 = 0;
  }
  **(unsigned char **)a2 = v16;
  return result;
}

void *mlir::ElementsAttr::getSplatValue<llvm::APInt>@<X0>(mlir::BranchOpInterface *a1@<X0>, llvm::APInt *a2@<X8>)
{
  mlir::ElementsAttr::value_begin<llvm::APInt>(a1, (uint64_t)v7);
  uint64_t result = v8;
  if (v7[1]) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = v9;
  }
  if (v7[0])
  {
    uint64_t v5 = &v8[16 * v4];
    unsigned int v6 = *((_DWORD *)v5 + 2);
    *((_DWORD *)a2 + 2) = v6;
    if (v6 > 0x40)
    {
      uint64_t result = llvm::APInt::initSlowCase(a2, (const void **)v5);
      if (v7[0]) {
        return result;
      }
    }
    else
    {
      *(void *)a2 = *(void *)v5;
      if (v7[0]) {
        return result;
      }
    }
  }
  else
  {
    uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v8 + 24))();
    if (v7[0]) {
      return result;
    }
  }
  uint64_t result = v8;
  char v8 = 0;
  if (result) {
    return (void *)(*(uint64_t (**)(void *))(*(void *)result + 8))(result);
  }
  return result;
}

uint64_t mlir::ElementsAttr::value_begin<llvm::APInt>@<X0>(mlir::BranchOpInterface *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = mlir::TypeID::get<llvm::APInt>();
  uint64_t result = mlir::BranchOpInterface::getSuccessorOperands(a1, v4);
  if (!v11) {
    mlir::ElementsAttr::value_begin<llvm::APInt>((llvm *)v9, (uint64_t *)a1);
  }
  char v6 = v9[1];
  if (v9[0])
  {
    uint64_t v7 = v10;
    char v8 = 1;
  }
  else
  {
    char v8 = 0;
    uint64_t v7 = v10;
  }
  *(unsigned char *)a2 = v8;
  *(unsigned char *)(a2 + 1) = v6;
  *(void *)(a2 + 8) = v7;
  *(void *)(a2 + 16) = 0;
  return result;
}

const char *llvm::getTypeName<llvm::APInt>()
{
  uint64_t v5 = "StringRef llvm::getTypeName() [DesiredTypeName = llvm::APInt]";
  unint64_t v6 = 61;
  unint64_t v0 = llvm::StringRef::find((uint64_t *)&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0) {
    unint64_t v1 = v0;
  }
  else {
    unint64_t v1 = v6;
  }
  int v2 = &v5[v1];
  if (v6 - v1 >= 0x12) {
    uint64_t v3 = 18;
  }
  else {
    uint64_t v3 = v6 - v1;
  }
  return &v2[v3];
}

uint64_t mlir::TypeID::get<llvm::APInt>()
{
  unint64_t v0 = 0x1E8EB8000uLL;
  {
    unint64_t v0 = 0x1E8EB8000;
    if (v2)
    {
      uint64_t v10 = "StringRef llvm::getTypeName() [DesiredTypeName = llvm::APInt]";
      unint64_t v11 = 61;
      unint64_t v3 = llvm::StringRef::find((uint64_t *)&v10, "DesiredTypeName = ", 0x12uLL, 0);
      if (v11 >= v3) {
        unint64_t v4 = v3;
      }
      else {
        unint64_t v4 = v11;
      }
      uint64_t v5 = &v10[v4];
      unint64_t v6 = v11 - v4;
      if (v11 - v4 >= 0x12) {
        uint64_t v7 = 18;
      }
      else {
        uint64_t v7 = v11 - v4;
      }
      unint64_t v8 = v6 - v7;
      if (v8 >= v8 - 1) {
        uint64_t v9 = v8 - 1;
      }
      else {
        uint64_t v9 = v8;
      }
      mlir::detail::TypeIDResolver<llvm::APInt,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v5[v7], v9);
      unint64_t v0 = 0x1E8EB8000;
    }
  }
  return *(void *)(v0 + 2328);
}

uint64_t mlir::ElementsAttr::value_begin<mlir::IntegerAttr,void>@<X0>(mlir::CallOpInterface *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = mlir::ElementsAttr::getValues<mlir::IntegerAttr,void>(a1, (uint64_t)v5);
  int v4 = v5[0];
  *(unsigned char *)a2 = v5[0];
  *(unsigned char *)(a2 + 1) = v5[1];
  if (v4) {
    *(void *)(a2 + 8) = v6;
  }
  else {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 16))(v6);
  }
  *(_OWORD *)(a2 + 16) = v7;
  if (!v8)
  {
    uint64_t result = v9;
    uint64_t v9 = 0;
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  if (!v5[0])
  {
    uint64_t result = v6;
    uint64_t v6 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  return result;
}

uint64_t mlir::ElementsAttr::getValues<mlir::IntegerAttr,void>@<X0>(mlir::CallOpInterface *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t ArgOperands = mlir::CallOpInterface::getArgOperands(a1);
  uint64_t v6 = v5;
  mlir::ElementsAttr::getValues<mlir::Attribute>((uint64_t *)a1, (uint64_t)v11);
  uint64_t result = llvm::map_range<mlir::detail::ElementsAttrRange<mlir::detail::ElementsAttrIterator<mlir::Attribute>>,mlir::TypedAttr (*)(mlir::Attribute)>(v11, (uint64_t)_ZZNK4mlir12ElementsAttr9getValuesINS_11IntegerAttrEvEENS_6detail17ElementsAttrRangeIN4llvm15mapped_iteratorINS3_20ElementsAttrIteratorINS_9AttributeEEEPFT_S8_EDTclclsr3stdE7declvalISC_EEdeclL_ZNSt3__17declvalB8nn180100IS9_EEDTclsr3stdE9__declvalISA_ELi0EEEvEEEEEEEEvENUlS8_E_8__invokeES8_, (uint64_t)v15);
  int v8 = v15[0];
  *(unsigned char *)a2 = v15[0];
  *(unsigned char *)(a2 + 1) = v15[1];
  if (v8) {
    *(void *)(a2 + 8) = v16;
  }
  else {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 16))(v16);
  }
  *(_OWORD *)(a2 + 16) = v17;
  int v9 = v18;
  *(unsigned char *)(a2 + 32) = v18;
  *(unsigned char *)(a2 + 33) = v19;
  if (v9)
  {
    *(_OWORD *)(a2 + 40) = *(_OWORD *)v20;
    *(void *)(a2 + 56) = *(void *)&v20[16];
    *(void *)(a2 + 64) = ArgOperands;
    *(void *)(a2 + 72) = v6;
  }
  else
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)v20 + 16))(*(void *)v20);
    int v10 = v18;
    *(_OWORD *)(a2 + 48) = *(_OWORD *)&v20[8];
    *(void *)(a2 + 64) = ArgOperands;
    *(void *)(a2 + 72) = v6;
    if (!v10)
    {
      uint64_t result = *(void *)v20;
      *(void *)__int16 v20 = 0;
      if (result) {
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
      }
    }
  }
  if (!v15[0])
  {
    uint64_t result = v16;
    uint64_t v16 = 0;
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  if (!v13)
  {
    uint64_t result = v14;
    uint64_t v14 = 0;
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  if (!v11[0])
  {
    uint64_t result = v12;
    uint64_t v12 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  return result;
}

void mlir::mps::anonymous namespace'::DivByConstant::~DivByConstant(mlir::mps::_anonymous_namespace_::DivByConstant *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::DivideOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::DivideOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::DivideOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::DivByConstant::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v46[1] = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::DivideOp,void>::id) {
    return 0;
  }
  if ((*(unsigned char *)(a2 + 46) & 0x80) == 0) {
    return 0;
  }
  if (*(_DWORD *)(a2 + 68) != 2) {
    return 0;
  }
  uint64_t v5 = *(void *)(a2 + 72);
  uint64_t v6 = *(void **)(v5 + 24);
  ElementTypeOrSelf = *(void **)(v5 + 56);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&ElementTypeOrSelf);
  if (!DefiningOp) {
    return 0;
  }
  uint64_t v8 = DefiningOp;
  if (*(_UNKNOWN **)(*(void *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id) {
    return 0;
  }
  ElementTypeOrSelf = (void *)mlir::getElementTypeOrSelf((void *)(*(void *)(DefiningOp - 8) & 0xFFFFFFFFFFFFFFF8));
  if (!mlir::Type::isF32((mlir::Type *)&ElementTypeOrSelf)) {
    return 0;
  }
  __p = (void *)mlir::getElementTypeOrSelf((uint64_t)v6);
  if (!mlir::Type::isF32((mlir::Type *)&__p)) {
    return 0;
  }
  uint64_t v9 = *(void *)(a2 + 24);
  uint64_t v38 = v8;
  ElementTypeOrSelf = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v38);
  uint64_t v45 = v10;
  __p = (void *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&ElementTypeOrSelf);
  uint64_t v42 = v11;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&__p);
  uint64_t v12 = (llvm::APFloatBase *)mlir::RankedTensorType::get(0, 0, OperandRange, 0);
  DenseElementsAttrOf = 0;
  unint64_t v40 = v12;
  if (mlir::Type::isIntOrIndex((mlir::Type *)&OperandRange))
  {
    int v13 = mlir::Type::isSignedInteger((mlir::Type *)&OperandRange)
       || mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange);
    if (!v12) {
      goto LABEL_34;
    }
    uint64_t v25 = *(void *)v12;
    unint64_t v26 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v27 = *(unsigned int *)(v25 + 16);
    if (!v27) {
      goto LABEL_34;
    }
    uint64_t v28 = *(void **)(v25 + 8);
    uint64_t v29 = &v28[2 * v27];
    do
    {
      unint64_t v30 = v27 >> 1;
      uint64_t v31 = &v28[2 * (v27 >> 1)];
      unint64_t v33 = *v31;
      uint64_t v32 = v31 + 2;
      v27 += ~(v27 >> 1);
      if (v33 < v26) {
        uint64_t v28 = v32;
      }
      else {
        unint64_t v27 = v30;
      }
    }
    while (v27);
    if (v28 != v29 && *v28 == v26) {
      uint64_t v34 = v28[1];
    }
    else {
LABEL_34:
    }
      uint64_t v34 = 0;
    __p = (void *)mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v40);
    unsigned int IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&__p);
    LODWORD(v42) = IntOrFloatBitWidth;
    if (IntOrFloatBitWidth > 0x40) {
      llvm::APInt::initSlowCase((llvm::APInt *)&__p, 1, v13);
    }
    else {
      __p = (void *)(IntOrFloatBitWidth != 0);
    }
    DenseElementsAttrOf = (uint64_t *)mlir::DenseElementsAttr::get((uint64_t)v12, v34, (llvm::APInt *)&__p, 1);
    if (v42 >= 0x41 && __p) {
      operator delete[](__p);
    }
  }
  else
  {
    if (!v12) {
      goto LABEL_22;
    }
    uint64_t v15 = *(void *)v12;
    unint64_t v16 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v17 = *(unsigned int *)(v15 + 16);
    if (!v17) {
      goto LABEL_22;
    }
    unsigned __int8 v18 = *(void **)(v15 + 8);
    char v19 = &v18[2 * v17];
    do
    {
      unint64_t v20 = v17 >> 1;
      uint64_t v21 = &v18[2 * (v17 >> 1)];
      unint64_t v23 = *v21;
      uint64_t v22 = v21 + 2;
      v17 += ~(v17 >> 1);
      if (v23 < v16) {
        unsigned __int8 v18 = v22;
      }
      else {
        unint64_t v17 = v20;
      }
    }
    while (v17);
    if (v18 != v19 && *v18 == v16) {
      uint64_t v24 = v18[1];
    }
    else {
LABEL_22:
    }
      uint64_t v24 = 0;
    DenseElementsAttrOf = (uint64_t *)mlir::createDenseElementsAttrOfType<float>(v12, v24, 1.0);
  }
  __p = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 8), v9, &DenseElementsAttrOf);
  __p = (void *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&__p);
  uint64_t OperandRange = v8;
  ElementTypeOrSelf = v46;
  uint64_t v45 = 0x100000000;
  mlir::OpBuilder::createOrFold<mlir::mps::DivideOp,mlir::Value,mlir::mps::ConstantOp>(a3 + 8, (uint64_t)&ElementTypeOrSelf, v9, (uint64_t *)&__p, &OperandRange);
  uint64_t v36 = *(void **)ElementTypeOrSelf;
  if (ElementTypeOrSelf != v46) {
    free(ElementTypeOrSelf);
  }
  ElementTypeOrSelf = v36;
  __p = v6;
  uint64_t v37 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)(a3 + 8), *(void *)(a2 + 24), (uint64_t *)&__p, (uint64_t *)&ElementTypeOrSelf);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, a2, v37);
  return 1;
}

void mlir::OpBuilder::createOrFold<mlir::mps::DivideOp,mlir::Value,mlir::mps::ConstantOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, void *a5)
{
  v25[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a3;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.divide", (const unsigned __int8 *)0xA, Context);
  if (!v12)
  {
    __int16 v24 = 1283;
    v23[2] = (uint64_t)"mps.divide";
    v23[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a3, v11);
  mlir::mps::ATan2Op::build((mlir::Float32Type **)a1, (uint64_t)v25, *a4, *a5 - 16);
  uint64_t v14 = (mlir::GenericProgramPoint *)mlir::Operation::create((mlir::Operation *)v25, v13);
  uint64_t v15 = *(void *)(a1 + 16);
  if (v15)
  {
    unint64_t v16 = *(uint64_t **)(a1 + 24);
    llvm::ilist_traits<mlir::Operation>::addNodeToList(v15 + 32, (uint64_t)v14);
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
    uint64_t v17 = *v16;
    *unsigned __int8 v18 = *v16;
    v18[1] = (uint64_t)v16;
    *(void *)(v17 + 8) = v18;
    uint64_t *v16 = (uint64_t)v18;
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
  }
  if (mlir::OpBuilder::tryFold((void *)a1, (uint64_t)v14, a2))
  {
    mlir::Operation::erase(v14);
  }
  else
  {
    uint64_t v19 = *(void *)(a1 + 8);
    if (v19) {
      (*(void (**)(uint64_t, mlir::GenericProgramPoint *))(*(void *)v19 + 16))(v19, v14);
    }
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
}

llvm::APFloatBase *mlir::createDenseElementsAttrOfType<float>(llvm::APFloatBase *a1, uint64_t a2, float a3)
{
  v22[3] = *MEMORY[0x1E4F143B8];
  unsigned __int8 v18 = a1;
  uint64_t v19 = a2;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v18);
  if (mlir::Type::isF16((mlir::Type *)&OperandRange))
  {
    char v17 = 0;
    int v4 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v20, a3);
    uint64_t v5 = llvm::APFloatBase::IEEEsingle(v4);
    llvm::APFloat::Storage::Storage(v22, v20, v5);
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v20);
    long long v7 = llvm::APFloatBase::IEEEhalf(v6);
    llvm::APFloat::convert((uint64_t)&OperandRange, v7, 1, &v17);
    uint64_t v8 = v18;
    uint64_t v9 = v19;
  }
  else
  {
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v18);
    if (!mlir::Type::isF32((mlir::Type *)&OperandRange))
    {
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v18);
      mlir::Type::isIntOrIndex((mlir::Type *)&OperandRange);
      return 0;
    }
    uint64_t v10 = v18;
    uint64_t v11 = v19;
    char v12 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v20, a3);
    int v13 = llvm::APFloatBase::IEEEsingle(v12);
    llvm::APFloat::Storage::Storage(v22, v20, v13);
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v20);
    uint64_t v8 = v10;
    uint64_t v9 = v11;
  }
  uint64_t v14 = (llvm::APFloatBase *)mlir::DenseElementsAttr::get(v8, v9, (uint64_t)&OperandRange, 1);
  uint64_t v15 = (void *)v22[0];
  if (llvm::APFloatBase::PPCDoubleDouble(v14) == v15) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v22);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v22);
  }
  return v14;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    v17[2] = (uint64_t)"mps.multiply";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::mps::anonymous namespace'::AddSubConsts::~AddSubConsts(mlir::mps::_anonymous_namespace_::AddSubConsts *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::AddOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::AddOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::AddOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::AddSubConsts::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::Float32Type **a3)
{
  v17[1] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  v13[0] = &v15;
  v13[1] = &v14;
  void v13[2] = 0;
  if (*(_UNKNOWN **)(*(void *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id
    || (*(unsigned char *)(a2 + 46) & 0x80) == 0
    || *(_DWORD *)(a2 + 68) != 2)
  {
    return 0;
  }
  int v5 = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(a2, 0, v13);
  v16[0] = *(void **)(*(void *)(a2 + 72) + 56);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)v16);
  if (!result) {
    return result;
  }
  int v7 = *(_UNKNOWN **)(*(void *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
     ? v5
     : 0;
  if (v7 != 1) {
    return 0;
  }
  uint64_t v8 = *(void *)(a2 + 24);
  uint64_t v11 = v14;
  uint64_t v12 = result;
  v16[0] = v17;
  v16[1] = (void *)0x100000000;
  mlir::OpBuilder::createOrFold<mlir::mps::SubtractOp,mlir::mps::ConstantOp,mlir::mps::ConstantOp>((uint64_t)(a3 + 1), (uint64_t)v16, v8, &v12, &v11);
  uint64_t v9 = *(void **)v16[0];
  if (v16[0] != v17) {
    free(v16[0]);
  }
  v16[0] = v9;
  uint64_t v12 = v15;
  char v10 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(a3 + 1, *(void *)(a2 + 24), &v12, (uint64_t *)v16);
  (*((void (**)(mlir::Float32Type **, uint64_t, mlir::GenericProgramPoint *))*a3 + 4))(a3, a2, v10);
  return 1;
}

uint64_t mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(uint64_t a1, unsigned int a2, uint64_t **a3)
{
  uint64_t v14 = *(void *)(*(void *)(a1 + 72) + 32 * a2 + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v14);
  uint64_t v6 = DefiningOp;
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(void *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::SubtractOp,void>::id
      || (*(unsigned char *)(DefiningOp + 46) & 0x80) == 0
      || *(_DWORD *)(DefiningOp + 68) != 2)
    {
      goto LABEL_15;
    }
    uint64_t v7 = *(void *)(DefiningOp + 72);
    uint64_t v8 = *(void *)(v7 + 24);
    uint64_t v9 = **a3;
    if (v9)
    {
      BOOL v10 = v9 == v8;
    }
    else
    {
      **a3 = v8;
      uint64_t v7 = *(void *)(DefiningOp + 72);
      BOOL v10 = 1;
    }
    if ((v11 = a3[1], uint64_t v14 = *(void *)(v7 + 56), (v12 = mlir::Value::getDefiningOp((mlir::Value *)&v14)) != 0)
      && *(_UNKNOWN **)(*(void *)(v12 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v11 || *v11 == v12)
      && (*uint64_t v11 = v12, v10))
    {
      a3[2] = (uint64_t *)v6;
      char v5 = 1;
    }
    else
    {
LABEL_15:
      char v5 = 0;
    }
  }
  return (v6 != 0) & v5;
}

void mlir::OpBuilder::createOrFold<mlir::mps::SubtractOp,mlir::mps::ConstantOp,mlir::mps::ConstantOp>(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5)
{
  v25[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a3;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.subtract", (const unsigned __int8 *)0xC, Context);
  if (!v12)
  {
    __int16 v24 = 1283;
    v23[2] = (uint64_t)"mps.subtract";
    v23[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a3, v11);
  mlir::mps::ATan2Op::build((mlir::Float32Type **)a1, (uint64_t)v25, *a4 - 16, *a5 - 16);
  uint64_t v14 = (mlir::GenericProgramPoint *)mlir::Operation::create((mlir::Operation *)v25, v13);
  uint64_t v15 = *(void *)(a1 + 16);
  if (v15)
  {
    __int16 v16 = *(uint64_t **)(a1 + 24);
    llvm::ilist_traits<mlir::Operation>::addNodeToList(v15 + 32, (uint64_t)v14);
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
    uint64_t v17 = *v16;
    *__int16 v18 = *v16;
    v18[1] = (uint64_t)v16;
    *(void *)(v17 + 8) = v18;
    uint64_t *v16 = (uint64_t)v18;
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
  }
  if (mlir::OpBuilder::tryFold((void *)a1, (uint64_t)v14, a2))
  {
    mlir::Operation::erase(v14);
  }
  else
  {
    uint64_t v19 = *(void *)(a1 + 8);
    if (v19) {
      (*(void (**)(uint64_t, mlir::GenericProgramPoint *))(*(void *)v19 + 16))(v19, v14);
    }
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.add";
    v17[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::mps::anonymous namespace'::CanonicalizeInstanceNorm::~CanonicalizeInstanceNorm(mlir::mps::_anonymous_namespace_::CanonicalizeInstanceNorm *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::NormalizationOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::NormalizationOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::NormalizationOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeInstanceNorm::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::Float32Type **a3)
{
  v25[3] = *MEMORY[0x1E4F143B8];
  uint64_t v21 = 0;
  uint64_t v22 = a2;
  uint64_t v20 = 0;
  v19[0] = &v21;
  v19[1] = &v20;
  v19[2] = 0;
  v17[0] = &v21;
  v17[1] = &v20;
  __int16 v18 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  v13[0] = &v21;
  v13[1] = v19;
  void v13[2] = v17;
  v13[3] = &v16;
  v13[4] = &v15;
  uint64_t v14 = 0;
  unint64_t v23 = (llvm::APFloatBase *)a2;
  if (*(_UNKNOWN **)(*(void *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::NormalizationOp,void>::id) {
    return 0;
  }
  if ((*(unsigned char *)(a2 + 46) & 0x80) == 0) {
    return 0;
  }
  if (*(_DWORD *)(a2 + 68) != 5) {
    return 0;
  }
  LOBYTE(v12) = 1;
  __int16 v24 = (mlir::GenericProgramPoint *)&v12;
  v25[0] = &v23;
  mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionVarianceOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::NormalizationOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionVarianceOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionVarianceOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> & *)#1},0ul,1ul,2ul,3ul,4ul>(v13, (uint64_t)&v24);
  if (!(_BYTE)v12) {
    return 0;
  }
  uint64_t v14 = v23;
  __int16 v24 = v18;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v24)) {
    return 0;
  }
  unint64_t v23 = v18;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v23)) {
    return 0;
  }
  uint64_t v5 = *(void *)(a2 + 24);
  uint64_t v11 = v20;
  uint64_t v12 = v21;
  mlir::mps::InstanceNormOp::getEpsilon((mlir::mps::InstanceNormOp *)&v22, (uint64_t)&v24);
  unint64_t v23 = mlir::OpBuilder::create<mlir::mps::InstanceNormOp,mlir::Value,mlir::Value,llvm::APFloat>(a3 + 1, v5, &v12, &v11, (uint64_t)&v24);
  uint64_t v6 = (void *)v25[0];
  if (llvm::APFloatBase::PPCDoubleDouble(v23) == v6) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v25);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v25);
  }
  uint64_t v8 = *(void *)(v22 + 24);
  uint64_t v12 = v16;
  __int16 v24 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::InstanceNormOp &,mlir::Value>(a3 + 1, v8, &v23, &v12);
  uint64_t v9 = v22;
  uint64_t v12 = v15;
  char v10 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::mps::MultiplyOp &,mlir::Value>(a3 + 1, *(void *)(v22 + 24), &v24, &v12);
  (*((void (**)(mlir::Float32Type **, uint64_t, mlir::GenericProgramPoint *))*a3 + 4))(a3, v9, v10);
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::InstanceNormOp,mlir::Value,mlir::Value,llvm::APFloat>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v29[38] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.instance_norm", (const unsigned __int8 *)0x11, Context);
  if (!v12)
  {
    __int16 v26 = 1283;
    v25[2] = (uint64_t)"mps.instance_norm";
    v25[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v29, a2, v11);
  uint64_t v13 = *a3;
  uint64_t v14 = *a4;
  uint64_t v16 = *(void **)(a5 + 8);
  uint64_t v15 = (void *)(a5 + 8);
  __int16 v18 = llvm::APFloatBase::PPCDoubleDouble(v17);
  if (v18 == v16) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v28, v15);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v28, (uint64_t)v15);
  }
  mlir::mps::InstanceNormOp::build(a1, (uint64_t)v29, v13, v14, (uint64_t)v27);
  if (v18 == (void *)v28[0]) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v28);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v28);
  }
  uint64_t v19 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v29);
  if (*(_UNKNOWN **)(*((void *)v19 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::InstanceNormOp,void>::id) {
    uint64_t v20 = v19;
  }
  else {
    uint64_t v20 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  return v20;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::InstanceNormOp &,mlir::Value>(mlir::Float32Type **a1, uint64_t a2, void *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.multiply";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3 - 16, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionVarianceOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::NormalizationOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionVarianceOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionVarianceOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> & *)#1},0ul,1ul,2ul,3ul,4ul>(uint64_t **a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(**(void **)(a2 + 8) + 72);
  uint64_t v5 = *(void *)(v4 + 24);
  uint64_t v6 = **a1;
  if (v6)
  {
    BOOL v7 = v6 == v5;
  }
  else
  {
    **a1 = v5;
    uint64_t v4 = *(void *)(**(void **)(a2 + 8) + 72);
    BOOL v7 = 1;
  }
  if (!**(unsigned char **)a2) {
    BOOL v7 = 0;
  }
  **(unsigned char **)a2 = v7;
  uint64_t v8 = (uint64_t **)a1[1];
  uint64_t v40 = *(void *)(v4 + 56);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v40);
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(void *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ReductionMeanOp,void>::id
      || (*(unsigned char *)(DefiningOp + 46) & 0x80) == 0
      || *(_DWORD *)(DefiningOp + 68) != 2)
    {
      goto LABEL_19;
    }
    uint64_t v11 = *(void *)(DefiningOp + 72);
    uint64_t v12 = *(void *)(v11 + 24);
    uint64_t v13 = **v8;
    if (v13)
    {
      BOOL v14 = v13 == v12;
    }
    else
    {
      **uint64_t v8 = v12;
      uint64_t v11 = *(void *)(DefiningOp + 72);
      BOOL v14 = 1;
    }
    uint64_t v15 = v8[1];
    uint64_t v16 = *(void *)(v11 + 56);
    if (*v15)
    {
      BOOL v17 = *v15 == v16;
    }
    else
    {
      uint64_t *v15 = v16;
      BOOL v17 = 1;
    }
    int v10 = v14 && v17;
    if (v10 == 1) {
      v8[2] = (uint64_t *)DefiningOp;
    }
    else {
LABEL_19:
    }
      LOBYTE(v10) = 0;
  }
  char v18 = v10 & (**(unsigned char **)a2 != 0);
  if (!DefiningOp) {
    char v18 = 0;
  }
  **(unsigned char **)a2 = v18;
  uint64_t v19 = (uint64_t **)a1[2];
  uint64_t v40 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 88);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v40);
  if (result)
  {
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ReductionVarianceOp,void>::id
      || (*(unsigned char *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 2)
    {
      goto LABEL_35;
    }
    uint64_t v22 = *(void *)(result + 72);
    uint64_t v23 = *(void *)(v22 + 24);
    uint64_t v24 = **v19;
    if (v24)
    {
      BOOL v25 = v24 == v23;
    }
    else
    {
      *mlir::GenericProgramPoint *v19 = v23;
      uint64_t v22 = *(void *)(result + 72);
      BOOL v25 = 1;
    }
    __int16 v26 = v19[1];
    uint64_t v27 = *(void *)(v22 + 56);
    if (*v26)
    {
      BOOL v28 = *v26 == v27;
    }
    else
    {
      *__int16 v26 = v27;
      BOOL v28 = 1;
    }
    if (v25 && v28)
    {
      v19[2] = (uint64_t *)result;
      char v21 = 1;
    }
    else
    {
LABEL_35:
      char v21 = 0;
    }
  }
  uint64_t v29 = *(BOOL **)a2;
  BOOL v30 = v21 & (**(unsigned char **)a2 != 0);
  if (result) {
    BOOL v31 = v30;
  }
  else {
    BOOL v31 = 0;
  }
  BOOL *v29 = v31;
  uint64_t v32 = a1[3];
  uint64_t v33 = *(void *)(**(void **)(a2 + 8) + 72);
  uint64_t v34 = *(void *)(v33 + 120);
  if (*v32)
  {
    BOOL v35 = *v32 == v34;
  }
  else
  {
    *uint64_t v32 = v34;
    uint64_t v29 = *(BOOL **)a2;
    uint64_t v33 = *(void *)(**(void **)(a2 + 8) + 72);
    BOOL v31 = **(unsigned char **)a2 != 0;
    BOOL v35 = 1;
  }
  BOOL v36 = v35 && v31;
  BOOL *v29 = v36;
  uint64_t v37 = a1[4];
  uint64_t v38 = *(void *)(v33 + 152);
  if (*v37)
  {
    BOOL v39 = *v37 == v38;
  }
  else
  {
    uint64_t *v37 = v38;
    uint64_t v29 = *(BOOL **)a2;
    BOOL v36 = **(unsigned char **)a2 != 0;
    BOOL v39 = 1;
  }
  BOOL *v29 = v39 && v36;
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::AddOp,mlir::mps::MultiplyOp &,mlir::Value>(mlir::Float32Type **a1, uint64_t a2, void *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.add";
    v17[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3 - 16, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::mps::anonymous namespace'::CanonicalizeMultiply::~CanonicalizeMultiply(mlir::mps::_anonymous_namespace_::CanonicalizeMultiply *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::MultiplyOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::MultiplyOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::MultiplyOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeMultiply::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v28 = a2;
  uint64_t Input = (unint64_t *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v28);
  uint64_t v27 = Input;
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v28);
  uint64_t v26 = Filter;
  if (Input == (unint64_t *)Filter)
  {
    uint64_t v22 = v28;
    v25[0] = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v28);
    uint64_t v23 = mlir::OpBuilder::create<mlir::mps::SquareOp,mlir::Value>((mlir::OpBuilder *)(a3 + 8), *(void *)(v22 + 24), v25);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, v22, v23);
    return 1;
  }
  else
  {
    uint64_t v6 = (unint64_t *)Filter;
    BOOL v7 = (uint64_t *)(*(void *)(v28 - 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v7) {
      goto LABEL_11;
    }
    uint64_t v8 = *v7;
    unint64_t v9 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v10 = *(unsigned int *)(v8 + 16);
    if (!v10) {
      goto LABEL_11;
    }
    uint64_t v11 = *(void **)(v8 + 8);
    uint64_t v12 = &v11[2 * v10];
    do
    {
      unint64_t v13 = v10 >> 1;
      uint64_t v14 = &v11[2 * (v10 >> 1)];
      unint64_t v16 = *v14;
      uint64_t v15 = v14 + 2;
      v10 += ~(v10 >> 1);
      if (v16 < v9) {
        uint64_t v11 = v15;
      }
      else {
        unint64_t v10 = v13;
      }
    }
    while (v10);
    if (v11 != v12 && *v11 == v9) {
      uint64_t v17 = v11[1];
    }
    else {
LABEL_11:
    }
      uint64_t v17 = 0;
    v25[0] = (uint64_t)v7;
    v25[1] = v17;
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v25))
    {
      ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v25);
      if (v19)
      {
        uint64_t v20 = 8 * v19;
        while (*ArgAttrsAttr != 0x8000000000000000)
        {
          ++ArgAttrsAttr;
          v20 -= 8;
          if (!v20) {
            goto LABEL_17;
          }
        }
      }
      else
      {
LABEL_17:
        if (mlir::isConstantFPOne(Input) && v25[0] == (v6[1] & 0xFFFFFFFFFFFFFFF8))
        {
          uint64_t v21 = 1;
          (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(void *)a3 + 24))(a3, v28, &v26, 1);
          return v21;
        }
        if (mlir::isConstantFPOne(v6) && v25[0] == (Input[1] & 0xFFFFFFFFFFFFFFF8))
        {
          uint64_t v21 = 1;
          (*(void (**)(uint64_t, uint64_t, unint64_t **, uint64_t))(*(void *)a3 + 24))(a3, v28, &v27, 1);
          return v21;
        }
      }
    }
    return 0;
  }
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SquareOp,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.square", (const unsigned __int8 *)0xA, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"mps.square";
    v15[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3);
  unint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SquareOp,void>::id) {
    unint64_t v10 = v9;
  }
  else {
    unint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

void mlir::mps::anonymous namespace'::CanonicalizeAdd::~CanonicalizeAdd(mlir::mps::_anonymous_namespace_::CanonicalizeAdd *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeAdd::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v25 = a2;
  uint64_t v4 = (uint64_t *)(*(void *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v4) {
    goto LABEL_10;
  }
  uint64_t v5 = *v4;
  unint64_t v6 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v7 = *(unsigned int *)(v5 + 16);
  if (!v7) {
    goto LABEL_10;
  }
  char v8 = *(void **)(v5 + 8);
  unint64_t v9 = &v8[2 * v7];
  do
  {
    unint64_t v10 = v7 >> 1;
    uint64_t v11 = &v8[2 * (v7 >> 1)];
    unint64_t v13 = *v11;
    uint64_t v12 = v11 + 2;
    v7 += ~(v7 >> 1);
    if (v13 < v6) {
      char v8 = v12;
    }
    else {
      unint64_t v7 = v10;
    }
  }
  while (v7);
  if (v8 != v9 && *v8 == v6) {
    uint64_t v14 = v8[1];
  }
  else {
LABEL_10:
  }
    uint64_t v14 = 0;
  v24[0] = v4;
  v24[1] = v14;
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v24))
  {
    ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v24);
    if (v16)
    {
      uint64_t v17 = 8 * v16;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v17 -= 8;
        if (!v17) {
          goto LABEL_16;
        }
      }
    }
    else
    {
LABEL_16:
      uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v25);
      uint64_t v23 = Input;
      uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v25);
      uint64_t v22 = Filter;
      if (mlir::isConstantFPValue(Input, 0.0)
        && v24[0] == (*(void *)(Filter + 8) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v20 = 1;
        (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(void *)a3 + 24))(a3, v25, &v22, 1);
        return v20;
      }
      if (mlir::isConstantFPValue(Filter, 0.0)
        && v24[0] == (*(void *)(Input + 8) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v20 = 1;
        (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(void *)a3 + 24))(a3, v25, &v23, 1);
        return v20;
      }
    }
  }
  return 0;
}

void *mlir::mps::anonymous namespace'::CanonicalizeReshapeChain<mlir::mps::ReshapeOp>::~CanonicalizeReshapeChain(void *a1)
{
  int v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  unint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::mps::anonymous namespace'::CanonicalizeReshapeChain<mlir::mps::ReshapeOp>::~CanonicalizeReshapeChain(void *__p)
{
  int v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  unint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeReshapeChain<mlir::mps::ReshapeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v21 = 0;
  uint64_t v22 = a2;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v16 = (uint64_t ****)&v21;
  uint64_t v17 = &v20;
  uint64_t v18 = 0;
  unint64_t v13 = (uint64_t **)&v16;
  uint64_t v14 = &v19;
  uint64_t v15 = 0;
  uint64_t v25 = a2;
  uint64_t v4 = *(void *)(a2 + 48);
  if (*(_UNKNOWN **)(v4 + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id
    && (*(unsigned char *)(a2 + 46) & 0x80) != 0
    && *(_DWORD *)(a2 + 68) == 2)
  {
    LOBYTE(FastmathAttr) = 1;
    uint64_t v23 = (uint64_t ***)&FastmathAttr;
    uint64_t v24 = &v25;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(&v13, (uint64_t)&v23);
    if ((_BYTE)FastmathAttr)
    {
      uint64_t v15 = v25;
      uint64_t v5 = v22;
      uint64_t v23 = (uint64_t ***)v21;
      uint64_t v25 = v19;
      uint64_t FastmathAttr = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v22);
      unint64_t v6 = (mlir::OpBuilder *)(a3 + 8);
      uint64_t v7 = *(void *)(v5 + 24);
      char v8 = (uint64_t *)&v23;
      p_uint64_t FastmathAttr = &FastmathAttr;
LABEL_12:
      unint64_t v10 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,mlir::Value,mlir::UnitAttr>(v6, v7, v8, &v25, p_FastmathAttr);
      (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, v5, v10);
      return 1;
    }
    a2 = v22;
    uint64_t v4 = *(void *)(v22 + 48);
  }
  uint64_t v21 = 0;
  uint64_t v20 = 0;
  uint64_t v23 = &v21;
  uint64_t v24 = 0;
  uint64_t v16 = &v23;
  uint64_t v17 = &v20;
  uint64_t v18 = 0;
  uint64_t v25 = a2;
  if (*(_UNKNOWN **)(v4 + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id
    && (*(unsigned char *)(a2 + 46) & 0x80) != 0
    && *(_DWORD *)(a2 + 68) == 2)
  {
    LOBYTE(v19) = 1;
    unint64_t v13 = (uint64_t **)&v19;
    uint64_t v14 = &v25;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>((uint64_t ***)&v16, (uint64_t)&v13);
    if ((_BYTE)v19)
    {
      uint64_t v18 = v25;
      uint64_t v5 = v22;
      unint64_t v13 = v21;
      uint64_t v25 = v20;
      uint64_t v19 = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v22);
      unint64_t v6 = (mlir::OpBuilder *)(a3 + 8);
      uint64_t v7 = *(void *)(v5 + 24);
      char v8 = (uint64_t *)&v13;
      p_uint64_t FastmathAttr = &v19;
      goto LABEL_12;
    }
  }
  return 0;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v20 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 24);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v20);
  if (result)
  {
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id
      || (*(unsigned char *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 2)
    {
      goto LABEL_14;
    }
    uint64_t v7 = *(void *)(result + 72);
    uint64_t v8 = *(void *)(v7 + 24);
    uint64_t v9 = **v4;
    if (v9)
    {
      BOOL v10 = v9 == v8;
    }
    else
    {
      *uint64_t *v4 = v8;
      uint64_t v7 = *(void *)(result + 72);
      BOOL v10 = 1;
    }
    uint64_t v11 = v4[1];
    uint64_t v12 = *(void *)(v7 + 56);
    if (*v11)
    {
      BOOL v13 = *v11 == v12;
    }
    else
    {
      *uint64_t v11 = v12;
      BOOL v13 = 1;
    }
    if (v10 && v13)
    {
      v4[2] = (uint64_t *)result;
      char v6 = 1;
    }
    else
    {
LABEL_14:
      char v6 = 0;
    }
  }
  uint64_t v14 = *(unsigned char **)a2;
  uint64_t v15 = *(void *)(a2 + 8);
  char v16 = v6 & (**(unsigned char **)a2 != 0);
  if (!result) {
    char v16 = 0;
  }
  *uint64_t v14 = v16;
  uint64_t v17 = a1[1];
  uint64_t v18 = *(uint64_t **)(*(void *)(*(void *)v15 + 72) + 56);
  if (*v17)
  {
    BOOL v19 = *v17 == v18;
  }
  else
  {
    *uint64_t v17 = v18;
    uint64_t v14 = *(unsigned char **)a2;
    char v16 = **(unsigned char **)a2 != 0;
    BOOL v19 = 1;
  }
  *uint64_t v14 = v19 & v16;
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,mlir::Value,mlir::UnitAttr>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reshape", (const unsigned __int8 *)0xB, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.reshape";
    void v19[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::ReshapeOp::build((uint64_t)a1, (uint64_t)v21, *a3, *a4, *a5);
  BOOL v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v15 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 24);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v15);
  if (result)
  {
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id
      || (*(unsigned char *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 1)
    {
      goto LABEL_7;
    }
    uint64_t v7 = *(void *)(*(void *)(result + 72) + 24);
    uint64_t v8 = **v4;
    if (v8)
    {
      if (v8 != v7)
      {
LABEL_7:
        char v6 = 0;
        goto LABEL_8;
      }
    }
    else
    {
      *uint64_t *v4 = v7;
    }
    v4[1] = (uint64_t *)result;
    char v6 = 1;
  }
LABEL_8:
  uint64_t v9 = *(unsigned char **)a2;
  uint64_t v10 = *(void *)(a2 + 8);
  char v11 = v6 & (**(unsigned char **)a2 != 0);
  if (!result) {
    char v11 = 0;
  }
  *uint64_t v9 = v11;
  char v12 = a1[1];
  BOOL v13 = *(uint64_t **)(*(void *)(*(void *)v10 + 72) + 56);
  if (*v12)
  {
    BOOL v14 = *v12 == v13;
  }
  else
  {
    *char v12 = v13;
    uint64_t v9 = *(unsigned char **)a2;
    char v11 = **(unsigned char **)a2 != 0;
    BOOL v14 = 1;
  }
  *uint64_t v9 = v14 & v11;
  return result;
}

void *mlir::mps::anonymous namespace'::CanonicalizeReshapeChain<mlir::mps::SqueezeOp>::~CanonicalizeReshapeChain(void *a1)
{
  int v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  unint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::mps::anonymous namespace'::CanonicalizeReshapeChain<mlir::mps::SqueezeOp>::~CanonicalizeReshapeChain(void *__p)
{
  int v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  unint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeReshapeChain<mlir::mps::SqueezeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v21 = 0;
  uint64_t v22 = a2;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v16 = (uint64_t ****)&v21;
  uint64_t v17 = &v20;
  uint64_t v18 = 0;
  BOOL v13 = (uint64_t **)&v16;
  BOOL v14 = &v19;
  uint64_t v15 = 0;
  uint64_t v25 = a2;
  uint64_t v4 = *(void *)(a2 + 48);
  if (*(_UNKNOWN **)(v4 + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id
    && (*(unsigned char *)(a2 + 46) & 0x80) != 0
    && *(_DWORD *)(a2 + 68) == 2)
  {
    LOBYTE(FastmathAttr) = 1;
    uint64_t v23 = (uint64_t ***)&FastmathAttr;
    uint64_t v24 = &v25;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(&v13, (uint64_t)&v23);
    if ((_BYTE)FastmathAttr)
    {
      uint64_t v15 = v25;
      uint64_t v5 = v22;
      uint64_t v23 = (uint64_t ***)v21;
      uint64_t v25 = v19;
      uint64_t FastmathAttr = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v22);
      char v6 = (mlir::OpBuilder *)(a3 + 8);
      uint64_t v7 = *(void *)(v5 + 24);
      uint64_t v8 = (uint64_t *)&v23;
      p_uint64_t FastmathAttr = &FastmathAttr;
LABEL_12:
      uint64_t v10 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,mlir::Value,mlir::UnitAttr>(v6, v7, v8, &v25, p_FastmathAttr);
      (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, v5, v10);
      return 1;
    }
    a2 = v22;
    uint64_t v4 = *(void *)(v22 + 48);
  }
  uint64_t v21 = 0;
  uint64_t v20 = 0;
  uint64_t v23 = &v21;
  uint64_t v24 = 0;
  uint64_t v16 = &v23;
  uint64_t v17 = &v20;
  uint64_t v18 = 0;
  uint64_t v25 = a2;
  if (*(_UNKNOWN **)(v4 + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id
    && (*(unsigned char *)(a2 + 46) & 0x80) != 0
    && *(_DWORD *)(a2 + 68) == 2)
  {
    LOBYTE(v19) = 1;
    BOOL v13 = (uint64_t **)&v19;
    BOOL v14 = &v25;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>((uint64_t ***)&v16, (uint64_t)&v13);
    if ((_BYTE)v19)
    {
      uint64_t v18 = v25;
      uint64_t v5 = v22;
      BOOL v13 = v21;
      uint64_t v25 = v20;
      uint64_t v19 = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v22);
      char v6 = (mlir::OpBuilder *)(a3 + 8);
      uint64_t v7 = *(void *)(v5 + 24);
      uint64_t v8 = (uint64_t *)&v13;
      p_uint64_t FastmathAttr = &v19;
      goto LABEL_12;
    }
  }
  return 0;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v20 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 24);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v20);
  if (result)
  {
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::SqueezeOp,void>::id
      || (*(unsigned char *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 2)
    {
      goto LABEL_14;
    }
    uint64_t v7 = *(void *)(result + 72);
    uint64_t v8 = *(void *)(v7 + 24);
    uint64_t v9 = **v4;
    if (v9)
    {
      BOOL v10 = v9 == v8;
    }
    else
    {
      *uint64_t *v4 = v8;
      uint64_t v7 = *(void *)(result + 72);
      BOOL v10 = 1;
    }
    char v11 = v4[1];
    uint64_t v12 = *(void *)(v7 + 56);
    if (*v11)
    {
      BOOL v13 = *v11 == v12;
    }
    else
    {
      *char v11 = v12;
      BOOL v13 = 1;
    }
    if (v10 && v13)
    {
      v4[2] = (uint64_t *)result;
      char v6 = 1;
    }
    else
    {
LABEL_14:
      char v6 = 0;
    }
  }
  BOOL v14 = *(unsigned char **)a2;
  uint64_t v15 = *(void *)(a2 + 8);
  char v16 = v6 & (**(unsigned char **)a2 != 0);
  if (!result) {
    char v16 = 0;
  }
  *BOOL v14 = v16;
  uint64_t v17 = a1[1];
  uint64_t v18 = *(uint64_t **)(*(void *)(*(void *)v15 + 72) + 56);
  if (*v17)
  {
    BOOL v19 = *v17 == v18;
  }
  else
  {
    *uint64_t v17 = v18;
    BOOL v14 = *(unsigned char **)a2;
    char v16 = **(unsigned char **)a2 != 0;
    BOOL v19 = 1;
  }
  *BOOL v14 = v19 & v16;
  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v15 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 24);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v15);
  if (result)
  {
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::SqueezeOp,void>::id
      || (*(unsigned char *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 1)
    {
      goto LABEL_7;
    }
    uint64_t v7 = *(void *)(*(void *)(result + 72) + 24);
    uint64_t v8 = **v4;
    if (v8)
    {
      if (v8 != v7)
      {
LABEL_7:
        char v6 = 0;
        goto LABEL_8;
      }
    }
    else
    {
      *uint64_t *v4 = v7;
    }
    v4[1] = (uint64_t *)result;
    char v6 = 1;
  }
LABEL_8:
  uint64_t v9 = *(unsigned char **)a2;
  uint64_t v10 = *(void *)(a2 + 8);
  char v11 = v6 & (**(unsigned char **)a2 != 0);
  if (!result) {
    char v11 = 0;
  }
  *uint64_t v9 = v11;
  uint64_t v12 = a1[1];
  BOOL v13 = *(uint64_t **)(*(void *)(*(void *)v10 + 72) + 56);
  if (*v12)
  {
    BOOL v14 = *v12 == v13;
  }
  else
  {
    *uint64_t v12 = v13;
    uint64_t v9 = *(unsigned char **)a2;
    char v11 = **(unsigned char **)a2 != 0;
    BOOL v14 = 1;
  }
  *uint64_t v9 = v14 & v11;
  return result;
}

void *mlir::mps::anonymous namespace'::CanonicalizeReshapeChain<mlir::mps::ExpandDimsOp>::~CanonicalizeReshapeChain(void *a1)
{
  int v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  unint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::mps::anonymous namespace'::CanonicalizeReshapeChain<mlir::mps::ExpandDimsOp>::~CanonicalizeReshapeChain(void *__p)
{
  int v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  unint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeReshapeChain<mlir::mps::ExpandDimsOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v21 = 0;
  uint64_t v22 = a2;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  char v16 = (uint64_t ****)&v21;
  uint64_t v17 = &v20;
  uint64_t v18 = 0;
  BOOL v13 = (uint64_t **)&v16;
  BOOL v14 = &v19;
  uint64_t v15 = 0;
  uint64_t v25 = a2;
  uint64_t v4 = *(void *)(a2 + 48);
  if (*(_UNKNOWN **)(v4 + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id
    && (*(unsigned char *)(a2 + 46) & 0x80) != 0
    && *(_DWORD *)(a2 + 68) == 2)
  {
    LOBYTE(FastmathAttr) = 1;
    uint64_t v23 = (uint64_t ***)&FastmathAttr;
    uint64_t v24 = &v25;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(&v13, (uint64_t)&v23);
    if ((_BYTE)FastmathAttr)
    {
      uint64_t v15 = v25;
      uint64_t v5 = v22;
      uint64_t v23 = (uint64_t ***)v21;
      uint64_t v25 = v19;
      uint64_t FastmathAttr = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v22);
      char v6 = (mlir::OpBuilder *)(a3 + 8);
      uint64_t v7 = *(void *)(v5 + 24);
      uint64_t v8 = (uint64_t *)&v23;
      p_uint64_t FastmathAttr = &FastmathAttr;
LABEL_12:
      uint64_t v10 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,mlir::Value,mlir::UnitAttr>(v6, v7, v8, &v25, p_FastmathAttr);
      (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, v5, v10);
      return 1;
    }
    a2 = v22;
    uint64_t v4 = *(void *)(v22 + 48);
  }
  uint64_t v21 = 0;
  uint64_t v20 = 0;
  uint64_t v23 = &v21;
  uint64_t v24 = 0;
  char v16 = &v23;
  uint64_t v17 = &v20;
  uint64_t v18 = 0;
  uint64_t v25 = a2;
  if (*(_UNKNOWN **)(v4 + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id
    && (*(unsigned char *)(a2 + 46) & 0x80) != 0
    && *(_DWORD *)(a2 + 68) == 2)
  {
    LOBYTE(v19) = 1;
    BOOL v13 = (uint64_t **)&v19;
    BOOL v14 = &v25;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>((uint64_t ***)&v16, (uint64_t)&v13);
    if ((_BYTE)v19)
    {
      uint64_t v18 = v25;
      uint64_t v5 = v22;
      BOOL v13 = v21;
      uint64_t v25 = v20;
      uint64_t v19 = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v22);
      char v6 = (mlir::OpBuilder *)(a3 + 8);
      uint64_t v7 = *(void *)(v5 + 24);
      uint64_t v8 = (uint64_t *)&v13;
      p_uint64_t FastmathAttr = &v19;
      goto LABEL_12;
    }
  }
  return 0;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v20 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 24);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v20);
  if (result)
  {
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ExpandDimsOp,void>::id
      || (*(unsigned char *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 2)
    {
      goto LABEL_14;
    }
    uint64_t v7 = *(void *)(result + 72);
    uint64_t v8 = *(void *)(v7 + 24);
    uint64_t v9 = **v4;
    if (v9)
    {
      BOOL v10 = v9 == v8;
    }
    else
    {
      *uint64_t *v4 = v8;
      uint64_t v7 = *(void *)(result + 72);
      BOOL v10 = 1;
    }
    char v11 = v4[1];
    uint64_t v12 = *(void *)(v7 + 56);
    if (*v11)
    {
      BOOL v13 = *v11 == v12;
    }
    else
    {
      *char v11 = v12;
      BOOL v13 = 1;
    }
    if (v10 && v13)
    {
      v4[2] = (uint64_t *)result;
      char v6 = 1;
    }
    else
    {
LABEL_14:
      char v6 = 0;
    }
  }
  BOOL v14 = *(unsigned char **)a2;
  uint64_t v15 = *(void *)(a2 + 8);
  char v16 = v6 & (**(unsigned char **)a2 != 0);
  if (!result) {
    char v16 = 0;
  }
  *BOOL v14 = v16;
  uint64_t v17 = a1[1];
  uint64_t v18 = *(uint64_t **)(*(void *)(*(void *)v15 + 72) + 56);
  if (*v17)
  {
    BOOL v19 = *v17 == v18;
  }
  else
  {
    *uint64_t v17 = v18;
    BOOL v14 = *(unsigned char **)a2;
    char v16 = **(unsigned char **)a2 != 0;
    BOOL v19 = 1;
  }
  *BOOL v14 = v19 & v16;
  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v15 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 24);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v15);
  if (result)
  {
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ExpandDimsOp,void>::id
      || (*(unsigned char *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 1)
    {
      goto LABEL_7;
    }
    uint64_t v7 = *(void *)(*(void *)(result + 72) + 24);
    uint64_t v8 = **v4;
    if (v8)
    {
      if (v8 != v7)
      {
LABEL_7:
        char v6 = 0;
        goto LABEL_8;
      }
    }
    else
    {
      *uint64_t *v4 = v7;
    }
    v4[1] = (uint64_t *)result;
    char v6 = 1;
  }
LABEL_8:
  uint64_t v9 = *(unsigned char **)a2;
  uint64_t v10 = *(void *)(a2 + 8);
  char v11 = v6 & (**(unsigned char **)a2 != 0);
  if (!result) {
    char v11 = 0;
  }
  *uint64_t v9 = v11;
  uint64_t v12 = a1[1];
  BOOL v13 = *(uint64_t **)(*(void *)(*(void *)v10 + 72) + 56);
  if (*v12)
  {
    BOOL v14 = *v12 == v13;
  }
  else
  {
    *uint64_t v12 = v13;
    uint64_t v9 = *(unsigned char **)a2;
    char v11 = **(unsigned char **)a2 != 0;
    BOOL v14 = 1;
  }
  *uint64_t v9 = v14 & v11;
  return result;
}

void mlir::mps::anonymous namespace'::CanonicalizePower::~CanonicalizePower(mlir::mps::_anonymous_namespace_::CanonicalizePower *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::PowerOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::PowerOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::PowerOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizePower::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v20 = a2;
  uint64_t Filter = (unint64_t *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v20);
  if (mlir::isConstantFPTwo(Filter))
  {
    uint64_t v6 = v20;
    __p = (void *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v20);
    uint64_t v7 = mlir::OpBuilder::create<mlir::mps::SquareOp,mlir::Value>((mlir::OpBuilder *)(a3 + 8), *(void *)(v6 + 24), (uint64_t *)&__p);
LABEL_9:
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, v6, v7);
    return 1;
  }
  LODWORD(v5) = 0.5;
  if (mlir::isConstantFPValue(Filter, v5))
  {
    uint64_t v6 = v20;
    __p = (void *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v20);
    uint64_t v7 = mlir::OpBuilder::create<mlir::mps::SquareRootOp,mlir::Value>((mlir::OpBuilder *)(a3 + 8), *(void *)(v6 + 24), (uint64_t *)&__p);
    goto LABEL_9;
  }
  LODWORD(v8) = -0.5;
  if (mlir::isConstantFPValue(Filter, v8))
  {
    uint64_t v6 = v20;
    __p = (void *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v20);
    uint64_t v7 = mlir::OpBuilder::create<mlir::mps::ReciprocalSquareRootOp,mlir::Value>((mlir::OpBuilder *)(a3 + 8), *(void *)(v6 + 24), (uint64_t *)&__p);
    goto LABEL_9;
  }
  LODWORD(v9) = -1.0;
  if (mlir::isConstantFPValue(Filter, v9))
  {
    uint64_t v6 = v20;
    __p = (void *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v20);
    uint64_t v7 = mlir::OpBuilder::create<mlir::mps::ReciprocalOp,mlir::Value>((mlir::OpBuilder *)(a3 + 8), *(void *)(v6 + 24), (uint64_t *)&__p);
    goto LABEL_9;
  }
  if (mlir::isConstantFPZero(Filter)) {
    goto LABEL_21;
  }
  unint64_t v21 = (unint64_t)Filter;
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v21);
  if (!DefiningOp) {
    return 0;
  }
  unsigned int v24 = 1;
  uint64_t p_p = (uint64_t)&__p;
  __p = 0;
  BOOL v10 = mlir::detail::constant_int_value_binder::match((mlir::detail::constant_int_value_binder *)&p_p, DefiningOp)
     && (uint64_t)mlir::m_Zero(void)::{lambda(llvm::APInt const&)#1}::__invoke((llvm::APInt *)&__p);
  if (v24 >= 0x41 && __p) {
    operator delete[](__p);
  }
  if (v10)
  {
LABEL_21:
    uint64_t v13 = *(void *)(v20 + 24);
    BOOL v10 = 1;
    LODWORD(p_p) = 1;
    __p = (char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,int>((mlir::mps::ConstantOp *)(a3 + 8), v13, (unsigned int *)&p_p)- 16;
    uint64_t v14 = *(void *)(v20 + 24);
    uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v20);
    uint64_t p_p = mlir::getElementTypeOrSelf(Input);
    __p = (char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)(a3 + 8), v14, (uint64_t *)&__p, &p_p)- 16;
    uint64_t v16 = *(void *)(v20 + 24);
    uint64_t v19 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v20);
    unint64_t v21 = (unint64_t)mlir::OpBuilder::create<mlir::mps::ShapeOp,mlir::Value>((mlir::OpBuilder *)(a3 + 8), v16, &v19);
    uint64_t p_p = (uint64_t)mlir::OpBuilder::create<mlir::mps::BroadcastToOp,mlir::Value &,mlir::mps::ShapeOp>((mlir::OpBuilder *)(a3 + 8), v16, (uint64_t *)&__p, &v21);
    uint64_t v17 = v20;
    unint64_t v21 = *(void *)(v20 - 8) & 0xFFFFFFFFFFFFFFF8;
    uint64_t v18 = mlir::OpBuilder::create<mlir::mps::TypeConstraintOp,mlir::mps::BroadcastToOp &,mlir::Type>((mlir::UnknownLoc **)(a3 + 8), *(void *)(v20 + 24), &p_p, (uint64_t *)&v21);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, v17, v18);
  }
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ConstantOp,int>(mlir::mps::ConstantOp *a1, uint64_t a2, unsigned int *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.constant", (const unsigned __int8 *)0xC, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"mps.constant";
    v15[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ConstantOp::build(a1, (mlir::OpBuilder *)v17, (mlir::OperationState *)*a3);
  double v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id) {
    BOOL v10 = v9;
  }
  else {
    BOOL v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.cast";
    v17[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::CastOp::build(a1, (uint64_t)v19, *a3, *a4);
  char v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::CastOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::BroadcastToOp,mlir::Value &,mlir::mps::ShapeOp>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, void *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.broadcast_to", (const unsigned __int8 *)0x10, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.broadcast_to";
    v17[3] = 16;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::BroadcastToOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4 - 16);
  char v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::BroadcastToOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ShapeOp,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.shape", (const unsigned __int8 *)9, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"mps.shape";
    v15[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ShapeOp::build((uint64_t)a1, (uint64_t)v17, *a3);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ShapeOp,void>::id) {
    char v10 = v9;
  }
  else {
    char v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SquareRootOp,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.square_root", (const unsigned __int8 *)0xF, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"mps.square_root";
    v15[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SquareRootOp,void>::id) {
    char v10 = v9;
  }
  else {
    char v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReciprocalSquareRootOp,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reciprocal_square_root", (const unsigned __int8 *)0x1A, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"mps.reciprocal_square_root";
    v15[3] = 26;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReciprocalSquareRootOp,void>::id) {
    char v10 = v9;
  }
  else {
    char v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReciprocalOp,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reciprocal", (const unsigned __int8 *)0xE, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"mps.reciprocal";
    v15[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReciprocalOp,void>::id) {
    char v10 = v9;
  }
  else {
    char v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

uint64_t mlir::detail::constant_int_value_binder::match(mlir::detail::constant_int_value_binder *this, mlir::Operation *a2)
{
  v12[1] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 6) + 32))(*((void *)a2 + 6), v4);
  if (result)
  {
    v11[0] = v12;
    v11[1] = (void *)0x100000000;
    mlir::Operation::fold((uint64_t)a2, 0, 0, (uint64_t)v11);
    unint64_t v6 = *(void *)v11[0] & 0xFFFFFFFFFFFFFFF8;
    if (v11[0] != v12) {
      free(v11[0]);
    }
    if (v6
      && ((uint64_t v7 = *(void **)(*(void *)(*((void *)a2 - 1) & 0xFFFFFFFFFFFFFFF8) + 136),
           v7 != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
        ? (BOOL v8 = v7 == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
        : (BOOL v8 = 1),
          !v8 ? (BOOL v9 = v7 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id) : (BOOL v9 = 1),
          !v9 ? (BOOL v10 = v7 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) : (BOOL v10 = 1),
          v10))
    {
      return mlir::detail::constant_int_value_binder::match((uint64_t *)this, v6);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::TypeConstraintOp,mlir::mps::BroadcastToOp &,mlir::Type>(mlir::UnknownLoc **a1, uint64_t a2, void *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.type_constraint", (const unsigned __int8 *)0x13, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.type_constraint";
    v17[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::TypeConstraintOp::build(a1, (uint64_t)v19, *a3 - 16, *a4);
  char v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::TypeConstraintOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::mps::anonymous namespace'::CanonicalizeSwish::~CanonicalizeSwish(mlir::mps::_anonymous_namespace_::CanonicalizeSwish *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeSwish::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v10 = 0;
  char v11 = &v13;
  BOOL v8 = (uint64_t *)&v11;
  uint64_t v9 = &v13;
  uint64_t v17 = a2;
  uint64_t v5 = *(void *)(a2 + 48);
  if (*(_UNKNOWN **)(v5 + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id
    && (*(unsigned char *)(a2 + 46) & 0x80) != 0
    && *(_DWORD *)(a2 + 68) == 2)
  {
    char v16 = 1;
    uint64_t v14 = &v16;
    uint64_t v15 = &v17;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>((uint64_t ***)&v8, (uint64_t)&v14);
    if (v16)
    {
LABEL_10:
      uint64_t v10 = v17;
      uint64_t v14 = (char *)v13;
      unint64_t v6 = mlir::OpBuilder::create<mlir::mps::SwishOp,mlir::Value>((mlir::OpBuilder *)(a3 + 8), *(void *)(a2 + 24), (uint64_t *)&v14);
      (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, a2, v6);
      return 1;
    }
    uint64_t v5 = *(void *)(a2 + 48);
  }
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v10 = 0;
  char v11 = &v13;
  BOOL v8 = &v13;
  uint64_t v9 = (uint64_t *)&v11;
  uint64_t v17 = a2;
  if (*(_UNKNOWN **)(v5 + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id
    && (*(unsigned char *)(a2 + 46) & 0x80) != 0
    && *(_DWORD *)(a2 + 68) == 2)
  {
    char v16 = 1;
    uint64_t v14 = &v16;
    uint64_t v15 = &v17;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder> *> & *)#1},0ul,1ul>(&v8, (uint64_t)&v14);
    if (v16) {
      goto LABEL_10;
    }
  }
  return 0;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v15 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 24);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v15);
  if (result)
  {
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::SigmoidOp,void>::id
      || (*(unsigned char *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 1)
    {
      goto LABEL_7;
    }
    uint64_t v7 = *(void *)(*(void *)(result + 72) + 24);
    uint64_t v8 = **v4;
    if (v8)
    {
      if (v8 != v7)
      {
LABEL_7:
        char v6 = 0;
        goto LABEL_8;
      }
    }
    else
    {
      *uint64_t *v4 = v7;
    }
    v4[1] = (uint64_t *)result;
    char v6 = 1;
  }
LABEL_8:
  uint64_t v9 = *(unsigned char **)a2;
  uint64_t v10 = *(void *)(a2 + 8);
  char v11 = v6 & (**(unsigned char **)a2 != 0);
  if (!result) {
    char v11 = 0;
  }
  *uint64_t v9 = v11;
  uint64_t v12 = a1[1];
  uint64_t v13 = *(uint64_t **)(*(void *)(*(void *)v10 + 72) + 56);
  if (*v12)
  {
    BOOL v14 = *v12 == v13;
  }
  else
  {
    *uint64_t v12 = v13;
    uint64_t v9 = *(unsigned char **)a2;
    char v11 = **(unsigned char **)a2 != 0;
    BOOL v14 = 1;
  }
  *uint64_t v9 = v14 & v11;
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SwishOp,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.swish", (const unsigned __int8 *)9, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"mps.swish";
    v15[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SwishOp,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder> *> & *)#1},0ul,1ul>(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(**(void **)(a2 + 8) + 72);
  uint64_t v4 = *(void *)(v3 + 24);
  uint64_t v5 = **a1;
  if (v5)
  {
    BOOL v6 = v5 == v4;
  }
  else
  {
    **a1 = v4;
    uint64_t v3 = *(void *)(**(void **)(a2 + 8) + 72);
    BOOL v6 = 1;
  }
  if (!**(unsigned char **)a2) {
    BOOL v6 = 0;
  }
  **(unsigned char **)a2 = v6;
  uint64_t v7 = (uint64_t **)a1[1];
  uint64_t v13 = *(void *)(v3 + 56);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v13);
  if (result)
  {
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::SigmoidOp,void>::id
      || (*(unsigned char *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 1)
    {
      goto LABEL_12;
    }
    uint64_t v10 = *(void *)(*(void *)(result + 72) + 24);
    uint64_t v11 = **v7;
    if (v11)
    {
      if (v11 != v10)
      {
LABEL_12:
        char v9 = 0;
        goto LABEL_13;
      }
    }
    else
    {
      **uint64_t v7 = v10;
    }
    v7[1] = (uint64_t *)result;
    char v9 = 1;
  }
LABEL_13:
  char v12 = v9 & (**(unsigned char **)a2 != 0);
  if (!result) {
    char v12 = 0;
  }
  **(unsigned char **)a2 = v12;
  return result;
}

void mlir::mps::anonymous namespace'::CanonicalizeBatchNorm::~CanonicalizeBatchNorm(mlir::mps::_anonymous_namespace_::CanonicalizeBatchNorm *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeBatchNorm::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::Float32Type **a3)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  uint64_t v44 = 0;
  uint64_t v45 = a2;
  uint64_t v3 = *(void *)(a2 + 24);
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  uint64_t v38 = 0;
  BOOL v39 = 0;
  v37[0] = &v44;
  v37[1] = &v43;
  v35[0] = v37;
  v35[1] = &v42;
  v35[2] = &v41;
  v35[3] = &v40;
  v35[4] = &v39;
  uint64_t v36 = 0;
  *(void *)&long long v50 = a2;
  if (*(_UNKNOWN **)(*(void *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::NormalizationOp,void>::id) {
    return 0;
  }
  if ((*(unsigned char *)(a2 + 46) & 0x80) == 0) {
    return 0;
  }
  if (*(_DWORD *)(a2 + 68) != 5) {
    return 0;
  }
  LOBYTE(v48) = 1;
  *(void *)&long long v46 = &v48;
  *((void *)&v46 + 1) = &v50;
  mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::NormalizationOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*> & *)#1},0ul,1ul,2ul,3ul,4ul>((uint64_t)v35, (uint64_t)&v46);
  if (!(_BYTE)v48) {
    return 0;
  }
  uint64_t v36 = v50;
  uint64_t v34 = v38;
  if (mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v34) != (void *)1) {
    return 0;
  }
  if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v34) == 1)
  {
    uint64_t v33 = v42;
    uint64_t v5 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v33);
    long long v46 = xmmword_18110B5F0;
    v47[0] = unk_18110B600;
    if (!mlir::mps::matchShape<mlir::Value>(v5, &v46, 4, -1)) {
      return 0;
    }
    uint64_t v32 = v41;
    uint64_t v6 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v32);
    long long v50 = xmmword_18110B5F0;
    long long v51 = unk_18110B600;
    if (!mlir::mps::matchShape<mlir::Value>(v6, &v50, 4, -1)) {
      return 0;
    }
    BOOL v31 = v40;
    uint64_t v7 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v31);
    long long v48 = xmmword_18110B5F0;
    long long v49 = unk_18110B600;
    if ((mlir::mps::matchShape<mlir::Value>(v7, &v48, 4, -1) & 1) == 0) {
      return 0;
    }
  }
  if (!mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v34))
  {
    uint64_t v33 = v42;
    uint64_t v10 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v33);
    long long v46 = xmmword_18110B630;
    v47[0] = unk_18110B640;
    if (!mlir::mps::matchShape<mlir::Value>(v10, &v46, 4, -1)) {
      return 0;
    }
    uint64_t v32 = v41;
    uint64_t v11 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v32);
    long long v50 = xmmword_18110B630;
    long long v51 = unk_18110B640;
    if (!mlir::mps::matchShape<mlir::Value>(v11, &v50, 4, -1)) {
      return 0;
    }
    BOOL v31 = v40;
    uint64_t v12 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v31);
    long long v48 = xmmword_18110B630;
    long long v49 = unk_18110B640;
    if ((mlir::mps::matchShape<mlir::Value>(v12, &v48, 4, -1) & 1) == 0) {
      return 0;
    }
  }
  mlir::mps::InstanceNormOp::getEpsilon((mlir::mps::InstanceNormOp *)&v45, (uint64_t)&v46);
  LODWORD(v50) = llvm::APFloat::convertToFloat((void **)&v46);
  char v8 = mlir::OpBuilder::create<mlir::mps::ConstantOp,float>(a3 + 1, v3, (float *)&v50);
  *(void *)&long long v48 = (char *)v8 - 16;
  char v9 = (void *)*((void *)&v46 + 1);
  if (llvm::APFloatBase::PPCDoubleDouble(v8) == v9) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)((char *)&v46 + 8));
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)((char *)&v46 + 8));
  }
  *(void *)&long long v46 = mlir::getElementTypeOrSelf((uint64_t)v41 - 16);
  *(void *)&long long v48 = (char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a3 + 1, v3, (uint64_t *)&v48, (uint64_t *)&v46)- 16;
  *(void *)&long long v46 = v41;
  uint64_t v33 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v46);
  if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v34)
    || mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v34) != 3)
  {
    if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v34)
      || mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v34) != 2)
    {
      goto LABEL_27;
    }
    __int16 v14 = &xmmword_18110B610;
  }
  else
  {
    __int16 v14 = &xmmword_18110B5F0;
  }
  long long v15 = v14[1];
  long long v50 = *v14;
  long long v51 = v15;
  llvm::SmallVector<long long,6u>::SmallVector(&v46, &v50, 4);
  uint64_t v33 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::SmallVector<long long,6u>>((mlir::Builder *)(a3 + 1), v3, &v33, (uint64_t)&v46)- 16;
  if ((_OWORD *)v46 != v47) {
    free((void *)v46);
  }
LABEL_27:
  uint64_t v32 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(a3 + 1, v3, &v33, (uint64_t *)&v48);
  BOOL v31 = mlir::OpBuilder::create<mlir::mps::ReciprocalSquareRootOp,mlir::mps::AddOp &>((mlir::OpBuilder *)(a3 + 1), v3, &v32);
  *(void *)&long long v46 = v40;
  uint64_t v30 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v46);
  if (!mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v34)
    && mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v34) == 3)
  {
    __int16 v16 = &xmmword_18110B5F0;
    goto LABEL_33;
  }
  if (!mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v34)
    && mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v34) == 2)
  {
    __int16 v16 = &xmmword_18110B610;
LABEL_33:
    long long v17 = v16[1];
    long long v50 = *v16;
    long long v51 = v17;
    llvm::SmallVector<long long,6u>::SmallVector(&v46, &v50, 4);
    uint64_t v30 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::SmallVector<long long,6u>>((mlir::Builder *)(a3 + 1), v3, &v30, (uint64_t)&v46)- 16;
    if ((_OWORD *)v46 != v47) {
      free((void *)v46);
    }
  }
  *(void *)&long long v50 = (char *)mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value &,mlir::mps::ReciprocalSquareRootOp &>(a3 + 1, v3, &v30, &v31)- 16;
  *(void *)&long long v46 = mlir::getElementTypeOrSelf(v43 - 16);
  uint64_t v29 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a3 + 1, v3, (uint64_t *)&v50, (uint64_t *)&v46);
  *(void *)&long long v46 = v43;
  uint64_t v28 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::ConstantOp,mlir::mps::CastOp &>(a3 + 1, v3, &v46, &v29);
  *(void *)&long long v46 = v44;
  Groups = mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v34);
  uint64_t Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v34);
  uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v34);
  uint64_t Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v34);
  unsigned int PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v34);
  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v34);
  unsigned int WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v34);
  uint64_t v27 = mlir::OpBuilder::create<mlir::mps::Conv2DOp,mlir::Value,mlir::mps::MultiplyOp &,unsigned long long,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle,mlir::mps::TensorDataLayout,mlir::mps::TensorDataLayout>((mlir::Builder *)(a3 + 1), v3, (uint64_t *)&v46, &v28, (uint64_t *)&Groups, &Strides, &InputAttributeNames, &Rewriter, &PaddingStyle, &StorageType, &WeightsLayout);
  if (!mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v34))
  {
    *(void *)&long long v46 = v47;
    v47[0] = xmmword_18110B630;
    v47[1] = unk_18110B640;
    *((void *)&v46 + 1) = 0x600000004;
    *(void *)&long long v50 = (char *)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::SmallVector<long long,6u>>((mlir::Builder *)(a3 + 1), v3, (uint64_t *)&v50, (uint64_t)&v46)- 16;
    if ((_OWORD *)v46 != v47) {
      free((void *)v46);
    }
  }
  uint64_t Strides = v42;
  Groups = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value &,mlir::mps::ReciprocalSquareRootOp &>(a3 + 1, v3, (uint64_t *)&v50, &Strides);
  *(void *)&long long v46 = mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::mps::Conv2DOp &,mlir::mps::MultiplyOp>(a3 + 1, v3, &v27, &Groups);
  uint64_t v18 = v45;
  Groups = v39;
  uint64_t v19 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::mps::SubtractOp &,mlir::mps::ConstantOp>(a3 + 1, *(void *)(v45 + 24), &v46, &Groups);
  (*((void (**)(mlir::Float32Type **, uint64_t, mlir::GenericProgramPoint *))*a3 + 4))(a3, v18, v19);
  return 1;
}

uint64_t mlir::mps::matchShape<mlir::Value>(uint64_t a1, const void *a2, uint64_t a3, int a4)
{
  unint64_t v5 = *(void *)(a1 + 8) & 0xFFFFFFFFFFFFFFF8;
  if (!v5) {
    goto LABEL_5;
  }
  uint64_t v4 = *(void **)(*(void *)v5 + 136);
  if (v4 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    unint64_t v5 = 0;
  }
  unint64_t v17 = v5;
  if (v4 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v17);
    uint64_t v13 = v12;
    __int16 v14 = (const void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v17);
    if (v15 == a3 && !memcmp(v14, a2, 8 * a3))
    {
      int v6 = 0;
      LODWORD(v4) = 1;
      return (v4 | v6) & 1;
    }
    if (a4 < 1 || v13 == a4)
    {
      if (!v13)
      {
LABEL_17:
        LODWORD(v4) = 0;
        int v6 = 1;
        return (v4 | v6) & 1;
      }
      while (1)
      {
        uint64_t v16 = *((void *)a2 + v13 - 1);
        if (v16 != -1 && v16 != *(void *)(Value - 8 + 8 * v13)) {
          break;
        }
        if (!--v13) {
          goto LABEL_17;
        }
      }
    }
    LODWORD(v4) = 0;
    int v6 = 0;
  }
  else
  {
LABEL_5:
    int v6 = 1;
  }
  return (v4 | v6) & 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ConstantOp,float>(mlir::Float32Type **a1, uint64_t a2, float *a3)
{
  v18[38] = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v13);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.constant", (const unsigned __int8 *)0xC, Context);
  if (!v8)
  {
    __int16 v17 = 1283;
    v16[2] = (uint64_t)"mps.constant";
    v16[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v15 = 259;
    llvm::operator+(v16, (uint64_t *)&v14, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::mps::ConstantOp::build(a1, (mlir::OpBuilder *)v18, v9, *a3);
  uint64_t v10 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v10 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v11;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::SmallVector<long long,6u>>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reshape", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.reshape";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ReshapeOp::build(a1, v19, *a3, *(void *)a4, (uint64_t *)*(unsigned int *)(a4 + 8));
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReciprocalSquareRootOp,mlir::mps::AddOp &>(mlir::OpBuilder *a1, uint64_t a2, void *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reciprocal_square_root", (const unsigned __int8 *)0x1A, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"mps.reciprocal_square_root";
    v15[3] = 26;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3 - 16);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReciprocalSquareRootOp,void>::id) {
    char v10 = v9;
  }
  else {
    char v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value &,mlir::mps::ReciprocalSquareRootOp &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, void *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.multiply";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3, *a4 - 16);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::ConstantOp,mlir::mps::CastOp &>(mlir::Float32Type **a1, uint64_t a2, void *a3, void *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.multiply";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3 - 16, *a4 - 16);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::Conv2DOp,mlir::Value,mlir::mps::MultiplyOp &,unsigned long long,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle,mlir::mps::TensorDataLayout,mlir::mps::TensorDataLayout>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, void *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, unsigned int *a9, unsigned int *a10, unsigned int *a11)
{
  v30[38] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v25);
  uint64_t v20 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_2d", (const unsigned __int8 *)0xB, Context);
  if (!v21)
  {
    __int16 v29 = 1283;
    v28[2] = (uint64_t)"mps.conv_2d";
    void v28[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v27 = 259;
    llvm::operator+(v28, (uint64_t *)&v26, (uint64_t)v30);
    llvm::report_fatal_error((llvm::Twine *)v30, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v20);
  mlir::mps::Conv2DOp::build(a1, (uint64_t)v30, *a3, *a4 - 16, *a5, *a6, *a7, *a8, *a9, *a10, *a11);
  uint64_t v22 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v30);
  if (*(_UNKNOWN **)(*((void *)v22 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id) {
    uint64_t v23 = v22;
  }
  else {
    uint64_t v23 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v23;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::mps::Conv2DOp &,mlir::mps::MultiplyOp>(mlir::Float32Type **a1, uint64_t a2, void *a3, void *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.subtract", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.subtract";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3 - 16, *a4 - 16);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SubtractOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::NormalizationOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*> & *)#1},0ul,1ul,2ul,3ul,4ul>(uint64_t a1, uint64_t a2)
{
  char v4 = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(**(void **)(a2 + 8), 0, *(uint64_t ***)a1);
  if (**(unsigned char **)a2) {
    char v5 = v4;
  }
  else {
    char v5 = 0;
  }
  **(unsigned char **)a2 = v5;
  int v6 = *(uint64_t **)(a1 + 8);
  uint64_t v23 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 56);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v23);
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(void *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (*v6 ? (BOOL v9 = *v6 == DefiningOp) : (BOOL v9 = 1), v9))
    {
      *int v6 = DefiningOp;
      char v8 = 1;
    }
    else
    {
      char v8 = 0;
    }
  }
  char v10 = v8 & (**(unsigned char **)a2 != 0);
  if (!DefiningOp) {
    char v10 = 0;
  }
  **(unsigned char **)a2 = v10;
  uint64_t v11 = *(uint64_t **)(a1 + 16);
  uint64_t v23 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 88);
  uint64_t v12 = mlir::Value::getDefiningOp((mlir::Value *)&v23);
  if (v12)
  {
    if (*(_UNKNOWN **)(*(void *)(v12 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v11 || *v11 == v12))
    {
      *uint64_t v11 = v12;
      char v13 = 1;
    }
    else
    {
      char v13 = 0;
    }
  }
  char v14 = v13 & (**(unsigned char **)a2 != 0);
  if (!v12) {
    char v14 = 0;
  }
  **(unsigned char **)a2 = v14;
  __int16 v15 = *(uint64_t **)(a1 + 24);
  uint64_t v23 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 120);
  uint64_t v16 = mlir::Value::getDefiningOp((mlir::Value *)&v23);
  if (v16)
  {
    if (*(_UNKNOWN **)(*(void *)(v16 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v15 || *v15 == v16))
    {
      uint64_t *v15 = v16;
      char v17 = 1;
    }
    else
    {
      char v17 = 0;
    }
  }
  char v18 = v17 & (**(unsigned char **)a2 != 0);
  if (!v16) {
    char v18 = 0;
  }
  **(unsigned char **)a2 = v18;
  uint64_t v19 = *(uint64_t **)(a1 + 32);
  uint64_t v23 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 152);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v23);
  if (result)
  {
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v19 || *v19 == result))
    {
      uint64_t *v19 = result;
      char v21 = 1;
    }
    else
    {
      char v21 = 0;
    }
  }
  char v22 = v21 & (**(unsigned char **)a2 != 0);
  if (!result) {
    char v22 = 0;
  }
  **(unsigned char **)a2 = v22;
  return result;
}

uint64_t mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(uint64_t a1, unsigned int a2, uint64_t **a3)
{
  uint64_t v14 = *(void *)(*(void *)(a1 + 72) + 32 * a2 + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v14);
  uint64_t v6 = DefiningOp;
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(void *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
      || (*(unsigned char *)(DefiningOp + 46) & 0x80) == 0
      || *(_DWORD *)(DefiningOp + 68) != 2)
    {
      goto LABEL_15;
    }
    uint64_t v7 = *(void *)(DefiningOp + 72);
    uint64_t v8 = *(void *)(v7 + 24);
    uint64_t v9 = **a3;
    if (v9)
    {
      BOOL v10 = v9 == v8;
    }
    else
    {
      **a3 = v8;
      uint64_t v7 = *(void *)(DefiningOp + 72);
      BOOL v10 = 1;
    }
    if ((v11 = a3[1], uint64_t v14 = *(void *)(v7 + 56), (v12 = mlir::Value::getDefiningOp((mlir::Value *)&v14)) != 0)
      && *(_UNKNOWN **)(*(void *)(v12 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v11 || *v11 == v12)
      && (*uint64_t v11 = v12, v10))
    {
      a3[2] = (uint64_t *)v6;
      char v5 = 1;
    }
    else
    {
LABEL_15:
      char v5 = 0;
    }
  }
  return (v6 != 0) & v5;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::AddOp,mlir::mps::SubtractOp &,mlir::mps::ConstantOp>(mlir::Float32Type **a1, uint64_t a2, void *a3, void *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.add";
    v17[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3 - 16, *a4 - 16);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::mps::anonymous namespace'::CanonicalizeBatchNormInference::~CanonicalizeBatchNormInference(mlir::mps::_anonymous_namespace_::CanonicalizeBatchNormInference *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeBatchNormInference::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::Float32Type **a3)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  uint64_t v47 = 0;
  uint64_t v48 = a2;
  uint64_t v3 = *(void *)(a2 + 24);
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  v39[0] = &v47;
  v39[1] = &v46;
  uint64_t v40 = 0;
  v38[1] = &v41;
  v38[2] = 0;
  v36[0] = (uint64_t)v38;
  v36[1] = (uint64_t)&v45;
  uint64_t v36[2] = (uint64_t)&v44;
  v36[3] = (uint64_t)&v43;
  v36[4] = (uint64_t)&v42;
  uint64_t v37 = 0;
  v38[0] = v39;
  *(void *)&long long v54 = a2;
  if (*(_UNKNOWN **)(*(void *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::NormalizationOp,void>::id) {
    return 0;
  }
  if ((*(unsigned char *)(a2 + 46) & 0x80) == 0) {
    return 0;
  }
  if (*(_DWORD *)(a2 + 68) != 5) {
    return 0;
  }
  LOBYTE(v52) = 1;
  *(void *)&long long v49 = &v52;
  *((void *)&v49 + 1) = &v54;
  mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BiasAddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::any_value_binder> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::NormalizationOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BiasAddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::any_value_binder>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BiasAddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::any_value_binder> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*> & *)#1},0ul,1ul,2ul,3ul,4ul>(v36, (uint64_t)&v49);
  if (!(_BYTE)v52) {
    return 0;
  }
  uint64_t v37 = v54;
  uint64_t v35 = v40;
  if (mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v35) != (void *)1) {
    return 0;
  }
  if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v35) == 1)
  {
    uint64_t v34 = v45;
    uint64_t v5 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v34);
    long long v49 = xmmword_18110B5F0;
    long long v50 = unk_18110B600;
    if (!mlir::mps::matchShape<mlir::Value>(v5, &v49, 4, -1)) {
      return 0;
    }
    uint64_t v33 = v44;
    uint64_t v6 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v33);
    long long v54 = xmmword_18110B5F0;
    long long v55 = unk_18110B600;
    if (!mlir::mps::matchShape<mlir::Value>(v6, &v54, 4, -1)) {
      return 0;
    }
    uint64_t v32 = v43;
    uint64_t v7 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v32);
    long long v52 = xmmword_18110B5F0;
    long long v53 = unk_18110B600;
    if ((mlir::mps::matchShape<mlir::Value>(v7, &v52, 4, -1) & 1) == 0) {
      return 0;
    }
  }
  if (!mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v35))
  {
    uint64_t v34 = v45;
    uint64_t v10 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v34);
    long long v49 = xmmword_18110B630;
    long long v50 = unk_18110B640;
    if (!mlir::mps::matchShape<mlir::Value>(v10, &v49, 4, -1)) {
      return 0;
    }
    uint64_t v33 = v44;
    uint64_t v11 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v33);
    long long v54 = xmmword_18110B630;
    long long v55 = unk_18110B640;
    if (!mlir::mps::matchShape<mlir::Value>(v11, &v54, 4, -1)) {
      return 0;
    }
    uint64_t v32 = v43;
    uint64_t v12 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v32);
    long long v52 = xmmword_18110B630;
    long long v53 = unk_18110B640;
    if ((mlir::mps::matchShape<mlir::Value>(v12, &v52, 4, -1) & 1) == 0) {
      return 0;
    }
  }
  mlir::mps::InstanceNormOp::getEpsilon((mlir::mps::InstanceNormOp *)&v48, (uint64_t)&v49);
  LODWORD(v54) = llvm::APFloat::convertToFloat((void **)&v49);
  uint64_t v8 = mlir::OpBuilder::create<mlir::mps::ConstantOp,float>(a3 + 1, v3, (float *)&v54);
  *(void *)&long long v52 = (char *)v8 - 16;
  uint64_t v9 = (void *)*((void *)&v49 + 1);
  if (llvm::APFloatBase::PPCDoubleDouble(v8) == v9) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)((char *)&v49 + 8));
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)((char *)&v49 + 8));
  }
  *(void *)&long long v49 = mlir::getElementTypeOrSelf((uint64_t)v44 - 16);
  *(void *)&long long v52 = (char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a3 + 1, v3, (uint64_t *)&v52, (uint64_t *)&v49)- 16;
  *(void *)&long long v49 = v44;
  uint64_t v34 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v49);
  if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v35)
    || mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v35) != 3)
  {
    if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v35)
      || mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v35) != 2)
    {
      goto LABEL_26;
    }
    uint64_t v14 = &xmmword_18110B610;
  }
  else
  {
    uint64_t v14 = &xmmword_18110B5F0;
  }
  long long v15 = v14[1];
  long long v54 = *v14;
  long long v55 = v15;
  llvm::SmallVector<long long,6u>::SmallVector(&v49, &v54, 4);
  uint64_t v34 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::SmallVector<long long,6u>>((mlir::Builder *)(a3 + 1), v3, &v34, (uint64_t)&v49)- 16;
  if ((long long *)v49 != &v50) {
    free((void *)v49);
  }
LABEL_26:
  uint64_t v33 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(a3 + 1, v3, &v34, (uint64_t *)&v52);
  uint64_t v32 = mlir::OpBuilder::create<mlir::mps::ReciprocalSquareRootOp,mlir::mps::AddOp &>((mlir::OpBuilder *)(a3 + 1), v3, &v33);
  *(void *)&long long v49 = v43;
  uint64_t v31 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v49);
  if (!mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v35)
    && mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v35) == 3)
  {
    __int16 v16 = &xmmword_18110B5F0;
    goto LABEL_32;
  }
  if (!mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v35)
    && mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v35) == 2)
  {
    __int16 v16 = &xmmword_18110B610;
LABEL_32:
    long long v17 = v16[1];
    long long v54 = *v16;
    long long v55 = v17;
    llvm::SmallVector<long long,6u>::SmallVector(&v49, &v54, 4);
    uint64_t v31 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::SmallVector<long long,6u>>((mlir::Builder *)(a3 + 1), v3, &v31, (uint64_t)&v49)- 16;
    if ((long long *)v49 != &v50) {
      free((void *)v49);
    }
  }
  *(void *)&long long v54 = (char *)mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value &,mlir::mps::ReciprocalSquareRootOp &>(a3 + 1, v3, &v31, &v32)- 16;
  *(void *)&long long v49 = mlir::getElementTypeOrSelf(v46 - 16);
  uint64_t v30 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a3 + 1, v3, (uint64_t *)&v54, (uint64_t *)&v49);
  *(void *)&long long v49 = v46;
  __int16 v29 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::ConstantOp,mlir::mps::CastOp &>(a3 + 1, v3, &v49, &v30);
  *(void *)&long long v49 = v47;
  Groups = (char *)mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v35);
  uint64_t Strides = (mlir::GenericProgramPoint *)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v35);
  uint64_t InputAttributeNames = (mlir::GenericProgramPoint *)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v35);
  uint64_t Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v35);
  unsigned int PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v35);
  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v35);
  unsigned int WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v35);
  __int16 v18 = mlir::OpBuilder::create<mlir::mps::Conv2DOp,mlir::Value,mlir::mps::MultiplyOp &,unsigned long long,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle,mlir::mps::TensorDataLayout,mlir::mps::TensorDataLayout>((mlir::Builder *)(a3 + 1), v3, (uint64_t *)&v49, &v29, (uint64_t *)&Groups, (uint64_t *)&Strides, (uint64_t *)&InputAttributeNames, &Rewriter, &PaddingStyle, &StorageType, &WeightsLayout);
  Groups = v41;
  uint64_t v28 = v18;
  if (!mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v35))
  {
    *(void *)&long long v49 = &v50;
    long long v50 = xmmword_18110B630;
    long long v51 = unk_18110B640;
    *((void *)&v49 + 1) = 0x600000004;
    *(void *)&long long v54 = (char *)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::SmallVector<long long,6u>>((mlir::Builder *)(a3 + 1), v3, (uint64_t *)&v54, (uint64_t)&v49)- 16;
    if ((long long *)v49 != &v50) {
      free((void *)v49);
    }
    *(void *)&long long v49 = &v50;
    long long v50 = xmmword_18110B630;
    long long v51 = unk_18110B640;
    *((void *)&v49 + 1) = 0x600000004;
    Groups = (char *)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::SmallVector<long long,6u>>((mlir::Builder *)(a3 + 1), v3, (uint64_t *)&Groups, (uint64_t)&v49)- 16;
    if ((long long *)v49 != &v50) {
      free((void *)v49);
    }
  }
  uint64_t Rewriter = v45;
  uint64_t InputAttributeNames = mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::mps::ConstantOp,mlir::Value &>(a3 + 1, v3, &Rewriter, (uint64_t *)&Groups);
  uint64_t Strides = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value &,mlir::mps::ReciprocalSquareRootOp &>(a3 + 1, v3, (uint64_t *)&v54, &InputAttributeNames);
  *(void *)&long long v49 = mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::mps::Conv2DOp &,mlir::mps::MultiplyOp>(a3 + 1, v3, &v28, &Strides);
  uint64_t v19 = v48;
  uint64_t Strides = v42;
  uint64_t v20 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::mps::SubtractOp &,mlir::mps::ConstantOp>(a3 + 1, *(void *)(v48 + 24), &v49, &Strides);
  (*((void (**)(mlir::Float32Type **, uint64_t, mlir::GenericProgramPoint *))*a3 + 4))(a3, v19, v20);
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::mps::ConstantOp,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, void *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.subtract", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.subtract";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3 - 16, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SubtractOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BiasAddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::any_value_binder> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::NormalizationOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BiasAddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::any_value_binder>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BiasAddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::any_value_binder> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*> & *)#1},0ul,1ul,2ul,3ul,4ul>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v29 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v29);
  uint64_t v7 = DefiningOp;
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(void *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::BiasAddOp,void>::id
      && (*(unsigned char *)(DefiningOp + 46) & 0x80) != 0
      && *(_DWORD *)(DefiningOp + 68) == 2
      && ((v8 = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(DefiningOp, 0, *(uint64_t ***)v4), v9 = *(void **)(v4 + 8), v10 = *(void *)(*(void *)(v7 + 72) + 56), !*v9)? (*v9 = v10, v11 = 1): (v11 = *v9 == v10), int v6 = v8 & v11, v6 == 1))
    {
      *(void *)(v4 + 16) = v7;
    }
    else
    {
      LOBYTE(v6) = 0;
    }
  }
  char v12 = v6 & (**(unsigned char **)a2 != 0);
  if (!v7) {
    char v12 = 0;
  }
  **(unsigned char **)a2 = v12;
  char v13 = (uint64_t *)a1[1];
  uint64_t v29 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 56);
  uint64_t v14 = mlir::Value::getDefiningOp((mlir::Value *)&v29);
  if (v14)
  {
    if (*(_UNKNOWN **)(*(void *)(v14 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v13 || *v13 == v14))
    {
      *char v13 = v14;
      char v15 = 1;
    }
    else
    {
      char v15 = 0;
    }
  }
  char v16 = v15 & (**(unsigned char **)a2 != 0);
  if (!v14) {
    char v16 = 0;
  }
  **(unsigned char **)a2 = v16;
  long long v17 = (uint64_t *)a1[2];
  uint64_t v29 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 88);
  uint64_t v18 = mlir::Value::getDefiningOp((mlir::Value *)&v29);
  if (v18)
  {
    if (*(_UNKNOWN **)(*(void *)(v18 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v17 || *v17 == v18))
    {
      *long long v17 = v18;
      char v19 = 1;
    }
    else
    {
      char v19 = 0;
    }
  }
  char v20 = v19 & (**(unsigned char **)a2 != 0);
  if (!v18) {
    char v20 = 0;
  }
  **(unsigned char **)a2 = v20;
  char v21 = (uint64_t *)a1[3];
  uint64_t v29 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 120);
  uint64_t v22 = mlir::Value::getDefiningOp((mlir::Value *)&v29);
  if (v22)
  {
    if (*(_UNKNOWN **)(*(void *)(v22 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v21 || *v21 == v22))
    {
      *char v21 = v22;
      char v23 = 1;
    }
    else
    {
      char v23 = 0;
    }
  }
  char v24 = v23 & (**(unsigned char **)a2 != 0);
  if (!v22) {
    char v24 = 0;
  }
  **(unsigned char **)a2 = v24;
  uint64_t v25 = (uint64_t *)a1[4];
  uint64_t v29 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 152);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v29);
  if (result)
  {
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v25 || *v25 == result))
    {
      *uint64_t v25 = result;
      char v27 = 1;
    }
    else
    {
      char v27 = 0;
    }
  }
  char v28 = v27 & (**(unsigned char **)a2 != 0);
  if (!result) {
    char v28 = 0;
  }
  **(unsigned char **)a2 = v28;
  return result;
}

void mlir::mps::anonymous namespace'::CanonicalizeTranspose::~CanonicalizeTranspose(mlir::mps::_anonymous_namespace_::CanonicalizeTranspose *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeTranspose::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v120[4] = *MEMORY[0x1E4F143B8];
  uint64_t v103 = a2;
  uint64_t v4 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v103) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v4) {
    goto LABEL_10;
  }
  uint64_t v5 = *v4;
  unint64_t v6 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v7 = *(unsigned int *)(v5 + 16);
  if (!v7) {
    goto LABEL_10;
  }
  int v8 = *(void **)(v5 + 8);
  uint64_t v9 = &v8[2 * v7];
  do
  {
    unint64_t v10 = v7 >> 1;
    BOOL v11 = &v8[2 * (v7 >> 1)];
    unint64_t v13 = *v11;
    char v12 = v11 + 2;
    v7 += ~(v7 >> 1);
    if (v13 < v6) {
      int v8 = v12;
    }
    else {
      unint64_t v7 = v10;
    }
  }
  while (v7);
  if (v8 != v9 && *v8 == v6) {
    uint64_t v14 = v8[1];
  }
  else {
LABEL_10:
  }
    uint64_t v14 = 0;
  v102[0] = v4;
  v102[1] = v14;
  v115[0] = &v116;
  v115[1] = (void *)0x100000000;
  v113[0] = &v114;
  v113[1] = (void *)0x100000000;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v102)
    || (uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v103),
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v102),
        !mlir::getPositiveAxes(Filter, v16, (uint64_t)v115, 0, 0, 0))
    || (uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v103),
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v102),
        !mlir::getPositiveAxes(Bias, v18, (uint64_t)v113, 0, 0, 0)))
  {
    uint64_t v24 = 0;
    goto LABEL_19;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v102);
  v110 = v112;
  uint64_t v111 = 0x400000000;
  if (!v19)
  {
    BOOL v26 = 1;
    char v27 = (int64x2_t *)v112;
    uint64_t v22 = (int64x2_t *)v112;
    goto LABEL_36;
  }
  unint64_t v20 = v19;
  if (v19 < 5)
  {
    uint64_t v21 = 0;
    uint64_t v22 = (int64x2_t *)v112;
    unint64_t v23 = v19;
    goto LABEL_27;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v110, v112, v19, 8);
  uint64_t v21 = v111;
  uint64_t v22 = (int64x2_t *)v110;
  unint64_t v23 = v20 - v111;
  if (v20 != v111) {
LABEL_27:
  }
    bzero((char *)v22 + 8 * v21, 8 * v23);
  LODWORD(v111) = v20;
  char v27 = (int64x2_t *)((char *)v22 + 8 * v20);
  BOOL v26 = v20 == 0;
  if (v20)
  {
    unint64_t v28 = (v20 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v28 >= 3)
    {
      unint64_t v31 = v28 + 1;
      uint64_t v29 = (v28 + 1) & 0x3FFFFFFFFFFFFFFCLL;
      uint64_t v30 = (int64x2_t *)((char *)v22 + 8 * v29);
      int64x2_t v32 = (int64x2_t)xmmword_1810FE2E0;
      uint64_t v33 = v22 + 1;
      int64x2_t v34 = vdupq_n_s64(2uLL);
      int64x2_t v35 = vdupq_n_s64(4uLL);
      uint64_t v36 = v29;
      do
      {
        v33[-1] = v32;
        int64x2_t *v33 = vaddq_s64(v32, v34);
        int64x2_t v32 = vaddq_s64(v32, v35);
        v33 += 2;
        v36 -= 4;
      }
      while (v36);
      if (v31 == v29) {
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v29 = 0;
      uint64_t v30 = v22;
    }
    do
    {
      v30->i64[0] = v29;
      uint64_t v30 = (int64x2_t *)((char *)v30 + 8);
      ++v29;
    }
    while (v30 != v27);
  }
  else
  {
    BOOL v26 = 1;
  }
LABEL_36:
  uint64_t v37 = *(void *)v115[0];
  uint64_t v38 = *(void *)v113[0];
  uint64_t v39 = v22->i64[v37];
  v22->i64[v37] = v22->i64[v38];
  v22->i64[v38] = v39;
  uint64_t v109 = v103;
  uint64_t v40 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v109) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v40) {
    goto LABEL_45;
  }
  uint64_t v41 = *v40;
  unint64_t v42 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v43 = *(unsigned int *)(v41 + 16);
  if (!v43) {
    goto LABEL_45;
  }
  uint64_t v44 = *(void **)(v41 + 8);
  uint64_t v45 = &v44[2 * v43];
  do
  {
    unint64_t v46 = v43 >> 1;
    uint64_t v47 = &v44[2 * (v43 >> 1)];
    unint64_t v49 = *v47;
    uint64_t v48 = v47 + 2;
    v43 += ~(v43 >> 1);
    if (v49 < v42) {
      uint64_t v44 = v48;
    }
    else {
      unint64_t v43 = v46;
    }
  }
  while (v43);
  if (v44 != v45 && *v44 == v42) {
    uint64_t v50 = v44[1];
  }
  else {
LABEL_45:
  }
    uint64_t v50 = 0;
  v108[0] = v40;
  v108[1] = v50;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v108);
  unint64_t v52 = v51;
  uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v108);
  uint64_t v54 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v108);
  if (!v55) {
    goto LABEL_57;
  }
  unint64_t v56 = (v55 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (v56 >= 3)
  {
    unint64_t v59 = v56 + 1;
    uint64_t v60 = (v56 + 1) & 0x3FFFFFFFFFFFFFFCLL;
    uint64_t v58 = (uint64_t *)(v54 + 8 * v60);
    uint64_t v61 = (int64x2_t *)(v54 + 16);
    int64x2_t v62 = 0uLL;
    int64x2_t v63 = vdupq_n_s64(0x8000000000000000);
    uint64_t v64 = v60;
    int64x2_t v65 = 0uLL;
    do
    {
      int64x2_t v62 = vsubq_s64(v62, vceqq_s64(v61[-1], v63));
      int64x2_t v65 = vsubq_s64(v65, vceqq_s64(*v61, v63));
      v61 += 2;
      v64 -= 4;
    }
    while (v64);
    unint64_t v57 = vaddvq_s64(vaddq_s64(v65, v62));
    if (v59 == v60) {
      goto LABEL_55;
    }
  }
  else
  {
    unint64_t v57 = 0;
    uint64_t v58 = (uint64_t *)v54;
  }
  do
  {
    uint64_t v66 = *v58++;
    if (v66 == 0x8000000000000000) {
      ++v57;
    }
  }
  while (v58 != (uint64_t *)(v54 + 8 * v55));
LABEL_55:
  if (v57 <= 1)
  {
LABEL_57:
    if (v26)
    {
LABEL_58:
      unint64_t v118 = v120;
      uint64_t v119 = 0x400000000;
      if (v52)
      {
        if (v52 < 5)
        {
          uint64_t v67 = 0;
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v118, v120, v52, 8);
          uint64_t v67 = v119;
        }
        if (v52 != v67) {
          bzero(&v118[v67], 8 * (v52 - v67));
        }
        LODWORD(v119) = v52;
      }
      if (!v26)
      {
        unint64_t v84 = v118;
        do
        {
          uint64_t v85 = v22->i64[0];
          uint64_t v22 = (int64x2_t *)((char *)v22 + 8);
          uint64_t v86 = *(void *)(ArgAttrsAttr + 8 * v85);
          if (v86 == 0x8000000000000000) {
            uint64_t v86 = -1;
          }
          *v84++ = v86;
        }
        while (v22 != v27);
      }
      unint64_t v117 = (mlir::GenericProgramPoint *)v52;
      uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 8), 0x40u, 1);
      unint64_t v88 = (void *)mlir::RankedTensorType::get((uint64_t)&v117, 1, IntegerType, 0);
      unint64_t v89 = v88;
      if (!v88) {
        goto LABEL_97;
      }
      uint64_t v90 = *v88;
      unint64_t v91 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v92 = *(unsigned int *)(v90 + 16);
      if (!v92) {
        goto LABEL_97;
      }
      int32x2_t v93 = *(void **)(v90 + 8);
      int32x2_t v94 = &v93[2 * v92];
      do
      {
        unint64_t v95 = v92 >> 1;
        uint64_t v96 = &v93[2 * (v92 >> 1)];
        unint64_t v98 = *v96;
        v97 = v96 + 2;
        v92 += ~(v92 >> 1);
        if (v98 < v91) {
          int32x2_t v93 = v97;
        }
        else {
          unint64_t v92 = v95;
        }
      }
      while (v92);
      if (v93 != v94 && *v93 == v91) {
        uint64_t v99 = v93[1];
      }
      else {
LABEL_97:
      }
        uint64_t v99 = 0;
      int32x2_t v107 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v89, v99, v118, 8 * v119, 8, 1, 1);
      unint64_t v117 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 8), *(void *)(v109 + 24), &v107);
      uint64_t v100 = v109;
      unint64_t v106 = *(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v109) + 8) & 0xFFFFFFFFFFFFFFF8;
      uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v109);
      unsigned __int8 v104 = 0;
      uint64_t v101 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Type,mlir::Value,mlir::mps::ConstantOp &,BOOL>((mlir::UnitAttr **)(a3 + 8), *(void *)(v100 + 24), (uint64_t *)&v106, &Input, &v117, &v104);
      (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, v100, v101);
      if (v118 != v120) {
        free(v118);
      }
      uint64_t v24 = 1;
      goto LABEL_101;
    }
    uint64_t v68 = 0;
    uint64_t v69 = 0;
    uint64_t v70 = 0;
    int64x2_t v71 = vdupq_n_s64(1uLL);
    uint64_t v72 = (uint64_t *)v22;
    while (1)
    {
      if (*v72 > v69) {
        uint64_t v69 = *v72;
      }
      if (v70 == v69) {
        break;
      }
      ++v70;
LABEL_63:
      if (++v72 == (uint64_t *)v27) {
        goto LABEL_58;
      }
    }
    uint64_t v73 = ArgAttrsAttr + 8 * v68;
    uint64_t v74 = ArgAttrsAttr + 8 * v70;
    if (v73 == v74 + 8)
    {
LABEL_78:
      uint64_t v69 = ++v70;
      uint64_t v68 = v70;
      goto LABEL_63;
    }
    unint64_t v75 = (v70 - v68) & 0x1FFFFFFFFFFFFFFFLL;
    if (v75 >= 3)
    {
      unint64_t v77 = v75 + 1;
      v73 += 8 * (v77 & 0x3FFFFFFFFFFFFFFCLL);
      unsigned int v78 = (int64x2_t *)(ArgAttrsAttr + 16 + 8 * v68);
      int64x2_t v79 = 0uLL;
      uint64_t v80 = v77 & 0x3FFFFFFFFFFFFFFCLL;
      int64x2_t v81 = 0uLL;
      do
      {
        int64x2_t v79 = vsubq_s64(v79, (int64x2_t)vmvnq_s8((int8x16_t)vceqq_s64(v78[-1], v71)));
        int64x2_t v81 = vsubq_s64(v81, (int64x2_t)vmvnq_s8((int8x16_t)vceqq_s64(*v78, v71)));
        v78 += 2;
        v80 -= 4;
      }
      while (v80);
      unint64_t v76 = vaddvq_s64(vaddq_s64(v81, v79));
      if (v77 == (v77 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_77;
      }
    }
    else
    {
      unint64_t v76 = 0;
    }
    uint64_t v82 = v73 - 8;
    do
    {
      uint64_t v83 = *(void *)(v82 + 8);
      v82 += 8;
      if (v83 != 1) {
        ++v76;
      }
    }
    while (v82 != v74);
LABEL_77:
    if (v76 > 1) {
      goto LABEL_56;
    }
    goto LABEL_78;
  }
LABEL_56:
  uint64_t v24 = 0;
LABEL_101:
  if (v110 != v112) {
    free(v110);
  }
LABEL_19:
  if (v113[0] != &v114) {
    free(v113[0]);
  }
  if (v115[0] != &v116) {
    free(v115[0]);
  }
  return v24;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Type,mlir::Value,mlir::mps::ConstantOp &,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, void *a5, unsigned __int8 *a6)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reshape", (const unsigned __int8 *)0xB, Context);
  if (!v14)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.reshape";
    v21[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::mps::ReshapeOp::build(a1, (uint64_t)v23, *a3, *a4, *a5 - 16, *a6);
  char v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::mps::anonymous namespace'::CanonicalizePermute::~CanonicalizePermute(mlir::mps::_anonymous_namespace_::CanonicalizePermute *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizePermute::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v99[4] = *MEMORY[0x1E4F143B8];
  uint64_t v86 = a2;
  uint64_t v4 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v86) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v4) {
    goto LABEL_10;
  }
  uint64_t v5 = *v4;
  unint64_t v6 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v7 = *(unsigned int *)(v5 + 16);
  if (!v7) {
    goto LABEL_10;
  }
  int v8 = *(void **)(v5 + 8);
  uint64_t v9 = &v8[2 * v7];
  do
  {
    unint64_t v10 = v7 >> 1;
    BOOL v11 = &v8[2 * (v7 >> 1)];
    unint64_t v13 = *v11;
    char v12 = v11 + 2;
    v7 += ~(v7 >> 1);
    if (v13 < v6) {
      int v8 = v12;
    }
    else {
      unint64_t v7 = v10;
    }
  }
  while (v7);
  if (v8 != v9 && *v8 == v6) {
    uint64_t v14 = v8[1];
  }
  else {
LABEL_10:
  }
    uint64_t v14 = 0;
  v85[0] = v4;
  v85[1] = v14;
  if (*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v86) + 8) >= 8uLL) {
    mlir::TypeID::get<mlir::ShapedType>();
  }
  int32x2_t v93 = v95;
  uint64_t v94 = 0x400000000;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v85)) {
    goto LABEL_35;
  }
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v86);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v85);
  if (!mlir::getPositiveAxes(Filter, v16, (uint64_t)&v93, 0, 0, 0)) {
    goto LABEL_35;
  }
  long long v17 = (uint64_t *)v93;
  uint64_t v18 = v94;
  uint64_t v92 = v86;
  unint64_t v19 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v92) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v19) {
    goto LABEL_24;
  }
  uint64_t v20 = *v19;
  unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v22 = *(unsigned int *)(v20 + 16);
  if (!v22) {
    goto LABEL_24;
  }
  unint64_t v23 = *(void **)(v20 + 8);
  uint64_t v24 = &v23[2 * v22];
  do
  {
    unint64_t v25 = v22 >> 1;
    BOOL v26 = &v23[2 * (v22 >> 1)];
    unint64_t v28 = *v26;
    char v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21) {
      unint64_t v23 = v27;
    }
    else {
      unint64_t v22 = v25;
    }
  }
  while (v22);
  if (v23 != v24 && *v23 == v21) {
    uint64_t v29 = v23[1];
  }
  else {
LABEL_24:
  }
    uint64_t v29 = 0;
  v91[0] = v19;
  v91[1] = v29;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v91);
  unint64_t v31 = v30;
  uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v91);
  uint64_t v33 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v91);
  if (v34)
  {
    unint64_t v35 = (v34 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v35 >= 3)
    {
      unint64_t v38 = v35 + 1;
      uint64_t v39 = (v35 + 1) & 0x3FFFFFFFFFFFFFFCLL;
      uint64_t v37 = (uint64_t *)(v33 + 8 * v39);
      uint64_t v40 = (int64x2_t *)(v33 + 16);
      int64x2_t v41 = 0uLL;
      int64x2_t v42 = vdupq_n_s64(0x8000000000000000);
      uint64_t v43 = v39;
      int64x2_t v44 = 0uLL;
      do
      {
        int64x2_t v41 = vsubq_s64(v41, vceqq_s64(v40[-1], v42));
        int64x2_t v44 = vsubq_s64(v44, vceqq_s64(*v40, v42));
        v40 += 2;
        v43 -= 4;
      }
      while (v43);
      unint64_t v36 = vaddvq_s64(vaddq_s64(v44, v41));
      if (v38 == v39) {
        goto LABEL_34;
      }
    }
    else
    {
      unint64_t v36 = 0;
      uint64_t v37 = (uint64_t *)v33;
    }
    do
    {
      uint64_t v45 = *v37++;
      if (v45 == 0x8000000000000000) {
        ++v36;
      }
    }
    while (v37 != (uint64_t *)(v33 + 8 * v34));
LABEL_34:
    if (v36 > 1)
    {
LABEL_35:
      uint64_t v46 = 0;
      goto LABEL_36;
    }
  }
  if (v18)
  {
    uint64_t v48 = 0;
    uint64_t v49 = 0;
    uint64_t v50 = 0;
    int64x2_t v51 = vdupq_n_s64(1uLL);
    unint64_t v52 = v17;
    while (1)
    {
      if (*v52 > v49) {
        uint64_t v49 = *v52;
      }
      if (v50 == v49) {
        break;
      }
      ++v50;
LABEL_42:
      if (++v52 == &v17[v18]) {
        goto LABEL_58;
      }
    }
    uint64_t v53 = ArgAttrsAttr + 8 * v48;
    uint64_t v54 = ArgAttrsAttr + 8 * v50;
    if (v53 == v54 + 8)
    {
LABEL_57:
      uint64_t v49 = ++v50;
      uint64_t v48 = v50;
      goto LABEL_42;
    }
    unint64_t v55 = (v50 - v48) & 0x1FFFFFFFFFFFFFFFLL;
    if (v55 >= 3)
    {
      unint64_t v57 = v55 + 1;
      v53 += 8 * (v57 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v58 = (int64x2_t *)(ArgAttrsAttr + 16 + 8 * v48);
      int64x2_t v59 = 0uLL;
      uint64_t v60 = v57 & 0x3FFFFFFFFFFFFFFCLL;
      int64x2_t v61 = 0uLL;
      do
      {
        int64x2_t v59 = vsubq_s64(v59, (int64x2_t)vmvnq_s8((int8x16_t)vceqq_s64(v58[-1], v51)));
        int64x2_t v61 = vsubq_s64(v61, (int64x2_t)vmvnq_s8((int8x16_t)vceqq_s64(*v58, v51)));
        v58 += 2;
        v60 -= 4;
      }
      while (v60);
      unint64_t v56 = vaddvq_s64(vaddq_s64(v61, v59));
      if (v57 == (v57 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_56;
      }
    }
    else
    {
      unint64_t v56 = 0;
    }
    uint64_t v62 = v53 - 8;
    do
    {
      uint64_t v63 = *(void *)(v62 + 8);
      v62 += 8;
      if (v63 != 1) {
        ++v56;
      }
    }
    while (v62 != v54);
LABEL_56:
    if (v56 > 1) {
      goto LABEL_35;
    }
    goto LABEL_57;
  }
LABEL_58:
  v97 = v99;
  uint64_t v98 = 0x400000000;
  if (v31)
  {
    if (v31 < 5)
    {
      uint64_t v64 = 0;
      unint64_t v65 = v31;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v97, v99, v31, 8);
      uint64_t v64 = v98;
      unint64_t v65 = v31 - v98;
      if (v31 == v98) {
        goto LABEL_65;
      }
    }
    bzero((char *)v97 + 8 * v64, 8 * v65);
LABEL_65:
    LODWORD(v98) = v31;
  }
  if (v18)
  {
    uint64_t v66 = (uint64_t *)v97;
    uint64_t v67 = 8 * v18;
    do
    {
      uint64_t v68 = *v17++;
      uint64_t v69 = *(void *)(ArgAttrsAttr + 8 * v68);
      if (v69 == 0x8000000000000000) {
        uint64_t v69 = -1;
      }
      *v66++ = v69;
      v67 -= 8;
    }
    while (v67);
  }
  uint64_t v96 = (mlir::GenericProgramPoint *)v31;
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 8), 0x40u, 1);
  int64x2_t v71 = (void *)mlir::RankedTensorType::get((uint64_t)&v96, 1, IntegerType, 0);
  uint64_t v72 = v71;
  if (!v71) {
    goto LABEL_80;
  }
  uint64_t v73 = *v71;
  unint64_t v74 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v75 = *(unsigned int *)(v73 + 16);
  if (!v75) {
    goto LABEL_80;
  }
  unint64_t v76 = *(void **)(v73 + 8);
  unint64_t v77 = &v76[2 * v75];
  do
  {
    unint64_t v78 = v75 >> 1;
    int64x2_t v79 = &v76[2 * (v75 >> 1)];
    unint64_t v81 = *v79;
    uint64_t v80 = v79 + 2;
    v75 += ~(v75 >> 1);
    if (v81 < v74) {
      unint64_t v76 = v80;
    }
    else {
      unint64_t v75 = v78;
    }
  }
  while (v75);
  if (v76 != v77 && *v76 == v74) {
    uint64_t v82 = v76[1];
  }
  else {
LABEL_80:
  }
    uint64_t v82 = 0;
  uint64_t v90 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v72, v82, v97, 8 * v98, 8, 1, 1);
  uint64_t v96 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 8), *(void *)(v92 + 24), &v90);
  uint64_t v83 = v92;
  unint64_t v89 = *(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v92) + 8) & 0xFFFFFFFFFFFFFFF8;
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v92);
  unsigned __int8 v87 = 0;
  unint64_t v84 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Type,mlir::Value,mlir::mps::ConstantOp &,BOOL>((mlir::UnitAttr **)(a3 + 8), *(void *)(v83 + 24), (uint64_t *)&v89, &Input, &v96, &v87);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, v83, v84);
  if (v97 != v99) {
    free(v97);
  }
  uint64_t v46 = 1;
LABEL_36:
  if (v93 != v95) {
    free(v93);
  }
  return v46;
}

void mlir::mps::anonymous namespace'::CanonicalizeIdentity::~CanonicalizeIdentity(mlir::mps::_anonymous_namespace_::CanonicalizeIdentity *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::IdentityOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::IdentityOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::IdentityOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeIdentity::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v9 = a2;
  uint64_t Input = (void *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v9);
  if (*Input && !*(void *)*Input)
  {
    uint64_t v10 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v9);
    uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v10);
    if (!DefiningOp) {
      return DefiningOp;
    }
    uint64_t v7 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    if ((*(unsigned int (**)(void, uint64_t))(**(void **)(DefiningOp + 48) + 32))(*(void *)(DefiningOp + 48), v7))
    {
      uint64_t v8 = v9;
      uint64_t v10 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v9);
      uint64_t DefiningOp = 1;
      (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(void *)a3 + 24))(a3, v8, &v10, 1);
      return DefiningOp;
    }
  }
  return 0;
}

void mlir::mps::anonymous namespace'::CanonicalizeConcat::~CanonicalizeConcat(mlir::mps::_anonymous_namespace_::CanonicalizeConcat *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ConcatOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ConcatOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ConcatOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeConcat::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::UnitAttr **a3)
{
  v46[4] = *MEMORY[0x1E4F143B8];
  uint64_t v39 = a2;
  Axis = (void *)mlir::mps::ConcatOp::getAxis((mlir::mps::ConcatOp *)&v39);
  int64x2_t v44 = 0;
  uint64_t v45 = 0;
  uint64_t v40 = &v44;
  int64x2_t v41 = Axis;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v41);
  if (!DefiningOp) {
    return 0;
  }
  if (!mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&v40, DefiningOp)) {
    return 0;
  }
  unint64_t SingleInt = mlir::getSingleIntValue<long long>((uint64_t)v44, v45);
  if (!v7) {
    return 0;
  }
  unint64_t v8 = SingleInt;
  uint64_t Values = mlir::mps::ConcatOp::getValues((mlir::mps::ConcatOp *)&v39);
  int64x2_t v44 = v46;
  uint64_t v45 = 0x400000000;
  if (v10)
  {
    uint64_t v11 = Values;
    uint64_t v12 = v10;
    for (uint64_t i = 0; i != v12; ++i)
    {
      uint64_t v16 = (uint64_t *)(*(void *)(*(void *)(v11 + 32 * i + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v16) {
        goto LABEL_19;
      }
      uint64_t v17 = *v16;
      unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v19 = *(unsigned int *)(v17 + 16);
      if (!v19) {
        goto LABEL_19;
      }
      uint64_t v20 = *(void **)(v17 + 8);
      unint64_t v21 = &v20[2 * v19];
      do
      {
        unint64_t v22 = v19 >> 1;
        unint64_t v23 = &v20[2 * (v19 >> 1)];
        unint64_t v25 = *v23;
        uint64_t v24 = v23 + 2;
        v19 += ~(v19 >> 1);
        if (v25 < v18) {
          uint64_t v20 = v24;
        }
        else {
          unint64_t v19 = v22;
        }
      }
      while (v19);
      if (v20 != v21 && *v20 == v18) {
        uint64_t v26 = v20[1];
      }
      else {
LABEL_19:
      }
        uint64_t v26 = 0;
      int64x2_t v41 = v16;
      uint64_t v42 = v26;
      if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v41))
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v41);
        if (v27)
        {
          unint64_t v28 = v8;
          if ((v8 & 0x8000000000000000) != 0)
          {
            mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v41);
            unint64_t v28 = v29 + v8;
          }
          if (!*(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v41) + 8 * v28))
          {
            uint64_t v30 = v45;
            if (v45 >= (unint64_t)HIDWORD(v45))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v46, v45 + 1, 8);
              uint64_t v30 = v45;
            }
            *((void *)v44 + v30) = i;
            LODWORD(v45) = v45 + 1;
          }
        }
      }
    }
    uint64_t v14 = 0;
    if (v45 && v12 != v45)
    {
      unsigned int v31 = 0;
      uint64_t v32 = 0;
      int64x2_t v41 = v43;
      uint64_t v42 = 0x400000000;
      uint64_t v33 = v44;
      uint64_t v34 = (uint64_t *)(v11 + 24);
      do
      {
        if (v32 == *v33)
        {
          ++v33;
        }
        else
        {
          uint64_t v35 = *v34;
          if (v31 >= HIDWORD(v42))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v43, v31 + 1, 8);
            unsigned int v31 = v42;
          }
          *((void *)v41 + v31) = v35;
          unsigned int v31 = v42 + 1;
          LODWORD(v42) = v42 + 1;
        }
        ++v32;
        v34 += 4;
      }
      while (v12 != v32);
      uint64_t v36 = v39;
      uint64_t v40 = (void **)mlir::mps::ConcatOp::getAxis((mlir::mps::ConcatOp *)&v39);
      BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v39);
      uint64_t v37 = mlir::OpBuilder::create<mlir::mps::ConcatOp,llvm::SmallVector<mlir::Value,4u> &,mlir::Value,BOOL>(a3 + 1, *(void *)(v36 + 24), (uint64_t)&v41, (uint64_t *)&v40, (unsigned __int8 *)&InferredResultTypes);
      (*((void (**)(mlir::UnitAttr **, uint64_t, mlir::GenericProgramPoint *))*a3 + 4))(a3, v36, v37);
      if (v41 != v43) {
        free(v41);
      }
      uint64_t v14 = 1;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  if (v44 != v46) {
    free(v44);
  }
  return v14;
}

unint64_t mlir::getSingleIntValue<long long>(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = a1;
  uint64_t v12 = a2;
  v10[0] = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v11);
  v10[1] = v2;
  uint64_t ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v10);
  if (mlir::ShapedType::getNumElements(ArgAttrsAttr, v4) == 1
    && (v9[0] = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v11),
        v9[1] = v5,
        *(_UNKNOWN **)(*(void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v9) + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id))
  {
    v9[0] = 0;
    mlir::copyElementsAttrData<long long>(v11, v12, (uint64_t)v9, 1);
    unint64_t v7 = v9[0] & 0xFFFFFFFFFFFFFF00;
    uint64_t v6 = LOBYTE(v9[0]);
  }
  else
  {
    uint64_t v6 = 0;
    unint64_t v7 = 0;
  }
  return v7 | v6;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ConcatOp,llvm::SmallVector<mlir::Value,4u> &,mlir::Value,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned __int8 *a5)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.concat", (const unsigned __int8 *)0xA, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.concat";
    void v19[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v22);
    llvm::report_fatal_error((llvm::Twine *)v22, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v11);
  mlir::ValueRange::ValueRange(v21, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::mps::ConcatOp::build(a1, (uint64_t)v22, v21[0], v21[1], *a4, *a5);
  unint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v22);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConcatOp,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v14;
}

void mlir::mps::anonymous namespace'::CanonicalizeOpsWith0Dims::~CanonicalizeOpsWith0Dims(mlir::mps::_anonymous_namespace_::CanonicalizeOpsWith0Dims *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeOpsWith0Dims::matchAndRewrite(mlir::mps::_anonymous_namespace_::CanonicalizeOpsWith0Dims *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v53[20] = *MEMORY[0x1E4F143B8];
  uint64_t v50 = a2;
  uint64_t v5 = *((void *)a2 + 6);
  if (*(_UNKNOWN **)(v5 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    int64x2_t v51 = *(void **)(v5 + 8);
    uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v51);
  }
  else
  {
    uint64_t Values = *(void *)(v5 + 24);
  }
  if (*(void *)(Values + 16) != 3
    || ((v7 = *(unsigned __int16 **)(Values + 8), int v8 = *v7, v9 = *((unsigned __int8 *)v7 + 2), v8 == 28781)
      ? (BOOL v10 = v9 == 115)
      : (BOOL v10 = 0),
        !v10))
  {
    uint64_t v11 = *((void *)a2 + 6);
    if (*(_UNKNOWN **)(v11 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      int64x2_t v51 = *(void **)(v11 + 8);
      uint64_t v12 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v51);
    }
    else
    {
      uint64_t v12 = *(void *)(v11 + 24);
    }
    if (*(void *)(v12 + 16) != 4 || **(_DWORD **)(v12 + 8) != 2020831341) {
      return 0;
    }
  }
  uint64_t v13 = mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects>(void)::Empty>>();
  if ((*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 6) + 32))(*((void *)a2 + 6), v13)) {
    return 0;
  }
  uint64_t v14 = mlir::TypeID::get<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>>();
  if (((*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 6) + 32))(*((void *)a2 + 6), v14) & 1) != 0
    || *(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id)
  {
    return 0;
  }
  if (!mlir::OpInterface<mlir::MemoryEffectOpInterface,mlir::detail::MemoryEffectOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)a2))
  {
    uint64_t v48 = 0;
    uint64_t InterfaceFor = 0;
    return 0;
  }
  uint64_t v48 = a2;
  uint64_t InterfaceFor = mlir::OpInterface<mlir::MemoryEffectOpInterface,mlir::detail::MemoryEffectOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)a2);
  if (!a2) {
    return 0;
  }
  int64x2_t v51 = v53;
  uint64_t v52 = 0x400000000;
  mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v48, (uint64_t)&v51);
  int v15 = v52;
  if (v51 != v53) {
    free(v51);
  }
  if (v15) {
    return 0;
  }
  uint64_t v17 = *((unsigned int *)a2 + 9);
  __int16 v18 = (char *)a2 - 16;
  if (v17) {
    unint64_t v19 = (char *)a2 - 16;
  }
  else {
    unint64_t v19 = 0;
  }
  int64x2_t v51 = v19;
  uint64_t v52 = v17;
    return mlir::RewriterBase::notifyMatchFailure<mlir::Operation *&>((uint64_t)a3, (uint64_t *)&v50, "failed: all the operands are expected to return ShapedTypes");
  uint64_t v20 = *((unsigned int *)a2 + 9);
  if (!v20) {
    __int16 v18 = 0;
  }
  char v21 = 0;
  if (v20)
  {
    for (uint64_t i = 0; i != v20; ++i)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v18, i);
      uint64_t v24 = (uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v24) {
        goto LABEL_45;
      }
      uint64_t v25 = *v24;
      unint64_t v26 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v27 = *(unsigned int *)(v25 + 16);
      if (!v27) {
        goto LABEL_45;
      }
      unint64_t v28 = *(void **)(v25 + 8);
      uint64_t v29 = &v28[2 * v27];
      do
      {
        unint64_t v30 = v27 >> 1;
        unsigned int v31 = &v28[2 * (v27 >> 1)];
        unint64_t v33 = *v31;
        uint64_t v32 = v31 + 2;
        v27 += ~(v27 >> 1);
        if (v33 < v26) {
          unint64_t v28 = v32;
        }
        else {
          unint64_t v27 = v30;
        }
      }
      while (v27);
      if (v28 != v29 && *v28 == v26) {
        uint64_t v34 = v28[1];
      }
      else {
LABEL_45:
      }
        uint64_t v34 = 0;
      int64x2_t v51 = v24;
      uint64_t v52 = v34;
      if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v51))
      {
        uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v51);
        if (v36)
        {
          uint64_t v37 = 8 * v36;
          while (*ArgAttrsAttr)
          {
            ++ArgAttrsAttr;
            v37 -= 8;
            if (!v37) {
              goto LABEL_35;
            }
          }
          uint64_t v38 = *((void *)a2 + 3);
          uint64_t v46 = (uint64_t *)mlir::DenseElementsAttr::get((uint64_t)v51, v52, 0, 0);
          uint64_t v47 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::MemRefType &,mlir::mps::MPSBufferTensorAttr &>((mlir::PatternRewriter *)((char *)a3 + 8), v38, (uint64_t *)&v51, &v46);
          uint64_t v39 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v47);
          uint64_t v40 = *(uint64_t **)NextResultAtOffset;
          if (*(void *)NextResultAtOffset)
          {
            int64x2_t v41 = (uint64_t *)v39;
            do
            {
              uint64_t v42 = (uint64_t *)*v40;
              uint64_t v43 = v40[2];
              (*(void (**)(mlir::PatternRewriter *, uint64_t))(*(void *)a3 + 72))(a3, v43);
              int64x2_t v44 = (uint64_t *)v40[1];
              if (v44)
              {
                *int64x2_t v44 = *v40;
                if (*v40) {
                  *(void *)(*v40 + 8) = v40[1];
                }
              }
              v40[3] = (uint64_t)v41;
              v40[1] = (uint64_t)v41;
              uint64_t v45 = *v41;
              uint64_t *v40 = *v41;
              if (v45) {
                *(void *)(v45 + 8) = v40;
              }
              uint64_t *v41 = (uint64_t)v40;
              (*(void (**)(mlir::PatternRewriter *, uint64_t))(*(void *)a3 + 80))(a3, v43);
              uint64_t v40 = v42;
            }
            while (v42);
          }
          char v21 = 1;
        }
      }
LABEL_35:
      ;
    }
  }
  return v21 & 1;
}

uint64_t llvm::any_of<mlir::ResultRange,mlir::mps::anonymous namespace'::CanonicalizeOpsWith0Dims::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::ResultRange)#1}>(uint64_t *a1)
{
  uint64_t v1 = a1[1];
  if (!v1) {
    return 0;
  }
  uint64_t v2 = 0;
  uint64_t v3 = *a1;
  while (1)
  {
    uint64_t v4 = *(void *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v3, v2) + 8) & 0xFFFFFFFFFFFFFFF8);
    unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v6 = *(unsigned int *)(v4 + 16);
    if (!v6) {
      break;
    }
    unint64_t v7 = *(void **)(v4 + 8);
    int v8 = &v7[2 * v6];
    do
    {
      unint64_t v9 = v6 >> 1;
      BOOL v10 = &v7[2 * (v6 >> 1)];
      unint64_t v12 = *v10;
      uint64_t v11 = v10 + 2;
      v6 += ~(v6 >> 1);
      if (v12 < v5) {
        unint64_t v7 = v11;
      }
      else {
        unint64_t v6 = v9;
      }
    }
    while (v6);
    if (v7 == v8 || *v7 != v5 || !v7[1]) {
      break;
    }
    if (++v2 == v1) {
      return 0;
    }
  }
  return 1;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::Operation *&>(uint64_t a1, uint64_t *a2, unsigned char *a3)
{
  char v3 = 1;
  char v9 = 1;
  if (*a3)
  {
    unint64_t v7 = a3;
    char v3 = 3;
  }
  char v8 = v3;
  uint64_t v4 = *a2;
  BOOL v10 = &v7;
  uint64_t v5 = *(void *)(a1 + 16);
  if (!v5) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16));
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v5 + 64))(v5, *(void *)(v4 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::Operation *&>(mlir::Operation *&,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v10);
  }
  return result;
}

uint64_t mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects>(void)::Empty>>()
{
  unint64_t v0 = 0x1E8EB8000uLL;
  {
    unint64_t v0 = 0x1E8EB8000;
    if (v2)
    {
      BOOL v10 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::HasRecursiveMemoryEffects<Empty>]";
      unint64_t v11 = 97;
      unint64_t v3 = llvm::StringRef::find((uint64_t *)&v10, "DesiredTypeName = ", 0x12uLL, 0);
      if (v11 >= v3) {
        unint64_t v4 = v3;
      }
      else {
        unint64_t v4 = v11;
      }
      uint64_t v5 = &v10[v4];
      unint64_t v6 = v11 - v4;
      if (v11 - v4 >= 0x12) {
        uint64_t v7 = 18;
      }
      else {
        uint64_t v7 = v11 - v4;
      }
      unint64_t v8 = v6 - v7;
      if (v8 >= v8 - 1) {
        uint64_t v9 = v8 - 1;
      }
      else {
        uint64_t v9 = v8;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::HasRecursiveMemoryEffects<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v5[v7], v9);
      unint64_t v0 = 0x1E8EB8000;
    }
  }
  return *(void *)(v0 + 2352);
}

uint64_t mlir::OpInterface<mlir::MemoryEffectOpInterface,mlir::detail::MemoryEffectOpInterfaceInterfaceTraits>::getInterfaceFor(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  int v2 = *(void **)(v1 + 16);
  BOOL v3 = v2 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 48);
  }
  if (v3)
  {
    uint64_t v22 = *(void *)(v1 + 8);
    uint64_t result = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v22);
    if (result)
    {
      uint64_t v20 = result;
      uint64_t v21 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v20 + 104))(v20, v21, v1);
    }
  }
  else
  {
    unint64_t v6 = v4 | v1 & 0xFFFFFFFFFFFFFF00;
    unint64_t v7 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
    unint64_t v8 = *(unsigned int *)(v6 + 40);
    if (!v8) {
      goto LABEL_14;
    }
    uint64_t v9 = *(void **)(v6 + 32);
    BOOL v10 = &v9[2 * v8];
    do
    {
      unint64_t v11 = v8 >> 1;
      unint64_t v12 = &v9[2 * (v8 >> 1)];
      unint64_t v14 = *v12;
      uint64_t v13 = v12 + 2;
      v8 += ~(v8 >> 1);
      if (v14 < v7) {
        uint64_t v9 = v13;
      }
      else {
        unint64_t v8 = v11;
      }
    }
    while (v8);
    if (v9 == v10 || *v9 != v7 || (uint64_t result = v9[1]) == 0)
    {
LABEL_14:
      uint64_t v16 = *(void *)(v6 + 24);
      uint64_t v17 = *(void *)(a1 + 48);
      uint64_t v18 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
      unint64_t v19 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v16 + 104);
      return v19(v16, v18, v17);
    }
  }
  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::Operation *&>(mlir::Operation *&,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

void mlir::mps::anonymous namespace'::CastToFFT::~CastToFFT(mlir::mps::_anonymous_namespace_::CastToFFT *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  BOOL v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  BOOL v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::FastFourierTransformOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::FastFourierTransformOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::FastFourierTransformOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::CastToFFT::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v21 = 0;
  uint64_t v22 = a2;
  unint64_t v19 = &v21;
  uint64_t v20 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  v16[0] = &v19;
  v16[1] = (uint64_t **)&v18;
  uint64_t v25 = (uint64_t *)a2;
  if (*(_UNKNOWN **)(*(void *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::FastFourierTransformOp,void>::id
    || (*(unsigned char *)(a2 + 46) & 0x80) == 0
    || *(_DWORD *)(a2 + 68) != 2
    || (LOBYTE(v15) = 1,
        v23[0] = (uint64_t)&v15,
        v23[1] = (uint64_t)&v25,
        mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::CastOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::FastFourierTransformOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::CastOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::CastOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(v16, (uint64_t)v23), !(_BYTE)v15))
  {
    uint64_t v9 = "could not detect cast -> fft op pattern";
    goto LABEL_12;
  }
  uint64_t v17 = (uint64_t)v25;
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf((void *)(*(void *)(v21 + 8) & 0xFFFFFFFFFFFFFFF8));
  v23[0] = v20;
  uint64_t v6 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v23);
  uint64_t v7 = mlir::getElementTypeOrSelf((void *)(*(void *)(v6 + 8) & 0xFFFFFFFFFFFFFFF8));
  if (*(_UNKNOWN **)(*(void *)v7 + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v15 = v8;
  if (v8)
  {
    if (ElementTypeOrSelf == mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v15))
    {
      v23[0] = v21;
      uint64_t v25 = (uint64_t *)v18;
      unsigned int Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v22);
      BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v22);
      unint64_t v12 = mlir::OpBuilder::create<mlir::mps::FastFourierTransformOp,mlir::Value,mlir::Value,mlir::mps::FFTScalingMode,BOOL>((mlir::UnitAttr **)(a3 + 8), *(void *)(a2 + 24), v23, (uint64_t *)&v25, &Layout, (unsigned __int8 *)&InferredResultTypes);
      (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, a2, v12);
      return 1;
    }
    uint64_t v9 = "underlying element-types must match in order to produce exactly the same output";
LABEL_12:
    v23[0] = (uint64_t)v9;
    __int16 v24 = 259;
    uint64_t v25 = v23;
    uint64_t v10 = *(void *)(a3 + 16);
    if (v10) {
      goto LABEL_13;
    }
    return 0;
  }
  v23[0] = (uint64_t)"cannot apply pattern unless output of cast is complex";
  __int16 v24 = 259;
  uint64_t v25 = v23;
  uint64_t v10 = *(void *)(a3 + 16);
  if (!v10) {
    return 0;
  }
LABEL_13:
  uint64_t result = mlir::RewriterBase::Listener::classof(v10);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), uint64_t **))(*(void *)v10 + 64))(v10, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::FastFourierTransformOp &>(mlir::mps::FastFourierTransformOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v25);
  }
  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::CastOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::FastFourierTransformOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::CastOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::CastOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v15 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 24);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v15);
  if (result)
  {
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::CastOp,void>::id
      || (*(unsigned char *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 1)
    {
      goto LABEL_7;
    }
    uint64_t v7 = *(void *)(*(void *)(result + 72) + 24);
    uint64_t v8 = **v4;
    if (v8)
    {
      if (v8 != v7)
      {
LABEL_7:
        char v6 = 0;
        goto LABEL_8;
      }
    }
    else
    {
      *uint64_t *v4 = v7;
    }
    v4[1] = (uint64_t *)result;
    char v6 = 1;
  }
LABEL_8:
  uint64_t v9 = *(unsigned char **)a2;
  uint64_t v10 = *(void *)(a2 + 8);
  char v11 = v6 & (**(unsigned char **)a2 != 0);
  if (!result) {
    char v11 = 0;
  }
  *uint64_t v9 = v11;
  unint64_t v12 = a1[1];
  uint64_t v13 = *(uint64_t **)(*(void *)(*(void *)v10 + 72) + 56);
  if (*v12)
  {
    BOOL v14 = *v12 == v13;
  }
  else
  {
    *unint64_t v12 = v13;
    uint64_t v9 = *(unsigned char **)a2;
    char v11 = **(unsigned char **)a2 != 0;
    BOOL v14 = 1;
  }
  *uint64_t v9 = v14 & v11;
  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::FastFourierTransformOp &>(mlir::mps::FastFourierTransformOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::FastFourierTransformOp,mlir::Value,mlir::Value,mlir::mps::FFTScalingMode,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned int *a5, unsigned __int8 *a6)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.fast_fourier_transform", (const unsigned __int8 *)0x1A, Context);
  if (!v14)
  {
    __int16 v22 = 1283;
    unint64_t v21[2] = (uint64_t)"mps.fast_fourier_transform";
    v21[3] = 26;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::mps::FastFourierTransformOp::build(a1, (uint64_t)v23, *a3, *a4, *a5, *a6);
  uint64_t v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::FastFourierTransformOp,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void *mlir::mps::anonymous namespace'::CanonicalizeNoOpReduction<mlir::mps::ReductionMaxOp>::~CanonicalizeNoOpReduction(void *a1)
{
  int v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::mps::anonymous namespace'::CanonicalizeNoOpReduction<mlir::mps::ReductionMaxOp>::~CanonicalizeNoOpReduction(void *__p)
{
  int v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  BOOL v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionMaxOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionMaxOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionMaxOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeNoOpReduction<mlir::mps::ReductionMaxOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v35[4] = *MEMORY[0x1E4F143B8];
  uint64_t v32 = a2;
  uint64_t v4 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v32) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v4) {
    goto LABEL_10;
  }
  uint64_t v5 = *v4;
  unint64_t v6 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v7 = *(unsigned int *)(v5 + 16);
  if (!v7) {
    goto LABEL_10;
  }
  uint64_t v8 = *(void **)(v5 + 8);
  uint64_t v9 = &v8[2 * v7];
  do
  {
    unint64_t v10 = v7 >> 1;
    char v11 = &v8[2 * (v7 >> 1)];
    unint64_t v13 = *v11;
    unint64_t v12 = v11 + 2;
    v7 += ~(v7 >> 1);
    if (v13 < v6) {
      uint64_t v8 = v12;
    }
    else {
      unint64_t v7 = v10;
    }
  }
  while (v7);
  if (v8 != v9 && *v8 == v6) {
    uint64_t v14 = v8[1];
  }
  else {
LABEL_10:
  }
    uint64_t v14 = 0;
  v31[0] = v4;
  v31[1] = v14;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v31)) {
    return 0;
  }
  uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v31);
  uint64_t v17 = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v31);
  uint64_t v19 = v18;
  unint64_t v33 = v35;
  uint64_t v34 = 0x400000000;
  uint64_t Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v32);
  uint64_t v30 = Axes;
  if (Axes && !mlir::getPositiveAxes(Axes, v19, (uint64_t)&v33, 0, 0, 0)) {
    goto LABEL_26;
  }
  if (v34) {
    uint64_t v21 = v34;
  }
  else {
    uint64_t v21 = v17;
  }
  if (v21 >= 1)
  {
    uint64_t v22 = 0;
    while (1)
    {
      uint64_t v23 = v22;
      if (v34) {
        uint64_t v23 = *((void *)v33 + v22);
      }
      if (*(void *)(ArgAttrsAttr + 8 * v23) != 1) {
        break;
      }
      if (v21 == ++v22) {
        goto LABEL_23;
      }
    }
LABEL_26:
    uint64_t v26 = 0;
    goto LABEL_28;
  }
LABEL_23:
  BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v32);
  uint64_t v25 = v32;
  if (InferredResultTypes)
  {
    uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v32);
    uint64_t v26 = 1;
    (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(void *)a3 + 24))(a3, v25, &Input, 1);
  }
  else
  {
    uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v32);
    unint64_t v27 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::Value&>((mlir::OpBuilder *)(a3 + 8), *(void *)(v25 + 24), &Input, &v30);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, v25, v27);
    uint64_t v26 = 1;
  }
LABEL_28:
  if (v33 != v35) {
    free(v33);
  }
  return v26;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::Value&>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.squeeze", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.squeeze";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::SqueezeOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  char v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SqueezeOp,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *mlir::mps::anonymous namespace'::CanonicalizeNoOpReduction<mlir::mps::ReductionMinOp>::~CanonicalizeNoOpReduction(void *a1)
{
  int v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::mps::anonymous namespace'::CanonicalizeNoOpReduction<mlir::mps::ReductionMinOp>::~CanonicalizeNoOpReduction(void *__p)
{
  int v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  BOOL v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionMinOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionMinOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionMinOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeNoOpReduction<mlir::mps::ReductionMinOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v35[4] = *MEMORY[0x1E4F143B8];
  uint64_t v32 = a2;
  uint64_t v4 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v32) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v4) {
    goto LABEL_10;
  }
  uint64_t v5 = *v4;
  unint64_t v6 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v7 = *(unsigned int *)(v5 + 16);
  if (!v7) {
    goto LABEL_10;
  }
  uint64_t v8 = *(void **)(v5 + 8);
  uint64_t v9 = &v8[2 * v7];
  do
  {
    unint64_t v10 = v7 >> 1;
    char v11 = &v8[2 * (v7 >> 1)];
    unint64_t v13 = *v11;
    unint64_t v12 = v11 + 2;
    v7 += ~(v7 >> 1);
    if (v13 < v6) {
      uint64_t v8 = v12;
    }
    else {
      unint64_t v7 = v10;
    }
  }
  while (v7);
  if (v8 != v9 && *v8 == v6) {
    uint64_t v14 = v8[1];
  }
  else {
LABEL_10:
  }
    uint64_t v14 = 0;
  v31[0] = v4;
  v31[1] = v14;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v31)) {
    return 0;
  }
  uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v31);
  uint64_t v17 = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v31);
  uint64_t v19 = v18;
  unint64_t v33 = v35;
  uint64_t v34 = 0x400000000;
  uint64_t Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v32);
  uint64_t v30 = Axes;
  if (Axes && !mlir::getPositiveAxes(Axes, v19, (uint64_t)&v33, 0, 0, 0)) {
    goto LABEL_26;
  }
  if (v34) {
    uint64_t v21 = v34;
  }
  else {
    uint64_t v21 = v17;
  }
  if (v21 >= 1)
  {
    uint64_t v22 = 0;
    while (1)
    {
      uint64_t v23 = v22;
      if (v34) {
        uint64_t v23 = *((void *)v33 + v22);
      }
      if (*(void *)(ArgAttrsAttr + 8 * v23) != 1) {
        break;
      }
      if (v21 == ++v22) {
        goto LABEL_23;
      }
    }
LABEL_26:
    uint64_t v26 = 0;
    goto LABEL_28;
  }
LABEL_23:
  BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v32);
  uint64_t v25 = v32;
  if (InferredResultTypes)
  {
    uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v32);
    uint64_t v26 = 1;
    (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(void *)a3 + 24))(a3, v25, &Input, 1);
  }
  else
  {
    uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v32);
    unint64_t v27 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::Value&>((mlir::OpBuilder *)(a3 + 8), *(void *)(v25 + 24), &Input, &v30);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, v25, v27);
    uint64_t v26 = 1;
  }
LABEL_28:
  if (v33 != v35) {
    free(v33);
  }
  return v26;
}

void *mlir::mps::anonymous namespace'::CanonicalizeNoOpReduction<mlir::mps::ReductionProdOp>::~CanonicalizeNoOpReduction(void *a1)
{
  int v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::mps::anonymous namespace'::CanonicalizeNoOpReduction<mlir::mps::ReductionProdOp>::~CanonicalizeNoOpReduction(void *__p)
{
  int v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  BOOL v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionProdOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionProdOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionProdOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeNoOpReduction<mlir::mps::ReductionProdOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v35[4] = *MEMORY[0x1E4F143B8];
  uint64_t v32 = a2;
  uint64_t v4 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v32) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v4) {
    goto LABEL_10;
  }
  uint64_t v5 = *v4;
  unint64_t v6 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v7 = *(unsigned int *)(v5 + 16);
  if (!v7) {
    goto LABEL_10;
  }
  uint64_t v8 = *(void **)(v5 + 8);
  uint64_t v9 = &v8[2 * v7];
  do
  {
    unint64_t v10 = v7 >> 1;
    char v11 = &v8[2 * (v7 >> 1)];
    unint64_t v13 = *v11;
    unint64_t v12 = v11 + 2;
    v7 += ~(v7 >> 1);
    if (v13 < v6) {
      uint64_t v8 = v12;
    }
    else {
      unint64_t v7 = v10;
    }
  }
  while (v7);
  if (v8 != v9 && *v8 == v6) {
    uint64_t v14 = v8[1];
  }
  else {
LABEL_10:
  }
    uint64_t v14 = 0;
  v31[0] = v4;
  v31[1] = v14;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v31)) {
    return 0;
  }
  uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v31);
  uint64_t v17 = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v31);
  uint64_t v19 = v18;
  unint64_t v33 = v35;
  uint64_t v34 = 0x400000000;
  uint64_t Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v32);
  uint64_t v30 = Axes;
  if (Axes && !mlir::getPositiveAxes(Axes, v19, (uint64_t)&v33, 0, 0, 0)) {
    goto LABEL_26;
  }
  if (v34) {
    uint64_t v21 = v34;
  }
  else {
    uint64_t v21 = v17;
  }
  if (v21 >= 1)
  {
    uint64_t v22 = 0;
    while (1)
    {
      uint64_t v23 = v22;
      if (v34) {
        uint64_t v23 = *((void *)v33 + v22);
      }
      if (*(void *)(ArgAttrsAttr + 8 * v23) != 1) {
        break;
      }
      if (v21 == ++v22) {
        goto LABEL_23;
      }
    }
LABEL_26:
    uint64_t v26 = 0;
    goto LABEL_28;
  }
LABEL_23:
  BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v32);
  uint64_t v25 = v32;
  if (InferredResultTypes)
  {
    uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v32);
    uint64_t v26 = 1;
    (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(void *)a3 + 24))(a3, v25, &Input, 1);
  }
  else
  {
    uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v32);
    unint64_t v27 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::Value&>((mlir::OpBuilder *)(a3 + 8), *(void *)(v25 + 24), &Input, &v30);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, v25, v27);
    uint64_t v26 = 1;
  }
LABEL_28:
  if (v33 != v35) {
    free(v33);
  }
  return v26;
}

void *mlir::mps::anonymous namespace'::CanonicalizeNoOpReduction<mlir::mps::ReductionSumOp>::~CanonicalizeNoOpReduction(void *a1)
{
  int v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::mps::anonymous namespace'::CanonicalizeNoOpReduction<mlir::mps::ReductionSumOp>::~CanonicalizeNoOpReduction(void *__p)
{
  int v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  BOOL v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionSumOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionSumOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionSumOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeNoOpReduction<mlir::mps::ReductionSumOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v35[4] = *MEMORY[0x1E4F143B8];
  uint64_t v32 = a2;
  uint64_t v4 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v32) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v4) {
    goto LABEL_10;
  }
  uint64_t v5 = *v4;
  unint64_t v6 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v7 = *(unsigned int *)(v5 + 16);
  if (!v7) {
    goto LABEL_10;
  }
  uint64_t v8 = *(void **)(v5 + 8);
  uint64_t v9 = &v8[2 * v7];
  do
  {
    unint64_t v10 = v7 >> 1;
    char v11 = &v8[2 * (v7 >> 1)];
    unint64_t v13 = *v11;
    unint64_t v12 = v11 + 2;
    v7 += ~(v7 >> 1);
    if (v13 < v6) {
      uint64_t v8 = v12;
    }
    else {
      unint64_t v7 = v10;
    }
  }
  while (v7);
  if (v8 != v9 && *v8 == v6) {
    uint64_t v14 = v8[1];
  }
  else {
LABEL_10:
  }
    uint64_t v14 = 0;
  v31[0] = v4;
  v31[1] = v14;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v31)) {
    return 0;
  }
  uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v31);
  uint64_t v17 = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v31);
  uint64_t v19 = v18;
  unint64_t v33 = v35;
  uint64_t v34 = 0x400000000;
  uint64_t Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v32);
  uint64_t v30 = Axes;
  if (Axes && !mlir::getPositiveAxes(Axes, v19, (uint64_t)&v33, 0, 0, 0)) {
    goto LABEL_26;
  }
  if (v34) {
    uint64_t v21 = v34;
  }
  else {
    uint64_t v21 = v17;
  }
  if (v21 >= 1)
  {
    uint64_t v22 = 0;
    while (1)
    {
      uint64_t v23 = v22;
      if (v34) {
        uint64_t v23 = *((void *)v33 + v22);
      }
      if (*(void *)(ArgAttrsAttr + 8 * v23) != 1) {
        break;
      }
      if (v21 == ++v22) {
        goto LABEL_23;
      }
    }
LABEL_26:
    uint64_t v26 = 0;
    goto LABEL_28;
  }
LABEL_23:
  BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v32);
  uint64_t v25 = v32;
  if (InferredResultTypes)
  {
    uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v32);
    uint64_t v26 = 1;
    (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(void *)a3 + 24))(a3, v25, &Input, 1);
  }
  else
  {
    uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v32);
    unint64_t v27 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::Value&>((mlir::OpBuilder *)(a3 + 8), *(void *)(v25 + 24), &Input, &v30);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, v25, v27);
    uint64_t v26 = 1;
  }
LABEL_28:
  if (v33 != v35) {
    free(v33);
  }
  return v26;
}

void *mlir::mps::anonymous namespace'::CanonicalizeMatMulExpandSqueezeBinary<mlir::mps::AddOp>::~CanonicalizeMatMulExpandSqueezeBinary(void *a1)
{
  int v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::mps::anonymous namespace'::CanonicalizeMatMulExpandSqueezeBinary<mlir::mps::AddOp>::~CanonicalizeMatMulExpandSqueezeBinary(void *__p)
{
  int v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  BOOL v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeMatMulExpandSqueezeBinary<mlir::mps::AddOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v50 = 0;
  uint64_t v51 = a2;
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  v46[0] = &v50;
  v46[1] = &v49;
  uint64_t v47 = 0;
  v44[0] = v46;
  v44[1] = &v48;
  uint64_t v45 = 0;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  v41[0] = v44;
  v41[1] = &v43;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  v38[0] = v41;
  v38[1] = &v40;
  v37[0] = a2;
  if (*(_UNKNOWN **)(*(void *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id) {
    return 0;
  }
  if ((*(unsigned char *)(a2 + 46) & 0x80) == 0) {
    return 0;
  }
  if (*(_DWORD *)(a2 + 68) != 2) {
    return 0;
  }
  LOBYTE(Input) = 1;
  v52[0] = &Input;
  v52[1] = v37;
  mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>((uint64_t)v38, (uint64_t)v52);
  if (!(_BYTE)Input) {
    return 0;
  }
  uint64_t v39 = v37[0];
  if (!v6) {
    return 0;
  }
  unint64_t v7 = SingleSqueezeIndex;
  v52[0] = v47;
  uint64_t v8 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)v52) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v8) {
    goto LABEL_15;
  }
  uint64_t v9 = *v8;
  unint64_t v10 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v11 = *(unsigned int *)(v9 + 16);
  if (!v11) {
    goto LABEL_15;
  }
  unint64_t v12 = *(void **)(v9 + 8);
  unint64_t v13 = &v12[2 * v11];
  do
  {
    unint64_t v14 = v11 >> 1;
    uint64_t v15 = &v12[2 * (v11 >> 1)];
    unint64_t v17 = *v15;
    uint64_t v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10) {
      unint64_t v12 = v16;
    }
    else {
      unint64_t v11 = v14;
    }
  }
  while (v11);
  if (v12 != v13 && *v12 == v10) {
    uint64_t v18 = v12[1];
  }
  else {
LABEL_15:
  }
    uint64_t v18 = 0;
  v37[0] = v8;
  v37[1] = v18;
  v52[0] = v45;
  BOOL IsNegated = mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)v52);
  uint64_t v20 = 1;
  if (IsNegated) {
    uint64_t v20 = 2;
  }
  unint64_t v21 = v20 + v7;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v37);
  if (v21 >= v22)
  {
    v52[0] = "cannot apply pattern if the squeeze is applied to the last two dimensions";
    __int16 v53 = 259;
    uint64_t Input = v52;
    uint64_t v26 = *(void *)(a3 + 16);
    if (v26) {
      goto LABEL_24;
    }
    return 0;
  }
  if (!v24) {
    return 0;
  }
  if (SingleExpandedIndex != v7)
  {
    v52[0] = "squeezed dimension and expanded dimension did not match";
    __int16 v53 = 259;
    uint64_t Input = v52;
    uint64_t v26 = *(void *)(a3 + 16);
    if (!v26) {
      return 0;
    }
LABEL_24:
    uint64_t result = mlir::RewriterBase::Listener::classof(v26);
    if (result) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v26 + 64))(v26, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(mlir::mps::ReshapeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &Input);
    }
    return result;
  }
  if (v7)
  {
    uint64_t v25 = "cannot apply squeeze->matmul->add->expand pattern if the expand/squeeze dimension is not 0";
  }
  else
  {
    if (mlir::Operation::hasOneUse(v45))
    {
      uint64_t v28 = *(void *)(v51 + 24);
      uint64_t v36 = v47;
      uint64_t Input = (void *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v36);
      uint64_t v35 = v48;
      unint64_t v33 = v45;
      BOOL v34 = mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v33);
      unsigned int v31 = v45;
      BOOL TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v31);
      v52[0] = mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value,mlir::Value,BOOL,BOOL>((mlir::BoolAttr **)(a3 + 8), v28, (uint64_t *)&Input, &v35, (unsigned __int8 *)&v34, (unsigned __int8 *)&TransposeRhs);
      uint64_t v29 = *(void *)(v51 + 24);
      uint64_t v36 = v42;
      uint64_t Input = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v36);
      uint64_t v30 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::mps::MultiplyOp &,mlir::Value>((mlir::Float32Type **)(a3 + 8), v29, v52, (uint64_t *)&Input);
      (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, v51, v30);
      return 1;
    }
    uint64_t v25 = "pattern should not be applied if matmul ops have more than one use";
  }
  return mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(a3, &v51, v25);
}

unint64_t mlir::mps::anonymous namespace'::anonymous namespace'::getSingleSqueezeIndex(uint64_t a1, uint64_t a2)
{
  uint64_t v45 = a1;
  BOOL v3 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3) {
    goto LABEL_10;
  }
  uint64_t v4 = *v3;
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *(unsigned int *)(v4 + 16);
  if (!v6) {
    goto LABEL_10;
  }
  unint64_t v7 = *(void **)(v4 + 8);
  uint64_t v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    unint64_t v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    unint64_t v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      unint64_t v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_10:
  }
    uint64_t v13 = 0;
  v44[0] = v3;
  v44[1] = v13;
  unint64_t v14 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v14) {
    goto LABEL_20;
  }
  uint64_t v15 = *v14;
  unint64_t v16 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v17 = *(unsigned int *)(v15 + 16);
  if (!v17) {
    goto LABEL_20;
  }
  uint64_t v18 = *(void **)(v15 + 8);
  uint64_t v19 = &v18[2 * v17];
  do
  {
    unint64_t v20 = v17 >> 1;
    unint64_t v21 = &v18[2 * (v17 >> 1)];
    unint64_t v23 = *v21;
    unint64_t v22 = v21 + 2;
    v17 += ~(v17 >> 1);
    if (v23 < v16) {
      uint64_t v18 = v22;
    }
    else {
      unint64_t v17 = v20;
    }
  }
  while (v17);
  if (v18 != v19 && *v18 == v16) {
    uint64_t v24 = v18[1];
  }
  else {
LABEL_20:
  }
    uint64_t v24 = 0;
  v43[0] = v14;
  v43[1] = v24;
  v47[0] = v14;
  v47[1] = v24;
  v46[0] = v3;
  v46[1] = v13;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v46)
    || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v47)
    || (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v47),
        uint64_t v26 = v25,
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v46),
        v26 <= v27)
    && (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v47), v28 >= 2))
  {
    uint64_t v29 = "the pattern did not define a valid squeeze operation";
LABEL_26:
    v47[0] = v29;
    __int16 v48 = 259;
    uint64_t v30 = v45;
    v46[0] = v47;
    uint64_t v31 = *(void *)(a2 + 16);
    if (v31 && mlir::RewriterBase::Listener::classof(v31)) {
      (*(void (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v31 + 64))(v31, *(void *)(v30 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(mlir::mps::ReshapeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v46);
    }
    uint64_t v32 = 0;
    unint64_t v33 = 0;
    return v33 | v32;
  }
  uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v43);
  uint64_t v36 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v44);
  if (v37)
  {
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    uint64_t v32 = -1;
    while (1)
    {
      uint64_t v40 = *(void *)(ArgAttrsAttr + 8 * v38);
      uint64_t v41 = *(void *)(v36 + 8 * v39);
      if (v40 != v41)
      {
        if (v40 != 1) {
          break;
        }
        ++v38;
        BOOL v42 = *(void *)(ArgAttrsAttr + 8 * v38) == v41 && v32 == -1;
        uint64_t v32 = v39;
        if (!v42) {
          break;
        }
      }
      ++v38;
      if (v37 == ++v39) {
        goto LABEL_44;
      }
    }
    uint64_t v29 = "cannot detect a squeeze over a single dimension";
    goto LABEL_26;
  }
  uint64_t v32 = -1;
LABEL_44:
  unint64_t v33 = v32 & 0xFFFFFFFFFFFFFF00;
  uint64_t v32 = v32;
  return v33 | v32;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(uint64_t a1, uint64_t *a2, unsigned char *a3)
{
  char v3 = 1;
  char v9 = 1;
  if (*a3)
  {
    unint64_t v7 = a3;
    char v3 = 3;
  }
  char v8 = v3;
  uint64_t v4 = *a2;
  unint64_t v10 = &v7;
  uint64_t v5 = *(void *)(a1 + 16);
  if (!v5) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16));
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v5 + 64))(v5, *(void *)(v4 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(mlir::mps::ReshapeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v10);
  }
  return result;
}

unint64_t mlir::mps::anonymous namespace'::anonymous namespace'::getSingleExpandedIndex(uint64_t a1, uint64_t a2)
{
  uint64_t v45 = a1;
  char v3 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3) {
    goto LABEL_10;
  }
  uint64_t v4 = *v3;
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *(unsigned int *)(v4 + 16);
  if (!v6) {
    goto LABEL_10;
  }
  unint64_t v7 = *(void **)(v4 + 8);
  char v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    unint64_t v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    unint64_t v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      unint64_t v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_10:
  }
    uint64_t v13 = 0;
  v44[0] = v3;
  v44[1] = v13;
  unint64_t v14 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v14) {
    goto LABEL_20;
  }
  uint64_t v15 = *v14;
  unint64_t v16 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v17 = *(unsigned int *)(v15 + 16);
  if (!v17) {
    goto LABEL_20;
  }
  uint64_t v18 = *(void **)(v15 + 8);
  uint64_t v19 = &v18[2 * v17];
  do
  {
    unint64_t v20 = v17 >> 1;
    unint64_t v21 = &v18[2 * (v17 >> 1)];
    unint64_t v23 = *v21;
    unint64_t v22 = v21 + 2;
    v17 += ~(v17 >> 1);
    if (v23 < v16) {
      uint64_t v18 = v22;
    }
    else {
      unint64_t v17 = v20;
    }
  }
  while (v17);
  if (v18 != v19 && *v18 == v16) {
    uint64_t v24 = v18[1];
  }
  else {
LABEL_20:
  }
    uint64_t v24 = 0;
  v43[0] = v14;
  v43[1] = v24;
  v47[0] = v3;
  v47[1] = v13;
  v46[0] = v14;
  v46[1] = v24;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v46)
    || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v47)
    || (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v47),
        uint64_t v26 = v25,
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v46),
        v26 <= v27)
    && (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v47), v28 >= 2))
  {
    uint64_t v29 = "the pattern did not define a valid expand operation";
LABEL_26:
    v47[0] = v29;
    __int16 v48 = 259;
    uint64_t v30 = v45;
    v46[0] = v47;
    uint64_t v31 = *(void *)(a2 + 16);
    if (v31 && mlir::RewriterBase::Listener::classof(v31)) {
      (*(void (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v31 + 64))(v31, *(void *)(v30 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(mlir::mps::ReshapeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v46);
    }
    uint64_t v32 = 0;
    unint64_t v33 = 0;
    return v33 | v32;
  }
  uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v44);
  uint64_t v36 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v43);
  if (v37)
  {
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    uint64_t v32 = -1;
    while (1)
    {
      uint64_t v40 = *(void *)(ArgAttrsAttr + 8 * v38);
      uint64_t v41 = *(void *)(v36 + 8 * v39);
      if (v40 != v41)
      {
        if (v40 != 1) {
          break;
        }
        ++v38;
        BOOL v42 = *(void *)(ArgAttrsAttr + 8 * v38) == v41 && v32 == -1;
        uint64_t v32 = v39;
        if (!v42) {
          break;
        }
      }
      ++v38;
      if (v37 == ++v39) {
        goto LABEL_44;
      }
    }
    uint64_t v29 = "cannot detect a squeeze over a single dimension";
    goto LABEL_26;
  }
  uint64_t v32 = -1;
LABEL_44:
  unint64_t v33 = v32 & 0xFFFFFFFFFFFFFF00;
  uint64_t v32 = v32;
  return v33 | v32;
}

BOOL mlir::Operation::hasOneUse(mlir::Operation *this)
{
  uint64_t v1 = *((unsigned int *)this + 9);
  int v2 = (char *)this - 16;
  if (!v1) {
    int v2 = 0;
  }
  *(void *)&v8[0] = v2;
  *((void *)&v8[0] + 1) = v1;
  mlir::ResultRange::getUses((uint64_t *)v8, (uint64_t *)v5);
  uint64_t v3 = v7;
  if (v6 == v7) {
    return 0;
  }
  v8[0] = v5[0];
  v8[1] = v5[1];
  uint64_t v9 = v6;
  mlir::ResultRange::UseIterator::operator++((uint64_t *)v8);
  return v9 == v3;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(uint64_t **)a1;
  v14[0] = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 24);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)v14);
  uint64_t v7 = result;
  if (result)
  {
    uint64_t v16 = result;
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id
      && (*(unsigned char *)(result + 46) & 0x80) != 0
      && *(_DWORD *)(result + 68) == 2)
    {
      unsigned __int8 v15 = 1;
      v14[0] = &v15;
      v14[1] = &v16;
      uint64_t result = mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(v4, (uint64_t)v14);
      int v8 = v15;
      if (v15) {
        v4[2] = v16;
      }
      BOOL v6 = v8 != 0;
    }
    else
    {
      BOOL v6 = 0;
    }
  }
  uint64_t v9 = *(BOOL **)a2;
  BOOL v10 = v6 && **(unsigned char **)a2 != 0;
  if (!v7) {
    BOOL v10 = 0;
  }
  *uint64_t v9 = v10;
  unint64_t v11 = *(void **)(a1 + 8);
  uint64_t v12 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 56);
  if (*v11)
  {
    BOOL v13 = *v11 == v12;
  }
  else
  {
    *unint64_t v11 = v12;
    uint64_t v9 = *(BOOL **)a2;
    BOOL v10 = **(unsigned char **)a2 != 0;
    BOOL v13 = 1;
  }
  *uint64_t v9 = v13 && v10;
  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  v14[0] = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 24);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)v14);
  uint64_t v7 = result;
  if (result)
  {
    uint64_t v16 = result;
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id
      && (*(unsigned char *)(result + 46) & 0x80) != 0
      && *(_DWORD *)(result + 68) == 2)
    {
      unsigned __int8 v15 = 1;
      v14[0] = &v15;
      v14[1] = &v16;
      uint64_t result = mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>((uint64_t ***)v4, (uint64_t)v14);
      int v8 = v15;
      if (v15) {
        *(void *)(v4 + 16) = v16;
      }
      BOOL v6 = v8 != 0;
    }
    else
    {
      BOOL v6 = 0;
    }
  }
  uint64_t v9 = *(BOOL **)a2;
  BOOL v10 = v6 && **(unsigned char **)a2 != 0;
  if (!v7) {
    BOOL v10 = 0;
  }
  *uint64_t v9 = v10;
  unint64_t v11 = (void *)a1[1];
  uint64_t v12 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 56);
  if (*v11)
  {
    BOOL v13 = *v11 == v12;
  }
  else
  {
    *unint64_t v11 = v12;
    uint64_t v9 = *(BOOL **)a2;
    BOOL v10 = **(unsigned char **)a2 != 0;
    BOOL v13 = 1;
  }
  *uint64_t v9 = v13 && v10;
  return result;
}

void *mlir::mps::anonymous namespace'::CanonicalizeMatMulExpandSqueezeUnary<mlir::mps::ReluOp>::~CanonicalizeMatMulExpandSqueezeUnary(void *a1)
{
  int v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::mps::anonymous namespace'::CanonicalizeMatMulExpandSqueezeUnary<mlir::mps::ReluOp>::~CanonicalizeMatMulExpandSqueezeUnary(void *__p)
{
  int v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeMatMulExpandSqueezeUnary<mlir::mps::ReluOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v49 = 0;
  uint64_t v50 = a2;
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  v45[0] = &v49;
  v45[1] = &v48;
  uint64_t v46 = 0;
  v43[0] = v45;
  v43[1] = &v47;
  uint64_t v44 = 0;
  v42[0] = v43;
  v42[1] = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  v39[0] = v42;
  v39[1] = &v41;
  *(void *)&v54[0] = a2;
  if (*(_UNKNOWN **)(*(void *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id) {
    return 0;
  }
  if ((*(unsigned char *)(a2 + 46) & 0x80) == 0) {
    return 0;
  }
  if (*(_DWORD *)(a2 + 68) != 2) {
    return 0;
  }
  LOBYTE(v38[0]) = 1;
  *(void *)&v51[0] = v38;
  *((void *)&v51[0] + 1) = v54;
  mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReluOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReluOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReluOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>((uint64_t)v39, (uint64_t)v51);
  if (!LOBYTE(v38[0])) {
    return 0;
  }
  uint64_t v40 = *(void *)&v54[0];
  if (!v6) {
    return 0;
  }
  unint64_t v7 = SingleSqueezeIndex;
  *(void *)&v51[0] = v46;
  int v8 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v8) {
    goto LABEL_15;
  }
  uint64_t v9 = *v8;
  unint64_t v10 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v11 = *(unsigned int *)(v9 + 16);
  if (!v11) {
    goto LABEL_15;
  }
  uint64_t v12 = *(void **)(v9 + 8);
  BOOL v13 = &v12[2 * v11];
  do
  {
    unint64_t v14 = v11 >> 1;
    unsigned __int8 v15 = &v12[2 * (v11 >> 1)];
    unint64_t v17 = *v15;
    uint64_t v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10) {
      uint64_t v12 = v16;
    }
    else {
      unint64_t v11 = v14;
    }
  }
  while (v11);
  if (v12 != v13 && *v12 == v10) {
    uint64_t v18 = v12[1];
  }
  else {
LABEL_15:
  }
    uint64_t v18 = 0;
  v38[0] = v8;
  v38[1] = v18;
  *(void *)&v51[0] = v44;
  BOOL IsNegated = mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)v51);
  uint64_t v20 = 1;
  if (IsNegated) {
    uint64_t v20 = 2;
  }
  unint64_t v21 = v20 + v7;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v38);
  if (v21 >= v22)
  {
    *(void *)&v51[0] = "cannot apply pattern if the squeeze is applied to the last two dimensions";
    LOWORD(v52) = 259;
    *(void *)&v54[0] = v51;
    uint64_t v29 = *(void *)(a3 + 16);
    if (!v29) {
      return 0;
    }
  }
  else
  {
    if (!v24) {
      return 0;
    }
    if (SingleExpandedIndex == v7)
    {
      uint64_t v25 = *(unsigned int *)(v44 + 36);
      uint64_t v26 = v44 - 16;
      if (!v25) {
        uint64_t v26 = 0;
      }
      *(void *)&v54[0] = v26;
      *((void *)&v54[0] + 1) = v25;
      mlir::ResultRange::getUses((uint64_t *)v54, (uint64_t *)v51);
      uint64_t v27 = v53;
      if (v52 == v53) {
        return mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(a3, &v50, "pattern should not be applied if matmul ops have more than one use");
      }
      v54[0] = v51[0];
      v54[1] = v51[1];
      uint64_t v55 = v52;
      mlir::ResultRange::UseIterator::operator++((uint64_t *)v54);
      if (v55 != v27) {
        return mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(a3, &v50, "pattern should not be applied if matmul ops have more than one use");
      }
      uint64_t v30 = *(void *)(a2 + 24);
      uint64_t v37 = v46;
      *(void *)&v54[0] = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
      uint64_t v36 = v47;
      uint64_t v34 = v44;
      BOOL v35 = mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v34);
      uint64_t v32 = v44;
      BOOL TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v32);
      *(void *)&v51[0] = mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value,mlir::Value,BOOL,BOOL>((mlir::BoolAttr **)(a3 + 8), v30, (uint64_t *)v54, &v36, (unsigned __int8 *)&v35, (unsigned __int8 *)&TransposeRhs);
      uint64_t v31 = mlir::OpBuilder::create<mlir::mps::ReluOp,mlir::mps::MatMulOp &>((mlir::OpBuilder *)(a3 + 8), *(void *)(a2 + 24), v51);
      (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, a2, v31);
      return 1;
    }
    *(void *)&v51[0] = "squeezed dimension and expanded dimension did not match";
    LOWORD(v52) = 259;
    *(void *)&v54[0] = v51;
    uint64_t v29 = *(void *)(a3 + 16);
    if (!v29) {
      return 0;
    }
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v29);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), _OWORD *))(*(void *)v29 + 64))(v29, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(mlir::mps::ReshapeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v54);
  }
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReluOp,mlir::mps::MatMulOp &>(mlir::OpBuilder *a1, uint64_t a2, void *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.relu", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"mps.relu";
    v15[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3 - 16);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReluOp,void>::id) {
    unint64_t v10 = v9;
  }
  else {
    unint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReluOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReluOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReluOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(uint64_t **)a1;
  v14[0] = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 24);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)v14);
  uint64_t v7 = result;
  if (result)
  {
    uint64_t v16 = result;
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReluOp,void>::id
      && (*(unsigned char *)(result + 46) & 0x80) != 0
      && *(_DWORD *)(result + 68) == 1)
    {
      unsigned __int8 v15 = 1;
      v14[0] = &v15;
      v14[1] = &v16;
      uint64_t result = mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReluOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *> & *)#1},0ul>(v4, (uint64_t)v14);
      int v8 = v15;
      if (v15) {
        v4[1] = v16;
      }
      BOOL v6 = v8 != 0;
    }
    else
    {
      BOOL v6 = 0;
    }
  }
  uint64_t v9 = *(BOOL **)a2;
  BOOL v10 = v6 && **(unsigned char **)a2 != 0;
  if (!v7) {
    BOOL v10 = 0;
  }
  *uint64_t v9 = v10;
  unint64_t v11 = *(void **)(a1 + 8);
  uint64_t v12 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 56);
  if (*v11)
  {
    BOOL v13 = *v11 == v12;
  }
  else
  {
    *unint64_t v11 = v12;
    uint64_t v9 = *(BOOL **)a2;
    BOOL v10 = **(unsigned char **)a2 != 0;
    BOOL v13 = 1;
  }
  *uint64_t v9 = v13 && v10;
  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReluOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *> & *)#1},0ul>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  v9[0] = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 24);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)v9);
  uint64_t v6 = result;
  if (result)
  {
    uint64_t v11 = result;
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id
      && (*(unsigned char *)(result + 46) & 0x80) != 0
      && *(_DWORD *)(result + 68) == 2)
    {
      unsigned __int8 v10 = 1;
      v9[0] = &v10;
      v9[1] = &v11;
      uint64_t result = mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>((uint64_t ***)v3, (uint64_t)v9);
      int v7 = v10;
      if (v10) {
        *(void *)(v3 + 16) = v11;
      }
      BOOL v5 = v7 != 0;
    }
    else
    {
      BOOL v5 = 0;
    }
  }
  BOOL v8 = v5 && **(unsigned char **)a2 != 0;
  if (!v6) {
    BOOL v8 = 0;
  }
  **(unsigned char **)a2 = v8;
  return result;
}

void mlir::mps::anonymous namespace'::CanonicalizeSoftMax::~CanonicalizeSoftMax(mlir::mps::_anonymous_namespace_::CanonicalizeSoftMax *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeSoftMax::matchAndRewrite(uint64_t a1, uint64_t a2, void *a3)
{
  unint64_t v33 = 0;
  uint64_t v34 = 0;
  v31[0] = &v34;
  v31[1] = &v33;
  uint64_t v32 = 0;
  v30[0] = &v34;
  v30[1] = v31;
  v30[2] = 0;
  v29[0] = v30;
  v29[1] = 0;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  v26[0] = v29;
  v26[1] = &v28;
  v24[0] = v29;
  v24[1] = v26;
  uint64_t v25 = 0;
  unint64_t v22 = (uint64_t *)a2;
  if (*(_UNKNOWN **)(*(void *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DivideOp,void>::id
    && (*(unsigned char *)(a2 + 46) & 0x80) != 0
    && *(_DWORD *)(a2 + 68) == 2)
  {
    LOBYTE(v37) = 1;
    v35[0] = (uint64_t)&v37;
    v35[1] = (uint64_t)&v22;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionSumOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::any_value_binder> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DivideOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionSumOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::any_value_binder>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionSumOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::any_value_binder> *> & *)#1},0ul,1ul>((uint64_t)v24, (uint64_t)v35);
    if ((_BYTE)v37)
    {
      uint64_t v25 = (uint64_t)v22;
      BOOL v5 = (uint64_t *)(*(void *)(v34 + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v5) {
        goto LABEL_14;
      }
      uint64_t v6 = *v5;
      unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v8 = *(unsigned int *)(v6 + 16);
      if (!v8) {
        goto LABEL_14;
      }
      uint64_t v9 = *(void **)(v6 + 8);
      unsigned __int8 v10 = &v9[2 * v8];
      do
      {
        unint64_t v11 = v8 >> 1;
        uint64_t v12 = &v9[2 * (v8 >> 1)];
        unint64_t v14 = *v12;
        BOOL v13 = v12 + 2;
        v8 += ~(v8 >> 1);
        if (v14 < v7) {
          uint64_t v9 = v13;
        }
        else {
          unint64_t v8 = v11;
        }
      }
      while (v8);
      if (v9 != v10 && *v9 == v7) {
        uint64_t v15 = v9[1];
      }
      else {
LABEL_14:
      }
        uint64_t v15 = 0;
      unint64_t v22 = v5;
      uint64_t v23 = v15;
      if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v22))
      {
        {
          return 0;
        }
        v35[0] = v32;
        BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)v35);
        v35[0] = v27;
        BOOL v17 = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)v35);
        if (InferredResultTypes && v17)
        {
          v35[0] = v34;
          uint64_t v37 = v33;
          uint64_t v18 = mlir::OpBuilder::create<mlir::mps::SoftmaxOp,mlir::Value,mlir::Value>((mlir::OpBuilder *)(a3 + 1), *(void *)(a2 + 24), v35, (uint64_t *)&v37);
          (*(void (**)(void *, uint64_t, mlir::GenericProgramPoint *))(*a3 + 32))(a3, a2, v18);
          return 1;
        }
        v35[0] = (uint64_t)"failed: reductions must keep dimensions to represent a softmax op";
        __int16 v36 = 259;
        uint64_t v37 = v35;
        uint64_t v21 = a3[2];
        if (!v21) {
          return 0;
        }
        goto LABEL_26;
      }
      v35[0] = (uint64_t)"failed: input is unranked";
      __int16 v36 = 259;
      uint64_t v37 = v35;
      uint64_t v21 = a3[2];
      if (v21)
      {
LABEL_26:
        uint64_t result = mlir::RewriterBase::Listener::classof(v21);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), uint64_t **))(*(void *)v21 + 64))(v21, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DivideOp &>(mlir::mps::DivideOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v37);
        }
        return result;
      }
      return 0;
    }
  }
  v35[0] = (uint64_t)"failed: pattern did not match";
  __int16 v36 = 259;
  unint64_t v22 = v35;
  uint64_t v20 = a3[2];
  if (!v20) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v20);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), uint64_t **))(*(void *)v20 + 64))(v20, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DivideOp &>(mlir::mps::DivideOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v22);
  }
  return result;
}

BOOL mlir::mps::anonymous namespace'::CanonicalizeSoftMax::verifyFastestRunningIndex(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  v8[0] = a2;
  v8[1] = a3;
  uint64_t v9 = v11;
  uint64_t v10 = 0x600000000;
  char matched = mlir::matchConstantWithIntVector<long long>(a1, (uint64_t)&v9);
  BOOL v4 = 0;
  BOOL v5 = v9;
  if (matched && v10 == 1)
  {
    if (*(void *)v9 != -1)
    {
      if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v8))
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v8);
        BOOL v5 = v9;
        BOOL v4 = *(void *)v9 == v6 - 1;
        if (v9 == v11) {
          return v4;
        }
      }
      else
      {
        BOOL v4 = 0;
        BOOL v5 = v9;
        if (v9 == v11) {
          return v4;
        }
      }
      goto LABEL_9;
    }
    BOOL v4 = 1;
  }
  if (v9 != v11) {
LABEL_9:
  }
    free(v5);
  return v4;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionSumOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::any_value_binder> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DivideOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionSumOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::any_value_binder>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionSumOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::any_value_binder> *> & *)#1},0ul,1ul>(uint64_t a1, uint64_t a2)
{
  BOOL v4 = *(uint64_t **)a1;
  uint64_t v16 = *(unsigned __int8 **)(*(void *)(**(void **)(a2 + 8) + 72) + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v16);
  uint64_t v7 = DefiningOp;
  if (DefiningOp)
  {
    uint64_t v19 = DefiningOp;
    if (*(_UNKNOWN **)(*(void *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ExponentOp,void>::id
      && (*(unsigned char *)(DefiningOp + 46) & 0x80) != 0
      && *(_DWORD *)(DefiningOp + 68) == 1)
    {
      unsigned __int8 v18 = 1;
      uint64_t v16 = &v18;
      BOOL v17 = &v19;
      mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>> *> & *)#1},0ul>(v4, (uint64_t)&v16);
      int v8 = v18;
      if (v18) {
        v4[1] = v19;
      }
      BOOL v6 = v8 != 0;
    }
    else
    {
      BOOL v6 = 0;
    }
  }
  BOOL v9 = v6 && **(unsigned char **)a2 != 0;
  if (!v7) {
    BOOL v9 = 0;
  }
  **(unsigned char **)a2 = v9;
  uint64_t v10 = *(void *)(a1 + 8);
  uint64_t v16 = *(unsigned __int8 **)(*(void *)(**(void **)(a2 + 8) + 72) + 56);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v16);
  uint64_t v13 = result;
  if (result)
  {
    uint64_t v19 = result;
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionSumOp,void>::id
      && (*(unsigned char *)(result + 46) & 0x80) != 0
      && *(_DWORD *)(result + 68) == 2)
    {
      unsigned __int8 v18 = 1;
      uint64_t v16 = &v18;
      BOOL v17 = &v19;
      uint64_t result = mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionSumOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(v10, (uint64_t)&v16);
      int v14 = v18;
      if (v18) {
        *(void *)(v10 + 16) = v19;
      }
      BOOL v12 = v14 != 0;
    }
    else
    {
      BOOL v12 = 0;
    }
  }
  BOOL v15 = v12 && **(unsigned char **)a2 != 0;
  if (!v13) {
    BOOL v15 = 0;
  }
  **(unsigned char **)a2 = v15;
  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>> *> & *)#1},0ul>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  v9[0] = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 24);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)v9);
  uint64_t v6 = result;
  if (result)
  {
    uint64_t v11 = result;
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SubtractOp,void>::id
      && (*(unsigned char *)(result + 46) & 0x80) != 0
      && *(_DWORD *)(result + 68) == 2)
    {
      unsigned __int8 v10 = 1;
      v9[0] = &v10;
      v9[1] = &v11;
      uint64_t result = mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *> & *)#1},0ul,1ul>((uint64_t **)v3, (uint64_t)v9);
      int v7 = v10;
      if (v10) {
        *(void *)(v3 + 16) = v11;
      }
      BOOL v5 = v7 != 0;
    }
    else
    {
      BOOL v5 = 0;
    }
  }
  BOOL v8 = v5 && **(unsigned char **)a2 != 0;
  if (!v6) {
    BOOL v8 = 0;
  }
  **(unsigned char **)a2 = v8;
  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *> & *)#1},0ul,1ul>(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(**(void **)(a2 + 8) + 72);
  uint64_t v4 = *(void *)(v3 + 24);
  uint64_t v5 = **a1;
  if (v5)
  {
    BOOL v6 = v5 == v4;
  }
  else
  {
    **a1 = v4;
    uint64_t v3 = *(void *)(**(void **)(a2 + 8) + 72);
    BOOL v6 = 1;
  }
  if (!**(unsigned char **)a2) {
    BOOL v6 = 0;
  }
  **(unsigned char **)a2 = v6;
  int v7 = (uint64_t **)a1[1];
  uint64_t v18 = *(void *)(v3 + 56);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v18);
  if (result)
  {
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ReductionMaxOp,void>::id
      || (*(unsigned char *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 2)
    {
      goto LABEL_19;
    }
    uint64_t v10 = *(void *)(result + 72);
    uint64_t v11 = *(void *)(v10 + 24);
    uint64_t v12 = **v7;
    if (v12)
    {
      BOOL v13 = v12 == v11;
    }
    else
    {
      **int v7 = v11;
      uint64_t v10 = *(void *)(result + 72);
      BOOL v13 = 1;
    }
    int v14 = v7[1];
    uint64_t v15 = *(void *)(v10 + 56);
    if (*v14)
    {
      BOOL v16 = *v14 == v15;
    }
    else
    {
      *int v14 = v15;
      BOOL v16 = 1;
    }
    int v9 = v13 && v16;
    if (v9 == 1) {
      void v7[2] = (uint64_t *)result;
    }
    else {
LABEL_19:
    }
      LOBYTE(v9) = 0;
  }
  char v17 = v9 & (**(unsigned char **)a2 != 0);
  if (!result) {
    char v17 = 0;
  }
  **(unsigned char **)a2 = v17;
  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionSumOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(uint64_t **)a1;
  v14[0] = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 24);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)v14);
  uint64_t v7 = result;
  if (result)
  {
    uint64_t v16 = result;
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ExponentOp,void>::id
      && (*(unsigned char *)(result + 46) & 0x80) != 0
      && *(_DWORD *)(result + 68) == 1)
    {
      unsigned __int8 v15 = 1;
      v14[0] = &v15;
      v14[1] = &v16;
      uint64_t result = mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>> *> & *)#1},0ul>(v4, (uint64_t)v14);
      int v8 = v15;
      if (v15) {
        v4[1] = v16;
      }
      BOOL v6 = v8 != 0;
    }
    else
    {
      BOOL v6 = 0;
    }
  }
  int v9 = *(BOOL **)a2;
  BOOL v10 = v6 && **(unsigned char **)a2 != 0;
  if (!v7) {
    BOOL v10 = 0;
  }
  *int v9 = v10;
  uint64_t v11 = *(void **)(a1 + 8);
  uint64_t v12 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 56);
  if (*v11)
  {
    BOOL v13 = *v11 == v12;
  }
  else
  {
    *uint64_t v11 = v12;
    int v9 = *(BOOL **)a2;
    BOOL v10 = **(unsigned char **)a2 != 0;
    BOOL v13 = 1;
  }
  *int v9 = v13 && v10;
  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DivideOp &>(mlir::mps::DivideOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t mlir::matchConstantWithIntVector<long long>(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  if (!a1) {
    return 0;
  }
  int v8 = (uint64_t **)&v9;
  uint64_t v11 = a1;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp) {
    return 0;
  }
  if (!mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v8, DefiningOp)) {
    return 0;
  }
  v7[0] = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v9);
  v7[1] = v4;
  if (*(_UNKNOWN **)(*(void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v7) + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id) {
    return 0;
  }
  uint64_t v5 = 1;
  mlir::getIntValues<long long>(v9, v10, a2, 1);
  return v5;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SoftmaxOp,mlir::Value,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.softmax", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.softmax";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::SoftmaxOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SoftmaxOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::mps::anonymous namespace'::CanonicalizeTileAsBroadcast::~CanonicalizeTileAsBroadcast(mlir::mps::_anonymous_namespace_::CanonicalizeTileAsBroadcast *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::TileOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::TileOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::TileOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeTileAsBroadcast::matchAndRewrite(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v37 = a2;
  uint64_t v4 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v4) {
    goto LABEL_10;
  }
  uint64_t v5 = *v4;
  unint64_t v6 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v7 = *(unsigned int *)(v5 + 16);
  if (!v7) {
    goto LABEL_10;
  }
  int v8 = *(void **)(v5 + 8);
  uint64_t v9 = &v8[2 * v7];
  do
  {
    unint64_t v10 = v7 >> 1;
    uint64_t v11 = &v8[2 * (v7 >> 1)];
    unint64_t v13 = *v11;
    uint64_t v12 = v11 + 2;
    v7 += ~(v7 >> 1);
    if (v13 < v6) {
      int v8 = v12;
    }
    else {
      unint64_t v7 = v10;
    }
  }
  while (v7);
  if (v8 != v9 && *v8 == v6) {
    uint64_t v14 = v8[1];
  }
  else {
LABEL_10:
  }
    uint64_t v14 = 0;
  v36[0] = v4;
  v36[1] = v14;
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v36) & 1) == 0)
  {
    uint64_t v26 = "failed: input must be a ranked shaped type";
    goto LABEL_27;
  }
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  uint64_t Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v37);
  uint64_t v41 = &v34;
  uint64_t v44 = Filter;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v44);
  if (!DefiningOp || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&v41, DefiningOp))
  {
    uint64_t v26 = "failed: multipliers must be constant to rewrite Tile as a broadcast op";
LABEL_27:
    uint64_t v44 = v26;
    v46[8] = 259;
    uint64_t v27 = v37;
    uint64_t v41 = &v44;
    uint64_t v28 = a3[2];
    if (v28)
    {
      if (mlir::RewriterBase::Listener::classof(v28)) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v28 + 64))(v28, *(void *)(v27 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TileOp &>(mlir::mps::TileOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v41);
      }
      else {
        return 0;
      }
    }
    return v28;
  }
  uint64_t v44 = v46;
  uint64_t v45 = 0x400000000;
  mlir::getIntValues<long long>(v34, v35, (uint64_t)&v44, 1);
  uint64_t v41 = v43;
  uint64_t v42 = 0x400000000;
  uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v36);
  if (!v18 || !v45)
  {
LABEL_31:
    v38[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,llvm::SmallVector<long long,4u> &>((mlir::Builder *)(a3 + 1), *(void *)(v37 + 24), (uint64_t)&v41);
    uint64_t v29 = v37;
    uint64_t Input = (void *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
    uint64_t v30 = mlir::OpBuilder::create<mlir::mps::BroadcastToOp,mlir::Value &,mlir::mps::ShapeOp>((mlir::OpBuilder *)(a3 + 1), *(void *)(v29 + 24), (uint64_t *)&Input, v38);
    (*(void (**)(void *, uint64_t, mlir::GenericProgramPoint *))(*a3 + 32))(a3, v29, v30);
    uint64_t v28 = 1;
    goto LABEL_32;
  }
  uint64_t v19 = (uint64_t *)ArgAttrsAttr;
  uint64_t v20 = (uint64_t *)v44;
  uint64_t v21 = 8 * v45 - 8;
  uint64_t v22 = 8 * v18 - 8;
  while (1)
  {
    uint64_t v23 = *v19;
    if (*v20 != 1) {
      break;
    }
    uint64_t v24 = v42;
    if (v42 < (unint64_t)HIDWORD(v42)) {
      goto LABEL_19;
    }
LABEL_24:
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v43, v24 + 1, 8);
    uint64_t v24 = v42;
LABEL_19:
    *((void *)v41 + v24) = v23;
    LODWORD(v42) = v42 + 1;
    if (v22)
    {
      ++v19;
      ++v20;
      uint64_t v25 = v21;
      v21 -= 8;
      v22 -= 8;
      if (v25) {
        continue;
      }
    }
    goto LABEL_31;
  }
  if (v23 == 1)
  {
    uint64_t v24 = v42;
    uint64_t v23 = *v20;
    if (v42 < (unint64_t)HIDWORD(v42)) {
      goto LABEL_19;
    }
    goto LABEL_24;
  }
  if (v23 == 0x8000000000000000) {
    uint64_t v32 = "failed: cannot apply pattern for tile operations along a dynamic dimension of the input";
  }
  else {
    uint64_t v32 = "failed: multipliers need to be applied to a dimension size 1";
  }
  v38[0] = v32;
  __int16 v39 = 259;
  uint64_t v33 = v37;
  uint64_t Input = v38;
  uint64_t v28 = a3[2];
  if (v28)
  {
    if (mlir::RewriterBase::Listener::classof(v28)) {
      uint64_t v28 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v28 + 64))(v28, *(void *)(v33 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TileOp &>(mlir::mps::TileOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &Input);
    }
    else {
      uint64_t v28 = 0;
    }
  }
LABEL_32:
  if (v41 != v43) {
    free(v41);
  }
  if (v44 != v46) {
    free(v44);
  }
  return v28;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ConstantOp,llvm::SmallVector<long long,4u> &>(mlir::Builder *a1, uint64_t a2, uint64_t a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.constant", (const unsigned __int8 *)0xC, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"mps.constant";
    v15[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ConstantOp::build(a1, (uint64_t)v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id) {
    unint64_t v10 = v9;
  }
  else {
    unint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TileOp &>(mlir::mps::TileOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

void mlir::mps::anonymous namespace'::CanonicalizeTensorFromElements::~CanonicalizeTensorFromElements(mlir::mps::_anonymous_namespace_::CanonicalizeTensorFromElements *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::FromElementsOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::FromElementsOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::FromElementsOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeTensorFromElements::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_UNKNOWN **)(*(void *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::tensor::FromElementsOp,void>::id) {
    return 0;
  }
  if ((*(unsigned char *)(a2 + 46) & 0x80) == 0) {
    return 0;
  }
  if (*(_DWORD *)(a2 + 68) != 1) {
    return 0;
  }
  unint64_t v17 = *(void *)(*(void *)(a2 + 72) + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v17);
  if (!DefiningOp
    || *(_UNKNOWN **)(*(void *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::tensor::ExtractOp,void>::id
    || (*(unsigned char *)(DefiningOp + 46) & 0x80) == 0
    || *(_DWORD *)(DefiningOp + 68) != 1)
  {
    return 0;
  }
  uint64_t v6 = *(void *)(*(void *)(DefiningOp + 72) + 24);
  unint64_t v7 = *(void *)(v6 + 8) & 0xFFFFFFFFFFFFFFF8;
  if (*(_UNKNOWN **)(*(void *)v7 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    unint64_t v7 = 0;
  }
  unint64_t v17 = v7;
  if (!v7) {
    return 0;
  }
  uint64_t Value = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v17);
  if (mlir::ShapedType::getNumElements(Value, v9) != 1) {
    return 0;
  }
  uint64_t v10 = *(void *)(a2 + 24);
  uint64_t v11 = 1;
  LODWORD(v15) = 1;
  uint64_t v12 = mlir::OpBuilder::create<mlir::mps::ConstantOp,int>((mlir::mps::ConstantOp *)(a3 + 8), v10, (unsigned int *)&v15);
  uint64_t v15 = v6;
  uint64_t v16 = (uint64_t)v12 - 16;
  unint64_t v13 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,mlir::Value&>((mlir::UnitAttr **)(a3 + 8), *(void *)(a2 + 24), &v15, &v16);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, a2, v13);
  return v11;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,mlir::Value&>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reshape", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.reshape";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ReshapeOp::build(a1, (uint64_t)v19, *a3, *a4, 0);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *mlir::mps::anonymous namespace'::FuseBinaryWithConstants<mlir::mps::AddOp,true>::~FuseBinaryWithConstants(void *a1)
{
  int v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::mps::anonymous namespace'::FuseBinaryWithConstants<mlir::mps::AddOp,true>::~FuseBinaryWithConstants(void *__p)
{
  int v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::mps::anonymous namespace'::FuseBinaryWithConstants<mlir::mps::AddOp,true>::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::Float32Type **a3)
{
  v31[1] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 24);
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  v25[0] = &v27;
  v25[1] = (uint64_t *)&v28;
  uint64_t v26 = 0;
  if (*(_UNKNOWN **)(*(void *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id
    || (*(unsigned char *)(a2 + 46) & 0x80) == 0
    || *(_DWORD *)(a2 + 68) != 2)
  {
    return 0;
  }
  int v7 = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AddOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(a2, 0, v25);
  uint64_t v29 = *(void **)(*(void *)(a2 + 72) + 56);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v29);
  if (!result) {
    return result;
  }
  uint64_t v9 = result;
  int v10 = *(_UNKNOWN **)(*(void *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      ? v7
      : 0;
  if (v10 != 1) {
    return 0;
  }
  uint64_t v29 = v28;
  uint64_t Value = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v29);
  uint64_t v13 = v12;
  v22[0] = v9;
  uint64_t v14 = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)v22);
    return 0;
  if (!*(unsigned char *)(a1 + 96))
  {
    uint64_t v24 = v26;
    __int16 v18 = *(void **)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v24);
    if (!v18 || *v18)
    {
      uint64_t v23 = v9;
      uint64_t v29 = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v23);
      uint64_t v30 = v19;
      if (mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v29))
      {
        uint64_t v21 = v28;
        v22[0] = (uint64_t)mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v21);
        v22[1] = v20;
        if ((mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v22) & 1) == 0) {
          return 0;
        }
      }
    }
  }
  v22[0] = (uint64_t)v28;
  uint64_t v24 = v9;
  uint64_t v29 = v31;
  uint64_t v30 = 0x100000000;
  mlir::OpBuilder::createOrFold<mlir::mps::AddOp,mlir::mps::ConstantOp,mlir::mps::ConstantOp>((uint64_t)(a3 + 1), (uint64_t)&v29, v3, v22, &v24);
  __int16 v16 = *(void **)v29;
  if (v29 != v31) {
    free(v29);
  }
  uint64_t v29 = v16;
  v22[0] = v27;
  unint64_t v17 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(a3 + 1, *(void *)(a2 + 24), v22, (uint64_t *)&v29);
  (*((void (**)(mlir::Float32Type **, uint64_t, mlir::GenericProgramPoint *))*a3 + 4))(a3, a2, v17);
  return 1;
}

uint64_t mlir::mps::anonymous namespace'::isBroadcastOnSameAxis(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = a1;
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if (mlir::ElementsAttr::getNumElements(a1, a2) == 1 || mlir::ElementsAttr::getNumElements(a3, a4) == 1) {
    return 1;
  }
  uint64_t v32 = &v34;
  uint64_t v34 = v7;
  uint64_t v35 = a2;
  uint64_t v36 = a3;
  uint64_t v37 = a4;
  uint64_t v33 = 0x200000002;
  uint64_t ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v34);
  uint64_t v31 = v10;
  uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
  if (v12 >= 1)
  {
    uint64_t v13 = (uint64_t *)ArgAttrsAttr;
    uint64_t v14 = -v12;
    do
    {
      uint64_t v15 = *v13;
      uint64_t NumElements = mlir::ElementsAttr::getNumElements(v34, v35);
      uint64_t v17 = *v13++;
      uint64_t v7 = v17;
      if (v15 != NumElements && v7 != 1) {
        goto LABEL_28;
      }
      if (v7 == mlir::ElementsAttr::getNumElements(v34, v35)) {
        a3 = v14;
      }
      BOOL v19 = __CFADD__(v14++, 1);
    }
    while (!v19);
  }
  uint64_t ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36);
  uint64_t v31 = v20;
  uint64_t v21 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
  if (v22 >= 1)
  {
    uint64_t v23 = (uint64_t *)v21;
    uint64_t v24 = -v22;
    while (1)
    {
      uint64_t v25 = *v23;
      uint64_t v26 = mlir::ElementsAttr::getNumElements(v36, v37);
      uint64_t v28 = *v23++;
      uint64_t v27 = v28;
      if (v25 != v26 && v27 != 1) {
        break;
      }
      if (v27 == mlir::ElementsAttr::getNumElements(v36, v37)) {
        uint64_t v7 = v24;
      }
      BOOL v19 = __CFADD__(v24++, 1);
      if (v19) {
        goto LABEL_29;
      }
    }
LABEL_28:
    BOOL v8 = 0;
    goto LABEL_30;
  }
LABEL_29:
  BOOL v8 = a3 == v7;
LABEL_30:
  if (v32 != &v34) {
    free(v32);
  }
  return v8;
}

uint64_t mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AddOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(uint64_t a1, unsigned int a2, uint64_t **a3)
{
  uint64_t v14 = *(void *)(*(void *)(a1 + 72) + 32 * a2 + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v14);
  uint64_t v6 = DefiningOp;
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(void *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id
      || (*(unsigned char *)(DefiningOp + 46) & 0x80) == 0
      || *(_DWORD *)(DefiningOp + 68) != 2)
    {
      goto LABEL_15;
    }
    uint64_t v7 = *(void *)(DefiningOp + 72);
    uint64_t v8 = *(void *)(v7 + 24);
    uint64_t v9 = **a3;
    if (v9)
    {
      BOOL v10 = v9 == v8;
    }
    else
    {
      **a3 = v8;
      uint64_t v7 = *(void *)(DefiningOp + 72);
      BOOL v10 = 1;
    }
    if ((v11 = a3[1], uint64_t v14 = *(void *)(v7 + 56), (v12 = mlir::Value::getDefiningOp((mlir::Value *)&v14)) != 0)
      && *(_UNKNOWN **)(*(void *)(v12 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v11 || *v11 == v12)
      && (*uint64_t v11 = v12, v10))
    {
      a3[2] = (uint64_t *)v6;
      char v5 = 1;
    }
    else
    {
LABEL_15:
      char v5 = 0;
    }
  }
  return (v6 != 0) & v5;
}

void mlir::OpBuilder::createOrFold<mlir::mps::AddOp,mlir::mps::ConstantOp,mlir::mps::ConstantOp>(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5)
{
  v25[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a3;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, Context);
  if (!v12)
  {
    __int16 v24 = 1283;
    v23[2] = (uint64_t)"mps.add";
    v23[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a3, v11);
  mlir::mps::ATan2Op::build((mlir::Float32Type **)a1, (uint64_t)v25, *a4 - 16, *a5 - 16);
  uint64_t v14 = (mlir::GenericProgramPoint *)mlir::Operation::create((mlir::Operation *)v25, v13);
  uint64_t v15 = *(void *)(a1 + 16);
  if (v15)
  {
    __int16 v16 = *(uint64_t **)(a1 + 24);
    llvm::ilist_traits<mlir::Operation>::addNodeToList(v15 + 32, (uint64_t)v14);
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
    uint64_t v17 = *v16;
    *__int16 v18 = *v16;
    v18[1] = (uint64_t)v16;
    *(void *)(v17 + 8) = v18;
    uint64_t *v16 = (uint64_t)v18;
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
  }
  if (mlir::OpBuilder::tryFold((void *)a1, (uint64_t)v14, a2))
  {
    mlir::Operation::erase(v14);
  }
  else
  {
    uint64_t v19 = *(void *)(a1 + 8);
    if (v19) {
      (*(void (**)(uint64_t, mlir::GenericProgramPoint *))(*(void *)v19 + 16))(v19, v14);
    }
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
}

void *mlir::mps::anonymous namespace'::FuseBinaryWithConstants<mlir::mps::MultiplyOp,true>::~FuseBinaryWithConstants(void *a1)
{
  int v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::mps::anonymous namespace'::FuseBinaryWithConstants<mlir::mps::MultiplyOp,true>::~FuseBinaryWithConstants(void *__p)
{
  int v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::mps::anonymous namespace'::FuseBinaryWithConstants<mlir::mps::MultiplyOp,true>::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::Float32Type **a3)
{
  v31[1] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 24);
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  v25[0] = &v27;
  v25[1] = (uint64_t *)&v28;
  uint64_t v26 = 0;
  if (*(_UNKNOWN **)(*(void *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id
    || (*(unsigned char *)(a2 + 46) & 0x80) == 0
    || *(_DWORD *)(a2 + 68) != 2)
  {
    return 0;
  }
  int v7 = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(a2, 0, v25);
  uint64_t v29 = *(void **)(*(void *)(a2 + 72) + 56);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v29);
  if (!result) {
    return result;
  }
  uint64_t v9 = result;
  int v10 = *(_UNKNOWN **)(*(void *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      ? v7
      : 0;
  if (v10 != 1) {
    return 0;
  }
  uint64_t v29 = v28;
  uint64_t Value = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v29);
  uint64_t v13 = v12;
  v22[0] = v9;
  uint64_t v14 = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)v22);
    return 0;
  if (!*(unsigned char *)(a1 + 96))
  {
    uint64_t v24 = v26;
    __int16 v18 = *(void **)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v24);
    if (!v18 || *v18)
    {
      uint64_t v23 = v9;
      uint64_t v29 = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v23);
      uint64_t v30 = v19;
      if (mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v29))
      {
        uint64_t v21 = v28;
        v22[0] = (uint64_t)mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v21);
        v22[1] = v20;
        if ((mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v22) & 1) == 0) {
          return 0;
        }
      }
    }
  }
  v22[0] = (uint64_t)v28;
  uint64_t v24 = v9;
  uint64_t v29 = v31;
  uint64_t v30 = 0x100000000;
  mlir::OpBuilder::createOrFold<mlir::mps::MultiplyOp,mlir::mps::ConstantOp,mlir::mps::ConstantOp>((uint64_t)(a3 + 1), (uint64_t)&v29, v3, v22, &v24);
  __int16 v16 = *(void **)v29;
  if (v29 != v31) {
    free(v29);
  }
  uint64_t v29 = v16;
  v22[0] = v27;
  uint64_t v17 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>(a3 + 1, *(void *)(a2 + 24), v22, (uint64_t *)&v29);
  (*((void (**)(mlir::Float32Type **, uint64_t, mlir::GenericProgramPoint *))*a3 + 4))(a3, a2, v17);
  return 1;
}

uint64_t mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(uint64_t a1, unsigned int a2, uint64_t **a3)
{
  uint64_t v14 = *(void *)(*(void *)(a1 + 72) + 32 * a2 + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v14);
  uint64_t v6 = DefiningOp;
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(void *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id
      || (*(unsigned char *)(DefiningOp + 46) & 0x80) == 0
      || *(_DWORD *)(DefiningOp + 68) != 2)
    {
      goto LABEL_15;
    }
    uint64_t v7 = *(void *)(DefiningOp + 72);
    uint64_t v8 = *(void *)(v7 + 24);
    uint64_t v9 = **a3;
    if (v9)
    {
      BOOL v10 = v9 == v8;
    }
    else
    {
      **a3 = v8;
      uint64_t v7 = *(void *)(DefiningOp + 72);
      BOOL v10 = 1;
    }
    if ((v11 = a3[1], uint64_t v14 = *(void *)(v7 + 56), (v12 = mlir::Value::getDefiningOp((mlir::Value *)&v14)) != 0)
      && *(_UNKNOWN **)(*(void *)(v12 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v11 || *v11 == v12)
      && (*uint64_t v11 = v12, v10))
    {
      a3[2] = (uint64_t *)v6;
      char v5 = 1;
    }
    else
    {
LABEL_15:
      char v5 = 0;
    }
  }
  return (v6 != 0) & v5;
}

void mlir::OpBuilder::createOrFold<mlir::mps::MultiplyOp,mlir::mps::ConstantOp,mlir::mps::ConstantOp>(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5)
{
  v25[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a3;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, Context);
  if (!v12)
  {
    __int16 v24 = 1283;
    v23[2] = (uint64_t)"mps.multiply";
    v23[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a3, v11);
  mlir::mps::ATan2Op::build((mlir::Float32Type **)a1, (uint64_t)v25, *a4 - 16, *a5 - 16);
  uint64_t v14 = (mlir::GenericProgramPoint *)mlir::Operation::create((mlir::Operation *)v25, v13);
  uint64_t v15 = *(void *)(a1 + 16);
  if (v15)
  {
    __int16 v16 = *(uint64_t **)(a1 + 24);
    llvm::ilist_traits<mlir::Operation>::addNodeToList(v15 + 32, (uint64_t)v14);
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
    uint64_t v17 = *v16;
    *__int16 v18 = *v16;
    v18[1] = (uint64_t)v16;
    *(void *)(v17 + 8) = v18;
    uint64_t *v16 = (uint64_t)v18;
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
  }
  if (mlir::OpBuilder::tryFold((void *)a1, (uint64_t)v14, a2))
  {
    mlir::Operation::erase(v14);
  }
  else
  {
    uint64_t v19 = *(void *)(a1 + 8);
    if (v19) {
      (*(void (**)(uint64_t, mlir::GenericProgramPoint *))(*(void *)v19 + 16))(v19, v14);
    }
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
}

void mlir::mps::anonymous namespace'::CanonicalizeSparseMatMul::~CanonicalizeSparseMatMul(mlir::mps::_anonymous_namespace_::CanonicalizeSparseMatMul *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeSparseMatMul::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v91[1] = *MEMORY[0x1E4F143B8];
  uint64_t v76 = a2;
  uint64_t Input = (char *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v76);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Input);
  if (!DefiningOp
    || *(_UNKNOWN **)(*(void *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::MaterializeSparseTensorOp,void>::id)
  {
    uint64_t Input = (char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v76);
    uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&Input);
    if (!result) {
      return result;
    }
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::MaterializeSparseTensorOp,void>::id) {
      return 0;
    }
    uint64_t v88 = v76;
    uint64_t Input = (char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v88);
    uint64_t v8 = mlir::Value::getDefiningOp((mlir::Value *)&Input);
    if (v8)
    {
      if (*(_UNKNOWN **)(*(void *)(v8 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MaterializeSparseTensorOp,void>::id) {
        uint64_t v9 = v8;
      }
      else {
        uint64_t v9 = 0;
      }
    }
    else
    {
      uint64_t v9 = 0;
    }
    uint64_t v87 = v9;
    uint64_t v86 = *(void *)(mlir::memref::LoadOp::getIndices((mlir::memref::LoadOp *)&v87) + 24);
    uint64_t v85 = *(void *)(mlir::memref::LoadOp::getIndices((mlir::memref::LoadOp *)&v87) + 56);
    uint64_t v43 = (mlir::GenericProgramPoint *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v87) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v43) {
      goto LABEL_47;
    }
    uint64_t v44 = *(void *)v43;
    unint64_t v45 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v46 = *(unsigned int *)(v44 + 16);
    if (!v46) {
      goto LABEL_47;
    }
    uint64_t v47 = *(void **)(v44 + 8);
    uint64_t v48 = &v47[2 * v46];
    do
    {
      unint64_t v49 = v46 >> 1;
      uint64_t v50 = &v47[2 * (v46 >> 1)];
      unint64_t v52 = *v50;
      uint64_t v51 = v50 + 2;
      v46 += ~(v46 >> 1);
      if (v52 < v45) {
        uint64_t v47 = v51;
      }
      else {
        unint64_t v46 = v49;
      }
    }
    while (v46);
    if (v47 != v48 && *v47 == v45) {
      uint64_t v53 = v47[1];
    }
    else {
LABEL_47:
    }
      uint64_t v53 = 0;
    uint64_t v83 = v43;
    uint64_t v84 = v53;
    uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v83);
    uint64_t v56 = v54;
    uint64_t Input = (char *)v91;
    uint64_t v90 = 0x200000000;
    unint64_t v57 = 8 * v54;
    if ((unint64_t)(8 * v54) < 0x11)
    {
      uint64_t v58 = 0;
      int v59 = 0;
      if (!v54)
      {
LABEL_59:
        LODWORD(v90) = v59 + (v57 >> 3);
        uint64_t v83 = mlir::OpBuilder::create<mlir::mps::ConstantOp,llvm::SmallVector<int,2u> &>((mlir::Builder *)(a3 + 8), *(void *)(v88 + 24), (uint64_t)&Input);
        uint64_t v74 = *(void *)(v88 + 24);
        uint64_t Filter = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v87);
        uint64_t v80 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v88);
        BOOL TransposeRhs = !mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v88);
        BOOL v78 = !mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v88);
        unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v87);
        uint64_t v82 = (uint64_t)mlir::OpBuilder::create<mlir::mpsx::SparseDenseMatMulOp,mlir::Value,mlir::Value&,mlir::Value&,mlir::mps::ConstantOp &,mlir::Value,BOOL,BOOL,mlir::mps::SparseTensorStorage>((mlir::BoolAttr **)(a3 + 8), v74, &Filter, &v86, &v85, &v83, &v80, (unsigned __int8 *)&TransposeRhs, (unsigned __int8 *)&v78, &StorageType)- 16;
        uint64_t v75 = *(void *)(v88 + 24);
        LODWORD(v80) = -1;
        unsigned int StorageType = -2;
        uint64_t Filter = (uint64_t)mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int,int>((mlir::mps::ConstantOp *)(a3 + 8), v75, &v82, (unsigned int *)&v80, &StorageType)- 16;
        (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(void *)a3 + 24))(a3, v88, &Filter, 1);
        goto LABEL_60;
      }
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&Input, v91, (8 * v54) >> 3, 4);
      uint64_t v58 = v90;
      int v59 = v90;
      if (!v56) {
        goto LABEL_59;
      }
    }
    uint64_t v60 = (int32x4_t *)&Input[4 * v58];
    unint64_t v61 = (v56 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v61 >= 7)
    {
      unint64_t v64 = v61 + 1;
      uint64_t v65 = (v61 + 1) & 0x3FFFFFFFFFFFFFF8;
      uint64_t v62 = &v60->i8[4 * v65];
      uint64_t v63 = (uint64_t *)(ArgAttrsAttr + 8 * v65);
      uint64_t v66 = (int32x4_t *)(ArgAttrsAttr + 32);
      uint64_t v67 = v60 + 1;
      uint64_t v68 = v65;
      do
      {
        int32x4_t v70 = v66[-2];
        int32x4_t v69 = v66[-1];
        int32x4_t v72 = *v66;
        int32x4_t v71 = v66[1];
        v66 += 4;
        v67[-1] = vuzp1q_s32(v70, v69);
        *uint64_t v67 = vuzp1q_s32(v72, v71);
        v67 += 2;
        v68 -= 8;
      }
      while (v68);
      if (v64 == v65) {
        goto LABEL_58;
      }
    }
    else
    {
      uint64_t v62 = (char *)v60;
      uint64_t v63 = (uint64_t *)ArgAttrsAttr;
    }
    do
    {
      uint64_t v73 = *v63++;
      *(_DWORD *)uint64_t v62 = v73;
      v62 += 4;
    }
    while (v63 != (uint64_t *)(ArgAttrsAttr + v57));
LABEL_58:
    int v59 = v90;
    goto LABEL_59;
  }
  uint64_t v88 = v76;
  uint64_t Input = (char *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v88);
  uint64_t v6 = mlir::Value::getDefiningOp((mlir::Value *)&Input);
  if (v6)
  {
    if (*(_UNKNOWN **)(*(void *)(v6 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MaterializeSparseTensorOp,void>::id) {
      uint64_t v7 = v6;
    }
    else {
      uint64_t v7 = 0;
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v87 = v7;
  uint64_t v86 = *(void *)(mlir::memref::LoadOp::getIndices((mlir::memref::LoadOp *)&v87) + 24);
  uint64_t v85 = *(void *)(mlir::memref::LoadOp::getIndices((mlir::memref::LoadOp *)&v87) + 56);
  BOOL v10 = (mlir::GenericProgramPoint *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v87) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_24;
  }
  uint64_t v11 = *(void *)v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_24;
  }
  uint64_t v14 = *(void **)(v11 + 8);
  uint64_t v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    uint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    __int16 v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      uint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_24:
  }
    uint64_t v20 = 0;
  uint64_t v83 = v10;
  uint64_t v84 = v20;
  uint64_t v22 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v83);
  uint64_t v23 = v21;
  uint64_t Input = (char *)v91;
  uint64_t v90 = 0x200000000;
  unint64_t v24 = 8 * v21;
  if ((unint64_t)(8 * v21) >= 0x11)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&Input, v91, (8 * v21) >> 3, 4);
    uint64_t v25 = v90;
    int v26 = v90;
    if (!v23) {
      goto LABEL_36;
    }
LABEL_29:
    uint64_t v27 = (int32x4_t *)&Input[4 * v25];
    unint64_t v28 = (v23 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v28 >= 7)
    {
      unint64_t v31 = v28 + 1;
      uint64_t v32 = (v28 + 1) & 0x3FFFFFFFFFFFFFF8;
      uint64_t v29 = &v27->i8[4 * v32];
      uint64_t v30 = (uint64_t *)(v22 + 8 * v32);
      uint64_t v33 = (int32x4_t *)(v22 + 32);
      uint64_t v34 = v27 + 1;
      uint64_t v35 = v32;
      do
      {
        int32x4_t v37 = v33[-2];
        int32x4_t v36 = v33[-1];
        int32x4_t v39 = *v33;
        int32x4_t v38 = v33[1];
        v33 += 4;
        v34[-1] = vuzp1q_s32(v37, v36);
        int32x4_t *v34 = vuzp1q_s32(v39, v38);
        v34 += 2;
        v35 -= 8;
      }
      while (v35);
      if (v31 == v32) {
        goto LABEL_35;
      }
    }
    else
    {
      uint64_t v29 = (char *)v27;
      uint64_t v30 = (uint64_t *)v22;
    }
    do
    {
      uint64_t v40 = *v30++;
      *(_DWORD *)uint64_t v29 = v40;
      v29 += 4;
    }
    while (v30 != (uint64_t *)(v22 + v24));
LABEL_35:
    int v26 = v90;
    goto LABEL_36;
  }
  uint64_t v25 = 0;
  int v26 = 0;
  if (v21) {
    goto LABEL_29;
  }
LABEL_36:
  LODWORD(v90) = v26 + (v24 >> 3);
  uint64_t v83 = mlir::OpBuilder::create<mlir::mps::ConstantOp,llvm::SmallVector<int,2u> &>((mlir::Builder *)(a3 + 8), *(void *)(v88 + 24), (uint64_t)&Input);
  uint64_t v41 = v88;
  uint64_t v82 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v87);
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v88);
  LOBYTE(StorageType) = mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v88);
  BOOL TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v88);
  LODWORD(v80) = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v87);
  uint64_t v42 = mlir::OpBuilder::create<mlir::mpsx::SparseDenseMatMulOp,mlir::Value,mlir::Value&,mlir::Value&,mlir::mps::ConstantOp &,mlir::Value,BOOL,BOOL,mlir::mps::SparseTensorStorage>((mlir::BoolAttr **)(a3 + 8), *(void *)(v41 + 24), &v82, &v86, &v85, &v83, &Filter, (unsigned __int8 *)&StorageType, (unsigned __int8 *)&TransposeRhs, (unsigned int *)&v80);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, v41, v42);
LABEL_60:
  if (Input != (char *)v91) {
    free(Input);
  }
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ConstantOp,llvm::SmallVector<int,2u> &>(mlir::Builder *a1, uint64_t a2, uint64_t a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.constant", (const unsigned __int8 *)0xC, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"mps.constant";
    v15[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ConstantOp::build(a1, (uint64_t)v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id) {
    BOOL v10 = v9;
  }
  else {
    BOOL v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mpsx::SparseDenseMatMulOp,mlir::Value,mlir::Value&,mlir::Value&,mlir::mps::ConstantOp &,mlir::Value,BOOL,BOOL,mlir::mps::SparseTensorStorage>(mlir::BoolAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, void *a6, uint64_t *a7, unsigned __int8 *a8, unsigned __int8 *a9, unsigned int *a10)
{
  v29[38] = *MEMORY[0x1E4F143B8];
  uint64_t v24 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  uint64_t v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.sparse_dense_matmul", (const unsigned __int8 *)0x18, Context);
  if (!v20)
  {
    __int16 v28 = 1283;
    v27[2] = (uint64_t)"mpsx.sparse_dense_matmul";
    v27[3] = 24;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v29, a2, v19);
  mlir::mpsx::SparseDenseMatMulOp::build(a1, (uint64_t)v29, *a3, *a4, *a5, *a6 - 16, *a7, (mlir::MLIRContext *)*a8, *a9, *a10);
  uint64_t v21 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v29);
  if (*(_UNKNOWN **)(*((void *)v21 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::SparseDenseMatMulOp,void>::id) {
    uint64_t v22 = v21;
  }
  else {
    uint64_t v22 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  return v22;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int,int>(mlir::mps::ConstantOp *a1, uint64_t a2, uint64_t *a3, unsigned int *a4, unsigned int *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.transpose", (const unsigned __int8 *)0xD, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.transpose";
    void v19[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::TransposeOp::build(a1, v21, *a3, *a4, *a5);
  unint64_t v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id) {
    __int16 v14 = v13;
  }
  else {
    __int16 v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void mlir::mps::anonymous namespace'::CanonicalizeSDPA::~CanonicalizeSDPA(mlir::mps::_anonymous_namespace_::CanonicalizeSDPA *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeSDPA::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::UnknownLoc **a3)
{
  uint64_t v89 = *MEMORY[0x1E4F143B8];
  uint64_t v81 = 0;
  uint64_t v82 = a2;
  uint64_t v79 = 0;
  uint64_t v80 = 0;
  uint64_t v77 = 0;
  uint64_t v78 = 0;
  uint64_t v75 = 0;
  uint64_t v76 = 0;
  v74[0] = &v81;
  v74[1] = &v80;
  v71[0] = v74;
  v71[1] = &v77;
  char v72 = 0;
  char v73 = 0;
  v68[0] = v71;
  v68[1] = &v79;
  char v69 = 0;
  char v70 = 0;
  v66[0] = v68;
  v66[1] = &v76;
  uint64_t v67 = 0;
  v64[0] = (uint64_t)v66;
  v64[1] = (uint64_t)&v78;
  uint64_t v65 = 0;
  v84[0] = a2;
  if (*(_UNKNOWN **)(*(void *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id) {
    return 0;
  }
  if ((*(unsigned char *)(a2 + 46) & 0x80) == 0) {
    return 0;
  }
  if (*(_DWORD *)(a2 + 68) != 2) {
    return 0;
  }
  LOBYTE(v62[0]) = 1;
  uint64_t v86 = (char *)v62;
  uint64_t v87 = (uint64_t)v84;
  mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SoftmaxOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SoftmaxOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SoftmaxOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(v64, (uint64_t)&v86);
  if (!LOBYTE(v62[0])) {
    return 0;
  }
  uint64_t v65 = v84[0];
  uint64_t v63 = v76;
  uint64_t Value = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v63);
  uint64_t v6 = v5;
  if (mlir::ElementsAttr::getNumElements((uint64_t)Value, v5) != 1)
  {
    uint64_t v86 = "failed: softmax must be applied to a single axis";
    v88[8] = 259;
    uint64_t v21 = v82;
    v84[0] = &v86;
    uint64_t v22 = (uint64_t)a3[2];
    if (!v22) {
      return v22;
    }
    if (mlir::RewriterBase::Listener::classof(v22)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v22 + 64))(v22, *(void *)(v21 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MatMulOp &>(mlir::mps::MatMulOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v84);
    }
    return 0;
  }
  uint64_t v86 = v67;
  uint64_t v7 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v86) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v7) {
    goto LABEL_15;
  }
  uint64_t v8 = *v7;
  unint64_t v9 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v10 = *(unsigned int *)(v8 + 16);
  if (!v10) {
    goto LABEL_15;
  }
  uint64_t v11 = *(void **)(v8 + 8);
  char v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    __int16 v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    uint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      uint64_t v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_15:
  }
    uint64_t v17 = 0;
  v62[0] = v7;
  v62[1] = v17;
  int ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v62);
  if (ArgOperands)
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v62);
    uint64_t v20 = v19;
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v86 = (char *)v88;
  uint64_t v87 = 0x400000000;
  mlir::getIntValues<long long>((uint64_t)Value, v6, (uint64_t)&v86, 1);
  if (v87)
  {
    uint64_t v24 = v86;
    uint64_t v25 = 8 * v87;
    while (1)
    {
      int v26 = *(void *)v24 == -1 ? 1 : ArgOperands;
      if (v26 != 1 || ArgOperands && (*(void *)v24 + v20) % v20 != v20 - 1) {
        break;
      }
      v24 += 8;
      v25 -= 8;
      if (!v25) {
        goto LABEL_34;
      }
    }
    uint64_t v27 = "failed: softmax axis should be -1 or equal to inputRank - 1";
LABEL_63:
    v84[0] = v27;
    __int16 v85 = 259;
    uint64_t v49 = v82;
    v61[0] = (uint64_t)v84;
    uint64_t v22 = (uint64_t)a3[2];
    if (!v22) {
      goto LABEL_78;
    }
    if (mlir::RewriterBase::Listener::classof(v22))
    {
      uint64_t v48 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(void *)v22 + 64))(v22, *(void *)(v49 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MatMulOp &>(mlir::mps::MatMulOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v61);
      goto LABEL_66;
    }
    goto LABEL_77;
  }
LABEL_34:
  uint64_t v28 = v77;
  if (!v77) {
    goto LABEL_56;
  }
  v84[0] = v77;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v84);
  if (!DefiningOp
    || (uint64_t v30 = DefiningOp,
        uint64_t v31 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        ((*(uint64_t (**)(void, uint64_t))(**(void **)(v30 + 48) + 32))(*(void *)(v30 + 48), v31) & 1) == 0))
  {
    uint64_t v27 = "failed: the value for scale must be a constant";
    goto LABEL_63;
  }
  uint64_t v32 = (uint64_t *)(*(void *)(v28 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v32) {
    goto LABEL_46;
  }
  uint64_t v33 = *v32;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_46;
  }
  int32x4_t v36 = *(void **)(v33 + 8);
  int32x4_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    int32x4_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    uint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      int32x4_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_46:
  }
    uint64_t v42 = 0;
  v61[0] = (uint64_t)v32;
  v61[1] = v42;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v61)
    || (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v61), v43 >= 2))
  {
    uint64_t v44 = "failed: scale should have rank 0 or 1";
LABEL_61:
    uint64_t v48 = mlir::RewriterBase::notifyMatchFailure<mlir::mps::MatMulOp &>((uint64_t)a3, &v82, v44);
LABEL_66:
    uint64_t v22 = v48;
    goto LABEL_78;
  }
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v61);
  if (v46)
  {
    uint64_t v47 = 8 * v46;
    while (*ArgAttrsAttr == 1)
    {
      ++ArgAttrsAttr;
      v47 -= 8;
      if (!v47) {
        goto LABEL_56;
      }
    }
    __int16 v85 = 259;
    uint64_t v55 = v82;
    uint64_t v83 = v84;
    v84[0] = "failed: scale should be scalar";
    uint64_t v22 = (uint64_t)a3[2];
    if (!v22) {
      goto LABEL_78;
    }
    if (mlir::RewriterBase::Listener::classof(v22))
    {
      uint64_t v48 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v22 + 64))(v22, *(void *)(v55 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MatMulOp &>(mlir::mps::MatMulOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v83);
      goto LABEL_66;
    }
  }
  else
  {
LABEL_56:
    uint64_t v83 = v75;
    if (mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v83)
      || !mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v83))
    {
      uint64_t v27 = "failed: Transpose of LHS and RHS when matrix multiplying query and key should be false and true respectively";
      goto LABEL_63;
    }
    v84[0] = v65;
    if (mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)v84)
      || mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)v84))
    {
      uint64_t v44 = "failed: Transpose of LHS and RHS when matrix multiplying softmax and value should be false and false respectively";
      goto LABEL_61;
    }
    v61[0] = v77;
    if (!v77)
    {
      uint64_t v50 = *(void *)(v82 + 24);
      LODWORD(ElementTypeOrSelf) = 1;
      v61[0] = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,int>((mlir::mps::ConstantOp *)(a3 + 1), v50, (unsigned int *)&ElementTypeOrSelf)- 16;
      uint64_t v51 = *(void *)(v82 + 24);
      uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v81);
      v61[0] = (uint64_t)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a3 + 1, v51, v61, &ElementTypeOrSelf)- 16;
    }
    uint64_t ElementTypeOrSelf = v79;
    if (!v79)
    {
      uint64_t v52 = *(void *)(v82 + 24);
      LODWORD(v59) = 0;
      uint64_t ElementTypeOrSelf = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,int>((mlir::mps::ConstantOp *)(a3 + 1), v52, (unsigned int *)&v59)- 16;
      uint64_t v53 = *(void *)(v82 + 24);
      int v59 = (uint64_t *)mlir::getElementTypeOrSelf(v81);
      uint64_t ElementTypeOrSelf = (uint64_t)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a3 + 1, v53, &ElementTypeOrSelf, (uint64_t *)&v59)- 16;
    }
    uint64_t v54 = *(void *)(v82 + 24);
    uint64_t v57 = v80;
    uint64_t v58 = v81;
    uint64_t v56 = v78;
    int v59 = (uint64_t *)mlir::OpBuilder::create<mlir::mpsx::ScaledDotProductAttentionOp,mlir::Value,mlir::Value,mlir::Value,mlir::Value&,mlir::Value&>(a3 + 1, v54, &v58, &v57, &v56, &ElementTypeOrSelf, v61);
    if (mlir::mpsx::ScaledDotProductAttentionOp::verify(&v59))
    {
      (*((void (**)(mlir::UnknownLoc **, uint64_t, uint64_t *))*a3 + 4))(a3, v82, v59);
      uint64_t v22 = 1;
      goto LABEL_78;
    }
  }
LABEL_77:
  uint64_t v22 = 0;
LABEL_78:
  if (v86 != (char *)v88) {
    free(v86);
  }
  return v22;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mps::MatMulOp &>(uint64_t a1, uint64_t *a2, unsigned char *a3)
{
  char v3 = 1;
  char v9 = 1;
  if (*a3)
  {
    uint64_t v7 = a3;
    char v3 = 3;
  }
  char v8 = v3;
  uint64_t v4 = *a2;
  unint64_t v10 = &v7;
  uint64_t v5 = *(void *)(a1 + 16);
  if (!v5) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16));
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v5 + 64))(v5, *(void *)(v4 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MatMulOp &>(mlir::mps::MatMulOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v10);
  }
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mpsx::ScaledDotProductAttentionOp,mlir::Value,mlir::Value,mlir::Value,mlir::Value&,mlir::Value&>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  v25[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.sdpa", (const unsigned __int8 *)9, Context);
  if (!v16)
  {
    __int16 v24 = 1283;
    v23[2] = (uint64_t)"mpsx.sdpa";
    v23[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a2, v15);
  mlir::mpsx::ScaledDotProductAttentionOp::build(a1, (uint64_t)v25, *a3, *a4, *a5, *a6, *a7);
  uint64_t v17 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v25);
  if (*(_UNKNOWN **)(*((void *)v17 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::ScaledDotProductAttentionOp,void>::id) {
    __int16 v18 = v17;
  }
  else {
    __int16 v18 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
  return v18;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SoftmaxOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SoftmaxOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SoftmaxOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  v14[0] = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 24);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)v14);
  uint64_t v7 = result;
  if (result)
  {
    uint64_t v16 = result;
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SoftmaxOp,void>::id
      && (*(unsigned char *)(result + 46) & 0x80) != 0
      && *(_DWORD *)(result + 68) == 2)
    {
      unsigned __int8 v15 = 1;
      v14[0] = &v15;
      v14[1] = &v16;
      uint64_t result = mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SoftmaxOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> & *)#1},0ul,1ul>(v4, (uint64_t)v14);
      int v8 = v15;
      if (v15) {
        *(void *)(v4 + 16) = v16;
      }
      BOOL v6 = v8 != 0;
    }
    else
    {
      BOOL v6 = 0;
    }
  }
  char v9 = *(BOOL **)a2;
  BOOL v10 = v6 && **(unsigned char **)a2 != 0;
  if (!v7) {
    BOOL v10 = 0;
  }
  *char v9 = v10;
  uint64_t v11 = (void *)a1[1];
  uint64_t v12 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 56);
  if (*v11)
  {
    BOOL v13 = *v11 == v12;
  }
  else
  {
    *uint64_t v11 = v12;
    char v9 = *(BOOL **)a2;
    BOOL v10 = **(unsigned char **)a2 != 0;
    BOOL v13 = 1;
  }
  *char v9 = v13 && v10;
  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SoftmaxOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> & *)#1},0ul,1ul>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(uint64_t ***)a1;
  uint64_t v11 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (DefiningOp) {
    LOBYTE(DefiningOp) = mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(v4, DefiningOp);
  }
  if (**(unsigned char **)a2) {
    char v6 = DefiningOp;
  }
  else {
    char v6 = 0;
  }
  **(unsigned char **)a2 = v6;
  uint64_t v7 = *(uint64_t **)(a1 + 8);
  uint64_t v11 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 56);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (result)
  {
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v7 || *v7 == result))
    {
      *uint64_t v7 = result;
      char v9 = 1;
    }
    else
    {
      char v9 = 0;
    }
  }
  char v10 = v9 & (**(unsigned char **)a2 != 0);
  if (!result) {
    char v10 = 0;
  }
  **(unsigned char **)a2 = v10;
  return result;
}

uint64_t mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(uint64_t **a1, uint64_t a2)
{
  if (*(_UNKNOWN **)(*(void *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id)
  {
    if ((mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match((void **)*a1, a2) & 1) == 0)
    {
      if (*(_DWORD *)(a2 + 36))
      {
        uint64_t v4 = a1[1];
        uint64_t v5 = a2 - 16;
        if (*v4) {
          return *v4 == v5;
        }
        uint64_t *v4 = v5;
        return 1;
      }
      return 0;
    }
    return 1;
  }
  uint64_t v7 = *a1;
  int v8 = a1[1];
  uint64_t v18 = *(void *)(*(void *)(a2 + 72) + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v18);
  if (DefiningOp) {
    LOBYTE(DefiningOp) = mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match((void **)v7, DefiningOp);
  }
  uint64_t v10 = *(void *)(*(void *)(a2 + 72) + 56);
  if (*v8)
  {
    if ((DefiningOp & (*v8 == v10)) != 0) {
      goto LABEL_20;
    }
  }
  else
  {
    *int v8 = v10;
    if (DefiningOp)
    {
LABEL_20:
      if (!*((unsigned char *)a1 + 24)) {
        *((unsigned char *)a1 + 24) = 1;
      }
      a1[2] = (uint64_t *)a2;
      return 1;
    }
  }
  *a1[1] = 0;
  uint64_t v11 = *a1;
  uint64_t v12 = **a1;
  **(void **)uint64_t v12 = 0;
  **(void **)(v12 + 8) = 0;
  *(void *)(v12 + 16) = 0;
  *(void *)v11[1] = 0;
  if (*((unsigned char *)v11 + 24)) {
    *((unsigned char *)v11 + 24) = 0;
  }
  __int16 v14 = *a1;
  BOOL v13 = a1[1];
  uint64_t v15 = *(void *)(a2 + 72);
  uint64_t v16 = *(void *)(v15 + 24);
  if (*v13)
  {
    BOOL v17 = *v13 == v16;
  }
  else
  {
    *BOOL v13 = v16;
    uint64_t v15 = *(void *)(a2 + 72);
    BOOL v17 = 1;
  }
  uint64_t v18 = *(void *)(v15 + 56);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v18);
  if (result)
  {
    if ((v17 & mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match((void **)v14, result)) != 1)return 0; {
    goto LABEL_20;
    }
  }
  return result;
}

uint64_t mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(void **a1, uint64_t a2)
{
  __int16 v22 = (void *)a2;
  char v3 = *(void **)(*(void *)(a2 + 48) + 16);
  if (v3 == &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id)
  {
    int v9 = 1;
    unsigned __int8 v21 = 1;
    int8x16_t v20 = *(int8x16_t *)a1;
    v19.i64[0] = (uint64_t)&v21;
    v19.i64[1] = (uint64_t)&v22;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>((uint64_t ***)&v20, (uint64_t)&v19);
    if (v21) {
      goto LABEL_9;
    }
    unsigned __int8 v21 = 1;
    *a1[1] = 0;
    uint64_t v10 = (uint64_t)*a1;
    *(void *)**a1 = 0;
    **(void **)(v10 + 8) = 0;
    *(void *)(v10 + 16) = 0;
    int8x16_t v19 = vextq_s8(*(int8x16_t *)a1, *(int8x16_t *)a1, 8uLL);
    v18[0] = &v21;
    v18[1] = &v22;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *> &,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *> & *)#2},0ul,1ul>((uint64_t **)&v19, (uint64_t)v18);
    int v9 = v21;
    if (v21)
    {
LABEL_9:
      uint64_t v11 = v22;
      if (!*((unsigned char *)a1 + 24)) {
        *((unsigned char *)a1 + 24) = 1;
      }
      a1[2] = v11;
    }
    return v9 != 0;
  }
  else
  {
    if (v3 != &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id
      || (*(unsigned char *)(a2 + 46) & 0x80) == 0
      || *(_DWORD *)(a2 + 68) != 2)
    {
      goto LABEL_19;
    }
    uint64_t v4 = (uint64_t)*a1;
    uint64_t v5 = (void *)**a1;
    uint64_t v6 = *(void *)(a2 + 72);
    uint64_t v7 = *(void *)(v6 + 24);
    if (*v5)
    {
      BOOL v8 = *v5 == v7;
    }
    else
    {
      *uint64_t v5 = v7;
      uint64_t v6 = *(void *)(a2 + 72);
      BOOL v8 = 1;
    }
    BOOL v13 = *(void **)(v4 + 8);
    uint64_t v14 = *(void *)(v6 + 56);
    if (*v13)
    {
      BOOL v15 = *v13 == v14;
    }
    else
    {
      *BOOL v13 = v14;
      BOOL v15 = 1;
    }
    if (v8 && v15)
    {
      *(void *)(v4 + 16) = a2;
    }
    else
    {
LABEL_19:
      if (!*(_DWORD *)(a2 + 36)) {
        return 0;
      }
      uint64_t v16 = a1[1];
      uint64_t v17 = a2 - 16;
      if (*v16) {
        return *v16 == v17;
      }
      void *v16 = v17;
    }
    return 1;
  }
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v20 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 24);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v20);
  if (result)
  {
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id
      || (*(unsigned char *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 2)
    {
      goto LABEL_14;
    }
    uint64_t v7 = *(void *)(result + 72);
    uint64_t v8 = *(void *)(v7 + 24);
    uint64_t v9 = **v4;
    if (v9)
    {
      BOOL v10 = v9 == v8;
    }
    else
    {
      *uint64_t *v4 = v8;
      uint64_t v7 = *(void *)(result + 72);
      BOOL v10 = 1;
    }
    uint64_t v11 = v4[1];
    uint64_t v12 = *(void *)(v7 + 56);
    if (*v11)
    {
      BOOL v13 = *v11 == v12;
    }
    else
    {
      *uint64_t v11 = v12;
      BOOL v13 = 1;
    }
    if (v10 && v13)
    {
      v4[2] = (uint64_t *)result;
      char v6 = 1;
    }
    else
    {
LABEL_14:
      char v6 = 0;
    }
  }
  uint64_t v14 = *(unsigned char **)a2;
  uint64_t v15 = *(void *)(a2 + 8);
  char v16 = v6 & (**(unsigned char **)a2 != 0);
  if (!result) {
    char v16 = 0;
  }
  *uint64_t v14 = v16;
  uint64_t v17 = a1[1];
  uint64_t v18 = *(uint64_t **)(*(void *)(*(void *)v15 + 72) + 56);
  if (*v17)
  {
    BOOL v19 = *v17 == v18;
  }
  else
  {
    *uint64_t v17 = v18;
    uint64_t v14 = *(unsigned char **)a2;
    char v16 = **(unsigned char **)a2 != 0;
    BOOL v19 = 1;
  }
  *uint64_t v14 = v19 & v16;
  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *> &,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *> & *)#2},0ul,1ul>(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(**(void **)(a2 + 8) + 72);
  uint64_t v4 = *(void *)(v3 + 24);
  uint64_t v5 = **a1;
  if (v5)
  {
    BOOL v6 = v5 == v4;
  }
  else
  {
    **a1 = v4;
    uint64_t v3 = *(void *)(**(void **)(a2 + 8) + 72);
    BOOL v6 = 1;
  }
  if (!**(unsigned char **)a2) {
    BOOL v6 = 0;
  }
  **(unsigned char **)a2 = v6;
  uint64_t v7 = (uint64_t **)a1[1];
  uint64_t v18 = *(void *)(v3 + 56);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v18);
  if (result)
  {
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id
      || (*(unsigned char *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 2)
    {
      goto LABEL_19;
    }
    uint64_t v10 = *(void *)(result + 72);
    uint64_t v11 = *(void *)(v10 + 24);
    uint64_t v12 = **v7;
    if (v12)
    {
      BOOL v13 = v12 == v11;
    }
    else
    {
      **uint64_t v7 = v11;
      uint64_t v10 = *(void *)(result + 72);
      BOOL v13 = 1;
    }
    uint64_t v14 = v7[1];
    uint64_t v15 = *(void *)(v10 + 56);
    if (*v14)
    {
      BOOL v16 = *v14 == v15;
    }
    else
    {
      *uint64_t v14 = v15;
      BOOL v16 = 1;
    }
    int v9 = v13 && v16;
    if (v9 == 1) {
      void v7[2] = (uint64_t *)result;
    }
    else {
LABEL_19:
    }
      LOBYTE(v9) = 0;
  }
  char v17 = v9 & (**(unsigned char **)a2 != 0);
  if (!result) {
    char v17 = 0;
  }
  **(unsigned char **)a2 = v17;
  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MatMulOp &>(mlir::mps::MatMulOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

void mlir::mps::anonymous namespace'::CanonicalizeQuantizedMatMulExpandSqueeze::~CanonicalizeQuantizedMatMulExpandSqueeze(mlir::mps::_anonymous_namespace_::CanonicalizeQuantizedMatMulExpandSqueeze *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mpsx::QuantizedMatMulOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mpsx::QuantizedMatMulOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mpsx::QuantizedMatMulOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeQuantizedMatMulExpandSqueeze::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3)
{
  uint64_t v54 = a2;
  uint64_t Input = mlir::mpsx::QuantizedMatMulOp::getInput(&v54);
  uint64_t Weights = mlir::mpsx::QuantizedMatMulOp::getWeights(&v54);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&Input);
  if (result)
  {
    uint64_t v5 = result;
    BOOL v6 = *(void **)(*(void *)(result + 48) + 16);
    BOOL v7 = v6 == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id;
    if (v6 == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id) {
      uint64_t v8 = result;
    }
    else {
      uint64_t v8 = 0;
    }
    uint64_t v51 = v8;
    if (!v7) {
      return 0;
    }
    uint64_t v9 = *((unsigned int *)v54 + 9);
    uint64_t v10 = (char *)v54 - 16;
    if (!v9) {
      uint64_t v10 = 0;
    }
    *(void *)&v58[0] = v10;
    *((void *)&v58[0] + 1) = v9;
    mlir::ResultRange::getUses((uint64_t *)v58, (uint64_t *)v55);
    uint64_t v11 = v57;
    if (v56 == v57) {
      return 0;
    }
    v58[0] = v55[0];
    v58[1] = v55[1];
    uint64_t v59 = v56;
    mlir::ResultRange::UseIterator::operator++((uint64_t *)v58);
    if (v59 != v11) {
      return 0;
    }
    uint64_t v12 = *((unsigned int *)v54 + 9);
    BOOL v13 = (char *)v54 - 16;
    if (!v12) {
      BOOL v13 = 0;
    }
    *(void *)&v58[0] = v13;
    *((void *)&v58[0] + 1) = v12;
    mlir::ResultRange::getUses((uint64_t *)v58, (uint64_t *)v55);
    uint64_t result = 0;
    uint64_t v14 = *(void *)(v56 + 16);
    if (v14)
    {
      if (*(_UNKNOWN **)(*(void *)(v14 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id)
      {
        if (!v16) {
          return 0;
        }
        unint64_t v17 = SingleSqueezeIndex;
        uint64_t v18 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!v18) {
          goto LABEL_26;
        }
        uint64_t v19 = *v18;
        unint64_t v20 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v21 = *(unsigned int *)(v19 + 16);
        if (!v21) {
          goto LABEL_26;
        }
        __int16 v22 = *(void **)(v19 + 8);
        uint64_t v23 = &v22[2 * v21];
        do
        {
          unint64_t v24 = v21 >> 1;
          uint64_t v25 = &v22[2 * (v21 >> 1)];
          unint64_t v27 = *v25;
          int v26 = v25 + 2;
          v21 += ~(v21 >> 1);
          if (v27 < v20) {
            __int16 v22 = v26;
          }
          else {
            unint64_t v21 = v24;
          }
        }
        while (v21);
        if (v22 != v23 && *v22 == v20) {
          uint64_t v28 = v22[1];
        }
        else {
LABEL_26:
        }
          uint64_t v28 = 0;
        *(void *)&v58[0] = v18;
        *((void *)&v58[0] + 1) = v28;
        BOOL TransposeLhs = mlir::mpsx::QuantizedMatMulOp::getTransposeLhs(&v54);
        uint64_t v30 = 1;
        if (TransposeLhs) {
          uint64_t v30 = 2;
        }
        unint64_t v31 = v30 + v17;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v58);
        if (v31 < v32)
        {
          if (v34)
          {
            if (SingleExpandedIndex != v17) {
              return mlir::RewriterBase::notifyMatchFailure<mlir::mpsx::QuantizedMatMulOp &>(a3, (uint64_t *)&v54, "squeezed dimension and expanded dimension did not match");
            }
            *(void *)&v55[0] = mlir::mpsx::QuantizedMatMulOp::getInputScale(&v54);
            InputZeroPoint = (_OWORD *)mlir::mpsx::QuantizedMatMulOp::getInputZeroPoint(&v54);
            InputMiuint64_t n = mlir::mpsx::QuantizedMatMulOp::getInputMin(&v54);
            uint64_t InputQuantParamsAxisAttr = mlir::mpsx::QuantizedMatMulOp::getInputQuantParamsAxisAttr(&v54);
            uint64_t WeightsScale = mlir::mpsx::QuantizedMatMulOp::getWeightsScale(&v54);
            uint64_t WeightsZeroPoint = mlir::mpsx::QuantizedMatMulOp::getWeightsZeroPoint(&v54);
            WeightsMiuint64_t n = mlir::mpsx::QuantizedMatMulOp::getWeightsMin(&v54);
            uint64_t WeightsQuantParamsAxisAttr = mlir::mpsx::QuantizedMatMulOp::getWeightsQuantParamsAxisAttr(&v54);
            unint64_t v35 = v54;
            uint64_t v44 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v51);
            uint64_t WeightsPaletteLut = mlir::mpsx::QuantizedMatMulOp::getWeightsPaletteLut(&v54);
            uint64_t BiquantWeightsScale = mlir::mpsx::QuantizedMatMulOp::getBiquantWeightsScale(&v54);
            uint64_t BiquantWeightsZeroPoint = mlir::mpsx::QuantizedMatMulOp::getBiquantWeightsZeroPoint(&v54);
            uint64_t OutputType = mlir::mpsx::QuantizedMatMulOp::getOutputType(&v54);
            BOOL v39 = mlir::mpsx::QuantizedMatMulOp::getTransposeLhs(&v54);
            BOOL TransposeRhs = mlir::mpsx::QuantizedMatMulOp::getTransposeRhs(&v54);
            mlir::RewriterBase::replaceOpWithNewOp<mlir::mpsx::QuantizedMatMulOp,mlir::Value,mlir::Value&,mlir::Value&,mlir::Value&,mlir::IntegerAttr &,mlir::Value&,mlir::Value&,mlir::Value&,mlir::Value&,mlir::IntegerAttr &,mlir::Value,mlir::detail::TypedValue<mlir::RankedTensorType>,mlir::detail::TypedValue<mlir::RankedTensorType>,mlir::Type,BOOL,BOOL>((mlir::MLIRContext **)a3, (uint64_t)v35, &v44, (uint64_t *)v55, (uint64_t *)&InputZeroPoint, &InputMin, &InputQuantParamsAxisAttr, &Weights, &WeightsScale, &WeightsZeroPoint, &WeightsMin, &WeightsQuantParamsAxisAttr, &WeightsPaletteLut, &BiquantWeightsScale, &BiquantWeightsZeroPoint, &OutputType, (unsigned __int8 *)&v39, (unsigned __int8 *)&TransposeRhs);
            return 1;
          }
          return 0;
        }
        *(void *)&v55[0] = "cannot apply pattern if the squeeze is applied to the last two dimensions";
        LOWORD(v56) = 259;
        int32x4_t v36 = v54;
        InputZeroPoint = v55;
        uint64_t v37 = *(void *)(a3 + 16);
        if (!v37) {
          return 0;
        }
        uint64_t result = mlir::RewriterBase::Listener::classof(v37);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), _OWORD **))(*(void *)v37 + 64))(v37, *((void *)v36 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mpsx::QuantizedMatMulOp &>(mlir::mpsx::QuantizedMatMulOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &InputZeroPoint);
        }
      }
    }
  }
  return result;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mpsx::QuantizedMatMulOp &>(uint64_t a1, uint64_t *a2, unsigned char *a3)
{
  char v3 = 1;
  char v9 = 1;
  if (*a3)
  {
    BOOL v7 = a3;
    char v3 = 3;
  }
  char v8 = v3;
  uint64_t v4 = *a2;
  uint64_t v10 = &v7;
  uint64_t v5 = *(void *)(a1 + 16);
  if (!v5) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16));
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v5 + 64))(v5, *(void *)(v4 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mpsx::QuantizedMatMulOp &>(mlir::mpsx::QuantizedMatMulOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v10);
  }
  return result;
}

mlir::GenericProgramPoint *mlir::RewriterBase::replaceOpWithNewOp<mlir::mpsx::QuantizedMatMulOp,mlir::Value,mlir::Value&,mlir::Value&,mlir::Value&,mlir::IntegerAttr &,mlir::Value&,mlir::Value&,mlir::Value&,mlir::Value&,mlir::IntegerAttr &,mlir::Value,mlir::detail::TypedValue<mlir::RankedTensorType>,mlir::detail::TypedValue<mlir::RankedTensorType>,mlir::Type,BOOL,BOOL>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10, uint64_t *a11, uint64_t *a12, uint64_t *a13, uint64_t *a14, uint64_t *a15, uint64_t *a16, unsigned __int8 *a17, unsigned __int8 *a18)
{
  unint64_t v20 = mlir::OpBuilder::create<mlir::mpsx::QuantizedMatMulOp,mlir::Value,mlir::Value&,mlir::Value&,mlir::Value&,mlir::IntegerAttr &,mlir::Value&,mlir::Value&,mlir::Value&,mlir::Value&,mlir::IntegerAttr &,mlir::Value,mlir::detail::TypedValue<mlir::RankedTensorType>,mlir::detail::TypedValue<mlir::RankedTensorType>,mlir::Type,BOOL,BOOL>(a1 + 1, *(void *)(a2 + 24), a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
  (*((void (**)(mlir::MLIRContext **, uint64_t, mlir::GenericProgramPoint *))*a1 + 4))(a1, a2, v20);
  return v20;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mpsx::QuantizedMatMulOp &>(mlir::mpsx::QuantizedMatMulOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mpsx::QuantizedMatMulOp,mlir::Value,mlir::Value&,mlir::Value&,mlir::Value&,mlir::IntegerAttr &,mlir::Value&,mlir::Value&,mlir::Value&,mlir::Value&,mlir::IntegerAttr &,mlir::Value,mlir::detail::TypedValue<mlir::RankedTensorType>,mlir::detail::TypedValue<mlir::RankedTensorType>,mlir::Type,BOOL,BOOL>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10, uint64_t *a11, uint64_t *a12, uint64_t *a13, uint64_t *a14, uint64_t *a15, uint64_t *a16, unsigned __int8 *a17, unsigned __int8 *a18)
{
  v37[38] = *MEMORY[0x1E4F143B8];
  uint64_t v32 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v32);
  uint64_t v27 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.quantized_matmul", (const unsigned __int8 *)0x15, Context);
  if (!v28)
  {
    __int16 v36 = 1283;
    v35[2] = (uint64_t)"mpsx.quantized_matmul";
    v35[3] = 21;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v34 = 259;
    llvm::operator+(v35, (uint64_t *)&v33, (uint64_t)v37);
    llvm::report_fatal_error((llvm::Twine *)v37, 1);
  }
  mlir::OperationState::OperationState(v37, a2, v27);
  mlir::mpsx::QuantizedMatMulOp::build(a1, (uint64_t)v37, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, *a11, *a12, *a13, *a14, *a15, *a16, *a17, *a18);
  uint64_t v29 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v37);
  if (*(_UNKNOWN **)(*((void *)v29 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::QuantizedMatMulOp,void>::id) {
    uint64_t v30 = v29;
  }
  else {
    uint64_t v30 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v37);
  return v30;
}

void mlir::mps::anonymous namespace'::CanonicalizeSDPAWithGQA::~CanonicalizeSDPAWithGQA(mlir::mps::_anonymous_namespace_::CanonicalizeSDPAWithGQA *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  char v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  char v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mpsx::ScaledDotProductAttentionOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mpsx::ScaledDotProductAttentionOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mpsx::ScaledDotProductAttentionOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeSDPAWithGQA::matchAndRewrite(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v4 = a2;
  uint64_t v136 = 0;
  uint64_t v137 = a2;
  uint64_t v134 = 0;
  uint64_t v135 = 0;
  v133[0] = &v136;
  v133[1] = &v135;
  uint64_t v131 = 0;
  uint64_t v132 = 0;
  v130[0] = v133;
  v130[1] = &v132;
  uint64_t v128 = 0;
  uint64_t v129 = 0;
  v126[0] = &v129;
  v126[1] = &v128;
  uint64_t v127 = 0;
  uint64_t v125 = 0;
  v123[0] = v126;
  v123[1] = &v125;
  uint64_t v124 = 0;
  uint64_t v121 = 0;
  uint64_t v122 = 0;
  uint64_t v119 = 0;
  uint64_t v120 = 0;
  v118[0] = &v120;
  v118[1] = v130;
  v118[2] = v123;
  v118[3] = &v122;
  v118[4] = &v121;
  v115[0] = a2;
  if (*(_UNKNOWN **)(*(void *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::ScaledDotProductAttentionOp,void>::id
    && (*(unsigned char *)(a2 + 46) & 0x80) != 0
    && *(_DWORD *)(a2 + 68) == 5)
  {
    LOBYTE(v113[0]) = 1;
    v138 = (const char *)v113;
    v139 = v115;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mpsx::ScaledDotProductAttentionOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::any_value_binder,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> & *)#1},0ul,1ul,2ul,3ul,4ul>((uint64_t)v118, (uint64_t)&v138);
    if (LOBYTE(v113[0]))
    {
      uint64_t v119 = v115[0];
      v138 = a3;
      v139 = &v137;
      uint64_t v117 = v134;
      uint64_t v5 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v117) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v5) {
        goto LABEL_14;
      }
      uint64_t v6 = *v5;
      unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v8 = *(unsigned int *)(v6 + 16);
      if (!v8) {
        goto LABEL_14;
      }
      char v9 = *(void **)(v6 + 8);
      uint64_t v10 = &v9[2 * v8];
      do
      {
        unint64_t v11 = v8 >> 1;
        uint64_t v12 = &v9[2 * (v8 >> 1)];
        unint64_t v14 = *v12;
        BOOL v13 = v12 + 2;
        v8 += ~(v8 >> 1);
        if (v14 < v7) {
          char v9 = v13;
        }
        else {
          unint64_t v8 = v11;
        }
      }
      while (v8);
      if (v9 != v10 && *v9 == v7) {
        uint64_t v15 = v9[1];
      }
      else {
LABEL_14:
      }
        uint64_t v15 = 0;
      char v16 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v117) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v16) {
        goto LABEL_24;
      }
      uint64_t v17 = *v16;
      unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v19 = *(unsigned int *)(v17 + 16);
      if (!v19) {
        goto LABEL_24;
      }
      unint64_t v20 = *(void **)(v17 + 8);
      unint64_t v21 = &v20[2 * v19];
      do
      {
        unint64_t v22 = v19 >> 1;
        uint64_t v23 = &v20[2 * (v19 >> 1)];
        unint64_t v25 = *v23;
        unint64_t v24 = v23 + 2;
        v19 += ~(v19 >> 1);
        if (v25 < v18) {
          unint64_t v20 = v24;
        }
        else {
          unint64_t v19 = v22;
        }
      }
      while (v19);
      if (v20 != v21 && *v20 == v18) {
        uint64_t v26 = v20[1];
      }
      else {
LABEL_24:
      }
        uint64_t v26 = 0;
      {
        uint64_t v116 = v127;
        uint64_t v27 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v116) + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!v27) {
          goto LABEL_35;
        }
        uint64_t v28 = *v27;
        unint64_t v29 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v30 = *(unsigned int *)(v28 + 16);
        if (!v30) {
          goto LABEL_35;
        }
        unint64_t v31 = *(void **)(v28 + 8);
        uint64_t v32 = &v31[2 * v30];
        do
        {
          unint64_t v33 = v30 >> 1;
          __int16 v34 = &v31[2 * (v30 >> 1)];
          unint64_t v36 = *v34;
          unint64_t v35 = v34 + 2;
          v30 += ~(v30 >> 1);
          if (v36 < v29) {
            unint64_t v31 = v35;
          }
          else {
            unint64_t v30 = v33;
          }
        }
        while (v30);
        if (v31 != v32 && *v31 == v29) {
          uint64_t v37 = v31[1];
        }
        else {
LABEL_35:
        }
          uint64_t v37 = 0;
        unint64_t v38 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v116) + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!v38) {
          goto LABEL_45;
        }
        uint64_t v39 = *v38;
        unint64_t v40 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v41 = *(unsigned int *)(v39 + 16);
        if (!v41) {
          goto LABEL_45;
        }
        uint64_t v42 = *(void **)(v39 + 8);
        uint64_t v43 = &v42[2 * v41];
        do
        {
          unint64_t v44 = v41 >> 1;
          unint64_t v45 = &v42[2 * (v41 >> 1)];
          unint64_t v47 = *v45;
          uint64_t v46 = v45 + 2;
          v41 += ~(v41 >> 1);
          if (v47 < v40) {
            uint64_t v42 = v46;
          }
          else {
            unint64_t v41 = v44;
          }
        }
        while (v41);
        if (v42 != v43 && *v42 == v40) {
          uint64_t v48 = v42[1];
        }
        else {
LABEL_45:
        }
          uint64_t v48 = 0;
        {
          v115[0] = (uint64_t)a3;
          v115[1] = (uint64_t)&v137;
          uint64_t v114 = v131;
          uint64_t v49 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v114) + 8) & 0xFFFFFFFFFFFFFFF8);
          if (!v49) {
            goto LABEL_56;
          }
          uint64_t v50 = *v49;
          unint64_t v51 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v52 = *(unsigned int *)(v50 + 16);
          if (!v52) {
            goto LABEL_56;
          }
          uint64_t v53 = *(void **)(v50 + 8);
          uint64_t v54 = &v53[2 * v52];
          do
          {
            unint64_t v55 = v52 >> 1;
            uint64_t v56 = &v53[2 * (v52 >> 1)];
            unint64_t v58 = *v56;
            uint64_t v57 = v56 + 2;
            v52 += ~(v52 >> 1);
            if (v58 < v51) {
              uint64_t v53 = v57;
            }
            else {
              unint64_t v52 = v55;
            }
          }
          while (v52);
          if (v53 != v54 && *v53 == v51) {
            uint64_t v59 = v53[1];
          }
          else {
LABEL_56:
          }
            uint64_t v59 = 0;
          v113[0] = v49;
          v113[1] = v59;
          uint64_t v60 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v114) + 8) & 0xFFFFFFFFFFFFFFF8);
          if (!v60) {
            goto LABEL_66;
          }
          uint64_t v61 = *v60;
          unint64_t v62 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v63 = *(unsigned int *)(v61 + 16);
          if (!v63) {
            goto LABEL_66;
          }
          unint64_t v64 = *(void **)(v61 + 8);
          uint64_t v65 = &v64[2 * v63];
          do
          {
            unint64_t v66 = v63 >> 1;
            uint64_t v67 = &v64[2 * (v63 >> 1)];
            unint64_t v69 = *v67;
            uint64_t v68 = v67 + 2;
            v63 += ~(v63 >> 1);
            if (v69 < v62) {
              unint64_t v64 = v68;
            }
            else {
              unint64_t v63 = v66;
            }
          }
          while (v63);
          if (v64 != v65 && *v64 == v62) {
            uint64_t v70 = v64[1];
          }
          else {
LABEL_66:
          }
            uint64_t v70 = 0;
          {
            uint64_t v112 = v124;
            int32x4_t v71 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v112) + 8) & 0xFFFFFFFFFFFFFFF8);
            if (!v71) {
              goto LABEL_77;
            }
            uint64_t v72 = *v71;
            unint64_t v73 = mlir::TypeID::get<mlir::ShapedType>();
            unint64_t v74 = *(unsigned int *)(v72 + 16);
            if (!v74) {
              goto LABEL_77;
            }
            uint64_t v75 = *(void **)(v72 + 8);
            uint64_t v76 = &v75[2 * v74];
            do
            {
              unint64_t v77 = v74 >> 1;
              uint64_t v78 = &v75[2 * (v74 >> 1)];
              unint64_t v80 = *v78;
              uint64_t v79 = v78 + 2;
              v74 += ~(v74 >> 1);
              if (v80 < v73) {
                uint64_t v75 = v79;
              }
              else {
                unint64_t v74 = v77;
              }
            }
            while (v74);
            if (v75 != v76 && *v75 == v73) {
              uint64_t v81 = v75[1];
            }
            else {
LABEL_77:
            }
              uint64_t v81 = 0;
            v111[0] = v71;
            v111[1] = v81;
            uint64_t v82 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v112) + 8) & 0xFFFFFFFFFFFFFFF8);
            if (!v82) {
              goto LABEL_87;
            }
            uint64_t v83 = *v82;
            unint64_t v84 = mlir::TypeID::get<mlir::ShapedType>();
            unint64_t v85 = *(unsigned int *)(v83 + 16);
            if (!v85) {
              goto LABEL_87;
            }
            uint64_t v86 = *(void **)(v83 + 8);
            uint64_t v87 = &v86[2 * v85];
            do
            {
              unint64_t v88 = v85 >> 1;
              uint64_t v89 = &v86[2 * (v85 >> 1)];
              unint64_t v91 = *v89;
              uint64_t v90 = v89 + 2;
              v85 += ~(v85 >> 1);
              if (v91 < v84) {
                uint64_t v86 = v90;
              }
              else {
                unint64_t v85 = v88;
              }
            }
            while (v85);
            if (v86 != v87 && *v86 == v84) {
              uint64_t v92 = v86[1];
            }
            else {
LABEL_87:
            }
              uint64_t v92 = 0;
            {
              uint64_t v93 = *(void *)(v137 + 24);
              mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v113);
              LODWORD(v109) = v94 - 3;
              uint64_t v110 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,int>((mlir::mps::ConstantOp *)(a3 + 8), v93, (unsigned int *)&v109)- 16;
              uint64_t v95 = *(void *)(v137 + 24);
              mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v111);
              LODWORD(v108) = v96 - 3;
              uint64_t v109 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,int>((mlir::mps::ConstantOp *)(a3 + 8), v95, (unsigned int *)&v108)- 16;
              uint64_t v97 = *(void *)(v137 + 24);
              uint64_t v107 = v136;
              uint64_t v108 = (uint64_t)mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::Value&>((mlir::OpBuilder *)(a3 + 8), v97, &v107, &v110)- 16;
              uint64_t v98 = *(void *)(v137 + 24);
              uint64_t v106 = v129;
              uint64_t v107 = (uint64_t)mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::Value&>((mlir::OpBuilder *)(a3 + 8), v98, &v106, &v109)- 16;
              uint64_t v99 = v137;
              uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v137);
              uint64_t v105 = v122;
              uint64_t v106 = Input;
              uint64_t v104 = v121;
              uint64_t v101 = mlir::OpBuilder::create<mlir::mpsx::ScaledDotProductAttentionOp,mlir::Value,mlir::Value,mlir::Value,mlir::Value&,mlir::Value&>((mlir::Float32Type **)a3 + 1, *(void *)(v99 + 24), &v106, &v108, &v107, &v105, &v104);
              (*(void (**)(char *, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, v99, v101);
              return 1;
            }
          }
        }
      }
      return 0;
    }
    uint64_t v4 = v137;
  }
  v138 = "failed: root pattern did not match";
  __int16 v140 = 259;
  v115[0] = (uint64_t)&v138;
  uint64_t v103 = *((void *)a3 + 2);
  if (!v103) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v103);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(void *)v103 + 64))(v103, *(void *)(v4 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mpsx::ScaledDotProductAttentionOp &>(mlir::mpsx::ScaledDotProductAttentionOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v115);
  }
  return result;
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeSDPAWithGQA::matchAndRewrite(mlir::mpsx::ScaledDotProductAttentionOp,mlir::PatternRewriter &)const::{lambda(mlir::ShapedType,mlir::ShapedType)#1}::operator()(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v31[6] = *MEMORY[0x1E4F143B8];
  v25[0] = a2;
  v25[1] = a3;
  v24[0] = a4;
  v24[1] = a5;
  unint64_t v29 = v31;
  uint64_t v30 = 0x600000000;
  uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v25);
  uint64_t v8 = v7;
  uint64_t v9 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v24);
  if (v8 && v10)
  {
    uint64_t v11 = v9;
    uint64_t v12 = 0;
    uint64_t v13 = 8 * v10 - 8;
    uint64_t v14 = 8 * v8 - 8;
    do
    {
      if (*(void *)(ArgAttrsAttr + 8 * v12) != *(void *)(v11 + 8 * v12))
      {
        uint64_t v15 = v30;
        if (v30 >= (unint64_t)HIDWORD(v30))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v29, v31, v30 + 1, 8);
          uint64_t v15 = v30;
        }
        *((void *)v29 + v15) = v12;
        LODWORD(v30) = v30 + 1;
      }
      if (!v14) {
        break;
      }
      ++v12;
      uint64_t v16 = v13;
      v13 -= 8;
      v14 -= 8;
    }
    while (v16);
  }
  if (v30 == 1)
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v25);
    if (v17 - 3 == *(void *)v29)
    {
      uint64_t v18 = 1;
      goto LABEL_19;
    }
    uint64_t v19 = *a1;
    unint64_t v20 = (uint64_t *)a1[1];
    unint64_t v21 = "failed: pattern can be applied only if the broadcasting dimension is the head dimension";
  }
  else
  {
    uint64_t v19 = *a1;
    unint64_t v20 = (uint64_t *)a1[1];
    unint64_t v21 = "failed: pattern can match only a single broadcasting dimension";
  }
  uint64_t v26 = v21;
  __int16 v27 = 259;
  uint64_t v22 = *v20;
  uint64_t v28 = &v26;
  uint64_t v18 = *(void *)(v19 + 16);
  if (v18)
  {
    if (mlir::RewriterBase::Listener::classof(*(void *)(v19 + 16))) {
      uint64_t v18 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), const char ***))(*(void *)v18 + 64))(v18, *(void *)(v22 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mpsx::ScaledDotProductAttentionOp &>(mlir::mpsx::ScaledDotProductAttentionOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v28);
    }
    else {
      uint64_t v18 = 0;
    }
  }
LABEL_19:
  if (v29 != v31) {
    free(v29);
  }
  return v18;
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeSDPAWithGQA::matchAndRewrite(mlir::mpsx::ScaledDotProductAttentionOp,mlir::PatternRewriter &)const::{lambda(mlir::ShapedType,mlir::ShapedType)#2}::operator()(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v19[0] = a2;
  v19[1] = a3;
  v18[0] = a4;
  v18[1] = a5;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v19);
  uint64_t v7 = v6;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v18);
  if (v7 > 4 || v8 >= 4)
  {
    int v10 = v8;
    uint64_t v11 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v19)
                    + 8 * (v7 - 4));
    uint64_t v12 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v19)
                    + 8 * (v7 - 3))
        * v11;
    if (v12 == *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v18)
                          + 8 * (v10 - 3)))
      return 1;
  }
  uint64_t v14 = *a1;
  uint64_t v15 = (uint64_t *)a1[1];
  unint64_t v20 = "failed: reshape does not concatenate groups";
  __int16 v21 = 259;
  uint64_t v16 = *v15;
  uint64_t v22 = &v20;
  uint64_t v17 = *(void *)(v14 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(*(void *)(v14 + 16));
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), const char ***))(*(void *)v17 + 64))(v17, *(void *)(v16 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mpsx::ScaledDotProductAttentionOp &>(mlir::mpsx::ScaledDotProductAttentionOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v22);
  }
  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mpsx::ScaledDotProductAttentionOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::any_value_binder,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> & *)#1},0ul,1ul,2ul,3ul,4ul>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = **(void **)(a2 + 8);
  uint64_t v6 = *(void *)(*(void *)(v5 + 72) + 24);
  if (*v4)
  {
    BOOL v7 = *v4 == v6;
  }
  else
  {
    void *v4 = v6;
    uint64_t v5 = **(void **)(a2 + 8);
    BOOL v7 = 1;
  }
  if (!**(unsigned char **)a2) {
    BOOL v7 = 0;
  }
  **(unsigned char **)a2 = v7;
  char v8 = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(v5, 1u, *(void *)(a1 + 8));
  uint64_t v9 = *(uint64_t **)(a2 + 8);
  if (**(unsigned char **)a2) {
    char v10 = v8;
  }
  else {
    char v10 = 0;
  }
  **(unsigned char **)a2 = v10;
  uint64_t result = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(*v9, 2u, *(void *)(a1 + 16));
  uint64_t v12 = *(BOOL **)a2;
  uint64_t v13 = *(void *)(a2 + 8);
  if (**(unsigned char **)a2) {
    BOOL v14 = result;
  }
  else {
    BOOL v14 = 0;
  }
  *uint64_t v12 = v14;
  uint64_t v15 = *(void **)(a1 + 24);
  uint64_t v16 = *(void *)(*(void *)v13 + 72);
  uint64_t v17 = *(void *)(v16 + 120);
  if (*v15)
  {
    BOOL v18 = *v15 == v17;
  }
  else
  {
    void *v15 = v17;
    uint64_t v12 = *(BOOL **)a2;
    uint64_t v16 = *(void *)(**(void **)(a2 + 8) + 72);
    BOOL v14 = **(unsigned char **)a2 != 0;
    BOOL v18 = 1;
  }
  BOOL v19 = v18 && v14;
  *uint64_t v12 = v19;
  unint64_t v20 = *(void **)(a1 + 32);
  uint64_t v21 = *(void *)(v16 + 152);
  if (*v20)
  {
    BOOL v22 = *v20 == v21;
  }
  else
  {
    *unint64_t v20 = v21;
    uint64_t v12 = *(BOOL **)a2;
    BOOL v19 = **(unsigned char **)a2 != 0;
    BOOL v22 = 1;
  }
  *uint64_t v12 = v22 && v19;
  return result;
}

uint64_t mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v11 = *(void *)(*(void *)(a1 + 72) + 32 * a2 + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  uint64_t v6 = DefiningOp;
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(void *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id
      && (*(unsigned char *)(DefiningOp + 46) & 0x80) != 0
      && *(_DWORD *)(DefiningOp + 68) == 2
      && (v7 = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(DefiningOp, 0, *(uint64_t ***)a3), char v8 = *(uint64_t **)(a3 + 8), v11 = *(void *)(*(void *)(v6 + 72) + 56), (v9 = mlir::Value::getDefiningOp((mlir::Value *)&v11)) != 0)&& *(_UNKNOWN **)(*(void *)(v9 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id&& (!*v8 || *v8 == v9)&& (*char v8 = v9, v7))
    {
      *(void *)(a3 + 16) = v6;
      char v5 = 1;
    }
    else
    {
      char v5 = 0;
    }
  }
  return (v6 != 0) & v5;
}

uint64_t mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(uint64_t a1, unsigned int a2, uint64_t **a3)
{
  uint64_t v14 = *(void *)(*(void *)(a1 + 72) + 32 * a2 + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v14);
  uint64_t v6 = DefiningOp;
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(void *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::BroadcastToOp,void>::id
      || (*(unsigned char *)(DefiningOp + 46) & 0x80) == 0
      || *(_DWORD *)(DefiningOp + 68) != 2)
    {
      goto LABEL_15;
    }
    uint64_t v7 = *(void *)(DefiningOp + 72);
    uint64_t v8 = *(void *)(v7 + 24);
    uint64_t v9 = **a3;
    if (v9)
    {
      BOOL v10 = v9 == v8;
    }
    else
    {
      **a3 = v8;
      uint64_t v7 = *(void *)(DefiningOp + 72);
      BOOL v10 = 1;
    }
    if ((v11 = a3[1], uint64_t v14 = *(void *)(v7 + 56), (v12 = mlir::Value::getDefiningOp((mlir::Value *)&v14)) != 0)
      && *(_UNKNOWN **)(*(void *)(v12 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v11 || *v11 == v12)
      && (*uint64_t v11 = v12, v10))
    {
      a3[2] = (uint64_t *)v6;
      char v5 = 1;
    }
    else
    {
LABEL_15:
      char v5 = 0;
    }
  }
  return (v6 != 0) & v5;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mpsx::ScaledDotProductAttentionOp &>(mlir::mpsx::ScaledDotProductAttentionOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

void mlir::mps::anonymous namespace'::CanonicalizeQuantizedGather::~CanonicalizeQuantizedGather(mlir::mps::_anonymous_namespace_::CanonicalizeQuantizedGather *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  char v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  char v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::GatherOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::GatherOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::GatherOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeQuantizedGather::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v102 = 0;
  uint64_t v103 = a2;
  uint64_t v100 = 0;
  uint64_t v101 = 0;
  v97[0] = &v102;
  v97[1] = &v101;
  v97[2] = &v100;
  v97[3] = &v99;
  uint64_t v98 = 0;
  uint64_t v99 = 0;
  uint64_t v95 = 0;
  uint64_t v96 = 0;
  v93[0] = (uint64_t)v97;
  v93[1] = (uint64_t)&v96;
  v93[2] = (uint64_t)&v95;
  uint64_t v94 = 0;
  v86[0] = a2;
  if (*(_UNKNOWN **)(*(void *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::GatherOp,void>::id
    && (*(unsigned char *)(a2 + 46) & 0x80) != 0
    && *(_DWORD *)(a2 + 68) == 3)
  {
    LOBYTE(v85[0]) = 1;
    v104[0] = (uint64_t)v85;
    v104[1] = (uint64_t)v86;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::GatherOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*> & *)#1},0ul,1ul,2ul>(v93, (uint64_t)v104);
    if (LOBYTE(v85[0]))
    {
      uint64_t v94 = v86[0];
      uint64_t v91 = v86[0];
      uint64_t v92 = v98;
      uint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v92);
      uint64_t v90 = SparseShape;
      uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v92);
      uint64_t v89 = Bias;
      uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v92);
      uint64_t v88 = Input;
      uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v92);
      uint64_t v87 = Filter;
      uint64_t v9 = (uint64_t *)(*(void *)(Input + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v9) {
        goto LABEL_14;
      }
      uint64_t v10 = *v9;
      unint64_t v11 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v12 = *(unsigned int *)(v10 + 16);
      if (!v12) {
        goto LABEL_14;
      }
      uint64_t v13 = *(void **)(v10 + 8);
      uint64_t v14 = &v13[2 * v12];
      do
      {
        unint64_t v15 = v12 >> 1;
        uint64_t v16 = &v13[2 * (v12 >> 1)];
        unint64_t v18 = *v16;
        uint64_t v17 = v16 + 2;
        v12 += ~(v12 >> 1);
        if (v18 < v11) {
          uint64_t v13 = v17;
        }
        else {
          unint64_t v12 = v15;
        }
      }
      while (v12);
      if (v13 != v14 && *v13 == v11) {
        uint64_t v19 = v13[1];
      }
      else {
LABEL_14:
      }
        uint64_t v19 = 0;
      v86[0] = v9;
      v86[1] = v19;
      unint64_t v20 = (uint64_t *)(*(void *)(Filter + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v20) {
        goto LABEL_24;
      }
      uint64_t v21 = *v20;
      unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v23 = *(unsigned int *)(v21 + 16);
      if (!v23) {
        goto LABEL_24;
      }
      unint64_t v24 = *(void **)(v21 + 8);
      unint64_t v25 = &v24[2 * v23];
      do
      {
        unint64_t v26 = v23 >> 1;
        __int16 v27 = &v24[2 * (v23 >> 1)];
        unint64_t v29 = *v27;
        uint64_t v28 = v27 + 2;
        v23 += ~(v23 >> 1);
        if (v29 < v22) {
          unint64_t v24 = v28;
        }
        else {
          unint64_t v23 = v26;
        }
      }
      while (v23);
      if (v24 != v25 && *v24 == v22) {
        uint64_t v30 = v24[1];
      }
      else {
LABEL_24:
      }
        uint64_t v30 = 0;
      v85[0] = v20;
      v85[1] = v30;
      unint64_t v31 = (uint64_t *)(*(void *)(SparseShape + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v31) {
        goto LABEL_34;
      }
      uint64_t v32 = *v31;
      unint64_t v33 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v34 = *(unsigned int *)(v32 + 16);
      if (!v34) {
        goto LABEL_34;
      }
      unint64_t v35 = *(void **)(v32 + 8);
      unint64_t v36 = &v35[2 * v34];
      do
      {
        unint64_t v37 = v34 >> 1;
        unint64_t v38 = &v35[2 * (v34 >> 1)];
        unint64_t v40 = *v38;
        uint64_t v39 = v38 + 2;
        v34 += ~(v34 >> 1);
        if (v40 < v33) {
          unint64_t v35 = v39;
        }
        else {
          unint64_t v34 = v37;
        }
      }
      while (v34);
      if (v35 != v36 && *v35 == v33) {
        uint64_t v41 = v35[1];
      }
      else {
LABEL_34:
      }
        uint64_t v41 = 0;
      v84[0] = v31;
      v84[1] = v41;
      uint64_t v42 = (uint64_t *)(*(void *)(Bias + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v42) {
        goto LABEL_44;
      }
      uint64_t v43 = *v42;
      unint64_t v44 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v45 = *(unsigned int *)(v43 + 16);
      if (!v45) {
        goto LABEL_44;
      }
      uint64_t v46 = *(void **)(v43 + 8);
      unint64_t v47 = &v46[2 * v45];
      do
      {
        unint64_t v48 = v45 >> 1;
        uint64_t v49 = &v46[2 * (v45 >> 1)];
        unint64_t v51 = *v49;
        uint64_t v50 = v49 + 2;
        v45 += ~(v45 >> 1);
        if (v51 < v44) {
          uint64_t v46 = v50;
        }
        else {
          unint64_t v45 = v48;
        }
      }
      while (v45);
      if (v46 != v47 && *v46 == v44) {
        uint64_t v52 = v46[1];
      }
      else {
LABEL_44:
      }
        uint64_t v52 = 0;
      v83[0] = v42;
      v83[1] = v52;
      if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86))
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v86);
        uint64_t v54 = v53 & ~(v53 >> 63);
      }
      else
      {
        uint64_t v54 = 0;
      }
      if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v85))
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v85);
        if (v54 <= v57) {
          uint64_t v54 = v57;
        }
      }
      if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v84))
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v84);
        if (v54 <= v58) {
          uint64_t v54 = v58;
        }
      }
      if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v83))
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v83);
        if (v54 <= v59) {
          uint64_t v54 = v59;
        }
      }
      v82[0] = a3;
      v82[1] = (uint64_t)&v103;
      char v81 = 5;
      strcpy((char *)v80, "input");
      {
        BOOL v60 = 1;
        if (v81 < 0) {
          goto LABEL_69;
        }
        goto LABEL_66;
      }
      char v79 = 5;
      strcpy((char *)v78, "scale");
      {
        char v77 = 9;
        strcpy((char *)v76, "zeroPoint");
        {
          char v75 = 3;
          LODWORD(v74) = 7235949;
          if ((v77 & 0x80000000) == 0) {
            goto LABEL_64;
          }
        }
        else
        {
          BOOL v60 = 1;
          if ((v77 & 0x80000000) == 0)
          {
LABEL_64:
            if ((v79 & 0x80000000) == 0) {
              goto LABEL_65;
            }
            goto LABEL_77;
          }
        }
        operator delete(v76[0]);
        if (v79 < 0)
        {
LABEL_77:
          operator delete(v78[0]);
          if (v81 < 0) {
            goto LABEL_69;
          }
LABEL_66:
          if (v60) {
            return 0;
          }
          goto LABEL_70;
        }
      }
      else
      {
        BOOL v60 = 1;
        if (v79 < 0) {
          goto LABEL_77;
        }
      }
LABEL_65:
      if ((v81 & 0x80000000) == 0) {
        goto LABEL_66;
      }
LABEL_69:
      operator delete(v80[0]);
      if (v60) {
        return 0;
      }
LABEL_70:
      if ((mlir::mps::DequantizeLUTOp::getAxis((mlir::mps::DequantizeLUTOp *)&v92) & 0xFF00000000) == 0)
      {
        char v73 = 5;
        strcpy(__p, "input");
        v71[24] = 5;
        strcpy(v71, "\tscale");
        strcpy(v70, "zeroPoint");
        char v69 = 3;
        LODWORD(v68) = 7235949;
        uint64_t v63 = v103;
        v104[0] = v96;
        uint64_t v106 = (uint64_t *)v95;
        uint64_t FunctionType = mlir::func::FuncOp::getFunctionType((mlir::func::FuncOp *)&v92);
        unsigned int Count = mlir::pdl_interp::CheckOperandCountOp::getCount((mlir::pdl_interp::CheckOperandCountOp *)&v91);
        BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v91);
        unint64_t v64 = mlir::OpBuilder::create<mlir::mpsx::QuantizedGatherOp,mlir::Value &,mlir::Value,mlir::Value,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Type,unsigned int,BOOL>((mlir::MLIRContext **)(a3 + 8), *(void *)(v63 + 24), &v88, v104, (uint64_t *)&v106, &v87, &v89, &v90, &FunctionType, &Count, (char *)&InferredResultTypes);
        (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, v63, v64);
        return 1;
      }
      v104[0] = (uint64_t)"can't fuse the dequantize op which has the broadcast axis";
      __int16 v105 = 259;
      uint64_t v61 = v103;
      uint64_t v106 = v104;
      uint64_t v62 = *(void *)(a3 + 16);
      if (v62)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v62);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), uint64_t **))(*(void *)v62 + 64))(v62, *(void *)(v61 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherOp &>(mlir::mps::GatherOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v106);
        }
        return result;
      }
      return 0;
    }
  }
  v104[0] = (uint64_t)"failed: root pattern did not match";
  __int16 v105 = 259;
  v86[0] = v104;
  uint64_t v55 = *(void *)(a3 + 16);
  if (!v55) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v55);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v55 + 64))(v55, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherOp &>(mlir::mps::GatherOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v86);
  }
  return result;
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeQuantizedGather::matchAndRewrite(mlir::mps::GatherOp,mlir::PatternRewriter &)const::{lambda(mlir::ShapedType const&,long long,mlir::Value &,BOOL,std::string)#1}::operator()(uint64_t *a1, mlir::CallOpInterface *this, uint64_t a3, uint64_t *a4, int a5)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  if (!mlir::CallOpInterface::getArgOperands(this)) {
    return 1;
  }
  mlir::CallableOpInterface::getArgAttrsAttr(this);
  if (a3 <= v10)
  {
    if (a3 >= v10) {
      return 1;
    }
    uint64_t v25 = *a1;
    unint64_t v26 = (uint64_t *)a1[1];
    std::operator+<char>();
    __int16 v27 = std::string::append(&v58, " tensor to ");
    std::string::size_type v28 = v27->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v66.__r_.__value_.__l.__data_ = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
    v66.__r_.__value_.__r.__words[2] = v28;
    v27->__r_.__value_.__l.__size_ = 0;
    v27->__r_.__value_.__r.__words[2] = 0;
    v27->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v57, a3);
    if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v29 = &v57;
    }
    else {
      unint64_t v29 = (std::string *)v57.__r_.__value_.__r.__words[0];
    }
    if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v57.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v57.__r_.__value_.__l.__size_;
    }
    unint64_t v31 = std::string::append(&v66, (const std::string::value_type *)v29, size);
    std::string::size_type v32 = v31->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
    std::string::size_type v60 = v32;
    v31->__r_.__value_.__l.__size_ = 0;
    v31->__r_.__value_.__r.__words[2] = 0;
    v31->__r_.__value_.__r.__words[0] = 0;
    __int16 v65 = 260;
    uint64_t v62 = __p;
    uint64_t v33 = *v26;
    uint64_t v61 = &v62;
    uint64_t v34 = *(void *)(v25 + 16);
    if (v34)
    {
      if (!mlir::RewriterBase::Listener::classof(v34))
      {
        uint64_t v34 = 0;
        if ((SHIBYTE(v60) & 0x80000000) == 0)
        {
LABEL_24:
          if ((SHIBYTE(v57.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_25;
          }
          goto LABEL_51;
        }
LABEL_50:
        operator delete(__p[0]);
        if ((SHIBYTE(v57.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_25:
          if ((SHIBYTE(v66.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_26;
          }
          goto LABEL_52;
        }
LABEL_51:
        operator delete(v57.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v66.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_26:
          if ((SHIBYTE(v58.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            return v34;
          }
LABEL_53:
          uint64_t v52 = (void *)v58.__r_.__value_.__r.__words[0];
LABEL_54:
          operator delete(v52);
          return v34;
        }
LABEL_52:
        operator delete(v66.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v58.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          return v34;
        }
        goto LABEL_53;
      }
      uint64_t v34 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void ***))(*(void *)v34 + 64))(v34, *(void *)(v33 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherOp &>(mlir::mps::GatherOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v61);
    }
    if ((SHIBYTE(v60) & 0x80000000) == 0) {
      goto LABEL_24;
    }
    goto LABEL_50;
  }
  uint64_t v11 = v10;
  v57.__r_.__value_.__r.__words[0] = mlir::MemoryMapperInterface::getOperandRange(this);
  if (*(_UNKNOWN **)(*(void *)v57.__r_.__value_.__l.__data_ + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id
    || mlir::Type::isInteger((mlir::Type *)&v57, 1)
    || mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&v57) > 7)
  {
    if (!a5) {
      return 1;
    }
    uint64_t v62 = v64;
    uint64_t v63 = 0x400000000;
    std::string::size_type v35 = a3 - v11;
    if (v35)
    {
      unsigned int v50 = 0;
      for (uint64_t i = 0; i != v35; ++i)
      {
        if (v50 >= HIDWORD(v63))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v64, v50 + 1, 4);
          unsigned int v50 = v63;
        }
        *((_DWORD *)v62 + v50) = i;
        unsigned int v50 = v63 + 1;
        LODWORD(v63) = v63 + 1;
      }
    }
    v66.__r_.__value_.__r.__words[0] = v35;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(*a1 + 8), 0x20u, 1);
    unint64_t v37 = (void *)mlir::RankedTensorType::get((uint64_t)&v66, 1, IntegerType, 0);
    unint64_t v38 = v37;
    if (!v37) {
      goto LABEL_39;
    }
    uint64_t v39 = *v37;
    unint64_t v40 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v41 = *(unsigned int *)(v39 + 16);
    if (!v41) {
      goto LABEL_39;
    }
    uint64_t v42 = *(void **)(v39 + 8);
    uint64_t v43 = &v42[2 * v41];
    do
    {
      unint64_t v44 = v41 >> 1;
      unint64_t v45 = &v42[2 * (v41 >> 1)];
      unint64_t v47 = *v45;
      uint64_t v46 = v45 + 2;
      v41 += ~(v41 >> 1);
      if (v47 < v40) {
        uint64_t v42 = v46;
      }
      else {
        unint64_t v41 = v44;
      }
    }
    while (v41);
    if (v42 != v43 && *v42 == v40) {
      uint64_t v48 = v42[1];
    }
    else {
LABEL_39:
    }
      uint64_t v48 = 0;
    __p[0] = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v38, v48, v62, 4 * v63, 4, 1, 1);
    v66.__r_.__value_.__r.__words[0] = (std::string::size_type)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(*a1 + 8), *(void *)(*(void *)a1[1] + 24), (uint64_t **)__p)- 16;
    *a4 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(*a1 + 8), *(void *)(*(void *)a1[1] + 24), a4, (uint64_t *)&v66)- 16;
    unint64_t v24 = v62;
    if (v62 == v64) {
      return 1;
    }
LABEL_41:
    free(v24);
    return 1;
  }
  *(_OWORD *)&v58.__r_.__value_.__l.__data_ = 0uLL;
  unint64_t v12 = (void *)*a4;
  __p[0] = &v58;
  uint64_t v62 = v12;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v62);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)__p, DefiningOp))
  {
    if (!a5) {
      return 1;
    }
    uint64_t ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr(this);
    llvm::SmallVector<mlir::Value,4u>::SmallVector(&v62, ArgAttrsAttr, v15);
    for (uint64_t j = a3 - v11; j; --j)
    {
      __p[0] = (void *)1;
      llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v62, (uint64_t)v62, (uint64_t *)__p);
    }
    uint64_t v17 = v62;
    uint64_t v18 = v63;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange(this);
    v66.__r_.__value_.__r.__words[0] = mlir::RankedTensorType::get((uint64_t)v17, v18, OperandRange, 0);
    long long v20 = *(_OWORD *)&v58.__r_.__value_.__l.__data_;
    uint64_t v21 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v66);
    __p[0] = mlir::reshapeElementsAttr(v20, *((uint64_t *)&v20 + 1), (uint64_t)v21, v22);
    __p[1] = v23;
    *a4 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ElementsAttr &>((mlir::OpBuilder *)(*a1 + 8), *(void *)(*(void *)a1[1] + 24), (uint64_t)__p)- 16;
    unint64_t v24 = v62;
    if (v62 == v64) {
      return 1;
    }
    goto LABEL_41;
  }
  uint64_t v53 = *a1;
  uint64_t v54 = (uint64_t *)a1[1];
  std::operator+<char>();
  uint64_t v55 = std::string::append(&v66, ", because it is not a constant");
  std::string::size_type v56 = v55->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = *(_OWORD *)&v55->__r_.__value_.__l.__data_;
  std::string::size_type v60 = v56;
  v55->__r_.__value_.__l.__size_ = 0;
  v55->__r_.__value_.__r.__words[2] = 0;
  v55->__r_.__value_.__r.__words[0] = 0;
  __int16 v65 = 260;
  uint64_t v62 = __p;
  uint64_t v34 = mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherOp &>(v53, v54, (uint64_t)&v62);
  if (SHIBYTE(v60) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0)
  {
    uint64_t v52 = (void *)v66.__r_.__value_.__r.__words[0];
    goto LABEL_54;
  }
  return v34;
}

uint64_t **mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::GatherOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*> & *)#1},0ul,1ul,2ul>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  v20[0] = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 24);
  uint64_t result = (uint64_t **)mlir::Value::getDefiningOp((mlir::Value *)v20);
  uint64_t v7 = result;
  if (result)
  {
    uint64_t v22 = result;
    if ((_UNKNOWN *)result[6][2] == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id
      && (*((unsigned char *)result + 46) & 0x80) != 0
      && *((_DWORD *)result + 17) == 4)
    {
      unsigned __int8 v21 = 1;
      v20[0] = &v21;
      v20[1] = &v22;
      uint64_t result = mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> & *)#1},0ul,1ul,2ul,3ul>((uint64_t **)v4, (uint64_t)v20);
      int v8 = v21;
      if (v21) {
        *(void *)(v4 + 32) = v22;
      }
      BOOL v6 = v8 != 0;
    }
    else
    {
      BOOL v6 = 0;
    }
  }
  uint64_t v9 = *(BOOL **)a2;
  BOOL v10 = v6 && **(unsigned char **)a2 != 0;
  if (v7) {
    BOOL v11 = v10;
  }
  else {
    BOOL v11 = 0;
  }
  *uint64_t v9 = v11;
  unint64_t v12 = (void *)a1[1];
  uint64_t v13 = *(void *)(**(void **)(a2 + 8) + 72);
  uint64_t v14 = *(void *)(v13 + 56);
  if (*v12)
  {
    BOOL v15 = *v12 == v14;
  }
  else
  {
    *unint64_t v12 = v14;
    uint64_t v9 = *(BOOL **)a2;
    uint64_t v13 = *(void *)(**(void **)(a2 + 8) + 72);
    BOOL v11 = **(unsigned char **)a2 != 0;
    BOOL v15 = 1;
  }
  BOOL v16 = v15 && v11;
  *uint64_t v9 = v16;
  uint64_t v17 = (void *)a1[2];
  uint64_t v18 = *(void *)(v13 + 88);
  if (*v17)
  {
    BOOL v19 = *v17 == v18;
  }
  else
  {
    *uint64_t v17 = v18;
    uint64_t v9 = *(BOOL **)a2;
    BOOL v16 = **(unsigned char **)a2 != 0;
    BOOL v19 = 1;
  }
  *uint64_t v9 = v19 && v16;
  return result;
}

uint64_t **mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> & *)#1},0ul,1ul,2ul,3ul>(uint64_t **result, uint64_t a2)
{
  int v2 = *(void **)(**(void **)(a2 + 8) + 72);
  uint64_t v3 = v2[3];
  uint64_t v4 = **result;
  if (v4)
  {
    BOOL v5 = v4 == v3;
  }
  else
  {
    **uint64_t result = v3;
    int v2 = *(void **)(**(void **)(a2 + 8) + 72);
    BOOL v5 = 1;
  }
  BOOL v6 = *(BOOL **)a2;
  if (!**(unsigned char **)a2) {
    BOOL v5 = 0;
  }
  *BOOL v6 = v5;
  uint64_t v7 = result[1];
  uint64_t v8 = v2[7];
  if (*v7)
  {
    BOOL v9 = *v7 == v8;
  }
  else
  {
    *uint64_t v7 = v8;
    BOOL v6 = *(BOOL **)a2;
    int v2 = *(void **)(**(void **)(a2 + 8) + 72);
    BOOL v5 = **(unsigned char **)a2 != 0;
    BOOL v9 = 1;
  }
  BOOL v10 = v9 && v5;
  *BOOL v6 = v10;
  BOOL v11 = result[2];
  uint64_t v12 = v2[11];
  if (*v11)
  {
    BOOL v13 = *v11 == v12;
  }
  else
  {
    *BOOL v11 = v12;
    BOOL v6 = *(BOOL **)a2;
    int v2 = *(void **)(**(void **)(a2 + 8) + 72);
    BOOL v10 = **(unsigned char **)a2 != 0;
    BOOL v13 = 1;
  }
  BOOL v14 = v13 && v10;
  *BOOL v6 = v14;
  BOOL v15 = result[3];
  uint64_t v16 = v2[15];
  if (*v15)
  {
    BOOL v17 = *v15 == v16;
  }
  else
  {
    uint64_t *v15 = v16;
    BOOL v6 = *(BOOL **)a2;
    BOOL v14 = **(unsigned char **)a2 != 0;
    BOOL v17 = 1;
  }
  *BOOL v6 = v17 && v14;
  return result;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherOp &>(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *a2;
  uint64_t v6 = a3;
  uint64_t v4 = *(void *)(a1 + 16);
  if (!v4) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16));
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(void *)v4 + 64))(v4, *(void *)(v3 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherOp &>(mlir::mps::GatherOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v6);
  }
  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherOp &>(mlir::mps::GatherOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ElementsAttr &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.constant", (const unsigned __int8 *)0xC, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"mps.constant";
    v15[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ConstantOp::build((uint64_t)a1, (uint64_t)v17, *(void **)a3, *(void *)(a3 + 8));
  BOOL v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id) {
    BOOL v10 = v9;
  }
  else {
    BOOL v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.expand_dims", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.expand_dims";
    v17[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ExpandDimsOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  BOOL v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ExpandDimsOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mpsx::QuantizedGatherOp,mlir::Value &,mlir::Value,mlir::Value,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Type,unsigned int,BOOL>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, unsigned int *a10, char *a11)
{
  v30[38] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v25);
  uint64_t v20 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.quantized_gather", (const unsigned __int8 *)0x15, Context);
  if (!v21)
  {
    __int16 v29 = 1283;
    v28[2] = (uint64_t)"mpsx.quantized_gather";
    void v28[3] = 21;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v27 = 259;
    llvm::operator+(v28, (uint64_t *)&v26, (uint64_t)v30);
    llvm::report_fatal_error((llvm::Twine *)v30, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v20);
  mlir::mpsx::QuantizedGatherOp::build(a1, (uint64_t)v30, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, *a11);
  uint64_t v22 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v30);
  if (*(_UNKNOWN **)(*((void *)v22 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::QuantizedGatherOp,void>::id) {
    unint64_t v23 = v22;
  }
  else {
    unint64_t v23 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v23;
}

void mlir::mps::anonymous namespace'::CanonicalizeMatMulTransposeConstantRHS::~CanonicalizeMatMulTransposeConstantRHS(mlir::mps::_anonymous_namespace_::CanonicalizeMatMulTransposeConstantRHS *this)
{
  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  int v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeMatMulTransposeConstantRHS::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v36[1] = *MEMORY[0x1E4F143B8];
  uint64_t v34 = a2;
  uint64_t Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v34);
  uint64_t v33 = Filter;
  BOOL v5 = (uint64_t *)(Filter[1] & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  char v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    BOOL v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v32[0] = v5;
  v32[1] = v15;
  if (!*Filter
    || *(void *)*Filter
    || mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v34)
    || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32))
  {
    return 0;
  }
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32);
  if (v17)
  {
    uint64_t v18 = 8 * v17;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v18 -= 8;
      if (!v18) {
        goto LABEL_19;
      }
    }
    return 0;
  }
LABEL_19:
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32);
  if (v19 < 2) {
    return 0;
  }
  v35[0] = Filter;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v35);
  if (!DefiningOp) {
    return 0;
  }
  uint64_t v21 = DefiningOp;
  uint64_t v22 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(void, uint64_t))(**(void **)(v21 + 48) + 32))(*(void *)(v21 + 48), v22)) {
    return 0;
  }
  uint64_t v23 = *(void *)(v34 + 24);
  LODWORD(Input) = -1;
  unsigned int v31 = -2;
  v35[0] = v36;
  v35[1] = (void *)0x100000000;
  mlir::OpBuilder::createOrFold<mlir::mps::TransposeOp,mlir::Value &,int,int>((mlir::mps::ConstantOp *)(a3 + 8), (uint64_t)v35, v23, (uint64_t *)&v33, (unsigned int *)&Input, &v31);
  unint64_t v24 = *(void **)v35[0];
  if (v35[0] != v36) {
    free(v35[0]);
  }
  v35[0] = v24;
  uint64_t v25 = v34;
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v34);
  LOBYTE(v31) = mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v34);
  uint64_t v26 = 1;
  unsigned __int8 v29 = 1;
  __int16 v27 = mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value,mlir::Value,BOOL,BOOL>((mlir::BoolAttr **)(a3 + 8), *(void *)(v25 + 24), &Input, (uint64_t *)v35, (unsigned __int8 *)&v31, &v29);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, v25, v27);
  return v26;
}

void mlir::OpBuilder::createOrFold<mlir::mps::TransposeOp,mlir::Value &,int,int>(mlir::mps::ConstantOp *a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int *a5, unsigned int *a6)
{
  v27[38] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = a3;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.transpose", (const unsigned __int8 *)0xD, Context);
  if (!v14)
  {
    __int16 v26 = 1283;
    void v25[2] = (uint64_t)"mps.transpose";
    v25[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v27, a3, v13);
  mlir::mps::TransposeOp::build(a1, v27, *a4, *a5, *a6);
  __int16 v16 = (mlir::GenericProgramPoint *)mlir::Operation::create((mlir::Operation *)v27, v15);
  uint64_t v17 = *((void *)a1 + 2);
  if (v17)
  {
    uint64_t v18 = (uint64_t *)*((void *)a1 + 3);
    llvm::ilist_traits<mlir::Operation>::addNodeToList(v17 + 32, (uint64_t)v16);
    mlir::GenericProgramPoint::~GenericProgramPoint(v16);
    uint64_t v19 = *v18;
    *uint64_t v20 = *v18;
    v20[1] = (uint64_t)v18;
    *(void *)(v19 + 8) = v20;
    *uint64_t v18 = (uint64_t)v20;
    mlir::GenericProgramPoint::~GenericProgramPoint(v16);
  }
  if (mlir::OpBuilder::tryFold(a1, (uint64_t)v16, a2))
  {
    mlir::Operation::erase(v16);
  }
  else
  {
    uint64_t v21 = *((void *)a1 + 1);
    if (v21) {
      (*(void (**)(uint64_t, mlir::GenericProgramPoint *))(*(void *)v21 + 16))(v21, v16);
    }
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v27);
}

void *mlir::mps::anonymous namespace'::CanonicalizeNCHWConv2DConstWeightsToHWIO<mlir::mps::Conv2DOp>::~CanonicalizeNCHWConv2DConstWeightsToHWIO(void *a1)
{
  int v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::mps::anonymous namespace'::CanonicalizeNCHWConv2DConstWeightsToHWIO<mlir::mps::Conv2DOp>::~CanonicalizeNCHWConv2DConstWeightsToHWIO(void *__p)
{
  int v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeNCHWConv2DConstWeightsToHWIO<mlir::mps::Conv2DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v26 = a2;
  uint64_t Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v26);
  BOOL v5 = (uint64_t *)(Filter[1] & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  char v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v25[0] = v5;
  v25[1] = v15;
  if (!*Filter || *(void *)*Filter) {
    return 0;
  }
  uint64_t result = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v25);
  if (result)
  {
    uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v25);
    if (v18)
    {
      uint64_t v19 = 8 * v18;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v19 -= 8;
        if (!v19) {
          goto LABEL_20;
        }
      }
      return 0;
    }
LABEL_20:
    if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v26)
      || mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v26) != 2)
    {
      return 0;
    }
    v24[0] = Filter;
    uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)v24);
    if (result)
    {
      uint64_t v20 = result;
      uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
      uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21);
      if (result)
      {
        uint64_t v22 = v26;
        if (v26) {
          uint64_t InterfaceFor = mlir::OpInterface<mlir::ConvertOpLayoutInterface,mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits>::getInterfaceFor(v26);
        }
        else {
          uint64_t InterfaceFor = 0;
        }
        v24[0] = v22;
        v24[1] = InterfaceFor;
        return mlir::ConvertOpLayoutInterface::convertLayout((uint64_t)v24, 0, 2, a3);
      }
    }
  }
  return result;
}

void *mlir::mps::anonymous namespace'::CanonicalizeNCHWConv2DConstWeightsToHWIO<mlir::mps::Conv2DDataGradientOp>::~CanonicalizeNCHWConv2DConstWeightsToHWIO(void *a1)
{
  int v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::mps::anonymous namespace'::CanonicalizeNCHWConv2DConstWeightsToHWIO<mlir::mps::Conv2DDataGradientOp>::~CanonicalizeNCHWConv2DConstWeightsToHWIO(void *__p)
{
  int v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::Conv2DDataGradientOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::Conv2DDataGradientOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::Conv2DDataGradientOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeNCHWConv2DConstWeightsToHWIO<mlir::mps::Conv2DDataGradientOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v26 = a2;
  uint64_t Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v26);
  BOOL v5 = (uint64_t *)(Filter[1] & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  char v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v25[0] = v5;
  v25[1] = v15;
  if (!*Filter || *(void *)*Filter) {
    return 0;
  }
  uint64_t result = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v25);
  if (result)
  {
    uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v25);
    if (v18)
    {
      uint64_t v19 = 8 * v18;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v19 -= 8;
        if (!v19) {
          goto LABEL_20;
        }
      }
      return 0;
    }
LABEL_20:
    if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v26)
      || mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v26) != 2)
    {
      return 0;
    }
    v24[0] = Filter;
    uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)v24);
    if (result)
    {
      uint64_t v20 = result;
      uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
      uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21);
      if (result)
      {
        uint64_t v22 = v26;
        if (v26) {
          uint64_t InterfaceFor = mlir::OpInterface<mlir::ConvertOpLayoutInterface,mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits>::getInterfaceFor(v26);
        }
        else {
          uint64_t InterfaceFor = 0;
        }
        v24[0] = v22;
        v24[1] = InterfaceFor;
        return mlir::ConvertOpLayoutInterface::convertLayout((uint64_t)v24, 0, 2, a3);
      }
    }
  }
  return result;
}

void *mlir::mps::anonymous namespace'::CanonicalizeNCHWConv2DConstWeightsToHWIO<mlir::mps::DepthwiseConv2DOp>::~CanonicalizeNCHWConv2DConstWeightsToHWIO(void *a1)
{
  int v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::mps::anonymous namespace'::CanonicalizeNCHWConv2DConstWeightsToHWIO<mlir::mps::DepthwiseConv2DOp>::~CanonicalizeNCHWConv2DConstWeightsToHWIO(void *__p)
{
  int v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::mps::anonymous namespace'::CanonicalizeNCHWConv2DConstWeightsToHWIO<mlir::mps::DepthwiseConv2DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v26 = a2;
  uint64_t Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v26);
  BOOL v5 = (uint64_t *)(Filter[1] & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  char v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v25[0] = v5;
  v25[1] = v15;
  if (!*Filter || *(void *)*Filter) {
    return 0;
  }
  uint64_t result = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v25);
  if (result)
  {
    uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v25);
    if (v18)
    {
      uint64_t v19 = 8 * v18;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v19 -= 8;
        if (!v19) {
          goto LABEL_20;
        }
      }
      return 0;
    }
LABEL_20:
    if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v26)
      || mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v26) != 2)
    {
      return 0;
    }
    v24[0] = Filter;
    uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)v24);
    if (result)
    {
      uint64_t v20 = result;
      uint64_t v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
      uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(v20 + 48) + 32))(*(void *)(v20 + 48), v21);
      if (result)
      {
        uint64_t v22 = v26;
        if (v26) {
          uint64_t InterfaceFor = mlir::OpInterface<mlir::ConvertOpLayoutInterface,mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits>::getInterfaceFor(v26);
        }
        else {
          uint64_t InterfaceFor = 0;
        }
        v24[0] = v22;
        v24[1] = InterfaceFor;
        return mlir::ConvertOpLayoutInterface::convertLayout((uint64_t)v24, 0, 2, a3);
      }
    }
  }
  return result;
}

uint64_t mlir::mps::createConstantsConversionPass@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x560uLL);
  *(void *)uint64_t v5 = &unk_1EC9C9428;
  *(_DWORD *)(v5 + 472) = *(_DWORD *)a1;
  uint64_t v6 = *(void *)(v5 + 936);
  if (!v6) {
    goto LABEL_5;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 48))(v6, a1);
  v4[1088] = *(unsigned char *)(a1 + 4);
  uint64_t v7 = *((void *)v4 + 143);
  if (!v7) {
    goto LABEL_5;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 48))(v7, a1 + 4);
  char v9 = *(unsigned char *)(a1 + 5);
  uint64_t v8 = a1 + 5;
  v4[1296] = v9;
  uint64_t v10 = *((void *)v4 + 169);
  if (v10)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v10 + 48))(v10, v8);
    *a2 = v4;
  }
  else
  {
LABEL_5:
    uint64_t v12 = std::__throw_bad_function_call[abi:nn180100]();
  }
  return result;
}

uint64_t mlir::mps::MPSConstantsConversionBase<mlir::mps::anonymous namespace'::ConstantsConversionPass>::MPSConstantsConversionBase(uint64_t a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 16) = "builtin.module";
  *(void *)(a1 + 24) = 14;
  *(unsigned char *)(a1 + 32) = 1;
  *(unsigned char *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 120) = 0;
  int v2 = (void *)(a1 + 152);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = a1 + 200;
  *(void *)(a1 + 192) = 0x400000000;
  *(void *)(a1 + 232) = a1 + 248;
  *(void *)(a1 + 240) = 0x400000000;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 296) = 0x1000000000;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(void *)(a1 + 336) = 0;
  *(void *)a1 = &unk_1EC9CA928;
  *(void *)&long long v6 = "The type of conversion to apply to the constant attributes.";
  *((void *)&v6 + 1) = 59;
  int v4 = 0;
  uint64_t v5 = &v4;
  v7.n128_u64[0] = (unint64_t)v8;
  v8[0] = "none";
  v8[1] = 4;
  int v9 = 0;
  uint64_t v10 = "The constant attribute type is not changed.";
  uint64_t v11 = 43;
  uint64_t v12 = "dense";
  uint64_t v13 = 5;
  int v14 = 1;
  uint64_t v15 = "The constant attribute type is converted to DenseElementsAttr.";
  uint64_t v16 = 62;
  uint64_t v17 = "buffer-tensors";
  uint64_t v18 = 14;
  uint64_t v20 = "The constant attribute type is converted to MPSBufferTensorAttr with each attribute backed by its own resource blob.";
  uint64_t v21 = 116;
  uint64_t v22 = "coalesced-buffer-tensors";
  uint64_t v23 = 24;
  int v19 = 2;
  int v24 = 3;
  uint64_t v25 = "The constant attribute type is converted to MPSBufferTensorAttr with all attributes coalesced and backed by a si"
        "ngle resource blob.";
  uint64_t v26 = 131;
  v7.n128_u64[1] = 0x400000004;
  mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::Option<llvm::cl::desc,llvm::cl::initializer<mlir::mps::ConstantAttributeConversionType>,llvm::cl::ValuesClass>((void *)(a1 + 344), (void *)(a1 + 152), (uint64_t)"conversion-type", 15, &v6, &v5, (uint64_t *)&v7);
  *(void *)(a1 + 344) = &unk_1EC9CAE20;
  *(void *)(a1 + 944) = &unk_1EC9CAEA0;
  if ((void *)v7.n128_u64[0] != v8) {
    free((void *)v7.n128_u64[0]);
  }
  v7.n128_u64[0] = (unint64_t)"Cast all constants attributes to the same ElementType than the op.";
  v7.n128_u64[1] = 66;
  LOBYTE(v5) = 0;
  *(void *)&long long v6 = &v5;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 960), v2, (uint64_t)"cast-to-op-type", 15, &v7, (unsigned char **)&v6);
  *(void *)(a1 + 960) = &unk_1EC9CB060;
  *(void *)(a1 + 1152) = &unk_1EC9CB0E0;
  v7.n128_u64[0] = (unint64_t)"Perform clipping to range of values of the output type before casting.";
  v7.n128_u64[1] = 70;
  LOBYTE(v5) = 0;
  *(void *)&long long v6 = &v5;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 1168), v2, (uint64_t)"clip-to-limits", 14, &v7, (unsigned char **)&v6);
  *(void *)(a1 + 1168) = &unk_1EC9CB060;
  *(void *)(a1 + 1360) = &unk_1EC9CB0E0;
  return a1;
}

void mlir::mps::anonymous namespace'::ConstantsConversionPass::~ConstantsConversionPass(mlir::mps::_anonymous_namespace_::ConstantsConversionPass *this)
{
  *(void *)this = &unk_1EC9CA928;
  *((void *)this + 146) = &unk_1EC9A3F00;
  int v2 = (char *)this + 1328;
  uint64_t v3 = (char *)*((void *)this + 169);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  *((void *)this + 146) = &unk_1EC9A42A8;
  int v4 = (void *)*((void *)this + 158);
  if (v4 != *((void **)this + 157)) {
    free(v4);
  }
  uint64_t v5 = (char *)*((void *)this + 154);
  if (v5 != (char *)this + 1248) {
    free(v5);
  }
  *((void *)this + 120) = &unk_1EC9A3F00;
  long long v6 = (mlir::mps::_anonymous_namespace_::ConstantsConversionPass *)*((void *)this + 143);
  if (v6 == (mlir::mps::_anonymous_namespace_::ConstantsConversionPass *)((char *)this + 1120))
  {
    (*(void (**)(char *))(*((void *)this + 140) + 32))((char *)this + 1120);
  }
  else if (v6)
  {
    (*(void (**)(mlir::mps::_anonymous_namespace_::ConstantsConversionPass *))(*(void *)v6 + 40))(v6);
  }
  *((void *)this + 120) = &unk_1EC9A42A8;
  __n128 v7 = (void *)*((void *)this + 132);
  if (v7 != *((void **)this + 131)) {
    free(v7);
  }
  uint64_t v8 = (char *)*((void *)this + 128);
  if (v8 != (char *)this + 1040) {
    free(v8);
  }
  mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::~Option((void *)this + 43);

  mlir::Pass::~Pass(this);
}

{
  void *v1;
  uint64_t vars8;

  operator delete(v1);
}

const char *mlir::mps::MPSConstantsConversionBase<mlir::mps::anonymous namespace'::ConstantsConversionPass>::getName()
{
  return "MPSConstantsConversion";
}

const char *mlir::mps::MPSConstantsConversionBase<mlir::mps::anonymous namespace'::ConstantsConversionPass>::getArgument()
{
  return "mps-constants-conversion";
}

const char *mlir::mps::MPSConstantsConversionBase<mlir::mps::anonymous namespace'::ConstantsConversionPass>::getDescription()
{
  return "Convert attributes of mps.Constant op between dense / Buffer Tensor.";
}

void mlir::mps::anonymous namespace'::ConstantsConversionPass::runOnOperation(mlir::mps::_anonymous_namespace_::ConstantsConversionPass *this)
{
  uint64_t v1 = this;
  uint64_t v141 = *MEMORY[0x1E4F143B8];
  int v2 = (unsigned int *)(*((void *)this + 5) & 0xFFFFFFFFFFFFFFF8);
  if (*((_DWORD *)this + 118) <= 2u)
  {
    Context = (void *)mlir::Attribute::getContext((mlir::Attribute *)(v2 + 6));
    *(_OWORD *)__p = 0u;
    long long v120 = 0u;
    uint64_t v121 = v123;
    uint64_t v122 = 0x600000000;
    uint64_t v124 = 0;
    uint64_t v125 = 0;
    unsigned int v126 = 0;
    uint64_t v127 = 0;
    uint64_t v128 = 0;
    uint64_t v129 = 0x2800000000;
    v130 = 0;
    uint64_t v131 = 0;
    uint64_t v132 = 0x2800000000;
    uint64_t v3 = (unsigned int *)operator new(0x68uLL);
    unsigned int v4 = *((_DWORD *)v1 + 118);
    char v5 = *((unsigned char *)v1 + 1088);
    char v6 = *((unsigned char *)v1 + 1296);
    mlir::PatternBenefit::PatternBenefit(&v136, 1);
    mlir::Pattern::Pattern((uint64_t)(v3 + 2), (uint64_t)"mps.constant", 12, (__int16)v136, (uint64_t)Context, 0, 0);
    *(void *)uint64_t v3 = &unk_1EC9C7F50;
    v3[24] = v4;
    *((unsigned char *)v3 + 100) = v5;
    *((unsigned char *)v3 + 101) = v6;
    if (!*((void *)v3 + 9))
    {
      uint64_t v136 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::ConvertConstant]";
      *(void *)&long long v137 = 99;
      unint64_t v7 = llvm::StringRef::find((uint64_t *)&v136, "DesiredTypeName = ", 0x12uLL, 0);
      if ((unint64_t)v137 >= v7) {
        uint64_t v8 = v7;
      }
      else {
        uint64_t v8 = v137;
      }
      int v9 = &v136[v8];
      uint64_t v10 = v137 - v8;
      if ((unint64_t)(v137 - v8) >= 0x12) {
        uint64_t v11 = 18;
      }
      else {
        uint64_t v11 = v137 - v8;
      }
      uint64_t v12 = &v9[v11];
      unint64_t v13 = v10 - v11;
      if (v13 >= v13 - 1) {
        --v13;
      }
      *((void *)v3 + 8) = v12;
      *((void *)v3 + 9) = v13;
    }
    unint64_t v14 = v3[22];
    if (v14 > v3[23])
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v3 + 20), v3 + 24, v14, 16);
      LODWORD(v14) = v3[22];
    }
    v3[22] = v14;
    uint64_t v15 = (char *)__p[1];
    if (__p[1] < (void *)v120)
    {
      *(void *)__p[1] = v3;
      uint64_t v16 = v15 + 8;
      goto LABEL_65;
    }
    uint64_t v30 = (char *)__p[0];
    int64_t v31 = (char *)__p[1] - (char *)__p[0];
    int64_t v32 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v33 = v32 + 1;
    if (!((unint64_t)(v32 + 1) >> 61))
    {
      uint64_t v34 = v120 - (unint64_t)__p[0];
      if ((uint64_t)(v120 - (unint64_t)__p[0]) >> 2 > v33) {
        unint64_t v33 = v34 >> 2;
      }
      if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v35 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v35 = v33;
      }
      if (!v35)
      {
        unint64_t v36 = 0;
        goto LABEL_50;
      }
      if (!(v35 >> 61))
      {
        unint64_t v36 = (char *)operator new(8 * v35);
LABEL_50:
        unint64_t v44 = &v36[8 * v32];
        unint64_t v45 = &v36[8 * v35];
        *(void *)unint64_t v44 = v3;
        uint64_t v16 = v44 + 8;
        if (v15 == v30)
        {
          __p[0] = &v36[8 * v32];
          __p[1] = v44 + 8;
          *(void *)&long long v120 = v45;
        }
        else
        {
          unint64_t v46 = v15 - v30 - 8;
          if (v46 < 0x78
            || &v15[-(v46 & 0xFFFFFFFFFFFFFFF8) - 8] < v44 && &v36[v31 - (v46 & 0xFFFFFFFFFFFFFFF8) - 8] < v15)
          {
            goto LABEL_161;
          }
          uint64_t v47 = (v46 >> 3) + 1;
          uint64_t v48 = 8 * (v47 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v49 = &v15[-v48];
          v44 -= v48;
          unsigned int v50 = &v36[8 * v32 - 16];
          unint64_t v51 = v15 - 16;
          uint64_t v52 = v47 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v54 = *((_OWORD *)v51 - 1);
            long long v53 = *(_OWORD *)v51;
            *((_OWORD *)v51 - 1) = 0uLL;
            *(_OWORD *)unint64_t v51 = 0uLL;
            *((_OWORD *)v50 - 1) = v54;
            *(_OWORD *)unsigned int v50 = v53;
            v50 -= 32;
            v51 -= 32;
            v52 -= 4;
          }
          while (v52);
          uint64_t v15 = v49;
          if (v47 != (v47 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_161:
            do
            {
              uint64_t v55 = *((void *)v15 - 1);
              v15 -= 8;
              *(void *)uint64_t v15 = 0;
              *((void *)v44 - 1) = v55;
              v44 -= 8;
            }
            while (v15 != v30);
          }
          uint64_t v15 = (char *)__p[0];
          std::string::size_type v56 = (char *)__p[1];
          __p[0] = v44;
          __p[1] = v16;
          *(void *)&long long v120 = v45;
          while (v56 != v15)
          {
            uint64_t v58 = *((void *)v56 - 1);
            v56 -= 8;
            uint64_t v57 = v58;
            *(void *)std::string::size_type v56 = 0;
            if (v58) {
              (*(void (**)(uint64_t))(*(void *)v57 + 8))(v57);
            }
          }
        }
        if (v15) {
          operator delete(v15);
        }
LABEL_65:
        __p[1] = v16;
        mlir::FrozenRewritePatternSet::FrozenRewritePatternSet(&v133, &Context, 0, 0, 0, 0);
        unint64_t v59 = v2[11];
        if ((v59 & 0x7FFFFF) != 0)
        {
          std::string::size_type v60 = (mlir::Region **)((((unint64_t)&v2[4 * ((v59 >> 23) & 1) + 16]
                                  + ((v59 >> 21) & 0x7F8)) & 0xFFFFFFFFFFFFFFF8)
                                + 32 * v2[10]);
          LOBYTE(v115) = 0;
          LOWORD(v136) = 256;
          *(_DWORD *)((char *)&v136 + 2) = 0;
          HIWORD(v136) = 0;
          long long v137 = xmmword_1810FE4B0;
          uint64_t v139 = 0;
          uint64_t v140 = 0;
          uint64_t v138 = 0;
          mlir::applyPatternsAndFoldGreedily(v60, (const mlir::FrozenRewritePatternSet *)&v133, (long long *)&v136, (BOOL *)&v115);
        }
        mlir::FrozenRewritePatternSet::~FrozenRewritePatternSet((mlir::FrozenRewritePatternSet *)&v133);
        if (HIDWORD(v131) && v131)
        {
          uint64_t v61 = 0;
          do
          {
            uint64_t v62 = *(llvm **)((char *)v130 + v61);
            if (v62 != (llvm *)-8 && v62 != 0)
            {
              uint64_t v64 = *(void *)v62;
              __int16 v65 = (void *)*((void *)v62 + 4);
              if (v65 == (void *)((char *)v62 + 8))
              {
                (*(void (**)(void *))(*((void *)v62 + 1) + 32))((void *)v62 + 1);
              }
              else if (v65)
              {
                (*(void (**)(void *))(*v65 + 40))(v65);
              }
              llvm::deallocate_buffer(v62, (void *)(v64 + 41));
            }
            v61 += 8;
          }
          while (8 * v131 != v61);
        }
        free(v130);
        if (HIDWORD(v128) && v128)
        {
          uint64_t v66 = 0;
          do
          {
            uint64_t v67 = *(llvm **)((char *)v127 + v66);
            if (v67 != (llvm *)-8 && v67 != 0)
            {
              uint64_t v69 = *(void *)v67;
              uint64_t v70 = (void *)*((void *)v67 + 4);
              if (v70 == (void *)((char *)v67 + 8))
              {
                (*(void (**)(void *))(*((void *)v67 + 1) + 32))((void *)v67 + 1);
              }
              else if (v70)
              {
                (*(void (**)(void *))(*v70 + 40))(v70);
              }
              llvm::deallocate_buffer(v67, (void *)(v69 + 41));
            }
            v66 += 8;
          }
          while (8 * v128 != v66);
        }
        free(v127);
        llvm::deallocate_buffer(v124, (void *)(16 * v126));
      }
LABEL_158:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
LABEL_157:
    abort();
  }
  if (*((unsigned char *)this + 1088))
  {
    Context = (void *)mlir::Attribute::getContext((mlir::Attribute *)(v2 + 6));
    *(_OWORD *)__p = 0u;
    long long v120 = 0u;
    uint64_t v121 = v123;
    uint64_t v122 = 0x600000000;
    uint64_t v124 = 0;
    uint64_t v125 = 0;
    unsigned int v126 = 0;
    uint64_t v127 = 0;
    uint64_t v128 = 0;
    uint64_t v129 = 0x2800000000;
    v130 = 0;
    uint64_t v131 = 0;
    uint64_t v132 = 0x2800000000;
    uint64_t v17 = (unsigned int *)operator new(0x68uLL);
    char v18 = *((unsigned char *)v1 + 1088);
    char v19 = *((unsigned char *)v1 + 1296);
    mlir::PatternBenefit::PatternBenefit(&v136, 1);
    mlir::Pattern::Pattern((uint64_t)(v17 + 2), (uint64_t)"mps.constant", 12, (__int16)v136, (uint64_t)Context, 0, 0);
    *(void *)uint64_t v17 = &unk_1EC9C7F50;
    v17[24] = 0;
    *((unsigned char *)v17 + 100) = v18;
    *((unsigned char *)v17 + 101) = v19;
    if (!*((void *)v17 + 9))
    {
      uint64_t v136 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::ConvertConstant]";
      *(void *)&long long v137 = 99;
      unint64_t v20 = llvm::StringRef::find((uint64_t *)&v136, "DesiredTypeName = ", 0x12uLL, 0);
      if ((unint64_t)v137 >= v20) {
        uint64_t v21 = v20;
      }
      else {
        uint64_t v21 = v137;
      }
      uint64_t v22 = &v136[v21];
      uint64_t v23 = v137 - v21;
      if ((unint64_t)(v137 - v21) >= 0x12) {
        uint64_t v24 = 18;
      }
      else {
        uint64_t v24 = v137 - v21;
      }
      uint64_t v25 = &v22[v24];
      unint64_t v26 = v23 - v24;
      if (v26 >= v26 - 1) {
        --v26;
      }
      *((void *)v17 + 8) = v25;
      *((void *)v17 + 9) = v26;
    }
    unint64_t v27 = v17[22];
    if (v27 > v17[23])
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v17 + 20), v17 + 24, v27, 16);
      LODWORD(v27) = v17[22];
    }
    v17[22] = v27;
    std::string::size_type v28 = (char *)__p[1];
    if (__p[1] >= (void *)v120)
    {
      unint64_t v37 = (char *)__p[0];
      int64_t v38 = (char *)__p[1] - (char *)__p[0];
      int64_t v39 = ((char *)__p[1] - (char *)__p[0]) >> 3;
      unint64_t v40 = v39 + 1;
      if ((unint64_t)(v39 + 1) >> 61) {
        goto LABEL_157;
      }
      uint64_t v41 = v120 - (unint64_t)__p[0];
      if ((uint64_t)(v120 - (unint64_t)__p[0]) >> 2 > v40) {
        unint64_t v40 = v41 >> 2;
      }
      if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v42 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v42 = v40;
      }
      if (v42)
      {
        if (v42 >> 61) {
          goto LABEL_158;
        }
        uint64_t v43 = (char *)operator new(8 * v42);
      }
      else
      {
        uint64_t v43 = 0;
      }
      int32x4_t v71 = &v43[8 * v39];
      uint64_t v72 = &v43[8 * v42];
      *(void *)int32x4_t v71 = v17;
      unsigned __int8 v29 = v71 + 8;
      if (v28 == v37)
      {
        __p[0] = &v43[8 * v39];
        __p[1] = v71 + 8;
        *(void *)&long long v120 = v72;
      }
      else
      {
        unint64_t v73 = v28 - v37 - 8;
        if (v73 < 0x78
          || &v28[-(v73 & 0xFFFFFFFFFFFFFFF8) - 8] < v71 && &v43[v38 - (v73 & 0xFFFFFFFFFFFFFFF8) - 8] < v28)
        {
          goto LABEL_162;
        }
        uint64_t v74 = (v73 >> 3) + 1;
        uint64_t v75 = 8 * (v74 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v76 = &v28[-v75];
        v71 -= v75;
        char v77 = &v43[8 * v39 - 16];
        uint64_t v78 = v28 - 16;
        uint64_t v79 = v74 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v81 = *((_OWORD *)v78 - 1);
          long long v80 = *(_OWORD *)v78;
          *((_OWORD *)v78 - 1) = 0uLL;
          *(_OWORD *)uint64_t v78 = 0uLL;
          *((_OWORD *)v77 - 1) = v81;
          *(_OWORD *)char v77 = v80;
          v77 -= 32;
          v78 -= 32;
          v79 -= 4;
        }
        while (v79);
        std::string::size_type v28 = v76;
        if (v74 != (v74 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_162:
          do
          {
            uint64_t v82 = *((void *)v28 - 1);
            v28 -= 8;
            *(void *)std::string::size_type v28 = 0;
            *((void *)v71 - 1) = v82;
            v71 -= 8;
          }
          while (v28 != v37);
        }
        std::string::size_type v28 = (char *)__p[0];
        uint64_t v83 = (char *)__p[1];
        __p[0] = v71;
        __p[1] = v29;
        *(void *)&long long v120 = v72;
        while (v83 != v28)
        {
          uint64_t v85 = *((void *)v83 - 1);
          v83 -= 8;
          uint64_t v84 = v85;
          *(void *)uint64_t v83 = 0;
          if (v85) {
            (*(void (**)(uint64_t))(*(void *)v84 + 8))(v84);
          }
        }
      }
      if (v28) {
        operator delete(v28);
      }
    }
    else
    {
      *(void *)__p[1] = v17;
      unsigned __int8 v29 = v28 + 8;
    }
    __p[1] = v29;
    mlir::FrozenRewritePatternSet::FrozenRewritePatternSet(&v133, &Context, 0, 0, 0, 0);
    unint64_t v86 = v2[11];
    if ((v86 & 0x7FFFFF) != 0)
    {
      uint64_t v87 = (mlir::Region **)((((unint64_t)&v2[4 * ((v86 >> 23) & 1) + 16] + ((v86 >> 21) & 0x7F8)) & 0xFFFFFFFFFFFFFFF8)
                            + 32 * v2[10]);
      LOBYTE(v115) = 0;
      LOWORD(v136) = 256;
      *(_DWORD *)((char *)&v136 + 2) = 0;
      HIWORD(v136) = 0;
      long long v137 = xmmword_1810FE4B0;
      uint64_t v139 = 0;
      uint64_t v140 = 0;
      uint64_t v138 = 0;
      mlir::applyPatternsAndFoldGreedily(v87, (const mlir::FrozenRewritePatternSet *)&v133, (long long *)&v136, (BOOL *)&v115);
    }
    mlir::FrozenRewritePatternSet::~FrozenRewritePatternSet((mlir::FrozenRewritePatternSet *)&v133);
    if (HIDWORD(v131) && v131)
    {
      uint64_t v88 = 0;
      do
      {
        uint64_t v89 = *(llvm **)((char *)v130 + v88);
        if (v89 != (llvm *)-8 && v89 != 0)
        {
          uint64_t v91 = *(void *)v89;
          uint64_t v92 = (void *)*((void *)v89 + 4);
          if (v92 == (void *)((char *)v89 + 8))
          {
            (*(void (**)(void *))(*((void *)v89 + 1) + 32))((void *)v89 + 1);
          }
          else if (v92)
          {
            (*(void (**)(void *))(*v92 + 40))(v92);
          }
          llvm::deallocate_buffer(v89, (void *)(v91 + 41));
        }
        v88 += 8;
      }
      while (8 * v131 != v88);
    }
    free(v130);
    if (HIDWORD(v128) && v128)
    {
      uint64_t v93 = 0;
      do
      {
        uint64_t v94 = *(llvm **)((char *)v127 + v93);
        if (v94 != (llvm *)-8 && v94 != 0)
        {
          uint64_t v96 = *(void *)v94;
          uint64_t v97 = (void *)*((void *)v94 + 4);
          if (v97 == (void *)((char *)v94 + 8))
          {
            (*(void (**)(void *))(*((void *)v94 + 1) + 32))((void *)v94 + 1);
          }
          else if (v97)
          {
            (*(void (**)(void *))(*v97 + 40))(v97);
          }
          llvm::deallocate_buffer(v94, (void *)(v96 + 41));
        }
        v93 += 8;
      }
      while (8 * v128 != v93);
    }
    free(v127);
    llvm::deallocate_buffer(v124, (void *)(16 * v126));
  }
  uint64_t v136 = (char *)&v137 + 8;
  *(void *)&long long v137 = 0xA00000000;
  v133 = v135;
  uint64_t v134 = 0xA00000000;
  Context = &__p[1];
  __p[0] = (void *)0xA00000000;
  unint64_t v115 = &v136;
  uint64_t v116 = &v133;
  p_Context = &Context;
  uint64_t v111 = &v115;
  mlir::detail::walk<mlir::ForwardIterator>((mlir::ForwardIterator *)v2, (mlir::Operation *)_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_3mps12_GLOBAL__N_123ConstantsConversionPass31convertToCoalescedBufferTensorsENS1_8ModuleOpEEUlNSB_10ConstantOpEE_SF_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESO_E4typeES3_OT1_EUlS3_E_EEvlS3_, (uint64_t)&v111, 1);
  unsigned int v98 = v137;
  if (v137 >= 2)
  {
    uint64_t v109 = v1;
    mlir::mps::getBufferTensorAttrs((mlir::Attribute *)v133, v134, (const void **)Context, LODWORD(__p[0]), (uint64_t)&v115);
    v112[0] = mlir::Attribute::getContext((mlir::Attribute *)(v2 + 6));
    v112[1] = 0;
    uint64_t v113 = 0;
    uint64_t v114 = 0;
    uint64_t v111 = (void **)&unk_1EC9A4978;
    if (v137 && v116)
    {
      uint64_t v99 = (mlir::GenericProgramPoint **)v136;
      uint64_t v100 = (uint64_t **)v115;
      uint64_t v101 = 8 * v116 - 8;
      uint64_t v102 = 8 * v137 - 8;
      uint64_t v103 = v136;
      do
      {
        uint64_t v104 = *((void *)*v99 + 2);
        mlir::GenericProgramPoint::~GenericProgramPoint(*v99);
        uint64_t v113 = v104;
        uint64_t v114 = v105;
        uint64_t v106 = *(void *)v103;
        v103 += 8;
        unint64_t v110 = *(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v99) + 8) & 0xFFFFFFFFFFFFFFF8;
        uint64_t v107 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::MemRefType &,mlir::mps::MPSBufferTensorAttr &>((mlir::OpBuilder *)v112, *(void *)(v106 + 24), (uint64_t *)&v110, v100);
        ((void (*)(void ***, uint64_t, mlir::GenericProgramPoint *))v111[4])(&v111, v106, v107);
        if (!v102) {
          break;
        }
        ++v100;
        uint64_t v108 = v101;
        v101 -= 8;
        v102 -= 8;
        uint64_t v99 = (mlir::GenericProgramPoint **)v103;
      }
      while (v108);
    }
    mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v111);
    if (v115 != &p_Context) {
      free(v115);
    }
    uint64_t v1 = v109;
  }
  if (Context != &__p[1]) {
    free(Context);
  }
  if (v133 != v135) {
    free(v133);
  }
  if (v136 != (char *)&v137 + 8) {
    free(v136);
  }
  if (v98 <= 1) {
    *((void *)v1 + 5) |= 4uLL;
  }
}

void *mlir::mps::MPSConstantsConversionBase<mlir::mps::anonymous namespace'::ConstantsConversionPass>::clonePass@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = (char *)operator new(0x560uLL);
  uint64_t v5 = *(void *)(a1 + 8);
  *((_OWORD *)v4 + 1) = *(_OWORD *)(a1 + 16);
  *((void *)v4 + 4) = *(void *)(a1 + 32);
  *((void *)v4 + 1) = v5;
  v4[40] = 0;
  v4[120] = 0;
  char v6 = v4 + 152;
  *((_OWORD *)v4 + 8) = 0u;
  *((_OWORD *)v4 + 9) = 0u;
  *((_OWORD *)v4 + 10) = 0u;
  *((void *)v4 + 22) = 0;
  *((void *)v4 + 23) = v4 + 200;
  *((void *)v4 + 24) = 0x400000000;
  *((void *)v4 + 29) = v4 + 248;
  *((void *)v4 + 30) = 0x400000000;
  *((void *)v4 + 35) = 0;
  *((void *)v4 + 36) = 0;
  *((_DWORD *)v4 + 74) = 0;
  *((_DWORD *)v4 + 75) = 16;
  *((_OWORD *)v4 + 19) = 0u;
  *((_OWORD *)v4 + 20) = 0u;
  *((void *)v4 + 42) = 0;
  *(void *)unsigned int v4 = &unk_1EC9CA928;
  *(void *)&long long v10 = "The type of conversion to apply to the constant attributes.";
  *((void *)&v10 + 1) = 59;
  int v8 = 0;
  int v9 = &v8;
  v11.n128_u64[0] = (unint64_t)v12;
  v12[0] = "none";
  v12[1] = 4;
  int v13 = 0;
  unint64_t v14 = "The constant attribute type is not changed.";
  uint64_t v15 = 43;
  uint64_t v16 = "dense";
  uint64_t v17 = 5;
  int v18 = 1;
  char v19 = "The constant attribute type is converted to DenseElementsAttr.";
  uint64_t v20 = 62;
  uint64_t v21 = "buffer-tensors";
  uint64_t v22 = 14;
  uint64_t v24 = "The constant attribute type is converted to MPSBufferTensorAttr with each attribute backed by its own resource blob.";
  uint64_t v25 = 116;
  unint64_t v26 = "coalesced-buffer-tensors";
  uint64_t v27 = 24;
  int v23 = 2;
  int v28 = 3;
  unsigned __int8 v29 = "The constant attribute type is converted to MPSBufferTensorAttr with all attributes coalesced and backed by a si"
        "ngle resource blob.";
  uint64_t v30 = 131;
  v11.n128_u64[1] = 0x400000004;
  mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::Option<llvm::cl::desc,llvm::cl::initializer<mlir::mps::ConstantAttributeConversionType>,llvm::cl::ValuesClass>((void *)v4 + 43, (void *)v4 + 19, (uint64_t)"conversion-type", 15, &v10, &v9, (uint64_t *)&v11);
  *((void *)v4 + 43) = &unk_1EC9CAE20;
  *((void *)v4 + 118) = &unk_1EC9CAEA0;
  if ((void *)v11.n128_u64[0] != v12) {
    free((void *)v11.n128_u64[0]);
  }
  v11.n128_u64[0] = (unint64_t)"Cast all constants attributes to the same ElementType than the op.";
  v11.n128_u64[1] = 66;
  LOBYTE(v9) = 0;
  *(void *)&long long v10 = &v9;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)v4 + 120, v6, (uint64_t)"cast-to-op-type", 15, &v11, (unsigned char **)&v10);
  *((void *)v4 + 120) = &unk_1EC9CB060;
  *((void *)v4 + 144) = &unk_1EC9CB0E0;
  v11.n128_u64[0] = (unint64_t)"Perform clipping to range of values of the output type before casting.";
  v11.n128_u64[1] = 70;
  LOBYTE(v9) = 0;
  *(void *)&long long v10 = &v9;
  uint64_t result = mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)v4 + 146, v6, (uint64_t)"clip-to-limits", 14, &v11, (unsigned char **)&v10);
  *((void *)v4 + 146) = &unk_1EC9CB060;
  *((void *)v4 + 170) = &unk_1EC9CB0E0;
  *(void *)unsigned int v4 = &unk_1EC9C9428;
  *a2 = v4;
  return result;
}

void *mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::Option<llvm::cl::desc,llvm::cl::initializer<mlir::mps::ConstantAttributeConversionType>,llvm::cl::ValuesClass>(void *a1, void *a2, uint64_t a3, uint64_t a4, _OWORD *a5, _DWORD **a6, uint64_t *a7)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  v32[0] = a3;
  v32[1] = a4;
  v35[0] = a2;
  uint64_t v9 = llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<mlir::mps::ConstantAttributeConversionType>,llvm::cl::ValuesClass>((uint64_t)a1, (uint64_t)v32, v35, a5, a6, a7);
  uint64_t v10 = v9 + 600;
  *(unsigned char *)(v9 + 608) = 0;
  *(void *)uint64_t v9 = &unk_1EC9CCBC8;
  *(void *)(v9 + 600) = &unk_1EC9CCC48;
  uint64_t v12 = (uint64_t *)a2[21];
  unint64_t v11 = a2[22];
  int v13 = v12;
  if ((unint64_t)v12 >= v11)
  {
    uint64_t v15 = (uint64_t *)a2[20];
    uint64_t v16 = v12 - v15;
    unint64_t v17 = v16 + 1;
    if ((unint64_t)(v16 + 1) >> 61) {
      abort();
    }
    uint64_t v18 = v11 - (void)v15;
    if (v18 >> 2 > v17) {
      unint64_t v17 = v18 >> 2;
    }
    if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v19 = v17;
    }
    if (v19)
    {
      if (v19 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v20 = (char *)operator new(8 * v19);
    }
    else
    {
      uint64_t v20 = 0;
    }
    uint64_t v21 = (uint64_t *)&v20[8 * v16];
    uint64_t v22 = &v20[8 * v19];
    *uint64_t v21 = v10;
    unint64_t v14 = v21 + 1;
    if (v12 != v15)
    {
      unint64_t v23 = (char *)v12 - (char *)v15 - 8;
      if (v23 < 0x58) {
        goto LABEL_36;
      }
      if ((unint64_t)((char *)v15 - v20) < 0x20) {
        goto LABEL_36;
      }
      uint64_t v24 = (v23 >> 3) + 1;
      uint64_t v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
      int v13 = &v12[v25 / 0xFFFFFFFFFFFFFFF8];
      uint64_t v21 = (uint64_t *)((char *)v21 - v25);
      unint64_t v26 = &v20[8 * v16 - 16];
      uint64_t v27 = v12 - 2;
      uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *((_OWORD *)v26 - 1) = *((_OWORD *)v27 - 1);
        *(_OWORD *)unint64_t v26 = v29;
        v26 -= 32;
        v27 -= 4;
        v28 -= 4;
      }
      while (v28);
      if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_36:
        do
        {
          uint64_t v30 = *--v13;
          *--uint64_t v21 = v30;
        }
        while (v13 != v15);
      }
      int v13 = (uint64_t *)a2[20];
    }
    a2[20] = v21;
    a2[21] = v14;
    a2[22] = v22;
    if (v13) {
      operator delete(v13);
    }
  }
  else
  {
    *uint64_t v12 = v10;
    unint64_t v14 = v12 + 1;
  }
  a2[21] = v14;
  v33[0] = &unk_1EC9CF7C8;
  v33[1] = a1;
  unint64_t v36 = v35;
  uint64_t v34 = v33;
  v35[0] = &unk_1EC9CF7C8;
  v35[1] = a1;
  std::__function::__value_func<void ()(mlir::mps::ConstantAttributeConversionType const&)>::swap[abi:nn180100](v35, a1 + 71);
  if (v36 == v35)
  {
    (*((void (**)(const void **))v35[0] + 4))(v35);
  }
  else if (v36)
  {
    (*((void (**)(void))*v36 + 5))();
  }
  if (v34 == v33)
  {
    (*(void (**)(void *))(v33[0] + 32))(v33);
  }
  else if (v34)
  {
    (*(void (**)(void))(*v34 + 40))();
  }
  return a1;
}

uint64_t llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::handleOccurrence(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  int v12 = 0;
  uint64_t v8 = llvm::cl::parser<mlir::anec::Family>::parse(a1 + 152, (void *)a1, a3, a4, a5, a6, &v12);
  if (v8) {
    return v8;
  }
  *(_DWORD *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(void *)v9 + 48))(v9, &v12);
    return v8;
  }
  uint64_t v11 = std::__throw_bad_function_call[abi:nn180100]();
  return llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::getValueExpectedFlagDefault(v11);
}

uint64_t llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::getValueExpectedFlagDefault(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 160) + 24)) {
    return 2;
  }
  else {
    return 3;
  }
}

void mlir::Pass::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::~Option(void *a1)
{
  uint64_t v1 = mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::~Option(a1);

  operator delete(v1);
}

unint64_t llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::getOptionWidth(llvm::cl::Option *a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth((llvm::cl::Option *)((char *)a1 + 152), a1);
}

uint64_t llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::printOptionInfo(uint64_t a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::generic_parser_base *)(a1 + 152), (const llvm::cl::Option *)a1, a2);
}

llvm::raw_ostream *llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::printOptionValue(llvm::raw_ostream *result, int a2, char a3)
{
  if ((a3 & 1) != 0 || !*((unsigned char *)result + 148) || *((_DWORD *)result + 36) != *((_DWORD *)result + 32))
  {
    int v3 = *((_DWORD *)result + 32);
    unsigned int v4 = &unk_1EC9A3A60;
    char v6 = 1;
    int v5 = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 152), result, (const llvm::cl::GenericOptionValue *)&v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  return result;
}

uint64_t llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::setDefault(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 148);
  if (*(unsigned char *)(result + 148)) {
    int v1 = *(_DWORD *)(result + 144);
  }
  *(_DWORD *)(result + 128) = v1;
  return result;
}

void llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::getExtraOptionNames(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(*(void *)(a1 + 160) + 24))
  {
    uint64_t v3 = a1 + 152;
    int v4 = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 152) + 16))(a1 + 152);
    if (v4)
    {
      int v5 = v4;
      uint64_t v6 = 0;
      do
      {
        uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 24))(v3, v6);
        uint64_t v9 = v8;
        unint64_t v10 = *(unsigned int *)(a2 + 8);
        if (v10 >= *(unsigned int *)(a2 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v10 + 1, 16);
          unint64_t v10 = *(unsigned int *)(a2 + 8);
        }
        uint64_t v11 = (uint64_t *)(*(void *)a2 + 16 * v10);
        *uint64_t v11 = v7;
        v11[1] = v9;
        ++*(_DWORD *)(a2 + 8);
        uint64_t v6 = (v6 + 1);
      }
      while (v5 != v6);
    }
  }
}

llvm::raw_ostream *mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::print(uint64_t a1, llvm::raw_ostream *this)
{
  int v4 = *(const void **)(a1 + 16);
  size_t v5 = *(void *)(a1 + 24);
  uint64_t v6 = (unsigned char *)*((void *)this + 4);
  if (v5 <= *((void *)this + 3) - (void)v6)
  {
    if (v5)
    {
      memcpy(v6, v4, v5);
      uint64_t v6 = (unsigned char *)(*((void *)this + 4) + v5);
      *((void *)this + 4) = v6;
    }
    uint64_t v7 = this;
  }
  else
  {
    uint64_t v7 = llvm::raw_ostream::write(this, (const char *)v4, v5);
    uint64_t v6 = (unsigned char *)*((void *)v7 + 4);
  }
  if ((unint64_t)v6 >= *((void *)v7 + 3))
  {
    llvm::raw_ostream::write(v7, 61);
  }
  else
  {
    *((void *)v7 + 4) = v6 + 1;
    *uint64_t v6 = 61;
  }
  uint64_t v8 = (unsigned char *)(*(void *)(a1 + 168) + 44);
  uint64_t v9 = 48 * *(unsigned int *)(a1 + 176);
  while (1)
  {
    v9 -= 48;
    if (*v8)
    {
      if (*((_DWORD *)v8 - 1) == *(_DWORD *)(a1 + 128)) {
        break;
      }
    }
    v8 += 48;
  }
  unint64_t v10 = *(const void **)(v8 - 44);
  size_t v11 = *(void *)(v8 - 36);
  uint64_t result = (llvm::raw_ostream *)*((void *)this + 4);
  if (v11 <= *((void *)this + 3) - (void)result)
  {
    if (v11)
    {
      uint64_t result = (llvm::raw_ostream *)memcpy(result, v10, v11);
      *((void *)this + 4) += v11;
    }
  }
  else
  {
    size_t v13 = *(void *)(v8 - 36);
    return llvm::raw_ostream::write(this, (const char *)v10, v13);
  }
  return result;
}

uint64_t mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::copyValueFrom(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 128) = *(_DWORD *)(a2 - 472);
  *(unsigned char *)(result + 608) = *(unsigned char *)(a2 + 8);
  return result;
}

void *non-virtual thunk to'mlir::Pass::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::~Option(uint64_t a1)
{
  return mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::~Option((void *)(a1 - 600));
}

void non-virtual thunk to'mlir::Pass::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::~Option(uint64_t a1)
{
  int v1 = mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::~Option((void *)(a1 - 600));

  operator delete(v1);
}

llvm::raw_ostream *non-virtual thunk to'mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::print(uint64_t a1, llvm::raw_ostream *a2)
{
  return mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::print(a1 - 600, a2);
}

uint64_t non-virtual thunk to'mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::getOption(uint64_t a1)
{
  return a1 - 600;
}

uint64_t non-virtual thunk to'mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::copyValueFrom(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result - 472) = *(_DWORD *)(a2 - 472);
  *(unsigned char *)(result + 8) = *(unsigned char *)(a2 + 8);
  return result;
}

uint64_t llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<mlir::mps::ConstantAttributeConversionType>,llvm::cl::ValuesClass>(uint64_t a1, uint64_t a2, const void **a3, _OWORD *a4, _DWORD **a5, uint64_t *a6)
{
  *(void *)a1 = &unk_1EC9A42A8;
  *(_WORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 10) &= 0x8000u;
  int v12 = (void *)(a1 + 80);
  *(void *)(a1 + 64) = a1 + 80;
  uint64_t v13 = a1 + 64;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_DWORD *)(a1 + 60) = 0;
  *(void *)(a1 + 72) = 0x100000000;
  *(void *)(a1 + 88) = a1 + 120;
  *(void *)(a1 + 96) = a1 + 120;
  *(void *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 112) = 0;
  GeneralCategory = llvm::cl::getGeneralCategory((llvm::cl *)a1);
  uint64_t v15 = *(unsigned int *)(a1 + 72);
  if (v15 >= *(_DWORD *)(a1 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v13, v12, v15 + 1, 8);
    LODWORD(v15) = *(_DWORD *)(a1 + 72);
  }
  *(void *)(*(void *)(a1 + 64) + 8 * v15) = GeneralCategory;
  ++*(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = &unk_1EC9A3A60;
  *(void *)(a1 + 144) = 0;
  *(void *)a1 = &unk_1EC9A3CF8;
  *(void *)(a1 + 160) = a1;
  *(void *)(a1 + 168) = a1 + 184;
  *(void *)(a1 + 176) = 0x800000000;
  *(void *)(a1 + 152) = &unk_1EC9CCB28;
  *(void *)(a1 + 568) = &unk_1EC9CE4F8;
  *(void *)(a1 + 592) = a1 + 568;
  llvm::cl::apply<llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<mlir::mps::ConstantAttributeConversionType>,llvm::cl::ValuesClass>(a1, a2, a3, a4, a5, a6);
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

void mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::~Option(void *a1)
{
  int v1 = mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::~Option(a1);

  operator delete(v1);
}

void *non-virtual thunk to'mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::~Option(uint64_t a1)
{
  return mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::~Option((void *)(a1 - 600));
}

void non-virtual thunk to'mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::~Option(uint64_t a1)
{
  int v1 = mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::~Option((void *)(a1 - 600));

  operator delete(v1);
}

void llvm::cl::apply<llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<mlir::mps::ConstantAttributeConversionType>,llvm::cl::ValuesClass>(uint64_t a1, uint64_t a2, const void **a3, _OWORD *a4, _DWORD **a5, uint64_t *a6)
{
  llvm::cl::Option::setArgStr(a1, *(int8x16_t **)a2, *(const unsigned __int8 **)(a2 + 8));
  size_t v11 = *a3;
  uint64_t v12 = *(void *)(a1 + 96);
  if (v12 != *(void *)(a1 + 88)) {
    goto LABEL_2;
  }
  uint64_t v14 = *(unsigned int *)(a1 + 108);
  if (v14)
  {
    uint64_t v15 = 0;
    uint64_t v16 = 8 * v14;
    unint64_t v17 = *(void **)(a1 + 96);
    while ((const void *)*v17 != v11)
    {
      if (*v17 == -2) {
        uint64_t v15 = v17;
      }
      ++v17;
      v16 -= 8;
      if (!v16)
      {
        if (!v15) {
          goto LABEL_14;
        }
        void *v15 = v11;
        --*(_DWORD *)(a1 + 112);
        break;
      }
    }
  }
  else
  {
LABEL_14:
    if (v14 >= *(_DWORD *)(a1 + 104))
    {
LABEL_2:
      llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)(a1 + 88), v11);
      goto LABEL_3;
    }
    *(_DWORD *)(a1 + 108) = v14 + 1;
    *(void *)(v12 + 8 * v14) = v11;
  }
LABEL_3:
  *(_OWORD *)(a1 + 32) = *a4;
  uint64_t v13 = *a5;
  *(_DWORD *)(a1 + 128) = **a5;
  *(unsigned char *)(a1 + 148) = 1;
  *(_DWORD *)(a1 + 144) = *v13;

  llvm::cl::ValuesClass::apply<llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>>(a6, a1);
}

void *llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::~opt(void *a1)
{
  *a1 = &unk_1EC9A3CF8;
  int v2 = a1 + 71;
  uint64_t v3 = (void *)a1[74];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  a1[19] = &unk_1EC9A4340;
  int v4 = (void *)a1[21];
  if (v4 != a1 + 23) {
    free(v4);
  }
  *a1 = &unk_1EC9A42A8;
  size_t v5 = (void *)a1[12];
  if (v5 != (void *)a1[11]) {
    free(v5);
  }
  uint64_t v6 = (void *)a1[8];
  if (v6 != a1 + 10) {
    free(v6);
  }
  return a1;
}

void llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::~opt(char *__p)
{
  *(void *)__p = &unk_1EC9A3CF8;
  int v2 = __p + 568;
  uint64_t v3 = (char *)*((void *)__p + 74);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  *((void *)__p + 19) = &unk_1EC9A4340;
  int v4 = (char *)*((void *)__p + 21);
  if (v4 != __p + 184) {
    free(v4);
  }
  *(void *)__p = &unk_1EC9A42A8;
  size_t v5 = (void *)*((void *)__p + 12);
  if (v5 != *((void **)__p + 11)) {
    free(v5);
  }
  uint64_t v6 = (char *)*((void *)__p + 8);
  if (v6 != __p + 80) {
    free(v6);
  }

  operator delete(__p);
}

BOOL llvm::cl::OptionValueCopy<mlir::mps::ConstantAttributeConversionType>::compare(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 12) && *(unsigned char *)(a1 + 12) && *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8);
}

void *mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>::~GenericOptionParser(void *a1)
{
  *a1 = &unk_1EC9A4340;
  int v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

void mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>::~GenericOptionParser(void *__p)
{
  void *__p = &unk_1EC9A4340;
  int v2 = (void *)__p[2];
  if (v2 != __p + 4) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t llvm::cl::parser<mlir::mps::ConstantAttributeConversionType>::getNumOptions(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t llvm::cl::parser<mlir::mps::ConstantAttributeConversionType>::getOption(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2);
}

uint64_t llvm::cl::parser<mlir::mps::ConstantAttributeConversionType>::getDescription(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2 + 16);
}

uint64_t llvm::cl::parser<mlir::mps::ConstantAttributeConversionType>::getOptionValue(uint64_t a1, unsigned int a2)
{
  return *(void *)(a1 + 16) + 48 * a2 + 32;
}

void *llvm::cl::parser<mlir::mps::ConstantAttributeConversionType>::~parser(void *a1)
{
  *a1 = &unk_1EC9A4340;
  int v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

void llvm::cl::parser<mlir::mps::ConstantAttributeConversionType>::~parser(void *__p)
{
  void *__p = &unk_1EC9A4340;
  int v2 = (void *)__p[2];
  if (v2 != __p + 4) {
    free(v2);
  }

  operator delete(__p);
}

void *std::__function::__func<llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::{lambda(mlir::mps::ConstantAttributeConversionType const&)#1},std::allocator<llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::{lambda(mlir::mps::ConstantAttributeConversionType const&)#1}>,void ()(mlir::mps::ConstantAttributeConversionType const&)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EC9CE4F8;
  return result;
}

void std::__function::__func<llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::{lambda(mlir::mps::ConstantAttributeConversionType const&)#1},std::allocator<llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::{lambda(mlir::mps::ConstantAttributeConversionType const&)#1}>,void ()(mlir::mps::ConstantAttributeConversionType const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EC9CE4F8;
}

void llvm::cl::ValuesClass::apply<llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>>(uint64_t *a1, uint64_t a2)
{
  unsigned int v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    uint64_t v4 = *a1;
    uint64_t v5 = *a1 + 40 * v2;
    uint64_t v6 = a2 + 168;
    do
    {
      uint64_t v8 = *(const unsigned __int8 **)(v4 + 8);
      long long v9 = *(_OWORD *)(v4 + 24);
      int v10 = *(_DWORD *)(v4 + 16);
      v15[0] = *(void *)v4;
      uint64_t v7 = (int8x16_t *)v15[0];
      v15[1] = v8;
      long long v16 = v9;
      unint64_t v17 = &unk_1EC9A3A60;
      char v19 = 1;
      int v18 = v10;
      Address = llvm::SmallVectorTemplateBase<llvm::cl::parser<mlir::mps::ConstantAttributeConversionType>::OptionInfo,false>::reserveForParamAndGetAddress(v6, (unint64_t)v15, 1);
      uint64_t v12 = *(void *)(a2 + 168) + 48 * *(unsigned int *)(a2 + 176);
      long long v13 = *((_OWORD *)Address + 1);
      *(_OWORD *)uint64_t v12 = *(_OWORD *)Address;
      *(_OWORD *)(v12 + 16) = v13;
      *(void *)(v12 + 32) = &unk_1EC9A3B60;
      char v14 = Address[44];
      *(_DWORD *)(v12 + 40) = *((_DWORD *)Address + 10);
      *(unsigned char *)(v12 + 44) = v14;
      *(void *)(v12 + 32) = &unk_1EC9A3A60;
      ++*(_DWORD *)(a2 + 176);
      llvm::cl::AddLiteralOption(*(void *)(a2 + 160), v7, v8);
      v4 += 40;
    }
    while (v4 != v5);
  }
}

char *llvm::SmallVectorTemplateBase<llvm::cl::parser<mlir::mps::ConstantAttributeConversionType>::OptionInfo,false>::reserveForParamAndGetAddress(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v3 = a2;
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  unint64_t v5 = v4 + a3;
  if (v5 > *(unsigned int *)(a1 + 12))
  {
    unint64_t v8 = *(void *)a1 + 48 * v4;
    if (*(void *)a1 <= a2 && v8 > a2)
    {
      uint64_t v20 = (uint64_t)(a2 - *(void *)a1) >> 4;
      unint64_t v32 = 0;
      uint64_t v21 = (char *)(a1 + 16);
      uint64_t v22 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), v5, 48, &v32);
      unint64_t v23 = *(char **)a1;
      unsigned int v24 = *(_DWORD *)(a1 + 8);
      if (v24)
      {
        uint64_t v25 = &v23[48 * v24];
        unint64_t v26 = v22 + 32;
        uint64_t v27 = v22;
        do
        {
          long long v28 = *((_OWORD *)v23 + 1);
          *(_OWORD *)uint64_t v27 = *(_OWORD *)v23;
          *((_OWORD *)v27 + 1) = v28;
          *((void *)v27 + 4) = &unk_1EC9A3B60;
          int v29 = *((_DWORD *)v23 + 10);
          v27[44] = v23[44];
          *((_DWORD *)v27 + 10) = v29;
          *((void *)v27 + 4) = &unk_1EC9A3A60;
          v26 += 48;
          v23 += 48;
          v27 += 48;
        }
        while (v23 != v25);
        unint64_t v23 = *(char **)a1;
      }
      unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * v20;
      int v31 = v32;
      if (v23 != v21) {
        free(v23);
      }
      *(void *)a1 = v22;
      *(_DWORD *)(a1 + 12) = v31;
      return &v22[48 * v30];
    }
    else
    {
      unint64_t v32 = 0;
      int v10 = (char *)(a1 + 16);
      size_t v11 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), v5, 48, &v32);
      uint64_t v12 = *(char **)a1;
      unsigned int v13 = *(_DWORD *)(a1 + 8);
      if (v13)
      {
        char v14 = &v12[48 * v13];
        uint64_t v15 = v11 + 32;
        long long v16 = v11;
        do
        {
          long long v17 = *((_OWORD *)v12 + 1);
          *(_OWORD *)long long v16 = *(_OWORD *)v12;
          *((_OWORD *)v16 + 1) = v17;
          *((void *)v16 + 4) = &unk_1EC9A3B60;
          int v18 = *((_DWORD *)v12 + 10);
          v16[44] = v12[44];
          *((_DWORD *)v16 + 10) = v18;
          *((void *)v16 + 4) = &unk_1EC9A3A60;
          v15 += 48;
          v12 += 48;
          v16 += 48;
        }
        while (v12 != v14);
        uint64_t v12 = *(char **)a1;
      }
      int v19 = v32;
      if (v12 != v10) {
        free(v12);
      }
      *(void *)a1 = v11;
      *(_DWORD *)(a1 + 12) = v19;
    }
  }
  return (char *)v3;
}

void *std::__function::__value_func<void ()(mlir::mps::ConstantAttributeConversionType const&)>::swap[abi:nn180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    unint64_t v3 = result;
    uint64_t v4 = (void *)result[3];
    unint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void *_ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionINS2_3mps31ConstantAttributeConversionTypeENS4_19GenericOptionParserIS7_EEEC1IJN4llvm2cl4descENSD_11initializerIS7_EENSD_11ValuesClassEEEERS4_NSC_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISQ_EEFvRKS7_EE7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EC9CF7C8;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionINS2_3mps31ConstantAttributeConversionTypeENS4_19GenericOptionParserIS7_EEEC1IJN4llvm2cl4descENSD_11initializerIS7_EENSD_11ValuesClassEEEERS4_NSC_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISQ_EEFvRKS7_EE7__cloneEPNS0_6__baseISV_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EC9CF7C8;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionINS2_3mps31ConstantAttributeConversionTypeENS4_19GenericOptionParserIS7_EEEC1IJN4llvm2cl4descENSD_11initializerIS7_EENSD_11ValuesClassEEEERS4_NSC_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISQ_EEFvRKS7_EEclESU_(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 8) + 608) = 1;
  return result;
}

void *mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::~Option(void *a1)
{
  *a1 = &unk_1EC9A3CF8;
  uint64_t v2 = a1 + 71;
  uint64_t v3 = (void *)a1[74];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  a1[19] = &unk_1EC9A4340;
  uint64_t v4 = (void *)a1[21];
  if (v4 != a1 + 23) {
    free(v4);
  }
  *a1 = &unk_1EC9A42A8;
  unint64_t v5 = (void *)a1[12];
  if (v5 != (void *)a1[11]) {
    free(v5);
  }
  uint64_t v6 = (void *)a1[8];
  if (v6 != a1 + 10) {
    free(v6);
  }
  return a1;
}

void mlir::mps::anonymous namespace'::ConvertConstant::~ConvertConstant(mlir::mps::_anonymous_namespace_::ConvertConstant *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ConstantOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ConstantOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ConstantOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::mps::anonymous namespace'::ConvertConstant::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v171[9] = *MEMORY[0x1E4F143B8];
  uint64_t v168 = a2;
  uint64_t Value = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v168);
  uint64_t v167 = v5;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&Value);
  uint64_t v6 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v168) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  int v10 = *(void **)(v7 + 8);
  size_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    unsigned int v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    char v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      int v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v164[0] = (uint64_t)v6;
  v164[1] = v16;
  v163 = Type;
  uint64_t RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&Type);
  if (RHS != mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v164) && *(unsigned char *)(a1 + 100))
  {
    uint64_t v18 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&Type);
    uint64_t v20 = v19;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v164);
    v163 = (void *)mlir::RankedTensorType::get(v18, v20, OperandRange, 0);
  }
  uint64_t v22 = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v163);
  int isCompatibleWithDenseStorage = mlir::mps::isCompatibleWithDenseStorage(v22);
  if ((isCompatibleWithDenseStorage & 1) != 0 || !mlir::DenseElementsAttr::classof((uint64_t)Value))
  {
    if (Type == v163)
    {
      int v34 = *(_DWORD *)(a1 + 96);
      if (!v34) {
        return 0;
      }
      if (v34 != 2)
      {
        if ((isCompatibleWithDenseStorage & 1) == 0 || mlir::DenseElementsAttr::classof((uint64_t)Value)) {
          return 0;
        }
LABEL_23:
        if ((mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value) & 1) != 0
          || (int v33 = *(_DWORD *)(a1 + 96), v33 == 1))
        {
          int isCompatibleWithDenseStorage = 1;
        }
        else
        {
          int isCompatibleWithDenseStorage = v33 != 2 && mlir::DenseElementsAttr::classof((uint64_t)Value);
        }
LABEL_33:
        if (Type != v163)
        {
          mlir::mps::CPUNDArray::CPUNDArray(&v169, Value, v167);
          unint64_t v35 = v163;
          if (!v163) {
            goto LABEL_43;
          }
          uint64_t v36 = *v163;
          unint64_t v37 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v38 = *(unsigned int *)(v36 + 16);
          if (!v38) {
            goto LABEL_43;
          }
          int64_t v39 = *(void **)(v36 + 8);
          unint64_t v40 = &v39[2 * v38];
          do
          {
            unint64_t v41 = v38 >> 1;
            unint64_t v42 = &v39[2 * (v38 >> 1)];
            unint64_t v44 = *v42;
            uint64_t v43 = v42 + 2;
            v38 += ~(v38 >> 1);
            if (v44 < v37) {
              int64_t v39 = v43;
            }
            else {
              unint64_t v38 = v41;
            }
          }
          while (v38);
          if (v39 != v40 && *v39 == v37) {
            uint64_t v45 = v39[1];
          }
          else {
LABEL_43:
          }
            uint64_t v45 = 0;
          mlir::mps::CPUNDArray::CPUNDArray(v162, v35, v45, 0);
          if (*(unsigned char *)(a1 + 101)) {
            int v46 = 14;
          }
          else {
            int v46 = 13;
          }
          mlir::mps::CPUNDArrayArithmeticUnaryKernel::CPUNDArrayArithmeticUnaryKernel((uint64_t)v161, v46, 0.0);
          uint64_t v47 = operator new(8uLL);
          v158 = v47;
          *uint64_t v47 = &v169;
          v159 = v47 + 1;
          v160 = v47 + 1;
          uint64_t v48 = operator new(8uLL);
          v155 = v48;
          *uint64_t v48 = v162;
          v156 = v48 + 1;
          v157 = v48 + 1;
          uint64_t v49 = operator new(8uLL);
          v152 = v49;
          void *v49 = 0;
          v153 = v49 + 1;
          v154 = v49 + 1;
          unsigned int v50 = operator new(8uLL);
          __p = v50;
          *unsigned int v50 = 0;
          v150 = v50 + 1;
          v151 = v50 + 1;
          mlir::mps::CPUNDArrayKernel::cpuTilingEngine((uint64_t)v161, (uint64_t *)&v158, (uint64_t **)&v155, (uint64_t)&v152, (uint64_t)&__p, 0, *((uint64_t *)&v170 + 1), (uint64_t)v161);
          if (__p)
          {
            v150 = __p;
            operator delete(__p);
          }
          if (v152)
          {
            v153 = v152;
            operator delete(v152);
          }
          if (v155)
          {
            v156 = v155;
            operator delete(v155);
          }
          if (v158)
          {
            v159 = v158;
            operator delete(v158);
          }
          unint64_t v51 = v162[5];
          BufferByteSize = (const void *)mlir::mps::CPUNDArray::getBufferByteSize((mlir::mps::CPUNDArray *)v162);
          v158 = 0;
          v159 = 0;
          std::string::size_type v56 = v163;
          if (isCompatibleWithDenseStorage)
          {
            if (!v163) {
              goto LABEL_65;
            }
            uint64_t v57 = *v163;
            unint64_t v58 = mlir::TypeID::get<mlir::ShapedType>();
            unint64_t v59 = *(unsigned int *)(v57 + 16);
            if (!v59) {
              goto LABEL_65;
            }
            std::string::size_type v60 = *(void **)(v57 + 8);
            uint64_t v61 = &v60[2 * v59];
            do
            {
              unint64_t v62 = v59 >> 1;
              uint64_t v63 = &v60[2 * (v59 >> 1)];
              unint64_t v65 = *v63;
              uint64_t v64 = v63 + 2;
              v59 += ~(v59 >> 1);
              if (v65 < v58) {
                std::string::size_type v60 = v64;
              }
              else {
                unint64_t v59 = v62;
              }
            }
            while (v59);
            if (v60 != v61 && *v60 == v58) {
              uint64_t v66 = v60[1];
            }
            else {
LABEL_65:
            }
              uint64_t v66 = 0;
            uint64_t v67 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v56, v66, v51, BufferByteSize, v52, v53, v54);
            uint64_t v68 = v67;
            if (!v67) {
              goto LABEL_102;
            }
            uint64_t v69 = *v67;
            unint64_t v70 = mlir::TypeID::get<mlir::ElementsAttr>();
            unint64_t v71 = *(unsigned int *)(v69 + 16);
            if (!v71) {
              goto LABEL_102;
            }
            uint64_t v72 = *(void **)(v69 + 8);
            unint64_t v73 = &v72[2 * v71];
            do
            {
              unint64_t v74 = v71 >> 1;
              uint64_t v75 = &v72[2 * (v71 >> 1)];
              unint64_t v77 = *v75;
              uint64_t v76 = v75 + 2;
              v71 += ~(v71 >> 1);
              if (v77 < v70) {
                uint64_t v72 = v76;
              }
              else {
                unint64_t v71 = v74;
              }
            }
            while (v71);
          }
          else
          {
            BufferTensorAttr = (uint64_t *)mlir::mps::getBufferTensorAttr((uint64_t)v163, v51, BufferByteSize);
            uint64_t v68 = BufferTensorAttr;
            if (!BufferTensorAttr) {
              goto LABEL_102;
            }
            uint64_t v107 = *BufferTensorAttr;
            unint64_t v70 = mlir::TypeID::get<mlir::ElementsAttr>();
            unint64_t v108 = *(unsigned int *)(v107 + 16);
            if (!v108) {
              goto LABEL_102;
            }
            uint64_t v72 = *(void **)(v107 + 8);
            unint64_t v73 = &v72[2 * v108];
            do
            {
              unint64_t v109 = v108 >> 1;
              unint64_t v110 = &v72[2 * (v108 >> 1)];
              unint64_t v112 = *v110;
              uint64_t v111 = v110 + 2;
              v108 += ~(v108 >> 1);
              if (v112 < v70) {
                uint64_t v72 = v111;
              }
              else {
                unint64_t v108 = v109;
              }
            }
            while (v108);
          }
          if (v72 != v73 && *v72 == v70)
          {
            uint64_t v113 = (void *)v72[1];
            goto LABEL_103;
          }
LABEL_102:
          uint64_t v113 = 0;
LABEL_103:
          v158 = v68;
          v159 = v113;
          uint64_t v114 = v168;
          unint64_t v115 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a3 + 8), *(void *)(v168 + 24), v164, (void **)&v158);
          (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, v114, v115);
          mlir::mps::CPUNDArray::~CPUNDArray((mlir::mps::CPUNDArray *)v162);
          mlir::mps::CPUNDArray::~CPUNDArray((mlir::mps::CPUNDArray *)&v169);
          return 1;
        }
        ElementsAttrRawData = (const void *)mlir::getElementsAttrRawData((uint64_t)Value);
        uint64_t v83 = v78;
        v169 = 0;
        *(void *)&long long v170 = 0;
        uint64_t v84 = Type;
        if (isCompatibleWithDenseStorage)
        {
          if (!Type) {
            goto LABEL_84;
          }
          uint64_t v85 = *Type;
          unint64_t v86 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v87 = *(unsigned int *)(v85 + 16);
          if (!v87) {
            goto LABEL_84;
          }
          uint64_t v88 = *(void **)(v85 + 8);
          uint64_t v89 = &v88[2 * v87];
          do
          {
            unint64_t v90 = v87 >> 1;
            uint64_t v91 = &v88[2 * (v87 >> 1)];
            unint64_t v93 = *v91;
            uint64_t v92 = v91 + 2;
            v87 += ~(v87 >> 1);
            if (v93 < v86) {
              uint64_t v88 = v92;
            }
            else {
              unint64_t v87 = v90;
            }
          }
          while (v87);
          if (v88 != v89 && *v88 == v86) {
            uint64_t v94 = v88[1];
          }
          else {
LABEL_84:
          }
            uint64_t v94 = 0;
          uint64_t v95 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v84, v94, ElementsAttrRawData, v83, v79, v80, v81);
          uint64_t v96 = v95;
          if (!v95) {
            goto LABEL_113;
          }
          uint64_t v97 = *v95;
          unint64_t v98 = mlir::TypeID::get<mlir::ElementsAttr>();
          unint64_t v99 = *(unsigned int *)(v97 + 16);
          if (!v99) {
            goto LABEL_113;
          }
          uint64_t v100 = *(void **)(v97 + 8);
          uint64_t v101 = &v100[2 * v99];
          do
          {
            unint64_t v102 = v99 >> 1;
            uint64_t v103 = &v100[2 * (v99 >> 1)];
            unint64_t v105 = *v103;
            uint64_t v104 = v103 + 2;
            v99 += ~(v99 >> 1);
            if (v105 < v98) {
              uint64_t v100 = v104;
            }
            else {
              unint64_t v99 = v102;
            }
          }
          while (v99);
        }
        else
        {
          uint64_t v116 = (void *)mlir::mps::getBufferTensorAttr((uint64_t)Type, ElementsAttrRawData, v78);
          uint64_t v96 = v116;
          if (!v116) {
            goto LABEL_113;
          }
          uint64_t v117 = *v116;
          unint64_t v98 = mlir::TypeID::get<mlir::ElementsAttr>();
          unint64_t v118 = *(unsigned int *)(v117 + 16);
          if (!v118) {
            goto LABEL_113;
          }
          uint64_t v100 = *(void **)(v117 + 8);
          uint64_t v101 = &v100[2 * v118];
          do
          {
            unint64_t v119 = v118 >> 1;
            long long v120 = &v100[2 * (v118 >> 1)];
            unint64_t v122 = *v120;
            uint64_t v121 = v120 + 2;
            v118 += ~(v118 >> 1);
            if (v122 < v98) {
              uint64_t v100 = v121;
            }
            else {
              unint64_t v118 = v119;
            }
          }
          while (v118);
        }
        if (v100 != v101 && *v100 == v98)
        {
          uint64_t v123 = v100[1];
          goto LABEL_114;
        }
LABEL_113:
        uint64_t v123 = 0;
LABEL_114:
        v169 = v96;
        *(void *)&long long v170 = v123;
        uint64_t v124 = v168;
        uint64_t v125 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a3 + 8), *(void *)(v168 + 24), v164, &v169);
        (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, v124, v125);
        return 1;
      }
      if (*(_UNKNOWN **)(*Value + 136) == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id
        || (mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value) & 1) != 0)
      {
        return 0;
      }
    }
    if (!isCompatibleWithDenseStorage) {
      goto LABEL_33;
    }
    goto LABEL_23;
  }
  if ((mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value) & 1) == 0)
  {
    uint64_t v24 = mlir::getElementsAttrRawData((uint64_t)Value);
    unint64_t v26 = v25;
    uint64_t NumElements = mlir::ElementsAttr::getNumElements((uint64_t)Value, v167);
    v169 = (void *)mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&Type);
    unsigned int IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&v169);
    unint64_t v29 = 8 / IntOrFloatBitWidth;
    if (v29 * IntOrFloatBitWidth == 8)
    {
      v169 = v171;
      long long v170 = xmmword_1810FE310;
      unint64_t v30 = NumElements - 1 + v29;
      if (__CFADD__(NumElements - 1, v29))
      {
        int v31 = 0;
        unint64_t v32 = v171;
      }
      else
      {
        char v127 = IntOrFloatBitWidth;
        unint64_t v128 = v30 / v29;
        if (v30 / v29 < 0x29)
        {
          uint64_t v130 = 0;
          uint64_t v129 = v171;
        }
        else
        {
          llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v169, v171, v30 / v29, 1);
          uint64_t v129 = v169;
          uint64_t v130 = v170;
        }
        if (v128 != v130)
        {
          bzero((char *)v129 + v130, v128 - v130);
          uint64_t v129 = v169;
        }
        uint64_t v131 = 0;
        *(void *)&long long v170 = v128;
        unint64_t v132 = v26;
        do
        {
          uint64_t v133 = v131 * v29;
          unint64_t v134 = v26 - v131 * v29;
          if (v134 >= v29) {
            unint64_t v134 = v29;
          }
          if (v134)
          {
            uint64_t v135 = v132 >= v29 ? v29 : v132;
            LODWORD(v134) = *(unsigned __int8 *)(v24 + v133);
            if (v135 != 1)
            {
              LODWORD(v134) = v134 | (*(unsigned __int8 *)(v133 + v24 + 1) << v127);
              if (v135 != 2)
              {
                LODWORD(v134) = v134 | (*(unsigned __int8 *)(v133 + v24 + 2) << (2 * v127));
                if (v135 != 3)
                {
                  LODWORD(v134) = v134 | (*(unsigned __int8 *)(v133 + v24 + 3) << (3 * v127));
                  if (v135 != 4)
                  {
                    LODWORD(v134) = v134 | (*(unsigned __int8 *)(v133 + v24 + 4) << (4 * v127));
                    if (v135 != 5)
                    {
                      LODWORD(v134) = v134 | (*(unsigned __int8 *)(v133 + v24 + 5) << (5 * v127));
                      if (v135 != 6)
                      {
                        LODWORD(v134) = v134 | (*(unsigned __int8 *)(v133 + v24 + 6) << (6 * v127));
                        if (v135 != 7) {
                          LODWORD(v134) = v134 | (*(unsigned __int8 *)(v133 + v24 + 7) << (7 * v127));
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          *(unsigned char *)uint64_t v129 = v134;
          uint64_t v129 = (void *)((char *)v129 + 1);
          ++v131;
          v132 -= v29;
          --v128;
        }
        while (v128);
        unint64_t v32 = v169;
        int v31 = (const void *)v170;
      }
      uint64_t v136 = (void *)mlir::mps::getBufferTensorAttr((uint64_t)Type, v32, v31);
      v162[0] = v136;
      if (!v136) {
        goto LABEL_156;
      }
      uint64_t v137 = *v136;
      unint64_t v138 = mlir::TypeID::get<mlir::ElementsAttr>();
      unint64_t v139 = *(unsigned int *)(v137 + 16);
      if (!v139) {
        goto LABEL_156;
      }
      uint64_t v140 = *(void **)(v137 + 8);
      uint64_t v141 = &v140[2 * v139];
      do
      {
        unint64_t v142 = v139 >> 1;
        v143 = &v140[2 * (v139 >> 1)];
        unint64_t v145 = *v143;
        v144 = v143 + 2;
        v139 += ~(v139 >> 1);
        if (v145 < v138) {
          uint64_t v140 = v144;
        }
        else {
          unint64_t v139 = v142;
        }
      }
      while (v139);
      if (v140 != v141 && *v140 == v138) {
        v146 = (void *)v140[1];
      }
      else {
LABEL_156:
      }
        v146 = 0;
      v162[1] = v146;
      uint64_t v147 = v168;
      v148 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a3 + 8), *(void *)(v168 + 24), v164, v162);
      (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, v147, v148);
      if (v169 != v171) {
        free(v169);
      }
      return 1;
    }
  }
  return 0;
}

uint64_t _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_3mps12_GLOBAL__N_123ConstantsConversionPass31convertToCoalescedBufferTensorsENS1_8ModuleOpEEUlNSB_10ConstantOpEE_SF_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESO_E4typeES3_OT1_EUlS3_E_EEvlS3_(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    if (*(_UNKNOWN **)(*(void *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id)
    {
      uint64_t v2 = *(uint64_t **)result;
      uint64_t v19 = a2;
      v18[0] = (uint64_t)mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v19);
      v18[1] = v3;
      uint64_t result = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v18);
      if ((result & 1) == 0)
      {
        uint64_t v4 = *v2;
        uint64_t v5 = v19;
        uint64_t v6 = *(unsigned int *)(*v2 + 8);
        if (v6 >= *(_DWORD *)(*v2 + 12))
        {
          uint64_t v15 = v19;
          llvm::SmallVectorBase<unsigned int>::grow_pod(*v2, (void *)(v4 + 16), v6 + 1, 8);
          uint64_t v5 = v15;
          LODWORD(v6) = *(_DWORD *)(v4 + 8);
        }
        *(void *)(*(void *)v4 + 8 * v6) = v5;
        ++*(_DWORD *)(v4 + 8);
        uint64_t v7 = v2[1];
        uint64_t Type = mlir::ElementsAttr::getType((mlir::ElementsAttr *)v18);
        uint64_t v9 = *(unsigned int *)(v7 + 8);
        if (v9 >= *(_DWORD *)(v7 + 12))
        {
          uint64_t v16 = Type;
          llvm::SmallVectorBase<unsigned int>::grow_pod(v7, (void *)(v7 + 16), v9 + 1, 8);
          uint64_t Type = v16;
          LODWORD(v9) = *(_DWORD *)(v7 + 8);
        }
        *(void *)(*(void *)v7 + 8 * v9) = Type;
        ++*(_DWORD *)(v7 + 8);
        uint64_t v10 = v2[2];
        uint64_t result = mlir::getElementsAttrRawData(v18[0]);
        uint64_t v12 = *(unsigned int *)(v10 + 8);
        if (v12 >= *(_DWORD *)(v10 + 12))
        {
          uint64_t v17 = result;
          uint64_t v14 = v11;
          llvm::SmallVectorBase<unsigned int>::grow_pod(v10, (void *)(v10 + 16), v12 + 1, 16);
          uint64_t v11 = v14;
          uint64_t result = v17;
          LODWORD(v12) = *(_DWORD *)(v10 + 8);
        }
        unsigned int v13 = (uint64_t *)(*(void *)v10 + 16 * v12);
        *unsigned int v13 = result;
        v13[1] = v11;
        ++*(_DWORD *)(v10 + 8);
      }
    }
  }
  return result;
}

void *mlir::mps::registerConvertOpLayoutExternalModels(mlir::mps *this, mlir::DialectRegistry *a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  v3[0] = &unk_1EC9CE990;
  v3[1] = mlir::mps::registerConvertOpLayoutExternalModels(mlir::DialectRegistry &)::$_0::__invoke;
  uint64_t v4 = v3;
  mlir::DialectRegistry::addExtension<mlir::mps::MPSDialect>(this, v3);
  uint64_t result = v4;
  if (v4 == v3) {
    return (void *)(*(uint64_t (**)(void *))(v3[0] + 32))(v3);
  }
  if (v4) {
    return (void *)(*(uint64_t (**)(void))(*v4 + 40))();
  }
  return result;
}

uint64_t mlir::ConvertOpLayoutInterface::convertLayout(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (**(uint64_t (***)(void, void, uint64_t, uint64_t, uint64_t))(a1 + 8))(*(void *)(a1 + 8), *(void *)a1, a2, a3, a4);
}

void mlir::mps::registerConvertOpLayoutExternalModels(mlir::DialectRegistry &)::$_0::__invoke(uint64_t *a1)
{
  uint64_t v2 = "mps.conv_2d";
  uint64_t v3 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_2d", (const unsigned __int8 *)0xB, a1);
  if (!v4) {
    goto LABEL_62;
  }
  uint64_t v5 = v3;
  uint64_t v6 = (void *)v3[2];
  if (v6 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v3[1];
    uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    uint64_t v6 = (void *)v5[2];
  }
  else
  {
    uint64_t Values = v3[3];
  }
  uint64_t v8 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(Values, (uint64_t)v6, v8);
  uint64_t v9 = malloc(8uLL);
  unint64_t v10 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v5 + 4), v10, v9);
  uint64_t v11 = "mps.conv_2d_data_gradient";
  uint64_t v12 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_2d_data_gradient", (const unsigned __int8 *)0x19, a1);
  if (!v13) {
    goto LABEL_63;
  }
  uint64_t v14 = v12;
  uint64_t v15 = (void *)v12[2];
  if (v15 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v12[1];
    uint64_t v16 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    uint64_t v15 = (void *)v14[2];
  }
  else
  {
    uint64_t v16 = v12[3];
  }
  uint64_t v17 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v16, (uint64_t)v15, v17);
  uint64_t v18 = malloc(8uLL);
  unint64_t v19 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v14 + 4), v19, v18);
  uint64_t v20 = "mps.conv_2d_weights_gradient";
  uint64_t v21 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_2d_weights_gradient", (const unsigned __int8 *)0x1C, a1);
  if (!v22) {
    goto LABEL_64;
  }
  unint64_t v23 = v21;
  uint64_t v24 = (void *)v21[2];
  if (v24 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v21[1];
    uint64_t v25 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    uint64_t v24 = (void *)v23[2];
  }
  else
  {
    uint64_t v25 = v21[3];
  }
  uint64_t v26 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v25, (uint64_t)v24, v26);
  uint64_t v27 = malloc(8uLL);
  unint64_t v28 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v23 + 4), v28, v27);
  uint64_t v2 = "mps.conv_3d";
  unint64_t v29 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_3d", (const unsigned __int8 *)0xB, a1);
  if (!v30)
  {
LABEL_62:
    __int16 v134 = 1283;
    uint64_t v131 = "Attempting to attach an interface to an unregistered operation ";
    unint64_t v132 = v2;
    uint64_t v128 = 11;
    goto LABEL_72;
  }
  int v31 = v29;
  unint64_t v32 = (void *)v29[2];
  if (v32 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v29[1];
    uint64_t v33 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    unint64_t v32 = (void *)v31[2];
  }
  else
  {
    uint64_t v33 = v29[3];
  }
  uint64_t v34 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v33, (uint64_t)v32, v34);
  unint64_t v35 = malloc(8uLL);
  unint64_t v36 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v31 + 4), v36, v35);
  uint64_t v11 = "mps.conv_3d_data_gradient";
  unint64_t v37 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_3d_data_gradient", (const unsigned __int8 *)0x19, a1);
  if (!v38)
  {
LABEL_63:
    __int16 v134 = 1283;
    uint64_t v131 = "Attempting to attach an interface to an unregistered operation ";
    unint64_t v132 = v11;
    uint64_t v128 = 25;
    goto LABEL_72;
  }
  int64_t v39 = v37;
  unint64_t v40 = (void *)v37[2];
  if (v40 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v37[1];
    uint64_t v41 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    unint64_t v40 = (void *)v39[2];
  }
  else
  {
    uint64_t v41 = v37[3];
  }
  uint64_t v42 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v41, (uint64_t)v40, v42);
  uint64_t v43 = malloc(8uLL);
  unint64_t v44 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v39 + 4), v44, v43);
  uint64_t v20 = "mps.conv_3d_weights_gradient";
  uint64_t v45 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_3d_weights_gradient", (const unsigned __int8 *)0x1C, a1);
  if (!v46)
  {
LABEL_64:
    __int16 v134 = 1283;
    uint64_t v131 = "Attempting to attach an interface to an unregistered operation ";
    unint64_t v132 = v20;
    uint64_t v128 = 28;
    goto LABEL_72;
  }
  uint64_t v47 = v45;
  uint64_t v48 = (void *)v45[2];
  if (v48 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v45[1];
    uint64_t v49 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    uint64_t v48 = (void *)v47[2];
  }
  else
  {
    uint64_t v49 = v45[3];
  }
  uint64_t v50 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v49, (uint64_t)v48, v50);
  unint64_t v51 = malloc(8uLL);
  unint64_t v52 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v47 + 4), v52, v51);
  uint64_t v53 = "mps.depthwise_conv_2d";
  uint64_t v54 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_2d", (const unsigned __int8 *)0x15, a1);
  if (!v55) {
    goto LABEL_65;
  }
  std::string::size_type v56 = v54;
  uint64_t v57 = (void *)v54[2];
  if (v57 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v54[1];
    uint64_t v58 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    uint64_t v57 = (void *)v56[2];
  }
  else
  {
    uint64_t v58 = v54[3];
  }
  uint64_t v59 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v58, (uint64_t)v57, v59);
  std::string::size_type v60 = malloc(8uLL);
  unint64_t v61 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v56 + 4), v61, v60);
  unint64_t v62 = "mps.depthwise_conv_2d_data_gradient";
  uint64_t v63 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_2d_data_gradient", (const unsigned __int8 *)0x23, a1);
  if (!v64) {
    goto LABEL_66;
  }
  unint64_t v65 = v63;
  uint64_t v66 = (void *)v63[2];
  if (v66 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v63[1];
    uint64_t v67 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    uint64_t v66 = (void *)v65[2];
  }
  else
  {
    uint64_t v67 = v63[3];
  }
  uint64_t v68 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v67, (uint64_t)v66, v68);
  uint64_t v69 = malloc(8uLL);
  unint64_t v70 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v65 + 4), v70, v69);
  unint64_t v71 = "mps.depthwise_conv_2d_weights_gradient";
  uint64_t v72 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_2d_weights_gradient", (const unsigned __int8 *)0x26, a1);
  if (!v73) {
    goto LABEL_67;
  }
  unint64_t v74 = v72;
  uint64_t v75 = (void *)v72[2];
  if (v75 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v72[1];
    uint64_t v76 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    uint64_t v75 = (void *)v74[2];
  }
  else
  {
    uint64_t v76 = v72[3];
  }
  uint64_t v77 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v76, (uint64_t)v75, v77);
  uint64_t v78 = malloc(8uLL);
  unint64_t v79 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v74 + 4), v79, v78);
  uint64_t v53 = "mps.depthwise_conv_3d";
  uint64_t v80 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_3d", (const unsigned __int8 *)0x15, a1);
  if (!v81)
  {
LABEL_65:
    __int16 v134 = 1283;
    uint64_t v131 = "Attempting to attach an interface to an unregistered operation ";
    unint64_t v132 = v53;
    uint64_t v128 = 21;
    goto LABEL_72;
  }
  uint64_t v82 = v80;
  uint64_t v83 = (void *)v80[2];
  if (v83 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v80[1];
    uint64_t v84 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    uint64_t v83 = (void *)v82[2];
  }
  else
  {
    uint64_t v84 = v80[3];
  }
  uint64_t v85 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v84, (uint64_t)v83, v85);
  unint64_t v86 = malloc(8uLL);
  unint64_t v87 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v82 + 4), v87, v86);
  unint64_t v62 = "mps.depthwise_conv_3d_data_gradient";
  uint64_t v88 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_3d_data_gradient", (const unsigned __int8 *)0x23, a1);
  if (!v89)
  {
LABEL_66:
    __int16 v134 = 1283;
    uint64_t v131 = "Attempting to attach an interface to an unregistered operation ";
    unint64_t v132 = v62;
    uint64_t v128 = 35;
    goto LABEL_72;
  }
  unint64_t v90 = v88;
  uint64_t v91 = (void *)v88[2];
  if (v91 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v88[1];
    uint64_t v92 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    uint64_t v91 = (void *)v90[2];
  }
  else
  {
    uint64_t v92 = v88[3];
  }
  uint64_t v93 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v92, (uint64_t)v91, v93);
  uint64_t v94 = malloc(8uLL);
  unint64_t v95 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v90 + 4), v95, v94);
  unint64_t v71 = "mps.depthwise_conv_3d_weights_gradient";
  uint64_t v96 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_3d_weights_gradient", (const unsigned __int8 *)0x26, a1);
  if (!v97)
  {
LABEL_67:
    __int16 v134 = 1283;
    uint64_t v131 = "Attempting to attach an interface to an unregistered operation ";
    unint64_t v132 = v71;
    uint64_t v128 = 38;
    goto LABEL_72;
  }
  unint64_t v98 = v96;
  unint64_t v99 = (void *)v96[2];
  if (v99 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v96[1];
    uint64_t v100 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    unint64_t v99 = (void *)v98[2];
  }
  else
  {
    uint64_t v100 = v96[3];
  }
  uint64_t v101 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v100, (uint64_t)v99, v101);
  unint64_t v102 = malloc(8uLL);
  unint64_t v103 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v98 + 4), v103, v102);
  uint64_t v104 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_average", (const unsigned __int8 *)0x13, a1);
  if (!v105)
  {
    __int16 v134 = 1283;
    uint64_t v131 = "Attempting to attach an interface to an unregistered operation ";
    unint64_t v132 = "mps.pooling_average";
LABEL_71:
    uint64_t v128 = 19;
LABEL_72:
    uint64_t v133 = v128;
    uint64_t v129 = ".";
    __int16 v130 = 259;
    llvm::operator+((uint64_t *)&v131, (uint64_t *)&v129, (uint64_t)v135);
    llvm::report_fatal_error((llvm::Twine *)v135, 1);
  }
  uint64_t v106 = v104;
  uint64_t v107 = (void *)v104[2];
  if (v107 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v104[1];
    uint64_t v108 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    uint64_t v107 = (void *)v106[2];
  }
  else
  {
    uint64_t v108 = v104[3];
  }
  uint64_t v109 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v108, (uint64_t)v107, v109);
  unint64_t v110 = malloc(8uLL);
  unint64_t v111 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v106 + 4), v111, v110);
  unint64_t v112 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_max", (const unsigned __int8 *)0xF, a1);
  if (!v113)
  {
    __int16 v134 = 1283;
    uint64_t v131 = "Attempting to attach an interface to an unregistered operation ";
    unint64_t v132 = "mps.pooling_max";
    uint64_t v128 = 15;
    goto LABEL_72;
  }
  uint64_t v114 = v112;
  unint64_t v115 = (void *)v112[2];
  if (v115 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v112[1];
    uint64_t v116 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    unint64_t v115 = (void *)v114[2];
  }
  else
  {
    uint64_t v116 = v112[3];
  }
  uint64_t v117 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v116, (uint64_t)v115, v117);
  unint64_t v118 = malloc(8uLL);
  unint64_t v119 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v114 + 4), v119, v118);
  long long v120 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_l2_norm", (const unsigned __int8 *)0x13, a1);
  if (!v121)
  {
    __int16 v134 = 1283;
    uint64_t v131 = "Attempting to attach an interface to an unregistered operation ";
    unint64_t v132 = "mps.pooling_l2_norm";
    goto LABEL_71;
  }
  unint64_t v122 = v120;
  uint64_t v123 = (void *)v120[2];
  if (v123 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v120[1];
    uint64_t v124 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    uint64_t v123 = (void *)v122[2];
  }
  else
  {
    uint64_t v124 = v120[3];
  }
  uint64_t v125 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v124, (uint64_t)v123, v125);
  unsigned int v126 = malloc(8uLL);
  unint64_t v127 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v122 + 4), v127, v126);
}

uint64_t mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConvertConvolutionInterface<mlir::mps::Conv2DOp>>::convertLayout(uint64_t a1, void *a2, int a3, int a4, uint64_t a5)
{
  v183[5] = *MEMORY[0x1E4F143B8];
  v163 = a2;
  int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v163);
  int WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v163);
  if (a3)
  {
    switch(StorageType)
    {
      case 0:
      case 7:
        if (a3 != 2) {
          goto LABEL_6;
        }
        break;
      case 1:
      case 8:
        if (a3 != 1) {
          goto LABEL_6;
        }
        break;
      default:
        goto LABEL_6;
    }
LABEL_9:
    uint64_t v11 = *(void **)(v163[6] + 16);
    BOOL v14 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
    char v15 = v14;
    if (v14)
    {
      int v16 = 0;
      BOOL v17 = 1;
    }
    else
    {
      BOOL v17 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id;
      int v16 = !v17;
    }
    unsigned int v21 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v163);
    unsigned int v22 = v21;
    if (a3)
    {
      switch(v21)
      {
        case 2u:
        case 3u:
          BOOL v23 = a3 == 1;
          int v24 = 2;
          goto LABEL_45;
        case 4u:
        case 5u:
        case 6u:
LABEL_215:
          __break(1u);
          JUMPOUT(0x18055F338);
        case 7u:
        case 8u:
          BOOL v23 = a3 == 1;
          int v24 = 7;
          goto LABEL_45;
        case 9u:
        case 0xAu:
          BOOL v23 = a3 == 1;
          int v24 = 9;
LABEL_45:
          if (v23) {
            unsigned int v22 = v24;
          }
          else {
            unsigned int v22 = v24 + 1;
          }
          break;
        default:
          unsigned int v22 = a3 != 1;
          break;
      }
    }
    unsigned int v25 = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v163);
    unsigned int v162 = v25;
    if (a4)
    {
      switch(v25)
      {
        case 2u:
        case 3u:
          BOOL v26 = a4 == 1;
          int v27 = 2;
          goto LABEL_54;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
        case 8u:
          BOOL v26 = a4 == 1;
          int v27 = 7;
          goto LABEL_54;
        case 9u:
        case 0xAu:
          BOOL v26 = a4 == 1;
          int v27 = 9;
LABEL_54:
          if (v26) {
            unsigned int v25 = v27;
          }
          else {
            unsigned int v25 = v27 + 1;
          }
          break;
        default:
          unsigned int v25 = a4 != 1;
          break;
      }
    }
    unsigned int v161 = v25;
    char v156 = v15;
    if (v21 == v22)
    {
      v175 = &v176[8];
      unsigned int v28 = 5;
      *(_DWORD *)&v176[4] = 5;
      if (v21 > 3)
      {
        int v177 = 4;
        *(_OWORD *)&v176[8] = xmmword_18110B6C0;
      }
      else
      {
        *(_OWORD *)&v176[8] = xmmword_1810FFF10;
        unsigned int v28 = 4;
      }
      *(_DWORD *)v176 = v28;
    }
    else
    {
      switch(v22)
      {
        case 1u:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x100000003;
          long long v29 = xmmword_18110B6A0;
          goto LABEL_67;
        case 2u:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x100000000;
          long long v29 = xmmword_18110B670;
          goto LABEL_67;
        case 3u:
          v175 = &v176[8];
          *(void *)&v176[16] = 1;
          long long v29 = xmmword_18110B680;
          goto LABEL_67;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
          v175 = &v176[8];
          int v31 = 3;
          unint64_t v32 = &xmmword_18110B6E8;
          goto LABEL_72;
        case 8u:
          v175 = &v176[8];
          int v31 = 1;
          unint64_t v32 = &xmmword_18110B6D4;
          goto LABEL_72;
        case 9u:
          v175 = &v176[8];
          int v31 = 2;
          unint64_t v32 = &xmmword_18110B710;
LABEL_72:
          int v177 = v31;
          long long v30 = *v32;
          goto LABEL_73;
        case 0xAu:
          v175 = &v176[8];
          int v177 = 0;
          long long v30 = xmmword_18110B6FC;
LABEL_73:
          *(_OWORD *)&v176[8] = v30;
          *(void *)v176 = 0x500000005;
          unsigned int v28 = 5;
          break;
        default:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x200000001;
          long long v29 = xmmword_18110B690;
LABEL_67:
          *(_OWORD *)v176 = v29;
          unsigned int v28 = 4;
          break;
      }
    }
    v158 = &v175;
    v159 = &v162;
    v160 = &v161;
    v157[0] = a5;
    v157[1] = &v163;
    v157[2] = &v158;
    uint64_t v33 = *(void *)(v163[9] + 24);
    uint64_t v34 = v163[3];
    v181 = (int32x4_t *)v183;
    HIDWORD(v182) = 5;
    memcpy(v183, &v176[8], 4 * v28);
    LODWORD(v182) = v28;
    if (v181 != (int32x4_t *)v183) {
      free(v181);
    }
    unint64_t v37 = (uint64_t *)v163[9];
    char v38 = (uint64_t *)v37[1];
    if (v38)
    {
      *char v38 = *v37;
      if (*v37) {
        *(void *)(*v37 + 8) = v37[1];
      }
    }
    v37[3] = (uint64_t)v35;
    v37[1] = (uint64_t)v35;
    uint64_t v39 = *v35;
    uint64_t *v37 = *v35;
    if (v39) {
      *(void *)(v39 + 8) = v37;
    }
    *unint64_t v35 = (uint64_t)v37;
    unint64_t v40 = (void *)v163[9];
    uint64_t v41 = v40 + 4;
    uint64_t v42 = (void *)v40[5];
    if (v42)
    {
      void *v42 = *v41;
      if (*v41) {
        *(void *)(*v41 + 8) = v40[5];
      }
    }
    v40[7] = v36;
    v40[5] = v36;
    uint64_t v43 = *v36;
    v40[4] = *v36;
    if (v43) {
      *(void *)(v43 + 8) = v41;
    }
    uint64_t *v36 = (uint64_t)v41;
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v163 + 3));
    uint64_t v45 = mlir::mps::TensorDataLayoutAttr::get(Context, v22);
    mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr((uint64_t *)&v163, v45);
    char v46 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v163 + 3));
    uint64_t v47 = mlir::mps::TensorDataLayoutAttr::get(v46, v161);
    mlir::mps::Conv2DDataGradientOp::setWeightsLayoutAttr((uint64_t *)&v163, v47);
    uint64_t Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v163);
    mlir::mps::Conv2DDataGradientOp::setStridesAttr((uint64_t *)&v163, v49);
    uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v163);
    mlir::mps::Conv2DDataGradientOp::setDilationRatesAttr((uint64_t *)&v163, v51);
    uint64_t Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v163);
    mlir::mps::Conv2DDataGradientOp::setExplicitPaddingAttr((uint64_t *)&v163, v53);
    uint64_t v54 = (mlir::GenericProgramPoint *)v163;
    if (!v17)
    {
      unsigned int v59 = *v159;
      if (*v159 == *v160)
      {
        std::string::size_type v56 = (unsigned int *)&v173[8];
        __dst = &v173[8];
        unsigned int v57 = 5;
        *(_DWORD *)&v173[4] = 5;
        if (v59 > 3)
        {
          int v174 = 4;
          *(_OWORD *)&v173[8] = xmmword_18110B6C0;
        }
        else
        {
          *(_OWORD *)&v173[8] = xmmword_1810FFF10;
          unsigned int v57 = 4;
        }
        *(_DWORD *)v173 = v57;
      }
      else
      {
        switch(*v160)
        {
          case 1u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x100000003;
            long long v60 = xmmword_18110B6A0;
            goto LABEL_112;
          case 2u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x100000000;
            long long v60 = xmmword_18110B670;
            goto LABEL_112;
          case 3u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 1;
            long long v60 = xmmword_18110B680;
            goto LABEL_112;
          case 4u:
          case 5u:
          case 6u:
            goto LABEL_215;
          case 7u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 3;
            uint64_t v63 = &xmmword_18110B6E8;
            goto LABEL_116;
          case 8u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 1;
            uint64_t v63 = &xmmword_18110B6D4;
            goto LABEL_116;
          case 9u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 2;
            uint64_t v63 = &xmmword_18110B710;
LABEL_116:
            int v174 = v62;
            long long v64 = *v63;
            goto LABEL_118;
          case 0xAu:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v174 = 0;
            long long v64 = xmmword_18110B6FC;
LABEL_118:
            *(_OWORD *)&v173[8] = v64;
            *(void *)v173 = 0x500000005;
            unsigned int v57 = 5;
            break;
          default:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x200000001;
            long long v60 = xmmword_18110B690;
LABEL_112:
            *(_OWORD *)v173 = v60;
            unsigned int v57 = 4;
            break;
        }
      }
      unsigned int v21 = v162;
      if (v161 == v162) {
        goto LABEL_103;
      }
      goto LABEL_120;
    }
    char v55 = v158;
    std::string::size_type v56 = (unsigned int *)&v173[8];
    __dst = &v173[8];
    *(void *)v173 = 0x500000000;
    if (v158 == &__dst)
    {
      unsigned int v57 = 0;
      if (v22 == v21)
      {
LABEL_103:
        v169 = &v170[8];
        unint64_t v61 = 5;
        *(_DWORD *)&v170[4] = 5;
        if (v21 > 3)
        {
          int v171 = 4;
          *(_OWORD *)&v170[8] = xmmword_18110B6C0;
        }
        else
        {
          *(_OWORD *)&v170[8] = xmmword_1810FFF10;
          unint64_t v61 = 4;
        }
        *(_DWORD *)long long v170 = v61;
        goto LABEL_132;
      }
LABEL_120:
      switch(v21)
      {
        case 1u:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x100000003;
          long long v65 = xmmword_18110B6A0;
          goto LABEL_126;
        case 2u:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x100000000;
          long long v65 = xmmword_18110B670;
          goto LABEL_126;
        case 3u:
          v169 = &v170[8];
          *(void *)&v170[16] = 1;
          long long v65 = xmmword_18110B680;
          goto LABEL_126;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
          v169 = &v170[8];
          int v67 = 3;
          uint64_t v68 = &xmmword_18110B6E8;
          goto LABEL_130;
        case 8u:
          v169 = &v170[8];
          int v67 = 1;
          uint64_t v68 = &xmmword_18110B6D4;
          goto LABEL_130;
        case 9u:
          v169 = &v170[8];
          int v67 = 2;
          uint64_t v68 = &xmmword_18110B710;
LABEL_130:
          int v171 = v67;
          long long v66 = *v68;
          goto LABEL_131;
        case 0xAu:
          v169 = &v170[8];
          int v171 = 0;
          long long v66 = xmmword_18110B6FC;
LABEL_131:
          *(_OWORD *)&v170[8] = v66;
          *(void *)long long v170 = 0x500000005;
          unint64_t v61 = 5;
          break;
        default:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x200000001;
          long long v65 = xmmword_18110B690;
LABEL_126:
          *(_OWORD *)long long v170 = v65;
          unint64_t v61 = 4;
          break;
      }
LABEL_132:
      uint64_t v168 = v54;
      uint64_t v69 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v168);
      uint64_t v167 = (uint64_t **)v69;
      unint64_t v70 = (uint64_t *)(*(void *)(v69 + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v70) {
        goto LABEL_141;
      }
      uint64_t v71 = *v70;
      unint64_t v72 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v73 = *(unsigned int *)(v71 + 16);
      if (!v73) {
        goto LABEL_141;
      }
      unint64_t v74 = *(void **)(v71 + 8);
      uint64_t v75 = &v74[2 * v73];
      do
      {
        unint64_t v76 = v73 >> 1;
        uint64_t v77 = &v74[2 * (v73 >> 1)];
        unint64_t v79 = *v77;
        uint64_t v78 = v77 + 2;
        v73 += ~(v73 >> 1);
        if (v79 < v72) {
          unint64_t v74 = v78;
        }
        else {
          unint64_t v73 = v76;
        }
      }
      while (v73);
      if (v74 != v75 && *v74 == v72) {
        uint64_t v80 = v74[1];
      }
      else {
LABEL_141:
      }
        uint64_t v80 = 0;
      v166[0] = v70;
      v166[1] = v80;
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v166))
      {
LABEL_199:
        uint64_t v146 = *((void *)v168 + 2);
        mlir::GenericProgramPoint::~GenericProgramPoint(v168);
        uint64_t v148 = *(void *)(v147 + 8);
        *(void *)(a5 + 24) = v146;
        *(void *)(a5 + 32) = v148;
        if ((int32x4_t *)v69 != v181)
        {
          uint64_t DefiningOp = (mlir::GenericProgramPoint *)mlir::Value::getDefiningOp((mlir::Value *)&v181);
          if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v166))
          {
            v150 = (uint64_t *)v181;
          }
          else
          {
            uint64_t v151 = *((void *)DefiningOp + 2);
            mlir::GenericProgramPoint::~GenericProgramPoint(DefiningOp);
            uint64_t v153 = *(void *)(v152 + 8);
            *(void *)(a5 + 24) = v151;
            *(void *)(a5 + 32) = v153;
            uint64_t v154 = *((void *)v168 + 3);
            uint64_t ElementTypeOrSelf = 0;
            LOBYTE(v164) = 1;
            v178 = mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>((mlir::UnitAttr **)(a5 + 8), v154, (uint64_t *)&v181, (uint64_t)&ElementTypeOrSelf, (unsigned __int8 *)&v164);
            v150 = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v178);
          }
          mlir::Value::replaceAllUsesExcept(&v167, v150, (uint64_t)DefiningOp);
        }
        if (v169 != &v170[8]) {
          free(v169);
        }
        if (__dst != &v173[8]) {
          free(__dst);
        }
        if (v175 != &v176[8]) {
          free(v175);
        }
        return 1;
      }
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v166);
      v181 = (int32x4_t *)v183;
      uint64_t v182 = 0x500000000;
      uint64_t v82 = (mlir::GenericProgramPoint *)(int)v81;
      if ((unint64_t)(v81 << 32) >= 0x500000001) {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v181, v183, (int)v81, 8);
      }
      if (v57)
      {
        uint64_t v83 = 4 * v57;
        do
        {
          uint64_t v84 = *v56;
          uint64_t v85 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v166) + 8 * v84);
          uint64_t v86 = v182;
          if (v182 >= (unint64_t)HIDWORD(v182))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v181, v183, v182 + 1, 8);
            uint64_t v86 = v182;
          }
          v181->i64[v86] = v85;
          unsigned int v87 = v182 + 1;
          LODWORD(v182) = v182 + 1;
          ++v56;
          v83 -= 4;
        }
        while (v83);
      }
      else
      {
        unsigned int v87 = v182;
      }
      v178 = (mlir::GenericProgramPoint *)v166[0];
      *(void *)(v69 + 8) = *(void *)(v69 + 8) & 7 | mlir::TensorType::clone((uint64_t)&v178, (uint64_t)v181, v87);
      if ((v156 & 1) != 0 || (*((unsigned char *)v168 + 46) & 0x80) == 0 || *((_DWORD *)v168 + 17) != 3)
      {
LABEL_197:
        if (v181 != (int32x4_t *)v183) {
          free(v181);
        }
        goto LABEL_199;
      }
      uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(void *)(*((void *)v168 + 9) + 88));
      if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 32)
      {
        v178 = v82;
        uint64_t v109 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v168 + 24));
        uint64_t v110 = mlir::IntegerType::get(v109, 0x40u, 1u);
        unint64_t v111 = (void *)mlir::RankedTensorType::get((uint64_t)&v178, 1, v110, 0);
        unint64_t v112 = v111;
        if (!v111) {
          goto LABEL_178;
        }
        uint64_t v113 = *v111;
        unint64_t v114 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v115 = *(unsigned int *)(v113 + 16);
        if (!v115) {
          goto LABEL_178;
        }
        uint64_t v116 = *(void **)(v113 + 8);
        uint64_t v117 = &v116[2 * v115];
        do
        {
          unint64_t v118 = v115 >> 1;
          unint64_t v119 = &v116[2 * (v115 >> 1)];
          unint64_t v121 = *v119;
          long long v120 = v119 + 2;
          v115 += ~(v115 >> 1);
          if (v121 < v114) {
            uint64_t v116 = v120;
          }
          else {
            unint64_t v115 = v118;
          }
        }
        while (v115);
        if (v116 != v117 && *v116 == v114) {
          uint64_t v122 = v116[1];
        }
        else {
LABEL_178:
        }
          uint64_t v122 = 0;
        uint64_t v123 = *((void *)v168 + 3);
        v178 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v112, v122, v181, 8 * v182, 8, 1, 1);
        uint64_t v124 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 8), v123, (uint64_t **)&v178);
LABEL_191:
        uint64_t v141 = (uint64_t *)((char *)v124 - 16);
        unint64_t v142 = (void *)*((void *)v168 + 9);
        v143 = v142 + 8;
        v144 = (void *)v142[9];
        if (v144)
        {
          void *v144 = *v143;
          if (*v143) {
            *(void *)(*v143 + 8) = v142[9];
          }
        }
        v142[11] = v141;
        v142[9] = v141;
        uint64_t v145 = *v141;
        v142[8] = *v141;
        if (v145) {
          *(void *)(v145 + 8) = v143;
        }
        *uint64_t v141 = (uint64_t)v143;
        goto LABEL_197;
      }
      uint64_t v88 = v181;
      unint64_t v89 = v182;
      v178 = v82;
      uint64_t v90 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v168 + 24));
      uint64_t v91 = mlir::IntegerType::get(v90, 0x20u, 1u);
      uint64_t v92 = (void *)mlir::RankedTensorType::get((uint64_t)&v178, 1, v91, 0);
      uint64_t v93 = v92;
      if (!v92) {
        goto LABEL_165;
      }
      uint64_t v94 = *v92;
      unint64_t v95 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v96 = *(unsigned int *)(v94 + 16);
      if (!v96) {
        goto LABEL_165;
      }
      char v97 = *(void **)(v94 + 8);
      unint64_t v98 = &v97[2 * v96];
      do
      {
        unint64_t v99 = v96 >> 1;
        uint64_t v100 = &v97[2 * (v96 >> 1)];
        unint64_t v102 = *v100;
        uint64_t v101 = v100 + 2;
        v96 += ~(v96 >> 1);
        if (v102 < v95) {
          char v97 = v101;
        }
        else {
          unint64_t v96 = v99;
        }
      }
      while (v96);
      if (v97 != v98 && *v97 == v95) {
        uint64_t v103 = v97[1];
      }
      else {
LABEL_165:
      }
        uint64_t v103 = 0;
      uint64_t v104 = (mlir::OpBuilder *)(a5 + 8);
      uint64_t v105 = *((void *)v168 + 3);
      v178 = (mlir::GenericProgramPoint *)v180;
      uint64_t v179 = 0x500000000;
      uint64_t v155 = v105;
      if (v89 < 6)
      {
        if (!v89)
        {
          int v140 = 0;
          uint64_t v108 = (uint64_t *)v180;
          uint64_t v125 = v155;
LABEL_189:
          LODWORD(v179) = v140 + v89;
          v164 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v93, v103, v108, 4 * (v140 + v89), 4, 1, 1);
          uint64_t v124 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v104, v125, &v164);
          if (v178 != (mlir::GenericProgramPoint *)v180) {
            free(v178);
          }
          goto LABEL_191;
        }
        uint64_t v107 = 0;
        uint64_t v108 = (uint64_t *)v180;
      }
      else
      {
        uint64_t v106 = v103;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v178, v180, v89, 4);
        uint64_t v103 = v106;
        uint64_t v104 = (mlir::OpBuilder *)(a5 + 8);
        uint64_t v107 = v179;
        uint64_t v108 = (uint64_t *)v178;
      }
      uint64_t v125 = v155;
      unsigned int v126 = (int32x4_t *)((char *)v108 + 4 * v107);
      unint64_t v127 = (v89 - 1) & 0x1FFFFFFFFFFFFFFFLL;
      if (v127 >= 7)
      {
        unint64_t v130 = v127 + 1;
        uint64_t v131 = (v127 + 1) & 0x3FFFFFFFFFFFFFF8;
        uint64_t v128 = (int32x4_t *)((char *)v126 + 4 * v131);
        uint64_t v129 = &v88->i8[8 * v131];
        unint64_t v132 = v88 + 2;
        uint64_t v133 = v126 + 1;
        uint64_t v134 = v131;
        do
        {
          int32x4_t v136 = v132[-2];
          int32x4_t v135 = v132[-1];
          int32x4_t v138 = *v132;
          int32x4_t v137 = v132[1];
          v132 += 4;
          v133[-1] = vuzp1q_s32(v136, v135);
          int32x4_t *v133 = vuzp1q_s32(v138, v137);
          v133 += 2;
          v134 -= 8;
        }
        while (v134);
        if (v130 == v131) {
          goto LABEL_188;
        }
      }
      else
      {
        uint64_t v128 = v126;
        uint64_t v129 = (char *)v88;
      }
      do
      {
        uint64_t v139 = *(void *)v129;
        v129 += 8;
        v128->i32[0] = v139;
        uint64_t v128 = (int32x4_t *)((char *)v128 + 4);
      }
      while (v129 != (char *)v88 + 8 * v89);
LABEL_188:
      int v140 = v179;
      goto LABEL_189;
    }
    unsigned int v57 = *((_DWORD *)v158 + 2);
    if (!v57)
    {
LABEL_102:
      if (v22 == v21) {
        goto LABEL_103;
      }
      goto LABEL_120;
    }
    if (v57 < 6)
    {
      unsigned int v58 = *((_DWORD *)v158 + 2);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v173[8], *((unsigned int *)v158 + 2), 4);
      unsigned int v58 = *((_DWORD *)v55 + 2);
      if (!v58)
      {
LABEL_101:
        *(_DWORD *)v173 = v57;
        std::string::size_type v56 = (unsigned int *)__dst;
        goto LABEL_102;
      }
      std::string::size_type v56 = (unsigned int *)__dst;
    }
    memcpy(v56, *v55, 4 * v58);
    goto LABEL_101;
  }
LABEL_6:
  uint64_t result = 0;
  if (a4)
  {
    switch(WeightsLayout)
    {
      case 2:
      case 9:
        if (a4 == 2) {
          goto LABEL_9;
        }
        goto LABEL_41;
      case 3:
      case 10:
        if (a4 == 1) {
          goto LABEL_9;
        }
LABEL_41:
        uint64_t result = 0;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t mlir::mps::anonymous namespace'::ConvertConvolutionInterface<mlir::mps::Conv2DOp>::convertLayout(mlir::Operation *,mlir::mps::LayoutConversionType,mlir::mps::LayoutConversionType,mlir::RewriterBase &)const::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)a1;
  uint64_t v5 = *(void *)(**(void **)(a1 + 8) + 24);
  uint64_t v6 = *(uint64_t **)(a1 + 16);
  if (a3)
  {
    uint64_t v7 = *v6;
    uint64_t v8 = &v21[8];
    __dst = &v21[8];
    *(void *)unsigned int v21 = 0x500000000;
    unint64_t v9 = *(unsigned int *)(v7 + 8);
    if ((void **)v7 == &__dst || v9 == 0)
    {
      unint64_t v9 = 0;
      goto LABEL_31;
    }
    if (v9 < 6)
    {
      unsigned int v13 = *(_DWORD *)(v7 + 8);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v21[8], *(unsigned int *)(v7 + 8), 4);
      unsigned int v13 = *(_DWORD *)(v7 + 8);
      if (!v13)
      {
LABEL_20:
        *(_DWORD *)unsigned int v21 = v9;
        uint64_t v8 = __dst;
        goto LABEL_31;
      }
      uint64_t v8 = __dst;
    }
    memcpy(v8, *(const void **)v7, 4 * v13);
    goto LABEL_20;
  }
  uint64_t v11 = (_DWORD *)v6[2];
  unsigned int v12 = *(_DWORD *)v6[1];
  if (v12 == *v11)
  {
    uint64_t v8 = &v21[8];
    __dst = &v21[8];
    unint64_t v9 = 5;
    *(_DWORD *)&uint64_t v21[4] = 5;
    if (v12 > 3)
    {
      int v22 = 4;
      *(_OWORD *)&v21[8] = xmmword_18110B6C0;
    }
    else
    {
      *(_OWORD *)&v21[8] = xmmword_1810FFF10;
      unint64_t v9 = 4;
    }
    *(_DWORD *)unsigned int v21 = v9;
  }
  else
  {
    switch(*v11)
    {
      case 1:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x100000003;
        long long v14 = xmmword_18110B6A0;
        goto LABEL_25;
      case 2:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x100000000;
        long long v14 = xmmword_18110B670;
        goto LABEL_25;
      case 3:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 1;
        long long v14 = xmmword_18110B680;
        goto LABEL_25;
      case 4:
      case 5:
      case 6:
        __break(1u);
        JUMPOUT(0x18055F730);
      case 7:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 3;
        BOOL v17 = &xmmword_18110B6E8;
        goto LABEL_29;
      case 8:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 1;
        BOOL v17 = &xmmword_18110B6D4;
        goto LABEL_29;
      case 9:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 2;
        BOOL v17 = &xmmword_18110B710;
LABEL_29:
        int v22 = v16;
        long long v15 = *v17;
        goto LABEL_30;
      case 0xA:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v22 = 0;
        long long v15 = xmmword_18110B6FC;
LABEL_30:
        *(_OWORD *)&v21[8] = v15;
        *(void *)unsigned int v21 = 0x500000005;
        unint64_t v9 = 5;
        break;
      default:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x200000001;
        long long v14 = xmmword_18110B690;
LABEL_25:
        *(_OWORD *)unsigned int v21 = v14;
        unint64_t v9 = 4;
        break;
    }
  }
LABEL_31:
  if (__dst != &v21[8]) {
    free(__dst);
  }
  return v18;
}

uint64_t mlir::mps::anonymous namespace'::permuteAttr(uint64_t a1, int *a2, uint64_t a3, uint64_t a4)
{
  v33[10] = *MEMORY[0x1E4F143B8];
  uint64_t v27 = a1;
  if (mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v27)) {
    return v27;
  }
  if (mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)&v27, 8, 1, 0))
  {
    uint64_t RawStringData = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&v27);
    char isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v27);
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v27);
    unint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v27);
    unint64_t v4 = NumElements;
    int v31 = v33;
    uint64_t v32 = 0xA00000000;
    if (NumElements < 0xB)
    {
      int v12 = 0;
      if (!NumElements) {
        goto LABEL_14;
      }
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v31, v33, NumElements, 8);
      int v12 = v32;
    }
    long long v14 = v31;
    LOBYTE(v13) = isSplat ^ 1;
  }
  else
  {
    int v12 = 0;
    uint64_t RawStringData = 0;
    unsigned int v13 = &v31;
    long long v14 = v33;
    int v31 = v33;
    uint64_t v32 = 0xA00000000;
  }
  uint64_t v15 = 0;
  int v16 = &v14[v12];
  do
  {
    if (v13) {
      uint64_t v17 = v15;
    }
    else {
      uint64_t v17 = 0;
    }
    v16[v15++] = *(void *)(RawStringData + 8 * v17);
  }
  while (v4 != v15);
LABEL_14:
  LODWORD(v32) = v12 + v4;
  unint64_t v18 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v27);
  unsigned int v28 = v30;
  uint64_t v29 = 0xA00000000;
  if (v18)
  {
    unint64_t v19 = v18;
    if (v18 < 0xB)
    {
      uint64_t v20 = 0;
      unint64_t v21 = v18;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v28, v30, v18, 8);
      uint64_t v20 = v29;
      unint64_t v21 = v19 - v29;
      if (v19 == v29) {
        goto LABEL_20;
      }
    }
    bzero((char *)v28 + 8 * v20, 8 * v21);
LABEL_20:
    LODWORD(v29) = v19;
  }
  if (a3)
  {
    uint64_t v22 = 0;
    do
    {
      uint64_t v23 = *a2++;
      memcpy((char *)v28 + v22, (char *)v31 + 8 * v23 * a4, 8 * a4);
      v22 += 8 * a4;
      --a3;
    }
    while (a3);
  }
  uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v27);
  uint64_t v8 = mlir::DenseElementsAttr::getFromRawBuffer(Value, v25, v28, 8 * v29, 8, 1, 0);
  if (v28 != v30) {
    free(v28);
  }
  if (v31 != v33) {
    free(v31);
  }
  return v8;
}

uint64_t mlir::mps::anonymous namespace'::permuteValue(uint64_t a1, uint64_t a2, uint64_t a3, void *__s2, unint64_t a5)
{
  uint64_t v7 = a3;
  v29[1] = *MEMORY[0x1E4F143B8];
  v23[1] = a5;
  uint64_t v24 = a3;
  v23[0] = (uint64_t)__s2;
  uint64_t v25 = (int32x4_t *)v27;
  uint64_t v26 = 0x400000000;
  if (!a5)
  {
    uint64_t v11 = (int32x4_t *)v27;
    goto LABEL_16;
  }
  if (a5 < 5)
  {
    uint64_t v10 = 0;
    uint64_t v11 = (int32x4_t *)v27;
    unint64_t v12 = a5;
    goto LABEL_7;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, a5, 4);
  uint64_t v10 = v26;
  uint64_t v11 = v25;
  unint64_t v12 = a5 - v26;
  if (a5 != v26) {
LABEL_7:
  }
    bzero((char *)v11 + 4 * v10, 4 * v12);
  LODWORD(v26) = a5;
  if (!a5) {
    goto LABEL_17;
  }
  unint64_t v13 = (a5 - 1) & 0x3FFFFFFFFFFFFFFFLL;
  if (v13 < 7)
  {
    LODWORD(v14) = 0;
    uint64_t v15 = v11;
    do
    {
LABEL_14:
      v15->i32[0] = v14;
      uint64_t v15 = (int32x4_t *)((char *)v15 + 4);
      LODWORD(v14) = v14 + 1;
    }
    while (v15 != (int32x4_t *)((char *)v11 + 4 * a5));
    goto LABEL_15;
  }
  unint64_t v16 = v13 + 1;
  uint64_t v14 = (v13 + 1) & 0x7FFFFFFFFFFFFFF8;
  uint64_t v15 = (int32x4_t *)((char *)v11 + 4 * v14);
  int32x4_t v17 = (int32x4_t)xmmword_1810FFF10;
  unint64_t v18 = v11 + 1;
  v19.i64[0] = 0x400000004;
  v19.i64[1] = 0x400000004;
  v20.i64[0] = 0x800000008;
  v20.i64[1] = 0x800000008;
  uint64_t v21 = v14;
  do
  {
    v18[-1] = v17;
    *unint64_t v18 = vaddq_s32(v17, v19);
    int32x4_t v17 = vaddq_s32(v17, v20);
    v18 += 2;
    v21 -= 8;
  }
  while (v21);
  if (v16 != v14) {
    goto LABEL_14;
  }
LABEL_15:
  if (a5 == v26)
  {
LABEL_16:
    if (!memcmp(v11, __s2, 4 * a5)) {
      goto LABEL_20;
    }
  }
LABEL_17:
  v28[0] = v29;
  v28[1] = (void *)0x100000000;
  mlir::OpBuilder::createOrFold<mlir::mps::PermuteOp,mlir::Value &,llvm::ArrayRef<int> &>((mlir::Builder *)(a1 + 8), (uint64_t)v28, a2, &v24, v23);
  uint64_t v7 = *(void *)v28[0];
  if (v28[0] != v29) {
    free(v28[0]);
  }
  uint64_t v11 = v25;
LABEL_20:
  if (v11 != (int32x4_t *)v27) {
    free(v11);
  }
  return v7;
}

void mlir::OpBuilder::createOrFold<mlir::mps::PermuteOp,mlir::Value &,llvm::ArrayRef<int> &>(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  v25[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a3;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.permute", (const unsigned __int8 *)0xB, Context);
  if (!v12)
  {
    __int16 v24 = 1283;
    uint64_t v23[2] = (uint64_t)"mps.permute";
    v23[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a3, v11);
  mlir::mps::PermuteOp::build(a1, v25, *a4, *a5, a5[1]);
  uint64_t v14 = (mlir::GenericProgramPoint *)mlir::Operation::create((mlir::Operation *)v25, v13);
  uint64_t v15 = *((void *)a1 + 2);
  if (v15)
  {
    unint64_t v16 = (uint64_t *)*((void *)a1 + 3);
    llvm::ilist_traits<mlir::Operation>::addNodeToList(v15 + 32, (uint64_t)v14);
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
    uint64_t v17 = *v16;
    *unint64_t v18 = *v16;
    v18[1] = (uint64_t)v16;
    *(void *)(v17 + 8) = v18;
    uint64_t *v16 = (uint64_t)v18;
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
  }
  if (mlir::OpBuilder::tryFold(a1, (uint64_t)v14, a2))
  {
    mlir::Operation::erase(v14);
  }
  else
  {
    uint64_t v19 = *((void *)a1 + 1);
    if (v19) {
      (*(void (**)(uint64_t, mlir::GenericProgramPoint *))(*(void *)v19 + 16))(v19, v14);
    }
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t a4, unsigned __int8 *a5)
{
  v20[38] = *MEMORY[0x1E4F143B8];
  uint64_t v15 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v15);
  uint64_t v10 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dynamic_shape_cast", (const unsigned __int8 *)0x16, Context);
  if (!v11)
  {
    __int16 v19 = 1283;
    uint64_t v18[2] = (uint64_t)"mps.dynamic_shape_cast";
    v18[3] = 22;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v17 = 259;
    llvm::operator+(v18, (uint64_t *)&v16, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v10);
  mlir::mps::DynamicShapeCastOp::build(a1, (uint64_t)v20, *a3, 0, *a5);
  char v12 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((void *)v12 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DynamicShapeCastOp,void>::id) {
    unint64_t v13 = v12;
  }
  else {
    unint64_t v13 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v13;
}

uint64_t mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConvertConvolutionInterface<mlir::mps::Conv2DDataGradientOp>>::convertLayout(uint64_t a1, void *a2, int a3, int a4, uint64_t a5)
{
  v183[5] = *MEMORY[0x1E4F143B8];
  v163 = a2;
  int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v163);
  int WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v163);
  if (a3)
  {
    switch(StorageType)
    {
      case 0:
      case 7:
        if (a3 != 2) {
          goto LABEL_6;
        }
        break;
      case 1:
      case 8:
        if (a3 != 1) {
          goto LABEL_6;
        }
        break;
      default:
        goto LABEL_6;
    }
LABEL_9:
    char v11 = *(void **)(v163[6] + 16);
    BOOL v14 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
    char v15 = v14;
    if (v14)
    {
      int v16 = 0;
      BOOL v17 = 1;
    }
    else
    {
      BOOL v17 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id;
      int v16 = !v17;
    }
    unsigned int v21 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v163);
    unsigned int v22 = v21;
    if (a3)
    {
      switch(v21)
      {
        case 2u:
        case 3u:
          BOOL v23 = a3 == 1;
          int v24 = 2;
          goto LABEL_45;
        case 4u:
        case 5u:
        case 6u:
LABEL_215:
          __break(1u);
          JUMPOUT(0x180560E70);
        case 7u:
        case 8u:
          BOOL v23 = a3 == 1;
          int v24 = 7;
          goto LABEL_45;
        case 9u:
        case 0xAu:
          BOOL v23 = a3 == 1;
          int v24 = 9;
LABEL_45:
          if (v23) {
            unsigned int v22 = v24;
          }
          else {
            unsigned int v22 = v24 + 1;
          }
          break;
        default:
          unsigned int v22 = a3 != 1;
          break;
      }
    }
    unsigned int v25 = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v163);
    unsigned int v162 = v25;
    if (a4)
    {
      switch(v25)
      {
        case 2u:
        case 3u:
          BOOL v26 = a4 == 1;
          int v27 = 2;
          goto LABEL_54;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
        case 8u:
          BOOL v26 = a4 == 1;
          int v27 = 7;
          goto LABEL_54;
        case 9u:
        case 0xAu:
          BOOL v26 = a4 == 1;
          int v27 = 9;
LABEL_54:
          if (v26) {
            unsigned int v25 = v27;
          }
          else {
            unsigned int v25 = v27 + 1;
          }
          break;
        default:
          unsigned int v25 = a4 != 1;
          break;
      }
    }
    unsigned int v161 = v25;
    char v156 = v15;
    if (v21 == v22)
    {
      v175 = &v176[8];
      unsigned int v28 = 5;
      *(_DWORD *)&v176[4] = 5;
      if (v21 > 3)
      {
        int v177 = 4;
        *(_OWORD *)&v176[8] = xmmword_18110B6C0;
      }
      else
      {
        *(_OWORD *)&v176[8] = xmmword_1810FFF10;
        unsigned int v28 = 4;
      }
      *(_DWORD *)v176 = v28;
    }
    else
    {
      switch(v22)
      {
        case 1u:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x100000003;
          long long v29 = xmmword_18110B6A0;
          goto LABEL_67;
        case 2u:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x100000000;
          long long v29 = xmmword_18110B670;
          goto LABEL_67;
        case 3u:
          v175 = &v176[8];
          *(void *)&v176[16] = 1;
          long long v29 = xmmword_18110B680;
          goto LABEL_67;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
          v175 = &v176[8];
          int v31 = 3;
          uint64_t v32 = &xmmword_18110B6E8;
          goto LABEL_72;
        case 8u:
          v175 = &v176[8];
          int v31 = 1;
          uint64_t v32 = &xmmword_18110B6D4;
          goto LABEL_72;
        case 9u:
          v175 = &v176[8];
          int v31 = 2;
          uint64_t v32 = &xmmword_18110B710;
LABEL_72:
          int v177 = v31;
          long long v30 = *v32;
          goto LABEL_73;
        case 0xAu:
          v175 = &v176[8];
          int v177 = 0;
          long long v30 = xmmword_18110B6FC;
LABEL_73:
          *(_OWORD *)&v176[8] = v30;
          *(void *)v176 = 0x500000005;
          unsigned int v28 = 5;
          break;
        default:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x200000001;
          long long v29 = xmmword_18110B690;
LABEL_67:
          *(_OWORD *)v176 = v29;
          unsigned int v28 = 4;
          break;
      }
    }
    v158 = &v175;
    v159 = &v162;
    v160 = &v161;
    v157[0] = a5;
    v157[1] = &v163;
    v157[2] = &v158;
    uint64_t v33 = *(void *)(v163[9] + 24);
    uint64_t v34 = v163[3];
    v181 = (int32x4_t *)v183;
    HIDWORD(v182) = 5;
    memcpy(v183, &v176[8], 4 * v28);
    LODWORD(v182) = v28;
    if (v181 != (int32x4_t *)v183) {
      free(v181);
    }
    unint64_t v37 = (uint64_t *)v163[9];
    char v38 = (uint64_t *)v37[1];
    if (v38)
    {
      *char v38 = *v37;
      if (*v37) {
        *(void *)(*v37 + 8) = v37[1];
      }
    }
    v37[3] = (uint64_t)v35;
    v37[1] = (uint64_t)v35;
    uint64_t v39 = *v35;
    uint64_t *v37 = *v35;
    if (v39) {
      *(void *)(v39 + 8) = v37;
    }
    *unint64_t v35 = (uint64_t)v37;
    unint64_t v40 = (void *)v163[9];
    uint64_t v41 = v40 + 4;
    uint64_t v42 = (void *)v40[5];
    if (v42)
    {
      void *v42 = *v41;
      if (*v41) {
        *(void *)(*v41 + 8) = v40[5];
      }
    }
    v40[7] = v36;
    v40[5] = v36;
    uint64_t v43 = *v36;
    v40[4] = *v36;
    if (v43) {
      *(void *)(v43 + 8) = v41;
    }
    uint64_t *v36 = (uint64_t)v41;
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v163 + 3));
    uint64_t v45 = mlir::mps::TensorDataLayoutAttr::get(Context, v22);
    mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr((uint64_t *)&v163, v45);
    char v46 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v163 + 3));
    uint64_t v47 = mlir::mps::TensorDataLayoutAttr::get(v46, v161);
    mlir::mps::Conv2DDataGradientOp::setWeightsLayoutAttr((uint64_t *)&v163, v47);
    uint64_t Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v163);
    mlir::mps::Conv2DDataGradientOp::setStridesAttr((uint64_t *)&v163, v49);
    uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v163);
    mlir::mps::Conv2DDataGradientOp::setDilationRatesAttr((uint64_t *)&v163, v51);
    uint64_t Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v163);
    mlir::mps::Conv2DDataGradientOp::setExplicitPaddingAttr((uint64_t *)&v163, v53);
    uint64_t v54 = (mlir::GenericProgramPoint *)v163;
    if (!v17)
    {
      unsigned int v59 = *v159;
      if (*v159 == *v160)
      {
        std::string::size_type v56 = (unsigned int *)&v173[8];
        __dst = &v173[8];
        unsigned int v57 = 5;
        *(_DWORD *)&v173[4] = 5;
        if (v59 > 3)
        {
          int v174 = 4;
          *(_OWORD *)&v173[8] = xmmword_18110B6C0;
        }
        else
        {
          *(_OWORD *)&v173[8] = xmmword_1810FFF10;
          unsigned int v57 = 4;
        }
        *(_DWORD *)v173 = v57;
      }
      else
      {
        switch(*v160)
        {
          case 1u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x100000003;
            long long v60 = xmmword_18110B6A0;
            goto LABEL_112;
          case 2u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x100000000;
            long long v60 = xmmword_18110B670;
            goto LABEL_112;
          case 3u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 1;
            long long v60 = xmmword_18110B680;
            goto LABEL_112;
          case 4u:
          case 5u:
          case 6u:
            goto LABEL_215;
          case 7u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 3;
            uint64_t v63 = &xmmword_18110B6E8;
            goto LABEL_116;
          case 8u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 1;
            uint64_t v63 = &xmmword_18110B6D4;
            goto LABEL_116;
          case 9u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 2;
            uint64_t v63 = &xmmword_18110B710;
LABEL_116:
            int v174 = v62;
            long long v64 = *v63;
            goto LABEL_118;
          case 0xAu:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v174 = 0;
            long long v64 = xmmword_18110B6FC;
LABEL_118:
            *(_OWORD *)&v173[8] = v64;
            *(void *)v173 = 0x500000005;
            unsigned int v57 = 5;
            break;
          default:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x200000001;
            long long v60 = xmmword_18110B690;
LABEL_112:
            *(_OWORD *)v173 = v60;
            unsigned int v57 = 4;
            break;
        }
      }
      unsigned int v21 = v162;
      if (v161 == v162) {
        goto LABEL_103;
      }
      goto LABEL_120;
    }
    char v55 = v158;
    std::string::size_type v56 = (unsigned int *)&v173[8];
    __dst = &v173[8];
    *(void *)v173 = 0x500000000;
    if (v158 == &__dst)
    {
      unsigned int v57 = 0;
      if (v22 == v21)
      {
LABEL_103:
        v169 = &v170[8];
        unint64_t v61 = 5;
        *(_DWORD *)&v170[4] = 5;
        if (v21 > 3)
        {
          int v171 = 4;
          *(_OWORD *)&v170[8] = xmmword_18110B6C0;
        }
        else
        {
          *(_OWORD *)&v170[8] = xmmword_1810FFF10;
          unint64_t v61 = 4;
        }
        *(_DWORD *)long long v170 = v61;
        goto LABEL_132;
      }
LABEL_120:
      switch(v21)
      {
        case 1u:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x100000003;
          long long v65 = xmmword_18110B6A0;
          goto LABEL_126;
        case 2u:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x100000000;
          long long v65 = xmmword_18110B670;
          goto LABEL_126;
        case 3u:
          v169 = &v170[8];
          *(void *)&v170[16] = 1;
          long long v65 = xmmword_18110B680;
          goto LABEL_126;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
          v169 = &v170[8];
          int v67 = 3;
          uint64_t v68 = &xmmword_18110B6E8;
          goto LABEL_130;
        case 8u:
          v169 = &v170[8];
          int v67 = 1;
          uint64_t v68 = &xmmword_18110B6D4;
          goto LABEL_130;
        case 9u:
          v169 = &v170[8];
          int v67 = 2;
          uint64_t v68 = &xmmword_18110B710;
LABEL_130:
          int v171 = v67;
          long long v66 = *v68;
          goto LABEL_131;
        case 0xAu:
          v169 = &v170[8];
          int v171 = 0;
          long long v66 = xmmword_18110B6FC;
LABEL_131:
          *(_OWORD *)&v170[8] = v66;
          *(void *)long long v170 = 0x500000005;
          unint64_t v61 = 5;
          break;
        default:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x200000001;
          long long v65 = xmmword_18110B690;
LABEL_126:
          *(_OWORD *)long long v170 = v65;
          unint64_t v61 = 4;
          break;
      }
LABEL_132:
      uint64_t v168 = v54;
      uint64_t v69 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v168);
      uint64_t v167 = (uint64_t **)v69;
      unint64_t v70 = (uint64_t *)(*(void *)(v69 + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v70) {
        goto LABEL_141;
      }
      uint64_t v71 = *v70;
      unint64_t v72 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v73 = *(unsigned int *)(v71 + 16);
      if (!v73) {
        goto LABEL_141;
      }
      unint64_t v74 = *(void **)(v71 + 8);
      uint64_t v75 = &v74[2 * v73];
      do
      {
        unint64_t v76 = v73 >> 1;
        uint64_t v77 = &v74[2 * (v73 >> 1)];
        unint64_t v79 = *v77;
        uint64_t v78 = v77 + 2;
        v73 += ~(v73 >> 1);
        if (v79 < v72) {
          unint64_t v74 = v78;
        }
        else {
          unint64_t v73 = v76;
        }
      }
      while (v73);
      if (v74 != v75 && *v74 == v72) {
        uint64_t v80 = v74[1];
      }
      else {
LABEL_141:
      }
        uint64_t v80 = 0;
      v166[0] = v70;
      v166[1] = v80;
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v166))
      {
LABEL_199:
        uint64_t v146 = *((void *)v168 + 2);
        mlir::GenericProgramPoint::~GenericProgramPoint(v168);
        uint64_t v148 = *(void *)(v147 + 8);
        *(void *)(a5 + 24) = v146;
        *(void *)(a5 + 32) = v148;
        if ((int32x4_t *)v69 != v181)
        {
          uint64_t DefiningOp = (mlir::GenericProgramPoint *)mlir::Value::getDefiningOp((mlir::Value *)&v181);
          if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v166))
          {
            v150 = (uint64_t *)v181;
          }
          else
          {
            uint64_t v151 = *((void *)DefiningOp + 2);
            mlir::GenericProgramPoint::~GenericProgramPoint(DefiningOp);
            uint64_t v153 = *(void *)(v152 + 8);
            *(void *)(a5 + 24) = v151;
            *(void *)(a5 + 32) = v153;
            uint64_t v154 = *((void *)v168 + 3);
            uint64_t ElementTypeOrSelf = 0;
            LOBYTE(v164) = 1;
            v178 = mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>((mlir::UnitAttr **)(a5 + 8), v154, (uint64_t *)&v181, (uint64_t)&ElementTypeOrSelf, (unsigned __int8 *)&v164);
            v150 = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v178);
          }
          mlir::Value::replaceAllUsesExcept(&v167, v150, (uint64_t)DefiningOp);
        }
        if (v169 != &v170[8]) {
          free(v169);
        }
        if (__dst != &v173[8]) {
          free(__dst);
        }
        if (v175 != &v176[8]) {
          free(v175);
        }
        return 1;
      }
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v166);
      v181 = (int32x4_t *)v183;
      uint64_t v182 = 0x500000000;
      uint64_t v82 = (mlir::GenericProgramPoint *)(int)v81;
      if ((unint64_t)(v81 << 32) >= 0x500000001) {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v181, v183, (int)v81, 8);
      }
      if (v57)
      {
        uint64_t v83 = 4 * v57;
        do
        {
          uint64_t v84 = *v56;
          uint64_t v85 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v166) + 8 * v84);
          uint64_t v86 = v182;
          if (v182 >= (unint64_t)HIDWORD(v182))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v181, v183, v182 + 1, 8);
            uint64_t v86 = v182;
          }
          v181->i64[v86] = v85;
          unsigned int v87 = v182 + 1;
          LODWORD(v182) = v182 + 1;
          ++v56;
          v83 -= 4;
        }
        while (v83);
      }
      else
      {
        unsigned int v87 = v182;
      }
      v178 = (mlir::GenericProgramPoint *)v166[0];
      *(void *)(v69 + 8) = *(void *)(v69 + 8) & 7 | mlir::TensorType::clone((uint64_t)&v178, (uint64_t)v181, v87);
      if ((v156 & 1) != 0 || (*((unsigned char *)v168 + 46) & 0x80) == 0 || *((_DWORD *)v168 + 17) != 3)
      {
LABEL_197:
        if (v181 != (int32x4_t *)v183) {
          free(v181);
        }
        goto LABEL_199;
      }
      uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(void *)(*((void *)v168 + 9) + 88));
      if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 32)
      {
        v178 = v82;
        uint64_t v109 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v168 + 24));
        uint64_t v110 = mlir::IntegerType::get(v109, 0x40u, 1u);
        unint64_t v111 = (void *)mlir::RankedTensorType::get((uint64_t)&v178, 1, v110, 0);
        unint64_t v112 = v111;
        if (!v111) {
          goto LABEL_178;
        }
        uint64_t v113 = *v111;
        unint64_t v114 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v115 = *(unsigned int *)(v113 + 16);
        if (!v115) {
          goto LABEL_178;
        }
        uint64_t v116 = *(void **)(v113 + 8);
        uint64_t v117 = &v116[2 * v115];
        do
        {
          unint64_t v118 = v115 >> 1;
          unint64_t v119 = &v116[2 * (v115 >> 1)];
          unint64_t v121 = *v119;
          long long v120 = v119 + 2;
          v115 += ~(v115 >> 1);
          if (v121 < v114) {
            uint64_t v116 = v120;
          }
          else {
            unint64_t v115 = v118;
          }
        }
        while (v115);
        if (v116 != v117 && *v116 == v114) {
          uint64_t v122 = v116[1];
        }
        else {
LABEL_178:
        }
          uint64_t v122 = 0;
        uint64_t v123 = *((void *)v168 + 3);
        v178 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v112, v122, v181, 8 * v182, 8, 1, 1);
        uint64_t v124 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 8), v123, (uint64_t **)&v178);
LABEL_191:
        uint64_t v141 = (uint64_t *)((char *)v124 - 16);
        unint64_t v142 = (void *)*((void *)v168 + 9);
        v143 = v142 + 8;
        v144 = (void *)v142[9];
        if (v144)
        {
          void *v144 = *v143;
          if (*v143) {
            *(void *)(*v143 + 8) = v142[9];
          }
        }
        v142[11] = v141;
        v142[9] = v141;
        uint64_t v145 = *v141;
        v142[8] = *v141;
        if (v145) {
          *(void *)(v145 + 8) = v143;
        }
        *uint64_t v141 = (uint64_t)v143;
        goto LABEL_197;
      }
      uint64_t v88 = v181;
      unint64_t v89 = v182;
      v178 = v82;
      uint64_t v90 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v168 + 24));
      uint64_t v91 = mlir::IntegerType::get(v90, 0x20u, 1u);
      uint64_t v92 = (void *)mlir::RankedTensorType::get((uint64_t)&v178, 1, v91, 0);
      uint64_t v93 = v92;
      if (!v92) {
        goto LABEL_165;
      }
      uint64_t v94 = *v92;
      unint64_t v95 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v96 = *(unsigned int *)(v94 + 16);
      if (!v96) {
        goto LABEL_165;
      }
      char v97 = *(void **)(v94 + 8);
      unint64_t v98 = &v97[2 * v96];
      do
      {
        unint64_t v99 = v96 >> 1;
        uint64_t v100 = &v97[2 * (v96 >> 1)];
        unint64_t v102 = *v100;
        uint64_t v101 = v100 + 2;
        v96 += ~(v96 >> 1);
        if (v102 < v95) {
          char v97 = v101;
        }
        else {
          unint64_t v96 = v99;
        }
      }
      while (v96);
      if (v97 != v98 && *v97 == v95) {
        uint64_t v103 = v97[1];
      }
      else {
LABEL_165:
      }
        uint64_t v103 = 0;
      uint64_t v104 = (mlir::OpBuilder *)(a5 + 8);
      uint64_t v105 = *((void *)v168 + 3);
      v178 = (mlir::GenericProgramPoint *)v180;
      uint64_t v179 = 0x500000000;
      uint64_t v155 = v105;
      if (v89 < 6)
      {
        if (!v89)
        {
          int v140 = 0;
          uint64_t v108 = (uint64_t *)v180;
          uint64_t v125 = v155;
LABEL_189:
          LODWORD(v179) = v140 + v89;
          v164 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v93, v103, v108, 4 * (v140 + v89), 4, 1, 1);
          uint64_t v124 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v104, v125, &v164);
          if (v178 != (mlir::GenericProgramPoint *)v180) {
            free(v178);
          }
          goto LABEL_191;
        }
        uint64_t v107 = 0;
        uint64_t v108 = (uint64_t *)v180;
      }
      else
      {
        uint64_t v106 = v103;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v178, v180, v89, 4);
        uint64_t v103 = v106;
        uint64_t v104 = (mlir::OpBuilder *)(a5 + 8);
        uint64_t v107 = v179;
        uint64_t v108 = (uint64_t *)v178;
      }
      uint64_t v125 = v155;
      unsigned int v126 = (int32x4_t *)((char *)v108 + 4 * v107);
      unint64_t v127 = (v89 - 1) & 0x1FFFFFFFFFFFFFFFLL;
      if (v127 >= 7)
      {
        unint64_t v130 = v127 + 1;
        uint64_t v131 = (v127 + 1) & 0x3FFFFFFFFFFFFFF8;
        uint64_t v128 = (int32x4_t *)((char *)v126 + 4 * v131);
        uint64_t v129 = &v88->i8[8 * v131];
        unint64_t v132 = v88 + 2;
        uint64_t v133 = v126 + 1;
        uint64_t v134 = v131;
        do
        {
          int32x4_t v136 = v132[-2];
          int32x4_t v135 = v132[-1];
          int32x4_t v138 = *v132;
          int32x4_t v137 = v132[1];
          v132 += 4;
          v133[-1] = vuzp1q_s32(v136, v135);
          int32x4_t *v133 = vuzp1q_s32(v138, v137);
          v133 += 2;
          v134 -= 8;
        }
        while (v134);
        if (v130 == v131) {
          goto LABEL_188;
        }
      }
      else
      {
        uint64_t v128 = v126;
        uint64_t v129 = (char *)v88;
      }
      do
      {
        uint64_t v139 = *(void *)v129;
        v129 += 8;
        v128->i32[0] = v139;
        uint64_t v128 = (int32x4_t *)((char *)v128 + 4);
      }
      while (v129 != (char *)v88 + 8 * v89);
LABEL_188:
      int v140 = v179;
      goto LABEL_189;
    }
    unsigned int v57 = *((_DWORD *)v158 + 2);
    if (!v57)
    {
LABEL_102:
      if (v22 == v21) {
        goto LABEL_103;
      }
      goto LABEL_120;
    }
    if (v57 < 6)
    {
      unsigned int v58 = *((_DWORD *)v158 + 2);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v173[8], *((unsigned int *)v158 + 2), 4);
      unsigned int v58 = *((_DWORD *)v55 + 2);
      if (!v58)
      {
LABEL_101:
        *(_DWORD *)v173 = v57;
        std::string::size_type v56 = (unsigned int *)__dst;
        goto LABEL_102;
      }
      std::string::size_type v56 = (unsigned int *)__dst;
    }
    memcpy(v56, *v55, 4 * v58);
    goto LABEL_101;
  }
LABEL_6:
  uint64_t result = 0;
  if (a4)
  {
    switch(WeightsLayout)
    {
      case 2:
      case 9:
        if (a4 == 2) {
          goto LABEL_9;
        }
        goto LABEL_41;
      case 3:
      case 10:
        if (a4 == 1) {
          goto LABEL_9;
        }
LABEL_41:
        uint64_t result = 0;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t mlir::mps::anonymous namespace'::ConvertConvolutionInterface<mlir::mps::Conv2DDataGradientOp>::convertLayout(mlir::Operation *,mlir::mps::LayoutConversionType,mlir::mps::LayoutConversionType,mlir::RewriterBase &)const::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)a1;
  uint64_t v5 = *(void *)(**(void **)(a1 + 8) + 24);
  uint64_t v6 = *(uint64_t **)(a1 + 16);
  if (a3)
  {
    uint64_t v7 = *v6;
    uint64_t v8 = &v21[8];
    __dst = &v21[8];
    *(void *)unsigned int v21 = 0x500000000;
    unint64_t v9 = *(unsigned int *)(v7 + 8);
    if ((void **)v7 == &__dst || v9 == 0)
    {
      unint64_t v9 = 0;
      goto LABEL_31;
    }
    if (v9 < 6)
    {
      unsigned int v13 = *(_DWORD *)(v7 + 8);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v21[8], *(unsigned int *)(v7 + 8), 4);
      unsigned int v13 = *(_DWORD *)(v7 + 8);
      if (!v13)
      {
LABEL_20:
        *(_DWORD *)unsigned int v21 = v9;
        uint64_t v8 = __dst;
        goto LABEL_31;
      }
      uint64_t v8 = __dst;
    }
    memcpy(v8, *(const void **)v7, 4 * v13);
    goto LABEL_20;
  }
  char v11 = (_DWORD *)v6[2];
  unsigned int v12 = *(_DWORD *)v6[1];
  if (v12 == *v11)
  {
    uint64_t v8 = &v21[8];
    __dst = &v21[8];
    unint64_t v9 = 5;
    *(_DWORD *)&uint64_t v21[4] = 5;
    if (v12 > 3)
    {
      int v22 = 4;
      *(_OWORD *)&v21[8] = xmmword_18110B6C0;
    }
    else
    {
      *(_OWORD *)&v21[8] = xmmword_1810FFF10;
      unint64_t v9 = 4;
    }
    *(_DWORD *)unsigned int v21 = v9;
  }
  else
  {
    switch(*v11)
    {
      case 1:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x100000003;
        long long v14 = xmmword_18110B6A0;
        goto LABEL_25;
      case 2:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x100000000;
        long long v14 = xmmword_18110B670;
        goto LABEL_25;
      case 3:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 1;
        long long v14 = xmmword_18110B680;
        goto LABEL_25;
      case 4:
      case 5:
      case 6:
        __break(1u);
        JUMPOUT(0x180561268);
      case 7:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 3;
        BOOL v17 = &xmmword_18110B6E8;
        goto LABEL_29;
      case 8:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 1;
        BOOL v17 = &xmmword_18110B6D4;
        goto LABEL_29;
      case 9:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 2;
        BOOL v17 = &xmmword_18110B710;
LABEL_29:
        int v22 = v16;
        long long v15 = *v17;
        goto LABEL_30;
      case 0xA:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v22 = 0;
        long long v15 = xmmword_18110B6FC;
LABEL_30:
        *(_OWORD *)&v21[8] = v15;
        *(void *)unsigned int v21 = 0x500000005;
        unint64_t v9 = 5;
        break;
      default:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x200000001;
        long long v14 = xmmword_18110B690;
LABEL_25:
        *(_OWORD *)unsigned int v21 = v14;
        unint64_t v9 = 4;
        break;
    }
  }
LABEL_31:
  if (__dst != &v21[8]) {
    free(__dst);
  }
  return v18;
}

uint64_t mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConvertConvolutionInterface<mlir::mps::Conv2DWeightsGradientOp>>::convertLayout(uint64_t a1, void *a2, int a3, int a4, uint64_t a5)
{
  v183[5] = *MEMORY[0x1E4F143B8];
  v163 = a2;
  int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v163);
  int WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v163);
  if (a3)
  {
    switch(StorageType)
    {
      case 0:
      case 7:
        if (a3 != 2) {
          goto LABEL_6;
        }
        break;
      case 1:
      case 8:
        if (a3 != 1) {
          goto LABEL_6;
        }
        break;
      default:
        goto LABEL_6;
    }
LABEL_9:
    char v11 = *(void **)(v163[6] + 16);
    BOOL v14 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
    char v15 = v14;
    if (v14)
    {
      int v16 = 0;
      BOOL v17 = 1;
    }
    else
    {
      BOOL v17 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id;
      int v16 = !v17;
    }
    unsigned int v21 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v163);
    unsigned int v22 = v21;
    if (a3)
    {
      switch(v21)
      {
        case 2u:
        case 3u:
          BOOL v23 = a3 == 1;
          int v24 = 2;
          goto LABEL_45;
        case 4u:
        case 5u:
        case 6u:
LABEL_215:
          __break(1u);
          JUMPOUT(0x180562258);
        case 7u:
        case 8u:
          BOOL v23 = a3 == 1;
          int v24 = 7;
          goto LABEL_45;
        case 9u:
        case 0xAu:
          BOOL v23 = a3 == 1;
          int v24 = 9;
LABEL_45:
          if (v23) {
            unsigned int v22 = v24;
          }
          else {
            unsigned int v22 = v24 + 1;
          }
          break;
        default:
          unsigned int v22 = a3 != 1;
          break;
      }
    }
    unsigned int v25 = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v163);
    unsigned int v162 = v25;
    if (a4)
    {
      switch(v25)
      {
        case 2u:
        case 3u:
          BOOL v26 = a4 == 1;
          int v27 = 2;
          goto LABEL_54;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
        case 8u:
          BOOL v26 = a4 == 1;
          int v27 = 7;
          goto LABEL_54;
        case 9u:
        case 0xAu:
          BOOL v26 = a4 == 1;
          int v27 = 9;
LABEL_54:
          if (v26) {
            unsigned int v25 = v27;
          }
          else {
            unsigned int v25 = v27 + 1;
          }
          break;
        default:
          unsigned int v25 = a4 != 1;
          break;
      }
    }
    unsigned int v161 = v25;
    char v156 = v15;
    if (v21 == v22)
    {
      v175 = &v176[8];
      unsigned int v28 = 5;
      *(_DWORD *)&v176[4] = 5;
      if (v21 > 3)
      {
        int v177 = 4;
        *(_OWORD *)&v176[8] = xmmword_18110B6C0;
      }
      else
      {
        *(_OWORD *)&v176[8] = xmmword_1810FFF10;
        unsigned int v28 = 4;
      }
      *(_DWORD *)v176 = v28;
    }
    else
    {
      switch(v22)
      {
        case 1u:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x100000003;
          long long v29 = xmmword_18110B6A0;
          goto LABEL_67;
        case 2u:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x100000000;
          long long v29 = xmmword_18110B670;
          goto LABEL_67;
        case 3u:
          v175 = &v176[8];
          *(void *)&v176[16] = 1;
          long long v29 = xmmword_18110B680;
          goto LABEL_67;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
          v175 = &v176[8];
          int v31 = 3;
          uint64_t v32 = &xmmword_18110B6E8;
          goto LABEL_72;
        case 8u:
          v175 = &v176[8];
          int v31 = 1;
          uint64_t v32 = &xmmword_18110B6D4;
          goto LABEL_72;
        case 9u:
          v175 = &v176[8];
          int v31 = 2;
          uint64_t v32 = &xmmword_18110B710;
LABEL_72:
          int v177 = v31;
          long long v30 = *v32;
          goto LABEL_73;
        case 0xAu:
          v175 = &v176[8];
          int v177 = 0;
          long long v30 = xmmword_18110B6FC;
LABEL_73:
          *(_OWORD *)&v176[8] = v30;
          *(void *)v176 = 0x500000005;
          unsigned int v28 = 5;
          break;
        default:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x200000001;
          long long v29 = xmmword_18110B690;
LABEL_67:
          *(_OWORD *)v176 = v29;
          unsigned int v28 = 4;
          break;
      }
    }
    v158 = &v175;
    v159 = &v162;
    v160 = &v161;
    v157[0] = a5;
    v157[1] = &v163;
    v157[2] = &v158;
    uint64_t v33 = *(void *)(v163[9] + 24);
    uint64_t v34 = v163[3];
    v181 = (int32x4_t *)v183;
    HIDWORD(v182) = 5;
    memcpy(v183, &v176[8], 4 * v28);
    LODWORD(v182) = v28;
    if (v181 != (int32x4_t *)v183) {
      free(v181);
    }
    unint64_t v37 = (uint64_t *)v163[9];
    char v38 = (uint64_t *)v37[1];
    if (v38)
    {
      *char v38 = *v37;
      if (*v37) {
        *(void *)(*v37 + 8) = v37[1];
      }
    }
    v37[3] = (uint64_t)v35;
    v37[1] = (uint64_t)v35;
    uint64_t v39 = *v35;
    uint64_t *v37 = *v35;
    if (v39) {
      *(void *)(v39 + 8) = v37;
    }
    *unint64_t v35 = (uint64_t)v37;
    unint64_t v40 = (void *)v163[9];
    uint64_t v41 = v40 + 4;
    uint64_t v42 = (void *)v40[5];
    if (v42)
    {
      void *v42 = *v41;
      if (*v41) {
        *(void *)(*v41 + 8) = v40[5];
      }
    }
    v40[7] = v36;
    v40[5] = v36;
    uint64_t v43 = *v36;
    v40[4] = *v36;
    if (v43) {
      *(void *)(v43 + 8) = v41;
    }
    uint64_t *v36 = (uint64_t)v41;
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v163 + 3));
    uint64_t v45 = mlir::mps::TensorDataLayoutAttr::get(Context, v22);
    mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr((uint64_t *)&v163, v45);
    char v46 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v163 + 3));
    uint64_t v47 = mlir::mps::TensorDataLayoutAttr::get(v46, v161);
    mlir::mps::Conv2DDataGradientOp::setWeightsLayoutAttr((uint64_t *)&v163, v47);
    uint64_t Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v163);
    mlir::mps::Conv2DDataGradientOp::setStridesAttr((uint64_t *)&v163, v49);
    uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v163);
    mlir::mps::Conv2DDataGradientOp::setDilationRatesAttr((uint64_t *)&v163, v51);
    uint64_t Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v163);
    mlir::mps::Conv2DDataGradientOp::setExplicitPaddingAttr((uint64_t *)&v163, v53);
    uint64_t v54 = (mlir::GenericProgramPoint *)v163;
    if (!v17)
    {
      unsigned int v59 = *v159;
      if (*v159 == *v160)
      {
        std::string::size_type v56 = (unsigned int *)&v173[8];
        __dst = &v173[8];
        unsigned int v57 = 5;
        *(_DWORD *)&v173[4] = 5;
        if (v59 > 3)
        {
          int v174 = 4;
          *(_OWORD *)&v173[8] = xmmword_18110B6C0;
        }
        else
        {
          *(_OWORD *)&v173[8] = xmmword_1810FFF10;
          unsigned int v57 = 4;
        }
        *(_DWORD *)v173 = v57;
      }
      else
      {
        switch(*v160)
        {
          case 1u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x100000003;
            long long v60 = xmmword_18110B6A0;
            goto LABEL_112;
          case 2u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x100000000;
            long long v60 = xmmword_18110B670;
            goto LABEL_112;
          case 3u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 1;
            long long v60 = xmmword_18110B680;
            goto LABEL_112;
          case 4u:
          case 5u:
          case 6u:
            goto LABEL_215;
          case 7u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 3;
            uint64_t v63 = &xmmword_18110B6E8;
            goto LABEL_116;
          case 8u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 1;
            uint64_t v63 = &xmmword_18110B6D4;
            goto LABEL_116;
          case 9u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 2;
            uint64_t v63 = &xmmword_18110B710;
LABEL_116:
            int v174 = v62;
            long long v64 = *v63;
            goto LABEL_118;
          case 0xAu:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v174 = 0;
            long long v64 = xmmword_18110B6FC;
LABEL_118:
            *(_OWORD *)&v173[8] = v64;
            *(void *)v173 = 0x500000005;
            unsigned int v57 = 5;
            break;
          default:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x200000001;
            long long v60 = xmmword_18110B690;
LABEL_112:
            *(_OWORD *)v173 = v60;
            unsigned int v57 = 4;
            break;
        }
      }
      unsigned int v21 = v162;
      if (v161 == v162) {
        goto LABEL_103;
      }
      goto LABEL_120;
    }
    char v55 = v158;
    std::string::size_type v56 = (unsigned int *)&v173[8];
    __dst = &v173[8];
    *(void *)v173 = 0x500000000;
    if (v158 == &__dst)
    {
      unsigned int v57 = 0;
      if (v22 == v21)
      {
LABEL_103:
        v169 = &v170[8];
        unint64_t v61 = 5;
        *(_DWORD *)&v170[4] = 5;
        if (v21 > 3)
        {
          int v171 = 4;
          *(_OWORD *)&v170[8] = xmmword_18110B6C0;
        }
        else
        {
          *(_OWORD *)&v170[8] = xmmword_1810FFF10;
          unint64_t v61 = 4;
        }
        *(_DWORD *)long long v170 = v61;
        goto LABEL_132;
      }
LABEL_120:
      switch(v21)
      {
        case 1u:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x100000003;
          long long v65 = xmmword_18110B6A0;
          goto LABEL_126;
        case 2u:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x100000000;
          long long v65 = xmmword_18110B670;
          goto LABEL_126;
        case 3u:
          v169 = &v170[8];
          *(void *)&v170[16] = 1;
          long long v65 = xmmword_18110B680;
          goto LABEL_126;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
          v169 = &v170[8];
          int v67 = 3;
          uint64_t v68 = &xmmword_18110B6E8;
          goto LABEL_130;
        case 8u:
          v169 = &v170[8];
          int v67 = 1;
          uint64_t v68 = &xmmword_18110B6D4;
          goto LABEL_130;
        case 9u:
          v169 = &v170[8];
          int v67 = 2;
          uint64_t v68 = &xmmword_18110B710;
LABEL_130:
          int v171 = v67;
          long long v66 = *v68;
          goto LABEL_131;
        case 0xAu:
          v169 = &v170[8];
          int v171 = 0;
          long long v66 = xmmword_18110B6FC;
LABEL_131:
          *(_OWORD *)&v170[8] = v66;
          *(void *)long long v170 = 0x500000005;
          unint64_t v61 = 5;
          break;
        default:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x200000001;
          long long v65 = xmmword_18110B690;
LABEL_126:
          *(_OWORD *)long long v170 = v65;
          unint64_t v61 = 4;
          break;
      }
LABEL_132:
      uint64_t v168 = v54;
      uint64_t v69 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v168);
      uint64_t v167 = (uint64_t **)v69;
      unint64_t v70 = (uint64_t *)(*(void *)(v69 + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v70) {
        goto LABEL_141;
      }
      uint64_t v71 = *v70;
      unint64_t v72 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v73 = *(unsigned int *)(v71 + 16);
      if (!v73) {
        goto LABEL_141;
      }
      unint64_t v74 = *(void **)(v71 + 8);
      uint64_t v75 = &v74[2 * v73];
      do
      {
        unint64_t v76 = v73 >> 1;
        uint64_t v77 = &v74[2 * (v73 >> 1)];
        unint64_t v79 = *v77;
        uint64_t v78 = v77 + 2;
        v73 += ~(v73 >> 1);
        if (v79 < v72) {
          unint64_t v74 = v78;
        }
        else {
          unint64_t v73 = v76;
        }
      }
      while (v73);
      if (v74 != v75 && *v74 == v72) {
        uint64_t v80 = v74[1];
      }
      else {
LABEL_141:
      }
        uint64_t v80 = 0;
      v166[0] = v70;
      v166[1] = v80;
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v166))
      {
LABEL_199:
        uint64_t v146 = *((void *)v168 + 2);
        mlir::GenericProgramPoint::~GenericProgramPoint(v168);
        uint64_t v148 = *(void *)(v147 + 8);
        *(void *)(a5 + 24) = v146;
        *(void *)(a5 + 32) = v148;
        if ((int32x4_t *)v69 != v181)
        {
          uint64_t DefiningOp = (mlir::GenericProgramPoint *)mlir::Value::getDefiningOp((mlir::Value *)&v181);
          if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v166))
          {
            v150 = (uint64_t *)v181;
          }
          else
          {
            uint64_t v151 = *((void *)DefiningOp + 2);
            mlir::GenericProgramPoint::~GenericProgramPoint(DefiningOp);
            uint64_t v153 = *(void *)(v152 + 8);
            *(void *)(a5 + 24) = v151;
            *(void *)(a5 + 32) = v153;
            uint64_t v154 = *((void *)v168 + 3);
            uint64_t ElementTypeOrSelf = 0;
            LOBYTE(v164) = 1;
            v178 = mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>((mlir::UnitAttr **)(a5 + 8), v154, (uint64_t *)&v181, (uint64_t)&ElementTypeOrSelf, (unsigned __int8 *)&v164);
            v150 = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v178);
          }
          mlir::Value::replaceAllUsesExcept(&v167, v150, (uint64_t)DefiningOp);
        }
        if (v169 != &v170[8]) {
          free(v169);
        }
        if (__dst != &v173[8]) {
          free(__dst);
        }
        if (v175 != &v176[8]) {
          free(v175);
        }
        return 1;
      }
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v166);
      v181 = (int32x4_t *)v183;
      uint64_t v182 = 0x500000000;
      uint64_t v82 = (mlir::GenericProgramPoint *)(int)v81;
      if ((unint64_t)(v81 << 32) >= 0x500000001) {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v181, v183, (int)v81, 8);
      }
      if (v57)
      {
        uint64_t v83 = 4 * v57;
        do
        {
          uint64_t v84 = *v56;
          uint64_t v85 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v166) + 8 * v84);
          uint64_t v86 = v182;
          if (v182 >= (unint64_t)HIDWORD(v182))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v181, v183, v182 + 1, 8);
            uint64_t v86 = v182;
          }
          v181->i64[v86] = v85;
          unsigned int v87 = v182 + 1;
          LODWORD(v182) = v182 + 1;
          ++v56;
          v83 -= 4;
        }
        while (v83);
      }
      else
      {
        unsigned int v87 = v182;
      }
      v178 = (mlir::GenericProgramPoint *)v166[0];
      *(void *)(v69 + 8) = *(void *)(v69 + 8) & 7 | mlir::TensorType::clone((uint64_t)&v178, (uint64_t)v181, v87);
      if ((v156 & 1) != 0 || (*((unsigned char *)v168 + 46) & 0x80) == 0 || *((_DWORD *)v168 + 17) != 3)
      {
LABEL_197:
        if (v181 != (int32x4_t *)v183) {
          free(v181);
        }
        goto LABEL_199;
      }
      uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(void *)(*((void *)v168 + 9) + 88));
      if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 32)
      {
        v178 = v82;
        uint64_t v109 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v168 + 24));
        uint64_t v110 = mlir::IntegerType::get(v109, 0x40u, 1u);
        unint64_t v111 = (void *)mlir::RankedTensorType::get((uint64_t)&v178, 1, v110, 0);
        unint64_t v112 = v111;
        if (!v111) {
          goto LABEL_178;
        }
        uint64_t v113 = *v111;
        unint64_t v114 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v115 = *(unsigned int *)(v113 + 16);
        if (!v115) {
          goto LABEL_178;
        }
        uint64_t v116 = *(void **)(v113 + 8);
        uint64_t v117 = &v116[2 * v115];
        do
        {
          unint64_t v118 = v115 >> 1;
          unint64_t v119 = &v116[2 * (v115 >> 1)];
          unint64_t v121 = *v119;
          long long v120 = v119 + 2;
          v115 += ~(v115 >> 1);
          if (v121 < v114) {
            uint64_t v116 = v120;
          }
          else {
            unint64_t v115 = v118;
          }
        }
        while (v115);
        if (v116 != v117 && *v116 == v114) {
          uint64_t v122 = v116[1];
        }
        else {
LABEL_178:
        }
          uint64_t v122 = 0;
        uint64_t v123 = *((void *)v168 + 3);
        v178 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v112, v122, v181, 8 * v182, 8, 1, 1);
        uint64_t v124 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 8), v123, (uint64_t **)&v178);
LABEL_191:
        uint64_t v141 = (uint64_t *)((char *)v124 - 16);
        unint64_t v142 = (void *)*((void *)v168 + 9);
        v143 = v142 + 8;
        v144 = (void *)v142[9];
        if (v144)
        {
          void *v144 = *v143;
          if (*v143) {
            *(void *)(*v143 + 8) = v142[9];
          }
        }
        v142[11] = v141;
        v142[9] = v141;
        uint64_t v145 = *v141;
        v142[8] = *v141;
        if (v145) {
          *(void *)(v145 + 8) = v143;
        }
        *uint64_t v141 = (uint64_t)v143;
        goto LABEL_197;
      }
      uint64_t v88 = v181;
      unint64_t v89 = v182;
      v178 = v82;
      uint64_t v90 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v168 + 24));
      uint64_t v91 = mlir::IntegerType::get(v90, 0x20u, 1u);
      uint64_t v92 = (void *)mlir::RankedTensorType::get((uint64_t)&v178, 1, v91, 0);
      uint64_t v93 = v92;
      if (!v92) {
        goto LABEL_165;
      }
      uint64_t v94 = *v92;
      unint64_t v95 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v96 = *(unsigned int *)(v94 + 16);
      if (!v96) {
        goto LABEL_165;
      }
      char v97 = *(void **)(v94 + 8);
      unint64_t v98 = &v97[2 * v96];
      do
      {
        unint64_t v99 = v96 >> 1;
        uint64_t v100 = &v97[2 * (v96 >> 1)];
        unint64_t v102 = *v100;
        uint64_t v101 = v100 + 2;
        v96 += ~(v96 >> 1);
        if (v102 < v95) {
          char v97 = v101;
        }
        else {
          unint64_t v96 = v99;
        }
      }
      while (v96);
      if (v97 != v98 && *v97 == v95) {
        uint64_t v103 = v97[1];
      }
      else {
LABEL_165:
      }
        uint64_t v103 = 0;
      uint64_t v104 = (mlir::OpBuilder *)(a5 + 8);
      uint64_t v105 = *((void *)v168 + 3);
      v178 = (mlir::GenericProgramPoint *)v180;
      uint64_t v179 = 0x500000000;
      uint64_t v155 = v105;
      if (v89 < 6)
      {
        if (!v89)
        {
          int v140 = 0;
          uint64_t v108 = (uint64_t *)v180;
          uint64_t v125 = v155;
LABEL_189:
          LODWORD(v179) = v140 + v89;
          v164 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v93, v103, v108, 4 * (v140 + v89), 4, 1, 1);
          uint64_t v124 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v104, v125, &v164);
          if (v178 != (mlir::GenericProgramPoint *)v180) {
            free(v178);
          }
          goto LABEL_191;
        }
        uint64_t v107 = 0;
        uint64_t v108 = (uint64_t *)v180;
      }
      else
      {
        uint64_t v106 = v103;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v178, v180, v89, 4);
        uint64_t v103 = v106;
        uint64_t v104 = (mlir::OpBuilder *)(a5 + 8);
        uint64_t v107 = v179;
        uint64_t v108 = (uint64_t *)v178;
      }
      uint64_t v125 = v155;
      unsigned int v126 = (int32x4_t *)((char *)v108 + 4 * v107);
      unint64_t v127 = (v89 - 1) & 0x1FFFFFFFFFFFFFFFLL;
      if (v127 >= 7)
      {
        unint64_t v130 = v127 + 1;
        uint64_t v131 = (v127 + 1) & 0x3FFFFFFFFFFFFFF8;
        uint64_t v128 = (int32x4_t *)((char *)v126 + 4 * v131);
        uint64_t v129 = &v88->i8[8 * v131];
        unint64_t v132 = v88 + 2;
        uint64_t v133 = v126 + 1;
        uint64_t v134 = v131;
        do
        {
          int32x4_t v136 = v132[-2];
          int32x4_t v135 = v132[-1];
          int32x4_t v138 = *v132;
          int32x4_t v137 = v132[1];
          v132 += 4;
          v133[-1] = vuzp1q_s32(v136, v135);
          int32x4_t *v133 = vuzp1q_s32(v138, v137);
          v133 += 2;
          v134 -= 8;
        }
        while (v134);
        if (v130 == v131) {
          goto LABEL_188;
        }
      }
      else
      {
        uint64_t v128 = v126;
        uint64_t v129 = (char *)v88;
      }
      do
      {
        uint64_t v139 = *(void *)v129;
        v129 += 8;
        v128->i32[0] = v139;
        uint64_t v128 = (int32x4_t *)((char *)v128 + 4);
      }
      while (v129 != (char *)v88 + 8 * v89);
LABEL_188:
      int v140 = v179;
      goto LABEL_189;
    }
    unsigned int v57 = *((_DWORD *)v158 + 2);
    if (!v57)
    {
LABEL_102:
      if (v22 == v21) {
        goto LABEL_103;
      }
      goto LABEL_120;
    }
    if (v57 < 6)
    {
      unsigned int v58 = *((_DWORD *)v158 + 2);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v173[8], *((unsigned int *)v158 + 2), 4);
      unsigned int v58 = *((_DWORD *)v55 + 2);
      if (!v58)
      {
LABEL_101:
        *(_DWORD *)v173 = v57;
        std::string::size_type v56 = (unsigned int *)__dst;
        goto LABEL_102;
      }
      std::string::size_type v56 = (unsigned int *)__dst;
    }
    memcpy(v56, *v55, 4 * v58);
    goto LABEL_101;
  }
LABEL_6:
  uint64_t result = 0;
  if (a4)
  {
    switch(WeightsLayout)
    {
      case 2:
      case 9:
        if (a4 == 2) {
          goto LABEL_9;
        }
        goto LABEL_41;
      case 3:
      case 10:
        if (a4 == 1) {
          goto LABEL_9;
        }
LABEL_41:
        uint64_t result = 0;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t mlir::mps::anonymous namespace'::ConvertConvolutionInterface<mlir::mps::Conv2DWeightsGradientOp>::convertLayout(mlir::Operation *,mlir::mps::LayoutConversionType,mlir::mps::LayoutConversionType,mlir::RewriterBase &)const::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)a1;
  uint64_t v5 = *(void *)(**(void **)(a1 + 8) + 24);
  uint64_t v6 = *(uint64_t **)(a1 + 16);
  if (a3)
  {
    uint64_t v7 = *v6;
    uint64_t v8 = &v21[8];
    __dst = &v21[8];
    *(void *)unsigned int v21 = 0x500000000;
    unint64_t v9 = *(unsigned int *)(v7 + 8);
    if ((void **)v7 == &__dst || v9 == 0)
    {
      unint64_t v9 = 0;
      goto LABEL_31;
    }
    if (v9 < 6)
    {
      unsigned int v13 = *(_DWORD *)(v7 + 8);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v21[8], *(unsigned int *)(v7 + 8), 4);
      unsigned int v13 = *(_DWORD *)(v7 + 8);
      if (!v13)
      {
LABEL_20:
        *(_DWORD *)unsigned int v21 = v9;
        uint64_t v8 = __dst;
        goto LABEL_31;
      }
      uint64_t v8 = __dst;
    }
    memcpy(v8, *(const void **)v7, 4 * v13);
    goto LABEL_20;
  }
  char v11 = (_DWORD *)v6[2];
  unsigned int v12 = *(_DWORD *)v6[1];
  if (v12 == *v11)
  {
    uint64_t v8 = &v21[8];
    __dst = &v21[8];
    unint64_t v9 = 5;
    *(_DWORD *)&uint64_t v21[4] = 5;
    if (v12 > 3)
    {
      int v22 = 4;
      *(_OWORD *)&v21[8] = xmmword_18110B6C0;
    }
    else
    {
      *(_OWORD *)&v21[8] = xmmword_1810FFF10;
      unint64_t v9 = 4;
    }
    *(_DWORD *)unsigned int v21 = v9;
  }
  else
  {
    switch(*v11)
    {
      case 1:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x100000003;
        long long v14 = xmmword_18110B6A0;
        goto LABEL_25;
      case 2:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x100000000;
        long long v14 = xmmword_18110B670;
        goto LABEL_25;
      case 3:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 1;
        long long v14 = xmmword_18110B680;
        goto LABEL_25;
      case 4:
      case 5:
      case 6:
        __break(1u);
        JUMPOUT(0x180562650);
      case 7:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 3;
        BOOL v17 = &xmmword_18110B6E8;
        goto LABEL_29;
      case 8:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 1;
        BOOL v17 = &xmmword_18110B6D4;
        goto LABEL_29;
      case 9:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 2;
        BOOL v17 = &xmmword_18110B710;
LABEL_29:
        int v22 = v16;
        long long v15 = *v17;
        goto LABEL_30;
      case 0xA:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v22 = 0;
        long long v15 = xmmword_18110B6FC;
LABEL_30:
        *(_OWORD *)&v21[8] = v15;
        *(void *)unsigned int v21 = 0x500000005;
        unint64_t v9 = 5;
        break;
      default:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x200000001;
        long long v14 = xmmword_18110B690;
LABEL_25:
        *(_OWORD *)unsigned int v21 = v14;
        unint64_t v9 = 4;
        break;
    }
  }
LABEL_31:
  if (__dst != &v21[8]) {
    free(__dst);
  }
  return v18;
}

uint64_t mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConvertConvolutionInterface<mlir::mps::Conv3DOp>>::convertLayout(uint64_t a1, void *a2, int a3, int a4, uint64_t a5)
{
  v183[5] = *MEMORY[0x1E4F143B8];
  v163 = a2;
  int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v163);
  int WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v163);
  if (a3)
  {
    switch(StorageType)
    {
      case 0:
      case 7:
        if (a3 != 2) {
          goto LABEL_6;
        }
        break;
      case 1:
      case 8:
        if (a3 != 1) {
          goto LABEL_6;
        }
        break;
      default:
        goto LABEL_6;
    }
LABEL_9:
    char v11 = *(void **)(v163[6] + 16);
    BOOL v14 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
    char v15 = v14;
    if (v14)
    {
      int v16 = 0;
      BOOL v17 = 1;
    }
    else
    {
      BOOL v17 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id;
      int v16 = !v17;
    }
    unsigned int v21 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v163);
    unsigned int v22 = v21;
    if (a3)
    {
      switch(v21)
      {
        case 2u:
        case 3u:
          BOOL v23 = a3 == 1;
          int v24 = 2;
          goto LABEL_45;
        case 4u:
        case 5u:
        case 6u:
LABEL_215:
          __break(1u);
          JUMPOUT(0x180563640);
        case 7u:
        case 8u:
          BOOL v23 = a3 == 1;
          int v24 = 7;
          goto LABEL_45;
        case 9u:
        case 0xAu:
          BOOL v23 = a3 == 1;
          int v24 = 9;
LABEL_45:
          if (v23) {
            unsigned int v22 = v24;
          }
          else {
            unsigned int v22 = v24 + 1;
          }
          break;
        default:
          unsigned int v22 = a3 != 1;
          break;
      }
    }
    unsigned int v25 = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v163);
    unsigned int v162 = v25;
    if (a4)
    {
      switch(v25)
      {
        case 2u:
        case 3u:
          BOOL v26 = a4 == 1;
          int v27 = 2;
          goto LABEL_54;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
        case 8u:
          BOOL v26 = a4 == 1;
          int v27 = 7;
          goto LABEL_54;
        case 9u:
        case 0xAu:
          BOOL v26 = a4 == 1;
          int v27 = 9;
LABEL_54:
          if (v26) {
            unsigned int v25 = v27;
          }
          else {
            unsigned int v25 = v27 + 1;
          }
          break;
        default:
          unsigned int v25 = a4 != 1;
          break;
      }
    }
    unsigned int v161 = v25;
    char v156 = v15;
    if (v21 == v22)
    {
      v175 = &v176[8];
      unsigned int v28 = 5;
      *(_DWORD *)&v176[4] = 5;
      if (v21 > 3)
      {
        int v177 = 4;
        *(_OWORD *)&v176[8] = xmmword_18110B6C0;
      }
      else
      {
        *(_OWORD *)&v176[8] = xmmword_1810FFF10;
        unsigned int v28 = 4;
      }
      *(_DWORD *)v176 = v28;
    }
    else
    {
      switch(v22)
      {
        case 1u:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x100000003;
          long long v29 = xmmword_18110B6A0;
          goto LABEL_67;
        case 2u:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x100000000;
          long long v29 = xmmword_18110B670;
          goto LABEL_67;
        case 3u:
          v175 = &v176[8];
          *(void *)&v176[16] = 1;
          long long v29 = xmmword_18110B680;
          goto LABEL_67;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
          v175 = &v176[8];
          int v31 = 3;
          uint64_t v32 = &xmmword_18110B6E8;
          goto LABEL_72;
        case 8u:
          v175 = &v176[8];
          int v31 = 1;
          uint64_t v32 = &xmmword_18110B6D4;
          goto LABEL_72;
        case 9u:
          v175 = &v176[8];
          int v31 = 2;
          uint64_t v32 = &xmmword_18110B710;
LABEL_72:
          int v177 = v31;
          long long v30 = *v32;
          goto LABEL_73;
        case 0xAu:
          v175 = &v176[8];
          int v177 = 0;
          long long v30 = xmmword_18110B6FC;
LABEL_73:
          *(_OWORD *)&v176[8] = v30;
          *(void *)v176 = 0x500000005;
          unsigned int v28 = 5;
          break;
        default:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x200000001;
          long long v29 = xmmword_18110B690;
LABEL_67:
          *(_OWORD *)v176 = v29;
          unsigned int v28 = 4;
          break;
      }
    }
    v158 = &v175;
    v159 = &v162;
    v160 = &v161;
    v157[0] = a5;
    v157[1] = &v163;
    v157[2] = &v158;
    uint64_t v33 = *(void *)(v163[9] + 24);
    uint64_t v34 = v163[3];
    v181 = (int32x4_t *)v183;
    HIDWORD(v182) = 5;
    memcpy(v183, &v176[8], 4 * v28);
    LODWORD(v182) = v28;
    if (v181 != (int32x4_t *)v183) {
      free(v181);
    }
    unint64_t v37 = (uint64_t *)v163[9];
    char v38 = (uint64_t *)v37[1];
    if (v38)
    {
      *char v38 = *v37;
      if (*v37) {
        *(void *)(*v37 + 8) = v37[1];
      }
    }
    v37[3] = (uint64_t)v35;
    v37[1] = (uint64_t)v35;
    uint64_t v39 = *v35;
    uint64_t *v37 = *v35;
    if (v39) {
      *(void *)(v39 + 8) = v37;
    }
    *unint64_t v35 = (uint64_t)v37;
    unint64_t v40 = (void *)v163[9];
    uint64_t v41 = v40 + 4;
    uint64_t v42 = (void *)v40[5];
    if (v42)
    {
      void *v42 = *v41;
      if (*v41) {
        *(void *)(*v41 + 8) = v40[5];
      }
    }
    v40[7] = v36;
    v40[5] = v36;
    uint64_t v43 = *v36;
    v40[4] = *v36;
    if (v43) {
      *(void *)(v43 + 8) = v41;
    }
    uint64_t *v36 = (uint64_t)v41;
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v163 + 3));
    uint64_t v45 = mlir::mps::TensorDataLayoutAttr::get(Context, v22);
    mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr((uint64_t *)&v163, v45);
    char v46 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v163 + 3));
    uint64_t v47 = mlir::mps::TensorDataLayoutAttr::get(v46, v161);
    mlir::mps::Conv2DDataGradientOp::setWeightsLayoutAttr((uint64_t *)&v163, v47);
    uint64_t Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v163);
    mlir::mps::Conv2DDataGradientOp::setStridesAttr((uint64_t *)&v163, v49);
    uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v163);
    mlir::mps::Conv2DDataGradientOp::setDilationRatesAttr((uint64_t *)&v163, v51);
    uint64_t Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v163);
    mlir::mps::Conv2DDataGradientOp::setExplicitPaddingAttr((uint64_t *)&v163, v53);
    uint64_t v54 = (mlir::GenericProgramPoint *)v163;
    if (!v17)
    {
      unsigned int v59 = *v159;
      if (*v159 == *v160)
      {
        std::string::size_type v56 = (unsigned int *)&v173[8];
        __dst = &v173[8];
        unsigned int v57 = 5;
        *(_DWORD *)&v173[4] = 5;
        if (v59 > 3)
        {
          int v174 = 4;
          *(_OWORD *)&v173[8] = xmmword_18110B6C0;
        }
        else
        {
          *(_OWORD *)&v173[8] = xmmword_1810FFF10;
          unsigned int v57 = 4;
        }
        *(_DWORD *)v173 = v57;
      }
      else
      {
        switch(*v160)
        {
          case 1u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x100000003;
            long long v60 = xmmword_18110B6A0;
            goto LABEL_112;
          case 2u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x100000000;
            long long v60 = xmmword_18110B670;
            goto LABEL_112;
          case 3u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 1;
            long long v60 = xmmword_18110B680;
            goto LABEL_112;
          case 4u:
          case 5u:
          case 6u:
            goto LABEL_215;
          case 7u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 3;
            uint64_t v63 = &xmmword_18110B6E8;
            goto LABEL_116;
          case 8u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 1;
            uint64_t v63 = &xmmword_18110B6D4;
            goto LABEL_116;
          case 9u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 2;
            uint64_t v63 = &xmmword_18110B710;
LABEL_116:
            int v174 = v62;
            long long v64 = *v63;
            goto LABEL_118;
          case 0xAu:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v174 = 0;
            long long v64 = xmmword_18110B6FC;
LABEL_118:
            *(_OWORD *)&v173[8] = v64;
            *(void *)v173 = 0x500000005;
            unsigned int v57 = 5;
            break;
          default:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x200000001;
            long long v60 = xmmword_18110B690;
LABEL_112:
            *(_OWORD *)v173 = v60;
            unsigned int v57 = 4;
            break;
        }
      }
      unsigned int v21 = v162;
      if (v161 == v162) {
        goto LABEL_103;
      }
      goto LABEL_120;
    }
    char v55 = v158;
    std::string::size_type v56 = (unsigned int *)&v173[8];
    __dst = &v173[8];
    *(void *)v173 = 0x500000000;
    if (v158 == &__dst)
    {
      unsigned int v57 = 0;
      if (v22 == v21)
      {
LABEL_103:
        v169 = &v170[8];
        unint64_t v61 = 5;
        *(_DWORD *)&v170[4] = 5;
        if (v21 > 3)
        {
          int v171 = 4;
          *(_OWORD *)&v170[8] = xmmword_18110B6C0;
        }
        else
        {
          *(_OWORD *)&v170[8] = xmmword_1810FFF10;
          unint64_t v61 = 4;
        }
        *(_DWORD *)long long v170 = v61;
        goto LABEL_132;
      }
LABEL_120:
      switch(v21)
      {
        case 1u:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x100000003;
          long long v65 = xmmword_18110B6A0;
          goto LABEL_126;
        case 2u:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x100000000;
          long long v65 = xmmword_18110B670;
          goto LABEL_126;
        case 3u:
          v169 = &v170[8];
          *(void *)&v170[16] = 1;
          long long v65 = xmmword_18110B680;
          goto LABEL_126;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
          v169 = &v170[8];
          int v67 = 3;
          uint64_t v68 = &xmmword_18110B6E8;
          goto LABEL_130;
        case 8u:
          v169 = &v170[8];
          int v67 = 1;
          uint64_t v68 = &xmmword_18110B6D4;
          goto LABEL_130;
        case 9u:
          v169 = &v170[8];
          int v67 = 2;
          uint64_t v68 = &xmmword_18110B710;
LABEL_130:
          int v171 = v67;
          long long v66 = *v68;
          goto LABEL_131;
        case 0xAu:
          v169 = &v170[8];
          int v171 = 0;
          long long v66 = xmmword_18110B6FC;
LABEL_131:
          *(_OWORD *)&v170[8] = v66;
          *(void *)long long v170 = 0x500000005;
          unint64_t v61 = 5;
          break;
        default:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x200000001;
          long long v65 = xmmword_18110B690;
LABEL_126:
          *(_OWORD *)long long v170 = v65;
          unint64_t v61 = 4;
          break;
      }
LABEL_132:
      uint64_t v168 = v54;
      uint64_t v69 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v168);
      uint64_t v167 = (uint64_t **)v69;
      unint64_t v70 = (uint64_t *)(*(void *)(v69 + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v70) {
        goto LABEL_141;
      }
      uint64_t v71 = *v70;
      unint64_t v72 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v73 = *(unsigned int *)(v71 + 16);
      if (!v73) {
        goto LABEL_141;
      }
      unint64_t v74 = *(void **)(v71 + 8);
      uint64_t v75 = &v74[2 * v73];
      do
      {
        unint64_t v76 = v73 >> 1;
        uint64_t v77 = &v74[2 * (v73 >> 1)];
        unint64_t v79 = *v77;
        uint64_t v78 = v77 + 2;
        v73 += ~(v73 >> 1);
        if (v79 < v72) {
          unint64_t v74 = v78;
        }
        else {
          unint64_t v73 = v76;
        }
      }
      while (v73);
      if (v74 != v75 && *v74 == v72) {
        uint64_t v80 = v74[1];
      }
      else {
LABEL_141:
      }
        uint64_t v80 = 0;
      v166[0] = v70;
      v166[1] = v80;
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v166))
      {
LABEL_199:
        uint64_t v146 = *((void *)v168 + 2);
        mlir::GenericProgramPoint::~GenericProgramPoint(v168);
        uint64_t v148 = *(void *)(v147 + 8);
        *(void *)(a5 + 24) = v146;
        *(void *)(a5 + 32) = v148;
        if ((int32x4_t *)v69 != v181)
        {
          uint64_t DefiningOp = (mlir::GenericProgramPoint *)mlir::Value::getDefiningOp((mlir::Value *)&v181);
          if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v166))
          {
            v150 = (uint64_t *)v181;
          }
          else
          {
            uint64_t v151 = *((void *)DefiningOp + 2);
            mlir::GenericProgramPoint::~GenericProgramPoint(DefiningOp);
            uint64_t v153 = *(void *)(v152 + 8);
            *(void *)(a5 + 24) = v151;
            *(void *)(a5 + 32) = v153;
            uint64_t v154 = *((void *)v168 + 3);
            uint64_t ElementTypeOrSelf = 0;
            LOBYTE(v164) = 1;
            v178 = mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>((mlir::UnitAttr **)(a5 + 8), v154, (uint64_t *)&v181, (uint64_t)&ElementTypeOrSelf, (unsigned __int8 *)&v164);
            v150 = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v178);
          }
          mlir::Value::replaceAllUsesExcept(&v167, v150, (uint64_t)DefiningOp);
        }
        if (v169 != &v170[8]) {
          free(v169);
        }
        if (__dst != &v173[8]) {
          free(__dst);
        }
        if (v175 != &v176[8]) {
          free(v175);
        }
        return 1;
      }
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v166);
      v181 = (int32x4_t *)v183;
      uint64_t v182 = 0x500000000;
      uint64_t v82 = (mlir::GenericProgramPoint *)(int)v81;
      if ((unint64_t)(v81 << 32) >= 0x500000001) {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v181, v183, (int)v81, 8);
      }
      if (v57)
      {
        uint64_t v83 = 4 * v57;
        do
        {
          uint64_t v84 = *v56;
          uint64_t v85 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v166) + 8 * v84);
          uint64_t v86 = v182;
          if (v182 >= (unint64_t)HIDWORD(v182))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v181, v183, v182 + 1, 8);
            uint64_t v86 = v182;
          }
          v181->i64[v86] = v85;
          unsigned int v87 = v182 + 1;
          LODWORD(v182) = v182 + 1;
          ++v56;
          v83 -= 4;
        }
        while (v83);
      }
      else
      {
        unsigned int v87 = v182;
      }
      v178 = (mlir::GenericProgramPoint *)v166[0];
      *(void *)(v69 + 8) = *(void *)(v69 + 8) & 7 | mlir::TensorType::clone((uint64_t)&v178, (uint64_t)v181, v87);
      if ((v156 & 1) != 0 || (*((unsigned char *)v168 + 46) & 0x80) == 0 || *((_DWORD *)v168 + 17) != 3)
      {
LABEL_197:
        if (v181 != (int32x4_t *)v183) {
          free(v181);
        }
        goto LABEL_199;
      }
      uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(void *)(*((void *)v168 + 9) + 88));
      if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 32)
      {
        v178 = v82;
        uint64_t v109 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v168 + 24));
        uint64_t v110 = mlir::IntegerType::get(v109, 0x40u, 1u);
        unint64_t v111 = (void *)mlir::RankedTensorType::get((uint64_t)&v178, 1, v110, 0);
        unint64_t v112 = v111;
        if (!v111) {
          goto LABEL_178;
        }
        uint64_t v113 = *v111;
        unint64_t v114 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v115 = *(unsigned int *)(v113 + 16);
        if (!v115) {
          goto LABEL_178;
        }
        uint64_t v116 = *(void **)(v113 + 8);
        uint64_t v117 = &v116[2 * v115];
        do
        {
          unint64_t v118 = v115 >> 1;
          unint64_t v119 = &v116[2 * (v115 >> 1)];
          unint64_t v121 = *v119;
          long long v120 = v119 + 2;
          v115 += ~(v115 >> 1);
          if (v121 < v114) {
            uint64_t v116 = v120;
          }
          else {
            unint64_t v115 = v118;
          }
        }
        while (v115);
        if (v116 != v117 && *v116 == v114) {
          uint64_t v122 = v116[1];
        }
        else {
LABEL_178:
        }
          uint64_t v122 = 0;
        uint64_t v123 = *((void *)v168 + 3);
        v178 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v112, v122, v181, 8 * v182, 8, 1, 1);
        uint64_t v124 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 8), v123, (uint64_t **)&v178);
LABEL_191:
        uint64_t v141 = (uint64_t *)((char *)v124 - 16);
        unint64_t v142 = (void *)*((void *)v168 + 9);
        v143 = v142 + 8;
        v144 = (void *)v142[9];
        if (v144)
        {
          void *v144 = *v143;
          if (*v143) {
            *(void *)(*v143 + 8) = v142[9];
          }
        }
        v142[11] = v141;
        v142[9] = v141;
        uint64_t v145 = *v141;
        v142[8] = *v141;
        if (v145) {
          *(void *)(v145 + 8) = v143;
        }
        *uint64_t v141 = (uint64_t)v143;
        goto LABEL_197;
      }
      uint64_t v88 = v181;
      unint64_t v89 = v182;
      v178 = v82;
      uint64_t v90 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v168 + 24));
      uint64_t v91 = mlir::IntegerType::get(v90, 0x20u, 1u);
      uint64_t v92 = (void *)mlir::RankedTensorType::get((uint64_t)&v178, 1, v91, 0);
      uint64_t v93 = v92;
      if (!v92) {
        goto LABEL_165;
      }
      uint64_t v94 = *v92;
      unint64_t v95 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v96 = *(unsigned int *)(v94 + 16);
      if (!v96) {
        goto LABEL_165;
      }
      char v97 = *(void **)(v94 + 8);
      unint64_t v98 = &v97[2 * v96];
      do
      {
        unint64_t v99 = v96 >> 1;
        uint64_t v100 = &v97[2 * (v96 >> 1)];
        unint64_t v102 = *v100;
        uint64_t v101 = v100 + 2;
        v96 += ~(v96 >> 1);
        if (v102 < v95) {
          char v97 = v101;
        }
        else {
          unint64_t v96 = v99;
        }
      }
      while (v96);
      if (v97 != v98 && *v97 == v95) {
        uint64_t v103 = v97[1];
      }
      else {
LABEL_165:
      }
        uint64_t v103 = 0;
      uint64_t v104 = (mlir::OpBuilder *)(a5 + 8);
      uint64_t v105 = *((void *)v168 + 3);
      v178 = (mlir::GenericProgramPoint *)v180;
      uint64_t v179 = 0x500000000;
      uint64_t v155 = v105;
      if (v89 < 6)
      {
        if (!v89)
        {
          int v140 = 0;
          uint64_t v108 = (uint64_t *)v180;
          uint64_t v125 = v155;
LABEL_189:
          LODWORD(v179) = v140 + v89;
          v164 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v93, v103, v108, 4 * (v140 + v89), 4, 1, 1);
          uint64_t v124 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v104, v125, &v164);
          if (v178 != (mlir::GenericProgramPoint *)v180) {
            free(v178);
          }
          goto LABEL_191;
        }
        uint64_t v107 = 0;
        uint64_t v108 = (uint64_t *)v180;
      }
      else
      {
        uint64_t v106 = v103;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v178, v180, v89, 4);
        uint64_t v103 = v106;
        uint64_t v104 = (mlir::OpBuilder *)(a5 + 8);
        uint64_t v107 = v179;
        uint64_t v108 = (uint64_t *)v178;
      }
      uint64_t v125 = v155;
      unsigned int v126 = (int32x4_t *)((char *)v108 + 4 * v107);
      unint64_t v127 = (v89 - 1) & 0x1FFFFFFFFFFFFFFFLL;
      if (v127 >= 7)
      {
        unint64_t v130 = v127 + 1;
        uint64_t v131 = (v127 + 1) & 0x3FFFFFFFFFFFFFF8;
        uint64_t v128 = (int32x4_t *)((char *)v126 + 4 * v131);
        uint64_t v129 = &v88->i8[8 * v131];
        unint64_t v132 = v88 + 2;
        uint64_t v133 = v126 + 1;
        uint64_t v134 = v131;
        do
        {
          int32x4_t v136 = v132[-2];
          int32x4_t v135 = v132[-1];
          int32x4_t v138 = *v132;
          int32x4_t v137 = v132[1];
          v132 += 4;
          v133[-1] = vuzp1q_s32(v136, v135);
          int32x4_t *v133 = vuzp1q_s32(v138, v137);
          v133 += 2;
          v134 -= 8;
        }
        while (v134);
        if (v130 == v131) {
          goto LABEL_188;
        }
      }
      else
      {
        uint64_t v128 = v126;
        uint64_t v129 = (char *)v88;
      }
      do
      {
        uint64_t v139 = *(void *)v129;
        v129 += 8;
        v128->i32[0] = v139;
        uint64_t v128 = (int32x4_t *)((char *)v128 + 4);
      }
      while (v129 != (char *)v88 + 8 * v89);
LABEL_188:
      int v140 = v179;
      goto LABEL_189;
    }
    unsigned int v57 = *((_DWORD *)v158 + 2);
    if (!v57)
    {
LABEL_102:
      if (v22 == v21) {
        goto LABEL_103;
      }
      goto LABEL_120;
    }
    if (v57 < 6)
    {
      unsigned int v58 = *((_DWORD *)v158 + 2);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v173[8], *((unsigned int *)v158 + 2), 4);
      unsigned int v58 = *((_DWORD *)v55 + 2);
      if (!v58)
      {
LABEL_101:
        *(_DWORD *)v173 = v57;
        std::string::size_type v56 = (unsigned int *)__dst;
        goto LABEL_102;
      }
      std::string::size_type v56 = (unsigned int *)__dst;
    }
    memcpy(v56, *v55, 4 * v58);
    goto LABEL_101;
  }
LABEL_6:
  uint64_t result = 0;
  if (a4)
  {
    switch(WeightsLayout)
    {
      case 2:
      case 9:
        if (a4 == 2) {
          goto LABEL_9;
        }
        goto LABEL_41;
      case 3:
      case 10:
        if (a4 == 1) {
          goto LABEL_9;
        }
LABEL_41:
        uint64_t result = 0;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t mlir::mps::anonymous namespace'::ConvertConvolutionInterface<mlir::mps::Conv3DOp>::convertLayout(mlir::Operation *,mlir::mps::LayoutConversionType,mlir::mps::LayoutConversionType,mlir::RewriterBase &)const::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)a1;
  uint64_t v5 = *(void *)(**(void **)(a1 + 8) + 24);
  uint64_t v6 = *(uint64_t **)(a1 + 16);
  if (a3)
  {
    uint64_t v7 = *v6;
    uint64_t v8 = &v21[8];
    __dst = &v21[8];
    *(void *)unsigned int v21 = 0x500000000;
    unint64_t v9 = *(unsigned int *)(v7 + 8);
    if ((void **)v7 == &__dst || v9 == 0)
    {
      unint64_t v9 = 0;
      goto LABEL_31;
    }
    if (v9 < 6)
    {
      unsigned int v13 = *(_DWORD *)(v7 + 8);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v21[8], *(unsigned int *)(v7 + 8), 4);
      unsigned int v13 = *(_DWORD *)(v7 + 8);
      if (!v13)
      {
LABEL_20:
        *(_DWORD *)unsigned int v21 = v9;
        uint64_t v8 = __dst;
        goto LABEL_31;
      }
      uint64_t v8 = __dst;
    }
    memcpy(v8, *(const void **)v7, 4 * v13);
    goto LABEL_20;
  }
  char v11 = (_DWORD *)v6[2];
  unsigned int v12 = *(_DWORD *)v6[1];
  if (v12 == *v11)
  {
    uint64_t v8 = &v21[8];
    __dst = &v21[8];
    unint64_t v9 = 5;
    *(_DWORD *)&uint64_t v21[4] = 5;
    if (v12 > 3)
    {
      int v22 = 4;
      *(_OWORD *)&v21[8] = xmmword_18110B6C0;
    }
    else
    {
      *(_OWORD *)&v21[8] = xmmword_1810FFF10;
      unint64_t v9 = 4;
    }
    *(_DWORD *)unsigned int v21 = v9;
  }
  else
  {
    switch(*v11)
    {
      case 1:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x100000003;
        long long v14 = xmmword_18110B6A0;
        goto LABEL_25;
      case 2:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x100000000;
        long long v14 = xmmword_18110B670;
        goto LABEL_25;
      case 3:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 1;
        long long v14 = xmmword_18110B680;
        goto LABEL_25;
      case 4:
      case 5:
      case 6:
        __break(1u);
        JUMPOUT(0x180563A38);
      case 7:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 3;
        BOOL v17 = &xmmword_18110B6E8;
        goto LABEL_29;
      case 8:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 1;
        BOOL v17 = &xmmword_18110B6D4;
        goto LABEL_29;
      case 9:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 2;
        BOOL v17 = &xmmword_18110B710;
LABEL_29:
        int v22 = v16;
        long long v15 = *v17;
        goto LABEL_30;
      case 0xA:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v22 = 0;
        long long v15 = xmmword_18110B6FC;
LABEL_30:
        *(_OWORD *)&v21[8] = v15;
        *(void *)unsigned int v21 = 0x500000005;
        unint64_t v9 = 5;
        break;
      default:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x200000001;
        long long v14 = xmmword_18110B690;
LABEL_25:
        *(_OWORD *)unsigned int v21 = v14;
        unint64_t v9 = 4;
        break;
    }
  }
LABEL_31:
  if (__dst != &v21[8]) {
    free(__dst);
  }
  return v18;
}

uint64_t mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConvertConvolutionInterface<mlir::mps::Conv3DDataGradientOp>>::convertLayout(uint64_t a1, void *a2, int a3, int a4, uint64_t a5)
{
  v183[5] = *MEMORY[0x1E4F143B8];
  v163 = a2;
  int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v163);
  int WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v163);
  if (a3)
  {
    switch(StorageType)
    {
      case 0:
      case 7:
        if (a3 != 2) {
          goto LABEL_6;
        }
        break;
      case 1:
      case 8:
        if (a3 != 1) {
          goto LABEL_6;
        }
        break;
      default:
        goto LABEL_6;
    }
LABEL_9:
    char v11 = *(void **)(v163[6] + 16);
    BOOL v14 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
    char v15 = v14;
    if (v14)
    {
      int v16 = 0;
      BOOL v17 = 1;
    }
    else
    {
      BOOL v17 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id;
      int v16 = !v17;
    }
    unsigned int v21 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v163);
    unsigned int v22 = v21;
    if (a3)
    {
      switch(v21)
      {
        case 2u:
        case 3u:
          BOOL v23 = a3 == 1;
          int v24 = 2;
          goto LABEL_45;
        case 4u:
        case 5u:
        case 6u:
LABEL_215:
          __break(1u);
          JUMPOUT(0x180564A28);
        case 7u:
        case 8u:
          BOOL v23 = a3 == 1;
          int v24 = 7;
          goto LABEL_45;
        case 9u:
        case 0xAu:
          BOOL v23 = a3 == 1;
          int v24 = 9;
LABEL_45:
          if (v23) {
            unsigned int v22 = v24;
          }
          else {
            unsigned int v22 = v24 + 1;
          }
          break;
        default:
          unsigned int v22 = a3 != 1;
          break;
      }
    }
    unsigned int v25 = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v163);
    unsigned int v162 = v25;
    if (a4)
    {
      switch(v25)
      {
        case 2u:
        case 3u:
          BOOL v26 = a4 == 1;
          int v27 = 2;
          goto LABEL_54;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
        case 8u:
          BOOL v26 = a4 == 1;
          int v27 = 7;
          goto LABEL_54;
        case 9u:
        case 0xAu:
          BOOL v26 = a4 == 1;
          int v27 = 9;
LABEL_54:
          if (v26) {
            unsigned int v25 = v27;
          }
          else {
            unsigned int v25 = v27 + 1;
          }
          break;
        default:
          unsigned int v25 = a4 != 1;
          break;
      }
    }
    unsigned int v161 = v25;
    char v156 = v15;
    if (v21 == v22)
    {
      v175 = &v176[8];
      unsigned int v28 = 5;
      *(_DWORD *)&v176[4] = 5;
      if (v21 > 3)
      {
        int v177 = 4;
        *(_OWORD *)&v176[8] = xmmword_18110B6C0;
      }
      else
      {
        *(_OWORD *)&v176[8] = xmmword_1810FFF10;
        unsigned int v28 = 4;
      }
      *(_DWORD *)v176 = v28;
    }
    else
    {
      switch(v22)
      {
        case 1u:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x100000003;
          long long v29 = xmmword_18110B6A0;
          goto LABEL_67;
        case 2u:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x100000000;
          long long v29 = xmmword_18110B670;
          goto LABEL_67;
        case 3u:
          v175 = &v176[8];
          *(void *)&v176[16] = 1;
          long long v29 = xmmword_18110B680;
          goto LABEL_67;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
          v175 = &v176[8];
          int v31 = 3;
          uint64_t v32 = &xmmword_18110B6E8;
          goto LABEL_72;
        case 8u:
          v175 = &v176[8];
          int v31 = 1;
          uint64_t v32 = &xmmword_18110B6D4;
          goto LABEL_72;
        case 9u:
          v175 = &v176[8];
          int v31 = 2;
          uint64_t v32 = &xmmword_18110B710;
LABEL_72:
          int v177 = v31;
          long long v30 = *v32;
          goto LABEL_73;
        case 0xAu:
          v175 = &v176[8];
          int v177 = 0;
          long long v30 = xmmword_18110B6FC;
LABEL_73:
          *(_OWORD *)&v176[8] = v30;
          *(void *)v176 = 0x500000005;
          unsigned int v28 = 5;
          break;
        default:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x200000001;
          long long v29 = xmmword_18110B690;
LABEL_67:
          *(_OWORD *)v176 = v29;
          unsigned int v28 = 4;
          break;
      }
    }
    v158 = &v175;
    v159 = &v162;
    v160 = &v161;
    v157[0] = a5;
    v157[1] = &v163;
    v157[2] = &v158;
    uint64_t v33 = *(void *)(v163[9] + 24);
    uint64_t v34 = v163[3];
    v181 = (int32x4_t *)v183;
    HIDWORD(v182) = 5;
    memcpy(v183, &v176[8], 4 * v28);
    LODWORD(v182) = v28;
    if (v181 != (int32x4_t *)v183) {
      free(v181);
    }
    unint64_t v37 = (uint64_t *)v163[9];
    char v38 = (uint64_t *)v37[1];
    if (v38)
    {
      *char v38 = *v37;
      if (*v37) {
        *(void *)(*v37 + 8) = v37[1];
      }
    }
    v37[3] = (uint64_t)v35;
    v37[1] = (uint64_t)v35;
    uint64_t v39 = *v35;
    uint64_t *v37 = *v35;
    if (v39) {
      *(void *)(v39 + 8) = v37;
    }
    *unint64_t v35 = (uint64_t)v37;
    unint64_t v40 = (void *)v163[9];
    uint64_t v41 = v40 + 4;
    uint64_t v42 = (void *)v40[5];
    if (v42)
    {
      void *v42 = *v41;
      if (*v41) {
        *(void *)(*v41 + 8) = v40[5];
      }
    }
    v40[7] = v36;
    v40[5] = v36;
    uint64_t v43 = *v36;
    v40[4] = *v36;
    if (v43) {
      *(void *)(v43 + 8) = v41;
    }
    uint64_t *v36 = (uint64_t)v41;
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v163 + 3));
    uint64_t v45 = mlir::mps::TensorDataLayoutAttr::get(Context, v22);
    mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr((uint64_t *)&v163, v45);
    char v46 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v163 + 3));
    uint64_t v47 = mlir::mps::TensorDataLayoutAttr::get(v46, v161);
    mlir::mps::Conv2DDataGradientOp::setWeightsLayoutAttr((uint64_t *)&v163, v47);
    uint64_t Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v163);
    mlir::mps::Conv2DDataGradientOp::setStridesAttr((uint64_t *)&v163, v49);
    uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v163);
    mlir::mps::Conv2DDataGradientOp::setDilationRatesAttr((uint64_t *)&v163, v51);
    uint64_t Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v163);
    mlir::mps::Conv2DDataGradientOp::setExplicitPaddingAttr((uint64_t *)&v163, v53);
    uint64_t v54 = (mlir::GenericProgramPoint *)v163;
    if (!v17)
    {
      unsigned int v59 = *v159;
      if (*v159 == *v160)
      {
        std::string::size_type v56 = (unsigned int *)&v173[8];
        __dst = &v173[8];
        unsigned int v57 = 5;
        *(_DWORD *)&v173[4] = 5;
        if (v59 > 3)
        {
          int v174 = 4;
          *(_OWORD *)&v173[8] = xmmword_18110B6C0;
        }
        else
        {
          *(_OWORD *)&v173[8] = xmmword_1810FFF10;
          unsigned int v57 = 4;
        }
        *(_DWORD *)v173 = v57;
      }
      else
      {
        switch(*v160)
        {
          case 1u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x100000003;
            long long v60 = xmmword_18110B6A0;
            goto LABEL_112;
          case 2u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x100000000;
            long long v60 = xmmword_18110B670;
            goto LABEL_112;
          case 3u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 1;
            long long v60 = xmmword_18110B680;
            goto LABEL_112;
          case 4u:
          case 5u:
          case 6u:
            goto LABEL_215;
          case 7u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 3;
            uint64_t v63 = &xmmword_18110B6E8;
            goto LABEL_116;
          case 8u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 1;
            uint64_t v63 = &xmmword_18110B6D4;
            goto LABEL_116;
          case 9u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 2;
            uint64_t v63 = &xmmword_18110B710;
LABEL_116:
            int v174 = v62;
            long long v64 = *v63;
            goto LABEL_118;
          case 0xAu:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v174 = 0;
            long long v64 = xmmword_18110B6FC;
LABEL_118:
            *(_OWORD *)&v173[8] = v64;
            *(void *)v173 = 0x500000005;
            unsigned int v57 = 5;
            break;
          default:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x200000001;
            long long v60 = xmmword_18110B690;
LABEL_112:
            *(_OWORD *)v173 = v60;
            unsigned int v57 = 4;
            break;
        }
      }
      unsigned int v21 = v162;
      if (v161 == v162) {
        goto LABEL_103;
      }
      goto LABEL_120;
    }
    char v55 = v158;
    std::string::size_type v56 = (unsigned int *)&v173[8];
    __dst = &v173[8];
    *(void *)v173 = 0x500000000;
    if (v158 == &__dst)
    {
      unsigned int v57 = 0;
      if (v22 == v21)
      {
LABEL_103:
        v169 = &v170[8];
        unint64_t v61 = 5;
        *(_DWORD *)&v170[4] = 5;
        if (v21 > 3)
        {
          int v171 = 4;
          *(_OWORD *)&v170[8] = xmmword_18110B6C0;
        }
        else
        {
          *(_OWORD *)&v170[8] = xmmword_1810FFF10;
          unint64_t v61 = 4;
        }
        *(_DWORD *)long long v170 = v61;
        goto LABEL_132;
      }
LABEL_120:
      switch(v21)
      {
        case 1u:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x100000003;
          long long v65 = xmmword_18110B6A0;
          goto LABEL_126;
        case 2u:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x100000000;
          long long v65 = xmmword_18110B670;
          goto LABEL_126;
        case 3u:
          v169 = &v170[8];
          *(void *)&v170[16] = 1;
          long long v65 = xmmword_18110B680;
          goto LABEL_126;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
          v169 = &v170[8];
          int v67 = 3;
          uint64_t v68 = &xmmword_18110B6E8;
          goto LABEL_130;
        case 8u:
          v169 = &v170[8];
          int v67 = 1;
          uint64_t v68 = &xmmword_18110B6D4;
          goto LABEL_130;
        case 9u:
          v169 = &v170[8];
          int v67 = 2;
          uint64_t v68 = &xmmword_18110B710;
LABEL_130:
          int v171 = v67;
          long long v66 = *v68;
          goto LABEL_131;
        case 0xAu:
          v169 = &v170[8];
          int v171 = 0;
          long long v66 = xmmword_18110B6FC;
LABEL_131:
          *(_OWORD *)&v170[8] = v66;
          *(void *)long long v170 = 0x500000005;
          unint64_t v61 = 5;
          break;
        default:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x200000001;
          long long v65 = xmmword_18110B690;
LABEL_126:
          *(_OWORD *)long long v170 = v65;
          unint64_t v61 = 4;
          break;
      }
LABEL_132:
      uint64_t v168 = v54;
      uint64_t v69 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v168);
      uint64_t v167 = (uint64_t **)v69;
      unint64_t v70 = (uint64_t *)(*(void *)(v69 + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v70) {
        goto LABEL_141;
      }
      uint64_t v71 = *v70;
      unint64_t v72 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v73 = *(unsigned int *)(v71 + 16);
      if (!v73) {
        goto LABEL_141;
      }
      unint64_t v74 = *(void **)(v71 + 8);
      uint64_t v75 = &v74[2 * v73];
      do
      {
        unint64_t v76 = v73 >> 1;
        uint64_t v77 = &v74[2 * (v73 >> 1)];
        unint64_t v79 = *v77;
        uint64_t v78 = v77 + 2;
        v73 += ~(v73 >> 1);
        if (v79 < v72) {
          unint64_t v74 = v78;
        }
        else {
          unint64_t v73 = v76;
        }
      }
      while (v73);
      if (v74 != v75 && *v74 == v72) {
        uint64_t v80 = v74[1];
      }
      else {
LABEL_141:
      }
        uint64_t v80 = 0;
      v166[0] = v70;
      v166[1] = v80;
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v166))
      {
LABEL_199:
        uint64_t v146 = *((void *)v168 + 2);
        mlir::GenericProgramPoint::~GenericProgramPoint(v168);
        uint64_t v148 = *(void *)(v147 + 8);
        *(void *)(a5 + 24) = v146;
        *(void *)(a5 + 32) = v148;
        if ((int32x4_t *)v69 != v181)
        {
          uint64_t DefiningOp = (mlir::GenericProgramPoint *)mlir::Value::getDefiningOp((mlir::Value *)&v181);
          if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v166))
          {
            v150 = (uint64_t *)v181;
          }
          else
          {
            uint64_t v151 = *((void *)DefiningOp + 2);
            mlir::GenericProgramPoint::~GenericProgramPoint(DefiningOp);
            uint64_t v153 = *(void *)(v152 + 8);
            *(void *)(a5 + 24) = v151;
            *(void *)(a5 + 32) = v153;
            uint64_t v154 = *((void *)v168 + 3);
            uint64_t ElementTypeOrSelf = 0;
            LOBYTE(v164) = 1;
            v178 = mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>((mlir::UnitAttr **)(a5 + 8), v154, (uint64_t *)&v181, (uint64_t)&ElementTypeOrSelf, (unsigned __int8 *)&v164);
            v150 = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v178);
          }
          mlir::Value::replaceAllUsesExcept(&v167, v150, (uint64_t)DefiningOp);
        }
        if (v169 != &v170[8]) {
          free(v169);
        }
        if (__dst != &v173[8]) {
          free(__dst);
        }
        if (v175 != &v176[8]) {
          free(v175);
        }
        return 1;
      }
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v166);
      v181 = (int32x4_t *)v183;
      uint64_t v182 = 0x500000000;
      uint64_t v82 = (mlir::GenericProgramPoint *)(int)v81;
      if ((unint64_t)(v81 << 32) >= 0x500000001) {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v181, v183, (int)v81, 8);
      }
      if (v57)
      {
        uint64_t v83 = 4 * v57;
        do
        {
          uint64_t v84 = *v56;
          uint64_t v85 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v166) + 8 * v84);
          uint64_t v86 = v182;
          if (v182 >= (unint64_t)HIDWORD(v182))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v181, v183, v182 + 1, 8);
            uint64_t v86 = v182;
          }
          v181->i64[v86] = v85;
          unsigned int v87 = v182 + 1;
          LODWORD(v182) = v182 + 1;
          ++v56;
          v83 -= 4;
        }
        while (v83);
      }
      else
      {
        unsigned int v87 = v182;
      }
      v178 = (mlir::GenericProgramPoint *)v166[0];
      *(void *)(v69 + 8) = *(void *)(v69 + 8) & 7 | mlir::TensorType::clone((uint64_t)&v178, (uint64_t)v181, v87);
      if ((v156 & 1) != 0 || (*((unsigned char *)v168 + 46) & 0x80) == 0 || *((_DWORD *)v168 + 17) != 3)
      {
LABEL_197:
        if (v181 != (int32x4_t *)v183) {
          free(v181);
        }
        goto LABEL_199;
      }
      uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(void *)(*((void *)v168 + 9) + 88));
      if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 32)
      {
        v178 = v82;
        uint64_t v109 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v168 + 24));
        uint64_t v110 = mlir::IntegerType::get(v109, 0x40u, 1u);
        unint64_t v111 = (void *)mlir::RankedTensorType::get((uint64_t)&v178, 1, v110, 0);
        unint64_t v112 = v111;
        if (!v111) {
          goto LABEL_178;
        }
        uint64_t v113 = *v111;
        unint64_t v114 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v115 = *(unsigned int *)(v113 + 16);
        if (!v115) {
          goto LABEL_178;
        }
        uint64_t v116 = *(void **)(v113 + 8);
        uint64_t v117 = &v116[2 * v115];
        do
        {
          unint64_t v118 = v115 >> 1;
          unint64_t v119 = &v116[2 * (v115 >> 1)];
          unint64_t v121 = *v119;
          long long v120 = v119 + 2;
          v115 += ~(v115 >> 1);
          if (v121 < v114) {
            uint64_t v116 = v120;
          }
          else {
            unint64_t v115 = v118;
          }
        }
        while (v115);
        if (v116 != v117 && *v116 == v114) {
          uint64_t v122 = v116[1];
        }
        else {
LABEL_178:
        }
          uint64_t v122 = 0;
        uint64_t v123 = *((void *)v168 + 3);
        v178 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v112, v122, v181, 8 * v182, 8, 1, 1);
        uint64_t v124 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 8), v123, (uint64_t **)&v178);
LABEL_191:
        uint64_t v141 = (uint64_t *)((char *)v124 - 16);
        unint64_t v142 = (void *)*((void *)v168 + 9);
        v143 = v142 + 8;
        v144 = (void *)v142[9];
        if (v144)
        {
          void *v144 = *v143;
          if (*v143) {
            *(void *)(*v143 + 8) = v142[9];
          }
        }
        v142[11] = v141;
        v142[9] = v141;
        uint64_t v145 = *v141;
        v142[8] = *v141;
        if (v145) {
          *(void *)(v145 + 8) = v143;
        }
        *uint64_t v141 = (uint64_t)v143;
        goto LABEL_197;
      }
      uint64_t v88 = v181;
      unint64_t v89 = v182;
      v178 = v82;
      uint64_t v90 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v168 + 24));
      uint64_t v91 = mlir::IntegerType::get(v90, 0x20u, 1u);
      uint64_t v92 = (void *)mlir::RankedTensorType::get((uint64_t)&v178, 1, v91, 0);
      uint64_t v93 = v92;
      if (!v92) {
        goto LABEL_165;
      }
      uint64_t v94 = *v92;
      unint64_t v95 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v96 = *(unsigned int *)(v94 + 16);
      if (!v96) {
        goto LABEL_165;
      }
      char v97 = *(void **)(v94 + 8);
      unint64_t v98 = &v97[2 * v96];
      do
      {
        unint64_t v99 = v96 >> 1;
        uint64_t v100 = &v97[2 * (v96 >> 1)];
        unint64_t v102 = *v100;
        uint64_t v101 = v100 + 2;
        v96 += ~(v96 >> 1);
        if (v102 < v95) {
          char v97 = v101;
        }
        else {
          unint64_t v96 = v99;
        }
      }
      while (v96);
      if (v97 != v98 && *v97 == v95) {
        uint64_t v103 = v97[1];
      }
      else {
LABEL_165:
      }
        uint64_t v103 = 0;
      uint64_t v104 = (mlir::OpBuilder *)(a5 + 8);
      uint64_t v105 = *((void *)v168 + 3);
      v178 = (mlir::GenericProgramPoint *)v180;
      uint64_t v179 = 0x500000000;
      uint64_t v155 = v105;
      if (v89 < 6)
      {
        if (!v89)
        {
          int v140 = 0;
          uint64_t v108 = (uint64_t *)v180;
          uint64_t v125 = v155;
LABEL_189:
          LODWORD(v179) = v140 + v89;
          v164 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v93, v103, v108, 4 * (v140 + v89), 4, 1, 1);
          uint64_t v124 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v104, v125, &v164);
          if (v178 != (mlir::GenericProgramPoint *)v180) {
            free(v178);
          }
          goto LABEL_191;
        }
        uint64_t v107 = 0;
        uint64_t v108 = (uint64_t *)v180;
      }
      else
      {
        uint64_t v106 = v103;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v178, v180, v89, 4);
        uint64_t v103 = v106;
        uint64_t v104 = (mlir::OpBuilder *)(a5 + 8);
        uint64_t v107 = v179;
        uint64_t v108 = (uint64_t *)v178;
      }
      uint64_t v125 = v155;
      unsigned int v126 = (int32x4_t *)((char *)v108 + 4 * v107);
      unint64_t v127 = (v89 - 1) & 0x1FFFFFFFFFFFFFFFLL;
      if (v127 >= 7)
      {
        unint64_t v130 = v127 + 1;
        uint64_t v131 = (v127 + 1) & 0x3FFFFFFFFFFFFFF8;
        uint64_t v128 = (int32x4_t *)((char *)v126 + 4 * v131);
        uint64_t v129 = &v88->i8[8 * v131];
        unint64_t v132 = v88 + 2;
        uint64_t v133 = v126 + 1;
        uint64_t v134 = v131;
        do
        {
          int32x4_t v136 = v132[-2];
          int32x4_t v135 = v132[-1];
          int32x4_t v138 = *v132;
          int32x4_t v137 = v132[1];
          v132 += 4;
          v133[-1] = vuzp1q_s32(v136, v135);
          int32x4_t *v133 = vuzp1q_s32(v138, v137);
          v133 += 2;
          v134 -= 8;
        }
        while (v134);
        if (v130 == v131) {
          goto LABEL_188;
        }
      }
      else
      {
        uint64_t v128 = v126;
        uint64_t v129 = (char *)v88;
      }
      do
      {
        uint64_t v139 = *(void *)v129;
        v129 += 8;
        v128->i32[0] = v139;
        uint64_t v128 = (int32x4_t *)((char *)v128 + 4);
      }
      while (v129 != (char *)v88 + 8 * v89);
LABEL_188:
      int v140 = v179;
      goto LABEL_189;
    }
    unsigned int v57 = *((_DWORD *)v158 + 2);
    if (!v57)
    {
LABEL_102:
      if (v22 == v21) {
        goto LABEL_103;
      }
      goto LABEL_120;
    }
    if (v57 < 6)
    {
      unsigned int v58 = *((_DWORD *)v158 + 2);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v173[8], *((unsigned int *)v158 + 2), 4);
      unsigned int v58 = *((_DWORD *)v55 + 2);
      if (!v58)
      {
LABEL_101:
        *(_DWORD *)v173 = v57;
        std::string::size_type v56 = (unsigned int *)__dst;
        goto LABEL_102;
      }
      std::string::size_type v56 = (unsigned int *)__dst;
    }
    memcpy(v56, *v55, 4 * v58);
    goto LABEL_101;
  }
LABEL_6:
  uint64_t result = 0;
  if (a4)
  {
    switch(WeightsLayout)
    {
      case 2:
      case 9:
        if (a4 == 2) {
          goto LABEL_9;
        }
        goto LABEL_41;
      case 3:
      case 10:
        if (a4 == 1) {
          goto LABEL_9;
        }
LABEL_41:
        uint64_t result = 0;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t mlir::mps::anonymous namespace'::ConvertConvolutionInterface<mlir::mps::Conv3DDataGradientOp>::convertLayout(mlir::Operation *,mlir::mps::LayoutConversionType,mlir::mps::LayoutConversionType,mlir::RewriterBase &)const::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)a1;
  uint64_t v5 = *(void *)(**(void **)(a1 + 8) + 24);
  uint64_t v6 = *(uint64_t **)(a1 + 16);
  if (a3)
  {
    uint64_t v7 = *v6;
    uint64_t v8 = &v21[8];
    __dst = &v21[8];
    *(void *)unsigned int v21 = 0x500000000;
    unint64_t v9 = *(unsigned int *)(v7 + 8);
    if ((void **)v7 == &__dst || v9 == 0)
    {
      unint64_t v9 = 0;
      goto LABEL_31;
    }
    if (v9 < 6)
    {
      unsigned int v13 = *(_DWORD *)(v7 + 8);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v21[8], *(unsigned int *)(v7 + 8), 4);
      unsigned int v13 = *(_DWORD *)(v7 + 8);
      if (!v13)
      {
LABEL_20:
        *(_DWORD *)unsigned int v21 = v9;
        uint64_t v8 = __dst;
        goto LABEL_31;
      }
      uint64_t v8 = __dst;
    }
    memcpy(v8, *(const void **)v7, 4 * v13);
    goto LABEL_20;
  }
  char v11 = (_DWORD *)v6[2];
  unsigned int v12 = *(_DWORD *)v6[1];
  if (v12 == *v11)
  {
    uint64_t v8 = &v21[8];
    __dst = &v21[8];
    unint64_t v9 = 5;
    *(_DWORD *)&uint64_t v21[4] = 5;
    if (v12 > 3)
    {
      int v22 = 4;
      *(_OWORD *)&v21[8] = xmmword_18110B6C0;
    }
    else
    {
      *(_OWORD *)&v21[8] = xmmword_1810FFF10;
      unint64_t v9 = 4;
    }
    *(_DWORD *)unsigned int v21 = v9;
  }
  else
  {
    switch(*v11)
    {
      case 1:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x100000003;
        long long v14 = xmmword_18110B6A0;
        goto LABEL_25;
      case 2:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x100000000;
        long long v14 = xmmword_18110B670;
        goto LABEL_25;
      case 3:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 1;
        long long v14 = xmmword_18110B680;
        goto LABEL_25;
      case 4:
      case 5:
      case 6:
        __break(1u);
        JUMPOUT(0x180564E20);
      case 7:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 3;
        BOOL v17 = &xmmword_18110B6E8;
        goto LABEL_29;
      case 8:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 1;
        BOOL v17 = &xmmword_18110B6D4;
        goto LABEL_29;
      case 9:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 2;
        BOOL v17 = &xmmword_18110B710;
LABEL_29:
        int v22 = v16;
        long long v15 = *v17;
        goto LABEL_30;
      case 0xA:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v22 = 0;
        long long v15 = xmmword_18110B6FC;
LABEL_30:
        *(_OWORD *)&v21[8] = v15;
        *(void *)unsigned int v21 = 0x500000005;
        unint64_t v9 = 5;
        break;
      default:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x200000001;
        long long v14 = xmmword_18110B690;
LABEL_25:
        *(_OWORD *)unsigned int v21 = v14;
        unint64_t v9 = 4;
        break;
    }
  }
LABEL_31:
  if (__dst != &v21[8]) {
    free(__dst);
  }
  return v18;
}

uint64_t mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConvertConvolutionInterface<mlir::mps::Conv3DWeightsGradientOp>>::convertLayout(uint64_t a1, void *a2, int a3, int a4, uint64_t a5)
{
  v183[5] = *MEMORY[0x1E4F143B8];
  v163 = a2;
  int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v163);
  int WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v163);
  if (a3)
  {
    switch(StorageType)
    {
      case 0:
      case 7:
        if (a3 != 2) {
          goto LABEL_6;
        }
        break;
      case 1:
      case 8:
        if (a3 != 1) {
          goto LABEL_6;
        }
        break;
      default:
        goto LABEL_6;
    }
LABEL_9:
    char v11 = *(void **)(v163[6] + 16);
    BOOL v14 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
    char v15 = v14;
    if (v14)
    {
      int v16 = 0;
      BOOL v17 = 1;
    }
    else
    {
      BOOL v17 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id;
      int v16 = !v17;
    }
    unsigned int v21 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v163);
    unsigned int v22 = v21;
    if (a3)
    {
      switch(v21)
      {
        case 2u:
        case 3u:
          BOOL v23 = a3 == 1;
          int v24 = 2;
          goto LABEL_45;
        case 4u:
        case 5u:
        case 6u:
LABEL_215:
          __break(1u);
          JUMPOUT(0x180565E10);
        case 7u:
        case 8u:
          BOOL v23 = a3 == 1;
          int v24 = 7;
          goto LABEL_45;
        case 9u:
        case 0xAu:
          BOOL v23 = a3 == 1;
          int v24 = 9;
LABEL_45:
          if (v23) {
            unsigned int v22 = v24;
          }
          else {
            unsigned int v22 = v24 + 1;
          }
          break;
        default:
          unsigned int v22 = a3 != 1;
          break;
      }
    }
    unsigned int v25 = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v163);
    unsigned int v162 = v25;
    if (a4)
    {
      switch(v25)
      {
        case 2u:
        case 3u:
          BOOL v26 = a4 == 1;
          int v27 = 2;
          goto LABEL_54;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
        case 8u:
          BOOL v26 = a4 == 1;
          int v27 = 7;
          goto LABEL_54;
        case 9u:
        case 0xAu:
          BOOL v26 = a4 == 1;
          int v27 = 9;
LABEL_54:
          if (v26) {
            unsigned int v25 = v27;
          }
          else {
            unsigned int v25 = v27 + 1;
          }
          break;
        default:
          unsigned int v25 = a4 != 1;
          break;
      }
    }
    unsigned int v161 = v25;
    char v156 = v15;
    if (v21 == v22)
    {
      v175 = &v176[8];
      unsigned int v28 = 5;
      *(_DWORD *)&v176[4] = 5;
      if (v21 > 3)
      {
        int v177 = 4;
        *(_OWORD *)&v176[8] = xmmword_18110B6C0;
      }
      else
      {
        *(_OWORD *)&v176[8] = xmmword_1810FFF10;
        unsigned int v28 = 4;
      }
      *(_DWORD *)v176 = v28;
    }
    else
    {
      switch(v22)
      {
        case 1u:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x100000003;
          long long v29 = xmmword_18110B6A0;
          goto LABEL_67;
        case 2u:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x100000000;
          long long v29 = xmmword_18110B670;
          goto LABEL_67;
        case 3u:
          v175 = &v176[8];
          *(void *)&v176[16] = 1;
          long long v29 = xmmword_18110B680;
          goto LABEL_67;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
          v175 = &v176[8];
          int v31 = 3;
          uint64_t v32 = &xmmword_18110B6E8;
          goto LABEL_72;
        case 8u:
          v175 = &v176[8];
          int v31 = 1;
          uint64_t v32 = &xmmword_18110B6D4;
          goto LABEL_72;
        case 9u:
          v175 = &v176[8];
          int v31 = 2;
          uint64_t v32 = &xmmword_18110B710;
LABEL_72:
          int v177 = v31;
          long long v30 = *v32;
          goto LABEL_73;
        case 0xAu:
          v175 = &v176[8];
          int v177 = 0;
          long long v30 = xmmword_18110B6FC;
LABEL_73:
          *(_OWORD *)&v176[8] = v30;
          *(void *)v176 = 0x500000005;
          unsigned int v28 = 5;
          break;
        default:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x200000001;
          long long v29 = xmmword_18110B690;
LABEL_67:
          *(_OWORD *)v176 = v29;
          unsigned int v28 = 4;
          break;
      }
    }
    v158 = &v175;
    v159 = &v162;
    v160 = &v161;
    v157[0] = a5;
    v157[1] = &v163;
    v157[2] = &v158;
    uint64_t v33 = *(void *)(v163[9] + 24);
    uint64_t v34 = v163[3];
    v181 = (int32x4_t *)v183;
    HIDWORD(v182) = 5;
    memcpy(v183, &v176[8], 4 * v28);
    LODWORD(v182) = v28;
    if (v181 != (int32x4_t *)v183) {
      free(v181);
    }
    unint64_t v37 = (uint64_t *)v163[9];
    char v38 = (uint64_t *)v37[1];
    if (v38)
    {
      *char v38 = *v37;
      if (*v37) {
        *(void *)(*v37 + 8) = v37[1];
      }
    }
    v37[3] = (uint64_t)v35;
    v37[1] = (uint64_t)v35;
    uint64_t v39 = *v35;
    uint64_t *v37 = *v35;
    if (v39) {
      *(void *)(v39 + 8) = v37;
    }
    *unint64_t v35 = (uint64_t)v37;
    unint64_t v40 = (void *)v163[9];
    uint64_t v41 = v40 + 4;
    uint64_t v42 = (void *)v40[5];
    if (v42)
    {
      void *v42 = *v41;
      if (*v41) {
        *(void *)(*v41 + 8) = v40[5];
      }
    }
    v40[7] = v36;
    v40[5] = v36;
    uint64_t v43 = *v36;
    v40[4] = *v36;
    if (v43) {
      *(void *)(v43 + 8) = v41;
    }
    uint64_t *v36 = (uint64_t)v41;
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v163 + 3));
    uint64_t v45 = mlir::mps::TensorDataLayoutAttr::get(Context, v22);
    mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr((uint64_t *)&v163, v45);
    char v46 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v163 + 3));
    uint64_t v47 = mlir::mps::TensorDataLayoutAttr::get(v46, v161);
    mlir::mps::Conv2DDataGradientOp::setWeightsLayoutAttr((uint64_t *)&v163, v47);
    uint64_t Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v163);
    mlir::mps::Conv2DDataGradientOp::setStridesAttr((uint64_t *)&v163, v49);
    uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v163);
    mlir::mps::Conv2DDataGradientOp::setDilationRatesAttr((uint64_t *)&v163, v51);
    uint64_t Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v163);
    mlir::mps::Conv2DDataGradientOp::setExplicitPaddingAttr((uint64_t *)&v163, v53);
    uint64_t v54 = (mlir::GenericProgramPoint *)v163;
    if (!v17)
    {
      unsigned int v59 = *v159;
      if (*v159 == *v160)
      {
        std::string::size_type v56 = (unsigned int *)&v173[8];
        __dst = &v173[8];
        unsigned int v57 = 5;
        *(_DWORD *)&v173[4] = 5;
        if (v59 > 3)
        {
          int v174 = 4;
          *(_OWORD *)&v173[8] = xmmword_18110B6C0;
        }
        else
        {
          *(_OWORD *)&v173[8] = xmmword_1810FFF10;
          unsigned int v57 = 4;
        }
        *(_DWORD *)v173 = v57;
      }
      else
      {
        switch(*v160)
        {
          case 1u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x100000003;
            long long v60 = xmmword_18110B6A0;
            goto LABEL_112;
          case 2u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x100000000;
            long long v60 = xmmword_18110B670;
            goto LABEL_112;
          case 3u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 1;
            long long v60 = xmmword_18110B680;
            goto LABEL_112;
          case 4u:
          case 5u:
          case 6u:
            goto LABEL_215;
          case 7u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 3;
            uint64_t v63 = &xmmword_18110B6E8;
            goto LABEL_116;
          case 8u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 1;
            uint64_t v63 = &xmmword_18110B6D4;
            goto LABEL_116;
          case 9u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 2;
            uint64_t v63 = &xmmword_18110B710;
LABEL_116:
            int v174 = v62;
            long long v64 = *v63;
            goto LABEL_118;
          case 0xAu:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v174 = 0;
            long long v64 = xmmword_18110B6FC;
LABEL_118:
            *(_OWORD *)&v173[8] = v64;
            *(void *)v173 = 0x500000005;
            unsigned int v57 = 5;
            break;
          default:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x200000001;
            long long v60 = xmmword_18110B690;
LABEL_112:
            *(_OWORD *)v173 = v60;
            unsigned int v57 = 4;
            break;
        }
      }
      unsigned int v21 = v162;
      if (v161 == v162) {
        goto LABEL_103;
      }
      goto LABEL_120;
    }
    char v55 = v158;
    std::string::size_type v56 = (unsigned int *)&v173[8];
    __dst = &v173[8];
    *(void *)v173 = 0x500000000;
    if (v158 == &__dst)
    {
      unsigned int v57 = 0;
      if (v22 == v21)
      {
LABEL_103:
        v169 = &v170[8];
        unint64_t v61 = 5;
        *(_DWORD *)&v170[4] = 5;
        if (v21 > 3)
        {
          int v171 = 4;
          *(_OWORD *)&v170[8] = xmmword_18110B6C0;
        }
        else
        {
          *(_OWORD *)&v170[8] = xmmword_1810FFF10;
          unint64_t v61 = 4;
        }
        *(_DWORD *)long long v170 = v61;
        goto LABEL_132;
      }
LABEL_120:
      switch(v21)
      {
        case 1u:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x100000003;
          long long v65 = xmmword_18110B6A0;
          goto LABEL_126;
        case 2u:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x100000000;
          long long v65 = xmmword_18110B670;
          goto LABEL_126;
        case 3u:
          v169 = &v170[8];
          *(void *)&v170[16] = 1;
          long long v65 = xmmword_18110B680;
          goto LABEL_126;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
          v169 = &v170[8];
          int v67 = 3;
          uint64_t v68 = &xmmword_18110B6E8;
          goto LABEL_130;
        case 8u:
          v169 = &v170[8];
          int v67 = 1;
          uint64_t v68 = &xmmword_18110B6D4;
          goto LABEL_130;
        case 9u:
          v169 = &v170[8];
          int v67 = 2;
          uint64_t v68 = &xmmword_18110B710;
LABEL_130:
          int v171 = v67;
          long long v66 = *v68;
          goto LABEL_131;
        case 0xAu:
          v169 = &v170[8];
          int v171 = 0;
          long long v66 = xmmword_18110B6FC;
LABEL_131:
          *(_OWORD *)&v170[8] = v66;
          *(void *)long long v170 = 0x500000005;
          unint64_t v61 = 5;
          break;
        default:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x200000001;
          long long v65 = xmmword_18110B690;
LABEL_126:
          *(_OWORD *)long long v170 = v65;
          unint64_t v61 = 4;
          break;
      }
LABEL_132:
      uint64_t v168 = v54;
      uint64_t v69 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v168);
      uint64_t v167 = (uint64_t **)v69;
      unint64_t v70 = (uint64_t *)(*(void *)(v69 + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v70) {
        goto LABEL_141;
      }
      uint64_t v71 = *v70;
      unint64_t v72 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v73 = *(unsigned int *)(v71 + 16);
      if (!v73) {
        goto LABEL_141;
      }
      unint64_t v74 = *(void **)(v71 + 8);
      uint64_t v75 = &v74[2 * v73];
      do
      {
        unint64_t v76 = v73 >> 1;
        uint64_t v77 = &v74[2 * (v73 >> 1)];
        unint64_t v79 = *v77;
        uint64_t v78 = v77 + 2;
        v73 += ~(v73 >> 1);
        if (v79 < v72) {
          unint64_t v74 = v78;
        }
        else {
          unint64_t v73 = v76;
        }
      }
      while (v73);
      if (v74 != v75 && *v74 == v72) {
        uint64_t v80 = v74[1];
      }
      else {
LABEL_141:
      }
        uint64_t v80 = 0;
      v166[0] = v70;
      v166[1] = v80;
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v166))
      {
LABEL_199:
        uint64_t v146 = *((void *)v168 + 2);
        mlir::GenericProgramPoint::~GenericProgramPoint(v168);
        uint64_t v148 = *(void *)(v147 + 8);
        *(void *)(a5 + 24) = v146;
        *(void *)(a5 + 32) = v148;
        if ((int32x4_t *)v69 != v181)
        {
          uint64_t DefiningOp = (mlir::GenericProgramPoint *)mlir::Value::getDefiningOp((mlir::Value *)&v181);
          if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v166))
          {
            v150 = (uint64_t *)v181;
          }
          else
          {
            uint64_t v151 = *((void *)DefiningOp + 2);
            mlir::GenericProgramPoint::~GenericProgramPoint(DefiningOp);
            uint64_t v153 = *(void *)(v152 + 8);
            *(void *)(a5 + 24) = v151;
            *(void *)(a5 + 32) = v153;
            uint64_t v154 = *((void *)v168 + 3);
            uint64_t ElementTypeOrSelf = 0;
            LOBYTE(v164) = 1;
            v178 = mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>((mlir::UnitAttr **)(a5 + 8), v154, (uint64_t *)&v181, (uint64_t)&ElementTypeOrSelf, (unsigned __int8 *)&v164);
            v150 = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v178);
          }
          mlir::Value::replaceAllUsesExcept(&v167, v150, (uint64_t)DefiningOp);
        }
        if (v169 != &v170[8]) {
          free(v169);
        }
        if (__dst != &v173[8]) {
          free(__dst);
        }
        if (v175 != &v176[8]) {
          free(v175);
        }
        return 1;
      }
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v166);
      v181 = (int32x4_t *)v183;
      uint64_t v182 = 0x500000000;
      uint64_t v82 = (mlir::GenericProgramPoint *)(int)v81;
      if ((unint64_t)(v81 << 32) >= 0x500000001) {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v181, v183, (int)v81, 8);
      }
      if (v57)
      {
        uint64_t v83 = 4 * v57;
        do
        {
          uint64_t v84 = *v56;
          uint64_t v85 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v166) + 8 * v84);
          uint64_t v86 = v182;
          if (v182 >= (unint64_t)HIDWORD(v182))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v181, v183, v182 + 1, 8);
            uint64_t v86 = v182;
          }
          v181->i64[v86] = v85;
          unsigned int v87 = v182 + 1;
          LODWORD(v182) = v182 + 1;
          ++v56;
          v83 -= 4;
        }
        while (v83);
      }
      else
      {
        unsigned int v87 = v182;
      }
      v178 = (mlir::GenericProgramPoint *)v166[0];
      *(void *)(v69 + 8) = *(void *)(v69 + 8) & 7 | mlir::TensorType::clone((uint64_t)&v178, (uint64_t)v181, v87);
      if ((v156 & 1) != 0 || (*((unsigned char *)v168 + 46) & 0x80) == 0 || *((_DWORD *)v168 + 17) != 3)
      {
LABEL_197:
        if (v181 != (int32x4_t *)v183) {
          free(v181);
        }
        goto LABEL_199;
      }
      uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(void *)(*((void *)v168 + 9) + 88));
      if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 32)
      {
        v178 = v82;
        uint64_t v109 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v168 + 24));
        uint64_t v110 = mlir::IntegerType::get(v109, 0x40u, 1u);
        unint64_t v111 = (void *)mlir::RankedTensorType::get((uint64_t)&v178, 1, v110, 0);
        unint64_t v112 = v111;
        if (!v111) {
          goto LABEL_178;
        }
        uint64_t v113 = *v111;
        unint64_t v114 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v115 = *(unsigned int *)(v113 + 16);
        if (!v115) {
          goto LABEL_178;
        }
        uint64_t v116 = *(void **)(v113 + 8);
        uint64_t v117 = &v116[2 * v115];
        do
        {
          unint64_t v118 = v115 >> 1;
          unint64_t v119 = &v116[2 * (v115 >> 1)];
          unint64_t v121 = *v119;
          long long v120 = v119 + 2;
          v115 += ~(v115 >> 1);
          if (v121 < v114) {
            uint64_t v116 = v120;
          }
          else {
            unint64_t v115 = v118;
          }
        }
        while (v115);
        if (v116 != v117 && *v116 == v114) {
          uint64_t v122 = v116[1];
        }
        else {
LABEL_178:
        }
          uint64_t v122 = 0;
        uint64_t v123 = *((void *)v168 + 3);
        v178 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v112, v122, v181, 8 * v182, 8, 1, 1);
        uint64_t v124 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 8), v123, (uint64_t **)&v178);
LABEL_191:
        uint64_t v141 = (uint64_t *)((char *)v124 - 16);
        unint64_t v142 = (void *)*((void *)v168 + 9);
        v143 = v142 + 8;
        v144 = (void *)v142[9];
        if (v144)
        {
          void *v144 = *v143;
          if (*v143) {
            *(void *)(*v143 + 8) = v142[9];
          }
        }
        v142[11] = v141;
        v142[9] = v141;
        uint64_t v145 = *v141;
        v142[8] = *v141;
        if (v145) {
          *(void *)(v145 + 8) = v143;
        }
        *uint64_t v141 = (uint64_t)v143;
        goto LABEL_197;
      }
      uint64_t v88 = v181;
      unint64_t v89 = v182;
      v178 = v82;
      uint64_t v90 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v168 + 24));
      uint64_t v91 = mlir::IntegerType::get(v90, 0x20u, 1u);
      uint64_t v92 = (void *)mlir::RankedTensorType::get((uint64_t)&v178, 1, v91, 0);
      uint64_t v93 = v92;
      if (!v92) {
        goto LABEL_165;
      }
      uint64_t v94 = *v92;
      unint64_t v95 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v96 = *(unsigned int *)(v94 + 16);
      if (!v96) {
        goto LABEL_165;
      }
      char v97 = *(void **)(v94 + 8);
      unint64_t v98 = &v97[2 * v96];
      do
      {
        unint64_t v99 = v96 >> 1;
        uint64_t v100 = &v97[2 * (v96 >> 1)];
        unint64_t v102 = *v100;
        uint64_t v101 = v100 + 2;
        v96 += ~(v96 >> 1);
        if (v102 < v95) {
          char v97 = v101;
        }
        else {
          unint64_t v96 = v99;
        }
      }
      while (v96);
      if (v97 != v98 && *v97 == v95) {
        uint64_t v103 = v97[1];
      }
      else {
LABEL_165:
      }
        uint64_t v103 = 0;
      uint64_t v104 = (mlir::OpBuilder *)(a5 + 8);
      uint64_t v105 = *((void *)v168 + 3);
      v178 = (mlir::GenericProgramPoint *)v180;
      uint64_t v179 = 0x500000000;
      uint64_t v155 = v105;
      if (v89 < 6)
      {
        if (!v89)
        {
          int v140 = 0;
          uint64_t v108 = (uint64_t *)v180;
          uint64_t v125 = v155;
LABEL_189:
          LODWORD(v179) = v140 + v89;
          v164 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v93, v103, v108, 4 * (v140 + v89), 4, 1, 1);
          uint64_t v124 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v104, v125, &v164);
          if (v178 != (mlir::GenericProgramPoint *)v180) {
            free(v178);
          }
          goto LABEL_191;
        }
        uint64_t v107 = 0;
        uint64_t v108 = (uint64_t *)v180;
      }
      else
      {
        uint64_t v106 = v103;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v178, v180, v89, 4);
        uint64_t v103 = v106;
        uint64_t v104 = (mlir::OpBuilder *)(a5 + 8);
        uint64_t v107 = v179;
        uint64_t v108 = (uint64_t *)v178;
      }
      uint64_t v125 = v155;
      unsigned int v126 = (int32x4_t *)((char *)v108 + 4 * v107);
      unint64_t v127 = (v89 - 1) & 0x1FFFFFFFFFFFFFFFLL;
      if (v127 >= 7)
      {
        unint64_t v130 = v127 + 1;
        uint64_t v131 = (v127 + 1) & 0x3FFFFFFFFFFFFFF8;
        uint64_t v128 = (int32x4_t *)((char *)v126 + 4 * v131);
        uint64_t v129 = &v88->i8[8 * v131];
        unint64_t v132 = v88 + 2;
        uint64_t v133 = v126 + 1;
        uint64_t v134 = v131;
        do
        {
          int32x4_t v136 = v132[-2];
          int32x4_t v135 = v132[-1];
          int32x4_t v138 = *v132;
          int32x4_t v137 = v132[1];
          v132 += 4;
          v133[-1] = vuzp1q_s32(v136, v135);
          int32x4_t *v133 = vuzp1q_s32(v138, v137);
          v133 += 2;
          v134 -= 8;
        }
        while (v134);
        if (v130 == v131) {
          goto LABEL_188;
        }
      }
      else
      {
        uint64_t v128 = v126;
        uint64_t v129 = (char *)v88;
      }
      do
      {
        uint64_t v139 = *(void *)v129;
        v129 += 8;
        v128->i32[0] = v139;
        uint64_t v128 = (int32x4_t *)((char *)v128 + 4);
      }
      while (v129 != (char *)v88 + 8 * v89);
LABEL_188:
      int v140 = v179;
      goto LABEL_189;
    }
    unsigned int v57 = *((_DWORD *)v158 + 2);
    if (!v57)
    {
LABEL_102:
      if (v22 == v21) {
        goto LABEL_103;
      }
      goto LABEL_120;
    }
    if (v57 < 6)
    {
      unsigned int v58 = *((_DWORD *)v158 + 2);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v173[8], *((unsigned int *)v158 + 2), 4);
      unsigned int v58 = *((_DWORD *)v55 + 2);
      if (!v58)
      {
LABEL_101:
        *(_DWORD *)v173 = v57;
        std::string::size_type v56 = (unsigned int *)__dst;
        goto LABEL_102;
      }
      std::string::size_type v56 = (unsigned int *)__dst;
    }
    memcpy(v56, *v55, 4 * v58);
    goto LABEL_101;
  }
LABEL_6:
  uint64_t result = 0;
  if (a4)
  {
    switch(WeightsLayout)
    {
      case 2:
      case 9:
        if (a4 == 2) {
          goto LABEL_9;
        }
        goto LABEL_41;
      case 3:
      case 10:
        if (a4 == 1) {
          goto LABEL_9;
        }
LABEL_41:
        uint64_t result = 0;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t mlir::mps::anonymous namespace'::ConvertConvolutionInterface<mlir::mps::Conv3DWeightsGradientOp>::convertLayout(mlir::Operation *,mlir::mps::LayoutConversionType,mlir::mps::LayoutConversionType,mlir::RewriterBase &)const::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)a1;
  uint64_t v5 = *(void *)(**(void **)(a1 + 8) + 24);
  uint64_t v6 = *(uint64_t **)(a1 + 16);
  if (a3)
  {
    uint64_t v7 = *v6;
    uint64_t v8 = &v21[8];
    __dst = &v21[8];
    *(void *)unsigned int v21 = 0x500000000;
    unint64_t v9 = *(unsigned int *)(v7 + 8);
    if ((void **)v7 == &__dst || v9 == 0)
    {
      unint64_t v9 = 0;
      goto LABEL_31;
    }
    if (v9 < 6)
    {
      unsigned int v13 = *(_DWORD *)(v7 + 8);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v21[8], *(unsigned int *)(v7 + 8), 4);
      unsigned int v13 = *(_DWORD *)(v7 + 8);
      if (!v13)
      {
LABEL_20:
        *(_DWORD *)unsigned int v21 = v9;
        uint64_t v8 = __dst;
        goto LABEL_31;
      }
      uint64_t v8 = __dst;
    }
    memcpy(v8, *(const void **)v7, 4 * v13);
    goto LABEL_20;
  }
  char v11 = (_DWORD *)v6[2];
  unsigned int v12 = *(_DWORD *)v6[1];
  if (v12 == *v11)
  {
    uint64_t v8 = &v21[8];
    __dst = &v21[8];
    unint64_t v9 = 5;
    *(_DWORD *)&uint64_t v21[4] = 5;
    if (v12 > 3)
    {
      int v22 = 4;
      *(_OWORD *)&v21[8] = xmmword_18110B6C0;
    }
    else
    {
      *(_OWORD *)&v21[8] = xmmword_1810FFF10;
      unint64_t v9 = 4;
    }
    *(_DWORD *)unsigned int v21 = v9;
  }
  else
  {
    switch(*v11)
    {
      case 1:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x100000003;
        long long v14 = xmmword_18110B6A0;
        goto LABEL_25;
      case 2:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x100000000;
        long long v14 = xmmword_18110B670;
        goto LABEL_25;
      case 3:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 1;
        long long v14 = xmmword_18110B680;
        goto LABEL_25;
      case 4:
      case 5:
      case 6:
        __break(1u);
        JUMPOUT(0x180566208);
      case 7:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 3;
        BOOL v17 = &xmmword_18110B6E8;
        goto LABEL_29;
      case 8:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 1;
        BOOL v17 = &xmmword_18110B6D4;
        goto LABEL_29;
      case 9:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 2;
        BOOL v17 = &xmmword_18110B710;
LABEL_29:
        int v22 = v16;
        long long v15 = *v17;
        goto LABEL_30;
      case 0xA:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v22 = 0;
        long long v15 = xmmword_18110B6FC;
LABEL_30:
        *(_OWORD *)&v21[8] = v15;
        *(void *)unsigned int v21 = 0x500000005;
        unint64_t v9 = 5;
        break;
      default:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x200000001;
        long long v14 = xmmword_18110B690;
LABEL_25:
        *(_OWORD *)unsigned int v21 = v14;
        unint64_t v9 = 4;
        break;
    }
  }
LABEL_31:
  if (__dst != &v21[8]) {
    free(__dst);
  }
  return v18;
}

uint64_t mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConvertConvolutionInterface<mlir::mps::DepthwiseConv2DOp>>::convertLayout(uint64_t a1, void *a2, int a3, int a4, uint64_t a5)
{
  v183[5] = *MEMORY[0x1E4F143B8];
  v163 = a2;
  int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v163);
  int PaddingStyle = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v163);
  if (a3)
  {
    switch(StorageType)
    {
      case 0:
      case 7:
        if (a3 != 2) {
          goto LABEL_6;
        }
        break;
      case 1:
      case 8:
        if (a3 != 1) {
          goto LABEL_6;
        }
        break;
      default:
        goto LABEL_6;
    }
LABEL_9:
    char v11 = *(void **)(v163[6] + 16);
    BOOL v14 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
    char v15 = v14;
    if (v14)
    {
      int v16 = 0;
      BOOL v17 = 1;
    }
    else
    {
      BOOL v17 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id;
      int v16 = !v17;
    }
    unsigned int v21 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v163);
    unsigned int v22 = v21;
    if (a3)
    {
      switch(v21)
      {
        case 2u:
        case 3u:
          BOOL v23 = a3 == 1;
          int v24 = 2;
          goto LABEL_45;
        case 4u:
        case 5u:
        case 6u:
LABEL_215:
          __break(1u);
          JUMPOUT(0x1805671F8);
        case 7u:
        case 8u:
          BOOL v23 = a3 == 1;
          int v24 = 7;
          goto LABEL_45;
        case 9u:
        case 0xAu:
          BOOL v23 = a3 == 1;
          int v24 = 9;
LABEL_45:
          if (v23) {
            unsigned int v22 = v24;
          }
          else {
            unsigned int v22 = v24 + 1;
          }
          break;
        default:
          unsigned int v22 = a3 != 1;
          break;
      }
    }
    unsigned int v25 = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v163);
    unsigned int v162 = v25;
    if (a4)
    {
      switch(v25)
      {
        case 2u:
        case 3u:
          BOOL v26 = a4 == 1;
          int v27 = 2;
          goto LABEL_54;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
        case 8u:
          BOOL v26 = a4 == 1;
          int v27 = 7;
          goto LABEL_54;
        case 9u:
        case 0xAu:
          BOOL v26 = a4 == 1;
          int v27 = 9;
LABEL_54:
          if (v26) {
            unsigned int v25 = v27;
          }
          else {
            unsigned int v25 = v27 + 1;
          }
          break;
        default:
          unsigned int v25 = a4 != 1;
          break;
      }
    }
    unsigned int v161 = v25;
    char v156 = v15;
    if (v21 == v22)
    {
      v175 = &v176[8];
      unsigned int v28 = 5;
      *(_DWORD *)&v176[4] = 5;
      if (v21 > 3)
      {
        int v177 = 4;
        *(_OWORD *)&v176[8] = xmmword_18110B6C0;
      }
      else
      {
        *(_OWORD *)&v176[8] = xmmword_1810FFF10;
        unsigned int v28 = 4;
      }
      *(_DWORD *)v176 = v28;
    }
    else
    {
      switch(v22)
      {
        case 1u:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x100000003;
          long long v29 = xmmword_18110B6A0;
          goto LABEL_67;
        case 2u:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x100000000;
          long long v29 = xmmword_18110B670;
          goto LABEL_67;
        case 3u:
          v175 = &v176[8];
          *(void *)&v176[16] = 1;
          long long v29 = xmmword_18110B680;
          goto LABEL_67;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
          v175 = &v176[8];
          int v31 = 3;
          uint64_t v32 = &xmmword_18110B6E8;
          goto LABEL_72;
        case 8u:
          v175 = &v176[8];
          int v31 = 1;
          uint64_t v32 = &xmmword_18110B6D4;
          goto LABEL_72;
        case 9u:
          v175 = &v176[8];
          int v31 = 2;
          uint64_t v32 = &xmmword_18110B710;
LABEL_72:
          int v177 = v31;
          long long v30 = *v32;
          goto LABEL_73;
        case 0xAu:
          v175 = &v176[8];
          int v177 = 0;
          long long v30 = xmmword_18110B6FC;
LABEL_73:
          *(_OWORD *)&v176[8] = v30;
          *(void *)v176 = 0x500000005;
          unsigned int v28 = 5;
          break;
        default:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x200000001;
          long long v29 = xmmword_18110B690;
LABEL_67:
          *(_OWORD *)v176 = v29;
          unsigned int v28 = 4;
          break;
      }
    }
    v158 = &v175;
    v159 = &v162;
    v160 = &v161;
    v157[0] = a5;
    v157[1] = &v163;
    v157[2] = &v158;
    uint64_t v33 = *(void *)(v163[9] + 24);
    uint64_t v34 = v163[3];
    v181 = (int32x4_t *)v183;
    HIDWORD(v182) = 5;
    memcpy(v183, &v176[8], 4 * v28);
    LODWORD(v182) = v28;
    if (v181 != (int32x4_t *)v183) {
      free(v181);
    }
    unint64_t v37 = (uint64_t *)v163[9];
    char v38 = (uint64_t *)v37[1];
    if (v38)
    {
      *char v38 = *v37;
      if (*v37) {
        *(void *)(*v37 + 8) = v37[1];
      }
    }
    v37[3] = (uint64_t)v35;
    v37[1] = (uint64_t)v35;
    uint64_t v39 = *v35;
    uint64_t *v37 = *v35;
    if (v39) {
      *(void *)(v39 + 8) = v37;
    }
    *unint64_t v35 = (uint64_t)v37;
    unint64_t v40 = (void *)v163[9];
    uint64_t v41 = v40 + 4;
    uint64_t v42 = (void *)v40[5];
    if (v42)
    {
      void *v42 = *v41;
      if (*v41) {
        *(void *)(*v41 + 8) = v40[5];
      }
    }
    v40[7] = v36;
    v40[5] = v36;
    uint64_t v43 = *v36;
    v40[4] = *v36;
    if (v43) {
      *(void *)(v43 + 8) = v41;
    }
    uint64_t *v36 = (uint64_t)v41;
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v163 + 3));
    uint64_t v45 = mlir::mps::TensorDataLayoutAttr::get(Context, v22);
    mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr((uint64_t *)&v163, v45);
    char v46 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v163 + 3));
    uint64_t v47 = mlir::mps::TensorDataLayoutAttr::get(v46, v161);
    mlir::mps::Conv2DDataGradientOp::setStridesAttr((uint64_t *)&v163, v47);
    uint64_t Strides = mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v163);
    mlir::mps::DepthwiseConv2DDataGradientOp::setStridesAttr((uint64_t *)&v163, v49);
    uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v163);
    mlir::mps::Conv2DDataGradientOp::setDilationRatesAttr((uint64_t *)&v163, v51);
    uint64_t Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v163);
    mlir::mps::Conv2DDataGradientOp::setExplicitPaddingAttr((uint64_t *)&v163, v53);
    uint64_t v54 = (mlir::GenericProgramPoint *)v163;
    if (!v17)
    {
      unsigned int v59 = *v159;
      if (*v159 == *v160)
      {
        std::string::size_type v56 = (unsigned int *)&v173[8];
        __dst = &v173[8];
        unsigned int v57 = 5;
        *(_DWORD *)&v173[4] = 5;
        if (v59 > 3)
        {
          int v174 = 4;
          *(_OWORD *)&v173[8] = xmmword_18110B6C0;
        }
        else
        {
          *(_OWORD *)&v173[8] = xmmword_1810FFF10;
          unsigned int v57 = 4;
        }
        *(_DWORD *)v173 = v57;
      }
      else
      {
        switch(*v160)
        {
          case 1u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x100000003;
            long long v60 = xmmword_18110B6A0;
            goto LABEL_112;
          case 2u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x100000000;
            long long v60 = xmmword_18110B670;
            goto LABEL_112;
          case 3u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 1;
            long long v60 = xmmword_18110B680;
            goto LABEL_112;
          case 4u:
          case 5u:
          case 6u:
            goto LABEL_215;
          case 7u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 3;
            uint64_t v63 = &xmmword_18110B6E8;
            goto LABEL_116;
          case 8u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 1;
            uint64_t v63 = &xmmword_18110B6D4;
            goto LABEL_116;
          case 9u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 2;
            uint64_t v63 = &xmmword_18110B710;
LABEL_116:
            int v174 = v62;
            long long v64 = *v63;
            goto LABEL_118;
          case 0xAu:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v174 = 0;
            long long v64 = xmmword_18110B6FC;
LABEL_118:
            *(_OWORD *)&v173[8] = v64;
            *(void *)v173 = 0x500000005;
            unsigned int v57 = 5;
            break;
          default:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x200000001;
            long long v60 = xmmword_18110B690;
LABEL_112:
            *(_OWORD *)v173 = v60;
            unsigned int v57 = 4;
            break;
        }
      }
      unsigned int v21 = v162;
      if (v161 == v162) {
        goto LABEL_103;
      }
      goto LABEL_120;
    }
    char v55 = v158;
    std::string::size_type v56 = (unsigned int *)&v173[8];
    __dst = &v173[8];
    *(void *)v173 = 0x500000000;
    if (v158 == &__dst)
    {
      unsigned int v57 = 0;
      if (v22 == v21)
      {
LABEL_103:
        v169 = &v170[8];
        unint64_t v61 = 5;
        *(_DWORD *)&v170[4] = 5;
        if (v21 > 3)
        {
          int v171 = 4;
          *(_OWORD *)&v170[8] = xmmword_18110B6C0;
        }
        else
        {
          *(_OWORD *)&v170[8] = xmmword_1810FFF10;
          unint64_t v61 = 4;
        }
        *(_DWORD *)long long v170 = v61;
        goto LABEL_132;
      }
LABEL_120:
      switch(v21)
      {
        case 1u:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x100000003;
          long long v65 = xmmword_18110B6A0;
          goto LABEL_126;
        case 2u:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x100000000;
          long long v65 = xmmword_18110B670;
          goto LABEL_126;
        case 3u:
          v169 = &v170[8];
          *(void *)&v170[16] = 1;
          long long v65 = xmmword_18110B680;
          goto LABEL_126;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
          v169 = &v170[8];
          int v67 = 3;
          uint64_t v68 = &xmmword_18110B6E8;
          goto LABEL_130;
        case 8u:
          v169 = &v170[8];
          int v67 = 1;
          uint64_t v68 = &xmmword_18110B6D4;
          goto LABEL_130;
        case 9u:
          v169 = &v170[8];
          int v67 = 2;
          uint64_t v68 = &xmmword_18110B710;
LABEL_130:
          int v171 = v67;
          long long v66 = *v68;
          goto LABEL_131;
        case 0xAu:
          v169 = &v170[8];
          int v171 = 0;
          long long v66 = xmmword_18110B6FC;
LABEL_131:
          *(_OWORD *)&v170[8] = v66;
          *(void *)long long v170 = 0x500000005;
          unint64_t v61 = 5;
          break;
        default:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x200000001;
          long long v65 = xmmword_18110B690;
LABEL_126:
          *(_OWORD *)long long v170 = v65;
          unint64_t v61 = 4;
          break;
      }
LABEL_132:
      uint64_t v168 = v54;
      uint64_t v69 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v168);
      uint64_t v167 = (uint64_t **)v69;
      unint64_t v70 = (uint64_t *)(*(void *)(v69 + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v70) {
        goto LABEL_141;
      }
      uint64_t v71 = *v70;
      unint64_t v72 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v73 = *(unsigned int *)(v71 + 16);
      if (!v73) {
        goto LABEL_141;
      }
      unint64_t v74 = *(void **)(v71 + 8);
      uint64_t v75 = &v74[2 * v73];
      do
      {
        unint64_t v76 = v73 >> 1;
        uint64_t v77 = &v74[2 * (v73 >> 1)];
        unint64_t v79 = *v77;
        uint64_t v78 = v77 + 2;
        v73 += ~(v73 >> 1);
        if (v79 < v72) {
          unint64_t v74 = v78;
        }
        else {
          unint64_t v73 = v76;
        }
      }
      while (v73);
      if (v74 != v75 && *v74 == v72) {
        uint64_t v80 = v74[1];
      }
      else {
LABEL_141:
      }
        uint64_t v80 = 0;
      v166[0] = v70;
      v166[1] = v80;
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v166))
      {
LABEL_199:
        uint64_t v146 = *((void *)v168 + 2);
        mlir::GenericProgramPoint::~GenericProgramPoint(v168);
        uint64_t v148 = *(void *)(v147 + 8);
        *(void *)(a5 + 24) = v146;
        *(void *)(a5 + 32) = v148;
        if ((int32x4_t *)v69 != v181)
        {
          uint64_t DefiningOp = (mlir::GenericProgramPoint *)mlir::Value::getDefiningOp((mlir::Value *)&v181);
          if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v166))
          {
            v150 = (uint64_t *)v181;
          }
          else
          {
            uint64_t v151 = *((void *)DefiningOp + 2);
            mlir::GenericProgramPoint::~GenericProgramPoint(DefiningOp);
            uint64_t v153 = *(void *)(v152 + 8);
            *(void *)(a5 + 24) = v151;
            *(void *)(a5 + 32) = v153;
            uint64_t v154 = *((void *)v168 + 3);
            uint64_t ElementTypeOrSelf = 0;
            LOBYTE(v164) = 1;
            v178 = mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>((mlir::UnitAttr **)(a5 + 8), v154, (uint64_t *)&v181, (uint64_t)&ElementTypeOrSelf, (unsigned __int8 *)&v164);
            v150 = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v178);
          }
          mlir::Value::replaceAllUsesExcept(&v167, v150, (uint64_t)DefiningOp);
        }
        if (v169 != &v170[8]) {
          free(v169);
        }
        if (__dst != &v173[8]) {
          free(__dst);
        }
        if (v175 != &v176[8]) {
          free(v175);
        }
        return 1;
      }
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v166);
      v181 = (int32x4_t *)v183;
      uint64_t v182 = 0x500000000;
      uint64_t v82 = (mlir::GenericProgramPoint *)(int)v81;
      if ((unint64_t)(v81 << 32) >= 0x500000001) {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v181, v183, (int)v81, 8);
      }
      if (v57)
      {
        uint64_t v83 = 4 * v57;
        do
        {
          uint64_t v84 = *v56;
          uint64_t v85 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v166) + 8 * v84);
          uint64_t v86 = v182;
          if (v182 >= (unint64_t)HIDWORD(v182))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v181, v183, v182 + 1, 8);
            uint64_t v86 = v182;
          }
          v181->i64[v86] = v85;
          unsigned int v87 = v182 + 1;
          LODWORD(v182) = v182 + 1;
          ++v56;
          v83 -= 4;
        }
        while (v83);
      }
      else
      {
        unsigned int v87 = v182;
      }
      v178 = (mlir::GenericProgramPoint *)v166[0];
      *(void *)(v69 + 8) = *(void *)(v69 + 8) & 7 | mlir::TensorType::clone((uint64_t)&v178, (uint64_t)v181, v87);
      if ((v156 & 1) != 0 || (*((unsigned char *)v168 + 46) & 0x80) == 0 || *((_DWORD *)v168 + 17) != 3)
      {
LABEL_197:
        if (v181 != (int32x4_t *)v183) {
          free(v181);
        }
        goto LABEL_199;
      }
      uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(void *)(*((void *)v168 + 9) + 88));
      if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 32)
      {
        v178 = v82;
        uint64_t v109 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v168 + 24));
        uint64_t v110 = mlir::IntegerType::get(v109, 0x40u, 1u);
        unint64_t v111 = (void *)mlir::RankedTensorType::get((uint64_t)&v178, 1, v110, 0);
        unint64_t v112 = v111;
        if (!v111) {
          goto LABEL_178;
        }
        uint64_t v113 = *v111;
        unint64_t v114 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v115 = *(unsigned int *)(v113 + 16);
        if (!v115) {
          goto LABEL_178;
        }
        uint64_t v116 = *(void **)(v113 + 8);
        uint64_t v117 = &v116[2 * v115];
        do
        {
          unint64_t v118 = v115 >> 1;
          unint64_t v119 = &v116[2 * (v115 >> 1)];
          unint64_t v121 = *v119;
          long long v120 = v119 + 2;
          v115 += ~(v115 >> 1);
          if (v121 < v114) {
            uint64_t v116 = v120;
          }
          else {
            unint64_t v115 = v118;
          }
        }
        while (v115);
        if (v116 != v117 && *v116 == v114) {
          uint64_t v122 = v116[1];
        }
        else {
LABEL_178:
        }
          uint64_t v122 = 0;
        uint64_t v123 = *((void *)v168 + 3);
        v178 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v112, v122, v181, 8 * v182, 8, 1, 1);
        uint64_t v124 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 8), v123, (uint64_t **)&v178);
LABEL_191:
        uint64_t v141 = (uint64_t *)((char *)v124 - 16);
        unint64_t v142 = (void *)*((void *)v168 + 9);
        v143 = v142 + 8;
        v144 = (void *)v142[9];
        if (v144)
        {
          void *v144 = *v143;
          if (*v143) {
            *(void *)(*v143 + 8) = v142[9];
          }
        }
        v142[11] = v141;
        v142[9] = v141;
        uint64_t v145 = *v141;
        v142[8] = *v141;
        if (v145) {
          *(void *)(v145 + 8) = v143;
        }
        *uint64_t v141 = (uint64_t)v143;
        goto LABEL_197;
      }
      uint64_t v88 = v181;
      unint64_t v89 = v182;
      v178 = v82;
      uint64_t v90 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v168 + 24));
      uint64_t v91 = mlir::IntegerType::get(v90, 0x20u, 1u);
      uint64_t v92 = (void *)mlir::RankedTensorType::get((uint64_t)&v178, 1, v91, 0);
      uint64_t v93 = v92;
      if (!v92) {
        goto LABEL_165;
      }
      uint64_t v94 = *v92;
      unint64_t v95 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v96 = *(unsigned int *)(v94 + 16);
      if (!v96) {
        goto LABEL_165;
      }
      char v97 = *(void **)(v94 + 8);
      unint64_t v98 = &v97[2 * v96];
      do
      {
        unint64_t v99 = v96 >> 1;
        uint64_t v100 = &v97[2 * (v96 >> 1)];
        unint64_t v102 = *v100;
        uint64_t v101 = v100 + 2;
        v96 += ~(v96 >> 1);
        if (v102 < v95) {
          char v97 = v101;
        }
        else {
          unint64_t v96 = v99;
        }
      }
      while (v96);
      if (v97 != v98 && *v97 == v95) {
        uint64_t v103 = v97[1];
      }
      else {
LABEL_165:
      }
        uint64_t v103 = 0;
      uint64_t v104 = (mlir::OpBuilder *)(a5 + 8);
      uint64_t v105 = *((void *)v168 + 3);
      v178 = (mlir::GenericProgramPoint *)v180;
      uint64_t v179 = 0x500000000;
      uint64_t v155 = v105;
      if (v89 < 6)
      {
        if (!v89)
        {
          int v140 = 0;
          uint64_t v108 = (uint64_t *)v180;
          uint64_t v125 = v155;
LABEL_189:
          LODWORD(v179) = v140 + v89;
          v164 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v93, v103, v108, 4 * (v140 + v89), 4, 1, 1);
          uint64_t v124 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v104, v125, &v164);
          if (v178 != (mlir::GenericProgramPoint *)v180) {
            free(v178);
          }
          goto LABEL_191;
        }
        uint64_t v107 = 0;
        uint64_t v108 = (uint64_t *)v180;
      }
      else
      {
        uint64_t v106 = v103;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v178, v180, v89, 4);
        uint64_t v103 = v106;
        uint64_t v104 = (mlir::OpBuilder *)(a5 + 8);
        uint64_t v107 = v179;
        uint64_t v108 = (uint64_t *)v178;
      }
      uint64_t v125 = v155;
      unsigned int v126 = (int32x4_t *)((char *)v108 + 4 * v107);
      unint64_t v127 = (v89 - 1) & 0x1FFFFFFFFFFFFFFFLL;
      if (v127 >= 7)
      {
        unint64_t v130 = v127 + 1;
        uint64_t v131 = (v127 + 1) & 0x3FFFFFFFFFFFFFF8;
        uint64_t v128 = (int32x4_t *)((char *)v126 + 4 * v131);
        uint64_t v129 = &v88->i8[8 * v131];
        unint64_t v132 = v88 + 2;
        uint64_t v133 = v126 + 1;
        uint64_t v134 = v131;
        do
        {
          int32x4_t v136 = v132[-2];
          int32x4_t v135 = v132[-1];
          int32x4_t v138 = *v132;
          int32x4_t v137 = v132[1];
          v132 += 4;
          v133[-1] = vuzp1q_s32(v136, v135);
          int32x4_t *v133 = vuzp1q_s32(v138, v137);
          v133 += 2;
          v134 -= 8;
        }
        while (v134);
        if (v130 == v131) {
          goto LABEL_188;
        }
      }
      else
      {
        uint64_t v128 = v126;
        uint64_t v129 = (char *)v88;
      }
      do
      {
        uint64_t v139 = *(void *)v129;
        v129 += 8;
        v128->i32[0] = v139;
        uint64_t v128 = (int32x4_t *)((char *)v128 + 4);
      }
      while (v129 != (char *)v88 + 8 * v89);
LABEL_188:
      int v140 = v179;
      goto LABEL_189;
    }
    unsigned int v57 = *((_DWORD *)v158 + 2);
    if (!v57)
    {
LABEL_102:
      if (v22 == v21) {
        goto LABEL_103;
      }
      goto LABEL_120;
    }
    if (v57 < 6)
    {
      unsigned int v58 = *((_DWORD *)v158 + 2);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v173[8], *((unsigned int *)v158 + 2), 4);
      unsigned int v58 = *((_DWORD *)v55 + 2);
      if (!v58)
      {
LABEL_101:
        *(_DWORD *)v173 = v57;
        std::string::size_type v56 = (unsigned int *)__dst;
        goto LABEL_102;
      }
      std::string::size_type v56 = (unsigned int *)__dst;
    }
    memcpy(v56, *v55, 4 * v58);
    goto LABEL_101;
  }
LABEL_6:
  uint64_t result = 0;
  if (a4)
  {
    switch(PaddingStyle)
    {
      case 2:
      case 9:
        if (a4 == 2) {
          goto LABEL_9;
        }
        goto LABEL_41;
      case 3:
      case 10:
        if (a4 == 1) {
          goto LABEL_9;
        }
LABEL_41:
        uint64_t result = 0;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t mlir::mps::anonymous namespace'::ConvertConvolutionInterface<mlir::mps::DepthwiseConv2DOp>::convertLayout(mlir::Operation *,mlir::mps::LayoutConversionType,mlir::mps::LayoutConversionType,mlir::RewriterBase &)const::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)a1;
  uint64_t v5 = *(void *)(**(void **)(a1 + 8) + 24);
  uint64_t v6 = *(uint64_t **)(a1 + 16);
  if (a3)
  {
    uint64_t v7 = *v6;
    uint64_t v8 = &v21[8];
    __dst = &v21[8];
    *(void *)unsigned int v21 = 0x500000000;
    unint64_t v9 = *(unsigned int *)(v7 + 8);
    if ((void **)v7 == &__dst || v9 == 0)
    {
      unint64_t v9 = 0;
      goto LABEL_31;
    }
    if (v9 < 6)
    {
      unsigned int v13 = *(_DWORD *)(v7 + 8);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v21[8], *(unsigned int *)(v7 + 8), 4);
      unsigned int v13 = *(_DWORD *)(v7 + 8);
      if (!v13)
      {
LABEL_20:
        *(_DWORD *)unsigned int v21 = v9;
        uint64_t v8 = __dst;
        goto LABEL_31;
      }
      uint64_t v8 = __dst;
    }
    memcpy(v8, *(const void **)v7, 4 * v13);
    goto LABEL_20;
  }
  char v11 = (_DWORD *)v6[2];
  unsigned int v12 = *(_DWORD *)v6[1];
  if (v12 == *v11)
  {
    uint64_t v8 = &v21[8];
    __dst = &v21[8];
    unint64_t v9 = 5;
    *(_DWORD *)&uint64_t v21[4] = 5;
    if (v12 > 3)
    {
      int v22 = 4;
      *(_OWORD *)&v21[8] = xmmword_18110B6C0;
    }
    else
    {
      *(_OWORD *)&v21[8] = xmmword_1810FFF10;
      unint64_t v9 = 4;
    }
    *(_DWORD *)unsigned int v21 = v9;
  }
  else
  {
    switch(*v11)
    {
      case 1:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x100000003;
        long long v14 = xmmword_18110B6A0;
        goto LABEL_25;
      case 2:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x100000000;
        long long v14 = xmmword_18110B670;
        goto LABEL_25;
      case 3:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 1;
        long long v14 = xmmword_18110B680;
        goto LABEL_25;
      case 4:
      case 5:
      case 6:
        __break(1u);
        JUMPOUT(0x1805675F0);
      case 7:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 3;
        BOOL v17 = &xmmword_18110B6E8;
        goto LABEL_29;
      case 8:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 1;
        BOOL v17 = &xmmword_18110B6D4;
        goto LABEL_29;
      case 9:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 2;
        BOOL v17 = &xmmword_18110B710;
LABEL_29:
        int v22 = v16;
        long long v15 = *v17;
        goto LABEL_30;
      case 0xA:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v22 = 0;
        long long v15 = xmmword_18110B6FC;
LABEL_30:
        *(_OWORD *)&v21[8] = v15;
        *(void *)unsigned int v21 = 0x500000005;
        unint64_t v9 = 5;
        break;
      default:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x200000001;
        long long v14 = xmmword_18110B690;
LABEL_25:
        *(_OWORD *)unsigned int v21 = v14;
        unint64_t v9 = 4;
        break;
    }
  }
LABEL_31:
  if (__dst != &v21[8]) {
    free(__dst);
  }
  return v18;
}

uint64_t mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConvertConvolutionInterface<mlir::mps::DepthwiseConv2DDataGradientOp>>::convertLayout(uint64_t a1, void *a2, int a3, int a4, uint64_t a5)
{
  v183[5] = *MEMORY[0x1E4F143B8];
  v163 = a2;
  int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v163);
  int PaddingStyle = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v163);
  if (a3)
  {
    switch(StorageType)
    {
      case 0:
      case 7:
        if (a3 != 2) {
          goto LABEL_6;
        }
        break;
      case 1:
      case 8:
        if (a3 != 1) {
          goto LABEL_6;
        }
        break;
      default:
        goto LABEL_6;
    }
LABEL_9:
    char v11 = *(void **)(v163[6] + 16);
    BOOL v14 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
    char v15 = v14;
    if (v14)
    {
      int v16 = 0;
      BOOL v17 = 1;
    }
    else
    {
      BOOL v17 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id;
      int v16 = !v17;
    }
    unsigned int v21 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v163);
    unsigned int v22 = v21;
    if (a3)
    {
      switch(v21)
      {
        case 2u:
        case 3u:
          BOOL v23 = a3 == 1;
          int v24 = 2;
          goto LABEL_45;
        case 4u:
        case 5u:
        case 6u:
LABEL_215:
          __break(1u);
          JUMPOUT(0x1805685E0);
        case 7u:
        case 8u:
          BOOL v23 = a3 == 1;
          int v24 = 7;
          goto LABEL_45;
        case 9u:
        case 0xAu:
          BOOL v23 = a3 == 1;
          int v24 = 9;
LABEL_45:
          if (v23) {
            unsigned int v22 = v24;
          }
          else {
            unsigned int v22 = v24 + 1;
          }
          break;
        default:
          unsigned int v22 = a3 != 1;
          break;
      }
    }
    unsigned int v25 = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v163);
    unsigned int v162 = v25;
    if (a4)
    {
      switch(v25)
      {
        case 2u:
        case 3u:
          BOOL v26 = a4 == 1;
          int v27 = 2;
          goto LABEL_54;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
        case 8u:
          BOOL v26 = a4 == 1;
          int v27 = 7;
          goto LABEL_54;
        case 9u:
        case 0xAu:
          BOOL v26 = a4 == 1;
          int v27 = 9;
LABEL_54:
          if (v26) {
            unsigned int v25 = v27;
          }
          else {
            unsigned int v25 = v27 + 1;
          }
          break;
        default:
          unsigned int v25 = a4 != 1;
          break;
      }
    }
    unsigned int v161 = v25;
    char v156 = v15;
    if (v21 == v22)
    {
      v175 = &v176[8];
      unsigned int v28 = 5;
      *(_DWORD *)&v176[4] = 5;
      if (v21 > 3)
      {
        int v177 = 4;
        *(_OWORD *)&v176[8] = xmmword_18110B6C0;
      }
      else
      {
        *(_OWORD *)&v176[8] = xmmword_1810FFF10;
        unsigned int v28 = 4;
      }
      *(_DWORD *)v176 = v28;
    }
    else
    {
      switch(v22)
      {
        case 1u:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x100000003;
          long long v29 = xmmword_18110B6A0;
          goto LABEL_67;
        case 2u:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x100000000;
          long long v29 = xmmword_18110B670;
          goto LABEL_67;
        case 3u:
          v175 = &v176[8];
          *(void *)&v176[16] = 1;
          long long v29 = xmmword_18110B680;
          goto LABEL_67;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
          v175 = &v176[8];
          int v31 = 3;
          uint64_t v32 = &xmmword_18110B6E8;
          goto LABEL_72;
        case 8u:
          v175 = &v176[8];
          int v31 = 1;
          uint64_t v32 = &xmmword_18110B6D4;
          goto LABEL_72;
        case 9u:
          v175 = &v176[8];
          int v31 = 2;
          uint64_t v32 = &xmmword_18110B710;
LABEL_72:
          int v177 = v31;
          long long v30 = *v32;
          goto LABEL_73;
        case 0xAu:
          v175 = &v176[8];
          int v177 = 0;
          long long v30 = xmmword_18110B6FC;
LABEL_73:
          *(_OWORD *)&v176[8] = v30;
          *(void *)v176 = 0x500000005;
          unsigned int v28 = 5;
          break;
        default:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x200000001;
          long long v29 = xmmword_18110B690;
LABEL_67:
          *(_OWORD *)v176 = v29;
          unsigned int v28 = 4;
          break;
      }
    }
    v158 = &v175;
    v159 = &v162;
    v160 = &v161;
    v157[0] = a5;
    v157[1] = &v163;
    v157[2] = &v158;
    uint64_t v33 = *(void *)(v163[9] + 24);
    uint64_t v34 = v163[3];
    v181 = (int32x4_t *)v183;
    HIDWORD(v182) = 5;
    memcpy(v183, &v176[8], 4 * v28);
    LODWORD(v182) = v28;
    if (v181 != (int32x4_t *)v183) {
      free(v181);
    }
    unint64_t v37 = (uint64_t *)v163[9];
    char v38 = (uint64_t *)v37[1];
    if (v38)
    {
      *char v38 = *v37;
      if (*v37) {
        *(void *)(*v37 + 8) = v37[1];
      }
    }
    v37[3] = (uint64_t)v35;
    v37[1] = (uint64_t)v35;
    uint64_t v39 = *v35;
    uint64_t *v37 = *v35;
    if (v39) {
      *(void *)(v39 + 8) = v37;
    }
    *unint64_t v35 = (uint64_t)v37;
    unint64_t v40 = (void *)v163[9];
    uint64_t v41 = v40 + 4;
    uint64_t v42 = (void *)v40[5];
    if (v42)
    {
      void *v42 = *v41;
      if (*v41) {
        *(void *)(*v41 + 8) = v40[5];
      }
    }
    v40[7] = v36;
    v40[5] = v36;
    uint64_t v43 = *v36;
    v40[4] = *v36;
    if (v43) {
      *(void *)(v43 + 8) = v41;
    }
    uint64_t *v36 = (uint64_t)v41;
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v163 + 3));
    uint64_t v45 = mlir::mps::TensorDataLayoutAttr::get(Context, v22);
    mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr((uint64_t *)&v163, v45);
    char v46 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v163 + 3));
    uint64_t v47 = mlir::mps::TensorDataLayoutAttr::get(v46, v161);
    mlir::mps::Conv2DDataGradientOp::setStridesAttr((uint64_t *)&v163, v47);
    uint64_t Strides = mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v163);
    mlir::mps::DepthwiseConv2DDataGradientOp::setStridesAttr((uint64_t *)&v163, v49);
    uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v163);
    mlir::mps::Conv2DDataGradientOp::setDilationRatesAttr((uint64_t *)&v163, v51);
    uint64_t Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v163);
    mlir::mps::Conv2DDataGradientOp::setExplicitPaddingAttr((uint64_t *)&v163, v53);
    uint64_t v54 = (mlir::GenericProgramPoint *)v163;
    if (!v17)
    {
      unsigned int v59 = *v159;
      if (*v159 == *v160)
      {
        std::string::size_type v56 = (unsigned int *)&v173[8];
        __dst = &v173[8];
        unsigned int v57 = 5;
        *(_DWORD *)&v173[4] = 5;
        if (v59 > 3)
        {
          int v174 = 4;
          *(_OWORD *)&v173[8] = xmmword_18110B6C0;
        }
        else
        {
          *(_OWORD *)&v173[8] = xmmword_1810FFF10;
          unsigned int v57 = 4;
        }
        *(_DWORD *)v173 = v57;
      }
      else
      {
        switch(*v160)
        {
          case 1u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x100000003;
            long long v60 = xmmword_18110B6A0;
            goto LABEL_112;
          case 2u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x100000000;
            long long v60 = xmmword_18110B670;
            goto LABEL_112;
          case 3u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 1;
            long long v60 = xmmword_18110B680;
            goto LABEL_112;
          case 4u:
          case 5u:
          case 6u:
            goto LABEL_215;
          case 7u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 3;
            uint64_t v63 = &xmmword_18110B6E8;
            goto LABEL_116;
          case 8u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 1;
            uint64_t v63 = &xmmword_18110B6D4;
            goto LABEL_116;
          case 9u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 2;
            uint64_t v63 = &xmmword_18110B710;
LABEL_116:
            int v174 = v62;
            long long v64 = *v63;
            goto LABEL_118;
          case 0xAu:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v174 = 0;
            long long v64 = xmmword_18110B6FC;
LABEL_118:
            *(_OWORD *)&v173[8] = v64;
            *(void *)v173 = 0x500000005;
            unsigned int v57 = 5;
            break;
          default:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x200000001;
            long long v60 = xmmword_18110B690;
LABEL_112:
            *(_OWORD *)v173 = v60;
            unsigned int v57 = 4;
            break;
        }
      }
      unsigned int v21 = v162;
      if (v161 == v162) {
        goto LABEL_103;
      }
      goto LABEL_120;
    }
    char v55 = v158;
    std::string::size_type v56 = (unsigned int *)&v173[8];
    __dst = &v173[8];
    *(void *)v173 = 0x500000000;
    if (v158 == &__dst)
    {
      unsigned int v57 = 0;
      if (v22 == v21)
      {
LABEL_103:
        v169 = &v170[8];
        unint64_t v61 = 5;
        *(_DWORD *)&v170[4] = 5;
        if (v21 > 3)
        {
          int v171 = 4;
          *(_OWORD *)&v170[8] = xmmword_18110B6C0;
        }
        else
        {
          *(_OWORD *)&v170[8] = xmmword_1810FFF10;
          unint64_t v61 = 4;
        }
        *(_DWORD *)long long v170 = v61;
        goto LABEL_132;
      }
LABEL_120:
      switch(v21)
      {
        case 1u:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x100000003;
          long long v65 = xmmword_18110B6A0;
          goto LABEL_126;
        case 2u:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x100000000;
          long long v65 = xmmword_18110B670;
          goto LABEL_126;
        case 3u:
          v169 = &v170[8];
          *(void *)&v170[16] = 1;
          long long v65 = xmmword_18110B680;
          goto LABEL_126;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
          v169 = &v170[8];
          int v67 = 3;
          uint64_t v68 = &xmmword_18110B6E8;
          goto LABEL_130;
        case 8u:
          v169 = &v170[8];
          int v67 = 1;
          uint64_t v68 = &xmmword_18110B6D4;
          goto LABEL_130;
        case 9u:
          v169 = &v170[8];
          int v67 = 2;
          uint64_t v68 = &xmmword_18110B710;
LABEL_130:
          int v171 = v67;
          long long v66 = *v68;
          goto LABEL_131;
        case 0xAu:
          v169 = &v170[8];
          int v171 = 0;
          long long v66 = xmmword_18110B6FC;
LABEL_131:
          *(_OWORD *)&v170[8] = v66;
          *(void *)long long v170 = 0x500000005;
          unint64_t v61 = 5;
          break;
        default:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x200000001;
          long long v65 = xmmword_18110B690;
LABEL_126:
          *(_OWORD *)long long v170 = v65;
          unint64_t v61 = 4;
          break;
      }
LABEL_132:
      uint64_t v168 = v54;
      uint64_t v69 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v168);
      uint64_t v167 = (uint64_t **)v69;
      unint64_t v70 = (uint64_t *)(*(void *)(v69 + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v70) {
        goto LABEL_141;
      }
      uint64_t v71 = *v70;
      unint64_t v72 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v73 = *(unsigned int *)(v71 + 16);
      if (!v73) {
        goto LABEL_141;
      }
      unint64_t v74 = *(void **)(v71 + 8);
      uint64_t v75 = &v74[2 * v73];
      do
      {
        unint64_t v76 = v73 >> 1;
        uint64_t v77 = &v74[2 * (v73 >> 1)];
        unint64_t v79 = *v77;
        uint64_t v78 = v77 + 2;
        v73 += ~(v73 >> 1);
        if (v79 < v72) {
          unint64_t v74 = v78;
        }
        else {
          unint64_t v73 = v76;
        }
      }
      while (v73);
      if (v74 != v75 && *v74 == v72) {
        uint64_t v80 = v74[1];
      }
      else {
LABEL_141:
      }
        uint64_t v80 = 0;
      v166[0] = v70;
      v166[1] = v80;
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v166))
      {
LABEL_199:
        uint64_t v146 = *((void *)v168 + 2);
        mlir::GenericProgramPoint::~GenericProgramPoint(v168);
        uint64_t v148 = *(void *)(v147 + 8);
        *(void *)(a5 + 24) = v146;
        *(void *)(a5 + 32) = v148;
        if ((int32x4_t *)v69 != v181)
        {
          uint64_t DefiningOp = (mlir::GenericProgramPoint *)mlir::Value::getDefiningOp((mlir::Value *)&v181);
          if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v166))
          {
            v150 = (uint64_t *)v181;
          }
          else
          {
            uint64_t v151 = *((void *)DefiningOp + 2);
            mlir::GenericProgramPoint::~GenericProgramPoint(DefiningOp);
            uint64_t v153 = *(void *)(v152 + 8);
            *(void *)(a5 + 24) = v151;
            *(void *)(a5 + 32) = v153;
            uint64_t v154 = *((void *)v168 + 3);
            uint64_t ElementTypeOrSelf = 0;
            LOBYTE(v164) = 1;
            v178 = mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>((mlir::UnitAttr **)(a5 + 8), v154, (uint64_t *)&v181, (uint64_t)&ElementTypeOrSelf, (unsigned __int8 *)&v164);
            v150 = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v178);
          }
          mlir::Value::replaceAllUsesExcept(&v167, v150, (uint64_t)DefiningOp);
        }
        if (v169 != &v170[8]) {
          free(v169);
        }
        if (__dst != &v173[8]) {
          free(__dst);
        }
        if (v175 != &v176[8]) {
          free(v175);
        }
        return 1;
      }
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v166);
      v181 = (int32x4_t *)v183;
      uint64_t v182 = 0x500000000;
      uint64_t v82 = (mlir::GenericProgramPoint *)(int)v81;
      if ((unint64_t)(v81 << 32) >= 0x500000001) {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v181, v183, (int)v81, 8);
      }
      if (v57)
      {
        uint64_t v83 = 4 * v57;
        do
        {
          uint64_t v84 = *v56;
          uint64_t v85 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v166) + 8 * v84);
          uint64_t v86 = v182;
          if (v182 >= (unint64_t)HIDWORD(v182))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v181, v183, v182 + 1, 8);
            uint64_t v86 = v182;
          }
          v181->i64[v86] = v85;
          unsigned int v87 = v182 + 1;
          LODWORD(v182) = v182 + 1;
          ++v56;
          v83 -= 4;
        }
        while (v83);
      }
      else
      {
        unsigned int v87 = v182;
      }
      v178 = (mlir::GenericProgramPoint *)v166[0];
      *(void *)(v69 + 8) = *(void *)(v69 + 8) & 7 | mlir::TensorType::clone((uint64_t)&v178, (uint64_t)v181, v87);
      if ((v156 & 1) != 0 || (*((unsigned char *)v168 + 46) & 0x80) == 0 || *((_DWORD *)v168 + 17) != 3)
      {
LABEL_197:
        if (v181 != (int32x4_t *)v183) {
          free(v181);
        }
        goto LABEL_199;
      }
      uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(void *)(*((void *)v168 + 9) + 88));
      if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 32)
      {
        v178 = v82;
        uint64_t v109 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v168 + 24));
        uint64_t v110 = mlir::IntegerType::get(v109, 0x40u, 1u);
        unint64_t v111 = (void *)mlir::RankedTensorType::get((uint64_t)&v178, 1, v110, 0);
        unint64_t v112 = v111;
        if (!v111) {
          goto LABEL_178;
        }
        uint64_t v113 = *v111;
        unint64_t v114 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v115 = *(unsigned int *)(v113 + 16);
        if (!v115) {
          goto LABEL_178;
        }
        uint64_t v116 = *(void **)(v113 + 8);
        uint64_t v117 = &v116[2 * v115];
        do
        {
          unint64_t v118 = v115 >> 1;
          unint64_t v119 = &v116[2 * (v115 >> 1)];
          unint64_t v121 = *v119;
          long long v120 = v119 + 2;
          v115 += ~(v115 >> 1);
          if (v121 < v114) {
            uint64_t v116 = v120;
          }
          else {
            unint64_t v115 = v118;
          }
        }
        while (v115);
        if (v116 != v117 && *v116 == v114) {
          uint64_t v122 = v116[1];
        }
        else {
LABEL_178:
        }
          uint64_t v122 = 0;
        uint64_t v123 = *((void *)v168 + 3);
        v178 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v112, v122, v181, 8 * v182, 8, 1, 1);
        uint64_t v124 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 8), v123, (uint64_t **)&v178);
LABEL_191:
        uint64_t v141 = (uint64_t *)((char *)v124 - 16);
        unint64_t v142 = (void *)*((void *)v168 + 9);
        v143 = v142 + 8;
        v144 = (void *)v142[9];
        if (v144)
        {
          void *v144 = *v143;
          if (*v143) {
            *(void *)(*v143 + 8) = v142[9];
          }
        }
        v142[11] = v141;
        v142[9] = v141;
        uint64_t v145 = *v141;
        v142[8] = *v141;
        if (v145) {
          *(void *)(v145 + 8) = v143;
        }
        *uint64_t v141 = (uint64_t)v143;
        goto LABEL_197;
      }
      uint64_t v88 = v181;
      unint64_t v89 = v182;
      v178 = v82;
      uint64_t v90 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v168 + 24));
      uint64_t v91 = mlir::IntegerType::get(v90, 0x20u, 1u);
      uint64_t v92 = (void *)mlir::RankedTensorType::get((uint64_t)&v178, 1, v91, 0);
      uint64_t v93 = v92;
      if (!v92) {
        goto LABEL_165;
      }
      uint64_t v94 = *v92;
      unint64_t v95 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v96 = *(unsigned int *)(v94 + 16);
      if (!v96) {
        goto LABEL_165;
      }
      char v97 = *(void **)(v94 + 8);
      unint64_t v98 = &v97[2 * v96];
      do
      {
        unint64_t v99 = v96 >> 1;
        uint64_t v100 = &v97[2 * (v96 >> 1)];
        unint64_t v102 = *v100;
        uint64_t v101 = v100 + 2;
        v96 += ~(v96 >> 1);
        if (v102 < v95) {
          char v97 = v101;
        }
        else {
          unint64_t v96 = v99;
        }
      }
      while (v96);
      if (v97 != v98 && *v97 == v95) {
        uint64_t v103 = v97[1];
      }
      else {
LABEL_165:
      }
        uint64_t v103 = 0;
      uint64_t v104 = (mlir::OpBuilder *)(a5 + 8);
      uint64_t v105 = *((void *)v168 + 3);
      v178 = (mlir::GenericProgramPoint *)v180;
      uint64_t v179 = 0x500000000;
      uint64_t v155 = v105;
      if (v89 < 6)
      {
        if (!v89)
        {
          int v140 = 0;
          uint64_t v108 = (uint64_t *)v180;
          uint64_t v125 = v155;
LABEL_189:
          LODWORD(v179) = v140 + v89;
          v164 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v93, v103, v108, 4 * (v140 + v89), 4, 1, 1);
          uint64_t v124 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v104, v125, &v164);
          if (v178 != (mlir::GenericProgramPoint *)v180) {
            free(v178);
          }
          goto LABEL_191;
        }
        uint64_t v107 = 0;
        uint64_t v108 = (uint64_t *)v180;
      }
      else
      {
        uint64_t v106 = v103;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v178, v180, v89, 4);
        uint64_t v103 = v106;
        uint64_t v104 = (mlir::OpBuilder *)(a5 + 8);
        uint64_t v107 = v179;
        uint64_t v108 = (uint64_t *)v178;
      }
      uint64_t v125 = v155;
      unsigned int v126 = (int32x4_t *)((char *)v108 + 4 * v107);
      unint64_t v127 = (v89 - 1) & 0x1FFFFFFFFFFFFFFFLL;
      if (v127 >= 7)
      {
        unint64_t v130 = v127 + 1;
        uint64_t v131 = (v127 + 1) & 0x3FFFFFFFFFFFFFF8;
        uint64_t v128 = (int32x4_t *)((char *)v126 + 4 * v131);
        uint64_t v129 = &v88->i8[8 * v131];
        unint64_t v132 = v88 + 2;
        uint64_t v133 = v126 + 1;
        uint64_t v134 = v131;
        do
        {
          int32x4_t v136 = v132[-2];
          int32x4_t v135 = v132[-1];
          int32x4_t v138 = *v132;
          int32x4_t v137 = v132[1];
          v132 += 4;
          v133[-1] = vuzp1q_s32(v136, v135);
          int32x4_t *v133 = vuzp1q_s32(v138, v137);
          v133 += 2;
          v134 -= 8;
        }
        while (v134);
        if (v130 == v131) {
          goto LABEL_188;
        }
      }
      else
      {
        uint64_t v128 = v126;
        uint64_t v129 = (char *)v88;
      }
      do
      {
        uint64_t v139 = *(void *)v129;
        v129 += 8;
        v128->i32[0] = v139;
        uint64_t v128 = (int32x4_t *)((char *)v128 + 4);
      }
      while (v129 != (char *)v88 + 8 * v89);
LABEL_188:
      int v140 = v179;
      goto LABEL_189;
    }
    unsigned int v57 = *((_DWORD *)v158 + 2);
    if (!v57)
    {
LABEL_102:
      if (v22 == v21) {
        goto LABEL_103;
      }
      goto LABEL_120;
    }
    if (v57 < 6)
    {
      unsigned int v58 = *((_DWORD *)v158 + 2);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v173[8], *((unsigned int *)v158 + 2), 4);
      unsigned int v58 = *((_DWORD *)v55 + 2);
      if (!v58)
      {
LABEL_101:
        *(_DWORD *)v173 = v57;
        std::string::size_type v56 = (unsigned int *)__dst;
        goto LABEL_102;
      }
      std::string::size_type v56 = (unsigned int *)__dst;
    }
    memcpy(v56, *v55, 4 * v58);
    goto LABEL_101;
  }
LABEL_6:
  uint64_t result = 0;
  if (a4)
  {
    switch(PaddingStyle)
    {
      case 2:
      case 9:
        if (a4 == 2) {
          goto LABEL_9;
        }
        goto LABEL_41;
      case 3:
      case 10:
        if (a4 == 1) {
          goto LABEL_9;
        }
LABEL_41:
        uint64_t result = 0;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t mlir::mps::anonymous namespace'::ConvertConvolutionInterface<mlir::mps::DepthwiseConv2DDataGradientOp>::convertLayout(mlir::Operation *,mlir::mps::LayoutConversionType,mlir::mps::LayoutConversionType,mlir::RewriterBase &)const::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)a1;
  uint64_t v5 = *(void *)(**(void **)(a1 + 8) + 24);
  uint64_t v6 = *(uint64_t **)(a1 + 16);
  if (a3)
  {
    uint64_t v7 = *v6;
    uint64_t v8 = &v21[8];
    __dst = &v21[8];
    *(void *)unsigned int v21 = 0x500000000;
    unint64_t v9 = *(unsigned int *)(v7 + 8);
    if ((void **)v7 == &__dst || v9 == 0)
    {
      unint64_t v9 = 0;
      goto LABEL_31;
    }
    if (v9 < 6)
    {
      unsigned int v13 = *(_DWORD *)(v7 + 8);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v21[8], *(unsigned int *)(v7 + 8), 4);
      unsigned int v13 = *(_DWORD *)(v7 + 8);
      if (!v13)
      {
LABEL_20:
        *(_DWORD *)unsigned int v21 = v9;
        uint64_t v8 = __dst;
        goto LABEL_31;
      }
      uint64_t v8 = __dst;
    }
    memcpy(v8, *(const void **)v7, 4 * v13);
    goto LABEL_20;
  }
  char v11 = (_DWORD *)v6[2];
  unsigned int v12 = *(_DWORD *)v6[1];
  if (v12 == *v11)
  {
    uint64_t v8 = &v21[8];
    __dst = &v21[8];
    unint64_t v9 = 5;
    *(_DWORD *)&uint64_t v21[4] = 5;
    if (v12 > 3)
    {
      int v22 = 4;
      *(_OWORD *)&v21[8] = xmmword_18110B6C0;
    }
    else
    {
      *(_OWORD *)&v21[8] = xmmword_1810FFF10;
      unint64_t v9 = 4;
    }
    *(_DWORD *)unsigned int v21 = v9;
  }
  else
  {
    switch(*v11)
    {
      case 1:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x100000003;
        long long v14 = xmmword_18110B6A0;
        goto LABEL_25;
      case 2:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x100000000;
        long long v14 = xmmword_18110B670;
        goto LABEL_25;
      case 3:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 1;
        long long v14 = xmmword_18110B680;
        goto LABEL_25;
      case 4:
      case 5:
      case 6:
        __break(1u);
        JUMPOUT(0x1805689D8);
      case 7:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 3;
        BOOL v17 = &xmmword_18110B6E8;
        goto LABEL_29;
      case 8:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 1;
        BOOL v17 = &xmmword_18110B6D4;
        goto LABEL_29;
      case 9:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 2;
        BOOL v17 = &xmmword_18110B710;
LABEL_29:
        int v22 = v16;
        long long v15 = *v17;
        goto LABEL_30;
      case 0xA:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v22 = 0;
        long long v15 = xmmword_18110B6FC;
LABEL_30:
        *(_OWORD *)&v21[8] = v15;
        *(void *)unsigned int v21 = 0x500000005;
        unint64_t v9 = 5;
        break;
      default:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x200000001;
        long long v14 = xmmword_18110B690;
LABEL_25:
        *(_OWORD *)unsigned int v21 = v14;
        unint64_t v9 = 4;
        break;
    }
  }
LABEL_31:
  if (__dst != &v21[8]) {
    free(__dst);
  }
  return v18;
}

uint64_t mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConvertConvolutionInterface<mlir::mps::DepthwiseConv2DWeightsGradientOp>>::convertLayout(uint64_t a1, void *a2, int a3, int a4, uint64_t a5)
{
  v183[5] = *MEMORY[0x1E4F143B8];
  v163 = a2;
  int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v163);
  int PaddingStyle = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v163);
  if (a3)
  {
    switch(StorageType)
    {
      case 0:
      case 7:
        if (a3 != 2) {
          goto LABEL_6;
        }
        break;
      case 1:
      case 8:
        if (a3 != 1) {
          goto LABEL_6;
        }
        break;
      default:
        goto LABEL_6;
    }
LABEL_9:
    char v11 = *(void **)(v163[6] + 16);
    BOOL v14 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id
       || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
    char v15 = v14;
    if (v14)
    {
      int v16 = 0;
      BOOL v17 = 1;
    }
    else
    {
      BOOL v17 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id
         || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id;
      int v16 = !v17;
    }
    unsigned int v21 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v163);
    unsigned int v22 = v21;
    if (a3)
    {
      switch(v21)
      {
        case 2u:
        case 3u:
          BOOL v23 = a3 == 1;
          int v24 = 2;
          goto LABEL_45;
        case 4u:
        case 5u:
        case 6u:
LABEL_215:
          __break(1u);
          JUMPOUT(0x1805699C8);
        case 7u:
        case 8u:
          BOOL v23 = a3 == 1;
          int v24 = 7;
          goto LABEL_45;
        case 9u:
        case 0xAu:
          BOOL v23 = a3 == 1;
          int v24 = 9;
LABEL_45:
          if (v23) {
            unsigned int v22 = v24;
          }
          else {
            unsigned int v22 = v24 + 1;
          }
          break;
        default:
          unsigned int v22 = a3 != 1;
          break;
      }
    }
    unsigned int v25 = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v163);
    unsigned int v162 = v25;
    if (a4)
    {
      switch(v25)
      {
        case 2u:
        case 3u:
          BOOL v26 = a4 == 1;
          int v27 = 2;
          goto LABEL_54;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
        case 8u:
          BOOL v26 = a4 == 1;
          int v27 = 7;
          goto LABEL_54;
        case 9u:
        case 0xAu:
          BOOL v26 = a4 == 1;
          int v27 = 9;
LABEL_54:
          if (v26) {
            unsigned int v25 = v27;
          }
          else {
            unsigned int v25 = v27 + 1;
          }
          break;
        default:
          unsigned int v25 = a4 != 1;
          break;
      }
    }
    unsigned int v161 = v25;
    char v156 = v15;
    if (v21 == v22)
    {
      v175 = &v176[8];
      unsigned int v28 = 5;
      *(_DWORD *)&v176[4] = 5;
      if (v21 > 3)
      {
        int v177 = 4;
        *(_OWORD *)&v176[8] = xmmword_18110B6C0;
      }
      else
      {
        *(_OWORD *)&v176[8] = xmmword_1810FFF10;
        unsigned int v28 = 4;
      }
      *(_DWORD *)v176 = v28;
    }
    else
    {
      switch(v22)
      {
        case 1u:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x100000003;
          long long v29 = xmmword_18110B6A0;
          goto LABEL_67;
        case 2u:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x100000000;
          long long v29 = xmmword_18110B670;
          goto LABEL_67;
        case 3u:
          v175 = &v176[8];
          *(void *)&v176[16] = 1;
          long long v29 = xmmword_18110B680;
          goto LABEL_67;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
          v175 = &v176[8];
          int v31 = 3;
          uint64_t v32 = &xmmword_18110B6E8;
          goto LABEL_72;
        case 8u:
          v175 = &v176[8];
          int v31 = 1;
          uint64_t v32 = &xmmword_18110B6D4;
          goto LABEL_72;
        case 9u:
          v175 = &v176[8];
          int v31 = 2;
          uint64_t v32 = &xmmword_18110B710;
LABEL_72:
          int v177 = v31;
          long long v30 = *v32;
          goto LABEL_73;
        case 0xAu:
          v175 = &v176[8];
          int v177 = 0;
          long long v30 = xmmword_18110B6FC;
LABEL_73:
          *(_OWORD *)&v176[8] = v30;
          *(void *)v176 = 0x500000005;
          unsigned int v28 = 5;
          break;
        default:
          v175 = &v176[8];
          *(void *)&v176[16] = 0x200000001;
          long long v29 = xmmword_18110B690;
LABEL_67:
          *(_OWORD *)v176 = v29;
          unsigned int v28 = 4;
          break;
      }
    }
    v158 = &v175;
    v159 = &v162;
    v160 = &v161;
    v157[0] = a5;
    v157[1] = &v163;
    v157[2] = &v158;
    uint64_t v33 = *(void *)(v163[9] + 24);
    uint64_t v34 = v163[3];
    v181 = (int32x4_t *)v183;
    HIDWORD(v182) = 5;
    memcpy(v183, &v176[8], 4 * v28);
    LODWORD(v182) = v28;
    if (v181 != (int32x4_t *)v183) {
      free(v181);
    }
    unint64_t v37 = (uint64_t *)v163[9];
    char v38 = (uint64_t *)v37[1];
    if (v38)
    {
      *char v38 = *v37;
      if (*v37) {
        *(void *)(*v37 + 8) = v37[1];
      }
    }
    v37[3] = (uint64_t)v35;
    v37[1] = (uint64_t)v35;
    uint64_t v39 = *v35;
    uint64_t *v37 = *v35;
    if (v39) {
      *(void *)(v39 + 8) = v37;
    }
    *unint64_t v35 = (uint64_t)v37;
    unint64_t v40 = (void *)v163[9];
    uint64_t v41 = v40 + 4;
    uint64_t v42 = (void *)v40[5];
    if (v42)
    {
      void *v42 = *v41;
      if (*v41) {
        *(void *)(*v41 + 8) = v40[5];
      }
    }
    v40[7] = v36;
    v40[5] = v36;
    uint64_t v43 = *v36;
    v40[4] = *v36;
    if (v43) {
      *(void *)(v43 + 8) = v41;
    }
    uint64_t *v36 = (uint64_t)v41;
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v163 + 3));
    uint64_t v45 = mlir::mps::TensorDataLayoutAttr::get(Context, v22);
    mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr((uint64_t *)&v163, v45);
    char v46 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v163 + 3));
    uint64_t v47 = mlir::mps::TensorDataLayoutAttr::get(v46, v161);
    mlir::mps::Conv2DDataGradientOp::setStridesAttr((uint64_t *)&v163, v47);
    uint64_t Strides = mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v163);
    mlir::mps::DepthwiseConv2DDataGradientOp::setStridesAttr((uint64_t *)&v163, v49);
    uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v163);
    mlir::mps::Conv2DDataGradientOp::setDilationRatesAttr((uint64_t *)&v163, v51);
    uint64_t Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v163);
    mlir::mps::Conv2DDataGradientOp::setExplicitPaddingAttr((uint64_t *)&v163, v53);
    uint64_t v54 = (mlir::GenericProgramPoint *)v163;
    if (!v17)
    {
      unsigned int v59 = *v159;
      if (*v159 == *v160)
      {
        std::string::size_type v56 = (unsigned int *)&v173[8];
        __dst = &v173[8];
        unsigned int v57 = 5;
        *(_DWORD *)&v173[4] = 5;
        if (v59 > 3)
        {
          int v174 = 4;
          *(_OWORD *)&v173[8] = xmmword_18110B6C0;
        }
        else
        {
          *(_OWORD *)&v173[8] = xmmword_1810FFF10;
          unsigned int v57 = 4;
        }
        *(_DWORD *)v173 = v57;
      }
      else
      {
        switch(*v160)
        {
          case 1u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x100000003;
            long long v60 = xmmword_18110B6A0;
            goto LABEL_112;
          case 2u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x100000000;
            long long v60 = xmmword_18110B670;
            goto LABEL_112;
          case 3u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 1;
            long long v60 = xmmword_18110B680;
            goto LABEL_112;
          case 4u:
          case 5u:
          case 6u:
            goto LABEL_215;
          case 7u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 3;
            uint64_t v63 = &xmmword_18110B6E8;
            goto LABEL_116;
          case 8u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 1;
            uint64_t v63 = &xmmword_18110B6D4;
            goto LABEL_116;
          case 9u:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v62 = 2;
            uint64_t v63 = &xmmword_18110B710;
LABEL_116:
            int v174 = v62;
            long long v64 = *v63;
            goto LABEL_118;
          case 0xAu:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            int v174 = 0;
            long long v64 = xmmword_18110B6FC;
LABEL_118:
            *(_OWORD *)&v173[8] = v64;
            *(void *)v173 = 0x500000005;
            unsigned int v57 = 5;
            break;
          default:
            std::string::size_type v56 = (unsigned int *)&v173[8];
            __dst = &v173[8];
            *(void *)&v173[16] = 0x200000001;
            long long v60 = xmmword_18110B690;
LABEL_112:
            *(_OWORD *)v173 = v60;
            unsigned int v57 = 4;
            break;
        }
      }
      unsigned int v21 = v162;
      if (v161 == v162) {
        goto LABEL_103;
      }
      goto LABEL_120;
    }
    char v55 = v158;
    std::string::size_type v56 = (unsigned int *)&v173[8];
    __dst = &v173[8];
    *(void *)v173 = 0x500000000;
    if (v158 == &__dst)
    {
      unsigned int v57 = 0;
      if (v22 == v21)
      {
LABEL_103:
        v169 = &v170[8];
        unint64_t v61 = 5;
        *(_DWORD *)&v170[4] = 5;
        if (v21 > 3)
        {
          int v171 = 4;
          *(_OWORD *)&v170[8] = xmmword_18110B6C0;
        }
        else
        {
          *(_OWORD *)&v170[8] = xmmword_1810FFF10;
          unint64_t v61 = 4;
        }
        *(_DWORD *)long long v170 = v61;
        goto LABEL_132;
      }
LABEL_120:
      switch(v21)
      {
        case 1u:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x100000003;
          long long v65 = xmmword_18110B6A0;
          goto LABEL_126;
        case 2u:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x100000000;
          long long v65 = xmmword_18110B670;
          goto LABEL_126;
        case 3u:
          v169 = &v170[8];
          *(void *)&v170[16] = 1;
          long long v65 = xmmword_18110B680;
          goto LABEL_126;
        case 4u:
        case 5u:
        case 6u:
          goto LABEL_215;
        case 7u:
          v169 = &v170[8];
          int v67 = 3;
          uint64_t v68 = &xmmword_18110B6E8;
          goto LABEL_130;
        case 8u:
          v169 = &v170[8];
          int v67 = 1;
          uint64_t v68 = &xmmword_18110B6D4;
          goto LABEL_130;
        case 9u:
          v169 = &v170[8];
          int v67 = 2;
          uint64_t v68 = &xmmword_18110B710;
LABEL_130:
          int v171 = v67;
          long long v66 = *v68;
          goto LABEL_131;
        case 0xAu:
          v169 = &v170[8];
          int v171 = 0;
          long long v66 = xmmword_18110B6FC;
LABEL_131:
          *(_OWORD *)&v170[8] = v66;
          *(void *)long long v170 = 0x500000005;
          unint64_t v61 = 5;
          break;
        default:
          v169 = &v170[8];
          *(void *)&v170[16] = 0x200000001;
          long long v65 = xmmword_18110B690;
LABEL_126:
          *(_OWORD *)long long v170 = v65;
          unint64_t v61 = 4;
          break;
      }
LABEL_132:
      uint64_t v168 = v54;
      uint64_t v69 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v168);
      uint64_t v167 = (uint64_t **)v69;
      unint64_t v70 = (uint64_t *)(*(void *)(v69 + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v70) {
        goto LABEL_141;
      }
      uint64_t v71 = *v70;
      unint64_t v72 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v73 = *(unsigned int *)(v71 + 16);
      if (!v73) {
        goto LABEL_141;
      }
      unint64_t v74 = *(void **)(v71 + 8);
      uint64_t v75 = &v74[2 * v73];
      do
      {
        unint64_t v76 = v73 >> 1;
        uint64_t v77 = &v74[2 * (v73 >> 1)];
        unint64_t v79 = *v77;
        uint64_t v78 = v77 + 2;
        v73 += ~(v73 >> 1);
        if (v79 < v72) {
          unint64_t v74 = v78;
        }
        else {
          unint64_t v73 = v76;
        }
      }
      while (v73);
      if (v74 != v75 && *v74 == v72) {
        uint64_t v80 = v74[1];
      }
      else {
LABEL_141:
      }
        uint64_t v80 = 0;
      v166[0] = v70;
      v166[1] = v80;
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v166))
      {
LABEL_199:
        uint64_t v146 = *((void *)v168 + 2);
        mlir::GenericProgramPoint::~GenericProgramPoint(v168);
        uint64_t v148 = *(void *)(v147 + 8);
        *(void *)(a5 + 24) = v146;
        *(void *)(a5 + 32) = v148;
        if ((int32x4_t *)v69 != v181)
        {
          uint64_t DefiningOp = (mlir::GenericProgramPoint *)mlir::Value::getDefiningOp((mlir::Value *)&v181);
          if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v166))
          {
            v150 = (uint64_t *)v181;
          }
          else
          {
            uint64_t v151 = *((void *)DefiningOp + 2);
            mlir::GenericProgramPoint::~GenericProgramPoint(DefiningOp);
            uint64_t v153 = *(void *)(v152 + 8);
            *(void *)(a5 + 24) = v151;
            *(void *)(a5 + 32) = v153;
            uint64_t v154 = *((void *)v168 + 3);
            uint64_t ElementTypeOrSelf = 0;
            LOBYTE(v164) = 1;
            v178 = mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>((mlir::UnitAttr **)(a5 + 8), v154, (uint64_t *)&v181, (uint64_t)&ElementTypeOrSelf, (unsigned __int8 *)&v164);
            v150 = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v178);
          }
          mlir::Value::replaceAllUsesExcept(&v167, v150, (uint64_t)DefiningOp);
        }
        if (v169 != &v170[8]) {
          free(v169);
        }
        if (__dst != &v173[8]) {
          free(__dst);
        }
        if (v175 != &v176[8]) {
          free(v175);
        }
        return 1;
      }
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v166);
      v181 = (int32x4_t *)v183;
      uint64_t v182 = 0x500000000;
      uint64_t v82 = (mlir::GenericProgramPoint *)(int)v81;
      if ((unint64_t)(v81 << 32) >= 0x500000001) {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v181, v183, (int)v81, 8);
      }
      if (v57)
      {
        uint64_t v83 = 4 * v57;
        do
        {
          uint64_t v84 = *v56;
          uint64_t v85 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v166) + 8 * v84);
          uint64_t v86 = v182;
          if (v182 >= (unint64_t)HIDWORD(v182))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v181, v183, v182 + 1, 8);
            uint64_t v86 = v182;
          }
          v181->i64[v86] = v85;
          unsigned int v87 = v182 + 1;
          LODWORD(v182) = v182 + 1;
          ++v56;
          v83 -= 4;
        }
        while (v83);
      }
      else
      {
        unsigned int v87 = v182;
      }
      v178 = (mlir::GenericProgramPoint *)v166[0];
      *(void *)(v69 + 8) = *(void *)(v69 + 8) & 7 | mlir::TensorType::clone((uint64_t)&v178, (uint64_t)v181, v87);
      if ((v156 & 1) != 0 || (*((unsigned char *)v168 + 46) & 0x80) == 0 || *((_DWORD *)v168 + 17) != 3)
      {
LABEL_197:
        if (v181 != (int32x4_t *)v183) {
          free(v181);
        }
        goto LABEL_199;
      }
      uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(void *)(*((void *)v168 + 9) + 88));
      if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 32)
      {
        v178 = v82;
        uint64_t v109 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v168 + 24));
        uint64_t v110 = mlir::IntegerType::get(v109, 0x40u, 1u);
        unint64_t v111 = (void *)mlir::RankedTensorType::get((uint64_t)&v178, 1, v110, 0);
        unint64_t v112 = v111;
        if (!v111) {
          goto LABEL_178;
        }
        uint64_t v113 = *v111;
        unint64_t v114 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v115 = *(unsigned int *)(v113 + 16);
        if (!v115) {
          goto LABEL_178;
        }
        uint64_t v116 = *(void **)(v113 + 8);
        uint64_t v117 = &v116[2 * v115];
        do
        {
          unint64_t v118 = v115 >> 1;
          unint64_t v119 = &v116[2 * (v115 >> 1)];
          unint64_t v121 = *v119;
          long long v120 = v119 + 2;
          v115 += ~(v115 >> 1);
          if (v121 < v114) {
            uint64_t v116 = v120;
          }
          else {
            unint64_t v115 = v118;
          }
        }
        while (v115);
        if (v116 != v117 && *v116 == v114) {
          uint64_t v122 = v116[1];
        }
        else {
LABEL_178:
        }
          uint64_t v122 = 0;
        uint64_t v123 = *((void *)v168 + 3);
        v178 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v112, v122, v181, 8 * v182, 8, 1, 1);
        uint64_t v124 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 8), v123, (uint64_t **)&v178);
LABEL_191:
        uint64_t v141 = (uint64_t *)((char *)v124 - 16);
        unint64_t v142 = (void *)*((void *)v168 + 9);
        v143 = v142 + 8;
        v144 = (void *)v142[9];
        if (v144)
        {
          void *v144 = *v143;
          if (*v143) {
            *(void *)(*v143 + 8) = v142[9];
          }
        }
        v142[11] = v141;
        v142[9] = v141;
        uint64_t v145 = *v141;
        v142[8] = *v141;
        if (v145) {
          *(void *)(v145 + 8) = v143;
        }
        *uint64_t v141 = (uint64_t)v143;
        goto LABEL_197;
      }
      uint64_t v88 = v181;
      unint64_t v89 = v182;
      v178 = v82;
      uint64_t v90 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v168 + 24));
      uint64_t v91 = mlir::IntegerType::get(v90, 0x20u, 1u);
      uint64_t v92 = (void *)mlir::RankedTensorType::get((uint64_t)&v178, 1, v91, 0);
      uint64_t v93 = v92;
      if (!v92) {
        goto LABEL_165;
      }
      uint64_t v94 = *v92;
      unint64_t v95 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v96 = *(unsigned int *)(v94 + 16);
      if (!v96) {
        goto LABEL_165;
      }
      char v97 = *(void **)(v94 + 8);
      unint64_t v98 = &v97[2 * v96];
      do
      {
        unint64_t v99 = v96 >> 1;
        uint64_t v100 = &v97[2 * (v96 >> 1)];
        unint64_t v102 = *v100;
        uint64_t v101 = v100 + 2;
        v96 += ~(v96 >> 1);
        if (v102 < v95) {
          char v97 = v101;
        }
        else {
          unint64_t v96 = v99;
        }
      }
      while (v96);
      if (v97 != v98 && *v97 == v95) {
        uint64_t v103 = v97[1];
      }
      else {
LABEL_165:
      }
        uint64_t v103 = 0;
      uint64_t v104 = (mlir::OpBuilder *)(a5 + 8);
      uint64_t v105 = *((void *)v168 + 3);
      v178 = (mlir::GenericProgramPoint *)v180;
      uint64_t v179 = 0x500000000;
      uint64_t v155 = v105;
      if (v89 < 6)
      {
        if (!v89)
        {
          int v140 = 0;
          uint64_t v108 = (uint64_t *)v180;
          uint64_t v125 = v155;
LABEL_189:
          LODWORD(v179) = v140 + v89;
          v164 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v93, v103, v108, 4 * (v140 + v89), 4, 1, 1);
          uint64_t v124 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v104, v125, &v164);
          if (v178 != (mlir::GenericProgramPoint *)v180) {
            free(v178);
          }
          goto LABEL_191;
        }
        uint64_t v107 = 0;
        uint64_t v108 = (uint64_t *)v180;
      }
      else
      {
        uint64_t v106 = v103;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v178, v180, v89, 4);
        uint64_t v103 = v106;
        uint64_t v104 = (mlir::OpBuilder *)(a5 + 8);
        uint64_t v107 = v179;
        uint64_t v108 = (uint64_t *)v178;
      }
      uint64_t v125 = v155;
      unsigned int v126 = (int32x4_t *)((char *)v108 + 4 * v107);
      unint64_t v127 = (v89 - 1) & 0x1FFFFFFFFFFFFFFFLL;
      if (v127 >= 7)
      {
        unint64_t v130 = v127 + 1;
        uint64_t v131 = (v127 + 1) & 0x3FFFFFFFFFFFFFF8;
        uint64_t v128 = (int32x4_t *)((char *)v126 + 4 * v131);
        uint64_t v129 = &v88->i8[8 * v131];
        unint64_t v132 = v88 + 2;
        uint64_t v133 = v126 + 1;
        uint64_t v134 = v131;
        do
        {
          int32x4_t v136 = v132[-2];
          int32x4_t v135 = v132[-1];
          int32x4_t v138 = *v132;
          int32x4_t v137 = v132[1];
          v132 += 4;
          v133[-1] = vuzp1q_s32(v136, v135);
          int32x4_t *v133 = vuzp1q_s32(v138, v137);
          v133 += 2;
          v134 -= 8;
        }
        while (v134);
        if (v130 == v131) {
          goto LABEL_188;
        }
      }
      else
      {
        uint64_t v128 = v126;
        uint64_t v129 = (char *)v88;
      }
      do
      {
        uint64_t v139 = *(void *)v129;
        v129 += 8;
        v128->i32[0] = v139;
        uint64_t v128 = (int32x4_t *)((char *)v128 + 4);
      }
      while (v129 != (char *)v88 + 8 * v89);
LABEL_188:
      int v140 = v179;
      goto LABEL_189;
    }
    unsigned int v57 = *((_DWORD *)v158 + 2);
    if (!v57)
    {
LABEL_102:
      if (v22 == v21) {
        goto LABEL_103;
      }
      goto LABEL_120;
    }
    if (v57 < 6)
    {
      unsigned int v58 = *((_DWORD *)v158 + 2);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v173[8], *((unsigned int *)v158 + 2), 4);
      unsigned int v58 = *((_DWORD *)v55 + 2);
      if (!v58)
      {
LABEL_101:
        *(_DWORD *)v173 = v57;
        std::string::size_type v56 = (unsigned int *)__dst;
        goto LABEL_102;
      }
      std::string::size_type v56 = (unsigned int *)__dst;
    }
    memcpy(v56, *v55, 4 * v58);
    goto LABEL_101;
  }
LABEL_6:
  uint64_t result = 0;
  if (a4)
  {
    switch(PaddingStyle)
    {
      case 2:
      case 9:
        if (a4 == 2) {
          goto LABEL_9;
        }
        goto LABEL_41;
      case 3:
      case 10:
        if (a4 == 1) {
          goto LABEL_9;
        }
LABEL_41:
        uint64_t result = 0;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t mlir::mps::anonymous namespace'::ConvertConvolutionInterface<mlir::mps::DepthwiseConv2DWeightsGradientOp>::convertLayout(mlir::Operation *,mlir::mps::LayoutConversionType,mlir::mps::LayoutConversionType,mlir::RewriterBase &)const::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)a1;
  uint64_t v5 = *(void *)(**(void **)(a1 + 8) + 24);
  uint64_t v6 = *(uint64_t **)(a1 + 16);
  if (a3)
  {
    uint64_t v7 = *v6;
    uint64_t v8 = &v21[8];
    __dst = &v21[8];
    *(void *)unsigned int v21 = 0x500000000;
    unint64_t v9 = *(unsigned int *)(v7 + 8);
    if ((void **)v7 == &__dst || v9 == 0)
    {
      unint64_t v9 = 0;
      goto LABEL_31;
    }
    if (v9 < 6)
    {
      unsigned int v13 = *(_DWORD *)(v7 + 8);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v21[8], *(unsigned int *)(v7 + 8), 4);
      unsigned int v13 = *(_DWORD *)(v7 + 8);
      if (!v13)
      {
LABEL_20:
        *(_DWORD *)unsigned int v21 = v9;
        uint64_t v8 = __dst;
        goto LABEL_31;
      }
      uint64_t v8 = __dst;
    }
    memcpy(v8, *(const void **)v7, 4 * v13);
    goto LABEL_20;
  }
  char v11 = (_DWORD *)v6[2];
  unsigned int v12 = *(_DWORD *)v6[1];
  if (v12 == *v11)
  {
    uint64_t v8 = &v21[8];
    __dst = &v21[8];
    unint64_t v9 = 5;
    *(_DWORD *)&uint64_t v21[4] = 5;
    if (v12 > 3)
    {
      int v22 = 4;
      *(_OWORD *)&v21[8] = xmmword_18110B6C0;
    }
    else
    {
      *(_OWORD *)&v21[8] = xmmword_1810FFF10;
      unint64_t v9 = 4;
    }
    *(_DWORD *)unsigned int v21 = v9;
  }
  else
  {
    switch(*v11)
    {
      case 1:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x100000003;
        long long v14 = xmmword_18110B6A0;
        goto LABEL_25;
      case 2:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x100000000;
        long long v14 = xmmword_18110B670;
        goto LABEL_25;
      case 3:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 1;
        long long v14 = xmmword_18110B680;
        goto LABEL_25;
      case 4:
      case 5:
      case 6:
        __break(1u);
        JUMPOUT(0x180569DC0);
      case 7:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 3;
        BOOL v17 = &xmmword_18110B6E8;
        goto LABEL_29;
      case 8:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 1;
        BOOL v17 = &xmmword_18110B6D4;
        goto LABEL_29;
      case 9:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v16 = 2;
        BOOL v17 = &xmmword_18110B710;
LABEL_29:
        int v22 = v16;
        long long v15 = *v17;
        goto LABEL_30;
      case 0xA:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        int v22 = 0;
        long long v15 = xmmword_18110B6FC;
LABEL_30:
        *(_OWORD *)&v21[8] = v15;
        *(void *)unsigned int v21 = 0x500000005;
        unint64_t v9 = 5;
        break;
      default:
        uint64_t v8 = &v21[8];
        __dst = &v21[8];
        *(void *)&v21[16] = 0x200000001;
        long long v14 = xmmword_18110B690;
LABEL_25:
        *(_OWORD *)unsigned int v21 = v14;
        unint64_t v9 = 4;
        break;
    }
  }
LABEL_31:
  if (__dst != &v21[8]) {
    free(__dst);
  }
  return v18;
}

uint64_t mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConvertDepthwise3DConvolutionInterface<mlir::mps::DepthwiseConv3DOp>>::convertLayout(uint64_t a1, void *a2, int a3, uint64_t a4, mlir::UnitAttr **a5)
{
  uint64_t v221 = *MEMORY[0x1E4F143B8];
  v203 = a2;
  uint64_t v8 = (uint64_t *)(*(void *)(*(void *)(a2[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *v8;
  unint64_t v10 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v11 = *(unsigned int *)(v9 + 16);
  if (!v11) {
    goto LABEL_10;
  }
  unsigned int v12 = *(void **)(v9 + 8);
  unsigned int v13 = &v12[2 * v11];
  do
  {
    unint64_t v14 = v11 >> 1;
    long long v15 = &v12[2 * (v11 >> 1)];
    unint64_t v17 = *v15;
    int v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10) {
      unsigned int v12 = v16;
    }
    else {
      unint64_t v11 = v14;
    }
  }
  while (v11);
  if (v12 != v13 && *v12 == v10) {
    uint64_t v18 = v12[1];
  }
  else {
LABEL_10:
  }
    uint64_t v18 = 0;
  v202[0] = v8;
  v202[1] = v18;
  __int16 v19 = (uint64_t *)(*(void *)(*(void *)(a2[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *v19;
  unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v22 = *(unsigned int *)(v20 + 16);
  if (!v22) {
    goto LABEL_20;
  }
  uint64_t v23 = *(void **)(v20 + 8);
  int v24 = &v23[2 * v22];
  do
  {
    unint64_t v25 = v22 >> 1;
    BOOL v26 = &v23[2 * (v22 >> 1)];
    unint64_t v28 = *v26;
    int v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21) {
      uint64_t v23 = v27;
    }
    else {
      unint64_t v22 = v25;
    }
  }
  while (v22);
  if (v23 != v24 && *v23 == v21) {
    uint64_t v29 = v23[1];
  }
  else {
LABEL_20:
  }
    uint64_t v29 = 0;
  v201[0] = v19;
  v201[1] = v29;
  long long v30 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v203) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v30) {
    goto LABEL_30;
  }
  uint64_t v31 = *v30;
  unint64_t v32 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v33 = *(unsigned int *)(v31 + 16);
  if (!v33) {
    goto LABEL_30;
  }
  uint64_t v34 = *(void **)(v31 + 8);
  unint64_t v35 = &v34[2 * v33];
  do
  {
    unint64_t v36 = v33 >> 1;
    unint64_t v37 = &v34[2 * (v33 >> 1)];
    unint64_t v39 = *v37;
    char v38 = v37 + 2;
    v33 += ~(v33 >> 1);
    if (v39 < v32) {
      uint64_t v34 = v38;
    }
    else {
      unint64_t v33 = v36;
    }
  }
  while (v33);
  if (v34 != v35 && *v34 == v32) {
    uint64_t v40 = v34[1];
  }
  else {
LABEL_30:
  }
    uint64_t v40 = 0;
  v200[0] = v30;
  v200[1] = v40;
  uint64_t v41 = *(void **)(v203[6] + 16);
  BOOL v44 = v41 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
     || v41 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id
     || v41 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id
     || v41 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
  char v45 = v44;
  if (v44
    || (v41 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id
      ? (BOOL v46 = v41 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id)
      : (BOOL v46 = 1),
        !v46 ? (BOOL v47 = v41 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id) : (BOOL v47 = 1),
        !v47 ? (BOOL v48 = v41 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id) : (BOOL v48 = 1),
        v48))
  {
    unsigned int v199 = 0;
    uint64_t v49 = (mlir::CallableOpInterface *)v202;
    if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v202) & 1) == 0)
    {
      uint64_t v49 = (mlir::CallableOpInterface *)v200;
      int ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v200);
      uint64_t result = 0;
      if (!ArgOperands) {
        return result;
      }
    }
    int v50 = 0;
  }
  else
  {
    unsigned int v199 = 0;
    uint64_t v49 = (mlir::CallableOpInterface *)v202;
    if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v202) & 1) == 0)
    {
      uint64_t v49 = (mlir::CallableOpInterface *)v201;
      if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v201) & 1) == 0) {
        return 0;
      }
    }
    int v50 = 1;
  }
  mlir::CallableOpInterface::getArgAttrsAttr(v49);
  unsigned int v199 = v53;
  if (v53 == -1) {
    return 0;
  }
  int ChannelAxis = mlir::mps::DepthwiseConv3DDataGradientOp::getChannelAxis((mlir::mps::DepthwiseConv3DDataGradientOp *)&v203);
  int PositiveAxis = mlir::getPositiveAxis(ChannelAxis, (int)v199);
  uint64_t result = 0;
  unsigned int v56 = v199;
  int v197 = PositiveAxis - (v199 != 4);
  int v198 = PositiveAxis;
  if (!a3 || (v199 & 0xFFFFFFFE) != 4) {
    return result;
  }
  if (v199 == 4) {
    int v57 = PositiveAxis + 1;
  }
  else {
    int v57 = PositiveAxis;
  }
  if (a3 == 1) {
    int v58 = 1;
  }
  else {
    int v58 = 4;
  }
  if (v57 == v58) {
    return 0;
  }
  if (a3 == 1) {
    unsigned int v59 = v199 != 4;
  }
  else {
    unsigned int v59 = v199 - 1;
  }
  if (a3 == 1) {
    int v60 = 0;
  }
  else {
    int v60 = 3;
  }
  int v195 = v60;
  signed int v196 = v59;
  v190 = (signed int *)&v199;
  v191 = (unsigned int *)&v198;
  v192 = &v196;
  v193 = (unsigned int *)&v197;
  v194 = &v195;
  v189[0] = a5;
  v189[1] = &v203;
  v189[2] = &v190;
  uint64_t v61 = *(void *)(v203[9] + 24);
  uint64_t v62 = v203[3];
  v218 = (int32x4_t *)v220;
  HIDWORD(v219) = 5;
  bzero(v220, 4 * v199);
  int v63 = 0;
  int v64 = 0;
  LODWORD(v219) = v56;
  do
  {
    if (v64 == PositiveAxis) {
      ++v64;
    }
    if (v63 == v59) {
      ++v63;
    }
    v220[v63++] = v64++;
  }
  while (v64 != v56 && v63 != v56);
  v220[v59] = PositiveAxis;
  if (v218 != (int32x4_t *)v220) {
    free(v218);
  }
  uint64_t v68 = (uint64_t *)v203[9];
  uint64_t v69 = (uint64_t *)v68[1];
  if (v69)
  {
    *uint64_t v69 = *v68;
    if (*v68) {
      *(void *)(*v68 + 8) = v68[1];
    }
  }
  v68[3] = (uint64_t)v66;
  v68[1] = (uint64_t)v66;
  uint64_t v70 = *v66;
  *uint64_t v68 = *v66;
  if (v70) {
    *(void *)(v70 + 8) = v68;
  }
  *long long v66 = (uint64_t)v68;
  uint64_t v71 = (void *)v203[9];
  unint64_t v72 = v71 + 4;
  unint64_t v73 = (void *)v71[5];
  if (v73)
  {
    *unint64_t v73 = *v72;
    if (*v72) {
      *(void *)(*v72 + 8) = v71[5];
    }
  }
  v71[7] = v67;
  v71[5] = v67;
  uint64_t v74 = *v67;
  v71[4] = *v67;
  if (v74) {
    *(void *)(v74 + 8) = v72;
  }
  *int v67 = (uint64_t)v72;
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(v203 + 3));
  uint64_t v76 = mlir::IntegerType::get(Context, 0x20u, 1u);
  uint64_t v77 = mlir::IntegerAttr::get(v76, v196);
  mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr((uint64_t *)&v203, v77);
  uint64_t v78 = (mlir::GenericProgramPoint *)v203;
  unint64_t v79 = "extureUnitInfo";
  if (v50)
  {
    int v80 = 0;
    int v81 = 0;
    unsigned int v82 = *v193;
    int v83 = *v194;
    uint64_t v84 = (unsigned int *)v214;
    v212 = (unsigned int *)v214;
    v214[0] = 0;
    v214[1] = 0;
    uint64_t v213 = 0x500000004;
    do
    {
      if (v81 == v82) {
        ++v81;
      }
      if (v80 == v83) {
        ++v80;
      }
      *((_DWORD *)v214 + v80++) = v81++;
    }
    while (v81 != 4 && v80 != 4);
  }
  else
  {
    signed int v86 = *v190;
    unsigned int v82 = *v191;
    int v83 = *v192;
    uint64_t v84 = (unsigned int *)v214;
    v212 = (unsigned int *)v214;
    uint64_t v213 = 0x500000000;
    if (!v86)
    {
      *((_DWORD *)v214 + v83) = v82;
      uint64_t v88 = v213;
      goto LABEL_143;
    }
    if (v86 < 6)
    {
      uint64_t v87 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v212, v214, v86, 4);
      unint64_t v79 = "20ZinIrTextureUnitInfo" + 8;
      uint64_t v87 = v213;
      uint64_t v84 = v212;
    }
    if (v86 != v87)
    {
      bzero(&v84[v87], 4 * (v86 - v87));
      unint64_t v79 = "20ZinIrTextureUnitInfo" + 8;
    }
    int v89 = 0;
    unsigned int v90 = 0;
    LODWORD(v213) = v86;
    do
    {
      if (v90 == v82) {
        ++v90;
      }
      if (v89 == v83) {
        ++v89;
      }
      v84[v89++] = v90++;
    }
    while (v90 != v86 && v89 != v86);
  }
  v84[v83] = v82;
  uint64_t v88 = v213;
  if (v50)
  {
    int v92 = 0;
    int v93 = 0;
    int v94 = v195;
    int v95 = v197;
    unint64_t v96 = v211;
    v209 = v211;
    v211[0] = 0;
    v211[1] = 0;
    uint64_t v210 = 0x500000004;
    do
    {
      if (v93 == v94) {
        ++v93;
      }
      if (v92 == v95) {
        ++v92;
      }
      *((_DWORD *)v211 + v92++) = v93++;
    }
    while (v93 != 4 && v92 != 4);
    goto LABEL_159;
  }
LABEL_143:
  int v95 = v198;
  signed int v98 = v199;
  int v94 = v196;
  unint64_t v96 = v211;
  v209 = v211;
  uint64_t v210 = *((void *)v79 + 8);
  if (v199)
  {
    if (v199 < 6)
    {
      uint64_t v99 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v209, v211, (int)v199, 4);
      uint64_t v99 = v210;
      unint64_t v96 = v209;
    }
    if (v98 != v99) {
      bzero((char *)v96 + 4 * v99, 4 * (v98 - v99));
    }
    int v100 = 0;
    int v101 = 0;
    LODWORD(v210) = v98;
    do
    {
      if (v101 == v94) {
        ++v101;
      }
      if (v100 == v95) {
        ++v100;
      }
      *((_DWORD *)v96 + v100++) = v101++;
    }
    while (v101 != v98 && v100 != v98);
  }
LABEL_159:
  *((_DWORD *)v96 + v95) = v94;
  unint64_t v103 = v210;
  v208 = v78;
  uint64_t v104 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v208);
  v207 = (uint64_t **)v104;
  uint64_t v105 = (uint64_t *)(*(void *)(v104 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v105) {
    goto LABEL_168;
  }
  uint64_t v106 = *v105;
  unint64_t v107 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v108 = *(unsigned int *)(v106 + 16);
  if (!v108) {
    goto LABEL_168;
  }
  uint64_t v109 = *(void **)(v106 + 8);
  uint64_t v110 = &v109[2 * v108];
  do
  {
    unint64_t v111 = v108 >> 1;
    unint64_t v112 = &v109[2 * (v108 >> 1)];
    unint64_t v114 = *v112;
    uint64_t v113 = v112 + 2;
    v108 += ~(v108 >> 1);
    if (v114 < v107) {
      uint64_t v109 = v113;
    }
    else {
      unint64_t v108 = v111;
    }
  }
  while (v108);
  if (v109 != v110 && *v109 == v107) {
    uint64_t v115 = v109[1];
  }
  else {
LABEL_168:
  }
    uint64_t v115 = 0;
  v206[0] = v105;
  v206[1] = v115;
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v206))
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v206);
    v218 = (int32x4_t *)v220;
    uint64_t v219 = 0x500000000;
    uint64_t v117 = (mlir::GenericProgramPoint *)(int)v116;
    if ((unint64_t)(v116 << 32) >= 0x500000001) {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v218, v220, (int)v116, 8);
    }
    if (v88)
    {
      uint64_t v118 = 4 * v88;
      do
      {
        uint64_t v119 = *v84;
        uint64_t v120 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v206) + 8 * v119);
        uint64_t v121 = v219;
        if (v219 >= (unint64_t)HIDWORD(v219))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v218, v220, v219 + 1, 8);
          uint64_t v121 = v219;
        }
        v218->i64[v121] = v120;
        unsigned int v122 = v219 + 1;
        LODWORD(v219) = v219 + 1;
        ++v84;
        v118 -= 4;
      }
      while (v118);
    }
    else
    {
      unsigned int v122 = v219;
    }
    v215 = (mlir::GenericProgramPoint *)v206[0];
    *(void *)(v104 + 8) = *(void *)(v104 + 8) & 7 | mlir::TensorType::clone((uint64_t)&v215, (uint64_t)v218, v122);
    if ((v45 & 1) != 0 || (*((unsigned char *)v208 + 46) & 0x80) == 0 || *((_DWORD *)v208 + 17) != 3) {
      goto LABEL_224;
    }
    uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(void *)(*((void *)v208 + 9) + 88));
    if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 32)
    {
      v215 = v117;
      uint64_t v143 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v208 + 24));
      uint64_t v144 = mlir::IntegerType::get(v143, 0x40u, 1u);
      uint64_t v145 = (void *)mlir::RankedTensorType::get((uint64_t)&v215, 1, v144, 0);
      uint64_t v146 = v145;
      if (!v145) {
        goto LABEL_205;
      }
      uint64_t v147 = *v145;
      unint64_t v148 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v149 = *(unsigned int *)(v147 + 16);
      if (!v149) {
        goto LABEL_205;
      }
      v150 = *(void **)(v147 + 8);
      uint64_t v151 = &v150[2 * v149];
      do
      {
        unint64_t v152 = v149 >> 1;
        uint64_t v153 = &v150[2 * (v149 >> 1)];
        unint64_t v155 = *v153;
        uint64_t v154 = v153 + 2;
        v149 += ~(v149 >> 1);
        if (v155 < v148) {
          v150 = v154;
        }
        else {
          unint64_t v149 = v152;
        }
      }
      while (v149);
      if (v150 != v151 && *v150 == v148) {
        uint64_t v156 = v150[1];
      }
      else {
LABEL_205:
      }
        uint64_t v156 = 0;
      uint64_t v157 = *((void *)v208 + 3);
      v215 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v146, v156, v218, 8 * v219, 8, 1, 1);
      v158 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 1), v157, (uint64_t **)&v215);
LABEL_218:
      int v174 = (uint64_t *)((char *)v158 - 16);
      v175 = (void *)*((void *)v208 + 9);
      v176 = v175 + 8;
      int v177 = (void *)v175[9];
      if (v177)
      {
        *int v177 = *v176;
        if (*v176) {
          *(void *)(*v176 + 8) = v175[9];
        }
      }
      v175[11] = v174;
      v175[9] = v174;
      uint64_t v178 = *v174;
      v175[8] = *v174;
      if (v178) {
        *(void *)(v178 + 8) = v176;
      }
      *int v174 = (uint64_t)v176;
LABEL_224:
      if (v218 != (int32x4_t *)v220) {
        free(v218);
      }
      goto LABEL_226;
    }
    uint64_t v123 = v218;
    unint64_t v124 = v219;
    v215 = v117;
    uint64_t v125 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v208 + 24));
    uint64_t v126 = mlir::IntegerType::get(v125, 0x20u, 1u);
    unint64_t v127 = (void *)mlir::RankedTensorType::get((uint64_t)&v215, 1, v126, 0);
    uint64_t v128 = v127;
    if (!v127) {
      goto LABEL_192;
    }
    uint64_t v129 = *v127;
    unint64_t v130 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v131 = *(unsigned int *)(v129 + 16);
    if (!v131) {
      goto LABEL_192;
    }
    unint64_t v132 = *(void **)(v129 + 8);
    uint64_t v133 = &v132[2 * v131];
    do
    {
      unint64_t v134 = v131 >> 1;
      int32x4_t v135 = &v132[2 * (v131 >> 1)];
      unint64_t v137 = *v135;
      int32x4_t v136 = v135 + 2;
      v131 += ~(v131 >> 1);
      if (v137 < v130) {
        unint64_t v132 = v136;
      }
      else {
        unint64_t v131 = v134;
      }
    }
    while (v131);
    if (v132 != v133 && *v132 == v130) {
      uint64_t v138 = v132[1];
    }
    else {
LABEL_192:
    }
      uint64_t v138 = 0;
    uint64_t v139 = *((void *)v208 + 3);
    v215 = (mlir::GenericProgramPoint *)v217;
    uint64_t v216 = 0x500000000;
    uint64_t v188 = v139;
    if (v124 < 6)
    {
      if (!v124)
      {
        int v173 = 0;
        unint64_t v142 = (uint64_t *)v217;
LABEL_216:
        LODWORD(v216) = v173 + v124;
        v204 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v128, v138, v142, 4 * (v173 + v124), 4, 1, 1);
        v158 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 1), v188, &v204);
        if (v215 != (mlir::GenericProgramPoint *)v217) {
          free(v215);
        }
        goto LABEL_218;
      }
      uint64_t v141 = 0;
      unint64_t v142 = (uint64_t *)v217;
    }
    else
    {
      uint64_t v140 = v138;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v217, v124, 4);
      uint64_t v138 = v140;
      uint64_t v141 = v216;
      unint64_t v142 = (uint64_t *)v215;
    }
    v159 = (int32x4_t *)((char *)v142 + 4 * v141);
    unint64_t v160 = (v124 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v160 >= 7)
    {
      unint64_t v163 = v160 + 1;
      uint64_t v164 = (v160 + 1) & 0x3FFFFFFFFFFFFFF8;
      unsigned int v161 = (int32x4_t *)((char *)v159 + 4 * v164);
      unsigned int v162 = &v123->i8[8 * v164];
      v165 = v123 + 2;
      v166 = v159 + 1;
      uint64_t v167 = v164;
      do
      {
        int32x4_t v169 = v165[-2];
        int32x4_t v168 = v165[-1];
        int32x4_t v171 = *v165;
        int32x4_t v170 = v165[1];
        v165 += 4;
        v166[-1] = vuzp1q_s32(v169, v168);
        int32x4_t *v166 = vuzp1q_s32(v171, v170);
        v166 += 2;
        v167 -= 8;
      }
      while (v167);
      if (v163 == v164) {
        goto LABEL_215;
      }
    }
    else
    {
      unsigned int v161 = v159;
      unsigned int v162 = (char *)v123;
    }
    do
    {
      uint64_t v172 = *(void *)v162;
      v162 += 8;
      v161->i32[0] = v172;
      unsigned int v161 = (int32x4_t *)((char *)v161 + 4);
    }
    while (v162 != (char *)v123 + 8 * v124);
LABEL_215:
    int v173 = v216;
    goto LABEL_216;
  }
LABEL_226:
  uint64_t v179 = (mlir::UnitAttr *)*((void *)v208 + 2);
  mlir::GenericProgramPoint::~GenericProgramPoint(v208);
  v181 = *(mlir::UnitAttr **)(v180 + 8);
  a5[3] = v179;
  a5[4] = v181;
  if ((int32x4_t *)v104 != v218)
  {
    uint64_t DefiningOp = (mlir::GenericProgramPoint *)mlir::Value::getDefiningOp((mlir::Value *)&v218);
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v206))
    {
      v183 = (uint64_t *)v218;
    }
    else
    {
      v184 = (mlir::UnitAttr *)*((void *)DefiningOp + 2);
      mlir::GenericProgramPoint::~GenericProgramPoint(DefiningOp);
      v186 = *(mlir::UnitAttr **)(v185 + 8);
      a5[3] = v184;
      a5[4] = v186;
      uint64_t v187 = *((void *)v208 + 3);
      uint64_t ElementTypeOrSelf = 0;
      LOBYTE(v204) = 1;
      v215 = mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>(a5 + 1, v187, (uint64_t *)&v218, (uint64_t)&ElementTypeOrSelf, (unsigned __int8 *)&v204);
      v183 = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v215);
    }
    mlir::Value::replaceAllUsesExcept(&v207, v183, (uint64_t)DefiningOp);
  }
  if (v209 != v211) {
    free(v209);
  }
  if (v212 != (unsigned int *)v214) {
    free(v212);
  }
  return 1;
}

uint64_t mlir::mps::anonymous namespace'::ConvertDepthwise3DConvolutionInterface<mlir::mps::DepthwiseConv3DOp>::convertLayout(mlir::Operation *,mlir::mps::LayoutConversionType,mlir::mps::LayoutConversionType,mlir::RewriterBase &)const::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t a1, uint64_t a2, int a3)
{
  v23[3] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)a1;
  uint64_t v5 = *(void *)(**(void **)(a1 + 8) + 24);
  uint64_t v6 = *(signed int ***)(a1 + 16);
  if (a3)
  {
    signed int v7 = **v6;
    int v8 = *v6[1];
    int v9 = *v6[2];
    unint64_t v10 = v23;
    unint64_t v21 = v23;
    uint64_t v22 = 0x500000000;
    if (!v7) {
      goto LABEL_29;
    }
    if (v7 < 6)
    {
      uint64_t v11 = 0;
      unint64_t v12 = v7;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v21, v23, v7, 4);
      uint64_t v11 = v22;
      unint64_t v10 = v21;
      unint64_t v12 = v7 - (unint64_t)v22;
      if (v7 == (unint64_t)v22)
      {
LABEL_19:
        int v16 = 0;
        int v17 = 0;
        LODWORD(v22) = v7;
        do
        {
          if (v17 == v8) {
            ++v17;
          }
          if (v16 == v9) {
            ++v16;
          }
          *((_DWORD *)v10 + v16++) = v17++;
        }
        while (v17 != v7 && v16 != v7);
        goto LABEL_29;
      }
    }
    bzero((char *)v10 + 4 * v11, 4 * v12);
    goto LABEL_19;
  }
  int v13 = 0;
  int v14 = 0;
  int v8 = *v6[3];
  int v9 = *v6[4];
  unint64_t v10 = v23;
  unint64_t v21 = v23;
  v23[0] = 0;
  v23[1] = 0;
  uint64_t v22 = 0x500000004;
  do
  {
    if (v14 == v8) {
      ++v14;
    }
    if (v13 == v9) {
      ++v13;
    }
    *((_DWORD *)v23 + v13++) = v14++;
  }
  while (v14 != 4 && v13 != 4);
LABEL_29:
  *((_DWORD *)v10 + v9) = v8;
  if (v21 != v23) {
    free(v21);
  }
  return v19;
}

uint64_t mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConvertDepthwise3DConvolutionInterface<mlir::mps::DepthwiseConv3DDataGradientOp>>::convertLayout(uint64_t a1, void *a2, int a3, uint64_t a4, mlir::UnitAttr **a5)
{
  uint64_t v221 = *MEMORY[0x1E4F143B8];
  v203 = a2;
  int v8 = (uint64_t *)(*(void *)(*(void *)(a2[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *v8;
  unint64_t v10 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v11 = *(unsigned int *)(v9 + 16);
  if (!v11) {
    goto LABEL_10;
  }
  unint64_t v12 = *(void **)(v9 + 8);
  int v13 = &v12[2 * v11];
  do
  {
    unint64_t v14 = v11 >> 1;
    long long v15 = &v12[2 * (v11 >> 1)];
    unint64_t v17 = *v15;
    int v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10) {
      unint64_t v12 = v16;
    }
    else {
      unint64_t v11 = v14;
    }
  }
  while (v11);
  if (v12 != v13 && *v12 == v10) {
    uint64_t v18 = v12[1];
  }
  else {
LABEL_10:
  }
    uint64_t v18 = 0;
  v202[0] = v8;
  v202[1] = v18;
  uint64_t v19 = (uint64_t *)(*(void *)(*(void *)(a2[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *v19;
  unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v22 = *(unsigned int *)(v20 + 16);
  if (!v22) {
    goto LABEL_20;
  }
  uint64_t v23 = *(void **)(v20 + 8);
  int v24 = &v23[2 * v22];
  do
  {
    unint64_t v25 = v22 >> 1;
    BOOL v26 = &v23[2 * (v22 >> 1)];
    unint64_t v28 = *v26;
    int v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21) {
      uint64_t v23 = v27;
    }
    else {
      unint64_t v22 = v25;
    }
  }
  while (v22);
  if (v23 != v24 && *v23 == v21) {
    uint64_t v29 = v23[1];
  }
  else {
LABEL_20:
  }
    uint64_t v29 = 0;
  v201[0] = v19;
  v201[1] = v29;
  long long v30 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v203) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v30) {
    goto LABEL_30;
  }
  uint64_t v31 = *v30;
  unint64_t v32 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v33 = *(unsigned int *)(v31 + 16);
  if (!v33) {
    goto LABEL_30;
  }
  uint64_t v34 = *(void **)(v31 + 8);
  unint64_t v35 = &v34[2 * v33];
  do
  {
    unint64_t v36 = v33 >> 1;
    unint64_t v37 = &v34[2 * (v33 >> 1)];
    unint64_t v39 = *v37;
    char v38 = v37 + 2;
    v33 += ~(v33 >> 1);
    if (v39 < v32) {
      uint64_t v34 = v38;
    }
    else {
      unint64_t v33 = v36;
    }
  }
  while (v33);
  if (v34 != v35 && *v34 == v32) {
    uint64_t v40 = v34[1];
  }
  else {
LABEL_30:
  }
    uint64_t v40 = 0;
  v200[0] = v30;
  v200[1] = v40;
  uint64_t v41 = *(void **)(v203[6] + 16);
  BOOL v44 = v41 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
     || v41 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id
     || v41 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id
     || v41 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
  char v45 = v44;
  if (v44
    || (v41 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id
      ? (BOOL v46 = v41 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id)
      : (BOOL v46 = 1),
        !v46 ? (BOOL v47 = v41 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id) : (BOOL v47 = 1),
        !v47 ? (BOOL v48 = v41 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id) : (BOOL v48 = 1),
        v48))
  {
    unsigned int v199 = 0;
    uint64_t v49 = (mlir::CallableOpInterface *)v202;
    if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v202) & 1) == 0)
    {
      uint64_t v49 = (mlir::CallableOpInterface *)v200;
      int ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v200);
      uint64_t result = 0;
      if (!ArgOperands) {
        return result;
      }
    }
    int v50 = 0;
  }
  else
  {
    unsigned int v199 = 0;
    uint64_t v49 = (mlir::CallableOpInterface *)v202;
    if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v202) & 1) == 0)
    {
      uint64_t v49 = (mlir::CallableOpInterface *)v201;
      if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v201) & 1) == 0) {
        return 0;
      }
    }
    int v50 = 1;
  }
  mlir::CallableOpInterface::getArgAttrsAttr(v49);
  unsigned int v199 = v53;
  if (v53 == -1) {
    return 0;
  }
  int ChannelAxis = mlir::mps::DepthwiseConv3DDataGradientOp::getChannelAxis((mlir::mps::DepthwiseConv3DDataGradientOp *)&v203);
  int PositiveAxis = mlir::getPositiveAxis(ChannelAxis, (int)v199);
  uint64_t result = 0;
  unsigned int v56 = v199;
  int v197 = PositiveAxis - (v199 != 4);
  int v198 = PositiveAxis;
  if (!a3 || (v199 & 0xFFFFFFFE) != 4) {
    return result;
  }
  if (v199 == 4) {
    int v57 = PositiveAxis + 1;
  }
  else {
    int v57 = PositiveAxis;
  }
  if (a3 == 1) {
    int v58 = 1;
  }
  else {
    int v58 = 4;
  }
  if (v57 == v58) {
    return 0;
  }
  if (a3 == 1) {
    unsigned int v59 = v199 != 4;
  }
  else {
    unsigned int v59 = v199 - 1;
  }
  if (a3 == 1) {
    int v60 = 0;
  }
  else {
    int v60 = 3;
  }
  int v195 = v60;
  signed int v196 = v59;
  v190 = (signed int *)&v199;
  v191 = (unsigned int *)&v198;
  v192 = &v196;
  v193 = (unsigned int *)&v197;
  v194 = &v195;
  v189[0] = a5;
  v189[1] = &v203;
  v189[2] = &v190;
  uint64_t v61 = *(void *)(v203[9] + 24);
  uint64_t v62 = v203[3];
  v218 = (int32x4_t *)v220;
  HIDWORD(v219) = 5;
  bzero(v220, 4 * v199);
  int v63 = 0;
  int v64 = 0;
  LODWORD(v219) = v56;
  do
  {
    if (v64 == PositiveAxis) {
      ++v64;
    }
    if (v63 == v59) {
      ++v63;
    }
    v220[v63++] = v64++;
  }
  while (v64 != v56 && v63 != v56);
  v220[v59] = PositiveAxis;
  if (v218 != (int32x4_t *)v220) {
    free(v218);
  }
  uint64_t v68 = (uint64_t *)v203[9];
  uint64_t v69 = (uint64_t *)v68[1];
  if (v69)
  {
    *uint64_t v69 = *v68;
    if (*v68) {
      *(void *)(*v68 + 8) = v68[1];
    }
  }
  v68[3] = (uint64_t)v66;
  v68[1] = (uint64_t)v66;
  uint64_t v70 = *v66;
  *uint64_t v68 = *v66;
  if (v70) {
    *(void *)(v70 + 8) = v68;
  }
  *long long v66 = (uint64_t)v68;
  uint64_t v71 = (void *)v203[9];
  unint64_t v72 = v71 + 4;
  unint64_t v73 = (void *)v71[5];
  if (v73)
  {
    *unint64_t v73 = *v72;
    if (*v72) {
      *(void *)(*v72 + 8) = v71[5];
    }
  }
  v71[7] = v67;
  v71[5] = v67;
  uint64_t v74 = *v67;
  v71[4] = *v67;
  if (v74) {
    *(void *)(v74 + 8) = v72;
  }
  *int v67 = (uint64_t)v72;
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(v203 + 3));
  uint64_t v76 = mlir::IntegerType::get(Context, 0x20u, 1u);
  uint64_t v77 = mlir::IntegerAttr::get(v76, v196);
  mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr((uint64_t *)&v203, v77);
  uint64_t v78 = (mlir::GenericProgramPoint *)v203;
  unint64_t v79 = "extureUnitInfo";
  if (v50)
  {
    int v80 = 0;
    int v81 = 0;
    unsigned int v82 = *v193;
    int v83 = *v194;
    uint64_t v84 = (unsigned int *)v214;
    v212 = (unsigned int *)v214;
    v214[0] = 0;
    v214[1] = 0;
    uint64_t v213 = 0x500000004;
    do
    {
      if (v81 == v82) {
        ++v81;
      }
      if (v80 == v83) {
        ++v80;
      }
      *((_DWORD *)v214 + v80++) = v81++;
    }
    while (v81 != 4 && v80 != 4);
  }
  else
  {
    signed int v86 = *v190;
    unsigned int v82 = *v191;
    int v83 = *v192;
    uint64_t v84 = (unsigned int *)v214;
    v212 = (unsigned int *)v214;
    uint64_t v213 = 0x500000000;
    if (!v86)
    {
      *((_DWORD *)v214 + v83) = v82;
      uint64_t v88 = v213;
      goto LABEL_143;
    }
    if (v86 < 6)
    {
      uint64_t v87 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v212, v214, v86, 4);
      unint64_t v79 = "20ZinIrTextureUnitInfo" + 8;
      uint64_t v87 = v213;
      uint64_t v84 = v212;
    }
    if (v86 != v87)
    {
      bzero(&v84[v87], 4 * (v86 - v87));
      unint64_t v79 = "20ZinIrTextureUnitInfo" + 8;
    }
    int v89 = 0;
    unsigned int v90 = 0;
    LODWORD(v213) = v86;
    do
    {
      if (v90 == v82) {
        ++v90;
      }
      if (v89 == v83) {
        ++v89;
      }
      v84[v89++] = v90++;
    }
    while (v90 != v86 && v89 != v86);
  }
  v84[v83] = v82;
  uint64_t v88 = v213;
  if (v50)
  {
    int v92 = 0;
    int v93 = 0;
    int v94 = v195;
    int v95 = v197;
    unint64_t v96 = v211;
    v209 = v211;
    v211[0] = 0;
    v211[1] = 0;
    uint64_t v210 = 0x500000004;
    do
    {
      if (v93 == v94) {
        ++v93;
      }
      if (v92 == v95) {
        ++v92;
      }
      *((_DWORD *)v211 + v92++) = v93++;
    }
    while (v93 != 4 && v92 != 4);
    goto LABEL_159;
  }
LABEL_143:
  int v95 = v198;
  signed int v98 = v199;
  int v94 = v196;
  unint64_t v96 = v211;
  v209 = v211;
  uint64_t v210 = *((void *)v79 + 8);
  if (v199)
  {
    if (v199 < 6)
    {
      uint64_t v99 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v209, v211, (int)v199, 4);
      uint64_t v99 = v210;
      unint64_t v96 = v209;
    }
    if (v98 != v99) {
      bzero((char *)v96 + 4 * v99, 4 * (v98 - v99));
    }
    int v100 = 0;
    int v101 = 0;
    LODWORD(v210) = v98;
    do
    {
      if (v101 == v94) {
        ++v101;
      }
      if (v100 == v95) {
        ++v100;
      }
      *((_DWORD *)v96 + v100++) = v101++;
    }
    while (v101 != v98 && v100 != v98);
  }
LABEL_159:
  *((_DWORD *)v96 + v95) = v94;
  unint64_t v103 = v210;
  v208 = v78;
  uint64_t v104 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v208);
  v207 = (uint64_t **)v104;
  uint64_t v105 = (uint64_t *)(*(void *)(v104 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v105) {
    goto LABEL_168;
  }
  uint64_t v106 = *v105;
  unint64_t v107 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v108 = *(unsigned int *)(v106 + 16);
  if (!v108) {
    goto LABEL_168;
  }
  uint64_t v109 = *(void **)(v106 + 8);
  uint64_t v110 = &v109[2 * v108];
  do
  {
    unint64_t v111 = v108 >> 1;
    unint64_t v112 = &v109[2 * (v108 >> 1)];
    unint64_t v114 = *v112;
    uint64_t v113 = v112 + 2;
    v108 += ~(v108 >> 1);
    if (v114 < v107) {
      uint64_t v109 = v113;
    }
    else {
      unint64_t v108 = v111;
    }
  }
  while (v108);
  if (v109 != v110 && *v109 == v107) {
    uint64_t v115 = v109[1];
  }
  else {
LABEL_168:
  }
    uint64_t v115 = 0;
  v206[0] = v105;
  v206[1] = v115;
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v206))
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v206);
    v218 = (int32x4_t *)v220;
    uint64_t v219 = 0x500000000;
    uint64_t v117 = (mlir::GenericProgramPoint *)(int)v116;
    if ((unint64_t)(v116 << 32) >= 0x500000001) {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v218, v220, (int)v116, 8);
    }
    if (v88)
    {
      uint64_t v118 = 4 * v88;
      do
      {
        uint64_t v119 = *v84;
        uint64_t v120 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v206) + 8 * v119);
        uint64_t v121 = v219;
        if (v219 >= (unint64_t)HIDWORD(v219))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v218, v220, v219 + 1, 8);
          uint64_t v121 = v219;
        }
        v218->i64[v121] = v120;
        unsigned int v122 = v219 + 1;
        LODWORD(v219) = v219 + 1;
        ++v84;
        v118 -= 4;
      }
      while (v118);
    }
    else
    {
      unsigned int v122 = v219;
    }
    v215 = (mlir::GenericProgramPoint *)v206[0];
    *(void *)(v104 + 8) = *(void *)(v104 + 8) & 7 | mlir::TensorType::clone((uint64_t)&v215, (uint64_t)v218, v122);
    if ((v45 & 1) != 0 || (*((unsigned char *)v208 + 46) & 0x80) == 0 || *((_DWORD *)v208 + 17) != 3) {
      goto LABEL_224;
    }
    uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(void *)(*((void *)v208 + 9) + 88));
    if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 32)
    {
      v215 = v117;
      uint64_t v143 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v208 + 24));
      uint64_t v144 = mlir::IntegerType::get(v143, 0x40u, 1u);
      uint64_t v145 = (void *)mlir::RankedTensorType::get((uint64_t)&v215, 1, v144, 0);
      uint64_t v146 = v145;
      if (!v145) {
        goto LABEL_205;
      }
      uint64_t v147 = *v145;
      unint64_t v148 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v149 = *(unsigned int *)(v147 + 16);
      if (!v149) {
        goto LABEL_205;
      }
      v150 = *(void **)(v147 + 8);
      uint64_t v151 = &v150[2 * v149];
      do
      {
        unint64_t v152 = v149 >> 1;
        uint64_t v153 = &v150[2 * (v149 >> 1)];
        unint64_t v155 = *v153;
        uint64_t v154 = v153 + 2;
        v149 += ~(v149 >> 1);
        if (v155 < v148) {
          v150 = v154;
        }
        else {
          unint64_t v149 = v152;
        }
      }
      while (v149);
      if (v150 != v151 && *v150 == v148) {
        uint64_t v156 = v150[1];
      }
      else {
LABEL_205:
      }
        uint64_t v156 = 0;
      uint64_t v157 = *((void *)v208 + 3);
      v215 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v146, v156, v218, 8 * v219, 8, 1, 1);
      v158 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 1), v157, (uint64_t **)&v215);
LABEL_218:
      int v174 = (uint64_t *)((char *)v158 - 16);
      v175 = (void *)*((void *)v208 + 9);
      v176 = v175 + 8;
      int v177 = (void *)v175[9];
      if (v177)
      {
        *int v177 = *v176;
        if (*v176) {
          *(void *)(*v176 + 8) = v175[9];
        }
      }
      v175[11] = v174;
      v175[9] = v174;
      uint64_t v178 = *v174;
      v175[8] = *v174;
      if (v178) {
        *(void *)(v178 + 8) = v176;
      }
      *int v174 = (uint64_t)v176;
LABEL_224:
      if (v218 != (int32x4_t *)v220) {
        free(v218);
      }
      goto LABEL_226;
    }
    uint64_t v123 = v218;
    unint64_t v124 = v219;
    v215 = v117;
    uint64_t v125 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v208 + 24));
    uint64_t v126 = mlir::IntegerType::get(v125, 0x20u, 1u);
    unint64_t v127 = (void *)mlir::RankedTensorType::get((uint64_t)&v215, 1, v126, 0);
    uint64_t v128 = v127;
    if (!v127) {
      goto LABEL_192;
    }
    uint64_t v129 = *v127;
    unint64_t v130 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v131 = *(unsigned int *)(v129 + 16);
    if (!v131) {
      goto LABEL_192;
    }
    unint64_t v132 = *(void **)(v129 + 8);
    uint64_t v133 = &v132[2 * v131];
    do
    {
      unint64_t v134 = v131 >> 1;
      int32x4_t v135 = &v132[2 * (v131 >> 1)];
      unint64_t v137 = *v135;
      int32x4_t v136 = v135 + 2;
      v131 += ~(v131 >> 1);
      if (v137 < v130) {
        unint64_t v132 = v136;
      }
      else {
        unint64_t v131 = v134;
      }
    }
    while (v131);
    if (v132 != v133 && *v132 == v130) {
      uint64_t v138 = v132[1];
    }
    else {
LABEL_192:
    }
      uint64_t v138 = 0;
    uint64_t v139 = *((void *)v208 + 3);
    v215 = (mlir::GenericProgramPoint *)v217;
    uint64_t v216 = 0x500000000;
    uint64_t v188 = v139;
    if (v124 < 6)
    {
      if (!v124)
      {
        int v173 = 0;
        unint64_t v142 = (uint64_t *)v217;
LABEL_216:
        LODWORD(v216) = v173 + v124;
        v204 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v128, v138, v142, 4 * (v173 + v124), 4, 1, 1);
        v158 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 1), v188, &v204);
        if (v215 != (mlir::GenericProgramPoint *)v217) {
          free(v215);
        }
        goto LABEL_218;
      }
      uint64_t v141 = 0;
      unint64_t v142 = (uint64_t *)v217;
    }
    else
    {
      uint64_t v140 = v138;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v217, v124, 4);
      uint64_t v138 = v140;
      uint64_t v141 = v216;
      unint64_t v142 = (uint64_t *)v215;
    }
    v159 = (int32x4_t *)((char *)v142 + 4 * v141);
    unint64_t v160 = (v124 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v160 >= 7)
    {
      unint64_t v163 = v160 + 1;
      uint64_t v164 = (v160 + 1) & 0x3FFFFFFFFFFFFFF8;
      unsigned int v161 = (int32x4_t *)((char *)v159 + 4 * v164);
      unsigned int v162 = &v123->i8[8 * v164];
      v165 = v123 + 2;
      v166 = v159 + 1;
      uint64_t v167 = v164;
      do
      {
        int32x4_t v169 = v165[-2];
        int32x4_t v168 = v165[-1];
        int32x4_t v171 = *v165;
        int32x4_t v170 = v165[1];
        v165 += 4;
        v166[-1] = vuzp1q_s32(v169, v168);
        int32x4_t *v166 = vuzp1q_s32(v171, v170);
        v166 += 2;
        v167 -= 8;
      }
      while (v167);
      if (v163 == v164) {
        goto LABEL_215;
      }
    }
    else
    {
      unsigned int v161 = v159;
      unsigned int v162 = (char *)v123;
    }
    do
    {
      uint64_t v172 = *(void *)v162;
      v162 += 8;
      v161->i32[0] = v172;
      unsigned int v161 = (int32x4_t *)((char *)v161 + 4);
    }
    while (v162 != (char *)v123 + 8 * v124);
LABEL_215:
    int v173 = v216;
    goto LABEL_216;
  }
LABEL_226:
  uint64_t v179 = (mlir::UnitAttr *)*((void *)v208 + 2);
  mlir::GenericProgramPoint::~GenericProgramPoint(v208);
  v181 = *(mlir::UnitAttr **)(v180 + 8);
  a5[3] = v179;
  a5[4] = v181;
  if ((int32x4_t *)v104 != v218)
  {
    uint64_t DefiningOp = (mlir::GenericProgramPoint *)mlir::Value::getDefiningOp((mlir::Value *)&v218);
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v206))
    {
      v183 = (uint64_t *)v218;
    }
    else
    {
      v184 = (mlir::UnitAttr *)*((void *)DefiningOp + 2);
      mlir::GenericProgramPoint::~GenericProgramPoint(DefiningOp);
      v186 = *(mlir::UnitAttr **)(v185 + 8);
      a5[3] = v184;
      a5[4] = v186;
      uint64_t v187 = *((void *)v208 + 3);
      uint64_t ElementTypeOrSelf = 0;
      LOBYTE(v204) = 1;
      v215 = mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>(a5 + 1, v187, (uint64_t *)&v218, (uint64_t)&ElementTypeOrSelf, (unsigned __int8 *)&v204);
      v183 = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v215);
    }
    mlir::Value::replaceAllUsesExcept(&v207, v183, (uint64_t)DefiningOp);
  }
  if (v209 != v211) {
    free(v209);
  }
  if (v212 != (unsigned int *)v214) {
    free(v212);
  }
  return 1;
}

uint64_t mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConvertDepthwise3DConvolutionInterface<mlir::mps::DepthwiseConv3DWeightsGradientOp>>::convertLayout(uint64_t a1, void *a2, int a3, uint64_t a4, mlir::UnitAttr **a5)
{
  uint64_t v221 = *MEMORY[0x1E4F143B8];
  v203 = a2;
  int v8 = (uint64_t *)(*(void *)(*(void *)(a2[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *v8;
  unint64_t v10 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v11 = *(unsigned int *)(v9 + 16);
  if (!v11) {
    goto LABEL_10;
  }
  unint64_t v12 = *(void **)(v9 + 8);
  int v13 = &v12[2 * v11];
  do
  {
    unint64_t v14 = v11 >> 1;
    long long v15 = &v12[2 * (v11 >> 1)];
    unint64_t v17 = *v15;
    int v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10) {
      unint64_t v12 = v16;
    }
    else {
      unint64_t v11 = v14;
    }
  }
  while (v11);
  if (v12 != v13 && *v12 == v10) {
    uint64_t v18 = v12[1];
  }
  else {
LABEL_10:
  }
    uint64_t v18 = 0;
  v202[0] = v8;
  v202[1] = v18;
  uint64_t v19 = (uint64_t *)(*(void *)(*(void *)(a2[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *v19;
  unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v22 = *(unsigned int *)(v20 + 16);
  if (!v22) {
    goto LABEL_20;
  }
  uint64_t v23 = *(void **)(v20 + 8);
  int v24 = &v23[2 * v22];
  do
  {
    unint64_t v25 = v22 >> 1;
    BOOL v26 = &v23[2 * (v22 >> 1)];
    unint64_t v28 = *v26;
    int v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21) {
      uint64_t v23 = v27;
    }
    else {
      unint64_t v22 = v25;
    }
  }
  while (v22);
  if (v23 != v24 && *v23 == v21) {
    uint64_t v29 = v23[1];
  }
  else {
LABEL_20:
  }
    uint64_t v29 = 0;
  v201[0] = v19;
  v201[1] = v29;
  long long v30 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v203) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v30) {
    goto LABEL_30;
  }
  uint64_t v31 = *v30;
  unint64_t v32 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v33 = *(unsigned int *)(v31 + 16);
  if (!v33) {
    goto LABEL_30;
  }
  uint64_t v34 = *(void **)(v31 + 8);
  unint64_t v35 = &v34[2 * v33];
  do
  {
    unint64_t v36 = v33 >> 1;
    unint64_t v37 = &v34[2 * (v33 >> 1)];
    unint64_t v39 = *v37;
    char v38 = v37 + 2;
    v33 += ~(v33 >> 1);
    if (v39 < v32) {
      uint64_t v34 = v38;
    }
    else {
      unint64_t v33 = v36;
    }
  }
  while (v33);
  if (v34 != v35 && *v34 == v32) {
    uint64_t v40 = v34[1];
  }
  else {
LABEL_30:
  }
    uint64_t v40 = 0;
  v200[0] = v30;
  v200[1] = v40;
  uint64_t v41 = *(void **)(v203[6] + 16);
  BOOL v44 = v41 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
     || v41 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id
     || v41 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id
     || v41 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
  char v45 = v44;
  if (v44
    || (v41 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id
      ? (BOOL v46 = v41 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id)
      : (BOOL v46 = 1),
        !v46 ? (BOOL v47 = v41 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id) : (BOOL v47 = 1),
        !v47 ? (BOOL v48 = v41 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id) : (BOOL v48 = 1),
        v48))
  {
    unsigned int v199 = 0;
    uint64_t v49 = (mlir::CallableOpInterface *)v202;
    if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v202) & 1) == 0)
    {
      uint64_t v49 = (mlir::CallableOpInterface *)v200;
      int ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v200);
      uint64_t result = 0;
      if (!ArgOperands) {
        return result;
      }
    }
    int v50 = 0;
  }
  else
  {
    unsigned int v199 = 0;
    uint64_t v49 = (mlir::CallableOpInterface *)v202;
    if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v202) & 1) == 0)
    {
      uint64_t v49 = (mlir::CallableOpInterface *)v201;
      if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v201) & 1) == 0) {
        return 0;
      }
    }
    int v50 = 1;
  }
  mlir::CallableOpInterface::getArgAttrsAttr(v49);
  unsigned int v199 = v53;
  if (v53 == -1) {
    return 0;
  }
  int ChannelAxis = mlir::mps::DepthwiseConv3DDataGradientOp::getChannelAxis((mlir::mps::DepthwiseConv3DDataGradientOp *)&v203);
  int PositiveAxis = mlir::getPositiveAxis(ChannelAxis, (int)v199);
  uint64_t result = 0;
  unsigned int v56 = v199;
  int v197 = PositiveAxis - (v199 != 4);
  int v198 = PositiveAxis;
  if (!a3 || (v199 & 0xFFFFFFFE) != 4) {
    return result;
  }
  if (v199 == 4) {
    int v57 = PositiveAxis + 1;
  }
  else {
    int v57 = PositiveAxis;
  }
  if (a3 == 1) {
    int v58 = 1;
  }
  else {
    int v58 = 4;
  }
  if (v57 == v58) {
    return 0;
  }
  if (a3 == 1) {
    unsigned int v59 = v199 != 4;
  }
  else {
    unsigned int v59 = v199 - 1;
  }
  if (a3 == 1) {
    int v60 = 0;
  }
  else {
    int v60 = 3;
  }
  int v195 = v60;
  signed int v196 = v59;
  v190 = (signed int *)&v199;
  v191 = (unsigned int *)&v198;
  v192 = &v196;
  v193 = (unsigned int *)&v197;
  v194 = &v195;
  v189[0] = a5;
  v189[1] = &v203;
  v189[2] = &v190;
  uint64_t v61 = *(void *)(v203[9] + 24);
  uint64_t v62 = v203[3];
  v218 = (int32x4_t *)v220;
  HIDWORD(v219) = 5;
  bzero(v220, 4 * v199);
  int v63 = 0;
  int v64 = 0;
  LODWORD(v219) = v56;
  do
  {
    if (v64 == PositiveAxis) {
      ++v64;
    }
    if (v63 == v59) {
      ++v63;
    }
    v220[v63++] = v64++;
  }
  while (v64 != v56 && v63 != v56);
  v220[v59] = PositiveAxis;
  if (v218 != (int32x4_t *)v220) {
    free(v218);
  }
  uint64_t v68 = (uint64_t *)v203[9];
  uint64_t v69 = (uint64_t *)v68[1];
  if (v69)
  {
    *uint64_t v69 = *v68;
    if (*v68) {
      *(void *)(*v68 + 8) = v68[1];
    }
  }
  v68[3] = (uint64_t)v66;
  v68[1] = (uint64_t)v66;
  uint64_t v70 = *v66;
  *uint64_t v68 = *v66;
  if (v70) {
    *(void *)(v70 + 8) = v68;
  }
  *long long v66 = (uint64_t)v68;
  uint64_t v71 = (void *)v203[9];
  unint64_t v72 = v71 + 4;
  unint64_t v73 = (void *)v71[5];
  if (v73)
  {
    *unint64_t v73 = *v72;
    if (*v72) {
      *(void *)(*v72 + 8) = v71[5];
    }
  }
  v71[7] = v67;
  v71[5] = v67;
  uint64_t v74 = *v67;
  v71[4] = *v67;
  if (v74) {
    *(void *)(v74 + 8) = v72;
  }
  *int v67 = (uint64_t)v72;
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(v203 + 3));
  uint64_t v76 = mlir::IntegerType::get(Context, 0x20u, 1u);
  uint64_t v77 = mlir::IntegerAttr::get(v76, v196);
  mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr((uint64_t *)&v203, v77);
  uint64_t v78 = (mlir::GenericProgramPoint *)v203;
  unint64_t v79 = "extureUnitInfo";
  if (v50)
  {
    int v80 = 0;
    int v81 = 0;
    unsigned int v82 = *v193;
    int v83 = *v194;
    uint64_t v84 = (unsigned int *)v214;
    v212 = (unsigned int *)v214;
    v214[0] = 0;
    v214[1] = 0;
    uint64_t v213 = 0x500000004;
    do
    {
      if (v81 == v82) {
        ++v81;
      }
      if (v80 == v83) {
        ++v80;
      }
      *((_DWORD *)v214 + v80++) = v81++;
    }
    while (v81 != 4 && v80 != 4);
  }
  else
  {
    signed int v86 = *v190;
    unsigned int v82 = *v191;
    int v83 = *v192;
    uint64_t v84 = (unsigned int *)v214;
    v212 = (unsigned int *)v214;
    uint64_t v213 = 0x500000000;
    if (!v86)
    {
      *((_DWORD *)v214 + v83) = v82;
      uint64_t v88 = v213;
      goto LABEL_143;
    }
    if (v86 < 6)
    {
      uint64_t v87 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v212, v214, v86, 4);
      unint64_t v79 = "20ZinIrTextureUnitInfo" + 8;
      uint64_t v87 = v213;
      uint64_t v84 = v212;
    }
    if (v86 != v87)
    {
      bzero(&v84[v87], 4 * (v86 - v87));
      unint64_t v79 = "20ZinIrTextureUnitInfo" + 8;
    }
    int v89 = 0;
    unsigned int v90 = 0;
    LODWORD(v213) = v86;
    do
    {
      if (v90 == v82) {
        ++v90;
      }
      if (v89 == v83) {
        ++v89;
      }
      v84[v89++] = v90++;
    }
    while (v90 != v86 && v89 != v86);
  }
  v84[v83] = v82;
  uint64_t v88 = v213;
  if (v50)
  {
    int v92 = 0;
    int v93 = 0;
    int v94 = v195;
    int v95 = v197;
    unint64_t v96 = v211;
    v209 = v211;
    v211[0] = 0;
    v211[1] = 0;
    uint64_t v210 = 0x500000004;
    do
    {
      if (v93 == v94) {
        ++v93;
      }
      if (v92 == v95) {
        ++v92;
      }
      *((_DWORD *)v211 + v92++) = v93++;
    }
    while (v93 != 4 && v92 != 4);
    goto LABEL_159;
  }
LABEL_143:
  int v95 = v198;
  signed int v98 = v199;
  int v94 = v196;
  unint64_t v96 = v211;
  v209 = v211;
  uint64_t v210 = *((void *)v79 + 8);
  if (v199)
  {
    if (v199 < 6)
    {
      uint64_t v99 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v209, v211, (int)v199, 4);
      uint64_t v99 = v210;
      unint64_t v96 = v209;
    }
    if (v98 != v99) {
      bzero((char *)v96 + 4 * v99, 4 * (v98 - v99));
    }
    int v100 = 0;
    int v101 = 0;
    LODWORD(v210) = v98;
    do
    {
      if (v101 == v94) {
        ++v101;
      }
      if (v100 == v95) {
        ++v100;
      }
      *((_DWORD *)v96 + v100++) = v101++;
    }
    while (v101 != v98 && v100 != v98);
  }
LABEL_159:
  *((_DWORD *)v96 + v95) = v94;
  unint64_t v103 = v210;
  v208 = v78;
  uint64_t v104 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v208);
  v207 = (uint64_t **)v104;
  uint64_t v105 = (uint64_t *)(*(void *)(v104 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v105) {
    goto LABEL_168;
  }
  uint64_t v106 = *v105;
  unint64_t v107 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v108 = *(unsigned int *)(v106 + 16);
  if (!v108) {
    goto LABEL_168;
  }
  uint64_t v109 = *(void **)(v106 + 8);
  uint64_t v110 = &v109[2 * v108];
  do
  {
    unint64_t v111 = v108 >> 1;
    unint64_t v112 = &v109[2 * (v108 >> 1)];
    unint64_t v114 = *v112;
    uint64_t v113 = v112 + 2;
    v108 += ~(v108 >> 1);
    if (v114 < v107) {
      uint64_t v109 = v113;
    }
    else {
      unint64_t v108 = v111;
    }
  }
  while (v108);
  if (v109 != v110 && *v109 == v107) {
    uint64_t v115 = v109[1];
  }
  else {
LABEL_168:
  }
    uint64_t v115 = 0;
  v206[0] = v105;
  v206[1] = v115;
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v206))
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v206);
    v218 = (int32x4_t *)v220;
    uint64_t v219 = 0x500000000;
    uint64_t v117 = (mlir::GenericProgramPoint *)(int)v116;
    if ((unint64_t)(v116 << 32) >= 0x500000001) {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v218, v220, (int)v116, 8);
    }
    if (v88)
    {
      uint64_t v118 = 4 * v88;
      do
      {
        uint64_t v119 = *v84;
        uint64_t v120 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v206) + 8 * v119);
        uint64_t v121 = v219;
        if (v219 >= (unint64_t)HIDWORD(v219))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v218, v220, v219 + 1, 8);
          uint64_t v121 = v219;
        }
        v218->i64[v121] = v120;
        unsigned int v122 = v219 + 1;
        LODWORD(v219) = v219 + 1;
        ++v84;
        v118 -= 4;
      }
      while (v118);
    }
    else
    {
      unsigned int v122 = v219;
    }
    v215 = (mlir::GenericProgramPoint *)v206[0];
    *(void *)(v104 + 8) = *(void *)(v104 + 8) & 7 | mlir::TensorType::clone((uint64_t)&v215, (uint64_t)v218, v122);
    if ((v45 & 1) != 0 || (*((unsigned char *)v208 + 46) & 0x80) == 0 || *((_DWORD *)v208 + 17) != 3) {
      goto LABEL_224;
    }
    uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(void *)(*((void *)v208 + 9) + 88));
    if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 32)
    {
      v215 = v117;
      uint64_t v143 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v208 + 24));
      uint64_t v144 = mlir::IntegerType::get(v143, 0x40u, 1u);
      uint64_t v145 = (void *)mlir::RankedTensorType::get((uint64_t)&v215, 1, v144, 0);
      uint64_t v146 = v145;
      if (!v145) {
        goto LABEL_205;
      }
      uint64_t v147 = *v145;
      unint64_t v148 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v149 = *(unsigned int *)(v147 + 16);
      if (!v149) {
        goto LABEL_205;
      }
      v150 = *(void **)(v147 + 8);
      uint64_t v151 = &v150[2 * v149];
      do
      {
        unint64_t v152 = v149 >> 1;
        uint64_t v153 = &v150[2 * (v149 >> 1)];
        unint64_t v155 = *v153;
        uint64_t v154 = v153 + 2;
        v149 += ~(v149 >> 1);
        if (v155 < v148) {
          v150 = v154;
        }
        else {
          unint64_t v149 = v152;
        }
      }
      while (v149);
      if (v150 != v151 && *v150 == v148) {
        uint64_t v156 = v150[1];
      }
      else {
LABEL_205:
      }
        uint64_t v156 = 0;
      uint64_t v157 = *((void *)v208 + 3);
      v215 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v146, v156, v218, 8 * v219, 8, 1, 1);
      v158 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 1), v157, (uint64_t **)&v215);
LABEL_218:
      int v174 = (uint64_t *)((char *)v158 - 16);
      v175 = (void *)*((void *)v208 + 9);
      v176 = v175 + 8;
      int v177 = (void *)v175[9];
      if (v177)
      {
        *int v177 = *v176;
        if (*v176) {
          *(void *)(*v176 + 8) = v175[9];
        }
      }
      v175[11] = v174;
      v175[9] = v174;
      uint64_t v178 = *v174;
      v175[8] = *v174;
      if (v178) {
        *(void *)(v178 + 8) = v176;
      }
      *int v174 = (uint64_t)v176;
LABEL_224:
      if (v218 != (int32x4_t *)v220) {
        free(v218);
      }
      goto LABEL_226;
    }
    uint64_t v123 = v218;
    unint64_t v124 = v219;
    v215 = v117;
    uint64_t v125 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v208 + 24));
    uint64_t v126 = mlir::IntegerType::get(v125, 0x20u, 1u);
    unint64_t v127 = (void *)mlir::RankedTensorType::get((uint64_t)&v215, 1, v126, 0);
    uint64_t v128 = v127;
    if (!v127) {
      goto LABEL_192;
    }
    uint64_t v129 = *v127;
    unint64_t v130 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v131 = *(unsigned int *)(v129 + 16);
    if (!v131) {
      goto LABEL_192;
    }
    unint64_t v132 = *(void **)(v129 + 8);
    uint64_t v133 = &v132[2 * v131];
    do
    {
      unint64_t v134 = v131 >> 1;
      int32x4_t v135 = &v132[2 * (v131 >> 1)];
      unint64_t v137 = *v135;
      int32x4_t v136 = v135 + 2;
      v131 += ~(v131 >> 1);
      if (v137 < v130) {
        unint64_t v132 = v136;
      }
      else {
        unint64_t v131 = v134;
      }
    }
    while (v131);
    if (v132 != v133 && *v132 == v130) {
      uint64_t v138 = v132[1];
    }
    else {
LABEL_192:
    }
      uint64_t v138 = 0;
    uint64_t v139 = *((void *)v208 + 3);
    v215 = (mlir::GenericProgramPoint *)v217;
    uint64_t v216 = 0x500000000;
    uint64_t v188 = v139;
    if (v124 < 6)
    {
      if (!v124)
      {
        int v173 = 0;
        unint64_t v142 = (uint64_t *)v217;
LABEL_216:
        LODWORD(v216) = v173 + v124;
        v204 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v128, v138, v142, 4 * (v173 + v124), 4, 1, 1);
        v158 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 1), v188, &v204);
        if (v215 != (mlir::GenericProgramPoint *)v217) {
          free(v215);
        }
        goto LABEL_218;
      }
      uint64_t v141 = 0;
      unint64_t v142 = (uint64_t *)v217;
    }
    else
    {
      uint64_t v140 = v138;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v217, v124, 4);
      uint64_t v138 = v140;
      uint64_t v141 = v216;
      unint64_t v142 = (uint64_t *)v215;
    }
    v159 = (int32x4_t *)((char *)v142 + 4 * v141);
    unint64_t v160 = (v124 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v160 >= 7)
    {
      unint64_t v163 = v160 + 1;
      uint64_t v164 = (v160 + 1) & 0x3FFFFFFFFFFFFFF8;
      unsigned int v161 = (int32x4_t *)((char *)v159 + 4 * v164);
      unsigned int v162 = &v123->i8[8 * v164];
      v165 = v123 + 2;
      v166 = v159 + 1;
      uint64_t v167 = v164;
      do
      {
        int32x4_t v169 = v165[-2];
        int32x4_t v168 = v165[-1];
        int32x4_t v171 = *v165;
        int32x4_t v170 = v165[1];
        v165 += 4;
        v166[-1] = vuzp1q_s32(v169, v168);
        int32x4_t *v166 = vuzp1q_s32(v171, v170);
        v166 += 2;
        v167 -= 8;
      }
      while (v167);
      if (v163 == v164) {
        goto LABEL_215;
      }
    }
    else
    {
      unsigned int v161 = v159;
      unsigned int v162 = (char *)v123;
    }
    do
    {
      uint64_t v172 = *(void *)v162;
      v162 += 8;
      v161->i32[0] = v172;
      unsigned int v161 = (int32x4_t *)((char *)v161 + 4);
    }
    while (v162 != (char *)v123 + 8 * v124);
LABEL_215:
    int v173 = v216;
    goto LABEL_216;
  }
LABEL_226:
  uint64_t v179 = (mlir::UnitAttr *)*((void *)v208 + 2);
  mlir::GenericProgramPoint::~GenericProgramPoint(v208);
  v181 = *(mlir::UnitAttr **)(v180 + 8);
  a5[3] = v179;
  a5[4] = v181;
  if ((int32x4_t *)v104 != v218)
  {
    uint64_t DefiningOp = (mlir::GenericProgramPoint *)mlir::Value::getDefiningOp((mlir::Value *)&v218);
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v206))
    {
      v183 = (uint64_t *)v218;
    }
    else
    {
      v184 = (mlir::UnitAttr *)*((void *)DefiningOp + 2);
      mlir::GenericProgramPoint::~GenericProgramPoint(DefiningOp);
      v186 = *(mlir::UnitAttr **)(v185 + 8);
      a5[3] = v184;
      a5[4] = v186;
      uint64_t v187 = *((void *)v208 + 3);
      uint64_t ElementTypeOrSelf = 0;
      LOBYTE(v204) = 1;
      v215 = mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>(a5 + 1, v187, (uint64_t *)&v218, (uint64_t)&ElementTypeOrSelf, (unsigned __int8 *)&v204);
      v183 = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v215);
    }
    mlir::Value::replaceAllUsesExcept(&v207, v183, (uint64_t)DefiningOp);
  }
  if (v209 != v211) {
    free(v209);
  }
  if (v212 != (unsigned int *)v214) {
    free(v212);
  }
  return 1;
}

mlir::GenericProgramPoint *mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConvertPoolingInterface<mlir::mps::PoolAvgOp>>::convertLayout(uint64_t a1, uint64_t a2, int a3, uint64_t a4, mlir::UnitAttr **a5, uint64_t a6, uint64_t a7, uint64_t a8, char *a9, char *a10)
{
  v108[5] = *MEMORY[0x1E4F143B8];
  uint64_t v91 = a2;
  uint64_t v93 = a2;
  __dst = (void *)mlir::mps::PoolAvgGradientOp::getWindowSizes((mlir::mps::PoolAvgGradientOp *)&v93);
  long long v15 = "extureUnitInfo";
  if (mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)&__dst, 8, 1, 0))
  {
    uint64_t RawStringData = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&__dst);
    char isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&__dst);
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&__dst);
    unint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&__dst);
    unint64_t v11 = NumElements;
    uint64_t v106 = v108;
    uint64_t v107 = 0x500000000;
    if (NumElements < 6)
    {
      int v18 = 0;
      if (!NumElements) {
        goto LABEL_12;
      }
      uint64_t v19 = v108;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v108, NumElements, 8);
      int v18 = v107;
      uint64_t v19 = v106;
    }
  }
  else
  {
    int v18 = 0;
    uint64_t RawStringData = 0;
    uint64_t v19 = v108;
    uint64_t v106 = v108;
    uint64_t v107 = 0x500000000;
  }
  uint64_t v20 = 0;
  unint64_t v21 = &v19[v18];
  do
  {
    if (isSplat) {
      uint64_t v22 = 0;
    }
    else {
      uint64_t v22 = v20;
    }
    v21[v20++] = *(void *)(RawStringData + 8 * v22);
  }
  while (v11 != v20);
LABEL_12:
  LODWORD(v107) = v18 + v11;
  __dst = (void *)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v93);
  if (mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)&__dst, 8, 1, 0))
  {
    uint64_t v23 = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&__dst);
    char isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&__dst);
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&__dst);
    unint64_t v24 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&__dst);
    unint64_t v12 = v24;
    unint64_t v103 = v105;
    uint64_t v104 = 0x500000000;
    if (v24 < 6)
    {
      int v25 = 0;
      if (!v24) {
        goto LABEL_23;
      }
      BOOL v26 = v105;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v105, v24, 8);
      int v25 = v104;
      BOOL v26 = v103;
    }
  }
  else
  {
    int v25 = 0;
    uint64_t v23 = 0;
    BOOL v26 = v105;
    unint64_t v103 = v105;
    uint64_t v104 = 0x500000000;
  }
  uint64_t v27 = 0;
  unint64_t v28 = &v26[8 * v25];
  do
  {
    if (isSplat) {
      uint64_t v29 = 0;
    }
    else {
      uint64_t v29 = v27;
    }
    *(void *)&v28[8 * v27++] = *(void *)(v23 + 8 * v29);
  }
  while (v12 != v27);
LABEL_23:
  LODWORD(v104) = v25 + v12;
  __dst = (void *)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v93);
  if (mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)&__dst, 8, 1, 0))
  {
    uint64_t v30 = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&__dst);
    char isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&__dst);
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&__dst);
    unint64_t v31 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&__dst);
    unint64_t v13 = v31;
    int v100 = v102;
    uint64_t v101 = 0x500000000;
    if (v31 < 6)
    {
      int v32 = 0;
      if (!v31) {
        goto LABEL_34;
      }
      unint64_t v33 = v102;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v102, v31, 8);
      int v32 = v101;
      unint64_t v33 = v100;
    }
  }
  else
  {
    int v32 = 0;
    uint64_t v30 = 0;
    unint64_t v33 = v102;
    int v100 = v102;
    uint64_t v101 = 0x500000000;
  }
  uint64_t v34 = 0;
  unint64_t v35 = &v33[8 * v32];
  do
  {
    if (isSplat) {
      uint64_t v36 = 0;
    }
    else {
      uint64_t v36 = v34;
    }
    *(void *)&v35[8 * v34++] = *(void *)(v30 + 8 * v36);
  }
  while (v13 != v34);
LABEL_34:
  LODWORD(v101) = v32 + v13;
  __dst = &v98[8];
  *(void *)signed int v98 = 0xA00000000;
  mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v93);
  if (v37)
  {
    v92[0] = mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v93);
    v92[1] = v38;
    if (!(_BYTE)v38) {
      goto LABEL_154;
    }
    int v39 = a3;
    if (mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)v92, 8, 1, 0))
    {
      uint64_t v40 = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)v92);
      char isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)v92);
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v92);
      unint64_t v41 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v92);
      long long v15 = (char *)v41;
      uint64_t v42 = &v95[8];
      __src = &v95[8];
      *(void *)int v95 = 0xA00000000;
      if (v41 < 0xB)
      {
        unsigned int v43 = 0;
        LODWORD(v45) = 0;
        BOOL v44 = &v95[8];
        if (!v41) {
          goto LABEL_56;
        }
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, &v95[8], v41, 8);
        unsigned int v43 = *(_DWORD *)v95;
        BOOL v44 = __src;
      }
    }
    else
    {
      unsigned int v43 = 0;
      uint64_t v40 = 0;
      BOOL v44 = &v95[8];
      __src = &v95[8];
      *(_DWORD *)&v95[4] = 10;
      uint64_t v42 = &v95[8];
    }
    BOOL v46 = 0;
    do
    {
      if (isSplat) {
        BOOL v47 = 0;
      }
      else {
        BOOL v47 = v46;
      }
      *(void *)&v44[8 * v43 + 8 * (void)v46++] = *(void *)(v40 + 8 * (void)v47);
    }
    while (v15 != v46);
    unint64_t v45 = v43 + v15;
    *(_DWORD *)int v95 = v43 + v15;
    if (v44 != &v95[8])
    {
      if (__dst != &v98[8])
      {
        free(__dst);
        BOOL v44 = __src;
        LODWORD(v45) = *(_DWORD *)v95;
      }
      __dst = v44;
      *(_DWORD *)signed int v98 = v45;
      *(_DWORD *)&v98[4] = *(_DWORD *)&v95[4];
      __src = &v95[8];
      *(_DWORD *)&v95[4] = 0;
      goto LABEL_63;
    }
    uint64_t v48 = *(unsigned int *)v98;
    if (*(_DWORD *)v98 < v45)
    {
      if (*(_DWORD *)&v98[4] >= v45)
      {
        if (*(_DWORD *)v98)
        {
          memmove(__dst, v44, 8 * *(unsigned int *)v98);
LABEL_60:
          if (v48 != *(unsigned int *)v95) {
            memcpy((char *)__dst + 8 * v48, (char *)__src + 8 * v48, 8 * *(unsigned int *)v95 - 8 * v48);
          }
          *(_DWORD *)signed int v98 = v45;
          uint64_t v42 = v44;
          goto LABEL_63;
        }
      }
      else
      {
        *(_DWORD *)signed int v98 = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v98[8], v45, 8);
      }
      uint64_t v48 = 0;
      goto LABEL_60;
    }
    if (v45) {
      memmove(__dst, v44, 8 * v45);
    }
    uint64_t v42 = v44;
LABEL_56:
    *(_DWORD *)signed int v98 = v45;
LABEL_63:
    *(_DWORD *)int v95 = 0;
    BOOL v49 = __src == v42;
    a3 = v39;
    if (!v49) {
      free(__src);
    }
  }
  if (v107 != 4)
  {
    uint64_t v51 = 0;
    int v52 = 0;
    goto LABEL_99;
  }
  __src = &v95[16];
  *(_DWORD *)&v95[16] = 0;
  *(int64x2_t *)int v95 = vdupq_n_s64(4uLL);
  if (*v106 != 1 || *v103 != 1 || *(void *)v100 != 1) {
    goto LABEL_73;
  }
  if (mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v93))
  {
    BOOL v50 = 0;
    goto LABEL_74;
  }
  if (!*(void *)__dst) {
    BOOL v50 = *((void *)__dst + 1) != 0;
  }
  else {
LABEL_73:
  }
    BOOL v50 = 1;
LABEL_74:
  *(unsigned char *)__src = v50;
  if (v106[1] != 1 || v103[1] != 1 || *((void *)v100 + 1) != 1) {
    goto LABEL_80;
  }
  if (mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v93))
  {
    BOOL v53 = 0;
    goto LABEL_81;
  }
  if (!*((void *)__dst + 2)) {
    BOOL v53 = *((void *)__dst + 3) != 0;
  }
  else {
LABEL_80:
  }
    BOOL v53 = 1;
LABEL_81:
  *((unsigned char *)__src + 1) = v53;
  if (v106[2] != 1 || v103[2] != 1 || *((void *)v100 + 2) != 1) {
    goto LABEL_87;
  }
  if (mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v93))
  {
    BOOL v54 = 0;
    goto LABEL_88;
  }
  if (!*((void *)__dst + 4)) {
    BOOL v54 = *((void *)__dst + 5) != 0;
  }
  else {
LABEL_87:
  }
    BOOL v54 = 1;
LABEL_88:
  *((unsigned char *)__src + 2) = v54;
  if (v106[3] != 1 || v103[3] != 1 || *((void *)v100 + 3) != 1) {
    goto LABEL_95;
  }
  if (mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v93))
  {
    char v55 = __src;
    *((unsigned char *)__src + 3) = 0;
    if (!*v55) {
      goto LABEL_118;
    }
LABEL_97:
    uint64_t v51 = 0;
    int v52 = 0;
    if (v55 == &v95[16]) {
      goto LABEL_99;
    }
    goto LABEL_98;
  }
  if (!*((void *)__dst + 6)) {
    BOOL v56 = *((void *)__dst + 7) != 0;
  }
  else {
LABEL_95:
  }
    BOOL v56 = 1;
  char v55 = __src;
  *((unsigned char *)__src + 3) = v56;
  if (*v55) {
    goto LABEL_97;
  }
  if (v56)
  {
    if (!v55[1])
    {
      int v52 = 0;
      goto LABEL_119;
    }
    goto LABEL_97;
  }
LABEL_118:
  int v52 = 1;
LABEL_119:
  uint64_t v51 = 0x100000000;
  if (v55 != &v95[16]) {
LABEL_98:
  }
    free(v55);
LABEL_99:
  if (__dst != &v98[8]) {
    free(__dst);
  }
  if (v100 != v102) {
    free(v100);
  }
  if (v103 != (void *)v105) {
    free(v103);
  }
  if (v106 != v108) {
    free(v106);
  }
  uint64_t result = 0;
  if (a3 && (v51 & 0x100000000) != 0)
  {
    if (v52)
    {
      if (a3 == 1) {
        goto LABEL_111;
      }
    }
    else if (a3 == 2)
    {
LABEL_111:
      int v58 = a3 != 1;
      __dst = &v98[8];
      if (v52 == v58)
      {
        *(_OWORD *)&v98[4] = xmmword_18110B6B0;
        int v59 = 3;
      }
      else
      {
        *(void *)&v98[4] = 5;
        if (a3 == 1)
        {
          *(void *)&v98[12] = 0x100000003;
          int v59 = 2;
        }
        else
        {
          *(void *)&v98[12] = 0x300000002;
          int v59 = 1;
        }
      }
      int v99 = v59;
      *(_DWORD *)signed int v98 = 4;
      uint64_t v60 = *(void *)(v91 + 24);
      uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v91);
      uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v91);
      uint64_t v93 = 0;
      mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v91);
      if (!v63) {
        goto LABEL_127;
      }
      uint64_t Offsets = mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v91);
      if (v65)
      {
LABEL_127:
        uint64_t Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v91);
        uint64_t WindowSizes = mlir::mps::PoolAvgGradientOp::getWindowSizes((mlir::mps::PoolAvgGradientOp *)&v91);
        uint64_t v68 = *(void *)(v91 + 24);
        LODWORD(__src) = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v91);
        LOBYTE(v106) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v91);
        LOBYTE(v103) = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v91);
        uint64_t v69 = mlir::OpBuilder::create<mlir::mps::PoolAvgOp,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyle,mlir::DenseIntElementsAttr &,BOOL,BOOL>(a5 + 1, v68, (uint64_t *)&v100, &v89, &v90, v92, (unsigned int *)&__src, &v93, (char *)&v106, (char *)&v103);
        if (v52 == v58)
        {
          __src = &v95[8];
          *(_OWORD *)&v95[4] = xmmword_18110B6B0;
          int v70 = 3;
        }
        else
        {
          __src = &v95[8];
          *(void *)&v95[4] = 5;
          if (v52)
          {
            *(void *)&v95[12] = 0x300000002;
            int v70 = 1;
          }
          else
          {
            *(void *)&v95[12] = 0x100000003;
            int v70 = 2;
          }
        }
        int v96 = v70;
        *(_DWORD *)int v95 = 4;
        uint64_t v106 = v108;
        uint64_t v107 = 0x200000000;
        uint64_t v71 = *((unsigned int *)v69 + 9);
        if (v71) {
          uint64_t v72 = (uint64_t)v69 - 16;
        }
        else {
          uint64_t v72 = 0;
        }
        if (v71)
        {
          for (uint64_t i = 0; i != v71; ++i)
          {
            uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v72, i);
            uint64_t v76 = v107;
            if (v107 >= (unint64_t)HIDWORD(v107))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v108, v107 + 1, 8);
              uint64_t v76 = v107;
            }
            v106[v76] = v75;
            unint64_t v77 = (v107 + 1);
            LODWORD(v107) = v107 + 1;
          }
          uint64_t v78 = v106;
        }
        else
        {
          unint64_t v77 = 0;
          uint64_t v78 = v108;
        }
        uint64_t v79 = v91;
        mlir::ValueRange::ValueRange((unint64_t *)&v103, (uint64_t)v78, v77);
        (*((void (**)(mlir::UnitAttr **, uint64_t, void *, uint64_t))*a5 + 3))(a5, v79, v103, v104);
        if (v106 != v108) {
          free(v106);
        }
        if (__src != &v95[8]) {
          free(__src);
        }
        if (__dst != &v98[8]) {
          free(__dst);
        }
        return (mlir::GenericProgramPoint *)1;
      }
LABEL_154:
      int v80 = (mlir::UnitAttr **)std::__throw_bad_optional_access[abi:nn180100]();
      return mlir::OpBuilder::create<mlir::mps::PoolAvgOp,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyle,mlir::DenseIntElementsAttr &,BOOL,BOOL>(v80, v81, v82, v83, v84, v85, v86, v87, a9, a10);
    }
    return 0;
  }
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::PoolAvgOp,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyle,mlir::DenseIntElementsAttr &,BOOL,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, unsigned int *a7, uint64_t *a8, char *a9, char *a10)
{
  v29[38] = *MEMORY[0x1E4F143B8];
  uint64_t v24 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  uint64_t v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_average", (const unsigned __int8 *)0x13, Context);
  if (!v20)
  {
    __int16 v28 = 1283;
    v27[2] = (uint64_t)"mps.pooling_average";
    v27[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v29, a2, v19);
  mlir::mps::PoolAvgOp::build(a1, (uint64_t)v29, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10);
  unint64_t v21 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v29);
  if (*(_UNKNOWN **)(*((void *)v21 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::PoolAvgOp,void>::id) {
    uint64_t v22 = v21;
  }
  else {
    uint64_t v22 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  return v22;
}

mlir::GenericProgramPoint *mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConvertPoolingInterface<mlir::mps::PoolMaxOp>>::convertLayout(uint64_t a1, uint64_t a2, int a3, uint64_t a4, mlir::UnitAttr **a5, uint64_t a6, uint64_t a7, uint64_t a8, char *a9, char *a10, unsigned int *a11, uint64_t *a12)
{
  v112[5] = *MEMORY[0x1E4F143B8];
  uint64_t v95 = a2;
  if (*(void *)mlir::mpsx::ListPopBackOp::getElement((mlir::mpsx::ListPopBackOp *)&v95)) {
    return 0;
  }
  uint64_t v97 = v95;
  uint64_t WindowSizes = (char *)mlir::mps::PoolMaxGradientOp::getWindowSizes((mlir::mps::PoolMaxGradientOp *)&v97);
  if (mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)&WindowSizes, 8, 1, 0))
  {
    uint64_t RawStringData = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&WindowSizes);
    char isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&WindowSizes);
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&WindowSizes);
    unint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&WindowSizes);
    unint64_t v13 = NumElements;
    uint64_t v110 = v112;
    uint64_t v111 = 0x500000000;
    if (NumElements < 6)
    {
      int v21 = 0;
      if (!NumElements) {
        goto LABEL_15;
      }
      uint64_t v22 = v112;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v110, v112, NumElements, 8);
      int v21 = v111;
      uint64_t v22 = v110;
    }
  }
  else
  {
    int v21 = 0;
    uint64_t RawStringData = 0;
    uint64_t v22 = v112;
    uint64_t v110 = v112;
    uint64_t v111 = 0x500000000;
  }
  uint64_t v23 = 0;
  uint64_t v24 = &v22[v21];
  do
  {
    if (isSplat) {
      uint64_t v25 = 0;
    }
    else {
      uint64_t v25 = v23;
    }
    v24[v23++] = *(void *)(RawStringData + 8 * v25);
  }
  while (v13 != v23);
LABEL_15:
  LODWORD(v111) = v21 + v13;
  uint64_t WindowSizes = (char *)mlir::mps::PoolMaxGradientOp::getStrides((mlir::mps::PoolMaxGradientOp *)&v97);
  if (mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)&WindowSizes, 8, 1, 0))
  {
    uint64_t v26 = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&WindowSizes);
    char isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&WindowSizes);
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&WindowSizes);
    unint64_t v27 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&WindowSizes);
    unint64_t v14 = v27;
    __int16 v28 = v109;
    uint64_t v107 = v109;
    uint64_t v108 = 0x500000000;
    if (v27 < 6)
    {
      int v29 = 0;
      if (!v27) {
        goto LABEL_26;
      }
      uint64_t v30 = v109;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v107, v109, v27, 8);
      int v29 = v108;
      uint64_t v30 = v107;
    }
  }
  else
  {
    int v29 = 0;
    uint64_t v26 = 0;
    uint64_t v30 = v109;
    uint64_t v107 = v109;
    uint64_t v108 = 0x500000000;
    __int16 v28 = v109;
  }
  uint64_t v31 = 0;
  int v32 = &v30[8 * v29];
  do
  {
    if (isSplat) {
      uint64_t v33 = 0;
    }
    else {
      uint64_t v33 = v31;
    }
    *(void *)&v32[8 * v31++] = *(void *)(v26 + 8 * v33);
  }
  while (v14 != v31);
LABEL_26:
  LODWORD(v108) = v29 + v14;
  uint64_t WindowSizes = (char *)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v97);
  if (mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)&WindowSizes, 8, 1, 0))
  {
    uint64_t v34 = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&WindowSizes);
    char isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&WindowSizes);
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&WindowSizes);
    unint64_t v35 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&WindowSizes);
    unint64_t v15 = v35;
    uint64_t v104 = v106;
    uint64_t v105 = 0x500000000;
    if (v35 < 6)
    {
      int v36 = 0;
      if (!v35) {
        goto LABEL_37;
      }
      char v37 = v106;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v104, v106, v35, 8);
      int v36 = v105;
      char v37 = v104;
    }
  }
  else
  {
    int v36 = 0;
    uint64_t v34 = 0;
    char v37 = v106;
    uint64_t v104 = v106;
    uint64_t v105 = 0x500000000;
  }
  uint64_t v38 = 0;
  int v39 = &v37[8 * v36];
  do
  {
    if (isSplat) {
      uint64_t v40 = 0;
    }
    else {
      uint64_t v40 = v38;
    }
    *(void *)&v39[8 * v38++] = *(void *)(v34 + 8 * v40);
  }
  while (v15 != v38);
LABEL_37:
  LODWORD(v105) = v36 + v15;
  uint64_t WindowSizes = &v102[8];
  *(void *)unint64_t v102 = 0xA00000000;
  mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v97);
  if (v41)
  {
    v96[0] = mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v97);
    v96[1] = v42;
    if (!(_BYTE)v42) {
      goto LABEL_157;
    }
    int v90 = a3;
    unsigned int v43 = a5;
    if (mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)v96, 8, 1, 0))
    {
      uint64_t v44 = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)v96);
      char isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)v96);
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v96);
      unint64_t v45 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v96);
      __int16 v28 = (unsigned char *)v45;
      BOOL v46 = &v99[8];
      __src = &v99[8];
      *(void *)int v99 = 0xA00000000;
      if (v45 < 0xB)
      {
        unsigned int v47 = 0;
        LODWORD(v49) = 0;
        uint64_t v48 = &v99[8];
        if (!v45) {
          goto LABEL_59;
        }
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, &v99[8], v45, 8);
        unsigned int v47 = *(_DWORD *)v99;
        uint64_t v48 = (char *)__src;
      }
    }
    else
    {
      unsigned int v47 = 0;
      uint64_t v44 = 0;
      uint64_t v48 = &v99[8];
      __src = &v99[8];
      *(_DWORD *)&v99[4] = 10;
      BOOL v46 = &v99[8];
    }
    BOOL v50 = 0;
    do
    {
      if (isSplat) {
        uint64_t v51 = 0;
      }
      else {
        uint64_t v51 = v50;
      }
      *(void *)&v48[8 * v47 + 8 * (void)v50++] = *(void *)(v44 + 8 * (void)v51);
    }
    while (v28 != v50);
    unint64_t v49 = v47 + v28;
    *(_DWORD *)int v99 = v47 + v28;
    if (v48 != &v99[8])
    {
      if (WindowSizes != &v102[8])
      {
        free(WindowSizes);
        uint64_t v48 = (char *)__src;
        LODWORD(v49) = *(_DWORD *)v99;
      }
      uint64_t WindowSizes = v48;
      *(_DWORD *)unint64_t v102 = v49;
      *(_DWORD *)&v102[4] = *(_DWORD *)&v99[4];
      __src = &v99[8];
      *(_DWORD *)&v99[4] = 0;
      goto LABEL_66;
    }
    uint64_t v52 = *(unsigned int *)v102;
    if (*(_DWORD *)v102 < v49)
    {
      if (*(_DWORD *)&v102[4] >= v49)
      {
        if (*(_DWORD *)v102) {
          memmove(WindowSizes, v48, 8 * *(unsigned int *)v102);
        }
        else {
          uint64_t v52 = 0;
        }
      }
      else
      {
        *(_DWORD *)unint64_t v102 = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&WindowSizes, &v102[8], v49, 8);
        uint64_t v52 = 0;
      }
      if (v52 != *(unsigned int *)v99) {
        memcpy(&WindowSizes[8 * v52], (char *)__src + 8 * v52, 8 * *(unsigned int *)v99 - 8 * v52);
      }
      *(_DWORD *)unint64_t v102 = v49;
      BOOL v46 = v48;
      goto LABEL_66;
    }
    if (v49) {
      memmove(WindowSizes, v48, 8 * v49);
    }
    BOOL v46 = v48;
LABEL_59:
    *(_DWORD *)unint64_t v102 = v49;
LABEL_66:
    *(_DWORD *)int v99 = 0;
    a5 = v43;
    if (__src != v46) {
      free(__src);
    }
    a3 = v90;
  }
  if (v111 != 4)
  {
    uint64_t v54 = 0;
    int v55 = 0;
    goto LABEL_103;
  }
  __src = &v99[16];
  *(_DWORD *)&v99[16] = 0;
  *(int64x2_t *)int v99 = vdupq_n_s64(4uLL);
  if (*v110 != 1 || *v107 != 1 || *v104 != 1) {
    goto LABEL_77;
  }
  if (mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v97))
  {
    BOOL v53 = 0;
    goto LABEL_78;
  }
  if (!*(void *)WindowSizes) {
    BOOL v53 = *((void *)WindowSizes + 1) != 0;
  }
  else {
LABEL_77:
  }
    BOOL v53 = 1;
LABEL_78:
  *(unsigned char *)__src = v53;
  if (v110[1] != 1 || v107[1] != 1 || v104[1] != 1) {
    goto LABEL_84;
  }
  if (mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v97))
  {
    BOOL v56 = 0;
    goto LABEL_85;
  }
  if (!*((void *)WindowSizes + 2)) {
    BOOL v56 = *((void *)WindowSizes + 3) != 0;
  }
  else {
LABEL_84:
  }
    BOOL v56 = 1;
LABEL_85:
  *((unsigned char *)__src + 1) = v56;
  if (v110[2] != 1 || v107[2] != 1 || v104[2] != 1) {
    goto LABEL_91;
  }
  if (mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v97))
  {
    BOOL v57 = 0;
    goto LABEL_92;
  }
  if (!*((void *)WindowSizes + 4)) {
    BOOL v57 = *((void *)WindowSizes + 5) != 0;
  }
  else {
LABEL_91:
  }
    BOOL v57 = 1;
LABEL_92:
  *((unsigned char *)__src + 2) = v57;
  if (v110[3] != 1 || v107[3] != 1 || v104[3] != 1) {
    goto LABEL_99;
  }
  if (mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v97))
  {
    int v58 = __src;
    *((unsigned char *)__src + 3) = 0;
    if (!*v58) {
      goto LABEL_122;
    }
LABEL_101:
    uint64_t v54 = 0;
    int v55 = 0;
    if (v58 == &v99[16]) {
      goto LABEL_103;
    }
    goto LABEL_102;
  }
  if (!*((void *)WindowSizes + 6)) {
    BOOL v59 = *((void *)WindowSizes + 7) != 0;
  }
  else {
LABEL_99:
  }
    BOOL v59 = 1;
  int v58 = __src;
  *((unsigned char *)__src + 3) = v59;
  if (*v58) {
    goto LABEL_101;
  }
  if (v59)
  {
    if (!v58[1])
    {
      int v55 = 0;
      goto LABEL_123;
    }
    goto LABEL_101;
  }
LABEL_122:
  int v55 = 1;
LABEL_123:
  uint64_t v54 = 0x100000000;
  if (v58 != &v99[16]) {
LABEL_102:
  }
    free(v58);
LABEL_103:
  if (WindowSizes != &v102[8]) {
    free(WindowSizes);
  }
  if (v104 != (void *)v106) {
    free(v104);
  }
  if (v107 != (void *)v109) {
    free(v107);
  }
  if (v110 != v112) {
    free(v110);
  }
  uint64_t result = 0;
  if (a3 && (v54 & 0x100000000) != 0)
  {
    if (v55)
    {
      if (a3 == 1)
      {
LABEL_120:
        int v60 = a3 != 1;
        uint64_t WindowSizes = &v102[8];
        if (v55 == v60)
        {
          *(_OWORD *)&v102[4] = xmmword_18110B6B0;
          int v61 = 3;
        }
        else
        {
          *(void *)&v102[4] = 5;
          if (a3 == 1)
          {
            *(void *)&v102[12] = 0x100000003;
            int v61 = 2;
          }
          else
          {
            *(void *)&v102[12] = 0x300000002;
            int v61 = 1;
          }
        }
        int v103 = v61;
        *(_DWORD *)unint64_t v102 = 4;
        uint64_t v62 = *(void *)(v95 + 24);
        uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95);
        uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v95);
        uint64_t v97 = 0;
        mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v95);
        if (!v65) {
          goto LABEL_131;
        }
        uint64_t Offsets = mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v95);
        if (v67)
        {
LABEL_131:
          uint64_t Strides = mlir::mps::PoolMaxGradientOp::getStrides((mlir::mps::PoolMaxGradientOp *)&v95);
          uint64_t v69 = mlir::mps::PoolMaxGradientOp::getWindowSizes((mlir::mps::PoolMaxGradientOp *)&v95);
          uint64_t v70 = *(void *)(v95 + 24);
          LODWORD(v110) = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v95);
          BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v95);
          BOOL ResetAfter = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v95);
          LODWORD(v107) = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v95);
          __src = (void *)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v95);
          uint64_t v71 = mlir::OpBuilder::create<mlir::mps::PoolMaxOp,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyle,mlir::DenseIntElementsAttr &,BOOL,BOOL,mlir::mps::PoolIndicesMode,mlir::TypeAttr>(a5 + 1, v70, (uint64_t *)&v104, &v93, &v94, v96, (unsigned int *)&v110, &v97, (char *)&InferredResultTypes, (char *)&ResetAfter, (unsigned int *)&v107, (uint64_t *)&__src);
          if (v55 == v60)
          {
            __src = &v99[8];
            *(_OWORD *)&v99[4] = xmmword_18110B6B0;
            int v72 = 3;
          }
          else
          {
            __src = &v99[8];
            *(void *)&v99[4] = 5;
            if (v55)
            {
              *(void *)&v99[12] = 0x300000002;
              int v72 = 1;
            }
            else
            {
              *(void *)&v99[12] = 0x100000003;
              int v72 = 2;
            }
          }
          int v100 = v72;
          *(_DWORD *)int v99 = 4;
          uint64_t v110 = v112;
          uint64_t v111 = 0x200000000;
          uint64_t v73 = *((unsigned int *)v71 + 9);
          if (v73) {
            uint64_t v74 = (uint64_t)v71 - 16;
          }
          else {
            uint64_t v74 = 0;
          }
          if (v73)
          {
            for (uint64_t i = 0; i != v73; ++i)
            {
              uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v74, i);
              uint64_t v78 = v111;
              if (v111 >= (unint64_t)HIDWORD(v111))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v110, v112, v111 + 1, 8);
                uint64_t v78 = v111;
              }
              v110[v78] = v77;
              unint64_t v79 = (v111 + 1);
              LODWORD(v111) = v111 + 1;
            }
            int v80 = v110;
          }
          else
          {
            unint64_t v79 = 0;
            int v80 = v112;
          }
          uint64_t v81 = v95;
          mlir::ValueRange::ValueRange((unint64_t *)&v107, (uint64_t)v80, v79);
          (*((void (**)(mlir::UnitAttr **, uint64_t, void *, uint64_t))*a5 + 3))(a5, v81, v107, v108);
          if (v110 != v112) {
            free(v110);
          }
          if (__src != &v99[8]) {
            free(__src);
          }
          if (WindowSizes != &v102[8]) {
            free(WindowSizes);
          }
          return (mlir::GenericProgramPoint *)1;
        }
LABEL_157:
        unsigned int v82 = (mlir::UnitAttr **)std::__throw_bad_optional_access[abi:nn180100]();
        return mlir::OpBuilder::create<mlir::mps::PoolMaxOp,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyle,mlir::DenseIntElementsAttr &,BOOL,BOOL,mlir::mps::PoolIndicesMode,mlir::TypeAttr>(v82, v83, v84, v85, v86, v87, v88, v89, a9, a10, a11, a12);
      }
    }
    else if (a3 == 2)
    {
      goto LABEL_120;
    }
    return 0;
  }
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::PoolMaxOp,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyle,mlir::DenseIntElementsAttr &,BOOL,BOOL,mlir::mps::PoolIndicesMode,mlir::TypeAttr>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, unsigned int *a7, uint64_t *a8, char *a9, char *a10, unsigned int *a11, uint64_t *a12)
{
  v31[38] = *MEMORY[0x1E4F143B8];
  uint64_t v26 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v26);
  uint64_t v21 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_max", (const unsigned __int8 *)0xF, Context);
  if (!v22)
  {
    __int16 v30 = 1283;
    void v29[2] = (uint64_t)"mps.pooling_max";
    v29[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v28 = 259;
    llvm::operator+(v29, (uint64_t *)&v27, (uint64_t)v31);
    llvm::report_fatal_error((llvm::Twine *)v31, 1);
  }
  mlir::OperationState::OperationState(v31, a2, v21);
  mlir::mps::PoolMaxOp::build(a1, (uint64_t)v31, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, *a11, *a12);
  uint64_t v23 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v31);
  if (*(_UNKNOWN **)(*((void *)v23 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::PoolMaxOp,void>::id) {
    uint64_t v24 = v23;
  }
  else {
    uint64_t v24 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v31);
  return v24;
}

mlir::GenericProgramPoint *mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConvertPoolingInterface<mlir::mps::PoolL2NormOp>>::convertLayout(uint64_t a1, uint64_t a2, int a3, uint64_t a4, mlir::UnitAttr **a5, uint64_t a6, uint64_t a7, uint64_t a8, char *a9, char *a10)
{
  v108[5] = *MEMORY[0x1E4F143B8];
  uint64_t v91 = a2;
  uint64_t v93 = a2;
  __dst = (void *)mlir::mps::PoolAvgGradientOp::getWindowSizes((mlir::mps::PoolAvgGradientOp *)&v93);
  unint64_t v15 = "extureUnitInfo";
  if (mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)&__dst, 8, 1, 0))
  {
    uint64_t RawStringData = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&__dst);
    char isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&__dst);
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&__dst);
    unint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&__dst);
    unint64_t v11 = NumElements;
    uint64_t v106 = v108;
    uint64_t v107 = 0x500000000;
    if (NumElements < 6)
    {
      int v18 = 0;
      if (!NumElements) {
        goto LABEL_12;
      }
      uint64_t v19 = v108;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v108, NumElements, 8);
      int v18 = v107;
      uint64_t v19 = v106;
    }
  }
  else
  {
    int v18 = 0;
    uint64_t RawStringData = 0;
    uint64_t v19 = v108;
    uint64_t v106 = v108;
    uint64_t v107 = 0x500000000;
  }
  uint64_t v20 = 0;
  uint64_t v21 = &v19[v18];
  do
  {
    if (isSplat) {
      uint64_t v22 = 0;
    }
    else {
      uint64_t v22 = v20;
    }
    v21[v20++] = *(void *)(RawStringData + 8 * v22);
  }
  while (v11 != v20);
LABEL_12:
  LODWORD(v107) = v18 + v11;
  __dst = (void *)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v93);
  if (mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)&__dst, 8, 1, 0))
  {
    uint64_t v23 = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&__dst);
    char isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&__dst);
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&__dst);
    unint64_t v24 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&__dst);
    unint64_t v12 = v24;
    int v103 = v105;
    uint64_t v104 = 0x500000000;
    if (v24 < 6)
    {
      int v25 = 0;
      if (!v24) {
        goto LABEL_23;
      }
      uint64_t v26 = v105;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v105, v24, 8);
      int v25 = v104;
      uint64_t v26 = v103;
    }
  }
  else
  {
    int v25 = 0;
    uint64_t v23 = 0;
    uint64_t v26 = v105;
    int v103 = v105;
    uint64_t v104 = 0x500000000;
  }
  uint64_t v27 = 0;
  __int16 v28 = &v26[8 * v25];
  do
  {
    if (isSplat) {
      uint64_t v29 = 0;
    }
    else {
      uint64_t v29 = v27;
    }
    *(void *)&v28[8 * v27++] = *(void *)(v23 + 8 * v29);
  }
  while (v12 != v27);
LABEL_23:
  LODWORD(v104) = v25 + v12;
  __dst = (void *)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v93);
  if (mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)&__dst, 8, 1, 0))
  {
    uint64_t v30 = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&__dst);
    char isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&__dst);
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&__dst);
    unint64_t v31 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&__dst);
    unint64_t v13 = v31;
    int v100 = v102;
    uint64_t v101 = 0x500000000;
    if (v31 < 6)
    {
      int v32 = 0;
      if (!v31) {
        goto LABEL_34;
      }
      uint64_t v33 = v102;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v102, v31, 8);
      int v32 = v101;
      uint64_t v33 = v100;
    }
  }
  else
  {
    int v32 = 0;
    uint64_t v30 = 0;
    uint64_t v33 = v102;
    int v100 = v102;
    uint64_t v101 = 0x500000000;
  }
  uint64_t v34 = 0;
  unint64_t v35 = &v33[8 * v32];
  do
  {
    if (isSplat) {
      uint64_t v36 = 0;
    }
    else {
      uint64_t v36 = v34;
    }
    *(void *)&v35[8 * v34++] = *(void *)(v30 + 8 * v36);
  }
  while (v13 != v34);
LABEL_34:
  LODWORD(v101) = v32 + v13;
  __dst = &v98[8];
  *(void *)signed int v98 = 0xA00000000;
  mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v93);
  if (v37)
  {
    v92[0] = mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v93);
    v92[1] = v38;
    if (!(_BYTE)v38) {
      goto LABEL_154;
    }
    int v39 = a3;
    if (mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)v92, 8, 1, 0))
    {
      uint64_t v40 = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)v92);
      char isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)v92);
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v92);
      unint64_t v41 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v92);
      unint64_t v15 = (char *)v41;
      uint64_t v42 = &v95[8];
      __src = &v95[8];
      *(void *)uint64_t v95 = 0xA00000000;
      if (v41 < 0xB)
      {
        unsigned int v43 = 0;
        LODWORD(v45) = 0;
        uint64_t v44 = &v95[8];
        if (!v41) {
          goto LABEL_56;
        }
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, &v95[8], v41, 8);
        unsigned int v43 = *(_DWORD *)v95;
        uint64_t v44 = __src;
      }
    }
    else
    {
      unsigned int v43 = 0;
      uint64_t v40 = 0;
      uint64_t v44 = &v95[8];
      __src = &v95[8];
      *(_DWORD *)&v95[4] = 10;
      uint64_t v42 = &v95[8];
    }
    BOOL v46 = 0;
    do
    {
      if (isSplat) {
        unsigned int v47 = 0;
      }
      else {
        unsigned int v47 = v46;
      }
      *(void *)&v44[8 * v43 + 8 * (void)v46++] = *(void *)(v40 + 8 * (void)v47);
    }
    while (v15 != v46);
    unint64_t v45 = v43 + v15;
    *(_DWORD *)uint64_t v95 = v43 + v15;
    if (v44 != &v95[8])
    {
      if (__dst != &v98[8])
      {
        free(__dst);
        uint64_t v44 = __src;
        LODWORD(v45) = *(_DWORD *)v95;
      }
      __dst = v44;
      *(_DWORD *)signed int v98 = v45;
      *(_DWORD *)&v98[4] = *(_DWORD *)&v95[4];
      __src = &v95[8];
      *(_DWORD *)&v95[4] = 0;
      goto LABEL_63;
    }
    uint64_t v48 = *(unsigned int *)v98;
    if (*(_DWORD *)v98 < v45)
    {
      if (*(_DWORD *)&v98[4] >= v45)
      {
        if (*(_DWORD *)v98)
        {
          memmove(__dst, v44, 8 * *(unsigned int *)v98);
LABEL_60:
          if (v48 != *(unsigned int *)v95) {
            memcpy((char *)__dst + 8 * v48, (char *)__src + 8 * v48, 8 * *(unsigned int *)v95 - 8 * v48);
          }
          *(_DWORD *)signed int v98 = v45;
          uint64_t v42 = v44;
          goto LABEL_63;
        }
      }
      else
      {
        *(_DWORD *)signed int v98 = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v98[8], v45, 8);
      }
      uint64_t v48 = 0;
      goto LABEL_60;
    }
    if (v45) {
      memmove(__dst, v44, 8 * v45);
    }
    uint64_t v42 = v44;
LABEL_56:
    *(_DWORD *)signed int v98 = v45;
LABEL_63:
    *(_DWORD *)uint64_t v95 = 0;
    BOOL v49 = __src == v42;
    a3 = v39;
    if (!v49) {
      free(__src);
    }
  }
  if (v107 != 4)
  {
    uint64_t v51 = 0;
    int v52 = 0;
    goto LABEL_99;
  }
  __src = &v95[16];
  *(_DWORD *)&v95[16] = 0;
  *(int64x2_t *)uint64_t v95 = vdupq_n_s64(4uLL);
  if (*v106 != 1 || *v103 != 1 || *(void *)v100 != 1) {
    goto LABEL_73;
  }
  if (mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v93))
  {
    BOOL v50 = 0;
    goto LABEL_74;
  }
  if (!*(void *)__dst) {
    BOOL v50 = *((void *)__dst + 1) != 0;
  }
  else {
LABEL_73:
  }
    BOOL v50 = 1;
LABEL_74:
  *(unsigned char *)__src = v50;
  if (v106[1] != 1 || v103[1] != 1 || *((void *)v100 + 1) != 1) {
    goto LABEL_80;
  }
  if (mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v93))
  {
    BOOL v53 = 0;
    goto LABEL_81;
  }
  if (!*((void *)__dst + 2)) {
    BOOL v53 = *((void *)__dst + 3) != 0;
  }
  else {
LABEL_80:
  }
    BOOL v53 = 1;
LABEL_81:
  *((unsigned char *)__src + 1) = v53;
  if (v106[2] != 1 || v103[2] != 1 || *((void *)v100 + 2) != 1) {
    goto LABEL_87;
  }
  if (mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v93))
  {
    BOOL v54 = 0;
    goto LABEL_88;
  }
  if (!*((void *)__dst + 4)) {
    BOOL v54 = *((void *)__dst + 5) != 0;
  }
  else {
LABEL_87:
  }
    BOOL v54 = 1;
LABEL_88:
  *((unsigned char *)__src + 2) = v54;
  if (v106[3] != 1 || v103[3] != 1 || *((void *)v100 + 3) != 1) {
    goto LABEL_95;
  }
  if (mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v93))
  {
    int v55 = __src;
    *((unsigned char *)__src + 3) = 0;
    if (!*v55) {
      goto LABEL_118;
    }
LABEL_97:
    uint64_t v51 = 0;
    int v52 = 0;
    if (v55 == &v95[16]) {
      goto LABEL_99;
    }
    goto LABEL_98;
  }
  if (!*((void *)__dst + 6)) {
    BOOL v56 = *((void *)__dst + 7) != 0;
  }
  else {
LABEL_95:
  }
    BOOL v56 = 1;
  int v55 = __src;
  *((unsigned char *)__src + 3) = v56;
  if (*v55) {
    goto LABEL_97;
  }
  if (v56)
  {
    if (!v55[1])
    {
      int v52 = 0;
      goto LABEL_119;
    }
    goto LABEL_97;
  }
LABEL_118:
  int v52 = 1;
LABEL_119:
  uint64_t v51 = 0x100000000;
  if (v55 != &v95[16]) {
LABEL_98:
  }
    free(v55);
LABEL_99:
  if (__dst != &v98[8]) {
    free(__dst);
  }
  if (v100 != v102) {
    free(v100);
  }
  if (v103 != (void *)v105) {
    free(v103);
  }
  if (v106 != v108) {
    free(v106);
  }
  uint64_t result = 0;
  if (a3 && (v51 & 0x100000000) != 0)
  {
    if (v52)
    {
      if (a3 == 1) {
        goto LABEL_111;
      }
    }
    else if (a3 == 2)
    {
LABEL_111:
      int v58 = a3 != 1;
      __dst = &v98[8];
      if (v52 == v58)
      {
        *(_OWORD *)&v98[4] = xmmword_18110B6B0;
        int v59 = 3;
      }
      else
      {
        *(void *)&v98[4] = 5;
        if (a3 == 1)
        {
          *(void *)&v98[12] = 0x100000003;
          int v59 = 2;
        }
        else
        {
          *(void *)&v98[12] = 0x300000002;
          int v59 = 1;
        }
      }
      int v99 = v59;
      *(_DWORD *)signed int v98 = 4;
      uint64_t v60 = *(void *)(v91 + 24);
      uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v91);
      uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v91);
      uint64_t v93 = 0;
      mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v91);
      if (!v63) {
        goto LABEL_127;
      }
      uint64_t Offsets = mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v91);
      if (v65)
      {
LABEL_127:
        uint64_t Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v91);
        uint64_t WindowSizes = mlir::mps::PoolAvgGradientOp::getWindowSizes((mlir::mps::PoolAvgGradientOp *)&v91);
        uint64_t v68 = *(void *)(v91 + 24);
        LODWORD(__src) = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v91);
        LOBYTE(v106) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v91);
        LOBYTE(v103) = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v91);
        uint64_t v69 = mlir::OpBuilder::create<mlir::mps::PoolL2NormOp,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyle,mlir::DenseIntElementsAttr &,BOOL,BOOL>(a5 + 1, v68, (uint64_t *)&v100, &v89, &v90, v92, (unsigned int *)&__src, &v93, (char *)&v106, (char *)&v103);
        if (v52 == v58)
        {
          __src = &v95[8];
          *(_OWORD *)&v95[4] = xmmword_18110B6B0;
          int v70 = 3;
        }
        else
        {
          __src = &v95[8];
          *(void *)&v95[4] = 5;
          if (v52)
          {
            *(void *)&v95[12] = 0x300000002;
            int v70 = 1;
          }
          else
          {
            *(void *)&v95[12] = 0x100000003;
            int v70 = 2;
          }
        }
        int v96 = v70;
        *(_DWORD *)uint64_t v95 = 4;
        uint64_t v106 = v108;
        uint64_t v107 = 0x200000000;
        uint64_t v71 = *((unsigned int *)v69 + 9);
        if (v71) {
          uint64_t v72 = (uint64_t)v69 - 16;
        }
        else {
          uint64_t v72 = 0;
        }
        if (v71)
        {
          for (uint64_t i = 0; i != v71; ++i)
          {
            uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v72, i);
            uint64_t v76 = v107;
            if (v107 >= (unint64_t)HIDWORD(v107))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v108, v107 + 1, 8);
              uint64_t v76 = v107;
            }
            v106[v76] = v75;
            unint64_t v77 = (v107 + 1);
            LODWORD(v107) = v107 + 1;
          }
          uint64_t v78 = v106;
        }
        else
        {
          unint64_t v77 = 0;
          uint64_t v78 = v108;
        }
        uint64_t v79 = v91;
        mlir::ValueRange::ValueRange((unint64_t *)&v103, (uint64_t)v78, v77);
        (*((void (**)(mlir::UnitAttr **, uint64_t, void *, uint64_t))*a5 + 3))(a5, v79, v103, v104);
        if (v106 != v108) {
          free(v106);
        }
        if (__src != &v95[8]) {
          free(__src);
        }
        if (__dst != &v98[8]) {
          free(__dst);
        }
        return (mlir::GenericProgramPoint *)1;
      }
LABEL_154:
      int v80 = (mlir::UnitAttr **)std::__throw_bad_optional_access[abi:nn180100]();
      return mlir::OpBuilder::create<mlir::mps::PoolL2NormOp,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyle,mlir::DenseIntElementsAttr &,BOOL,BOOL>(v80, v81, v82, v83, v84, v85, v86, v87, a9, a10);
    }
    return 0;
  }
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::PoolL2NormOp,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyle,mlir::DenseIntElementsAttr &,BOOL,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, unsigned int *a7, uint64_t *a8, char *a9, char *a10)
{
  v29[38] = *MEMORY[0x1E4F143B8];
  uint64_t v24 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  uint64_t v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_l2_norm", (const unsigned __int8 *)0x13, Context);
  if (!v20)
  {
    __int16 v28 = 1283;
    v27[2] = (uint64_t)"mps.pooling_l2_norm";
    v27[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v29, a2, v19);
  mlir::mps::PoolL2NormOp::build(a1, (uint64_t)v29, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10);
  uint64_t v21 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v29);
  if (*(_UNKNOWN **)(*((void *)v21 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::PoolL2NormOp,void>::id) {
    uint64_t v22 = v21;
  }
  else {
    uint64_t v22 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  return v22;
}

void *mlir::DialectRegistry::addExtension<mlir::mps::MPSDialect>(void *a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t result = operator new(0x68uLL);
  uint64_t v5 = result;
  uint64_t v6 = (void *)a2[3];
  if (v6)
  {
    if (v6 == a2)
    {
      unint64_t v11 = v10;
      uint64_t result = (void *)(*(uint64_t (**)(void *, void *))(*a2 + 24))(a2, v10);
      uint64_t v6 = v11;
    }
    else
    {
      unint64_t v11 = (void *)a2[3];
      a2[3] = 0;
    }
  }
  else
  {
    unint64_t v11 = 0;
  }
  v5[3] = "mps";
  v5[4] = 3;
  _OWORD v5[2] = 0x300000001;
  *uint64_t v5 = &unk_1EC9D0558;
  v5[1] = v5 + 3;
  if (v6)
  {
    if (v6 == v10)
    {
      v5[12] = v5 + 9;
      (*(void (**)(void *))(v10[0] + 24))(v10);
      uint64_t result = v11;
      if (v11 == v10)
      {
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v10[0] + 32))(v10);
      }
      else if (v11)
      {
        uint64_t result = (void *)(*(uint64_t (**)(void))(*v11 + 40))();
      }
    }
    else
    {
      v5[12] = v6;
    }
  }
  else
  {
    v5[12] = 0;
  }
  uint64_t v9 = v5;
  signed int v7 = (void *)a1[4];
  if ((unint64_t)v7 >= a1[5])
  {
    int v8 = std::vector<std::unique_ptr<mlir::DialectExtensionBase>>::__push_back_slow_path<std::unique_ptr<mlir::DialectExtensionBase>>(a1 + 3, (uint64_t *)&v9);
    uint64_t result = v9;
    a1[4] = v8;
    uint64_t v9 = 0;
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  else
  {
    *signed int v7 = v5;
    a1[4] = v7 + 1;
  }
  return result;
}

void mlir::DialectRegistry::addExtension<mlir::mps::MPSDialect>(std::function<void ()(mlir::MLIRContext *,mlir::mps::MPSDialect *)>)::Extension::~Extension(mlir::DialectExtensionBase *this)
{
  *(void *)this = &unk_1EC9D0558;
  uint64_t v2 = (char *)this + 72;
  uint64_t v3 = (char *)*((void *)this + 12);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }

  mlir::DialectExtensionBase::~DialectExtensionBase(this);
}

{
  char *v2;
  char *v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1EC9D0558;
  uint64_t v2 = (char *)this + 72;
  uint64_t v3 = (char *)*((void *)this + 12);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  mlir::DialectExtensionBase::~DialectExtensionBase(this);

  operator delete(v4);
}

uint64_t mlir::DialectExtension<void mlir::DialectRegistry::addExtension<mlir::mps::MPSDialect>(std::function<void ()(mlir::MLIRContext *,mlir::mps::MPSDialect *)>)::Extension,mlir::mps::MPSDialect>::apply(uint64_t a1, uint64_t a2, void *a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 32))(a1, a2, *a3);
}

void *mlir::DialectExtension<void mlir::DialectRegistry::addExtension<mlir::mps::MPSDialect>(std::function<void ()(mlir::MLIRContext *,mlir::mps::MPSDialect *)>)::Extension,mlir::mps::MPSDialect>::clone@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::DialectRegistry::addExtension<mlir::mps::MPSDialect>(std::function<void ()(mlir::MLIRContext *,mlir::mps::MPSDialect *)>)::Extension::Extension(v4, a1);
  *a2 = result;
  return result;
}

void *mlir::DialectRegistry::addExtension<mlir::mps::MPSDialect>(std::function<void ()(mlir::MLIRContext *,mlir::mps::MPSDialect *)>)::Extension::apply(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = a3;
  uint64_t v8 = a2;
  uint64_t v3 = *(void *)(a1 + 96);
  if (v3) {
    return (void *)(*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v3 + 48))(v3, &v8, &v7);
  }
  uint64_t v5 = (void *)std::__throw_bad_function_call[abi:nn180100]();
  return mlir::DialectRegistry::addExtension<mlir::mps::MPSDialect>(std::function<void ()(mlir::MLIRContext *,mlir::mps::MPSDialect *)>)::Extension::Extension(v5, v6);
}

void *mlir::DialectRegistry::addExtension<mlir::mps::MPSDialect>(std::function<void ()(mlir::MLIRContext *,mlir::mps::MPSDialect *)>)::Extension::Extension(void *a1, uint64_t a2)
{
  *a1 = &unk_1EC9AAD88;
  uint64_t v4 = a1 + 3;
  a1[1] = a1 + 3;
  uint64_t v5 = (void **)(a1 + 1);
  a1[2] = 0x300000000;
  if (a1 == (void *)a2) {
    goto LABEL_9;
  }
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  if (!v6) {
    goto LABEL_9;
  }
  if (v6 < 4)
  {
    unsigned int v7 = *(_DWORD *)(a2 + 16);
    goto LABEL_7;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(a1 + 1), v4, *(unsigned int *)(a2 + 16), 16);
  unsigned int v7 = *(_DWORD *)(a2 + 16);
  if (v7)
  {
    uint64_t v4 = *v5;
LABEL_7:
    memcpy(v4, *(const void **)(a2 + 8), 16 * v7);
  }
  *((_DWORD *)a1 + 4) = v6;
LABEL_9:
  *a1 = &unk_1EC9D0558;
  uint64_t v8 = a1 + 9;
  uint64_t v9 = *(void *)(a2 + 96);
  if (v9)
  {
    if (v9 == a2 + 72)
    {
      a1[12] = v8;
      (*(void (**)(void))(**(void **)(a2 + 96) + 24))(*(void *)(a2 + 96));
    }
    else
    {
      a1[12] = (*(uint64_t (**)(uint64_t, void *))(*(void *)v9 + 16))(v9, v8);
    }
  }
  else
  {
    a1[12] = 0;
  }
  return a1;
}

void *std::__function::__func<void (*)(mlir::MLIRContext *,mlir::mps::MPSDialect *),std::allocator<void (*)(mlir::MLIRContext *,mlir::mps::MPSDialect *)>,void ()(mlir::MLIRContext *,mlir::mps::MPSDialect *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EC9CE990;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void (*)(mlir::MLIRContext *,mlir::mps::MPSDialect *),std::allocator<void (*)(mlir::MLIRContext *,mlir::mps::MPSDialect *)>,void ()(mlir::MLIRContext *,mlir::mps::MPSDialect *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EC9CE990;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void (*)(mlir::MLIRContext *,mlir::mps::MPSDialect *),std::allocator<void (*)(mlir::MLIRContext *,mlir::mps::MPSDialect *)>,void ()(mlir::MLIRContext *,mlir::mps::MPSDialect *)>::operator()(uint64_t a1, void *a2, void *a3)
{
  return (*(uint64_t (**)(void, void))(a1 + 8))(*a2, *a3);
}

void **mlir::mps::registerMapDynamicShapeOpExternalModels(mlir::mps *this, mlir::DialectRegistry *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (void (**)(void **))&unk_1EC9CE990;
  uint64_t v5 = mlir::mps::registerMapDynamicShapeOpExternalModels(mlir::DialectRegistry &)::$_0::__invoke;
  unsigned int v6 = (void **)&v4;
  mlir::DialectRegistry::addExtension<mlir::mps::MPSDialect>(this, &v4);
  if (v6 == (void **)&v4)
  {
    v4[4]((void **)&v4);
  }
  else if (v6)
  {
    (*((void (**)(void))*v6 + 5))();
  }
  uint64_t v4 = (void (**)(void **))&unk_1EC9CEA30;
  uint64_t v5 = mlir::mps::registerMapDynamicShapeOpExternalModels(mlir::DialectRegistry &)::$_1::__invoke;
  unsigned int v6 = (void **)&v4;
  mlir::DialectRegistry::addExtension<mlir::mpsx::MPSXDialect>(this, &v4);
  uint64_t result = v6;
  if (v6 == (void **)&v4) {
    return (void **)((uint64_t (*)(void **))v4[4])((void **)&v4);
  }
  if (v6) {
    return (void **)(*((uint64_t (**)(void))*v6 + 5))();
  }
  return result;
}

uint64_t mlir::MapDynamicShapeOpInterface::mapDynamicShape(mlir::MapDynamicShapeOpInterface *this)
{
  return (**((uint64_t (***)(void, void))this + 1))(*((void *)this + 1), *(void *)this);
}

void mlir::mps::registerMapDynamicShapeOpExternalModels(mlir::DialectRegistry &)::$_0::__invoke(uint64_t *a1)
{
  uint64_t v2 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.relu", (const unsigned __int8 *)8, a1);
  if (!v3)
  {
    __int16 v149 = 1283;
    uint64_t v146 = "Attempting to attach an interface to an unregistered operation ";
    uint64_t v147 = "mps.relu";
    uint64_t v143 = 8;
    goto LABEL_79;
  }
  uint64_t v4 = v2;
  uint64_t v5 = (void *)v2[2];
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v2[1];
    uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    uint64_t v5 = (void *)v4[2];
  }
  else
  {
    uint64_t Values = v2[3];
  }
  uint64_t v7 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(Values, (uint64_t)v5, v7);
  uint64_t v8 = malloc(8uLL);
  unint64_t v9 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v4 + 4), v9, v8);
  unint64_t v10 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, a1);
  if (!v11)
  {
    __int16 v149 = 1283;
    uint64_t v146 = "Attempting to attach an interface to an unregistered operation ";
    uint64_t v147 = "mps.add";
    uint64_t v143 = 7;
    goto LABEL_79;
  }
  uint64_t v12 = v10;
  unint64_t v13 = (void *)v10[2];
  if (v13 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v10[1];
    uint64_t v14 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    unint64_t v13 = (void *)v12[2];
  }
  else
  {
    uint64_t v14 = v10[3];
  }
  uint64_t v15 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v14, (uint64_t)v13, v15);
  int v16 = malloc(8uLL);
  unint64_t v17 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v12 + 4), v17, v16);
  int v18 = "mps.multiply";
  uint64_t v19 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, a1);
  if (!v20) {
    goto LABEL_70;
  }
  uint64_t v21 = v19;
  uint64_t v22 = (void *)v19[2];
  if (v22 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v19[1];
    uint64_t v23 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    uint64_t v22 = (void *)v21[2];
  }
  else
  {
    uint64_t v23 = v19[3];
  }
  uint64_t v24 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v23, (uint64_t)v22, v24);
  int v25 = malloc(8uLL);
  unint64_t v26 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v21 + 4), v26, v25);
  uint64_t v27 = "mps.gather";
  __int16 v28 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.gather", (const unsigned __int8 *)0xA, a1);
  if (!v29) {
    goto LABEL_71;
  }
  uint64_t v30 = v28;
  unint64_t v31 = (void *)v28[2];
  if (v31 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v28[1];
    uint64_t v32 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    unint64_t v31 = (void *)v30[2];
  }
  else
  {
    uint64_t v32 = v28[3];
  }
  uint64_t v33 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v32, (uint64_t)v31, v33);
  uint64_t v34 = malloc(8uLL);
  unint64_t v35 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v30 + 4), v35, v34);
  uint64_t v27 = "mps.matmul";
  uint64_t v36 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.matmul", (const unsigned __int8 *)0xA, a1);
  if (!v37)
  {
LABEL_71:
    __int16 v149 = 1283;
    uint64_t v146 = "Attempting to attach an interface to an unregistered operation ";
    uint64_t v147 = v27;
    uint64_t v143 = 10;
    goto LABEL_79;
  }
  uint64_t v38 = v36;
  int v39 = (void *)v36[2];
  if (v39 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v36[1];
    uint64_t v40 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    int v39 = (void *)v38[2];
  }
  else
  {
    uint64_t v40 = v36[3];
  }
  uint64_t v41 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v40, (uint64_t)v39, v41);
  uint64_t v42 = malloc(8uLL);
  unint64_t v43 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v38 + 4), v43, v42);
  int v18 = "mps.exponent";
  uint64_t v44 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.exponent", (const unsigned __int8 *)0xC, a1);
  if (!v45) {
    goto LABEL_70;
  }
  BOOL v46 = v44;
  unsigned int v47 = (void *)v44[2];
  if (v47 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v44[1];
    uint64_t v48 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    unsigned int v47 = (void *)v46[2];
  }
  else
  {
    uint64_t v48 = v44[3];
  }
  uint64_t v49 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v48, (uint64_t)v47, v49);
  BOOL v50 = malloc(8uLL);
  unint64_t v51 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v46 + 4), v51, v50);
  int v18 = "mps.negative";
  int v52 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.negative", (const unsigned __int8 *)0xC, a1);
  if (!v53) {
    goto LABEL_70;
  }
  BOOL v54 = v52;
  int v55 = (void *)v52[2];
  if (v55 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v52[1];
    uint64_t v56 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    int v55 = (void *)v54[2];
  }
  else
  {
    uint64_t v56 = v52[3];
  }
  uint64_t v57 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v56, (uint64_t)v55, v57);
  int v58 = malloc(8uLL);
  unint64_t v59 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v54 + 4), v59, v58);
  int v18 = "mps.subtract";
  uint64_t v60 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.subtract", (const unsigned __int8 *)0xC, a1);
  if (!v61) {
    goto LABEL_70;
  }
  uint64_t v62 = v60;
  char v63 = (void *)v60[2];
  if (v63 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v60[1];
    uint64_t v64 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    char v63 = (void *)v62[2];
  }
  else
  {
    uint64_t v64 = v60[3];
  }
  uint64_t v65 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v64, (uint64_t)v63, v65);
  long long v66 = malloc(8uLL);
  unint64_t v67 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v62 + 4), v67, v66);
  uint64_t v68 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reciprocal", (const unsigned __int8 *)0xE, a1);
  if (!v69)
  {
    __int16 v149 = 1283;
    uint64_t v146 = "Attempting to attach an interface to an unregistered operation ";
    uint64_t v147 = "mps.reciprocal";
    uint64_t v143 = 14;
    goto LABEL_79;
  }
  int v70 = v68;
  uint64_t v71 = (void *)v68[2];
  if (v71 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v68[1];
    uint64_t v72 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    uint64_t v71 = (void *)v70[2];
  }
  else
  {
    uint64_t v72 = v68[3];
  }
  uint64_t v73 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v72, (uint64_t)v71, v73);
  uint64_t v74 = malloc(8uLL);
  unint64_t v75 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v70 + 4), v75, v74);
  int v18 = "mps.identity";
  uint64_t v76 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.identity", (const unsigned __int8 *)0xC, a1);
  if (!v77)
  {
LABEL_70:
    __int16 v149 = 1283;
    uint64_t v146 = "Attempting to attach an interface to an unregistered operation ";
    uint64_t v147 = v18;
    uint64_t v143 = 12;
    goto LABEL_79;
  }
  uint64_t v78 = v76;
  uint64_t v79 = (void *)v76[2];
  if (v79 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v76[1];
    uint64_t v80 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    uint64_t v79 = (void *)v78[2];
  }
  else
  {
    uint64_t v80 = v76[3];
  }
  uint64_t v81 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v80, (uint64_t)v79, v81);
  unsigned int v82 = malloc(8uLL);
  unint64_t v83 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v78 + 4), v83, v82);
  uint64_t v84 = "mps.permute";
  uint64_t v85 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.permute", (const unsigned __int8 *)0xB, a1);
  if (!v86) {
    goto LABEL_72;
  }
  uint64_t v87 = v85;
  uint64_t v88 = (void *)v85[2];
  if (v88 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v85[1];
    uint64_t v89 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    uint64_t v88 = (void *)v87[2];
  }
  else
  {
    uint64_t v89 = v85[3];
  }
  uint64_t v90 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v89, (uint64_t)v88, v90);
  uint64_t v91 = malloc(8uLL);
  unint64_t v92 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v87 + 4), v92, v91);
  uint64_t v93 = "mps.read_variable";
  uint64_t v94 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.read_variable", (const unsigned __int8 *)0x11, a1);
  if (!v95) {
    goto LABEL_73;
  }
  int v96 = v94;
  uint64_t v97 = (void *)v94[2];
  if (v97 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v94[1];
    uint64_t v98 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    uint64_t v97 = (void *)v96[2];
  }
  else
  {
    uint64_t v98 = v94[3];
  }
  uint64_t v99 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v98, (uint64_t)v97, v99);
  int v100 = malloc(8uLL);
  unint64_t v101 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v96 + 4), v101, v100);
  unint64_t v102 = "mps.variable_from_tensor";
  int v103 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.variable_from_tensor", (const unsigned __int8 *)0x18, a1);
  if (!v104) {
    goto LABEL_74;
  }
  uint64_t v105 = v103;
  uint64_t v106 = (void *)v103[2];
  if (v106 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v103[1];
    uint64_t v107 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    uint64_t v106 = (void *)v105[2];
  }
  else
  {
    uint64_t v107 = v103[3];
  }
  uint64_t v108 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v107, (uint64_t)v106, v108);
  uint64_t v109 = malloc(8uLL);
  unint64_t v110 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v105 + 4), v110, v109);
  uint64_t v84 = "mps.reshape";
  uint64_t v111 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reshape", (const unsigned __int8 *)0xB, a1);
  if (!v112)
  {
LABEL_72:
    __int16 v149 = 1283;
    uint64_t v146 = "Attempting to attach an interface to an unregistered operation ";
    uint64_t v147 = v84;
    uint64_t v143 = 11;
    goto LABEL_79;
  }
  uint64_t v113 = v111;
  unint64_t v114 = (void *)v111[2];
  if (v114 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v111[1];
    uint64_t v115 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    unint64_t v114 = (void *)v113[2];
  }
  else
  {
    uint64_t v115 = v111[3];
  }
  uint64_t v116 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v115, (uint64_t)v114, v116);
  uint64_t v117 = malloc(8uLL);
  unint64_t v118 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v113 + 4), v118, v117);
  uint64_t v93 = "mps.strided_slice";
  uint64_t v119 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.strided_slice", (const unsigned __int8 *)0x11, a1);
  if (!v120)
  {
LABEL_73:
    __int16 v149 = 1283;
    uint64_t v146 = "Attempting to attach an interface to an unregistered operation ";
    uint64_t v147 = v93;
    uint64_t v143 = 17;
    goto LABEL_79;
  }
  uint64_t v121 = v119;
  unsigned int v122 = (void *)v119[2];
  if (v122 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v119[1];
    uint64_t v123 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    unsigned int v122 = (void *)v121[2];
  }
  else
  {
    uint64_t v123 = v119[3];
  }
  uint64_t v124 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v123, (uint64_t)v122, v124);
  uint64_t v125 = malloc(8uLL);
  unint64_t v126 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v121 + 4), v126, v125);
  unint64_t v102 = "mps.strided_slice_update";
  unint64_t v127 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.strided_slice_update", (const unsigned __int8 *)0x18, a1);
  if (!v128)
  {
LABEL_74:
    __int16 v149 = 1283;
    uint64_t v146 = "Attempting to attach an interface to an unregistered operation ";
    uint64_t v147 = v102;
    uint64_t v143 = 24;
    goto LABEL_79;
  }
  uint64_t v129 = v127;
  unint64_t v130 = (void *)v127[2];
  if (v130 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v127[1];
    uint64_t v131 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    unint64_t v130 = (void *)v129[2];
  }
  else
  {
    uint64_t v131 = v127[3];
  }
  uint64_t v132 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v131, (uint64_t)v130, v132);
  uint64_t v133 = malloc(8uLL);
  unint64_t v134 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v129 + 4), v134, v133);
  int32x4_t v135 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.transpose", (const unsigned __int8 *)0xD, a1);
  if (!v136)
  {
    __int16 v149 = 1283;
    uint64_t v146 = "Attempting to attach an interface to an unregistered operation ";
    uint64_t v147 = "mps.transpose";
    uint64_t v143 = 13;
LABEL_79:
    uint64_t v148 = v143;
    uint64_t v144 = ".";
    __int16 v145 = 259;
    llvm::operator+((uint64_t *)&v146, (uint64_t *)&v144, (uint64_t)v150);
    llvm::report_fatal_error((llvm::Twine *)v150, 1);
  }
  unint64_t v137 = v135;
  uint64_t v138 = (void *)v135[2];
  if (v138 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v135[1];
    uint64_t v139 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    uint64_t v138 = (void *)v137[2];
  }
  else
  {
    uint64_t v139 = v135[3];
  }
  uint64_t v140 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v139, (uint64_t)v138, v140);
  uint64_t v141 = malloc(8uLL);
  unint64_t v142 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v137 + 4), v142, v141);
}

uint64_t mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>()
{
  unint64_t v0 = 0x1E8EB8000uLL;
  {
    unint64_t v0 = 0x1E8EB8000;
    if (v2)
    {
      unint64_t v10 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MapDynamicShapeOpInterface]";
      unint64_t v11 = 82;
      unint64_t v3 = llvm::StringRef::find((uint64_t *)&v10, "DesiredTypeName = ", 0x12uLL, 0);
      if (v11 >= v3) {
        unint64_t v4 = v3;
      }
      else {
        unint64_t v4 = v11;
      }
      uint64_t v5 = &v10[v4];
      unint64_t v6 = v11 - v4;
      if (v11 - v4 >= 0x12) {
        uint64_t v7 = 18;
      }
      else {
        uint64_t v7 = v11 - v4;
      }
      unint64_t v8 = v6 - v7;
      if (v8 >= v8 - 1) {
        uint64_t v9 = v8 - 1;
      }
      else {
        uint64_t v9 = v8;
      }
      mlir::detail::TypeIDResolver<mlir::MapDynamicShapeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v5[v7], v9);
      unint64_t v0 = 0x1E8EB8000;
    }
  }
  return *(void *)(v0 + 1920);
}

void mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::anonymous namespace'::MapReluOpInterface>::mapDynamicShape(mlir::_anonymous_namespace_ *a1@<X1>, uint64_t a2@<X8>)
{
}

void mlir::anonymous namespace'::mapDynamicShapeNAry(mlir::_anonymous_namespace_ *this@<X0>, uint64_t a2@<X8>)
{
  v25[6] = *MEMORY[0x1E4F143B8];
  __src = v25;
  uint64_t v24 = 0x600000000;
  if ((*((unsigned char *)this + 46) & 0x80) == 0) {
    goto LABEL_18;
  }
  uint64_t v4 = *((unsigned int *)this + 17);
  if (!v4) {
    goto LABEL_17;
  }
  uint64_t v5 = 0;
  uint64_t v6 = *((void *)this + 9);
  do
  {
    __dst = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(*(void *)(v6 + 32 * v5 + 24) + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v21 = v8;
    if (!__dst) {
      goto LABEL_7;
    }
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&__dst))
    {
      uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__dst);
      if (!v10) {
        goto LABEL_7;
      }
      uint64_t v11 = 8 * v10;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v11 -= 8;
        if (!v11) {
          goto LABEL_7;
        }
      }
    }
    uint64_t v7 = v24;
    if (v24 >= (unint64_t)HIDWORD(v24))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v25, v24 + 1, 8);
      uint64_t v7 = v24;
    }
    *((void *)__src + v7) = v5;
    LODWORD(v24) = v24 + 1;
LABEL_7:
    ++v5;
  }
  while (v5 != v4);
  unsigned int v12 = v24;
  if (v24)
  {
    unint64_t v13 = v22;
    __dst = v22;
    uint64_t v21 = 0x600000000;
    goto LABEL_22;
  }
LABEL_17:
  if (HIDWORD(v24))
  {
LABEL_18:
    uint64_t v14 = 0;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v25, 1uLL, 8);
    uint64_t v14 = v24;
  }
  *((void *)__src + v14) = -1;
  unint64_t v13 = v22;
  __dst = v22;
  uint64_t v21 = 0x600000000;
  BOOL v15 = __CFADD__(v24, 1);
  unsigned int v12 = v24 + 1;
  LODWORD(v24) = v24 + 1;
  if (v15)
  {
    unsigned int v12 = 0;
  }
  else
  {
LABEL_22:
    if (v12 < 7)
    {
      unsigned int v16 = v12;
LABEL_26:
      memcpy(v13, __src, 8 * v16);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v22, v12, 8);
      unsigned int v16 = v24;
      if (v24)
      {
        unint64_t v13 = __dst;
        goto LABEL_26;
      }
    }
    LODWORD(v21) = v12;
  }
  unint64_t v17 = (void *)(a2 + 32);
  *(void *)(a2 + 16) = a2 + 32;
  *(void *)a2 = a2 + 16;
  *(void *)(a2 + 8) = 0x100000000;
  *(void *)(a2 + 24) = 0x600000000;
  int v18 = 1;
  if ((void **)(a2 + 16) != &__dst && v12)
  {
    if (v12 < 7)
    {
      unsigned int v19 = v12;
LABEL_34:
      memcpy(v17, __dst, 8 * v19);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 16, (void *)(a2 + 32), v12, 8);
      unsigned int v19 = v21;
      if (v21)
      {
        unint64_t v17 = *(void **)(a2 + 16);
        goto LABEL_34;
      }
    }
    *(_DWORD *)(a2 + 24) = v12;
    int v18 = *(_DWORD *)(a2 + 8) + 1;
  }
  *(_DWORD *)(a2 + 8) = v18;
  if (__dst != v22) {
    free(__dst);
  }
  if (__src != v25) {
    free(__src);
  }
}

void mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::anonymous namespace'::MapAddOpInterface>::mapDynamicShape(mlir::_anonymous_namespace_ *this@<X1>, uint64_t a2@<X8>)
{
}

void mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::anonymous namespace'::MapMultiplyOpInterface>::mapDynamicShape(mlir::_anonymous_namespace_ *this@<X1>, uint64_t a2@<X8>)
{
}

uint64_t mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::anonymous namespace'::MapGatherOpInterface>::mapDynamicShape@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  v60[6] = *MEMORY[0x1E4F143B8];
  uint64_t v49 = a1;
  if (*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v49) + 8) >= 8uLL) {
    mlir::TypeID::get<mlir::ShapedType>();
  }
  unint64_t v3 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v49) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3) {
    goto LABEL_12;
  }
  uint64_t v4 = *v3;
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *(unsigned int *)(v4 + 16);
  if (!v6) {
    goto LABEL_12;
  }
  uint64_t v7 = *(void **)(v4 + 8);
  uint64_t v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    uint64_t v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    uint64_t v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      uint64_t v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_12:
  }
    uint64_t v13 = 0;
  v48[0] = v3;
  v48[1] = v13;
  uint64_t v14 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v49) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v14) {
    goto LABEL_22;
  }
  uint64_t v15 = *v14;
  unint64_t v16 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v17 = *(unsigned int *)(v15 + 16);
  if (!v17) {
    goto LABEL_22;
  }
  int v18 = *(void **)(v15 + 8);
  unsigned int v19 = &v18[2 * v17];
  do
  {
    unint64_t v20 = v17 >> 1;
    uint64_t v21 = &v18[2 * (v17 >> 1)];
    unint64_t v23 = *v21;
    uint64_t v22 = v21 + 2;
    v17 += ~(v17 >> 1);
    if (v23 < v16) {
      int v18 = v22;
    }
    else {
      unint64_t v17 = v20;
    }
  }
  while (v17);
  if (v18 != v19 && *v18 == v16) {
    uint64_t v24 = v18[1];
  }
  else {
LABEL_22:
  }
    uint64_t v24 = 0;
  v47[0] = v14;
  v47[1] = v24;
  uint64_t result = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v48);
  if (result)
  {
    uint64_t result = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v47);
    if (result)
    {
      if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v47))
      {
        uint64_t result = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v47);
        if (!v26) {
          goto LABEL_35;
        }
        uint64_t v27 = 8 * v26;
        while (*(void *)result != 0x8000000000000000)
        {
          result += 8;
          v27 -= 8;
          if (!v27) {
            goto LABEL_35;
          }
        }
      }
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v48);
      uint64_t v29 = v28;
      unsigned int Count = mlir::pdl_interp::CheckOperandCountOp::getCount((mlir::pdl_interp::CheckOperandCountOp *)&v49);
      uint64_t v45 = 0;
      uint64_t v46 = 0;
      uint64_t Bias = (void *)mlir::anec::GOC::getBias((mlir::anec::GOC *)&v49);
      v59[0] = (uint64_t **)&v45;
      __b = Bias;
      uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&__b);
      if (result)
      {
        uint64_t result = mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(v59, result);
        if (result)
        {
          v59[0] = (uint64_t **)v60;
          v59[1] = (uint64_t **)0x600000000;
          mlir::getIntValues<long long>(v45, v46, (uint64_t)v59, 1);
          uint64_t v32 = (uint64_t)*v59[0];
          __b = 0;
          uint64_t v54 = 0;
          unsigned int v55 = 0;
          uint64_t v56 = v58;
          uint64_t v57 = 0x600000000;
          mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v47);
          if (v33 >= 1)
          {
            uint64_t v34 = v33;
            uint64_t v35 = 0;
            uint64_t v36 = v32 + Count;
            uint64_t v37 = v36 + v29;
            do
            {
              if (*(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v47)
                             + 8 * v35) == 0x8000000000000000)
              {
                __src = (void *)(v35 >= v36 && v35 <= v37);
                llvm::SetVector<long long,llvm::SmallVector<long long,6u>,llvm::DenseSet<long long,llvm::DenseMapInfo<long long,void>>,2u>::insert((uint64_t)&__b, (uint64_t *)&__src);
              }
              ++v35;
            }
            while (v34 != v35);
          }
          if (!v57)
          {
            __src = (void *)-1;
            llvm::SetVector<long long,llvm::SmallVector<long long,6u>,llvm::DenseSet<long long,llvm::DenseMapInfo<long long,void>>,2u>::insert((uint64_t)&__b, (uint64_t *)&__src);
          }
          if (v54)
          {
            if (v55 <= 4 * (int)v54 || v55 < 0x41)
            {
              if (v55) {
                memset_pattern16(__b, &unk_1811011A0, 8 * v55);
              }
              uint64_t v54 = 0;
            }
            else
            {
              llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::shrink_and_clear((uint64_t)&__b);
            }
          }
          __src = v52;
          uint64_t v51 = 0x600000000;
          unint64_t v38 = v57;
          if (!v57)
          {
LABEL_64:
            uint64_t v42 = (void *)(a2 + 32);
            *(void *)(a2 + 16) = a2 + 32;
            *(void *)a2 = a2 + 16;
            *(void *)(a2 + 8) = 0x100000000;
            *(void *)(a2 + 24) = 0x600000000;
            int v43 = 1;
            if ((void **)(a2 + 16) == &__src || !v38)
            {
LABEL_72:
              *(_DWORD *)(a2 + 8) = v43;
              if (__src != v52) {
                free(__src);
              }
              if (v56 != v58) {
                free(v56);
              }
              llvm::deallocate_buffer((llvm *)__b, (void *)(8 * v55));
            }
            if (v38 < 7)
            {
              unsigned int v44 = v38;
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 16, (void *)(a2 + 32), v38, 8);
              unsigned int v44 = v51;
              if (!v51)
              {
LABEL_71:
                *(_DWORD *)(a2 + 24) = v38;
                int v43 = *(_DWORD *)(a2 + 8) + 1;
                goto LABEL_72;
              }
              uint64_t v42 = *(void **)(a2 + 16);
            }
            memcpy(v42, __src, 8 * v44);
            goto LABEL_71;
          }
          if (v56 != v58)
          {
            __src = v56;
            uint64_t v51 = v57;
            uint64_t v56 = v58;
            HIDWORD(v57) = 0;
LABEL_63:
            LODWORD(v57) = 0;
            goto LABEL_64;
          }
          if (v57 < 7)
          {
            uint64_t v41 = v52;
            uint64_t v40 = v58;
            unsigned int v39 = v57;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v52, v57, 8);
            unsigned int v39 = v57;
            if (!v57)
            {
LABEL_62:
              LODWORD(v51) = v38;
              goto LABEL_63;
            }
            uint64_t v40 = v56;
            uint64_t v41 = __src;
          }
          memcpy(v41, v40, 8 * v39);
          goto LABEL_62;
        }
      }
    }
  }
LABEL_35:
  *(void *)(a2 + 32) = -1;
  *(void *)(a2 + 16) = a2 + 32;
  *(void *)a2 = a2 + 16;
  *(void *)(a2 + 24) = 0x600000001;
  *(void *)(a2 + 8) = 0x100000001;
  return result;
}

uint64_t llvm::SetVector<long long,llvm::SmallVector<long long,6u>,llvm::DenseSet<long long,llvm::DenseMapInfo<long long,void>>,2u>::insert(uint64_t a1, uint64_t *a2)
{
  if (!*(_DWORD *)(a1 + 8))
  {
    uint64_t v13 = a1 + 24;
    uint64_t v14 = *(void **)(a1 + 24);
    uint64_t v15 = *(unsigned int *)(a1 + 32);
    unint64_t v16 = v14;
    if (v15)
    {
      uint64_t v17 = 8 * v15;
      unint64_t v16 = *(void **)(a1 + 24);
      while (*v16 != *a2)
      {
        ++v16;
        v17 -= 8;
        if (!v17)
        {
          unint64_t v16 = &v14[v15];
          break;
        }
      }
    }
    if (v15 != v16 - v14) {
      return 0;
    }
    uint64_t v18 = *a2;
    if (v15 >= *(_DWORD *)(a1 + 36))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v13, (void *)(a1 + 40), v15 + 1, 8);
      uint64_t v15 = *(unsigned int *)(a1 + 32);
      uint64_t v14 = *(void **)(a1 + 24);
    }
    v14[v15] = v18;
    unsigned int v19 = *(_DWORD *)(a1 + 32) + 1;
    *(_DWORD *)(a1 + 32) = v19;
    if (v19 < 3) {
      return 1;
    }
    unint64_t v20 = *(uint64_t **)(a1 + 24);
    uint64_t v21 = &v20[v19];
    while (1)
    {
      int v26 = *(_DWORD *)(a1 + 16);
      if (!v26) {
        break;
      }
      int v22 = v26 - 1;
      unsigned int v23 = (37 * *v20) & v22;
      uint64_t v24 = (uint64_t *)(*(void *)a1 + 8 * v23);
      uint64_t v25 = *v24;
      if (*v20 != *v24)
      {
        uint64_t v28 = 0;
        int v29 = 1;
        while (v25 != 0x7FFFFFFFFFFFFFFFLL)
        {
          if (v28) {
            BOOL v30 = 0;
          }
          else {
            BOOL v30 = v25 == 0x8000000000000000;
          }
          if (v30) {
            uint64_t v28 = v24;
          }
          unsigned int v31 = v23 + v29++;
          unsigned int v23 = v31 & v22;
          uint64_t v24 = (uint64_t *)(*(void *)a1 + 8 * v23);
          uint64_t v25 = *v24;
          if (*v20 == *v24) {
            goto LABEL_24;
          }
        }
        if (v28) {
          uint64_t v27 = v28;
        }
        else {
          uint64_t v27 = v24;
        }
        goto LABEL_27;
      }
LABEL_24:
      if (++v20 == v21) {
        return 1;
      }
    }
    uint64_t v27 = 0;
LABEL_27:
    llvm::DenseMapBase<llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>,long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::InsertIntoBucket<long long const&,llvm::detail::DenseSetEmpty&>(a1, v27, v20);
    goto LABEL_24;
  }
  int v4 = *(_DWORD *)(a1 + 16);
  if (v4)
  {
    int v5 = v4 - 1;
    unsigned int v6 = (37 * *a2) & v5;
    uint64_t v7 = (uint64_t *)(*(void *)a1 + 8 * v6);
    uint64_t v8 = *v7;
    if (*a2 != *v7)
    {
      unint64_t v9 = 0;
      int v10 = 1;
      while (v8 != 0x7FFFFFFFFFFFFFFFLL)
      {
        if (v9) {
          BOOL v11 = 0;
        }
        else {
          BOOL v11 = v8 == 0x8000000000000000;
        }
        if (v11) {
          unint64_t v9 = v7;
        }
        unsigned int v12 = v6 + v10++;
        unsigned int v6 = v12 & v5;
        uint64_t v7 = (uint64_t *)(*(void *)a1 + 8 * v6);
        uint64_t v8 = *v7;
        if (*a2 == *v7) {
          return 0;
        }
      }
      if (v9) {
        uint64_t v33 = v9;
      }
      else {
        uint64_t v33 = v7;
      }
      goto LABEL_42;
    }
    return 0;
  }
  uint64_t v33 = 0;
LABEL_42:
  llvm::DenseMapBase<llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>,long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::InsertIntoBucket<long long const&,llvm::detail::DenseSetEmpty&>(a1, v33, a2);
  uint64_t v34 = *a2;
  uint64_t v35 = *(unsigned int *)(a1 + 32);
  if (v35 >= *(_DWORD *)(a1 + 36))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 24, (void *)(a1 + 40), v35 + 1, 8);
    LODWORD(v35) = *(_DWORD *)(a1 + 32);
  }
  *(void *)(*(void *)(a1 + 24) + 8 * v35) = v34;
  ++*(_DWORD *)(a1 + 32);
  return 1;
}

uint64_t *llvm::DenseMapBase<llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>,long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::InsertIntoBucket<long long const&,llvm::detail::DenseSetEmpty&>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
LABEL_3:
    uint64_t v8 = *a2;
    goto LABEL_4;
  }
  llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::grow(a1, v7);
  uint64_t v8 = *a3;
  int v10 = *(_DWORD *)(a1 + 16) - 1;
  unsigned int v11 = (37 * *a3) & v10;
  a2 = (uint64_t *)(*(void *)a1 + 8 * v11);
  uint64_t v12 = *a2;
  if (*a3 != *a2)
  {
    uint64_t v13 = 0;
    int v14 = 1;
    while (v12 != 0x7FFFFFFFFFFFFFFFLL)
    {
      if (v13) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v12 == 0x8000000000000000;
      }
      if (v15) {
        uint64_t v13 = a2;
      }
      unsigned int v16 = v11 + v14++;
      unsigned int v11 = v16 & v10;
      a2 = (uint64_t *)(*(void *)a1 + 8 * (v16 & v10));
      uint64_t v12 = *a2;
      if (v8 == *a2) {
        goto LABEL_4;
      }
    }
    if (v13) {
      a2 = v13;
    }
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v8 != 0x7FFFFFFFFFFFFFFFLL) {
    --*(_DWORD *)(a1 + 12);
  }
  *a2 = *a3;
  return a2;
}

void llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::shrink_and_clear(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 16);
  int v2 = *(_DWORD *)(a1 + 8);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    int v4 = v3;
  }
  else {
    int v4 = 0;
  }
  if (v4 != v1) {
    llvm::deallocate_buffer(*(llvm **)a1, (void *)(8 * v1));
  }
  *(void *)(a1 + 8) = 0;
  if (v1)
  {
    int v5 = *(llvm **)a1;
    memset_pattern16(v5, &unk_1811011A0, 8 * v1);
  }
}

void *mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::anonymous namespace'::MapMatMulOpInterface>::mapDynamicShape@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v39 = a1;
  int v3 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3) {
    goto LABEL_10;
  }
  uint64_t v4 = *v3;
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *(unsigned int *)(v4 + 16);
  if (!v6) {
    goto LABEL_10;
  }
  unsigned int v7 = *(void **)(v4 + 8);
  uint64_t v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    int v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    unsigned int v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      unsigned int v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_10:
  }
    uint64_t v13 = 0;
  int v14 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v39) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v14) {
    goto LABEL_20;
  }
  uint64_t v15 = *v14;
  unint64_t v16 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v17 = *(unsigned int *)(v15 + 16);
  if (!v17) {
    goto LABEL_20;
  }
  uint64_t v18 = *(void **)(v15 + 8);
  unsigned int v19 = &v18[2 * v17];
  do
  {
    unint64_t v20 = v17 >> 1;
    uint64_t v21 = &v18[2 * (v17 >> 1)];
    unint64_t v23 = *v21;
    int v22 = v21 + 2;
    v17 += ~(v17 >> 1);
    if (v23 < v16) {
      uint64_t v18 = v22;
    }
    else {
      unint64_t v17 = v20;
    }
  }
  while (v17);
  if (v18 != v19 && *v18 == v16) {
    uint64_t v24 = v18[1];
  }
  else {
LABEL_20:
  }
    uint64_t v24 = 0;
  uint64_t v25 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v25) {
    goto LABEL_30;
  }
  uint64_t v26 = *v25;
  unint64_t v27 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v28 = *(unsigned int *)(v26 + 16);
  if (!v28) {
    goto LABEL_30;
  }
  int v29 = *(void **)(v26 + 8);
  BOOL v30 = &v29[2 * v28];
  do
  {
    unint64_t v31 = v28 >> 1;
    uint64_t v32 = &v29[2 * (v28 >> 1)];
    unint64_t v34 = *v32;
    uint64_t v33 = v32 + 2;
    v28 += ~(v28 >> 1);
    if (v34 < v27) {
      int v29 = v33;
    }
    else {
      unint64_t v28 = v31;
    }
  }
  while (v28);
  if (v29 != v30 && *v29 == v27) {
    uint64_t v35 = v29[1];
  }
  else {
LABEL_30:
  }
    uint64_t v35 = 0;
  BOOL IsNegated = mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v39);
  BOOL TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v39);
}

void *mlir::anonymous namespace'::mapMatMulOperands@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int a7@<W6>, int a8@<W7>, uint64_t a9@<X8>)
{
  v43[6] = *MEMORY[0x1E4F143B8];
  v34[0] = a5;
  v34[1] = a6;
  uint64_t result = (void *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v34);
  if (result)
  {
    if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v34)) {
      goto LABEL_8;
    }
    uint64_t result = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v34);
    if (v16)
    {
      uint64_t v17 = 8 * v16;
      while (*result != 0x8000000000000000)
      {
        ++result;
        v17 -= 8;
        if (!v17) {
          goto LABEL_7;
        }
      }
LABEL_8:
      __b = 0;
      uint64_t v39 = 0;
      unsigned int v40 = 0;
      __src = v43;
      uint64_t v42 = 0x600000000;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v34);
      if (v18 >= 1)
      {
        uint64_t v19 = v18;
        uint64_t v20 = 0;
        if (a7) {
          uint64_t v21 = -1;
        }
        else {
          uint64_t v21 = -2;
        }
        uint64_t v32 = v21;
        if (a8) {
          uint64_t v22 = -2;
        }
        else {
          uint64_t v22 = -1;
        }
        do
        {
          if (*(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v34)
                         + 8 * v20) == 0x8000000000000000)
          {
            __dst = a1;
            uint64_t v36 = a2;
            mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__dst);
            uint64_t v24 = v23;
            if (v20 + 2 <= v23
              && *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__dst)
                           + 8 * v20) == 0x8000000000000000
              || v20 == v24 + v32
              && *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__dst)
                           + 8 * v20) == 0x8000000000000000)
            {
              __dst = 0;
              llvm::SetVector<long long,llvm::SmallVector<long long,6u>,llvm::DenseSet<long long,llvm::DenseMapInfo<long long,void>>,2u>::insert((uint64_t)&__b, (uint64_t *)&__dst);
            }
            __dst = a3;
            uint64_t v36 = a4;
            mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__dst);
            uint64_t v26 = v25;
            if (v20 + 2 <= v25
              && *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__dst)
                           + 8 * v20) == 0x8000000000000000
              || v20 == v26 + v22
              && *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__dst)
                           + 8 * v20) == 0x8000000000000000)
            {
              __dst = (void *)1;
              llvm::SetVector<long long,llvm::SmallVector<long long,6u>,llvm::DenseSet<long long,llvm::DenseMapInfo<long long,void>>,2u>::insert((uint64_t)&__b, (uint64_t *)&__dst);
            }
          }
          ++v20;
        }
        while (v19 != v20);
      }
      if (!v42)
      {
        __dst = (void *)-1;
        llvm::SetVector<long long,llvm::SmallVector<long long,6u>,llvm::DenseSet<long long,llvm::DenseMapInfo<long long,void>>,2u>::insert((uint64_t)&__b, (uint64_t *)&__dst);
      }
      if (v39)
      {
        if (v40 <= 4 * (int)v39 || v40 < 0x41)
        {
          if (v40) {
            memset_pattern16(__b, &unk_1811011A0, 8 * v40);
          }
          uint64_t v39 = 0;
        }
        else
        {
          llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::shrink_and_clear((uint64_t)&__b);
        }
      }
      __dst = v37;
      uint64_t v36 = 0x600000000;
      unint64_t v27 = v42;
      if (v42)
      {
        if (__src == v43)
        {
          unsigned int v28 = v42;
          if (v42 < 7
            || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v37, v42, 8),
                (unsigned int v28 = v42) != 0))
          {
            memcpy(__dst, __src, 8 * v28);
          }
          LODWORD(v36) = v27;
        }
        else
        {
          __dst = __src;
          uint64_t v36 = v42;
          __src = v43;
          HIDWORD(v42) = 0;
        }
        LODWORD(v42) = 0;
      }
      int v29 = (void *)(a9 + 32);
      *(void *)(a9 + 16) = a9 + 32;
      *(void *)a9 = a9 + 16;
      *(void *)(a9 + 8) = 0x100000000;
      *(void *)(a9 + 24) = 0x600000000;
      int v30 = 1;
      if ((void **)(a9 + 16) == &__dst || !v27)
      {
LABEL_53:
        *(_DWORD *)(a9 + 8) = v30;
        if (__dst != v37) {
          free(__dst);
        }
        if (__src != v43) {
          free(__src);
        }
        llvm::deallocate_buffer((llvm *)__b, (void *)(8 * v40));
      }
      if (v27 < 7)
      {
        unsigned int v31 = v27;
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a9 + 16, (void *)(a9 + 32), v27, 8);
        unsigned int v31 = v36;
        if (!v36)
        {
LABEL_52:
          *(_DWORD *)(a9 + 24) = v27;
          int v30 = *(_DWORD *)(a9 + 8) + 1;
          goto LABEL_53;
        }
        int v29 = *(void **)(a9 + 16);
      }
      memcpy(v29, __dst, 8 * v31);
      goto LABEL_52;
    }
  }
LABEL_7:
  *(void *)(a9 + 32) = -1;
  *(void *)(a9 + 16) = a9 + 32;
  *(void *)a9 = a9 + 16;
  *(void *)(a9 + 24) = 0x600000001;
  *(void *)(a9 + 8) = 0x100000001;
  return result;
}

void mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::anonymous namespace'::MapExponentOpInterface>::mapDynamicShape(mlir::_anonymous_namespace_ *this@<X1>, uint64_t a2@<X8>)
{
}

void mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::anonymous namespace'::MapNegativeOpInterface>::mapDynamicShape(mlir::_anonymous_namespace_ *this@<X1>, uint64_t a2@<X8>)
{
}

void mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::anonymous namespace'::MapSubtractOpInterface>::mapDynamicShape(mlir::_anonymous_namespace_ *this@<X1>, uint64_t a2@<X8>)
{
}

void mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::anonymous namespace'::MapReciprocalOpInterface>::mapDynamicShape(mlir::_anonymous_namespace_ *this@<X1>, uint64_t a2@<X8>)
{
}

void mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::anonymous namespace'::MapIdentityOpInterface>::mapDynamicShape(mlir::_anonymous_namespace_ *this@<X1>, uint64_t a2@<X8>)
{
}

double mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::anonymous namespace'::MapPermuteOpInterface>::mapDynamicShape@<D0>(void *a1@<X8>)
{
  a1[4] = 0;
  a1[2] = a1 + 4;
  *a1 = a1 + 2;
  a1[3] = 0x600000001;
  *(void *)&double result = 0x100000001;
  a1[1] = 0x100000001;
  return result;
}

void mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::anonymous namespace'::MapReadVariableOpInterface>::mapDynamicShape(mlir::_anonymous_namespace_ *this@<X1>, uint64_t a2@<X8>)
{
}

void mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::anonymous namespace'::MapVariableFromTensorOpInterface>::mapDynamicShape(mlir::_anonymous_namespace_ *this@<X1>, uint64_t a2@<X8>)
{
}

int64x2_t *mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::anonymous namespace'::MapReshapeOpInterface>::mapDynamicShape@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v57 = a1;
  int v3 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v57) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3) {
    goto LABEL_10;
  }
  uint64_t v4 = *v3;
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *(unsigned int *)(v4 + 16);
  if (!v6) {
    goto LABEL_10;
  }
  unsigned int v7 = *(void **)(v4 + 8);
  uint64_t v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    int v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    unsigned int v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      unsigned int v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_10:
  }
    uint64_t v13 = 0;
  *(void *)&long long v56 = v3;
  *((void *)&v56 + 1) = v13;
  int v14 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v57) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v14) {
    goto LABEL_20;
  }
  uint64_t v15 = *v14;
  unint64_t v16 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v17 = *(unsigned int *)(v15 + 16);
  if (!v17) {
    goto LABEL_20;
  }
  uint64_t v18 = *(void **)(v15 + 8);
  uint64_t v19 = &v18[2 * v17];
  do
  {
    unint64_t v20 = v17 >> 1;
    uint64_t v21 = &v18[2 * (v17 >> 1)];
    unint64_t v23 = *v21;
    uint64_t v22 = v21 + 2;
    v17 += ~(v17 >> 1);
    if (v23 < v16) {
      uint64_t v18 = v22;
    }
    else {
      unint64_t v17 = v20;
    }
  }
  while (v17);
  if (v18 != v19 && *v18 == v16) {
    uint64_t v24 = v18[1];
  }
  else {
LABEL_20:
  }
    uint64_t v24 = 0;
  *(void *)&long long v55 = v14;
  *((void *)&v55 + 1) = v24;
  double result = (int64x2_t *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v56);
  if (!result) {
    goto LABEL_41;
  }
  double result = (int64x2_t *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v55);
  if (!result) {
    goto LABEL_41;
  }
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v55))
  {
    double result = (int64x2_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v55);
    if (!v26)
    {
LABEL_41:
      *(void *)(a2 + 32) = -1;
      *(void *)(a2 + 16) = a2 + 32;
      *(void *)a2 = a2 + 16;
      *(_DWORD *)(a2 + 12) = 1;
      *(_DWORD *)(a2 + 28) = 6;
      goto LABEL_42;
    }
    uint64_t v27 = 8 * v26;
    while (result->i64[0] != 0x8000000000000000)
    {
      double result = (int64x2_t *)((char *)result + 8);
      v27 -= 8;
      if (!v27) {
        goto LABEL_41;
      }
    }
  }
  double result = (int64x2_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v56);
  if (v28)
  {
    unint64_t v29 = (v28 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v29 >= 3)
    {
      unint64_t v32 = v29 + 1;
      uint64_t v33 = (v29 + 1) & 0x3FFFFFFFFFFFFFFCLL;
      unsigned int v31 = &result->i64[v33];
      unint64_t v34 = result + 1;
      int64x2_t v35 = 0uLL;
      int64x2_t v36 = vdupq_n_s64(0x8000000000000000);
      uint64_t v37 = v33;
      int64x2_t v38 = 0uLL;
      do
      {
        int64x2_t v35 = vsubq_s64(v35, vceqq_s64(v34[-1], v36));
        int64x2_t v38 = vsubq_s64(v38, vceqq_s64(*v34, v36));
        v34 += 2;
        v37 -= 4;
      }
      while (v37);
      unint64_t v30 = vaddvq_s64(vaddq_s64(v38, v35));
      if (v32 == v33) {
        goto LABEL_40;
      }
    }
    else
    {
      unint64_t v30 = 0;
      unsigned int v31 = (uint64_t *)result;
    }
    do
    {
      uint64_t v39 = *v31++;
      if (v39 == 0x8000000000000000) {
        ++v30;
      }
    }
    while (v31 != (uint64_t *)((char *)result + 8 * v28));
LABEL_40:
    if (v30 >= 2) {
      goto LABEL_41;
    }
  }
  long long v58 = v56;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
  if (v40 >= 1)
  {
    uint64_t v41 = 0;
    char v42 = 0;
    uint64_t v43 = 1;
    uint64_t v44 = 1;
    while (1)
    {
      if (*(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58)
                     + 8 * v41) != 0x8000000000000000)
      {
        uint64_t v46 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58)
                        + 8 * v41);
        if ((v42 & 1) == 0)
        {
          char v42 = 0;
          v44 *= v46;
          goto LABEL_47;
        }
        v43 *= v46;
      }
      char v42 = 1;
LABEL_47:
      ++v41;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
      if (v41 >= v45) {
        goto LABEL_52;
      }
    }
  }
  uint64_t v44 = 1;
  uint64_t v43 = 1;
LABEL_52:
  long long v58 = v55;
  double result = (int64x2_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
  if (v47 >= 1)
  {
    uint64_t v48 = 0;
    char v49 = 0;
    uint64_t v50 = 1;
    uint64_t v51 = 1;
    while (1)
    {
      if (*(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58)
                     + 8 * v48) != 0x8000000000000000)
      {
        uint64_t v53 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58)
                        + 8 * v48);
        if ((v49 & 1) == 0)
        {
          char v49 = 0;
          v51 *= v53;
          goto LABEL_56;
        }
        v50 *= v53;
      }
      char v49 = 1;
LABEL_56:
      ++v48;
      double result = (int64x2_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
      if (v48 >= v52) {
        goto LABEL_61;
      }
    }
  }
  uint64_t v51 = 1;
  uint64_t v50 = 1;
LABEL_61:
  uint64_t v54 = (void *)(a2 + 32);
  *(void *)(a2 + 16) = a2 + 32;
  *(void *)a2 = a2 + 16;
  *(_DWORD *)(a2 + 12) = 1;
  *(_DWORD *)(a2 + 28) = 6;
  if (v44 == v51 && v43 == v50) {
    *uint64_t v54 = 0;
  }
  else {
    *uint64_t v54 = -1;
  }
LABEL_42:
  *(_DWORD *)(a2 + 24) = 1;
  *(_DWORD *)(a2 + 8) = 1;
  return result;
}

void mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::anonymous namespace'::MapStridedSliceOpInterface>::mapDynamicShape(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  v71[4] = *MEMORY[0x1E4F143B8];
  uint64_t v57 = a1;
  int v3 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v57) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3) {
    goto LABEL_10;
  }
  uint64_t v4 = *v3;
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *(unsigned int *)(v4 + 16);
  if (!v6) {
    goto LABEL_10;
  }
  unsigned int v7 = *(void **)(v4 + 8);
  uint64_t v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    int v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    unsigned int v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      unsigned int v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_10:
  }
    uint64_t v13 = 0;
  v56[0] = v3;
  v56[1] = v13;
  int v14 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v57) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v14) {
    goto LABEL_20;
  }
  uint64_t v15 = *v14;
  unint64_t v16 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v17 = *(unsigned int *)(v15 + 16);
  if (!v17) {
    goto LABEL_20;
  }
  uint64_t v18 = *(void **)(v15 + 8);
  uint64_t v19 = &v18[2 * v17];
  do
  {
    unint64_t v20 = v17 >> 1;
    uint64_t v21 = &v18[2 * (v17 >> 1)];
    unint64_t v23 = *v21;
    uint64_t v22 = v21 + 2;
    v17 += ~(v17 >> 1);
    if (v23 < v16) {
      uint64_t v18 = v22;
    }
    else {
      unint64_t v17 = v20;
    }
  }
  while (v17);
  if (v18 != v19 && *v18 == v16) {
    uint64_t v24 = v18[1];
  }
  else {
LABEL_20:
  }
    uint64_t v24 = 0;
  v55[0] = v14;
  v55[1] = v24;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v56)
    || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v55))
  {
    goto LABEL_28;
  }
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v55)) {
    goto LABEL_30;
  }
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55);
  if (!v26)
  {
LABEL_28:
    *(void *)(a2 + 32) = -1;
    *(void *)(a2 + 16) = a2 + 32;
    *(void *)a2 = a2 + 16;
    *(void *)(a2 + 24) = 0x600000001;
    *(void *)(a2 + 8) = 0x100000001;
    return;
  }
  uint64_t v27 = 8 * v26;
  while (*ArgAttrsAttr != 0x8000000000000000)
  {
    ++ArgAttrsAttr;
    v27 -= 8;
    if (!v27) {
      goto LABEL_28;
    }
  }
LABEL_30:
  uint64_t v53 = 0;
  uint64_t v54 = 0;
  uint64_t v51 = 0;
  uint64_t v52 = 0;
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  uint64_t Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v57);
  v58[0] = (uint64_t **)&v53;
  uint64_t v60 = Filter;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v60);
  if (DefiningOp) {
    mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(v58, DefiningOp);
  }
  uint64_t Bias = (void *)mlir::anec::GOC::getBias((mlir::anec::GOC *)&v57);
  v58[0] = (uint64_t **)&v51;
  uint64_t v60 = Bias;
  uint64_t v31 = mlir::Value::getDefiningOp((mlir::Value *)&v60);
  if (v31) {
    mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(v58, v31);
  }
  uint64_t SparseShape = (void *)mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v57);
  v58[0] = (uint64_t **)&v49;
  uint64_t v60 = SparseShape;
  uint64_t v33 = mlir::Value::getDefiningOp((mlir::Value *)&v60);
  if (v33) {
    mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(v58, v33);
  }
  char v69 = v71;
  uint64_t v70 = 0x400000000;
  long long v66 = v68;
  uint64_t v67 = 0x400000000;
  char v63 = v65;
  uint64_t v64 = 0x400000000;
  if (v53) {
    mlir::getIntValues<long long>(v53, v54, (uint64_t)&v69, 1);
  }
  if (v51) {
    mlir::getIntValues<long long>(v51, v52, (uint64_t)&v66, 1);
  }
  if (v49) {
    mlir::getIntValues<long long>(v49, v50, (uint64_t)&v63, 1);
  }
  unsigned int Index = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v57);
  unsigned int Offset = mlir::mps::ReadDataFromFileOp::getOffset((mlir::mps::ReadDataFromFileOp *)&v57);
  unsigned int Groups = mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v57);
  int64x2_t v38 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55);
  uint64_t v39 = v37;
  uint64_t v60 = v62;
  uint64_t v61 = 0x600000000;
  size_t v40 = 8 * v37;
  if ((unint64_t)(8 * v37) >= 0x31)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v62, (8 * v37) >> 3, 8);
    unsigned int v41 = v61;
    if (!v39) {
      goto LABEL_49;
    }
    goto LABEL_48;
  }
  unsigned int v41 = 0;
  if (v37)
  {
LABEL_48:
    memcpy((char *)v60 + 8 * v41, v38, v40);
    unsigned int v41 = v61;
  }
LABEL_49:
  LODWORD(v61) = v41 + (v40 >> 3);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v56);
  if (v42 >= 1)
  {
    uint64_t v43 = 0;
    for (uint64_t i = 0; i < v45; ++i)
    {
      if ((Groups >> i))
      {
        v58[0] = (uint64_t **)1;
        llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v60, (uint64_t)v60 + v43, (uint64_t *)v58);
      }
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v56);
      v43 += 8;
    }
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v56);
  if (v46 < 1)
  {
LABEL_70:
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 16) = a2 + 32;
    *(void *)a2 = a2 + 16;
LABEL_72:
    *(void *)(a2 + 24) = 0x600000001;
    *(void *)(a2 + 8) = 0x100000001;
  }
  else
  {
    unint64_t v47 = 0;
    while (1)
    {
      if (*((void *)v60 + v47) == 0x8000000000000000
        && *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v56)
                     + 8 * v47) == 0x8000000000000000)
      {
        if (v47 >= v64
          || *((void *)v63 + v47) != 1
          || v47 >= v70
          || v69[v47] && ((Index >> v47) & 1) == 0)
        {
          *(void *)(a2 + 32) = -1;
          *(void *)(a2 + 16) = a2 + 32;
          *(void *)a2 = a2 + 16;
          goto LABEL_72;
        }
        if (v47 >= v67 || v66[v47] && ((Offset >> v47) & 1) == 0) {
          break;
        }
      }
      ++v47;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v56);
      if ((uint64_t)v47 >= v48) {
        goto LABEL_70;
      }
    }
    v58[0] = (uint64_t **)&v59;
    v58[1] = (uint64_t **)0x600000000;
    *(void *)(a2 + 16) = a2 + 32;
    uint64_t v59 = -1;
    *(void *)a2 = a2 + 16;
    *(_DWORD *)(a2 + 12) = 1;
    *(void *)(a2 + 24) = 0x600000000;
    if ((uint64_t ***)(a2 + 16) != v58)
    {
      *(void *)(a2 + 32) = v59;
      *(_DWORD *)(a2 + 24) = 1;
    }
    *(_DWORD *)(a2 + 8) = 1;
  }
  if (v60 != v62) {
    free(v60);
  }
  if (v63 != v65) {
    free(v63);
  }
  if (v66 != (void *)v68) {
    free(v66);
  }
  if (v69 != v71) {
    free(v69);
  }
}

double mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::anonymous namespace'::MapStridedSliceUpdateOpInterface>::mapDynamicShape@<D0>(void *a1@<X8>)
{
  a1[4] = 0;
  a1[2] = a1 + 4;
  *a1 = a1 + 2;
  a1[3] = 0x600000001;
  *(void *)&double result = 0x100000001;
  a1[1] = 0x100000001;
  return result;
}

double mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::anonymous namespace'::MapTransposeOpInterface>::mapDynamicShape@<D0>(void *a1@<X8>)
{
  a1[4] = 0;
  a1[2] = a1 + 4;
  *a1 = a1 + 2;
  a1[3] = 0x600000001;
  *(void *)&double result = 0x100000001;
  a1[1] = 0x100000001;
  return result;
}

void mlir::mps::registerMapDynamicShapeOpExternalModels(mlir::DialectRegistry &)::$_1::__invoke(uint64_t *a1)
{
  int v2 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.quantized_matmul", (const unsigned __int8 *)0x15, a1);
  if (!v3)
  {
    __int16 v32 = 1283;
    unint64_t v29 = "Attempting to attach an interface to an unregistered operation ";
    unint64_t v30 = "mpsx.quantized_matmul";
    uint64_t v26 = 21;
    goto LABEL_17;
  }
  uint64_t v4 = v2;
  unint64_t v5 = (void *)v2[2];
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v33[0] = v2[1];
    uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v33);
    unint64_t v5 = (void *)v4[2];
  }
  else
  {
    uint64_t Values = v2[3];
  }
  uint64_t v7 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(Values, (uint64_t)v5, v7);
  uint64_t v8 = malloc(8uLL);
  unint64_t v9 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v4 + 4), v9, v8);
  int v10 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.rms_norm", (const unsigned __int8 *)0xD, a1);
  if (!v11)
  {
    __int16 v32 = 1283;
    unint64_t v29 = "Attempting to attach an interface to an unregistered operation ";
    unint64_t v30 = "mpsx.rms_norm";
    uint64_t v26 = 13;
    goto LABEL_17;
  }
  unint64_t v12 = v10;
  uint64_t v13 = (void *)v10[2];
  if (v13 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v33[0] = v10[1];
    uint64_t v14 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v33);
    uint64_t v13 = (void *)v12[2];
  }
  else
  {
    uint64_t v14 = v10[3];
  }
  uint64_t v15 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v14, (uint64_t)v13, v15);
  unint64_t v16 = malloc(8uLL);
  unint64_t v17 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v12 + 4), v17, v16);
  uint64_t v18 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.sdpa", (const unsigned __int8 *)9, a1);
  if (!v19)
  {
    __int16 v32 = 1283;
    unint64_t v29 = "Attempting to attach an interface to an unregistered operation ";
    unint64_t v30 = "mpsx.sdpa";
    uint64_t v26 = 9;
LABEL_17:
    uint64_t v31 = v26;
    uint64_t v27 = ".";
    __int16 v28 = 259;
    llvm::operator+((uint64_t *)&v29, (uint64_t *)&v27, (uint64_t)v33);
    llvm::report_fatal_error((llvm::Twine *)v33, 1);
  }
  unint64_t v20 = v18;
  uint64_t v21 = (void *)v18[2];
  if (v21 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v33[0] = v18[1];
    uint64_t v22 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v33);
    uint64_t v21 = (void *)v20[2];
  }
  else
  {
    uint64_t v22 = v18[3];
  }
  uint64_t v23 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v22, (uint64_t)v21, v23);
  uint64_t v24 = malloc(8uLL);
  unint64_t v25 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v20 + 4), v25, v24);
}

void *mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::anonymous namespace'::MapQuantizedMatMulOpInterface>::mapDynamicShape@<X0>(mlir::Operation *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v39 = a1;
  char v3 = (uint64_t *)(*(void *)(mlir::mpsx::QuantizedMatMulOp::getInput(&v39) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3) {
    goto LABEL_10;
  }
  uint64_t v4 = *v3;
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *(unsigned int *)(v4 + 16);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *(void **)(v4 + 8);
  uint64_t v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    int v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    char v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      uint64_t v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_10:
  }
    uint64_t v13 = 0;
  uint64_t v14 = (uint64_t *)(*(void *)(mlir::mpsx::QuantizedMatMulOp::getWeights(&v39) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v14) {
    goto LABEL_20;
  }
  uint64_t v15 = *v14;
  unint64_t v16 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v17 = *(unsigned int *)(v15 + 16);
  if (!v17) {
    goto LABEL_20;
  }
  uint64_t v18 = *(void **)(v15 + 8);
  char v19 = &v18[2 * v17];
  do
  {
    unint64_t v20 = v17 >> 1;
    uint64_t v21 = &v18[2 * (v17 >> 1)];
    unint64_t v23 = *v21;
    uint64_t v22 = v21 + 2;
    v17 += ~(v17 >> 1);
    if (v23 < v16) {
      uint64_t v18 = v22;
    }
    else {
      unint64_t v17 = v20;
    }
  }
  while (v17);
  if (v18 != v19 && *v18 == v16) {
    uint64_t v24 = v18[1];
  }
  else {
LABEL_20:
  }
    uint64_t v24 = 0;
  unint64_t v25 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v25) {
    goto LABEL_30;
  }
  uint64_t v26 = *v25;
  unint64_t v27 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v28 = *(unsigned int *)(v26 + 16);
  if (!v28) {
    goto LABEL_30;
  }
  unint64_t v29 = *(void **)(v26 + 8);
  unint64_t v30 = &v29[2 * v28];
  do
  {
    unint64_t v31 = v28 >> 1;
    __int16 v32 = &v29[2 * (v28 >> 1)];
    unint64_t v34 = *v32;
    uint64_t v33 = v32 + 2;
    v28 += ~(v28 >> 1);
    if (v34 < v27) {
      unint64_t v29 = v33;
    }
    else {
      unint64_t v28 = v31;
    }
  }
  while (v28);
  if (v29 != v30 && *v29 == v27) {
    uint64_t v35 = v29[1];
  }
  else {
LABEL_30:
  }
    uint64_t v35 = 0;
  BOOL TransposeLhs = mlir::mpsx::QuantizedMatMulOp::getTransposeLhs(&v39);
  BOOL TransposeRhs = mlir::mpsx::QuantizedMatMulOp::getTransposeRhs(&v39);
}

double mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::anonymous namespace'::MapRMSNormOpInterface>::mapDynamicShape@<D0>(void *a1@<X8>)
{
  a1[4] = 0;
  a1[2] = a1 + 4;
  *a1 = a1 + 2;
  a1[3] = 0x600000001;
  *(void *)&double result = 0x100000001;
  a1[1] = 0x100000001;
  return result;
}

double mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::anonymous namespace'::MapScaledDotProductAttentionOpInterface>::mapDynamicShape@<D0>(void *a1@<X8>)
{
  a1[4] = 0;
  a1[2] = a1 + 4;
  *a1 = a1 + 2;
  a1[3] = 0x600000001;
  *(void *)&double result = 0x100000001;
  a1[1] = 0x100000001;
  return result;
}

void *mlir::DialectRegistry::addExtension<mlir::mpsx::MPSXDialect>(void *a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  double result = operator new(0x68uLL);
  unint64_t v5 = result;
  unint64_t v6 = (void *)a2[3];
  if (v6)
  {
    if (v6 == a2)
    {
      char v11 = v10;
      double result = (void *)(*(uint64_t (**)(void *, void *))(*a2 + 24))(a2, v10);
      unint64_t v6 = v11;
    }
    else
    {
      char v11 = (void *)a2[3];
      a2[3] = 0;
    }
  }
  else
  {
    char v11 = 0;
  }
  v5[3] = "mpsx";
  v5[4] = 4;
  _OWORD v5[2] = 0x300000001;
  *unint64_t v5 = &unk_1EC9D05C8;
  v5[1] = v5 + 3;
  if (v6)
  {
    if (v6 == v10)
    {
      v5[12] = v5 + 9;
      (*(void (**)(void *))(v10[0] + 24))(v10);
      double result = v11;
      if (v11 == v10)
      {
        double result = (void *)(*(uint64_t (**)(void *))(v10[0] + 32))(v10);
      }
      else if (v11)
      {
        double result = (void *)(*(uint64_t (**)(void))(*v11 + 40))();
      }
    }
    else
    {
      v5[12] = v6;
    }
  }
  else
  {
    v5[12] = 0;
  }
  unint64_t v9 = v5;
  uint64_t v7 = (void *)a1[4];
  if ((unint64_t)v7 >= a1[5])
  {
    uint64_t v8 = std::vector<std::unique_ptr<mlir::DialectExtensionBase>>::__push_back_slow_path<std::unique_ptr<mlir::DialectExtensionBase>>(a1 + 3, (uint64_t *)&v9);
    double result = v9;
    a1[4] = v8;
    unint64_t v9 = 0;
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  else
  {
    *uint64_t v7 = v5;
    a1[4] = v7 + 1;
  }
  return result;
}

void mlir::DialectRegistry::addExtension<mlir::mpsx::MPSXDialect>(std::function<void ()(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *)>)::Extension::~Extension(mlir::DialectExtensionBase *this)
{
  *(void *)this = &unk_1EC9D05C8;
  int v2 = (char *)this + 72;
  char v3 = (char *)*((void *)this + 12);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }

  mlir::DialectExtensionBase::~DialectExtensionBase(this);
}

{
  char *v2;
  char *v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1EC9D05C8;
  int v2 = (char *)this + 72;
  char v3 = (char *)*((void *)this + 12);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  mlir::DialectExtensionBase::~DialectExtensionBase(this);

  operator delete(v4);
}

uint64_t mlir::DialectExtension<void mlir::DialectRegistry::addExtension<mlir::mpsx::MPSXDialect>(std::function<void ()(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *)>)::Extension,mlir::mpsx::MPSXDialect>::apply(uint64_t a1, uint64_t a2, void *a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 32))(a1, a2, *a3);
}

void *mlir::DialectExtension<void mlir::DialectRegistry::addExtension<mlir::mpsx::MPSXDialect>(std::function<void ()(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *)>)::Extension,mlir::mpsx::MPSXDialect>::clone@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x68uLL);
  double result = mlir::DialectRegistry::addExtension<mlir::mpsx::MPSXDialect>(std::function<void ()(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *)>)::Extension::Extension(v4, a1);
  *a2 = result;
  return result;
}

void *mlir::DialectRegistry::addExtension<mlir::mpsx::MPSXDialect>(std::function<void ()(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *)>)::Extension::apply(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = a3;
  uint64_t v8 = a2;
  uint64_t v3 = *(void *)(a1 + 96);
  if (v3) {
    return (void *)(*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v3 + 48))(v3, &v8, &v7);
  }
  unint64_t v5 = (void *)std::__throw_bad_function_call[abi:nn180100]();
  return mlir::DialectRegistry::addExtension<mlir::mpsx::MPSXDialect>(std::function<void ()(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *)>)::Extension::Extension(v5, v6);
}

void *mlir::DialectRegistry::addExtension<mlir::mpsx::MPSXDialect>(std::function<void ()(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *)>)::Extension::Extension(void *a1, uint64_t a2)
{
  *a1 = &unk_1EC9AAD88;
  uint64_t v4 = a1 + 3;
  a1[1] = a1 + 3;
  unint64_t v5 = (void **)(a1 + 1);
  a1[2] = 0x300000000;
  if (a1 == (void *)a2) {
    goto LABEL_9;
  }
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  if (!v6) {
    goto LABEL_9;
  }
  if (v6 < 4)
  {
    unsigned int v7 = *(_DWORD *)(a2 + 16);
    goto LABEL_7;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(a1 + 1), v4, *(unsigned int *)(a2 + 16), 16);
  unsigned int v7 = *(_DWORD *)(a2 + 16);
  if (v7)
  {
    uint64_t v4 = *v5;
LABEL_7:
    memcpy(v4, *(const void **)(a2 + 8), 16 * v7);
  }
  *((_DWORD *)a1 + 4) = v6;
LABEL_9:
  *a1 = &unk_1EC9D05C8;
  uint64_t v8 = a1 + 9;
  uint64_t v9 = *(void *)(a2 + 96);
  if (v9)
  {
    if (v9 == a2 + 72)
    {
      a1[12] = v8;
      (*(void (**)(void))(**(void **)(a2 + 96) + 24))(*(void *)(a2 + 96));
    }
    else
    {
      a1[12] = (*(uint64_t (**)(uint64_t, void *))(*(void *)v9 + 16))(v9, v8);
    }
  }
  else
  {
    a1[12] = 0;
  }
  return a1;
}

void *std::__function::__func<void (*)(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *),std::allocator<void (*)(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *)>,void ()(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_1EC9CEA30;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void (*)(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *),std::allocator<void (*)(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *)>,void ()(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EC9CEA30;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void (*)(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *),std::allocator<void (*)(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *)>,void ()(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *)>::operator()(uint64_t a1, void *a2, void *a3)
{
  return (*(uint64_t (**)(void, void))(a1 + 8))(*a2, *a3);
}

void **mlir::mps::registerMPSRuntimeDynamicEncodeOpExternalModels(mlir::mps *this, mlir::DialectRegistry *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (void (**)(void **))&unk_1EC9CE990;
  unint64_t v5 = (void (*)(uint64_t *))mlir::mps::registerMPSRuntimeDynamicEncodeOpExternalModels(mlir::DialectRegistry &)::$_0::__invoke;
  unsigned int v6 = (void **)&v4;
  mlir::DialectRegistry::addExtension<mlir::mps::MPSDialect>(this, &v4);
  if (v6 == (void **)&v4)
  {
    v4[4]((void **)&v4);
  }
  else if (v6)
  {
    (*((void (**)(void))*v6 + 5))();
  }
  uint64_t v4 = (void (**)(void **))&unk_1EC9CEA30;
  unint64_t v5 = mlir::mps::registerMPSRuntimeDynamicEncodeOpExternalModels(mlir::DialectRegistry &)::$_1::__invoke;
  unsigned int v6 = (void **)&v4;
  mlir::DialectRegistry::addExtension<mlir::mpsx::MPSXDialect>(this, &v4);
  double result = v6;
  if (v6 == (void **)&v4) {
    return (void **)((uint64_t (*)(void **))v4[4])((void **)&v4);
  }
  if (v6) {
    return (void **)(*((uint64_t (**)(void))*v6 + 5))();
  }
  return result;
}

void mlir::mps::registerMPSRuntimeDynamicEncodeOpExternalModels(mlir::DialectRegistry &)::$_0::operator()(uint64_t *a1)
{
  uint64_t v2 = "mps.acos";
  uint64_t v3 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.acos", (const unsigned __int8 *)8, a1);
  if (!v4) {
    goto LABEL_838;
  }
  unint64_t v5 = v3;
  unsigned int v6 = (void *)v3[2];
  if (v6 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v3[1];
    uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    unsigned int v6 = (void *)v5[2];
  }
  else
  {
    uint64_t Values = v3[3];
  }
  uint64_t v8 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(Values, (uint64_t)v6, v8);
  uint64_t v9 = malloc(8uLL);
  unint64_t v10 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v5 + 4), v10, v9);
  char v11 = "mps.acosh";
  uint64_t v12 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.acosh", (const unsigned __int8 *)9, a1);
  if (!v13) {
    goto LABEL_839;
  }
  uint64_t v14 = v12;
  uint64_t v15 = (void *)v12[2];
  if (v15 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v12[1];
    uint64_t v16 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    uint64_t v15 = (void *)v14[2];
  }
  else
  {
    uint64_t v16 = v12[3];
  }
  uint64_t v17 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v16, (uint64_t)v15, v17);
  uint64_t v18 = malloc(8uLL);
  unint64_t v19 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v14 + 4), v19, v18);
  uint64_t v2 = "mps.asin";
  unint64_t v20 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.asin", (const unsigned __int8 *)8, a1);
  if (!v21) {
    goto LABEL_838;
  }
  uint64_t v22 = v20;
  unint64_t v23 = (void *)v20[2];
  if (v23 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v20[1];
    uint64_t v24 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    unint64_t v23 = (void *)v22[2];
  }
  else
  {
    uint64_t v24 = v20[3];
  }
  uint64_t v25 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v24, (uint64_t)v23, v25);
  uint64_t v26 = malloc(8uLL);
  unint64_t v27 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v22 + 4), v27, v26);
  char v11 = "mps.asinh";
  unint64_t v28 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.asinh", (const unsigned __int8 *)9, a1);
  if (!v29) {
    goto LABEL_839;
  }
  unint64_t v30 = v28;
  unint64_t v31 = (void *)v28[2];
  if (v31 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v28[1];
    uint64_t v32 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    unint64_t v31 = (void *)v30[2];
  }
  else
  {
    uint64_t v32 = v28[3];
  }
  uint64_t v33 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v32, (uint64_t)v31, v33);
  unint64_t v34 = malloc(8uLL);
  unint64_t v35 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v30 + 4), v35, v34);
  char v11 = "mps.atan2";
  int64x2_t v36 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.atan2", (const unsigned __int8 *)9, a1);
  if (!v37) {
    goto LABEL_839;
  }
  int64x2_t v38 = v36;
  uint64_t v39 = (void *)v36[2];
  if (v39 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v36[1];
    uint64_t v40 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    uint64_t v39 = (void *)v38[2];
  }
  else
  {
    uint64_t v40 = v36[3];
  }
  uint64_t v41 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v40, (uint64_t)v39, v41);
  uint64_t v42 = malloc(8uLL);
  unint64_t v43 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v38 + 4), v43, v42);
  uint64_t v2 = "mps.atan";
  uint64_t v44 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.atan", (const unsigned __int8 *)8, a1);
  if (!v45) {
    goto LABEL_838;
  }
  uint64_t v46 = v44;
  unint64_t v47 = (void *)v44[2];
  if (v47 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v44[1];
    uint64_t v48 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    unint64_t v47 = (void *)v46[2];
  }
  else
  {
    uint64_t v48 = v44[3];
  }
  uint64_t v49 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v48, (uint64_t)v47, v49);
  uint64_t v50 = malloc(8uLL);
  unint64_t v51 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v46 + 4), v51, v50);
  char v11 = "mps.atanh";
  uint64_t v52 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.atanh", (const unsigned __int8 *)9, a1);
  if (!v53) {
    goto LABEL_839;
  }
  uint64_t v54 = v52;
  long long v55 = (void *)v52[2];
  if (v55 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v52[1];
    uint64_t v56 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    long long v55 = (void *)v54[2];
  }
  else
  {
    uint64_t v56 = v52[3];
  }
  uint64_t v57 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v56, (uint64_t)v55, v57);
  long long v58 = malloc(8uLL);
  unint64_t v59 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v54 + 4), v59, v58);
  uint64_t v60 = "mps.absolute";
  uint64_t v61 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.absolute", (const unsigned __int8 *)0xC, a1);
  if (!v62) {
    goto LABEL_843;
  }
  char v63 = v61;
  uint64_t v64 = (void *)v61[2];
  if (v64 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v61[1];
    uint64_t v65 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    uint64_t v64 = (void *)v63[2];
  }
  else
  {
    uint64_t v65 = v61[3];
  }
  uint64_t v66 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v65, (uint64_t)v64, v66);
  uint64_t v67 = malloc(8uLL);
  unint64_t v68 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v63 + 4), v68, v67);
  char v69 = "mps.absolute_square";
  uint64_t v70 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.absolute_square", (const unsigned __int8 *)0x13, a1);
  if (!v71) {
    goto LABEL_849;
  }
  uint64_t v72 = v70;
  uint64_t v73 = (void *)v70[2];
  if (v73 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v70[1];
    uint64_t v74 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    uint64_t v73 = (void *)v72[2];
  }
  else
  {
    uint64_t v74 = v70[3];
  }
  uint64_t v75 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v74, (uint64_t)v73, v75);
  uint64_t v76 = malloc(8uLL);
  unint64_t v77 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v72 + 4), v77, v76);
  uint64_t v78 = "mps.add";
  uint64_t v79 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, a1);
  if (!v80) {
    goto LABEL_842;
  }
  uint64_t v81 = v79;
  unsigned int v82 = (void *)v79[2];
  if (v82 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v79[1];
    uint64_t v83 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    unsigned int v82 = (void *)v81[2];
  }
  else
  {
    uint64_t v83 = v79[3];
  }
  uint64_t v84 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v83, (uint64_t)v82, v84);
  uint64_t v85 = malloc(8uLL);
  unint64_t v86 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v81 + 4), v86, v85);
  uint64_t v78 = "mps.and";
  uint64_t v87 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.and", (const unsigned __int8 *)7, a1);
  if (!v88) {
    goto LABEL_842;
  }
  uint64_t v89 = v87;
  uint64_t v90 = (void *)v87[2];
  if (v90 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v87[1];
    uint64_t v91 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    uint64_t v90 = (void *)v89[2];
  }
  else
  {
    uint64_t v91 = v87[3];
  }
  uint64_t v92 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v91, (uint64_t)v90, v92);
  uint64_t v93 = malloc(8uLL);
  unint64_t v94 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v89 + 4), v94, v93);
  char v69 = "mps.assign_variable";
  char v95 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.assign_variable", (const unsigned __int8 *)0x13, a1);
  if (!v96) {
    goto LABEL_849;
  }
  uint64_t v97 = v95;
  uint64_t v98 = (void *)v95[2];
  if (v98 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v95[1];
    uint64_t v99 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    uint64_t v98 = (void *)v97[2];
  }
  else
  {
    uint64_t v99 = v95[3];
  }
  uint64_t v100 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v99, (uint64_t)v98, v100);
  unint64_t v101 = malloc(8uLL);
  unint64_t v102 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v97 + 4), v102, v101);
  int v103 = "mps.band_part";
  char v104 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.band_part", (const unsigned __int8 *)0xD, a1);
  if (!v105) {
    goto LABEL_844;
  }
  uint64_t v106 = v104;
  uint64_t v107 = (void *)v104[2];
  if (v107 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v104[1];
    uint64_t v108 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    uint64_t v107 = (void *)v106[2];
  }
  else
  {
    uint64_t v108 = v104[3];
  }
  uint64_t v109 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v108, (uint64_t)v107, v109);
  unint64_t v110 = malloc(8uLL);
  unint64_t v111 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v106 + 4), v111, v110);
  char v112 = "mps.bitwise_and";
  uint64_t v113 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.bitwise_and", (const unsigned __int8 *)0xF, a1);
  if (!v114) {
    goto LABEL_847;
  }
  uint64_t v115 = v113;
  uint64_t v116 = (void *)v113[2];
  if (v116 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v113[1];
    uint64_t v117 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    uint64_t v116 = (void *)v115[2];
  }
  else
  {
    uint64_t v117 = v113[3];
  }
  uint64_t v118 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v117, (uint64_t)v116, v118);
  uint64_t v119 = malloc(8uLL);
  unint64_t v120 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v115 + 4), v120, v119);
  uint64_t v121 = "mps.bitwise_left_shift";
  unsigned int v122 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.bitwise_left_shift", (const unsigned __int8 *)0x16, a1);
  if (!v123) {
    goto LABEL_852;
  }
  uint64_t v124 = v122;
  uint64_t v125 = (void *)v122[2];
  if (v125 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v122[1];
    uint64_t v126 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    uint64_t v125 = (void *)v124[2];
  }
  else
  {
    uint64_t v126 = v122[3];
  }
  uint64_t v127 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v126, (uint64_t)v125, v127);
  char v128 = malloc(8uLL);
  unint64_t v129 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v124 + 4), v129, v128);
  char v112 = "mps.bitwise_not";
  unint64_t v130 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.bitwise_not", (const unsigned __int8 *)0xF, a1);
  if (!v131) {
    goto LABEL_847;
  }
  uint64_t v132 = v130;
  uint64_t v133 = (void *)v130[2];
  if (v133 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v130[1];
    uint64_t v134 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    uint64_t v133 = (void *)v132[2];
  }
  else
  {
    uint64_t v134 = v130[3];
  }
  uint64_t v135 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v134, (uint64_t)v133, v135);
  char v136 = malloc(8uLL);
  unint64_t v137 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v132 + 4), v137, v136);
  uint64_t v138 = "mps.bitwise_or";
  uint64_t v139 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.bitwise_or", (const unsigned __int8 *)0xE, a1);
  if (!v140) {
    goto LABEL_850;
  }
  uint64_t v141 = v139;
  unint64_t v142 = (void *)v139[2];
  if (v142 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v139[1];
    uint64_t v143 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    unint64_t v142 = (void *)v141[2];
  }
  else
  {
    uint64_t v143 = v139[3];
  }
  uint64_t v144 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v143, (uint64_t)v142, v144);
  __int16 v145 = malloc(8uLL);
  unint64_t v146 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v141 + 4), v146, v145);
  uint64_t v147 = "mps.bitwise_popcount";
  uint64_t v148 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.bitwise_popcount", (const unsigned __int8 *)0x14, a1);
  if (!v149) {
    goto LABEL_851;
  }
  v150 = v148;
  uint64_t v151 = (void *)v148[2];
  if (v151 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v148[1];
    uint64_t v152 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    uint64_t v151 = (void *)v150[2];
  }
  else
  {
    uint64_t v152 = v148[3];
  }
  uint64_t v153 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v152, (uint64_t)v151, v153);
  uint64_t v154 = malloc(8uLL);
  unint64_t v155 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v150 + 4), v155, v154);
  uint64_t v156 = "mps.bitwise_right_shift";
  uint64_t v157 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.bitwise_right_shift", (const unsigned __int8 *)0x17, a1);
  if (!v158)
  {
LABEL_856:
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = v156;
    uint64_t v1699 = 23;
    goto LABEL_866;
  }
  v159 = v157;
  unint64_t v160 = (void *)v157[2];
  if (v160 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v157[1];
    uint64_t v161 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    unint64_t v160 = (void *)v159[2];
  }
  else
  {
    uint64_t v161 = v157[3];
  }
  uint64_t v162 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v161, (uint64_t)v160, v162);
  unint64_t v163 = malloc(8uLL);
  unint64_t v164 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v159 + 4), v164, v163);
  char v112 = "mps.bitwise_xor";
  v165 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.bitwise_xor", (const unsigned __int8 *)0xF, a1);
  if (!v166) {
    goto LABEL_847;
  }
  uint64_t v167 = v165;
  int32x4_t v168 = (void *)v165[2];
  if (v168 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v165[1];
    uint64_t v169 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    int32x4_t v168 = (void *)v167[2];
  }
  else
  {
    uint64_t v169 = v165[3];
  }
  uint64_t v170 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v169, (uint64_t)v168, v170);
  int32x4_t v171 = malloc(8uLL);
  unint64_t v172 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v167 + 4), v172, v171);
  uint64_t v2 = "mps.cast";
  int v173 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, a1);
  if (!v174) {
    goto LABEL_838;
  }
  v175 = v173;
  v176 = (void *)v173[2];
  if (v176 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v173[1];
    uint64_t v177 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v176 = (void *)v175[2];
  }
  else
  {
    uint64_t v177 = v173[3];
  }
  uint64_t v178 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v177, (uint64_t)v176, v178);
  uint64_t v179 = malloc(8uLL);
  unint64_t v180 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v175 + 4), v180, v179);
  uint64_t v2 = "mps.ceil";
  v181 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.ceil", (const unsigned __int8 *)8, a1);
  if (!v182) {
    goto LABEL_838;
  }
  v183 = v181;
  v184 = (void *)v181[2];
  if (v184 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v181[1];
    uint64_t v185 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v184 = (void *)v183[2];
  }
  else
  {
    uint64_t v185 = v181[3];
  }
  uint64_t v186 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v185, (uint64_t)v184, v186);
  uint64_t v187 = malloc(8uLL);
  unint64_t v188 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v183 + 4), v188, v187);
  char v11 = "mps.clamp";
  v189 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.clamp", (const unsigned __int8 *)9, a1);
  if (!v190) {
    goto LABEL_839;
  }
  v191 = v189;
  v192 = (void *)v189[2];
  if (v192 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v189[1];
    uint64_t v193 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v192 = (void *)v191[2];
  }
  else
  {
    uint64_t v193 = v189[3];
  }
  uint64_t v194 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v193, (uint64_t)v192, v194);
  int v195 = malloc(8uLL);
  unint64_t v196 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v191 + 4), v196, v195);
  int v103 = "mps.col_to_im";
  int v197 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.col_to_im", (const unsigned __int8 *)0xD, a1);
  if (!v198) {
    goto LABEL_844;
  }
  unsigned int v199 = v197;
  v200 = (void *)v197[2];
  if (v200 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v197[1];
    uint64_t v201 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v200 = (void *)v199[2];
  }
  else
  {
    uint64_t v201 = v197[3];
  }
  uint64_t v202 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v201, (uint64_t)v200, v202);
  v203 = malloc(8uLL);
  unint64_t v204 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v199 + 4), v204, v203);
  int v103 = "mps.conjugate";
  v205 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conjugate", (const unsigned __int8 *)0xD, a1);
  if (!v206) {
    goto LABEL_844;
  }
  v207 = v205;
  v208 = (void *)v205[2];
  if (v208 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v205[1];
    uint64_t v209 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v208 = (void *)v207[2];
  }
  else
  {
    uint64_t v209 = v205[3];
  }
  uint64_t v210 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v209, (uint64_t)v208, v210);
  v211 = malloc(8uLL);
  unint64_t v212 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v207 + 4), v212, v211);
  uint64_t v60 = "mps.constant";
  uint64_t v213 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.constant", (const unsigned __int8 *)0xC, a1);
  if (!v214) {
    goto LABEL_843;
  }
  v215 = v213;
  uint64_t v216 = (void *)v213[2];
  if (v216 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v213[1];
    uint64_t v217 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    uint64_t v216 = (void *)v215[2];
  }
  else
  {
    uint64_t v217 = v213[3];
  }
  uint64_t v218 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v217, (uint64_t)v216, v218);
  uint64_t v219 = malloc(8uLL);
  unint64_t v220 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v215 + 4), v220, v219);
  uint64_t v221 = "mps.conv_2d";
  v222 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_2d", (const unsigned __int8 *)0xB, a1);
  if (!v223) {
    goto LABEL_840;
  }
  v224 = v222;
  v225 = (void *)v222[2];
  if (v225 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v222[1];
    uint64_t v226 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v225 = (void *)v224[2];
  }
  else
  {
    uint64_t v226 = v222[3];
  }
  uint64_t v227 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v226, (uint64_t)v225, v227);
  v228 = malloc(8uLL);
  unint64_t v229 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v224 + 4), v229, v228);
  uint64_t v221 = "mps.conv_3d";
  v230 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_3d", (const unsigned __int8 *)0xB, a1);
  if (!v231) {
    goto LABEL_840;
  }
  v232 = v230;
  v233 = (void *)v230[2];
  if (v233 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v230[1];
    uint64_t v234 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v233 = (void *)v232[2];
  }
  else
  {
    uint64_t v234 = v230[3];
  }
  uint64_t v235 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v234, (uint64_t)v233, v235);
  v236 = malloc(8uLL);
  unint64_t v237 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v232 + 4), v237, v236);
  uint64_t v78 = "mps.cos";
  v238 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cos", (const unsigned __int8 *)7, a1);
  if (!v239) {
    goto LABEL_842;
  }
  v240 = v238;
  v241 = (void *)v238[2];
  if (v241 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v238[1];
    uint64_t v242 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v241 = (void *)v240[2];
  }
  else
  {
    uint64_t v242 = v238[3];
  }
  uint64_t v243 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v242, (uint64_t)v241, v243);
  v244 = malloc(8uLL);
  unint64_t v245 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v240 + 4), v245, v244);
  uint64_t v2 = "mps.cosh";
  v246 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cosh", (const unsigned __int8 *)8, a1);
  if (!v247) {
    goto LABEL_838;
  }
  v248 = v246;
  v249 = (void *)v246[2];
  if (v249 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v246[1];
    uint64_t v250 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v249 = (void *)v248[2];
  }
  else
  {
    uint64_t v250 = v246[3];
  }
  uint64_t v251 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v250, (uint64_t)v249, v251);
  v252 = malloc(8uLL);
  unint64_t v253 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v248 + 4), v253, v252);
  char v112 = "mps.cost_volume";
  v254 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cost_volume", (const unsigned __int8 *)0xF, a1);
  if (!v255) {
    goto LABEL_847;
  }
  v256 = v254;
  v257 = (void *)v254[2];
  if (v257 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v254[1];
    uint64_t v258 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v257 = (void *)v256[2];
  }
  else
  {
    uint64_t v258 = v254[3];
  }
  uint64_t v259 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v258, (uint64_t)v257, v259);
  v260 = malloc(8uLL);
  unint64_t v261 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v256 + 4), v261, v260);
  v262 = "mps.create_complex";
  v263 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.create_complex", (const unsigned __int8 *)0x12, a1);
  if (!v264) {
    goto LABEL_841;
  }
  v265 = v263;
  v266 = (void *)v263[2];
  if (v266 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v263[1];
    uint64_t v267 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v266 = (void *)v265[2];
  }
  else
  {
    uint64_t v267 = v263[3];
  }
  uint64_t v268 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v267, (uint64_t)v266, v268);
  v269 = malloc(8uLL);
  unint64_t v270 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v265 + 4), v270, v269);
  char v112 = "mps.crop_resize";
  v271 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.crop_resize", (const unsigned __int8 *)0xF, a1);
  if (!v272)
  {
LABEL_847:
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = v112;
LABEL_848:
    uint64_t v1699 = 15;
    goto LABEL_866;
  }
  v273 = v271;
  v274 = (void *)v271[2];
  if (v274 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v271[1];
    uint64_t v275 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v274 = (void *)v273[2];
  }
  else
  {
    uint64_t v275 = v271[3];
  }
  uint64_t v276 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v275, (uint64_t)v274, v276);
  v277 = malloc(8uLL);
  unint64_t v278 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v273 + 4), v278, v277);
  v279 = "mps.depthwise_conv_2d";
  v280 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_2d", (const unsigned __int8 *)0x15, a1);
  if (!v281) {
    goto LABEL_853;
  }
  v282 = v280;
  v283 = (void *)v280[2];
  if (v283 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v280[1];
    uint64_t v284 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v283 = (void *)v282[2];
  }
  else
  {
    uint64_t v284 = v280[3];
  }
  uint64_t v285 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v284, (uint64_t)v283, v285);
  v286 = malloc(8uLL);
  unint64_t v287 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v282 + 4), v287, v286);
  v279 = "mps.depthwise_conv_3d";
  v288 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_3d", (const unsigned __int8 *)0x15, a1);
  if (!v289) {
    goto LABEL_853;
  }
  v290 = v288;
  v291 = (void *)v288[2];
  if (v291 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v288[1];
    uint64_t v292 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v291 = (void *)v290[2];
  }
  else
  {
    uint64_t v292 = v288[3];
  }
  uint64_t v293 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v292, (uint64_t)v291, v293);
  v294 = malloc(8uLL);
  unint64_t v295 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v290 + 4), v295, v294);
  v262 = "mps.dequantize_lut";
  v296 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dequantize_lut", (const unsigned __int8 *)0x12, a1);
  if (!v297) {
    goto LABEL_841;
  }
  v298 = v296;
  v299 = (void *)v296[2];
  if (v299 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v296[1];
    uint64_t v300 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v299 = (void *)v298[2];
  }
  else
  {
    uint64_t v300 = v296[3];
  }
  uint64_t v301 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v300, (uint64_t)v299, v301);
  v302 = malloc(8uLL);
  unint64_t v303 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v298 + 4), v303, v302);
  uint64_t v138 = "mps.dequantize";
  v304 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dequantize", (const unsigned __int8 *)0xE, a1);
  if (!v305) {
    goto LABEL_850;
  }
  v306 = v304;
  v307 = (void *)v304[2];
  if (v307 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v304[1];
    uint64_t v308 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v307 = (void *)v306[2];
  }
  else
  {
    uint64_t v308 = v304[3];
  }
  uint64_t v309 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v308, (uint64_t)v307, v309);
  v310 = malloc(8uLL);
  unint64_t v311 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v306 + 4), v311, v310);
  v312 = "mps.divide";
  v313 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.divide", (const unsigned __int8 *)0xA, a1);
  if (!v314) {
    goto LABEL_846;
  }
  v315 = v313;
  v316 = (void *)v313[2];
  if (v316 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v313[1];
    uint64_t v317 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v316 = (void *)v315[2];
  }
  else
  {
    uint64_t v317 = v313[3];
  }
  uint64_t v318 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v317, (uint64_t)v316, v318);
  v319 = malloc(8uLL);
  unint64_t v320 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v315 + 4), v320, v319);
  uint64_t v121 = "mps.dynamic_shape_cast";
  v321 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dynamic_shape_cast", (const unsigned __int8 *)0x16, a1);
  if (!v322) {
    goto LABEL_852;
  }
  v323 = v321;
  v324 = (void *)v321[2];
  if (v324 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v321[1];
    uint64_t v325 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v324 = (void *)v323[2];
  }
  else
  {
    uint64_t v325 = v321[3];
  }
  uint64_t v326 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v325, (uint64_t)v324, v326);
  v327 = malloc(8uLL);
  unint64_t v328 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v323 + 4), v328, v327);
  uint64_t v78 = "mps.elu";
  v329 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.elu", (const unsigned __int8 *)7, a1);
  if (!v330) {
    goto LABEL_842;
  }
  v331 = v329;
  v332 = (void *)v329[2];
  if (v332 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v329[1];
    uint64_t v333 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v332 = (void *)v331[2];
  }
  else
  {
    uint64_t v333 = v329[3];
  }
  uint64_t v334 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v333, (uint64_t)v332, v334);
  v335 = malloc(8uLL);
  unint64_t v336 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v331 + 4), v336, v335);
  char v11 = "mps.equal";
  v337 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.equal", (const unsigned __int8 *)9, a1);
  if (!v338) {
    goto LABEL_839;
  }
  v339 = v337;
  v340 = (void *)v337[2];
  if (v340 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v337[1];
    uint64_t v341 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v340 = (void *)v339[2];
  }
  else
  {
    uint64_t v341 = v337[3];
  }
  uint64_t v342 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v341, (uint64_t)v340, v342);
  v343 = malloc(8uLL);
  unint64_t v344 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v339 + 4), v344, v343);
  uint64_t v78 = "mps.erf";
  v345 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.erf", (const unsigned __int8 *)7, a1);
  if (!v346) {
    goto LABEL_842;
  }
  v347 = v345;
  v348 = (void *)v345[2];
  if (v348 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v345[1];
    uint64_t v349 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v348 = (void *)v347[2];
  }
  else
  {
    uint64_t v349 = v345[3];
  }
  uint64_t v350 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v349, (uint64_t)v348, v350);
  v351 = malloc(8uLL);
  unint64_t v352 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v347 + 4), v352, v351);
  uint64_t v147 = "mps.exponent_base_10";
  v353 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.exponent_base_10", (const unsigned __int8 *)0x14, a1);
  if (!v354) {
    goto LABEL_851;
  }
  v355 = v353;
  v356 = (void *)v353[2];
  if (v356 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v353[1];
    uint64_t v357 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v356 = (void *)v355[2];
  }
  else
  {
    uint64_t v357 = v353[3];
  }
  uint64_t v358 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v357, (uint64_t)v356, v358);
  v359 = malloc(8uLL);
  unint64_t v360 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v355 + 4), v360, v359);
  char v69 = "mps.exponent_base_2";
  v361 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.exponent_base_2", (const unsigned __int8 *)0x13, a1);
  if (!v362) {
    goto LABEL_849;
  }
  v363 = v361;
  v364 = (void *)v361[2];
  if (v364 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v361[1];
    uint64_t v365 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v364 = (void *)v363[2];
  }
  else
  {
    uint64_t v365 = v361[3];
  }
  uint64_t v366 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v365, (uint64_t)v364, v366);
  v367 = malloc(8uLL);
  unint64_t v368 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v363 + 4), v368, v367);
  uint64_t v60 = "mps.exponent";
  v369 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.exponent", (const unsigned __int8 *)0xC, a1);
  if (!v370) {
    goto LABEL_843;
  }
  v371 = v369;
  v372 = (void *)v369[2];
  if (v372 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v369[1];
    uint64_t v373 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v372 = (void *)v371[2];
  }
  else
  {
    uint64_t v373 = v369[3];
  }
  uint64_t v374 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v373, (uint64_t)v372, v374);
  v375 = malloc(8uLL);
  unint64_t v376 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v371 + 4), v376, v375);
  v377 = "mps.floor_divide";
  v378 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.floor_divide", (const unsigned __int8 *)0x10, a1);
  if (!v379) {
    goto LABEL_854;
  }
  v380 = v378;
  v381 = (void *)v378[2];
  if (v381 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v378[1];
    uint64_t v382 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v381 = (void *)v380[2];
  }
  else
  {
    uint64_t v382 = v378[3];
  }
  uint64_t v383 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v382, (uint64_t)v381, v383);
  v384 = malloc(8uLL);
  unint64_t v385 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v380 + 4), v385, v384);
  char v11 = "mps.floor";
  v386 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.floor", (const unsigned __int8 *)9, a1);
  if (!v387) {
    goto LABEL_839;
  }
  v388 = v386;
  v389 = (void *)v386[2];
  if (v389 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v386[1];
    uint64_t v390 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v389 = (void *)v388[2];
  }
  else
  {
    uint64_t v390 = v386[3];
  }
  uint64_t v391 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v390, (uint64_t)v389, v391);
  v392 = malloc(8uLL);
  unint64_t v393 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v388 + 4), v393, v392);
  v377 = "mps.gru_gradient";
  v394 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.gru_gradient", (const unsigned __int8 *)0x10, a1);
  if (!v395) {
    goto LABEL_854;
  }
  v396 = v394;
  v397 = (void *)v394[2];
  if (v397 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v394[1];
    uint64_t v398 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v397 = (void *)v396[2];
  }
  else
  {
    uint64_t v398 = v394[3];
  }
  uint64_t v399 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v398, (uint64_t)v397, v399);
  v400 = malloc(8uLL);
  unint64_t v401 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v396 + 4), v401, v400);
  uint64_t v78 = "mps.gru";
  v402 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.gru", (const unsigned __int8 *)7, a1);
  if (!v403) {
    goto LABEL_842;
  }
  v404 = v402;
  v405 = (void *)v402[2];
  if (v405 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v402[1];
    uint64_t v406 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v405 = (void *)v404[2];
  }
  else
  {
    uint64_t v406 = v402[3];
  }
  uint64_t v407 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v406, (uint64_t)v405, v407);
  v408 = malloc(8uLL);
  unint64_t v409 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v404 + 4), v409, v408);
  int v103 = "mps.gather_nd";
  v410 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.gather_nd", (const unsigned __int8 *)0xD, a1);
  if (!v411) {
    goto LABEL_844;
  }
  v412 = v410;
  v413 = (void *)v410[2];
  if (v413 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v410[1];
    uint64_t v414 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v413 = (void *)v412[2];
  }
  else
  {
    uint64_t v414 = v410[3];
  }
  uint64_t v415 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v414, (uint64_t)v413, v415);
  v416 = malloc(8uLL);
  unint64_t v417 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v412 + 4), v417, v416);
  uint64_t v2 = "mps.gelu";
  v418 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.gelu", (const unsigned __int8 *)8, a1);
  if (!v419) {
    goto LABEL_838;
  }
  v420 = v418;
  v421 = (void *)v418[2];
  if (v421 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v418[1];
    uint64_t v422 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v421 = (void *)v420[2];
  }
  else
  {
    uint64_t v422 = v418[3];
  }
  uint64_t v423 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v422, (uint64_t)v421, v423);
  v424 = malloc(8uLL);
  unint64_t v425 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v420 + 4), v425, v424);
  uint64_t v221 = "mps.greater";
  v426 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.greater", (const unsigned __int8 *)0xB, a1);
  if (!v427)
  {
LABEL_840:
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = v221;
    uint64_t v1699 = 11;
    goto LABEL_866;
  }
  v428 = v426;
  v429 = (void *)v426[2];
  if (v429 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v426[1];
    uint64_t v430 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v429 = (void *)v428[2];
  }
  else
  {
    uint64_t v430 = v426[3];
  }
  uint64_t v431 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v430, (uint64_t)v429, v431);
  v432 = malloc(8uLL);
  unint64_t v433 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v428 + 4), v433, v432);
  v434 = "mps.greater_equal";
  v435 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.greater_equal", (const unsigned __int8 *)0x11, a1);
  if (!v436) {
    goto LABEL_845;
  }
  v437 = v435;
  v438 = (void *)v435[2];
  if (v438 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v435[1];
    uint64_t v439 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v438 = (void *)v437[2];
  }
  else
  {
    uint64_t v439 = v435[3];
  }
  uint64_t v440 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v439, (uint64_t)v438, v440);
  v441 = malloc(8uLL);
  unint64_t v442 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v437 + 4), v442, v441);
  uint64_t v147 = "mps.hamming_distance";
  v443 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.hamming_distance", (const unsigned __int8 *)0x14, a1);
  if (!v444) {
    goto LABEL_851;
  }
  v445 = v443;
  v446 = (void *)v443[2];
  if (v446 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v443[1];
    uint64_t v447 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v446 = (void *)v445[2];
  }
  else
  {
    uint64_t v447 = v443[3];
  }
  uint64_t v448 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v447, (uint64_t)v446, v448);
  v449 = malloc(8uLL);
  unint64_t v450 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v445 + 4), v450, v449);
  uint64_t v60 = "mps.identity";
  v451 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.identity", (const unsigned __int8 *)0xC, a1);
  if (!v452) {
    goto LABEL_843;
  }
  v453 = v451;
  v454 = (void *)v451[2];
  if (v454 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v451[1];
    uint64_t v455 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v454 = (void *)v453[2];
  }
  else
  {
    uint64_t v455 = v451[3];
  }
  uint64_t v456 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v455, (uint64_t)v454, v456);
  v457 = malloc(8uLL);
  unint64_t v458 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v453 + 4), v458, v457);
  int v103 = "mps.im_to_col";
  v459 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.im_to_col", (const unsigned __int8 *)0xD, a1);
  if (!v460) {
    goto LABEL_844;
  }
  v461 = v459;
  v462 = (void *)v459[2];
  if (v462 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v459[1];
    uint64_t v463 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v462 = (void *)v461[2];
  }
  else
  {
    uint64_t v463 = v459[3];
  }
  uint64_t v464 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v463, (uint64_t)v462, v464);
  v465 = malloc(8uLL);
  unint64_t v466 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v461 + 4), v466, v465);
  v262 = "mps.imaginary_part";
  v467 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.imaginary_part", (const unsigned __int8 *)0x12, a1);
  if (!v468) {
    goto LABEL_841;
  }
  v469 = v467;
  v470 = (void *)v467[2];
  if (v470 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v467[1];
    uint64_t v471 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v470 = (void *)v469[2];
  }
  else
  {
    uint64_t v471 = v467[3];
  }
  uint64_t v472 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v471, (uint64_t)v470, v472);
  v473 = malloc(8uLL);
  unint64_t v474 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v469 + 4), v474, v473);
  int v103 = "mps.is_finite";
  v475 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.is_finite", (const unsigned __int8 *)0xD, a1);
  if (!v476) {
    goto LABEL_844;
  }
  v477 = v475;
  v478 = (void *)v475[2];
  if (v478 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v475[1];
    uint64_t v479 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v478 = (void *)v477[2];
  }
  else
  {
    uint64_t v479 = v475[3];
  }
  uint64_t v480 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v479, (uint64_t)v478, v480);
  v481 = malloc(8uLL);
  unint64_t v482 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v477 + 4), v482, v481);
  char v112 = "mps.is_infinite";
  v483 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.is_infinite", (const unsigned __int8 *)0xF, a1);
  if (!v484) {
    goto LABEL_847;
  }
  v485 = v483;
  v486 = (void *)v483[2];
  if (v486 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v483[1];
    uint64_t v487 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v486 = (void *)v485[2];
  }
  else
  {
    uint64_t v487 = v483[3];
  }
  uint64_t v488 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v487, (uint64_t)v486, v488);
  v489 = malloc(8uLL);
  unint64_t v490 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v485 + 4), v490, v489);
  v312 = "mps.is_nan";
  v491 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.is_nan", (const unsigned __int8 *)0xA, a1);
  if (!v492) {
    goto LABEL_846;
  }
  v493 = v491;
  v494 = (void *)v491[2];
  if (v494 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v491[1];
    uint64_t v495 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v494 = (void *)v493[2];
  }
  else
  {
    uint64_t v495 = v491[3];
  }
  uint64_t v496 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v495, (uint64_t)v494, v496);
  v497 = malloc(8uLL);
  unint64_t v498 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v493 + 4), v498, v497);
  v434 = "mps.lstm_gradient";
  v499 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.lstm_gradient", (const unsigned __int8 *)0x11, a1);
  if (!v500) {
    goto LABEL_845;
  }
  v501 = v499;
  v502 = (void *)v499[2];
  if (v502 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v499[1];
    uint64_t v503 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v502 = (void *)v501[2];
  }
  else
  {
    uint64_t v503 = v499[3];
  }
  uint64_t v504 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v503, (uint64_t)v502, v504);
  v505 = malloc(8uLL);
  unint64_t v506 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v501 + 4), v506, v505);
  uint64_t v2 = "mps.lstm";
  v507 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.lstm", (const unsigned __int8 *)8, a1);
  if (!v508) {
    goto LABEL_838;
  }
  v509 = v507;
  v510 = (void *)v507[2];
  if (v510 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v507[1];
    uint64_t v511 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v510 = (void *)v509[2];
  }
  else
  {
    uint64_t v511 = v507[3];
  }
  uint64_t v512 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v511, (uint64_t)v510, v512);
  v513 = malloc(8uLL);
  unint64_t v514 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v509 + 4), v514, v513);
  uint64_t v138 = "mps.leaky_relu";
  v515 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.leaky_relu", (const unsigned __int8 *)0xE, a1);
  if (!v516) {
    goto LABEL_850;
  }
  v517 = v515;
  v518 = (void *)v515[2];
  if (v518 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v515[1];
    uint64_t v519 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v518 = (void *)v517[2];
  }
  else
  {
    uint64_t v519 = v515[3];
  }
  uint64_t v520 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v519, (uint64_t)v518, v520);
  v521 = malloc(8uLL);
  unint64_t v522 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v517 + 4), v522, v521);
  uint64_t v2 = "mps.less";
  v523 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.less", (const unsigned __int8 *)8, a1);
  if (!v524) {
    goto LABEL_838;
  }
  v525 = v523;
  v526 = (void *)v523[2];
  if (v526 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v523[1];
    uint64_t v527 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v526 = (void *)v525[2];
  }
  else
  {
    uint64_t v527 = v523[3];
  }
  uint64_t v528 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v527, (uint64_t)v526, v528);
  v529 = malloc(8uLL);
  unint64_t v530 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v525 + 4), v530, v529);
  uint64_t v138 = "mps.less_equal";
  v531 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.less_equal", (const unsigned __int8 *)0xE, a1);
  if (!v532)
  {
LABEL_850:
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = v138;
    uint64_t v1699 = 14;
    goto LABEL_866;
  }
  v533 = v531;
  v534 = (void *)v531[2];
  if (v534 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v531[1];
    uint64_t v535 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v534 = (void *)v533[2];
  }
  else
  {
    uint64_t v535 = v531[3];
  }
  uint64_t v536 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v535, (uint64_t)v534, v536);
  v537 = malloc(8uLL);
  unint64_t v538 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v533 + 4), v538, v537);
  v539 = "mps.local_convolution_data_gradient";
  v540 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.local_convolution_data_gradient", (const unsigned __int8 *)0x23, a1);
  if (!v541) {
    goto LABEL_859;
  }
  v542 = v540;
  v543 = (void *)v540[2];
  if (v543 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v540[1];
    uint64_t v544 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v543 = (void *)v542[2];
  }
  else
  {
    uint64_t v544 = v540[3];
  }
  uint64_t v545 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v544, (uint64_t)v543, v545);
  v546 = malloc(8uLL);
  unint64_t v547 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v542 + 4), v547, v546);
  v279 = "mps.local_convolution";
  v548 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.local_convolution", (const unsigned __int8 *)0x15, a1);
  if (!v549) {
    goto LABEL_853;
  }
  v550 = v548;
  v551 = (void *)v548[2];
  if (v551 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v548[1];
    uint64_t v552 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v551 = (void *)v550[2];
  }
  else
  {
    uint64_t v552 = v548[3];
  }
  uint64_t v553 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v552, (uint64_t)v551, v553);
  v554 = malloc(8uLL);
  unint64_t v555 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v550 + 4), v555, v554);
  v556 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.local_convolution_weight_gradient", (const unsigned __int8 *)0x25, a1);
  if (!v557)
  {
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = "mps.local_convolution_weight_gradient";
    uint64_t v1699 = 37;
    goto LABEL_866;
  }
  v558 = v556;
  v559 = (void *)v556[2];
  if (v559 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v556[1];
    uint64_t v560 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v559 = (void *)v558[2];
  }
  else
  {
    uint64_t v560 = v556[3];
  }
  uint64_t v561 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v560, (uint64_t)v559, v561);
  v562 = malloc(8uLL);
  unint64_t v563 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v558 + 4), v563, v562);
  v279 = "mps.logarithm_base_10";
  v564 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.logarithm_base_10", (const unsigned __int8 *)0x15, a1);
  if (!v565) {
    goto LABEL_853;
  }
  v566 = v564;
  v567 = (void *)v564[2];
  if (v567 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v564[1];
    uint64_t v568 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v567 = (void *)v566[2];
  }
  else
  {
    uint64_t v568 = v564[3];
  }
  uint64_t v569 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v568, (uint64_t)v567, v569);
  v570 = malloc(8uLL);
  unint64_t v571 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v566 + 4), v571, v570);
  uint64_t v147 = "mps.logarithm_base_2";
  v572 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.logarithm_base_2", (const unsigned __int8 *)0x14, a1);
  if (!v573) {
    goto LABEL_851;
  }
  v574 = v572;
  v575 = (void *)v572[2];
  if (v575 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v572[1];
    uint64_t v576 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v575 = (void *)v574[2];
  }
  else
  {
    uint64_t v576 = v572[3];
  }
  uint64_t v577 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v576, (uint64_t)v575, v577);
  v578 = malloc(8uLL);
  unint64_t v579 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v574 + 4), v579, v578);
  int v103 = "mps.logarithm";
  v580 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.logarithm", (const unsigned __int8 *)0xD, a1);
  if (!v581) {
    goto LABEL_844;
  }
  v582 = v580;
  v583 = (void *)v580[2];
  if (v583 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v580[1];
    uint64_t v584 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v583 = (void *)v582[2];
  }
  else
  {
    uint64_t v584 = v580[3];
  }
  uint64_t v585 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v584, (uint64_t)v583, v585);
  v586 = malloc(8uLL);
  unint64_t v587 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v582 + 4), v587, v586);
  v312 = "mps.matmul";
  v588 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.matmul", (const unsigned __int8 *)0xA, a1);
  if (!v589) {
    goto LABEL_846;
  }
  v590 = v588;
  v591 = (void *)v588[2];
  if (v591 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v588[1];
    uint64_t v592 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v591 = (void *)v590[2];
  }
  else
  {
    uint64_t v592 = v588[3];
  }
  uint64_t v593 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v592, (uint64_t)v591, v593);
  v594 = malloc(8uLL);
  unint64_t v595 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v590 + 4), v595, v594);
  uint64_t v221 = "mps.maximum";
  v596 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.maximum", (const unsigned __int8 *)0xB, a1);
  if (!v597) {
    goto LABEL_840;
  }
  v598 = v596;
  v599 = (void *)v596[2];
  if (v599 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v596[1];
    uint64_t v600 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v599 = (void *)v598[2];
  }
  else
  {
    uint64_t v600 = v596[3];
  }
  uint64_t v601 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v600, (uint64_t)v599, v601);
  v602 = malloc(8uLL);
  unint64_t v603 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v598 + 4), v603, v602);
  uint64_t v221 = "mps.minimum";
  v604 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.minimum", (const unsigned __int8 *)0xB, a1);
  if (!v605) {
    goto LABEL_840;
  }
  v606 = v604;
  v607 = (void *)v604[2];
  if (v607 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v604[1];
    uint64_t v608 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v607 = (void *)v606[2];
  }
  else
  {
    uint64_t v608 = v604[3];
  }
  uint64_t v609 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v608, (uint64_t)v607, v609);
  v610 = malloc(8uLL);
  unint64_t v611 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v606 + 4), v611, v610);
  v312 = "mps.modulo";
  v612 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.modulo", (const unsigned __int8 *)0xA, a1);
  if (!v613)
  {
LABEL_846:
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = v312;
    uint64_t v1699 = 10;
    goto LABEL_866;
  }
  v614 = v612;
  v615 = (void *)v612[2];
  if (v615 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v612[1];
    uint64_t v616 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v615 = (void *)v614[2];
  }
  else
  {
    uint64_t v616 = v612[3];
  }
  uint64_t v617 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v616, (uint64_t)v615, v617);
  v618 = malloc(8uLL);
  unint64_t v619 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v614 + 4), v619, v618);
  uint64_t v60 = "mps.multiply";
  v620 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, a1);
  if (!v621) {
    goto LABEL_843;
  }
  v622 = v620;
  v623 = (void *)v620[2];
  if (v623 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v620[1];
    uint64_t v624 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v623 = (void *)v622[2];
  }
  else
  {
    uint64_t v624 = v620[3];
  }
  uint64_t v625 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v624, (uint64_t)v623, v625);
  v626 = malloc(8uLL);
  unint64_t v627 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v622 + 4), v627, v626);
  v312 = "mps.n_relu";
  v628 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.n_relu", (const unsigned __int8 *)0xA, a1);
  if (!v629) {
    goto LABEL_846;
  }
  v630 = v628;
  v631 = (void *)v628[2];
  if (v631 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v628[1];
    uint64_t v632 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v631 = (void *)v630[2];
  }
  else
  {
    uint64_t v632 = v628[3];
  }
  uint64_t v633 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v632, (uint64_t)v631, v633);
  v634 = malloc(8uLL);
  unint64_t v635 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v630 + 4), v635, v634);
  uint64_t v2 = "mps.nand";
  v636 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.nand", (const unsigned __int8 *)8, a1);
  if (!v637) {
    goto LABEL_838;
  }
  v638 = v636;
  v639 = (void *)v636[2];
  if (v639 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v636[1];
    uint64_t v640 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v639 = (void *)v638[2];
  }
  else
  {
    uint64_t v640 = v636[3];
  }
  uint64_t v641 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v640, (uint64_t)v639, v641);
  v642 = malloc(8uLL);
  unint64_t v643 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v638 + 4), v643, v642);
  uint64_t v60 = "mps.negative";
  v644 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.negative", (const unsigned __int8 *)0xC, a1);
  if (!v645)
  {
LABEL_843:
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = v60;
    uint64_t v1699 = 12;
    goto LABEL_866;
  }
  v646 = v644;
  v647 = (void *)v644[2];
  if (v647 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v644[1];
    uint64_t v648 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v647 = (void *)v646[2];
  }
  else
  {
    uint64_t v648 = v644[3];
  }
  uint64_t v649 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v648, (uint64_t)v647, v649);
  v650 = malloc(8uLL);
  unint64_t v651 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v646 + 4), v651, v650);
  uint64_t v78 = "mps.nor";
  v652 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.nor", (const unsigned __int8 *)7, a1);
  if (!v653) {
    goto LABEL_842;
  }
  v654 = v652;
  v655 = (void *)v652[2];
  if (v655 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v652[1];
    uint64_t v656 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v655 = (void *)v654[2];
  }
  else
  {
    uint64_t v656 = v652[3];
  }
  uint64_t v657 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v656, (uint64_t)v655, v657);
  v658 = malloc(8uLL);
  unint64_t v659 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v654 + 4), v659, v658);
  int v103 = "mps.not_equal";
  v660 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.not_equal", (const unsigned __int8 *)0xD, a1);
  if (!v661) {
    goto LABEL_844;
  }
  v662 = v660;
  v663 = (void *)v660[2];
  if (v663 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v660[1];
    uint64_t v664 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v663 = (void *)v662[2];
  }
  else
  {
    uint64_t v664 = v660[3];
  }
  uint64_t v665 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v664, (uint64_t)v663, v665);
  v666 = malloc(8uLL);
  unint64_t v667 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v662 + 4), v667, v666);
  uint64_t v78 = "mps.not";
  v668 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.not", (const unsigned __int8 *)7, a1);
  if (!v669) {
    goto LABEL_842;
  }
  v670 = v668;
  v671 = (void *)v668[2];
  if (v671 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v668[1];
    uint64_t v672 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v671 = (void *)v670[2];
  }
  else
  {
    uint64_t v672 = v668[3];
  }
  uint64_t v673 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v672, (uint64_t)v671, v673);
  v674 = malloc(8uLL);
  unint64_t v675 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v670 + 4), v675, v674);
  v676 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.or", (const unsigned __int8 *)6, a1);
  if (!v677)
  {
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = "mps.or";
    uint64_t v1699 = 6;
LABEL_866:
    uint64_t v1704 = v1699;
    v1700 = ".";
    __int16 v1701 = 259;
    llvm::operator+((uint64_t *)&v1702, (uint64_t *)&v1700, (uint64_t)v1706);
    llvm::report_fatal_error((llvm::Twine *)v1706, 1);
  }
  v678 = v676;
  v679 = (void *)v676[2];
  if (v679 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v676[1];
    uint64_t v680 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v679 = (void *)v678[2];
  }
  else
  {
    uint64_t v680 = v676[3];
  }
  uint64_t v681 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v680, (uint64_t)v679, v681);
  v682 = malloc(8uLL);
  unint64_t v683 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v678 + 4), v683, v682);
  char v11 = "mps.prelu";
  v684 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.prelu", (const unsigned __int8 *)9, a1);
  if (!v685) {
    goto LABEL_839;
  }
  v686 = v684;
  v687 = (void *)v684[2];
  if (v687 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v684[1];
    uint64_t v688 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v687 = (void *)v686[2];
  }
  else
  {
    uint64_t v688 = v684[3];
  }
  uint64_t v689 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v688, (uint64_t)v687, v689);
  v690 = malloc(8uLL);
  unint64_t v691 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v686 + 4), v691, v690);
  v692 = "mps.pooling_average_gradient";
  v693 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_average_gradient", (const unsigned __int8 *)0x1C, a1);
  if (!v694) {
    goto LABEL_855;
  }
  v695 = v693;
  v696 = (void *)v693[2];
  if (v696 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v693[1];
    uint64_t v697 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v696 = (void *)v695[2];
  }
  else
  {
    uint64_t v697 = v693[3];
  }
  uint64_t v698 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v697, (uint64_t)v696, v698);
  v699 = malloc(8uLL);
  unint64_t v700 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v695 + 4), v700, v699);
  char v69 = "mps.pooling_average";
  v701 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_average", (const unsigned __int8 *)0x13, a1);
  if (!v702) {
    goto LABEL_849;
  }
  v703 = v701;
  v704 = (void *)v701[2];
  if (v704 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v701[1];
    uint64_t v705 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v704 = (void *)v703[2];
  }
  else
  {
    uint64_t v705 = v701[3];
  }
  uint64_t v706 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v705, (uint64_t)v704, v706);
  v707 = malloc(8uLL);
  unint64_t v708 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v703 + 4), v708, v707);
  v692 = "mps.pooling_l2_norm_gradient";
  v709 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_l2_norm_gradient", (const unsigned __int8 *)0x1C, a1);
  if (!v710) {
    goto LABEL_855;
  }
  v711 = v709;
  v712 = (void *)v709[2];
  if (v712 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v709[1];
    uint64_t v713 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v712 = (void *)v711[2];
  }
  else
  {
    uint64_t v713 = v709[3];
  }
  uint64_t v714 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v713, (uint64_t)v712, v714);
  v715 = malloc(8uLL);
  unint64_t v716 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v711 + 4), v716, v715);
  char v69 = "mps.pooling_l2_norm";
  v717 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_l2_norm", (const unsigned __int8 *)0x13, a1);
  if (!v718) {
    goto LABEL_849;
  }
  v719 = v717;
  v720 = (void *)v717[2];
  if (v720 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v717[1];
    uint64_t v721 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v720 = (void *)v719[2];
  }
  else
  {
    uint64_t v721 = v717[3];
  }
  uint64_t v722 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v721, (uint64_t)v720, v722);
  v723 = malloc(8uLL);
  unint64_t v724 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v719 + 4), v724, v723);
  v725 = "mps.pooling_max_gradient";
  v726 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_max_gradient", (const unsigned __int8 *)0x18, a1);
  if (!v727) {
    goto LABEL_861;
  }
  v728 = v726;
  v729 = (void *)v726[2];
  if (v729 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v726[1];
    uint64_t v730 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v729 = (void *)v728[2];
  }
  else
  {
    uint64_t v730 = v726[3];
  }
  uint64_t v731 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v730, (uint64_t)v729, v731);
  v732 = malloc(8uLL);
  unint64_t v733 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v728 + 4), v733, v732);
  char v112 = "mps.pooling_max";
  v734 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_max", (const unsigned __int8 *)0xF, a1);
  if (!v735) {
    goto LABEL_847;
  }
  v736 = v734;
  v737 = (void *)v734[2];
  if (v737 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v734[1];
    uint64_t v738 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v737 = (void *)v736[2];
  }
  else
  {
    uint64_t v738 = v734[3];
  }
  uint64_t v739 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v738, (uint64_t)v737, v739);
  v740 = malloc(8uLL);
  unint64_t v741 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v736 + 4), v741, v740);
  char v11 = "mps.power";
  v742 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.power", (const unsigned __int8 *)9, a1);
  if (!v743) {
    goto LABEL_839;
  }
  v744 = v742;
  v745 = (void *)v742[2];
  if (v745 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v742[1];
    uint64_t v746 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v745 = (void *)v744[2];
  }
  else
  {
    uint64_t v746 = v742[3];
  }
  uint64_t v747 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v746, (uint64_t)v745, v747);
  v748 = malloc(8uLL);
  unint64_t v749 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v744 + 4), v749, v748);
  v262 = "mps.prune_gradient";
  v750 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.prune_gradient", (const unsigned __int8 *)0x12, a1);
  if (!v751) {
    goto LABEL_841;
  }
  v752 = v750;
  v753 = (void *)v750[2];
  if (v753 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v750[1];
    uint64_t v754 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v753 = (void *)v752[2];
  }
  else
  {
    uint64_t v754 = v750[3];
  }
  uint64_t v755 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v754, (uint64_t)v753, v755);
  v756 = malloc(8uLL);
  unint64_t v757 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v752 + 4), v757, v756);
  char v11 = "mps.prune";
  v758 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.prune", (const unsigned __int8 *)9, a1);
  if (!v759) {
    goto LABEL_839;
  }
  v760 = v758;
  v761 = (void *)v758[2];
  if (v761 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v758[1];
    uint64_t v762 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v761 = (void *)v760[2];
  }
  else
  {
    uint64_t v762 = v758[3];
  }
  uint64_t v763 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v762, (uint64_t)v761, v763);
  v764 = malloc(8uLL);
  unint64_t v765 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v760 + 4), v765, v764);
  uint64_t v60 = "mps.quantize";
  v766 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.quantize", (const unsigned __int8 *)0xC, a1);
  if (!v767) {
    goto LABEL_843;
  }
  v768 = v766;
  v769 = (void *)v766[2];
  if (v769 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v766[1];
    uint64_t v770 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v769 = (void *)v768[2];
  }
  else
  {
    uint64_t v770 = v766[3];
  }
  uint64_t v771 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v770, (uint64_t)v769, v771);
  v772 = malloc(8uLL);
  unint64_t v773 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v768 + 4), v773, v772);
  uint64_t v156 = "mps.read_data_from_file";
  v774 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.read_data_from_file", (const unsigned __int8 *)0x17, a1);
  if (!v775) {
    goto LABEL_856;
  }
  v776 = v774;
  v777 = (void *)v774[2];
  if (v777 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v774[1];
    uint64_t v778 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v777 = (void *)v776[2];
  }
  else
  {
    uint64_t v778 = v774[3];
  }
  uint64_t v779 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v778, (uint64_t)v777, v779);
  v780 = malloc(8uLL);
  unint64_t v781 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v776 + 4), v781, v780);
  v434 = "mps.read_variable";
  v782 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.read_variable", (const unsigned __int8 *)0x11, a1);
  if (!v783) {
    goto LABEL_845;
  }
  v784 = v782;
  v785 = (void *)v782[2];
  if (v785 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v782[1];
    uint64_t v786 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v785 = (void *)v784[2];
  }
  else
  {
    uint64_t v786 = v782[3];
  }
  uint64_t v787 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v786, (uint64_t)v785, v787);
  v788 = malloc(8uLL);
  unint64_t v789 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v784 + 4), v789, v788);
  int v103 = "mps.real_part";
  v790 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.real_part", (const unsigned __int8 *)0xD, a1);
  if (!v791) {
    goto LABEL_844;
  }
  v792 = v790;
  v793 = (void *)v790[2];
  if (v793 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v790[1];
    uint64_t v794 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v793 = (void *)v792[2];
  }
  else
  {
    uint64_t v794 = v790[3];
  }
  uint64_t v795 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v794, (uint64_t)v793, v795);
  v796 = malloc(8uLL);
  unint64_t v797 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v792 + 4), v797, v796);
  uint64_t v138 = "mps.reciprocal";
  v798 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reciprocal", (const unsigned __int8 *)0xE, a1);
  if (!v799) {
    goto LABEL_850;
  }
  v800 = v798;
  v801 = (void *)v798[2];
  if (v801 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v798[1];
    uint64_t v802 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v801 = (void *)v800[2];
  }
  else
  {
    uint64_t v802 = v798[3];
  }
  uint64_t v803 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v802, (uint64_t)v801, v803);
  v804 = malloc(8uLL);
  unint64_t v805 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v800 + 4), v805, v804);
  v806 = "mps.reciprocal_square_root";
  v807 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reciprocal_square_root", (const unsigned __int8 *)0x1A, a1);
  if (!v808) {
    goto LABEL_860;
  }
  v809 = v807;
  v810 = (void *)v807[2];
  if (v810 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v807[1];
    uint64_t v811 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v810 = (void *)v809[2];
  }
  else
  {
    uint64_t v811 = v807[3];
  }
  uint64_t v812 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v811, (uint64_t)v810, v812);
  v813 = malloc(8uLL);
  unint64_t v814 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v809 + 4), v814, v813);
  uint64_t v147 = "mps.reinterpret_cast";
  v815 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reinterpret_cast", (const unsigned __int8 *)0x14, a1);
  if (!v816) {
    goto LABEL_851;
  }
  v817 = v815;
  v818 = (void *)v815[2];
  if (v818 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v815[1];
    uint64_t v819 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v818 = (void *)v817[2];
  }
  else
  {
    uint64_t v819 = v815[3];
  }
  uint64_t v820 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v819, (uint64_t)v818, v820);
  v821 = malloc(8uLL);
  unint64_t v822 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v817 + 4), v822, v821);
  char v11 = "mps.relu6";
  v823 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.relu6", (const unsigned __int8 *)9, a1);
  if (!v824) {
    goto LABEL_839;
  }
  v825 = v823;
  v826 = (void *)v823[2];
  if (v826 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v823[1];
    uint64_t v827 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v826 = (void *)v825[2];
  }
  else
  {
    uint64_t v827 = v823[3];
  }
  uint64_t v828 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v827, (uint64_t)v826, v828);
  v829 = malloc(8uLL);
  unint64_t v830 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v825 + 4), v830, v829);
  int v103 = "mps.relu_grad";
  v831 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.relu_grad", (const unsigned __int8 *)0xD, a1);
  if (!v832) {
    goto LABEL_844;
  }
  v833 = v831;
  v834 = (void *)v831[2];
  if (v834 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v831[1];
    uint64_t v835 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v834 = (void *)v833[2];
  }
  else
  {
    uint64_t v835 = v831[3];
  }
  uint64_t v836 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v835, (uint64_t)v834, v836);
  v837 = malloc(8uLL);
  unint64_t v838 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v833 + 4), v838, v837);
  uint64_t v2 = "mps.relu";
  v839 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.relu", (const unsigned __int8 *)8, a1);
  if (!v840) {
    goto LABEL_838;
  }
  v841 = v839;
  v842 = (void *)v839[2];
  if (v842 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v839[1];
    uint64_t v843 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v842 = (void *)v841[2];
  }
  else
  {
    uint64_t v843 = v839[3];
  }
  uint64_t v844 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v843, (uint64_t)v842, v844);
  v845 = malloc(8uLL);
  unint64_t v846 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v841 + 4), v846, v845);
  uint64_t v2 = "mps.rint";
  v847 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.rint", (const unsigned __int8 *)8, a1);
  if (!v848) {
    goto LABEL_838;
  }
  v849 = v847;
  v850 = (void *)v847[2];
  if (v850 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v847[1];
    uint64_t v851 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v850 = (void *)v849[2];
  }
  else
  {
    uint64_t v851 = v847[3];
  }
  uint64_t v852 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v851, (uint64_t)v850, v852);
  v853 = malloc(8uLL);
  unint64_t v854 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v849 + 4), v854, v853);
  char v11 = "mps.round";
  v855 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.round", (const unsigned __int8 *)9, a1);
  if (!v856)
  {
LABEL_839:
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = v11;
    uint64_t v1699 = 9;
    goto LABEL_866;
  }
  v857 = v855;
  v858 = (void *)v855[2];
  if (v858 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v855[1];
    uint64_t v859 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v858 = (void *)v857[2];
  }
  else
  {
    uint64_t v859 = v855[3];
  }
  uint64_t v860 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v859, (uint64_t)v858, v860);
  v861 = malloc(8uLL);
  unint64_t v862 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v857 + 4), v862, v861);
  uint64_t v138 = "mps.scatter_nd";
  v863 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.scatter_nd", (const unsigned __int8 *)0xE, a1);
  if (!v864) {
    goto LABEL_850;
  }
  v865 = v863;
  v866 = (void *)v863[2];
  if (v866 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v863[1];
    uint64_t v867 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v866 = (void *)v865[2];
  }
  else
  {
    uint64_t v867 = v863[3];
  }
  uint64_t v868 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v867, (uint64_t)v866, v868);
  v869 = malloc(8uLL);
  unint64_t v870 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v865 + 4), v870, v869);
  v312 = "mps.select";
  v871 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.select", (const unsigned __int8 *)0xA, a1);
  if (!v872) {
    goto LABEL_846;
  }
  v873 = v871;
  v874 = (void *)v871[2];
  if (v874 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v871[1];
    uint64_t v875 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v874 = (void *)v873[2];
  }
  else
  {
    uint64_t v875 = v871[3];
  }
  uint64_t v876 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v875, (uint64_t)v874, v876);
  v877 = malloc(8uLL);
  unint64_t v878 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v873 + 4), v878, v877);
  uint64_t v2 = "mps.sign";
  v879 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sign", (const unsigned __int8 *)8, a1);
  if (!v880) {
    goto LABEL_838;
  }
  v881 = v879;
  v882 = (void *)v879[2];
  if (v882 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v879[1];
    uint64_t v883 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v882 = (void *)v881[2];
  }
  else
  {
    uint64_t v883 = v879[3];
  }
  uint64_t v884 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v883, (uint64_t)v882, v884);
  v885 = malloc(8uLL);
  unint64_t v886 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v881 + 4), v886, v885);
  uint64_t v221 = "mps.signbit";
  v887 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.signbit", (const unsigned __int8 *)0xB, a1);
  if (!v888) {
    goto LABEL_840;
  }
  v889 = v887;
  v890 = (void *)v887[2];
  if (v890 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v887[1];
    uint64_t v891 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v890 = (void *)v889[2];
  }
  else
  {
    uint64_t v891 = v887[3];
  }
  uint64_t v892 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v891, (uint64_t)v890, v892);
  v893 = malloc(8uLL);
  unint64_t v894 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v889 + 4), v894, v893);
  uint64_t v78 = "mps.sin";
  v895 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sin", (const unsigned __int8 *)7, a1);
  if (!v896) {
    goto LABEL_842;
  }
  v897 = v895;
  v898 = (void *)v895[2];
  if (v898 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v895[1];
    uint64_t v899 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v898 = (void *)v897[2];
  }
  else
  {
    uint64_t v899 = v895[3];
  }
  uint64_t v900 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v899, (uint64_t)v898, v900);
  v901 = malloc(8uLL);
  unint64_t v902 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v897 + 4), v902, v901);
  v903 = "mps.singlegate_rnn_gradient";
  v904 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.singlegate_rnn_gradient", (const unsigned __int8 *)0x1B, a1);
  if (!v905) {
    goto LABEL_858;
  }
  v906 = v904;
  v907 = (void *)v904[2];
  if (v907 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v904[1];
    uint64_t v908 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v907 = (void *)v906[2];
  }
  else
  {
    uint64_t v908 = v904[3];
  }
  uint64_t v909 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v908, (uint64_t)v907, v909);
  v910 = malloc(8uLL);
  unint64_t v911 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v906 + 4), v911, v910);
  v262 = "mps.singlegate_rnn";
  v912 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.singlegate_rnn", (const unsigned __int8 *)0x12, a1);
  if (!v913) {
    goto LABEL_841;
  }
  v914 = v912;
  v915 = (void *)v912[2];
  if (v915 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v912[1];
    uint64_t v916 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v915 = (void *)v914[2];
  }
  else
  {
    uint64_t v916 = v912[3];
  }
  uint64_t v917 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v916, (uint64_t)v915, v917);
  v918 = malloc(8uLL);
  unint64_t v919 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v914 + 4), v919, v918);
  uint64_t v2 = "mps.sinh";
  v920 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sinh", (const unsigned __int8 *)8, a1);
  if (!v921) {
    goto LABEL_838;
  }
  v922 = v920;
  v923 = (void *)v920[2];
  if (v923 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v920[1];
    uint64_t v924 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v923 = (void *)v922[2];
  }
  else
  {
    uint64_t v924 = v920[3];
  }
  uint64_t v925 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v924, (uint64_t)v923, v925);
  v926 = malloc(8uLL);
  unint64_t v927 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v922 + 4), v927, v926);
  uint64_t v60 = "mps.softplus";
  v928 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.softplus", (const unsigned __int8 *)0xC, a1);
  if (!v929) {
    goto LABEL_843;
  }
  v930 = v928;
  v931 = (void *)v928[2];
  if (v931 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v928[1];
    uint64_t v932 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v931 = (void *)v930[2];
  }
  else
  {
    uint64_t v932 = v928[3];
  }
  uint64_t v933 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v932, (uint64_t)v931, v933);
  v934 = malloc(8uLL);
  unint64_t v935 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v930 + 4), v935, v934);
  uint64_t v156 = "mps.softplus_parametric";
  v936 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.softplus_parametric", (const unsigned __int8 *)0x17, a1);
  if (!v937) {
    goto LABEL_856;
  }
  v938 = v936;
  v939 = (void *)v936[2];
  if (v939 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v936[1];
    uint64_t v940 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v939 = (void *)v938[2];
  }
  else
  {
    uint64_t v940 = v936[3];
  }
  uint64_t v941 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v940, (uint64_t)v939, v941);
  v942 = malloc(8uLL);
  unint64_t v943 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v938 + 4), v943, v942);
  uint64_t v60 = "mps.softsign";
  v944 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.softsign", (const unsigned __int8 *)0xC, a1);
  if (!v945) {
    goto LABEL_843;
  }
  v946 = v944;
  v947 = (void *)v944[2];
  if (v947 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v944[1];
    uint64_t v948 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v947 = (void *)v946[2];
  }
  else
  {
    uint64_t v948 = v944[3];
  }
  uint64_t v949 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v948, (uint64_t)v947, v949);
  v950 = malloc(8uLL);
  unint64_t v951 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v946 + 4), v951, v950);
  v312 = "mps.square";
  v952 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.square", (const unsigned __int8 *)0xA, a1);
  if (!v953) {
    goto LABEL_846;
  }
  v954 = v952;
  v955 = (void *)v952[2];
  if (v955 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v952[1];
    uint64_t v956 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v955 = (void *)v954[2];
  }
  else
  {
    uint64_t v956 = v952[3];
  }
  uint64_t v957 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v956, (uint64_t)v955, v957);
  v958 = malloc(8uLL);
  unint64_t v959 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v954 + 4), v959, v958);
  char v112 = "mps.square_root";
  v960 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.square_root", (const unsigned __int8 *)0xF, a1);
  if (!v961) {
    goto LABEL_847;
  }
  v962 = v960;
  v963 = (void *)v960[2];
  if (v963 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v960[1];
    uint64_t v964 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v963 = (void *)v962[2];
  }
  else
  {
    uint64_t v964 = v960[3];
  }
  uint64_t v965 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v964, (uint64_t)v963, v965);
  v966 = malloc(8uLL);
  unint64_t v967 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v962 + 4), v967, v966);
  uint64_t v221 = "mps.stencil";
  v968 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.stencil", (const unsigned __int8 *)0xB, a1);
  if (!v969) {
    goto LABEL_840;
  }
  v970 = v968;
  v971 = (void *)v968[2];
  if (v971 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v968[1];
    uint64_t v972 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v971 = (void *)v970[2];
  }
  else
  {
    uint64_t v972 = v968[3];
  }
  uint64_t v973 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v972, (uint64_t)v971, v973);
  v974 = malloc(8uLL);
  unint64_t v975 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v970 + 4), v975, v974);
  uint64_t v60 = "mps.subtract";
  v976 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.subtract", (const unsigned __int8 *)0xC, a1);
  if (!v977) {
    goto LABEL_843;
  }
  v978 = v976;
  v979 = (void *)v976[2];
  if (v979 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v976[1];
    uint64_t v980 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v979 = (void *)v978[2];
  }
  else
  {
    uint64_t v980 = v976[3];
  }
  uint64_t v981 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v980, (uint64_t)v979, v981);
  v982 = malloc(8uLL);
  unint64_t v983 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v978 + 4), v983, v982);
  char v11 = "mps.swish";
  v984 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.swish", (const unsigned __int8 *)9, a1);
  if (!v985) {
    goto LABEL_839;
  }
  v986 = v984;
  v987 = (void *)v984[2];
  if (v987 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v984[1];
    uint64_t v988 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v987 = (void *)v986[2];
  }
  else
  {
    uint64_t v988 = v984[3];
  }
  uint64_t v989 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v988, (uint64_t)v987, v989);
  v990 = malloc(8uLL);
  unint64_t v991 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v986 + 4), v991, v990);
  uint64_t v78 = "mps.tan";
  v992 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.tan", (const unsigned __int8 *)7, a1);
  if (!v993) {
    goto LABEL_842;
  }
  v994 = v992;
  v995 = (void *)v992[2];
  if (v995 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v992[1];
    uint64_t v996 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v995 = (void *)v994[2];
  }
  else
  {
    uint64_t v996 = v992[3];
  }
  uint64_t v997 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v996, (uint64_t)v995, v997);
  v998 = malloc(8uLL);
  unint64_t v999 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v994 + 4), v999, v998);
  uint64_t v2 = "mps.tanh";
  v1000 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.tanh", (const unsigned __int8 *)8, a1);
  if (!v1001) {
    goto LABEL_838;
  }
  v1002 = v1000;
  v1003 = (void *)v1000[2];
  if (v1003 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1000[1];
    uint64_t v1004 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1003 = (void *)v1002[2];
  }
  else
  {
    uint64_t v1004 = v1000[3];
  }
  uint64_t v1005 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1004, (uint64_t)v1003, v1005);
  v1006 = malloc(8uLL);
  unint64_t v1007 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1002 + 4), v1007, v1006);
  uint64_t v60 = "mps.truncate";
  v1008 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.truncate", (const unsigned __int8 *)0xC, a1);
  if (!v1009) {
    goto LABEL_843;
  }
  v1010 = v1008;
  v1011 = (void *)v1008[2];
  if (v1011 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1008[1];
    uint64_t v1012 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1011 = (void *)v1010[2];
  }
  else
  {
    uint64_t v1012 = v1008[3];
  }
  uint64_t v1013 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1012, (uint64_t)v1011, v1013);
  v1014 = malloc(8uLL);
  unint64_t v1015 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1010 + 4), v1015, v1014);
  char v69 = "mps.type_constraint";
  v1016 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.type_constraint", (const unsigned __int8 *)0x13, a1);
  if (!v1017) {
    goto LABEL_849;
  }
  v1018 = v1016;
  v1019 = (void *)v1016[2];
  if (v1019 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1016[1];
    uint64_t v1020 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1019 = (void *)v1018[2];
  }
  else
  {
    uint64_t v1020 = v1016[3];
  }
  uint64_t v1021 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1020, (uint64_t)v1019, v1021);
  v1022 = malloc(8uLL);
  unint64_t v1023 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1018 + 4), v1023, v1022);
  v725 = "mps.variable_from_tensor";
  v1024 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.variable_from_tensor", (const unsigned __int8 *)0x18, a1);
  if (!v1025) {
    goto LABEL_861;
  }
  v1026 = v1024;
  v1027 = (void *)v1024[2];
  if (v1027 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1024[1];
    uint64_t v1028 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1027 = (void *)v1026[2];
  }
  else
  {
    uint64_t v1028 = v1024[3];
  }
  uint64_t v1029 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1028, (uint64_t)v1027, v1029);
  v1030 = malloc(8uLL);
  unint64_t v1031 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1026 + 4), v1031, v1030);
  uint64_t v2 = "mps.xnor";
  v1032 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.xnor", (const unsigned __int8 *)8, a1);
  if (!v1033) {
    goto LABEL_838;
  }
  v1034 = v1032;
  v1035 = (void *)v1032[2];
  if (v1035 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1032[1];
    uint64_t v1036 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1035 = (void *)v1034[2];
  }
  else
  {
    uint64_t v1036 = v1032[3];
  }
  uint64_t v1037 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1036, (uint64_t)v1035, v1037);
  v1038 = malloc(8uLL);
  unint64_t v1039 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1034 + 4), v1039, v1038);
  uint64_t v78 = "mps.xor";
  v1040 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.xor", (const unsigned __int8 *)7, a1);
  if (!v1041) {
    goto LABEL_842;
  }
  v1042 = v1040;
  v1043 = (void *)v1040[2];
  if (v1043 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1040[1];
    uint64_t v1044 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1043 = (void *)v1042[2];
  }
  else
  {
    uint64_t v1044 = v1040[3];
  }
  uint64_t v1045 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1044, (uint64_t)v1043, v1045);
  v1046 = malloc(8uLL);
  unint64_t v1047 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1042 + 4), v1047, v1046);
  v377 = "mps.broadcast_to";
  v1048 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.broadcast_to", (const unsigned __int8 *)0x10, a1);
  if (!v1049) {
    goto LABEL_854;
  }
  v1050 = v1048;
  v1051 = (void *)v1048[2];
  if (v1051 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1048[1];
    uint64_t v1052 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1051 = (void *)v1050[2];
  }
  else
  {
    uint64_t v1052 = v1048[3];
  }
  uint64_t v1053 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1052, (uint64_t)v1051, v1053);
  v1054 = malloc(8uLL);
  unint64_t v1055 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1050 + 4), v1055, v1054);
  v312 = "mps.concat";
  v1056 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.concat", (const unsigned __int8 *)0xA, a1);
  if (!v1057) {
    goto LABEL_846;
  }
  v1058 = v1056;
  v1059 = (void *)v1056[2];
  if (v1059 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1056[1];
    uint64_t v1060 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1059 = (void *)v1058[2];
  }
  else
  {
    uint64_t v1060 = v1056[3];
  }
  uint64_t v1061 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1060, (uint64_t)v1059, v1061);
  v1062 = malloc(8uLL);
  unint64_t v1063 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1058 + 4), v1063, v1062);
  v1064 = "mps.conv_2d_data_gradient";
  v1065 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_2d_data_gradient", (const unsigned __int8 *)0x19, a1);
  if (!v1066) {
    goto LABEL_857;
  }
  v1067 = v1065;
  v1068 = (void *)v1065[2];
  if (v1068 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1065[1];
    uint64_t v1069 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1068 = (void *)v1067[2];
  }
  else
  {
    uint64_t v1069 = v1065[3];
  }
  uint64_t v1070 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1069, (uint64_t)v1068, v1070);
  v1071 = malloc(8uLL);
  unint64_t v1072 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1067 + 4), v1072, v1071);
  v692 = "mps.conv_2d_weights_gradient";
  v1073 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_2d_weights_gradient", (const unsigned __int8 *)0x1C, a1);
  if (!v1074) {
    goto LABEL_855;
  }
  v1075 = v1073;
  v1076 = (void *)v1073[2];
  if (v1076 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1073[1];
    uint64_t v1077 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1076 = (void *)v1075[2];
  }
  else
  {
    uint64_t v1077 = v1073[3];
  }
  uint64_t v1078 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1077, (uint64_t)v1076, v1078);
  v1079 = malloc(8uLL);
  unint64_t v1080 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1075 + 4), v1080, v1079);
  v1064 = "mps.conv_3d_data_gradient";
  v1081 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_3d_data_gradient", (const unsigned __int8 *)0x19, a1);
  if (!v1082) {
    goto LABEL_857;
  }
  v1083 = v1081;
  v1084 = (void *)v1081[2];
  if (v1084 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1081[1];
    uint64_t v1085 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1084 = (void *)v1083[2];
  }
  else
  {
    uint64_t v1085 = v1081[3];
  }
  uint64_t v1086 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1085, (uint64_t)v1084, v1086);
  v1087 = malloc(8uLL);
  unint64_t v1088 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1083 + 4), v1088, v1087);
  v692 = "mps.conv_3d_weights_gradient";
  v1089 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_3d_weights_gradient", (const unsigned __int8 *)0x1C, a1);
  if (!v1090)
  {
LABEL_855:
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = v692;
    uint64_t v1699 = 28;
    goto LABEL_866;
  }
  v1091 = v1089;
  v1092 = (void *)v1089[2];
  if (v1092 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1089[1];
    uint64_t v1093 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1092 = (void *)v1091[2];
  }
  else
  {
    uint64_t v1093 = v1089[3];
  }
  uint64_t v1094 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1093, (uint64_t)v1092, v1094);
  v1095 = malloc(8uLL);
  unint64_t v1096 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1091 + 4), v1096, v1095);
  uint64_t v2 = "mps.crop";
  v1097 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.crop", (const unsigned __int8 *)8, a1);
  if (!v1098) {
    goto LABEL_838;
  }
  v1099 = v1097;
  v1100 = (void *)v1097[2];
  if (v1100 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1097[1];
    uint64_t v1101 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1100 = (void *)v1099[2];
  }
  else
  {
    uint64_t v1101 = v1097[3];
  }
  uint64_t v1102 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1101, (uint64_t)v1100, v1102);
  v1103 = malloc(8uLL);
  unint64_t v1104 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1099 + 4), v1104, v1103);
  uint64_t v121 = "mps.cumulative_maximum";
  v1105 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cumulative_maximum", (const unsigned __int8 *)0x16, a1);
  if (!v1106) {
    goto LABEL_852;
  }
  v1107 = v1105;
  v1108 = (void *)v1105[2];
  if (v1108 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1105[1];
    uint64_t v1109 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1108 = (void *)v1107[2];
  }
  else
  {
    uint64_t v1109 = v1105[3];
  }
  uint64_t v1110 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1109, (uint64_t)v1108, v1110);
  v1111 = malloc(8uLL);
  unint64_t v1112 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1107 + 4), v1112, v1111);
  uint64_t v121 = "mps.cumulative_minimum";
  v1113 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cumulative_minimum", (const unsigned __int8 *)0x16, a1);
  if (!v1114) {
    goto LABEL_852;
  }
  v1115 = v1113;
  v1116 = (void *)v1113[2];
  if (v1116 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1113[1];
    uint64_t v1117 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1116 = (void *)v1115[2];
  }
  else
  {
    uint64_t v1117 = v1113[3];
  }
  uint64_t v1118 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1117, (uint64_t)v1116, v1118);
  v1119 = malloc(8uLL);
  unint64_t v1120 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1115 + 4), v1120, v1119);
  uint64_t v121 = "mps.cumulative_product";
  v1121 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cumulative_product", (const unsigned __int8 *)0x16, a1);
  if (!v1122) {
    goto LABEL_852;
  }
  v1123 = v1121;
  v1124 = (void *)v1121[2];
  if (v1124 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1121[1];
    uint64_t v1125 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1124 = (void *)v1123[2];
  }
  else
  {
    uint64_t v1125 = v1121[3];
  }
  uint64_t v1126 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1125, (uint64_t)v1124, v1126);
  v1127 = malloc(8uLL);
  unint64_t v1128 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1123 + 4), v1128, v1127);
  v262 = "mps.cumulative_sum";
  v1129 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cumulative_sum", (const unsigned __int8 *)0x12, a1);
  if (!v1130) {
    goto LABEL_841;
  }
  v1131 = v1129;
  v1132 = (void *)v1129[2];
  if (v1132 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1129[1];
    uint64_t v1133 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1132 = (void *)v1131[2];
  }
  else
  {
    uint64_t v1133 = v1129[3];
  }
  uint64_t v1134 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1133, (uint64_t)v1132, v1134);
  v1135 = malloc(8uLL);
  unint64_t v1136 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1131 + 4), v1136, v1135);
  v539 = "mps.depthwise_conv_2d_data_gradient";
  v1137 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_2d_data_gradient", (const unsigned __int8 *)0x23, a1);
  if (!v1138) {
    goto LABEL_859;
  }
  v1139 = v1137;
  v1140 = (void *)v1137[2];
  if (v1140 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1137[1];
    uint64_t v1141 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1140 = (void *)v1139[2];
  }
  else
  {
    uint64_t v1141 = v1137[3];
  }
  uint64_t v1142 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1141, (uint64_t)v1140, v1142);
  v1143 = malloc(8uLL);
  unint64_t v1144 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1139 + 4), v1144, v1143);
  v1145 = "mps.depthwise_conv_2d_weights_gradient";
  v1146 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_2d_weights_gradient", (const unsigned __int8 *)0x26, a1);
  if (!v1147) {
    goto LABEL_862;
  }
  v1148 = v1146;
  v1149 = (void *)v1146[2];
  if (v1149 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1146[1];
    uint64_t v1150 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1149 = (void *)v1148[2];
  }
  else
  {
    uint64_t v1150 = v1146[3];
  }
  uint64_t v1151 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1150, (uint64_t)v1149, v1151);
  v1152 = malloc(8uLL);
  unint64_t v1153 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1148 + 4), v1153, v1152);
  v539 = "mps.depthwise_conv_3d_data_gradient";
  v1154 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_3d_data_gradient", (const unsigned __int8 *)0x23, a1);
  if (!v1155)
  {
LABEL_859:
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = v539;
    uint64_t v1699 = 35;
    goto LABEL_866;
  }
  v1156 = v1154;
  v1157 = (void *)v1154[2];
  if (v1157 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1154[1];
    uint64_t v1158 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1157 = (void *)v1156[2];
  }
  else
  {
    uint64_t v1158 = v1154[3];
  }
  uint64_t v1159 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1158, (uint64_t)v1157, v1159);
  v1160 = malloc(8uLL);
  unint64_t v1161 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1156 + 4), v1161, v1160);
  v1145 = "mps.depthwise_conv_3d_weights_gradient";
  v1162 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_3d_weights_gradient", (const unsigned __int8 *)0x26, a1);
  if (!v1163)
  {
LABEL_862:
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = v1145;
    uint64_t v1699 = 38;
    goto LABEL_866;
  }
  v1164 = v1162;
  v1165 = (void *)v1162[2];
  if (v1165 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1162[1];
    uint64_t v1166 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1165 = (void *)v1164[2];
  }
  else
  {
    uint64_t v1166 = v1162[3];
  }
  uint64_t v1167 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1166, (uint64_t)v1165, v1167);
  v1168 = malloc(8uLL);
  unint64_t v1169 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1164 + 4), v1169, v1168);
  char v112 = "mps.expand_dims";
  v1170 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.expand_dims", (const unsigned __int8 *)0xF, a1);
  if (!v1171) {
    goto LABEL_847;
  }
  v1172 = v1170;
  v1173 = (void *)v1170[2];
  if (v1173 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1170[1];
    uint64_t v1174 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1173 = (void *)v1172[2];
  }
  else
  {
    uint64_t v1174 = v1170[3];
  }
  uint64_t v1175 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1174, (uint64_t)v1173, v1175);
  v1176 = malloc(8uLL);
  unint64_t v1177 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1172 + 4), v1177, v1176);
  v806 = "mps.fast_fourier_transform";
  v1178 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.fast_fourier_transform", (const unsigned __int8 *)0x1A, a1);
  if (!v1179) {
    goto LABEL_860;
  }
  v1180 = v1178;
  v1181 = (void *)v1178[2];
  if (v1181 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1178[1];
    uint64_t v1182 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1181 = (void *)v1180[2];
  }
  else
  {
    uint64_t v1182 = v1178[3];
  }
  uint64_t v1183 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1182, (uint64_t)v1181, v1183);
  v1184 = malloc(8uLL);
  unint64_t v1185 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1180 + 4), v1185, v1184);
  uint64_t v138 = "mps.flatten_2d";
  v1186 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.flatten_2d", (const unsigned __int8 *)0xE, a1);
  if (!v1187) {
    goto LABEL_850;
  }
  v1188 = v1186;
  v1189 = (void *)v1186[2];
  if (v1189 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1186[1];
    uint64_t v1190 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1189 = (void *)v1188[2];
  }
  else
  {
    uint64_t v1190 = v1186[3];
  }
  uint64_t v1191 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1190, (uint64_t)v1189, v1191);
  v1192 = malloc(8uLL);
  unint64_t v1193 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1188 + 4), v1193, v1192);
  v279 = "mps.gather_along_axis";
  v1194 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.gather_along_axis", (const unsigned __int8 *)0x15, a1);
  if (!v1195) {
    goto LABEL_853;
  }
  v1196 = v1194;
  v1197 = (void *)v1194[2];
  if (v1197 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1194[1];
    uint64_t v1198 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1197 = (void *)v1196[2];
  }
  else
  {
    uint64_t v1198 = v1194[3];
  }
  uint64_t v1199 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1198, (uint64_t)v1197, v1199);
  v1200 = malloc(8uLL);
  unint64_t v1201 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1196 + 4), v1201, v1200);
  v312 = "mps.gather";
  v1202 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.gather", (const unsigned __int8 *)0xA, a1);
  if (!v1203) {
    goto LABEL_846;
  }
  v1204 = v1202;
  v1205 = (void *)v1202[2];
  if (v1205 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1202[1];
    uint64_t v1206 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1205 = (void *)v1204[2];
  }
  else
  {
    uint64_t v1206 = v1202[3];
  }
  uint64_t v1207 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1206, (uint64_t)v1205, v1207);
  v1208 = malloc(8uLL);
  unint64_t v1209 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1204 + 4), v1209, v1208);
  char v69 = "mps.get_coordinates";
  v1210 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.get_coordinates", (const unsigned __int8 *)0x13, a1);
  if (!v1211) {
    goto LABEL_849;
  }
  v1212 = v1210;
  v1213 = (void *)v1210[2];
  if (v1213 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1210[1];
    uint64_t v1214 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1213 = (void *)v1212[2];
  }
  else
  {
    uint64_t v1214 = v1210[3];
  }
  uint64_t v1215 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1214, (uint64_t)v1213, v1215);
  v1216 = malloc(8uLL);
  unint64_t v1217 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1212 + 4), v1217, v1216);
  v1064 = "mps.hermitean_to_real_fft";
  v1218 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.hermitean_to_real_fft", (const unsigned __int8 *)0x19, a1);
  if (!v1219) {
    goto LABEL_857;
  }
  v1220 = v1218;
  v1221 = (void *)v1218[2];
  if (v1221 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1218[1];
    uint64_t v1222 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1221 = (void *)v1220[2];
  }
  else
  {
    uint64_t v1222 = v1218[3];
  }
  uint64_t v1223 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1222, (uint64_t)v1221, v1223);
  v1224 = malloc(8uLL);
  unint64_t v1225 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1220 + 4), v1225, v1224);
  v434 = "mps.instance_norm";
  v1226 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.instance_norm", (const unsigned __int8 *)0x11, a1);
  if (!v1227)
  {
LABEL_845:
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = v434;
    uint64_t v1699 = 17;
    goto LABEL_866;
  }
  v1228 = v1226;
  v1229 = (void *)v1226[2];
  if (v1229 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1226[1];
    uint64_t v1230 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1229 = (void *)v1228[2];
  }
  else
  {
    uint64_t v1230 = v1226[3];
  }
  uint64_t v1231 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1230, (uint64_t)v1229, v1231);
  v1232 = malloc(8uLL);
  unint64_t v1233 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1228 + 4), v1233, v1232);
  uint64_t v221 = "mps.one_hot";
  v1234 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.one_hot", (const unsigned __int8 *)0xB, a1);
  if (!v1235) {
    goto LABEL_840;
  }
  v1236 = v1234;
  v1237 = (void *)v1234[2];
  if (v1237 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1234[1];
    uint64_t v1238 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1237 = (void *)v1236[2];
  }
  else
  {
    uint64_t v1238 = v1234[3];
  }
  uint64_t v1239 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1238, (uint64_t)v1237, v1239);
  v1240 = malloc(8uLL);
  unint64_t v1241 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1236 + 4), v1241, v1240);
  v377 = "mps.pad_gradient";
  v1242 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pad_gradient", (const unsigned __int8 *)0x10, a1);
  if (!v1243) {
    goto LABEL_854;
  }
  v1244 = v1242;
  v1245 = (void *)v1242[2];
  if (v1245 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1242[1];
    uint64_t v1246 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1245 = (void *)v1244[2];
  }
  else
  {
    uint64_t v1246 = v1242[3];
  }
  uint64_t v1247 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1246, (uint64_t)v1245, v1247);
  v1248 = malloc(8uLL);
  unint64_t v1249 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1244 + 4), v1249, v1248);
  uint64_t v78 = "mps.pad";
  v1250 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pad", (const unsigned __int8 *)7, a1);
  if (!v1251)
  {
LABEL_842:
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = v78;
    uint64_t v1699 = 7;
    goto LABEL_866;
  }
  v1252 = v1250;
  v1253 = (void *)v1250[2];
  if (v1253 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1250[1];
    uint64_t v1254 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1253 = (void *)v1252[2];
  }
  else
  {
    uint64_t v1254 = v1250[3];
  }
  uint64_t v1255 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1254, (uint64_t)v1253, v1255);
  v1256 = malloc(8uLL);
  unint64_t v1257 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1252 + 4), v1257, v1256);
  uint64_t v221 = "mps.permute";
  v1258 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.permute", (const unsigned __int8 *)0xB, a1);
  if (!v1259) {
    goto LABEL_840;
  }
  v1260 = v1258;
  v1261 = (void *)v1258[2];
  if (v1261 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1258[1];
    uint64_t v1262 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1261 = (void *)v1260[2];
  }
  else
  {
    uint64_t v1262 = v1258[3];
  }
  uint64_t v1263 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1262, (uint64_t)v1261, v1263);
  v1264 = malloc(8uLL);
  unint64_t v1265 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1260 + 4), v1265, v1264);
  v1064 = "mps.real_to_hermitean_fft";
  v1266 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.real_to_hermitean_fft", (const unsigned __int8 *)0x19, a1);
  if (!v1267) {
    goto LABEL_857;
  }
  v1268 = v1266;
  v1269 = (void *)v1266[2];
  if (v1269 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1266[1];
    uint64_t v1270 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1269 = (void *)v1268[2];
  }
  else
  {
    uint64_t v1270 = v1266[3];
  }
  uint64_t v1271 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1270, (uint64_t)v1269, v1271);
  v1272 = malloc(8uLL);
  unint64_t v1273 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1268 + 4), v1273, v1272);
  v434 = "mps.reduction_and";
  v1274 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_and", (const unsigned __int8 *)0x11, a1);
  if (!v1275) {
    goto LABEL_845;
  }
  v1276 = v1274;
  v1277 = (void *)v1274[2];
  if (v1277 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1274[1];
    uint64_t v1278 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1277 = (void *)v1276[2];
  }
  else
  {
    uint64_t v1278 = v1274[3];
  }
  uint64_t v1279 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1278, (uint64_t)v1277, v1279);
  v1280 = malloc(8uLL);
  unint64_t v1281 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1276 + 4), v1281, v1280);
  uint64_t v147 = "mps.reduction_argmax";
  v1282 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_argmax", (const unsigned __int8 *)0x14, a1);
  if (!v1283) {
    goto LABEL_851;
  }
  v1284 = v1282;
  v1285 = (void *)v1282[2];
  if (v1285 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1282[1];
    uint64_t v1286 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1285 = (void *)v1284[2];
  }
  else
  {
    uint64_t v1286 = v1282[3];
  }
  uint64_t v1287 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1286, (uint64_t)v1285, v1287);
  v1288 = malloc(8uLL);
  unint64_t v1289 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1284 + 4), v1289, v1288);
  uint64_t v147 = "mps.reduction_argmin";
  v1290 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_argmin", (const unsigned __int8 *)0x14, a1);
  if (!v1291) {
    goto LABEL_851;
  }
  v1292 = v1290;
  v1293 = (void *)v1290[2];
  if (v1293 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1290[1];
    uint64_t v1294 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1293 = (void *)v1292[2];
  }
  else
  {
    uint64_t v1294 = v1290[3];
  }
  uint64_t v1295 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1294, (uint64_t)v1293, v1295);
  v1296 = malloc(8uLL);
  unint64_t v1297 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1292 + 4), v1297, v1296);
  uint64_t v156 = "mps.reduction_logsumexp";
  v1298 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_logsumexp", (const unsigned __int8 *)0x17, a1);
  if (!v1299) {
    goto LABEL_856;
  }
  v1300 = v1298;
  v1301 = (void *)v1298[2];
  if (v1301 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1298[1];
    uint64_t v1302 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1301 = (void *)v1300[2];
  }
  else
  {
    uint64_t v1302 = v1298[3];
  }
  uint64_t v1303 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1302, (uint64_t)v1301, v1303);
  v1304 = malloc(8uLL);
  unint64_t v1305 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1300 + 4), v1305, v1304);
  v434 = "mps.reduction_max";
  v1306 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_max", (const unsigned __int8 *)0x11, a1);
  if (!v1307) {
    goto LABEL_845;
  }
  v1308 = v1306;
  v1309 = (void *)v1306[2];
  if (v1309 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1306[1];
    uint64_t v1310 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1309 = (void *)v1308[2];
  }
  else
  {
    uint64_t v1310 = v1306[3];
  }
  uint64_t v1311 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1310, (uint64_t)v1309, v1311);
  v1312 = malloc(8uLL);
  unint64_t v1313 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1308 + 4), v1313, v1312);
  v262 = "mps.reduction_mean";
  v1314 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_mean", (const unsigned __int8 *)0x12, a1);
  if (!v1315) {
    goto LABEL_841;
  }
  v1316 = v1314;
  v1317 = (void *)v1314[2];
  if (v1317 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1314[1];
    uint64_t v1318 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1317 = (void *)v1316[2];
  }
  else
  {
    uint64_t v1318 = v1314[3];
  }
  uint64_t v1319 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1318, (uint64_t)v1317, v1319);
  v1320 = malloc(8uLL);
  unint64_t v1321 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1316 + 4), v1321, v1320);
  v434 = "mps.reduction_min";
  v1322 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_min", (const unsigned __int8 *)0x11, a1);
  if (!v1323) {
    goto LABEL_845;
  }
  v1324 = v1322;
  v1325 = (void *)v1322[2];
  if (v1325 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1322[1];
    uint64_t v1326 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1325 = (void *)v1324[2];
  }
  else
  {
    uint64_t v1326 = v1322[3];
  }
  uint64_t v1327 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1326, (uint64_t)v1325, v1327);
  v1328 = malloc(8uLL);
  unint64_t v1329 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1324 + 4), v1329, v1328);
  v377 = "mps.reduction_or";
  v1330 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_or", (const unsigned __int8 *)0x10, a1);
  if (!v1331)
  {
LABEL_854:
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = v377;
    uint64_t v1699 = 16;
    goto LABEL_866;
  }
  v1332 = v1330;
  v1333 = (void *)v1330[2];
  if (v1333 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1330[1];
    uint64_t v1334 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1333 = (void *)v1332[2];
  }
  else
  {
    uint64_t v1334 = v1330[3];
  }
  uint64_t v1335 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1334, (uint64_t)v1333, v1335);
  v1336 = malloc(8uLL);
  unint64_t v1337 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1332 + 4), v1337, v1336);
  v262 = "mps.reduction_prod";
  v1338 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_prod", (const unsigned __int8 *)0x12, a1);
  if (!v1339) {
    goto LABEL_841;
  }
  v1340 = v1338;
  v1341 = (void *)v1338[2];
  if (v1341 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1338[1];
    uint64_t v1342 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1341 = (void *)v1340[2];
  }
  else
  {
    uint64_t v1342 = v1338[3];
  }
  uint64_t v1343 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1342, (uint64_t)v1341, v1343);
  v1344 = malloc(8uLL);
  unint64_t v1345 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1340 + 4), v1345, v1344);
  v434 = "mps.reduction_sum";
  v1346 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_sum", (const unsigned __int8 *)0x11, a1);
  if (!v1347) {
    goto LABEL_845;
  }
  v1348 = v1346;
  v1349 = (void *)v1346[2];
  if (v1349 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1346[1];
    uint64_t v1350 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1349 = (void *)v1348[2];
  }
  else
  {
    uint64_t v1350 = v1346[3];
  }
  uint64_t v1351 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1350, (uint64_t)v1349, v1351);
  v1352 = malloc(8uLL);
  unint64_t v1353 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1348 + 4), v1353, v1352);
  uint64_t v121 = "mps.reduction_variance";
  v1354 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_variance", (const unsigned __int8 *)0x16, a1);
  if (!v1355) {
    goto LABEL_852;
  }
  v1356 = v1354;
  v1357 = (void *)v1354[2];
  if (v1357 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1354[1];
    uint64_t v1358 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1357 = (void *)v1356[2];
  }
  else
  {
    uint64_t v1358 = v1354[3];
  }
  uint64_t v1359 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1358, (uint64_t)v1357, v1359);
  v1360 = malloc(8uLL);
  unint64_t v1361 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1356 + 4), v1361, v1360);
  uint64_t v221 = "mps.reshape";
  v1362 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reshape", (const unsigned __int8 *)0xB, a1);
  if (!v1363) {
    goto LABEL_840;
  }
  v1364 = v1362;
  v1365 = (void *)v1362[2];
  if (v1365 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1362[1];
    uint64_t v1366 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1365 = (void *)v1364[2];
  }
  else
  {
    uint64_t v1366 = v1362[3];
  }
  uint64_t v1367 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1366, (uint64_t)v1365, v1367);
  v1368 = malloc(8uLL);
  unint64_t v1369 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1364 + 4), v1369, v1368);
  char v69 = "mps.resize_gradient";
  v1370 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.resize_gradient", (const unsigned __int8 *)0x13, a1);
  if (!v1371)
  {
LABEL_849:
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = v69;
    uint64_t v1699 = 19;
    goto LABEL_866;
  }
  v1372 = v1370;
  v1373 = (void *)v1370[2];
  if (v1373 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1370[1];
    uint64_t v1374 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1373 = (void *)v1372[2];
  }
  else
  {
    uint64_t v1374 = v1370[3];
  }
  uint64_t v1375 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1374, (uint64_t)v1373, v1375);
  v1376 = malloc(8uLL);
  unint64_t v1377 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1372 + 4), v1377, v1376);
  v312 = "mps.resize";
  v1378 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.resize", (const unsigned __int8 *)0xA, a1);
  if (!v1379) {
    goto LABEL_846;
  }
  v1380 = v1378;
  v1381 = (void *)v1378[2];
  if (v1381 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1378[1];
    uint64_t v1382 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1381 = (void *)v1380[2];
  }
  else
  {
    uint64_t v1382 = v1378[3];
  }
  uint64_t v1383 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1382, (uint64_t)v1381, v1383);
  v1384 = malloc(8uLL);
  unint64_t v1385 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1380 + 4), v1385, v1384);
  uint64_t v221 = "mps.reverse";
  v1386 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reverse", (const unsigned __int8 *)0xB, a1);
  if (!v1387) {
    goto LABEL_840;
  }
  v1388 = v1386;
  v1389 = (void *)v1386[2];
  if (v1389 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1386[1];
    uint64_t v1390 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1389 = (void *)v1388[2];
  }
  else
  {
    uint64_t v1390 = v1386[3];
  }
  uint64_t v1391 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1390, (uint64_t)v1389, v1391);
  v1392 = malloc(8uLL);
  unint64_t v1393 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1388 + 4), v1393, v1392);
  uint64_t v121 = "mps.scatter_along_axis";
  v1394 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.scatter_along_axis", (const unsigned __int8 *)0x16, a1);
  if (!v1395)
  {
LABEL_852:
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = v121;
    uint64_t v1699 = 22;
    goto LABEL_866;
  }
  v1396 = v1394;
  v1397 = (void *)v1394[2];
  if (v1397 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1394[1];
    uint64_t v1398 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1397 = (void *)v1396[2];
  }
  else
  {
    uint64_t v1398 = v1394[3];
  }
  uint64_t v1399 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1398, (uint64_t)v1397, v1399);
  v1400 = malloc(8uLL);
  unint64_t v1401 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1396 + 4), v1401, v1400);
  uint64_t v221 = "mps.scatter";
  v1402 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.scatter", (const unsigned __int8 *)0xB, a1);
  if (!v1403) {
    goto LABEL_840;
  }
  v1404 = v1402;
  v1405 = (void *)v1402[2];
  if (v1405 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1402[1];
    uint64_t v1406 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1405 = (void *)v1404[2];
  }
  else
  {
    uint64_t v1406 = v1402[3];
  }
  uint64_t v1407 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1406, (uint64_t)v1405, v1407);
  v1408 = malloc(8uLL);
  unint64_t v1409 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1404 + 4), v1409, v1408);
  char v11 = "mps.slice";
  v1410 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.slice", (const unsigned __int8 *)9, a1);
  if (!v1411) {
    goto LABEL_839;
  }
  v1412 = v1410;
  v1413 = (void *)v1410[2];
  if (v1413 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1410[1];
    uint64_t v1414 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1413 = (void *)v1412[2];
  }
  else
  {
    uint64_t v1414 = v1410[3];
  }
  uint64_t v1415 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1414, (uint64_t)v1413, v1415);
  v1416 = malloc(8uLL);
  unint64_t v1417 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1412 + 4), v1417, v1416);
  uint64_t v221 = "mps.softmax";
  v1418 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.softmax", (const unsigned __int8 *)0xB, a1);
  if (!v1419) {
    goto LABEL_840;
  }
  v1420 = v1418;
  v1421 = (void *)v1418[2];
  if (v1421 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1418[1];
    uint64_t v1422 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1421 = (void *)v1420[2];
  }
  else
  {
    uint64_t v1422 = v1418[3];
  }
  uint64_t v1423 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1422, (uint64_t)v1421, v1423);
  v1424 = malloc(8uLL);
  unint64_t v1425 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1420 + 4), v1425, v1424);
  uint64_t v2 = "mps.sort";
  v1426 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sort", (const unsigned __int8 *)8, a1);
  if (!v1427) {
    goto LABEL_838;
  }
  v1428 = v1426;
  v1429 = (void *)v1426[2];
  if (v1429 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1426[1];
    uint64_t v1430 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1429 = (void *)v1428[2];
  }
  else
  {
    uint64_t v1430 = v1426[3];
  }
  uint64_t v1431 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1430, (uint64_t)v1429, v1431);
  v1432 = malloc(8uLL);
  unint64_t v1433 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1428 + 4), v1433, v1432);
  char v11 = "mps.split";
  v1434 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.split", (const unsigned __int8 *)9, a1);
  if (!v1435) {
    goto LABEL_839;
  }
  v1436 = v1434;
  v1437 = (void *)v1434[2];
  if (v1437 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1434[1];
    uint64_t v1438 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1437 = (void *)v1436[2];
  }
  else
  {
    uint64_t v1438 = v1434[3];
  }
  uint64_t v1439 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1438, (uint64_t)v1437, v1439);
  v1440 = malloc(8uLL);
  unint64_t v1441 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1436 + 4), v1441, v1440);
  uint64_t v221 = "mps.squeeze";
  v1442 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.squeeze", (const unsigned __int8 *)0xB, a1);
  if (!v1443) {
    goto LABEL_840;
  }
  v1444 = v1442;
  v1445 = (void *)v1442[2];
  if (v1445 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1442[1];
    uint64_t v1446 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1445 = (void *)v1444[2];
  }
  else
  {
    uint64_t v1446 = v1442[3];
  }
  uint64_t v1447 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1446, (uint64_t)v1445, v1447);
  v1448 = malloc(8uLL);
  unint64_t v1449 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1444 + 4), v1449, v1448);
  v806 = "mps.strided_slice_gradient";
  v1450 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.strided_slice_gradient", (const unsigned __int8 *)0x1A, a1);
  if (!v1451)
  {
LABEL_860:
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = v806;
    uint64_t v1699 = 26;
    goto LABEL_866;
  }
  v1452 = v1450;
  v1453 = (void *)v1450[2];
  if (v1453 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1450[1];
    uint64_t v1454 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1453 = (void *)v1452[2];
  }
  else
  {
    uint64_t v1454 = v1450[3];
  }
  uint64_t v1455 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1454, (uint64_t)v1453, v1455);
  v1456 = malloc(8uLL);
  unint64_t v1457 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1452 + 4), v1457, v1456);
  v434 = "mps.strided_slice";
  v1458 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.strided_slice", (const unsigned __int8 *)0x11, a1);
  if (!v1459) {
    goto LABEL_845;
  }
  v1460 = v1458;
  v1461 = (void *)v1458[2];
  if (v1461 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1458[1];
    uint64_t v1462 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1461 = (void *)v1460[2];
  }
  else
  {
    uint64_t v1462 = v1458[3];
  }
  uint64_t v1463 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1462, (uint64_t)v1461, v1463);
  v1464 = malloc(8uLL);
  unint64_t v1465 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1460 + 4), v1465, v1464);
  v725 = "mps.strided_slice_update";
  v1466 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.strided_slice_update", (const unsigned __int8 *)0x18, a1);
  if (!v1467)
  {
LABEL_861:
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = v725;
    uint64_t v1699 = 24;
    goto LABEL_866;
  }
  v1468 = v1466;
  v1469 = (void *)v1466[2];
  if (v1469 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1466[1];
    uint64_t v1470 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1469 = (void *)v1468[2];
  }
  else
  {
    uint64_t v1470 = v1466[3];
  }
  uint64_t v1471 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1470, (uint64_t)v1469, v1471);
  v1472 = malloc(8uLL);
  unint64_t v1473 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1468 + 4), v1473, v1472);
  v434 = "mps.tile_gradient";
  v1474 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.tile_gradient", (const unsigned __int8 *)0x11, a1);
  if (!v1475) {
    goto LABEL_845;
  }
  v1476 = v1474;
  v1477 = (void *)v1474[2];
  if (v1477 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1474[1];
    uint64_t v1478 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1477 = (void *)v1476[2];
  }
  else
  {
    uint64_t v1478 = v1474[3];
  }
  uint64_t v1479 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1478, (uint64_t)v1477, v1479);
  v1480 = malloc(8uLL);
  unint64_t v1481 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1476 + 4), v1481, v1480);
  uint64_t v2 = "mps.tile";
  v1482 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.tile", (const unsigned __int8 *)8, a1);
  if (!v1483)
  {
LABEL_838:
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = v2;
    uint64_t v1699 = 8;
    goto LABEL_866;
  }
  v1484 = v1482;
  v1485 = (void *)v1482[2];
  if (v1485 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1482[1];
    uint64_t v1486 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1485 = (void *)v1484[2];
  }
  else
  {
    uint64_t v1486 = v1482[3];
  }
  uint64_t v1487 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1486, (uint64_t)v1485, v1487);
  v1488 = malloc(8uLL);
  unint64_t v1489 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1484 + 4), v1489, v1488);
  uint64_t v138 = "mps.top_k_grad";
  v1490 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.top_k_grad", (const unsigned __int8 *)0xE, a1);
  if (!v1491) {
    goto LABEL_850;
  }
  v1492 = v1490;
  v1493 = (void *)v1490[2];
  if (v1493 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1490[1];
    uint64_t v1494 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1493 = (void *)v1492[2];
  }
  else
  {
    uint64_t v1494 = v1490[3];
  }
  uint64_t v1495 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1494, (uint64_t)v1493, v1495);
  v1496 = malloc(8uLL);
  unint64_t v1497 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1492 + 4), v1497, v1496);
  char v11 = "mps.top_k";
  v1498 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.top_k", (const unsigned __int8 *)9, a1);
  if (!v1499) {
    goto LABEL_839;
  }
  v1500 = v1498;
  v1501 = (void *)v1498[2];
  if (v1501 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1498[1];
    uint64_t v1502 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1501 = (void *)v1500[2];
  }
  else
  {
    uint64_t v1502 = v1498[3];
  }
  uint64_t v1503 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1502, (uint64_t)v1501, v1503);
  v1504 = malloc(8uLL);
  unint64_t v1505 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1500 + 4), v1505, v1504);
  int v103 = "mps.transpose";
  v1506 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.transpose", (const unsigned __int8 *)0xD, a1);
  if (!v1507)
  {
LABEL_844:
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = v103;
    uint64_t v1699 = 13;
    goto LABEL_866;
  }
  v1508 = v1506;
  v1509 = (void *)v1506[2];
  if (v1509 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1506[1];
    uint64_t v1510 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1509 = (void *)v1508[2];
  }
  else
  {
    uint64_t v1510 = v1506[3];
  }
  uint64_t v1511 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1510, (uint64_t)v1509, v1511);
  v1512 = malloc(8uLL);
  unint64_t v1513 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1508 + 4), v1513, v1512);
  uint64_t v2 = "mps.call";
  v1514 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.call", (const unsigned __int8 *)8, a1);
  if (!v1515) {
    goto LABEL_838;
  }
  v1516 = v1514;
  v1517 = (void *)v1514[2];
  if (v1517 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1514[1];
    uint64_t v1518 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1517 = (void *)v1516[2];
  }
  else
  {
    uint64_t v1518 = v1514[3];
  }
  uint64_t v1519 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1518, (uint64_t)v1517, v1519);
  v1520 = malloc(8uLL);
  unint64_t v1521 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1516 + 4), v1521, v1520);
  v262 = "mps.dimension_size";
  v1522 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dimension_size", (const unsigned __int8 *)0x12, a1);
  if (!v1523) {
    goto LABEL_841;
  }
  v1524 = v1522;
  v1525 = (void *)v1522[2];
  if (v1525 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1522[1];
    uint64_t v1526 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1525 = (void *)v1524[2];
  }
  else
  {
    uint64_t v1526 = v1522[3];
  }
  uint64_t v1527 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1526, (uint64_t)v1525, v1527);
  v1528 = malloc(8uLL);
  unint64_t v1529 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1524 + 4), v1529, v1528);
  uint64_t v2 = "mps.rank";
  v1530 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.rank", (const unsigned __int8 *)8, a1);
  if (!v1531) {
    goto LABEL_838;
  }
  v1532 = v1530;
  v1533 = (void *)v1530[2];
  if (v1533 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1530[1];
    uint64_t v1534 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1533 = (void *)v1532[2];
  }
  else
  {
    uint64_t v1534 = v1530[3];
  }
  uint64_t v1535 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1534, (uint64_t)v1533, v1535);
  v1536 = malloc(8uLL);
  unint64_t v1537 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1532 + 4), v1537, v1536);
  char v11 = "mps.shape";
  v1538 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.shape", (const unsigned __int8 *)9, a1);
  if (!v1539) {
    goto LABEL_839;
  }
  v1540 = v1538;
  v1541 = (void *)v1538[2];
  if (v1541 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1538[1];
    uint64_t v1542 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1541 = (void *)v1540[2];
  }
  else
  {
    uint64_t v1542 = v1538[3];
  }
  uint64_t v1543 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1542, (uint64_t)v1541, v1543);
  v1544 = malloc(8uLL);
  unint64_t v1545 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1540 + 4), v1545, v1544);
  uint64_t v2 = "mps.size";
  v1546 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.size", (const unsigned __int8 *)8, a1);
  if (!v1547) {
    goto LABEL_838;
  }
  v1548 = v1546;
  v1549 = (void *)v1546[2];
  if (v1549 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1546[1];
    uint64_t v1550 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1549 = (void *)v1548[2];
  }
  else
  {
    uint64_t v1550 = v1546[3];
  }
  uint64_t v1551 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1550, (uint64_t)v1549, v1551);
  v1552 = malloc(8uLL);
  unint64_t v1553 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1548 + 4), v1553, v1552);
  v434 = "mps.random_normal";
  v1554 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.random_normal", (const unsigned __int8 *)0x11, a1);
  if (!v1555) {
    goto LABEL_845;
  }
  v1556 = v1554;
  v1557 = (void *)v1554[2];
  if (v1557 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1554[1];
    uint64_t v1558 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1557 = (void *)v1556[2];
  }
  else
  {
    uint64_t v1558 = v1554[3];
  }
  uint64_t v1559 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1558, (uint64_t)v1557, v1559);
  v1560 = malloc(8uLL);
  unint64_t v1561 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1556 + 4), v1561, v1560);
  v903 = "mps.random_truncated_normal";
  v1562 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.random_truncated_normal", (const unsigned __int8 *)0x1B, a1);
  if (!v1563) {
    goto LABEL_858;
  }
  v1564 = v1562;
  v1565 = (void *)v1562[2];
  if (v1565 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1562[1];
    uint64_t v1566 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1565 = (void *)v1564[2];
  }
  else
  {
    uint64_t v1566 = v1562[3];
  }
  uint64_t v1567 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1566, (uint64_t)v1565, v1567);
  v1568 = malloc(8uLL);
  unint64_t v1569 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1564 + 4), v1569, v1568);
  v262 = "mps.random_uniform";
  v1570 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.random_uniform", (const unsigned __int8 *)0x12, a1);
  if (!v1571) {
    goto LABEL_841;
  }
  v1572 = v1570;
  v1573 = (void *)v1570[2];
  if (v1573 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1570[1];
    uint64_t v1574 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1573 = (void *)v1572[2];
  }
  else
  {
    uint64_t v1574 = v1570[3];
  }
  uint64_t v1575 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1574, (uint64_t)v1573, v1575);
  v1576 = malloc(8uLL);
  unint64_t v1577 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1572 + 4), v1577, v1576);
  v692 = "mps.init_random_philox_state";
  v1578 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.init_random_philox_state", (const unsigned __int8 *)0x1C, a1);
  if (!v1579) {
    goto LABEL_855;
  }
  v1580 = v1578;
  v1581 = (void *)v1578[2];
  if (v1581 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1578[1];
    uint64_t v1582 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1581 = (void *)v1580[2];
  }
  else
  {
    uint64_t v1582 = v1578[3];
  }
  uint64_t v1583 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1582, (uint64_t)v1581, v1583);
  v1584 = malloc(8uLL);
  unint64_t v1585 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1580 + 4), v1585, v1584);
  uint64_t v156 = "mps.update_random_state";
  v1586 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.update_random_state", (const unsigned __int8 *)0x17, a1);
  if (!v1587) {
    goto LABEL_856;
  }
  v1588 = v1586;
  v1589 = (void *)v1586[2];
  if (v1589 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1586[1];
    uint64_t v1590 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1589 = (void *)v1588[2];
  }
  else
  {
    uint64_t v1590 = v1586[3];
  }
  uint64_t v1591 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1590, (uint64_t)v1589, v1591);
  v1592 = malloc(8uLL);
  unint64_t v1593 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1588 + 4), v1593, v1592);
  v262 = "mps.batch_to_space";
  v1594 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.batch_to_space", (const unsigned __int8 *)0x12, a1);
  if (!v1595) {
    goto LABEL_841;
  }
  v1596 = v1594;
  v1597 = (void *)v1594[2];
  if (v1597 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1594[1];
    uint64_t v1598 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1597 = (void *)v1596[2];
  }
  else
  {
    uint64_t v1598 = v1594[3];
  }
  uint64_t v1599 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1598, (uint64_t)v1597, v1599);
  v1600 = malloc(8uLL);
  unint64_t v1601 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1596 + 4), v1601, v1600);
  v262 = "mps.space_to_batch";
  v1602 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.space_to_batch", (const unsigned __int8 *)0x12, a1);
  if (!v1603) {
    goto LABEL_841;
  }
  v1604 = v1602;
  v1605 = (void *)v1602[2];
  if (v1605 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1602[1];
    uint64_t v1606 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1605 = (void *)v1604[2];
  }
  else
  {
    uint64_t v1606 = v1602[3];
  }
  uint64_t v1607 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1606, (uint64_t)v1605, v1607);
  v1608 = malloc(8uLL);
  unint64_t v1609 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1604 + 4), v1609, v1608);
  v279 = "mps.space_to_depth_2d";
  v1610 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.space_to_depth_2d", (const unsigned __int8 *)0x15, a1);
  if (!v1611) {
    goto LABEL_853;
  }
  v1612 = v1610;
  v1613 = (void *)v1610[2];
  if (v1613 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1610[1];
    uint64_t v1614 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1613 = (void *)v1612[2];
  }
  else
  {
    uint64_t v1614 = v1610[3];
  }
  uint64_t v1615 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1614, (uint64_t)v1613, v1615);
  v1616 = malloc(8uLL);
  unint64_t v1617 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1612 + 4), v1617, v1616);
  v279 = "mps.depth_to_space_2d";
  v1618 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depth_to_space_2d", (const unsigned __int8 *)0x15, a1);
  if (!v1619)
  {
LABEL_853:
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = v279;
    uint64_t v1699 = 21;
    goto LABEL_866;
  }
  v1620 = v1618;
  v1621 = (void *)v1618[2];
  if (v1621 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1618[1];
    uint64_t v1622 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1621 = (void *)v1620[2];
  }
  else
  {
    uint64_t v1622 = v1618[3];
  }
  uint64_t v1623 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1622, (uint64_t)v1621, v1623);
  v1624 = malloc(8uLL);
  unint64_t v1625 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1620 + 4), v1625, v1624);
  v903 = "mps.broadcast_gradient_args";
  v1626 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.broadcast_gradient_args", (const unsigned __int8 *)0x1B, a1);
  if (!v1627) {
    goto LABEL_858;
  }
  v1628 = v1626;
  v1629 = (void *)v1626[2];
  if (v1629 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1626[1];
    uint64_t v1630 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1629 = (void *)v1628[2];
  }
  else
  {
    uint64_t v1630 = v1626[3];
  }
  uint64_t v1631 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1630, (uint64_t)v1629, v1631);
  v1632 = malloc(8uLL);
  unint64_t v1633 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1628 + 4), v1633, v1632);
  v1064 = "mps.create_texture_tensor";
  v1634 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.create_texture_tensor", (const unsigned __int8 *)0x19, a1);
  if (!v1635)
  {
LABEL_857:
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = v1064;
    uint64_t v1699 = 25;
    goto LABEL_866;
  }
  v1636 = v1634;
  v1637 = (void *)v1634[2];
  if (v1637 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1634[1];
    uint64_t v1638 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1637 = (void *)v1636[2];
  }
  else
  {
    uint64_t v1638 = v1634[3];
  }
  uint64_t v1639 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1638, (uint64_t)v1637, v1639);
  v1640 = malloc(8uLL);
  unint64_t v1641 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1636 + 4), v1641, v1640);
  v1642 = "mps.materialize_sparse_tensor";
  v1643 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.materialize_sparse_tensor", (const unsigned __int8 *)0x1D, a1);
  if (!v1644) {
    goto LABEL_863;
  }
  v1645 = v1643;
  v1646 = (void *)v1643[2];
  if (v1646 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1643[1];
    uint64_t v1647 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1646 = (void *)v1645[2];
  }
  else
  {
    uint64_t v1647 = v1643[3];
  }
  uint64_t v1648 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1647, (uint64_t)v1646, v1648);
  v1649 = malloc(8uLL);
  unint64_t v1650 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1645 + 4), v1650, v1649);
  v903 = "mps.matrix_decomposition_lu";
  v1651 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.matrix_decomposition_lu", (const unsigned __int8 *)0x1B, a1);
  if (!v1652)
  {
LABEL_858:
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = v903;
    uint64_t v1699 = 27;
    goto LABEL_866;
  }
  v1653 = v1651;
  v1654 = (void *)v1651[2];
  if (v1654 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1651[1];
    uint64_t v1655 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1654 = (void *)v1653[2];
  }
  else
  {
    uint64_t v1655 = v1651[3];
  }
  uint64_t v1656 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1655, (uint64_t)v1654, v1656);
  v1657 = malloc(8uLL);
  unint64_t v1658 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1653 + 4), v1658, v1657);
  v262 = "mps.matrix_inverse";
  v1659 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.matrix_inverse", (const unsigned __int8 *)0x12, a1);
  if (!v1660)
  {
LABEL_841:
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = v262;
    uint64_t v1699 = 18;
    goto LABEL_866;
  }
  v1661 = v1659;
  v1662 = (void *)v1659[2];
  if (v1662 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1659[1];
    uint64_t v1663 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1662 = (void *)v1661[2];
  }
  else
  {
    uint64_t v1663 = v1659[3];
  }
  uint64_t v1664 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1663, (uint64_t)v1662, v1664);
  v1665 = malloc(8uLL);
  unint64_t v1666 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1661 + 4), v1666, v1665);
  uint64_t v147 = "mps.matrix_solver_lu";
  v1667 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.matrix_solver_lu", (const unsigned __int8 *)0x14, a1);
  if (!v1668)
  {
LABEL_851:
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = v147;
    uint64_t v1699 = 20;
    goto LABEL_866;
  }
  v1669 = v1667;
  v1670 = (void *)v1667[2];
  if (v1670 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1667[1];
    uint64_t v1671 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1670 = (void *)v1669[2];
  }
  else
  {
    uint64_t v1671 = v1667[3];
  }
  uint64_t v1672 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1671, (uint64_t)v1670, v1672);
  v1673 = malloc(8uLL);
  unint64_t v1674 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1669 + 4), v1674, v1673);
  v903 = "mps.non_maximum_suppression";
  v1675 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.non_maximum_suppression", (const unsigned __int8 *)0x1B, a1);
  if (!v1676) {
    goto LABEL_858;
  }
  v1677 = v1675;
  v1678 = (void *)v1675[2];
  if (v1678 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1675[1];
    uint64_t v1679 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1678 = (void *)v1677[2];
  }
  else
  {
    uint64_t v1679 = v1675[3];
  }
  uint64_t v1680 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1679, (uint64_t)v1678, v1680);
  v1681 = malloc(8uLL);
  unint64_t v1682 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1677 + 4), v1682, v1681);
  v1642 = "mps.sample_grid_data_gradient";
  v1683 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sample_grid_data_gradient", (const unsigned __int8 *)0x1D, a1);
  if (!v1684)
  {
LABEL_863:
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = v1642;
    uint64_t v1699 = 29;
    goto LABEL_866;
  }
  v1685 = v1683;
  v1686 = (void *)v1683[2];
  if (v1686 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1683[1];
    uint64_t v1687 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1686 = (void *)v1685[2];
  }
  else
  {
    uint64_t v1687 = v1683[3];
  }
  uint64_t v1688 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1687, (uint64_t)v1686, v1688);
  v1689 = malloc(8uLL);
  unint64_t v1690 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1685 + 4), v1690, v1689);
  v1691 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sample_grid", (const unsigned __int8 *)0xF, a1);
  if (!v1692)
  {
    __int16 v1705 = 1283;
    v1702 = "Attempting to attach an interface to an unregistered operation ";
    v1703 = "mps.sample_grid";
    goto LABEL_848;
  }
  v1693 = v1691;
  v1694 = (void *)v1691[2];
  if (v1694 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1706[0] = v1691[1];
    uint64_t v1695 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1706);
    v1694 = (void *)v1693[2];
  }
  else
  {
    uint64_t v1695 = v1691[3];
  }
  uint64_t v1696 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1695, (uint64_t)v1694, v1696);
  v1697 = malloc(8uLL);
  unint64_t v1698 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1693 + 4), v1698, v1697);
}

uint64_t mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>()
{
  unint64_t v0 = 0x1E8EB8000uLL;
  {
    unint64_t v0 = 0x1E8EB8000;
    if (v2)
    {
      unint64_t v10 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MPSRuntimeDynamicEncodeOpInterface]";
      unint64_t v11 = 90;
      unint64_t v3 = llvm::StringRef::find((uint64_t *)&v10, "DesiredTypeName = ", 0x12uLL, 0);
      if (v11 >= v3) {
        unint64_t v4 = v3;
      }
      else {
        unint64_t v4 = v11;
      }
      unint64_t v5 = &v10[v4];
      unint64_t v6 = v11 - v4;
      if (v11 - v4 >= 0x12) {
        uint64_t v7 = 18;
      }
      else {
        uint64_t v7 = v11 - v4;
      }
      unint64_t v8 = v6 - v7;
      if (v8 >= v8 - 1) {
        uint64_t v9 = v8 - 1;
      }
      else {
        uint64_t v9 = v8;
      }
      mlir::detail::TypeIDResolver<mlir::MPSRuntimeDynamicEncodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v5[v7], v9);
      unint64_t v0 = 0x1E8EB8000;
    }
  }
  return *(void *)(v0 + 1944);
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ACosOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ACoshOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ASinOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ASinhOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ATan2Op>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ATanOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ATanhOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::AbsoluteOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::AbsoluteSquareOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::AddOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::AndOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::AssignVariableOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::BandPartOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::BitwiseAndOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::BitwiseLeftShiftOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::BitwiseNotOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::BitwiseOrOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::BitwisePopcountOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::BitwiseRightShiftOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::BitwiseXorOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::CastOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::CeilOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ClampOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ColToImOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ConjugateOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ConstantOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::Conv2DOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::Conv3DOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::CosOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::CoshOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::CostVolumeOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::CreateComplexOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::CropResizeOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::DepthwiseConv2DOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::DepthwiseConv3DOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::DequantizeLUTOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::DequantizeOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::DivideOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::DynamicShapeCastOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::EluOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::EqualToOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ErfOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ExponentBase10Op>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ExponentBase2Op>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ExponentOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::FloorDivideOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::FloorOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::GRUGradientOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::GRUOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::GatherNDOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::GeluOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::GreaterThanOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::GreaterThanOrEqualToOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::HammingDistanceOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::IdentityOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ImToColOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ImaginaryPartOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::IsFiniteOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::IsInfiniteOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::IsNaNOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::LSTMGradientOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::LSTMOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::LeakyReluOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::LessThanOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::LessThanOrEqualToOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::LocalConvolutionDataGradientOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::LocalConvolutionOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::LocalConvolutionWeightGradientOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::LogarithmBase10Op>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::LogarithmBase2Op>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::LogarithmOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::MatMulOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::MaximumOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::MinimumOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ModuloOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::MultiplyOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::NReluOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::NandOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::NegativeOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::NorOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::NotEqualToOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::NotOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::OrOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::PReluOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::PoolAvgGradientOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::PoolAvgOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::PoolL2NormGradientOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::PoolL2NormOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::PoolMaxGradientOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::PoolMaxOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::PowerOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::PruningGradientOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::PruningOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::QuantizeOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ReadDataFromFileOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ReadVariableOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::RealPartOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ReciprocalOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ReciprocalSquareRootOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ReinterpretCastOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::Relu6Op>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ReluGradOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ReluOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::RintOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::RoundOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ScatterNDOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SelectOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SignOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SignbitOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SinOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SingleGateRNNGradientOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SingleGateRNNOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SinhOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SoftplusOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SoftplusParametricOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SoftsignOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SquareOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SquareRootOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::StencilOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SubtractOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SwishOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::TanOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::TanhOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::TruncateOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::TypeConstraintOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::VariableFromTensorOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::XnorOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::XorOp>>::isDynamicallyEncoded()
{
  return 0;
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::BroadcastToOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ConcatOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL result = 0;
  if ((*(unsigned char *)(a2 + 46) & 0x80) != 0)
  {
    int v3 = *(_DWORD *)(a2 + 68);
    if (v3)
    {
      if (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 32 * (v3 - 1) + 24)))return 1; {
    }
      }
  }
  return result;
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::Conv2DDataGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 88));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::Conv2DWeightsGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 88));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::Conv3DDataGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 88));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::Conv3DWeightsGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 88));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::CropOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56))
       || (*(unsigned char *)(a2 + 46) & 0x80) != 0
       && *(_DWORD *)(a2 + 68) >= 3u
       && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 88))
        || (*(unsigned char *)(a2 + 46) & 0x80) != 0
        && *(_DWORD *)(a2 + 68) >= 4u
        && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 120))));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::CumulativeMaximumOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::CumulativeMinimumOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::CumulativeProductOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::CumulativeSumOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::DepthwiseConv2DDataGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 88));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::DepthwiseConv2DWeightsGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 88));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::DepthwiseConv3DDataGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 88));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::DepthwiseConv3DWeightsGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 88));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ExpandDimsOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::FastFourierTransformOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::Flatten2DOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::GatherAlongAxisOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 88));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::GatherOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 88));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::GetCoordOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68)
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 24));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::HermiteanToRealFFTOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::InstanceNormOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::OneHotOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56))
       || (*(unsigned char *)(a2 + 46) & 0x80) != 0
       && *(_DWORD *)(a2 + 68) >= 3u
       && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 88)));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::PadGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::PadOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::PermuteOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::RealToHermiteanFFTOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReductionAndOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReductionArgMaxOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReductionArgMinOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReductionLogSumExpOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReductionMaxOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReductionMeanOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReductionMinOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReductionOrOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReductionProdOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReductionSumOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReductionVarianceOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReshapeOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ResizeGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ResizeOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReverseOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ScatterAlongAxisOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 4u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 120));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ScatterOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 4u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 120));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::SliceOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56))
       || (*(unsigned char *)(a2 + 46) & 0x80) != 0
       && *(_DWORD *)(a2 + 68) >= 3u
       && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 88))
        || (*(unsigned char *)(a2 + 46) & 0x80) != 0
        && *(_DWORD *)(a2 + 68) >= 4u
        && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 120))));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::SoftmaxOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::SortOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::SplitOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56))
       || (*(unsigned char *)(a2 + 46) & 0x80) != 0
       && *(_DWORD *)(a2 + 68) >= 3u
       && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 88)));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::SqueezeOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::StridedSliceGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56))
       || (*(unsigned char *)(a2 + 46) & 0x80) != 0
       && *(_DWORD *)(a2 + 68) >= 3u
       && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 88))
        || (*(unsigned char *)(a2 + 46) & 0x80) != 0
        && *(_DWORD *)(a2 + 68) >= 4u
        && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 120))
         || (*(unsigned char *)(a2 + 46) & 0x80) != 0
         && *(_DWORD *)(a2 + 68) >= 5u
         && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 152)))));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::StridedSliceOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56))
       || (*(unsigned char *)(a2 + 46) & 0x80) != 0
       && *(_DWORD *)(a2 + 68) >= 3u
       && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 88))
        || (*(unsigned char *)(a2 + 46) & 0x80) != 0
        && *(_DWORD *)(a2 + 68) >= 4u
        && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 120))));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::StridedSliceUpdateOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 88))
       || (*(unsigned char *)(a2 + 46) & 0x80) != 0
       && *(_DWORD *)(a2 + 68) >= 4u
       && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 120))
        || (*(unsigned char *)(a2 + 46) & 0x80) != 0
        && *(_DWORD *)(a2 + 68) >= 5u
        && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 152))));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::TileGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 88));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::TileOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::TopKGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 88))
       || (*(unsigned char *)(a2 + 46) & 0x80) != 0
       && *(_DWORD *)(a2 + 68) >= 4u
       && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 120)));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::TopKOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56))
       || (*(unsigned char *)(a2 + 46) & 0x80) != 0
       && *(_DWORD *)(a2 + 68) >= 3u
       && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 88)));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::TransposeOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 56))
       || (*(unsigned char *)(a2 + 46) & 0x80) != 0
       && *(_DWORD *)(a2 + 68) >= 3u
       && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 88)));
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::CallOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::DimensionSizeOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::RankOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::ShapeOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::SizeOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::RandomNormalOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::RandomTruncatedNormalOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::RandomUniformOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::InitRandomPhiloxStateOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::UpdateRandomStateOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::BatchToSpaceOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::SpaceToBatchOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::SpaceToDepth2DOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::DepthToSpace2DOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::BroadcastGradientArgsOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::CreateTextureTensorOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::MaterializeSparseTensorOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::MatrixDecompositionLUOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::MatrixInverseOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::MatrixSolverLUOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::NonMaximumSuppressionOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::SampleGridDataGradientOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::SampleGridOp>>::isDynamicallyEncoded()
{
  return 1;
}

void mlir::mps::registerMPSRuntimeDynamicEncodeOpExternalModels(mlir::DialectRegistry &)::$_1::__invoke(uint64_t *a1)
{
  int v2 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.fp_to_int_clamped", (const unsigned __int8 *)0x16, a1);
  if (!v3)
  {
    __int16 v156 = 1283;
    uint64_t v153 = "Attempting to attach an interface to an unregistered operation ";
    uint64_t v154 = "mpsx.fp_to_int_clamped";
    uint64_t v150 = 22;
    goto LABEL_86;
  }
  unint64_t v4 = v2;
  unint64_t v5 = (void *)v2[2];
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v157[0] = v2[1];
    uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v157);
    unint64_t v5 = (void *)v4[2];
  }
  else
  {
    uint64_t Values = v2[3];
  }
  uint64_t v7 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(Values, (uint64_t)v5, v7);
  unint64_t v8 = malloc(8uLL);
  unint64_t v9 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v4 + 4), v9, v8);
  unint64_t v10 = "mpsx.fusion_return";
  unint64_t v11 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.fusion_return", (const unsigned __int8 *)0x12, a1);
  if (!v12) {
    goto LABEL_75;
  }
  char v13 = v11;
  uint64_t v14 = (void *)v11[2];
  if (v14 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v157[0] = v11[1];
    uint64_t v15 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v157);
    uint64_t v14 = (void *)v13[2];
  }
  else
  {
    uint64_t v15 = v11[3];
  }
  uint64_t v16 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v15, (uint64_t)v14, v16);
  uint64_t v17 = malloc(8uLL);
  unint64_t v18 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v13 + 4), v18, v17);
  unint64_t v19 = "mpsx.quantized_matmul";
  unint64_t v20 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.quantized_matmul", (const unsigned __int8 *)0x15, a1);
  if (!v21) {
    goto LABEL_76;
  }
  uint64_t v22 = v20;
  unint64_t v23 = (void *)v20[2];
  if (v23 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v157[0] = v20[1];
    uint64_t v24 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v157);
    unint64_t v23 = (void *)v22[2];
  }
  else
  {
    uint64_t v24 = v20[3];
  }
  uint64_t v25 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v24, (uint64_t)v23, v25);
  uint64_t v26 = malloc(8uLL);
  unint64_t v27 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v22 + 4), v27, v26);
  unint64_t v10 = "mpsx.region_return";
  unint64_t v28 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.region_return", (const unsigned __int8 *)0x12, a1);
  if (!v29) {
    goto LABEL_75;
  }
  unint64_t v30 = v28;
  unint64_t v31 = (void *)v28[2];
  if (v31 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v157[0] = v28[1];
    uint64_t v32 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v157);
    unint64_t v31 = (void *)v30[2];
  }
  else
  {
    uint64_t v32 = v28[3];
  }
  uint64_t v33 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v32, (uint64_t)v31, v33);
  unint64_t v34 = malloc(8uLL);
  unint64_t v35 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v30 + 4), v35, v34);
  int64x2_t v36 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.stitched_return", (const unsigned __int8 *)0x14, a1);
  if (!v37)
  {
    __int16 v156 = 1283;
    uint64_t v153 = "Attempting to attach an interface to an unregistered operation ";
    uint64_t v154 = "mpsx.stitched_return";
    uint64_t v150 = 20;
    goto LABEL_86;
  }
  int64x2_t v38 = v36;
  uint64_t v39 = (void *)v36[2];
  if (v39 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v157[0] = v36[1];
    uint64_t v40 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v157);
    uint64_t v39 = (void *)v38[2];
  }
  else
  {
    uint64_t v40 = v36[3];
  }
  uint64_t v41 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v40, (uint64_t)v39, v41);
  uint64_t v42 = malloc(8uLL);
  unint64_t v43 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v38 + 4), v43, v42);
  uint64_t v44 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.sdpa", (const unsigned __int8 *)9, a1);
  if (!v45)
  {
    __int16 v156 = 1283;
    uint64_t v153 = "Attempting to attach an interface to an unregistered operation ";
    uint64_t v154 = "mpsx.sdpa";
    uint64_t v150 = 9;
    goto LABEL_86;
  }
  uint64_t v46 = v44;
  unint64_t v47 = (void *)v44[2];
  if (v47 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v157[0] = v44[1];
    uint64_t v48 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v157);
    unint64_t v47 = (void *)v46[2];
  }
  else
  {
    uint64_t v48 = v44[3];
  }
  uint64_t v49 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v48, (uint64_t)v47, v49);
  uint64_t v50 = malloc(8uLL);
  unint64_t v51 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v46 + 4), v51, v50);
  uint64_t v52 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.var_handle", (const unsigned __int8 *)0xF, a1);
  if (!v53)
  {
    __int16 v156 = 1283;
    uint64_t v153 = "Attempting to attach an interface to an unregistered operation ";
    uint64_t v154 = "mpsx.var_handle";
    uint64_t v150 = 15;
    goto LABEL_86;
  }
  uint64_t v54 = v52;
  long long v55 = (void *)v52[2];
  if (v55 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v157[0] = v52[1];
    uint64_t v56 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v157);
    long long v55 = (void *)v54[2];
  }
  else
  {
    uint64_t v56 = v52[3];
  }
  uint64_t v57 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v56, (uint64_t)v55, v57);
  long long v58 = malloc(8uLL);
  unint64_t v59 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v54 + 4), v59, v58);
  uint64_t v60 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.fusion", (const unsigned __int8 *)0xB, a1);
  if (!v61)
  {
    __int16 v156 = 1283;
    uint64_t v153 = "Attempting to attach an interface to an unregistered operation ";
    uint64_t v154 = "mpsx.fusion";
    uint64_t v150 = 11;
    goto LABEL_86;
  }
  char v62 = v60;
  char v63 = (void *)v60[2];
  if (v63 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v157[0] = v60[1];
    uint64_t v64 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v157);
    char v63 = (void *)v62[2];
  }
  else
  {
    uint64_t v64 = v60[3];
  }
  uint64_t v65 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v64, (uint64_t)v63, v65);
  uint64_t v66 = malloc(8uLL);
  unint64_t v67 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v62 + 4), v67, v66);
  unint64_t v19 = "mpsx.quantized_gather";
  unint64_t v68 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.quantized_gather", (const unsigned __int8 *)0x15, a1);
  if (!v69)
  {
LABEL_76:
    __int16 v156 = 1283;
    uint64_t v153 = "Attempting to attach an interface to an unregistered operation ";
    uint64_t v154 = v19;
    uint64_t v150 = 21;
    goto LABEL_86;
  }
  uint64_t v70 = v68;
  char v71 = (void *)v68[2];
  if (v71 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v157[0] = v68[1];
    uint64_t v72 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v157);
    char v71 = (void *)v70[2];
  }
  else
  {
    uint64_t v72 = v68[3];
  }
  uint64_t v73 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v72, (uint64_t)v71, v73);
  uint64_t v74 = malloc(8uLL);
  unint64_t v75 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v70 + 4), v75, v74);
  uint64_t v76 = "mpsx.rms_norm";
  unint64_t v77 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.rms_norm", (const unsigned __int8 *)0xD, a1);
  if (!v78) {
    goto LABEL_77;
  }
  uint64_t v79 = v77;
  char v80 = (void *)v77[2];
  if (v80 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v157[0] = v77[1];
    uint64_t v81 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v157);
    char v80 = (void *)v79[2];
  }
  else
  {
    uint64_t v81 = v77[3];
  }
  uint64_t v82 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v81, (uint64_t)v80, v82);
  uint64_t v83 = malloc(8uLL);
  unint64_t v84 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v79 + 4), v84, v83);
  uint64_t v76 = "mpsx.stitched";
  uint64_t v85 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.stitched", (const unsigned __int8 *)0xD, a1);
  if (!v86)
  {
LABEL_77:
    __int16 v156 = 1283;
    uint64_t v153 = "Attempting to attach an interface to an unregistered operation ";
    uint64_t v154 = v76;
    uint64_t v150 = 13;
    goto LABEL_86;
  }
  uint64_t v87 = v85;
  char v88 = (void *)v85[2];
  if (v88 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v157[0] = v85[1];
    uint64_t v89 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v157);
    char v88 = (void *)v87[2];
  }
  else
  {
    uint64_t v89 = v85[3];
  }
  uint64_t v90 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v89, (uint64_t)v88, v90);
  uint64_t v91 = malloc(8uLL);
  unint64_t v92 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v87 + 4), v92, v91);
  uint64_t v93 = "mpsx.cpu";
  unint64_t v94 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.cpu", (const unsigned __int8 *)8, a1);
  if (!v95) {
    goto LABEL_74;
  }
  char v96 = v94;
  uint64_t v97 = (void *)v94[2];
  if (v97 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v157[0] = v94[1];
    uint64_t v98 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v157);
    uint64_t v97 = (void *)v96[2];
  }
  else
  {
    uint64_t v98 = v94[3];
  }
  uint64_t v99 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v98, (uint64_t)v97, v99);
  uint64_t v100 = malloc(8uLL);
  unint64_t v101 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v96 + 4), v101, v100);
  uint64_t v93 = "mpsx.ane";
  unint64_t v102 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.ane", (const unsigned __int8 *)8, a1);
  if (!v103) {
    goto LABEL_74;
  }
  char v104 = v102;
  char v105 = (void *)v102[2];
  if (v105 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v157[0] = v102[1];
    uint64_t v106 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v157);
    char v105 = (void *)v104[2];
  }
  else
  {
    uint64_t v106 = v102[3];
  }
  uint64_t v107 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v106, (uint64_t)v105, v107);
  uint64_t v108 = malloc(8uLL);
  unint64_t v109 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v104 + 4), v109, v108);
  uint64_t v93 = "mpsx.gpu";
  unint64_t v110 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.gpu", (const unsigned __int8 *)8, a1);
  if (!v111)
  {
LABEL_74:
    __int16 v156 = 1283;
    uint64_t v153 = "Attempting to attach an interface to an unregistered operation ";
    uint64_t v154 = v93;
    uint64_t v150 = 8;
    goto LABEL_86;
  }
  char v112 = v110;
  uint64_t v113 = (void *)v110[2];
  if (v113 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v157[0] = v110[1];
    uint64_t v114 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v157);
    uint64_t v113 = (void *)v112[2];
  }
  else
  {
    uint64_t v114 = v110[3];
  }
  uint64_t v115 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v114, (uint64_t)v113, v115);
  uint64_t v116 = malloc(8uLL);
  unint64_t v117 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v112 + 4), v117, v116);
  unint64_t v10 = "mpsx.list_pop_back";
  uint64_t v118 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.list_pop_back", (const unsigned __int8 *)0x12, a1);
  if (!v119)
  {
LABEL_75:
    __int16 v156 = 1283;
    uint64_t v153 = "Attempting to attach an interface to an unregistered operation ";
    uint64_t v154 = v10;
    uint64_t v150 = 18;
    goto LABEL_86;
  }
  unint64_t v120 = v118;
  uint64_t v121 = (void *)v118[2];
  if (v121 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v157[0] = v118[1];
    uint64_t v122 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v157);
    uint64_t v121 = (void *)v120[2];
  }
  else
  {
    uint64_t v122 = v118[3];
  }
  uint64_t v123 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v122, (uint64_t)v121, v123);
  uint64_t v124 = malloc(8uLL);
  unint64_t v125 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v120 + 4), v125, v124);
  uint64_t v126 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.list_push_back", (const unsigned __int8 *)0x13, a1);
  if (!v127)
  {
    __int16 v156 = 1283;
    uint64_t v153 = "Attempting to attach an interface to an unregistered operation ";
    uint64_t v154 = "mpsx.list_push_back";
    uint64_t v150 = 19;
    goto LABEL_86;
  }
  char v128 = v126;
  unint64_t v129 = (void *)v126[2];
  if (v129 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v157[0] = v126[1];
    uint64_t v130 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v157);
    unint64_t v129 = (void *)v128[2];
  }
  else
  {
    uint64_t v130 = v126[3];
  }
  uint64_t v131 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v130, (uint64_t)v129, v131);
  uint64_t v132 = malloc(8uLL);
  unint64_t v133 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v128 + 4), v133, v132);
  uint64_t v134 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.make_list", (const unsigned __int8 *)0xE, a1);
  if (!v135)
  {
    __int16 v156 = 1283;
    uint64_t v153 = "Attempting to attach an interface to an unregistered operation ";
    uint64_t v154 = "mpsx.make_list";
    uint64_t v150 = 14;
    goto LABEL_86;
  }
  char v136 = v134;
  unint64_t v137 = (void *)v134[2];
  if (v137 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v157[0] = v134[1];
    uint64_t v138 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v157);
    unint64_t v137 = (void *)v136[2];
  }
  else
  {
    uint64_t v138 = v134[3];
  }
  uint64_t v139 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v138, (uint64_t)v137, v139);
  char v140 = malloc(8uLL);
  unint64_t v141 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v136 + 4), v141, v140);
  unint64_t v142 = (void *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.sparse_dense_matmul", (const unsigned __int8 *)0x18, a1);
  if (!v143)
  {
    __int16 v156 = 1283;
    uint64_t v153 = "Attempting to attach an interface to an unregistered operation ";
    uint64_t v154 = "mpsx.sparse_dense_matmul";
    uint64_t v150 = 24;
LABEL_86:
    uint64_t v155 = v150;
    uint64_t v151 = ".";
    __int16 v152 = 259;
    llvm::operator+((uint64_t *)&v153, (uint64_t *)&v151, (uint64_t)v157);
    llvm::report_fatal_error((llvm::Twine *)v157, 1);
  }
  uint64_t v144 = v142;
  __int16 v145 = (void *)v142[2];
  if (v145 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v157[0] = v142[1];
    uint64_t v146 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v157);
    __int16 v145 = (void *)v144[2];
  }
  else
  {
    uint64_t v146 = v142[3];
  }
  uint64_t v147 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v146, (uint64_t)v145, v147);
  uint64_t v148 = malloc(8uLL);
  unint64_t v149 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v144 + 4), v149, v148);
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mpsx::FPToIntClampedOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mpsx::FusionReturnOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mpsx::QuantizedMatMulOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mpsx::RegionReturnOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mpsx::ReturnStitchedOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mpsx::ScaledDotProductAttentionOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mpsx::VarHandleOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mpsx::FusionOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v13 = a2;
  Body = (mlir::Region *)mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v13);
  mlir::Region::OpIterator::OpIterator(&v14, Body, 0);
  mlir::Region::OpIterator::OpIterator(&v11, Body, 1);
  unint64_t v5 = v15;
  unint64_t v6 = v12;
  if (v15 == v12) {
    return 0;
  }
  while (1)
  {
    mlir::GenericProgramPoint::~GenericProgramPoint(v5);
    uint64_t v8 = v7;
    if (!mlir::OpInterface<mlir::MPSRuntimeDynamicEncodeOpInterface,mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits>::getInterfaceFor(v7)) {
      break;
    }
    uint64_t InterfaceFor = (uint64_t (**)(void, uint64_t, uint64_t))mlir::OpInterface<mlir::MPSRuntimeDynamicEncodeOpInterface,mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits>::getInterfaceFor(v8);
    if (!v8 || ((*InterfaceFor)(InterfaceFor, v8, a3) & 1) != 0) {
      break;
    }
    mlir::Region::OpIterator::operator++((uint64_t *)&v14);
    unint64_t v5 = v15;
    if (v15 == v6) {
      return 0;
    }
  }
  return 1;
}

uint64_t mlir::OpInterface<mlir::MPSRuntimeDynamicEncodeOpInterface,mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits>::getInterfaceFor(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  int v2 = *(void **)(v1 + 16);
  BOOL v3 = v2 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 48);
  }
  if (v3)
  {
    uint64_t v22 = *(void *)(v1 + 8);
    uint64_t result = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v22);
    if (result)
    {
      uint64_t v20 = result;
      uint64_t v21 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v20 + 104))(v20, v21, v1);
    }
  }
  else
  {
    unint64_t v6 = v4 | v1 & 0xFFFFFFFFFFFFFF00;
    unint64_t v7 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
    unint64_t v8 = *(unsigned int *)(v6 + 40);
    if (!v8) {
      goto LABEL_14;
    }
    unint64_t v9 = *(void **)(v6 + 32);
    unint64_t v10 = &v9[2 * v8];
    do
    {
      unint64_t v11 = v8 >> 1;
      char v12 = &v9[2 * (v8 >> 1)];
      unint64_t v14 = *v12;
      uint64_t v13 = v12 + 2;
      v8 += ~(v8 >> 1);
      if (v14 < v7) {
        unint64_t v9 = v13;
      }
      else {
        unint64_t v8 = v11;
      }
    }
    while (v8);
    if (v9 == v10 || *v9 != v7 || (uint64_t result = v9[1]) == 0)
    {
LABEL_14:
      uint64_t v16 = *(void *)(v6 + 24);
      uint64_t v17 = *(void *)(a1 + 48);
      uint64_t v18 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
      unint64_t v19 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v16 + 104);
      return v19(v16, v18, v17);
    }
  }
  return result;
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mpsx::QuantizedGatherOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 88));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mpsx::RMSNormOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(unsigned char *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(void *)(*(void *)(a2 + 72) + 88));
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mpsx::StitchedOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v13 = a2;
  Body = (mlir::Region *)mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v13);
  mlir::Region::OpIterator::OpIterator(&v14, Body, 0);
  mlir::Region::OpIterator::OpIterator(&v11, Body, 1);
  unint64_t v5 = v15;
  unint64_t v6 = v12;
  if (v15 == v12) {
    return 0;
  }
  while (1)
  {
    mlir::GenericProgramPoint::~GenericProgramPoint(v5);
    uint64_t v8 = v7;
    if (!mlir::OpInterface<mlir::MPSRuntimeDynamicEncodeOpInterface,mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits>::getInterfaceFor(v7)) {
      break;
    }
    uint64_t InterfaceFor = (uint64_t (**)(void, uint64_t, uint64_t))mlir::OpInterface<mlir::MPSRuntimeDynamicEncodeOpInterface,mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits>::getInterfaceFor(v8);
    if (!v8 || ((*InterfaceFor)(InterfaceFor, v8, a3) & 1) != 0) {
      break;
    }
    mlir::Region::OpIterator::operator++((uint64_t *)&v14);
    unint64_t v5 = v15;
    if (v15 == v6) {
      return 0;
    }
  }
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mpsx::CPUOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mpsx::ANEOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mpsx::GPUOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mpsx::ListPopBackOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mpsx::ListPushBackOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mpsx::MakeListOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mpsx::SparseDenseMatMulOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::mps::createLoweringPass@<X0>(unsigned char *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x498uLL);
  *(void *)uint64_t v5 = &unk_1EC9C7A28;
  *(unsigned char *)(v5 + 472) = *a1;
  uint64_t v6 = *(void *)(v5 + 528);
  if (!v6) {
    goto LABEL_6;
  }
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v6 + 48))(v6, a1);
  v4[680] = a1[1];
  uint64_t v7 = *((void *)v4 + 92);
  if (!v7) {
    goto LABEL_6;
  }
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v7 + 48))(v7, a1 + 1);
  v4[888] = a1[2];
  uint64_t v8 = *((void *)v4 + 118);
  if (!v8) {
    goto LABEL_6;
  }
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v8 + 48))(v8, a1 + 2);
  char v10 = a1[3];
  unint64_t v9 = a1 + 3;
  v4[1096] = v10;
  uint64_t v11 = *((void *)v4 + 144);
  if (v11)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)v11 + 48))(v11, v9);
    *a2 = v4;
  }
  else
  {
LABEL_6:
    uint64_t v13 = std::__throw_bad_function_call[abi:nn180100]();
  }
  return result;
}

uint64_t mlir::mps::MPSLoweringBase<mlir::mps::anonymous namespace'::LoweringPass>::MPSLoweringBase(uint64_t a1)
{
  *(void *)(a1 + 16) = "func.func";
  *(void *)(a1 + 24) = 9;
  *(unsigned char *)(a1 + 32) = 1;
  *(unsigned char *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 120) = 0;
  int v2 = (void *)(a1 + 152);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = a1 + 200;
  *(void *)(a1 + 192) = 0x400000000;
  *(void *)(a1 + 232) = a1 + 248;
  *(void *)(a1 + 240) = 0x400000000;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 296) = 0x1000000000;
  *(void *)(a1 + 336) = 0;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(void *)a1 = &unk_1EC9CA608;
  v6.n128_u64[0] = (unint64_t)"MPS Runtime supports Convolution Kernels with int8 inputs";
  v6.n128_u64[1] = 57;
  char v4 = 0;
  uint64_t v5 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 344), (void *)(a1 + 152), (uint64_t)"native-int8-conv", 16, &v6, &v5);
  *(void *)(a1 + 344) = &unk_1EC9CB060;
  *(void *)(a1 + 536) = &unk_1EC9CB0E0;
  v6.n128_u64[0] = (unint64_t)"MPS Runtime supports GEMM Kernels with int8 inputs";
  v6.n128_u64[1] = 50;
  char v4 = 0;
  uint64_t v5 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 552), v2, (uint64_t)"native-int8-gemm", 16, &v6, &v5);
  *(void *)(a1 + 552) = &unk_1EC9CB060;
  *(void *)(a1 + 744) = &unk_1EC9CB0E0;
  v6.n128_u64[0] = (unint64_t)"MPS Runtime supports Convolution Kernels with int8 + zeroPoint inputs";
  v6.n128_u64[1] = 69;
  char v4 = 0;
  uint64_t v5 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 760), v2, (uint64_t)"native-int8-conv-zp", 19, &v6, &v5);
  *(void *)(a1 + 760) = &unk_1EC9CB060;
  *(void *)(a1 + 952) = &unk_1EC9CB0E0;
  v6.n128_u64[0] = (unint64_t)"MPS Runtime supports GEMM Kernels with int8 + zeroPoint inputs";
  v6.n128_u64[1] = 62;
  char v4 = 0;
  uint64_t v5 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 968), v2, (uint64_t)"native-int8-gemm-zp", 19, &v6, &v5);
  *(void *)(a1 + 968) = &unk_1EC9CB060;
  *(void *)(a1 + 1160) = &unk_1EC9CB0E0;
  return a1;
}

void mlir::mps::anonymous namespace'::LoweringPass::~LoweringPass(mlir::mps::_anonymous_namespace_::LoweringPass *this)
{
  *(void *)this = &unk_1EC9CA608;
  *((void *)this + 121) = &unk_1EC9A3F00;
  int v2 = (char *)this + 1128;
  BOOL v3 = (char *)*((void *)this + 144);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  *((void *)this + 121) = &unk_1EC9A42A8;
  char v4 = (void *)*((void *)this + 133);
  if (v4 != *((void **)this + 132)) {
    free(v4);
  }
  uint64_t v5 = (char *)*((void *)this + 129);
  if (v5 != (char *)this + 1048) {
    free(v5);
  }
  *((void *)this + 95) = &unk_1EC9A3F00;
  __n128 v6 = (mlir::mps::_anonymous_namespace_::LoweringPass *)*((void *)this + 118);
  if (v6 == (mlir::mps::_anonymous_namespace_::LoweringPass *)((char *)this + 920))
  {
    (*(void (**)(char *))(*((void *)this + 115) + 32))((char *)this + 920);
  }
  else if (v6)
  {
    (*(void (**)(mlir::mps::_anonymous_namespace_::LoweringPass *))(*(void *)v6 + 40))(v6);
  }
  *((void *)this + 95) = &unk_1EC9A42A8;
  uint64_t v7 = (void *)*((void *)this + 107);
  if (v7 != *((void **)this + 106)) {
    free(v7);
  }
  uint64_t v8 = (char *)*((void *)this + 103);
  if (v8 != (char *)this + 840) {
    free(v8);
  }
  *((void *)this + 69) = &unk_1EC9A3F00;
  unint64_t v9 = (mlir::mps::_anonymous_namespace_::LoweringPass *)*((void *)this + 92);
  if (v9 == (mlir::mps::_anonymous_namespace_::LoweringPass *)((char *)this + 712))
  {
    (*(void (**)(char *))(*((void *)this + 89) + 32))((char *)this + 712);
  }
  else if (v9)
  {
    (*(void (**)(mlir::mps::_anonymous_namespace_::LoweringPass *))(*(void *)v9 + 40))(v9);
  }
  *((void *)this + 69) = &unk_1EC9A42A8;
  char v10 = (void *)*((void *)this + 81);
  if (v10 != *((void **)this + 80)) {
    free(v10);
  }
  uint64_t v11 = (char *)*((void *)this + 77);
  if (v11 != (char *)this + 632) {
    free(v11);
  }
  *((void *)this + 43) = &unk_1EC9A3F00;
  char v12 = (mlir::mps::_anonymous_namespace_::LoweringPass *)*((void *)this + 66);
  if (v12 == (mlir::mps::_anonymous_namespace_::LoweringPass *)((char *)this + 504))
  {
    (*(void (**)(char *))(*((void *)this + 63) + 32))((char *)this + 504);
  }
  else if (v12)
  {
    (*(void (**)(mlir::mps::_anonymous_namespace_::LoweringPass *))(*(void *)v12 + 40))(v12);
  }
  *((void *)this + 43) = &unk_1EC9A42A8;
  uint64_t v13 = (void *)*((void *)this + 55);
  if (v13 != *((void **)this + 54)) {
    free(v13);
  }
  long long v14 = (char *)*((void *)this + 51);
  if (v14 != (char *)this + 424) {
    free(v14);
  }

  mlir::Pass::~Pass(this);
}

{
  void *v1;
  uint64_t vars8;

  operator delete(v1);
}

const char *mlir::mps::MPSLoweringBase<mlir::mps::anonymous namespace'::LoweringPass>::getName()
{
  return "MPSLowering";
}

void *mlir::mps::MPSLoweringBase<mlir::mps::anonymous namespace'::LoweringPass>::getDependentDialects(int a1, uint64_t **a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v4[0] = &unk_1EC9CEEE0;
  uint64_t v5 = v4;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::mps::MPSDialect,void>::id, "mps", 3uLL, v4);
  if (v5 == v4)
  {
    (*(void (**)(void *))(v4[0] + 32))(v4);
  }
  else if (v5)
  {
    (*(void (**)(void))(*v5 + 40))();
  }
  v4[0] = &unk_1EC9CF000;
  uint64_t v5 = v4;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::mpsx::MPSXDialect,void>::id, "mpsx", 4uLL, v4);
  if (v5 == v4)
  {
    (*(void (**)(void *))(v4[0] + 32))(v4);
  }
  else if (v5)
  {
    (*(void (**)(void))(*v5 + 40))();
  }
  v4[0] = &unk_1EC97F438;
  uint64_t v5 = v4;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::arith::ArithDialect,void>::id, "arith", 5uLL, v4);
  if (v5 == v4)
  {
    (*(void (**)(void *))(v4[0] + 32))(v4);
  }
  else if (v5)
  {
    (*(void (**)(void))(*v5 + 40))();
  }
  v4[0] = &unk_1EC9CF090;
  uint64_t v5 = v4;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::tensor::TensorDialect,void>::id, "tensor", 6uLL, v4);
  uint64_t result = v5;
  if (v5 == v4) {
    return (void *)(*(uint64_t (**)(void *))(v4[0] + 32))(v4);
  }
  if (v5) {
    return (void *)(*(uint64_t (**)(void))(*v5 + 40))();
  }
  return result;
}

const char *mlir::mps::MPSLoweringBase<mlir::mps::anonymous namespace'::LoweringPass>::getArgument()
{
  return "mps-lowering";
}

const char *mlir::mps::MPSLoweringBase<mlir::mps::anonymous namespace'::LoweringPass>::getDescription()
{
  return "Lower high-level MPS ops to lower-level MPS ops.";
}

void mlir::mps::anonymous namespace'::LoweringPass::runOnOperation(mlir::mps::_anonymous_namespace_::LoweringPass *this)
{
}

void *mlir::mps::MPSLoweringBase<mlir::mps::anonymous namespace'::LoweringPass>::clonePass@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  char v4 = operator new(0x498uLL);
  uint64_t v5 = *(void *)(a1 + 8);
  v4[1] = *(_OWORD *)(a1 + 16);
  *((void *)v4 + 4) = *(void *)(a1 + 32);
  *((void *)v4 + 1) = v5;
  *((unsigned char *)v4 + 40) = 0;
  *((unsigned char *)v4 + 120) = 0;
  v4[8] = 0u;
  v4[9] = 0u;
  v4[10] = 0u;
  *((void *)v4 + 22) = 0;
  *((void *)v4 + 23) = (char *)v4 + 200;
  *((void *)v4 + 24) = 0x400000000;
  *((void *)v4 + 29) = (char *)v4 + 248;
  *((void *)v4 + 30) = 0x400000000;
  *((void *)v4 + 35) = 0;
  *((void *)v4 + 36) = 0;
  *((_DWORD *)v4 + 74) = 0;
  *((_DWORD *)v4 + 75) = 16;
  v4[19] = 0u;
  v4[20] = 0u;
  *((void *)v4 + 42) = 0;
  *(void *)char v4 = &unk_1EC9CA608;
  v9.n128_u64[0] = (unint64_t)"MPS Runtime supports Convolution Kernels with int8 inputs";
  v9.n128_u64[1] = 57;
  char v7 = 0;
  uint64_t v8 = &v7;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)v4 + 43, (void *)v4 + 19, (uint64_t)"native-int8-conv", 16, &v9, &v8);
  *((void *)v4 + 43) = &unk_1EC9CB060;
  *((void *)v4 + 67) = &unk_1EC9CB0E0;
  v9.n128_u64[0] = (unint64_t)"MPS Runtime supports GEMM Kernels with int8 inputs";
  v9.n128_u64[1] = 50;
  char v7 = 0;
  uint64_t v8 = &v7;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)v4 + 69, (void *)v4 + 19, (uint64_t)"native-int8-gemm", 16, &v9, &v8);
  *((void *)v4 + 69) = &unk_1EC9CB060;
  *((void *)v4 + 93) = &unk_1EC9CB0E0;
  v9.n128_u64[0] = (unint64_t)"MPS Runtime supports Convolution Kernels with int8 + zeroPoint inputs";
  v9.n128_u64[1] = 69;
  char v7 = 0;
  uint64_t v8 = &v7;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)v4 + 95, (void *)v4 + 19, (uint64_t)"native-int8-conv-zp", 19, &v9, &v8);
  *((void *)v4 + 95) = &unk_1EC9CB060;
  *((void *)v4 + 119) = &unk_1EC9CB0E0;
  v9.n128_u64[0] = (unint64_t)"MPS Runtime supports GEMM Kernels with int8 + zeroPoint inputs";
  v9.n128_u64[1] = 62;
  char v7 = 0;
  uint64_t v8 = &v7;
  uint64_t result = mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)v4 + 121, (void *)v4 + 19, (uint64_t)"native-int8-gemm-zp", 19, &v9, &v8);
  *((void *)v4 + 121) = &unk_1EC9CB060;
  *((void *)v4 + 145) = &unk_1EC9CB0E0;
  *(void *)char v4 = &unk_1EC9C7A28;
  *a2 = v4;
  return result;
}

void *std::__function::__func<void mlir::DialectRegistry::insert<mlir::arith::ArithDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::arith::ArithDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EC97F438;
  return result;
}

void std::__function::__func<void mlir::DialectRegistry::insert<mlir::arith::ArithDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::arith::ArithDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EC97F438;
}

mlir::Dialect *std::__function::__func<void mlir::DialectRegistry::insert<mlir::arith::ArithDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::arith::ArithDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::operator()(uint64_t a1, void **a2)
{
  return mlir::MLIRContext::getOrLoadDialect(*a2, (uint64_t)"arith", 5, (uint64_t)&mlir::detail::TypeIDResolver<mlir::arith::ArithDialect,void>::id, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::arith::ArithDialect * mlir::MLIRContext::getOrLoadDialect<mlir::arith::ArithDialect>(void)::{lambda(void)#1}>, (uint64_t)&v3);
}

void mlir::mps::anonymous namespace'::LoweringPass::lower(mlir::mps::_anonymous_namespace_::LoweringPass *this, mlir::Operation *a2)
{
  uint64_t v609 = *MEMORY[0x1E4F143B8];
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Operation *)((char *)a2 + 24));
  mlir::mps::MPSConversionTarget::MPSConversionTarget((mlir::mps::MPSConversionTarget *)v607, Context);
  v571[0] = *((unsigned char *)this + 472);
  v571[1] = *((unsigned char *)this + 680);
  v571[2] = *((unsigned char *)this + 888);
  v571[3] = *((unsigned char *)this + 1096);
  mlir::OperationName::OperationName(&v589, "mps.bias_add_grad", 17, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.bias_add", 12, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.degamma", 11, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mpsx.deinterleave", 17, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.dequantize", 14, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.dirac", 9, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.elu", 7, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.floor_divide", 16, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.gelu", 8, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.instance_norm", 17, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mpsx.interleave", 15, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.lp_norm", 11, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.leaky_relu", 14, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.normalization", 17, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.non_zero", 12, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.prelu", 9, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.quantize", 12, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.reduction_logsumexp", 23, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.reduction_mean", 18, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.reduction_variance", 22, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.relu6", 9, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.relu_grad", 13, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.relu", 8, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.n_relu", 10, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.sigmoid_gradient", 20, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.sigmoid_gradient_with_sigmoid", 33, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.sigmoid_hard", 16, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.sigmoid", 11, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.softplus", 12, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.softplus_parametric", 23, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.softsign", 12, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.swish", 9, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  mlir::OperationName::OperationName(&v589, "mps.truncate", 12, v608);
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v589, 2);
  char v589 = (void (**)(void **))&unk_1EC9CF250;
  LOBYTE(v590) = 0;
  v592[0] = &v589;
  mlir::OperationName::OperationName(&v574, "mpsx.quantized_matmul", 21, v608);
  uint64_t v5 = (uint64_t)v574;
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v574, 1);
  mlir::ConversionTarget::setLegalityCallback((uint64_t)v607, v5, &v589);
  if ((void (***)(void **))v592[0] == &v589)
  {
    v589[4]((void **)&v589);
  }
  else if (v592[0])
  {
    (*(void (**)(void))(*(void *)v592[0] + 40))(v592[0]);
  }
  char v589 = (void (**)(void **))&unk_1EC9CF208;
  LOBYTE(v590) = 0;
  v592[0] = &v589;
  mlir::OperationName::OperationName(&v574, "mps.softmax", 11, v608);
  uint64_t v6 = (uint64_t)v574;
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v574, 1);
  mlir::ConversionTarget::setLegalityCallback((uint64_t)v607, v6, &v589);
  if ((void (***)(void **))v592[0] == &v589)
  {
    v589[4]((void **)&v589);
  }
  else if (v592[0])
  {
    (*(void (**)(void))(*(void *)v592[0] + 40))(v592[0]);
  }
  char v589 = (void (**)(void **))&unk_1EC9CF1C0;
  v590 = v571;
  v592[0] = &v589;
  mlir::OperationName::OperationName(&v574, "mps.dequantize", 14, v608);
  uint64_t v7 = (uint64_t)v574;
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v574, 1);
  mlir::ConversionTarget::setLegalityCallback((uint64_t)v607, v7, &v589);
  if ((void (***)(void **))v592[0] == &v589)
  {
    v589[4]((void **)&v589);
  }
  else if (v592[0])
  {
    (*(void (**)(void))(*(void *)v592[0] + 40))(v592[0]);
  }
  char v589 = (void (**)(void **))&unk_1EC9D1118;
  LOBYTE(v590) = 0;
  v592[0] = &v589;
  mlir::OperationName::OperationName(&v574, "mps.dequantize_lut", 18, v608);
  uint64_t v8 = (uint64_t)v574;
  mlir::ConversionTarget::setOpAction((uint64_t)v607, (uint64_t)v574, 1);
  mlir::ConversionTarget::setLegalityCallback((uint64_t)v607, v8, &v589);
  if ((void (***)(void **))v592[0] == &v589)
  {
    v589[4]((void **)&v589);
  }
  else if (v592[0])
  {
    (*(void (**)(void))(*(void *)v592[0] + 40))(v592[0]);
  }
  long long v605 = 0u;
  long long v606 = 0u;
  uint64_t v603 = 0;
  memset(v600, 0, sizeof(v600));
  long long v599 = 0u;
  long long v597 = 0u;
  memset(v598, 0, sizeof(v598));
  memset(v596, 0, sizeof(v596));
  long long v595 = 0u;
  memset(v594, 0, sizeof(v594));
  long long v593 = 0u;
  memset(v592, 0, sizeof(v592));
  char v589 = (void (**)(void **))&unk_1EC9AA670;
  v590 = v592;
  uint64_t v591 = 0x400000000;
  *(void *)&long long v593 = v594;
  *(void *)&long long v595 = v596;
  HIDWORD(v593) = 2;
  HIDWORD(v595) = 2;
  *(void *)&long long v597 = v598;
  HIDWORD(v597) = 2;
  *(void *)&long long v599 = v600;
  HIDWORD(v599) = 2;
  uint64_t v601 = 0;
  uint64_t v602 = 0;
  uint64_t v604 = 0;
  *(void *)&long long v605 = 0;
  DWORD2(v605) = 0;
  llvm::sys::RWMutexImpl::RWMutexImpl((llvm::sys::RWMutexImpl *)&v606);
  *((void *)&v606 + 1) = 0;
  char v589 = (void (**)(void **))&unk_1EC9C9080;
  v574 = (mlir::MLIRContext *)&unk_1EC9CFC88;
  __p[0] = &v589;
  v576[0] = (mlir::Operation *)&v574;
  mlir::TypeConverter::registerConversion((unsigned int *)&v589, (uint64_t)&v574);
  if ((mlir::MLIRContext **)v576[0] == &v574)
  {
    (*((void (**)(mlir::MLIRContext **))v574 + 4))(&v574);
  }
  else if (v576[0])
  {
    (*(void (**)(void))(*(void *)v576[0] + 40))();
  }
  v574 = (mlir::MLIRContext *)&unk_1EC9CFCD0;
  v576[0] = (mlir::Operation *)&v574;
  if (DWORD2(v595) >= HIDWORD(v595))
  {
    llvm::SmallVectorTemplateBase<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>,false>::growAndEmplaceBack<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>>((uint64_t)&v595, (uint64_t)&v574);
  }
  else
  {
    *(void *)(v595 + 32 * DWORD2(v595) + 24) = v595 + 32 * DWORD2(v595);
    (*(void (**)(mlir::Operation *))(*(void *)v576[0] + 24))(v576[0]);
    ++DWORD2(v595);
  }
  if ((mlir::MLIRContext **)v576[0] == &v574)
  {
    (*((void (**)(mlir::MLIRContext **))v574 + 4))(&v574);
  }
  else if (v576[0])
  {
    (*(void (**)(void))(*(void *)v576[0] + 40))();
  }
  v574 = Context;
  *(_OWORD *)__p = 0u;
  *(_OWORD *)uint64_t v576 = 0u;
  uint64_t v577 = &v579;
  uint64_t v578 = 0x600000000;
  uint64_t v581 = 0;
  v580 = 0;
  int v582 = 0;
  uint64_t v583 = 0;
  uint64_t v584 = 0;
  uint64_t v585 = 0x2800000000;
  uint64_t v586 = 0;
  uint64_t v587 = 0;
  uint64_t v588 = 0x2800000000;
  __n128 v9 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v572, 1);
  mlir::Pattern::Pattern((uint64_t)(v9 + 1), (uint64_t)"mps.bias_add_grad", 17, (__int16)v572, (uint64_t)Context, 0, 0);
  v9[12] = &v589;
  *__n128 v9 = &unk_1EC9C8B60;
  if (!v9[9])
  {
    v572 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerBiasAddGradNCHW]";
    unint64_t v573 = 104;
    unint64_t v10 = llvm::StringRef::find((uint64_t *)&v572, "DesiredTypeName = ", 0x12uLL, 0);
    if (v573 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v573;
    }
    char v12 = &v572[v11];
    unint64_t v13 = v573 - v11;
    if (v573 - v11 >= 0x12) {
      uint64_t v14 = 18;
    }
    else {
      uint64_t v14 = v573 - v11;
    }
    uint64_t v15 = &v12[v14];
    unint64_t v16 = v13 - v14;
    if (v16 >= v16 - 1) {
      --v16;
    }
    unsigned char v9[8] = v15;
    v9[9] = v16;
  }
  unint64_t v17 = *((unsigned int *)v9 + 22);
  if (v17 > *((_DWORD *)v9 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v9 + 10), v9 + 12, v17, 16);
    LODWORD(v17) = *((_DWORD *)v9 + 22);
  }
  *((_DWORD *)v9 + 22) = v17;
  uint64_t v18 = (char *)__p[1];
  if (__p[1] >= v576[0])
  {
    uint64_t v20 = (char *)__p[0];
    int64_t v21 = (char *)__p[1] - (char *)__p[0];
    int64_t v22 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v23 = v22 + 1;
    if ((unint64_t)(v22 + 1) >> 61) {
      goto LABEL_692;
    }
    int64_t v24 = (char *)v576[0] - (char *)__p[0];
    if (((char *)v576[0] - (char *)__p[0]) >> 2 > v23) {
      unint64_t v23 = v24 >> 2;
    }
    if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v25 = v23;
    }
    if (v25)
    {
      if (v25 >> 61) {
        goto LABEL_693;
      }
      uint64_t v26 = (char *)operator new(8 * v25);
    }
    else
    {
      uint64_t v26 = 0;
    }
    unint64_t v27 = &v26[8 * v22];
    unint64_t v28 = (mlir::Operation *)&v26[8 * v25];
    *(void *)unint64_t v27 = v9;
    unint64_t v19 = v27 + 8;
    if (v18 == v20)
    {
      __p[0] = &v26[8 * v22];
      __p[1] = v27 + 8;
      v576[0] = v28;
    }
    else
    {
      unint64_t v29 = v18 - v20 - 8;
      if (v29 < 0x78
        || &v18[-(v29 & 0xFFFFFFFFFFFFFFF8) - 8] < v27 && &v26[v21 - (v29 & 0xFFFFFFFFFFFFFFF8) - 8] < v18)
      {
        goto LABEL_696;
      }
      uint64_t v30 = (v29 >> 3) + 1;
      uint64_t v31 = 8 * (v30 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v32 = &v18[-v31];
      v27 -= v31;
      uint64_t v33 = &v26[8 * v22 - 16];
      unint64_t v34 = v18 - 16;
      uint64_t v35 = v30 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v37 = *((_OWORD *)v34 - 1);
        long long v36 = *(_OWORD *)v34;
        *((_OWORD *)v34 - 1) = 0uLL;
        *(_OWORD *)unint64_t v34 = 0uLL;
        *((_OWORD *)v33 - 1) = v37;
        *(_OWORD *)uint64_t v33 = v36;
        v33 -= 32;
        v34 -= 32;
        v35 -= 4;
      }
      while (v35);
      uint64_t v18 = v32;
      if (v30 != (v30 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_696:
        do
        {
          uint64_t v38 = *((void *)v18 - 1);
          v18 -= 8;
          *(void *)uint64_t v18 = 0;
          *((void *)v27 - 1) = v38;
          v27 -= 8;
        }
        while (v18 != v20);
      }
      uint64_t v18 = (char *)__p[0];
      uint64_t v39 = (char *)__p[1];
      __p[0] = v27;
      __p[1] = v19;
      v576[0] = v28;
      while (v39 != v18)
      {
        uint64_t v41 = *((void *)v39 - 1);
        v39 -= 8;
        uint64_t v40 = v41;
        *(void *)uint64_t v39 = 0;
        if (v41) {
          (*(void (**)(uint64_t))(*(void *)v40 + 8))(v40);
        }
      }
    }
    if (v18) {
      operator delete(v18);
    }
  }
  else
  {
    *(void *)__p[1] = v9;
    unint64_t v19 = v18 + 8;
  }
  __p[1] = v19;
  uint64_t v42 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v572, 1);
  mlir::Pattern::Pattern((uint64_t)(v42 + 1), (uint64_t)"mps.bias_add_grad", 17, (__int16)v572, (uint64_t)Context, 0, 0);
  v42[12] = &v589;
  void *v42 = &unk_1EC9D1160;
  if (!v42[9])
  {
    v572 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerBiasAddGradNHWC]";
    unint64_t v573 = 104;
    unint64_t v43 = llvm::StringRef::find((uint64_t *)&v572, "DesiredTypeName = ", 0x12uLL, 0);
    if (v573 >= v43) {
      unint64_t v44 = v43;
    }
    else {
      unint64_t v44 = v573;
    }
    char v45 = &v572[v44];
    unint64_t v46 = v573 - v44;
    if (v573 - v44 >= 0x12) {
      uint64_t v47 = 18;
    }
    else {
      uint64_t v47 = v573 - v44;
    }
    uint64_t v48 = &v45[v47];
    unint64_t v49 = v46 - v47;
    if (v49 >= v49 - 1) {
      --v49;
    }
    v42[8] = v48;
    v42[9] = v49;
  }
  unint64_t v50 = *((unsigned int *)v42 + 22);
  if (v50 > *((_DWORD *)v42 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v42 + 10), v42 + 12, v50, 16);
    LODWORD(v50) = *((_DWORD *)v42 + 22);
  }
  *((_DWORD *)v42 + 22) = v50;
  unint64_t v51 = (char *)__p[1];
  if (__p[1] >= v576[0])
  {
    char v53 = (char *)__p[0];
    int64_t v54 = (char *)__p[1] - (char *)__p[0];
    int64_t v55 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v56 = v55 + 1;
    if ((unint64_t)(v55 + 1) >> 61) {
      goto LABEL_692;
    }
    int64_t v57 = (char *)v576[0] - (char *)__p[0];
    if (((char *)v576[0] - (char *)__p[0]) >> 2 > v56) {
      unint64_t v56 = v57 >> 2;
    }
    if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v58 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v58 = v56;
    }
    if (v58)
    {
      if (v58 >> 61) {
        goto LABEL_693;
      }
      unint64_t v59 = (char *)operator new(8 * v58);
    }
    else
    {
      unint64_t v59 = 0;
    }
    uint64_t v60 = &v59[8 * v55];
    char v61 = (mlir::Operation *)&v59[8 * v58];
    *(void *)uint64_t v60 = v42;
    uint64_t v52 = v60 + 8;
    if (v51 == v53)
    {
      __p[0] = &v59[8 * v55];
      __p[1] = v60 + 8;
      v576[0] = v61;
    }
    else
    {
      unint64_t v62 = v51 - v53 - 8;
      if (v62 < 0x78
        || &v51[-(v62 & 0xFFFFFFFFFFFFFFF8) - 8] < v60 && &v59[v54 - (v62 & 0xFFFFFFFFFFFFFFF8) - 8] < v51)
      {
        goto LABEL_697;
      }
      uint64_t v63 = (v62 >> 3) + 1;
      uint64_t v64 = 8 * (v63 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v65 = &v51[-v64];
      v60 -= v64;
      uint64_t v66 = &v59[8 * v55 - 16];
      unint64_t v67 = v51 - 16;
      uint64_t v68 = v63 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v70 = *((_OWORD *)v67 - 1);
        long long v69 = *(_OWORD *)v67;
        *((_OWORD *)v67 - 1) = 0uLL;
        *(_OWORD *)unint64_t v67 = 0uLL;
        *((_OWORD *)v66 - 1) = v70;
        *(_OWORD *)uint64_t v66 = v69;
        v66 -= 32;
        v67 -= 32;
        v68 -= 4;
      }
      while (v68);
      unint64_t v51 = v65;
      if (v63 != (v63 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_697:
        do
        {
          uint64_t v71 = *((void *)v51 - 1);
          v51 -= 8;
          *(void *)unint64_t v51 = 0;
          *((void *)v60 - 1) = v71;
          v60 -= 8;
        }
        while (v51 != v53);
      }
      unint64_t v51 = (char *)__p[0];
      uint64_t v72 = (char *)__p[1];
      __p[0] = v60;
      __p[1] = v52;
      v576[0] = v61;
      while (v72 != v51)
      {
        uint64_t v74 = *((void *)v72 - 1);
        v72 -= 8;
        uint64_t v73 = v74;
        *(void *)uint64_t v72 = 0;
        if (v74) {
          (*(void (**)(uint64_t))(*(void *)v73 + 8))(v73);
        }
      }
    }
    if (v51) {
      operator delete(v51);
    }
  }
  else
  {
    *(void *)__p[1] = v42;
    uint64_t v52 = v51 + 8;
  }
  __p[1] = v52;
  unint64_t v75 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v572, 1);
  mlir::Pattern::Pattern((uint64_t)(v75 + 1), (uint64_t)"mps.bias_add", 12, (__int16)v572, (uint64_t)Context, 0, 0);
  v75[12] = &v589;
  *unint64_t v75 = &unk_1EC9D11C8;
  if (!v75[9])
  {
    v572 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerBiasAddNCHW]";
    unint64_t v573 = 100;
    unint64_t v76 = llvm::StringRef::find((uint64_t *)&v572, "DesiredTypeName = ", 0x12uLL, 0);
    if (v573 >= v76) {
      unint64_t v77 = v76;
    }
    else {
      unint64_t v77 = v573;
    }
    char v78 = &v572[v77];
    unint64_t v79 = v573 - v77;
    if (v573 - v77 >= 0x12) {
      uint64_t v80 = 18;
    }
    else {
      uint64_t v80 = v573 - v77;
    }
    uint64_t v81 = &v78[v80];
    unint64_t v82 = v79 - v80;
    if (v82 >= v82 - 1) {
      --v82;
    }
    v75[8] = v81;
    v75[9] = v82;
  }
  unint64_t v83 = *((unsigned int *)v75 + 22);
  if (v83 > *((_DWORD *)v75 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v75 + 10), v75 + 12, v83, 16);
    LODWORD(v83) = *((_DWORD *)v75 + 22);
  }
  *((_DWORD *)v75 + 22) = v83;
  unint64_t v84 = (char *)__p[1];
  if (__p[1] >= v576[0])
  {
    char v86 = (char *)__p[0];
    int64_t v87 = (char *)__p[1] - (char *)__p[0];
    int64_t v88 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v89 = v88 + 1;
    if ((unint64_t)(v88 + 1) >> 61) {
      goto LABEL_692;
    }
    int64_t v90 = (char *)v576[0] - (char *)__p[0];
    if (((char *)v576[0] - (char *)__p[0]) >> 2 > v89) {
      unint64_t v89 = v90 >> 2;
    }
    if ((unint64_t)v90 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v91 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v91 = v89;
    }
    if (v91)
    {
      if (v91 >> 61) {
        goto LABEL_693;
      }
      unint64_t v92 = (char *)operator new(8 * v91);
    }
    else
    {
      unint64_t v92 = 0;
    }
    uint64_t v93 = &v92[8 * v88];
    unint64_t v94 = (mlir::Operation *)&v92[8 * v91];
    *(void *)uint64_t v93 = v75;
    uint64_t v85 = v93 + 8;
    if (v84 == v86)
    {
      __p[0] = &v92[8 * v88];
      __p[1] = v93 + 8;
      v576[0] = v94;
    }
    else
    {
      unint64_t v95 = v84 - v86 - 8;
      if (v95 < 0x78
        || &v84[-(v95 & 0xFFFFFFFFFFFFFFF8) - 8] < v93 && &v92[v87 - (v95 & 0xFFFFFFFFFFFFFFF8) - 8] < v84)
      {
        goto LABEL_698;
      }
      uint64_t v96 = (v95 >> 3) + 1;
      uint64_t v97 = 8 * (v96 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v98 = &v84[-v97];
      v93 -= v97;
      uint64_t v99 = &v92[8 * v88 - 16];
      uint64_t v100 = v84 - 16;
      uint64_t v101 = v96 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v103 = *((_OWORD *)v100 - 1);
        long long v102 = *(_OWORD *)v100;
        *((_OWORD *)v100 - 1) = 0uLL;
        *(_OWORD *)uint64_t v100 = 0uLL;
        *((_OWORD *)v99 - 1) = v103;
        *(_OWORD *)uint64_t v99 = v102;
        v99 -= 32;
        v100 -= 32;
        v101 -= 4;
      }
      while (v101);
      unint64_t v84 = v98;
      if (v96 != (v96 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_698:
        do
        {
          uint64_t v104 = *((void *)v84 - 1);
          v84 -= 8;
          *(void *)unint64_t v84 = 0;
          *((void *)v93 - 1) = v104;
          v93 -= 8;
        }
        while (v84 != v86);
      }
      unint64_t v84 = (char *)__p[0];
      char v105 = (char *)__p[1];
      __p[0] = v93;
      __p[1] = v85;
      v576[0] = v94;
      while (v105 != v84)
      {
        uint64_t v107 = *((void *)v105 - 1);
        v105 -= 8;
        uint64_t v106 = v107;
        *(void *)char v105 = 0;
        if (v107) {
          (*(void (**)(uint64_t))(*(void *)v106 + 8))(v106);
        }
      }
    }
    if (v84) {
      operator delete(v84);
    }
  }
  else
  {
    *(void *)__p[1] = v75;
    uint64_t v85 = v84 + 8;
  }
  __p[1] = v85;
  uint64_t v108 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v572, 1);
  mlir::Pattern::Pattern((uint64_t)(v108 + 1), (uint64_t)"mps.reduction_mean", 18, (__int16)v572, (uint64_t)Context, 0, 0);
  v108[12] = &v589;
  *uint64_t v108 = &unk_1EC9C8768;
  if (!v108[9])
  {
    v572 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerReductionMean]";
    unint64_t v573 = 102;
    unint64_t v109 = llvm::StringRef::find((uint64_t *)&v572, "DesiredTypeName = ", 0x12uLL, 0);
    if (v573 >= v109) {
      unint64_t v110 = v109;
    }
    else {
      unint64_t v110 = v573;
    }
    char v111 = &v572[v110];
    unint64_t v112 = v573 - v110;
    if (v573 - v110 >= 0x12) {
      uint64_t v113 = 18;
    }
    else {
      uint64_t v113 = v573 - v110;
    }
    uint64_t v114 = &v111[v113];
    unint64_t v115 = v112 - v113;
    if (v115 >= v115 - 1) {
      --v115;
    }
    v108[8] = v114;
    v108[9] = v115;
  }
  unint64_t v116 = *((unsigned int *)v108 + 22);
  if (v116 > *((_DWORD *)v108 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v108 + 10), v108 + 12, v116, 16);
    LODWORD(v116) = *((_DWORD *)v108 + 22);
  }
  *((_DWORD *)v108 + 22) = v116;
  unint64_t v117 = (char *)__p[1];
  if (__p[1] >= v576[0])
  {
    char v119 = (char *)__p[0];
    int64_t v120 = (char *)__p[1] - (char *)__p[0];
    int64_t v121 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v122 = v121 + 1;
    if ((unint64_t)(v121 + 1) >> 61) {
      goto LABEL_692;
    }
    int64_t v123 = (char *)v576[0] - (char *)__p[0];
    if (((char *)v576[0] - (char *)__p[0]) >> 2 > v122) {
      unint64_t v122 = v123 >> 2;
    }
    if ((unint64_t)v123 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v124 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v124 = v122;
    }
    if (v124)
    {
      if (v124 >> 61) {
        goto LABEL_693;
      }
      unint64_t v125 = (char *)operator new(8 * v124);
    }
    else
    {
      unint64_t v125 = 0;
    }
    uint64_t v126 = &v125[8 * v121];
    char v127 = (mlir::Operation *)&v125[8 * v124];
    *(void *)uint64_t v126 = v108;
    uint64_t v118 = v126 + 8;
    if (v117 == v119)
    {
      __p[0] = &v125[8 * v121];
      __p[1] = v126 + 8;
      v576[0] = v127;
    }
    else
    {
      unint64_t v128 = v117 - v119 - 8;
      if (v128 < 0x78
        || &v117[-(v128 & 0xFFFFFFFFFFFFFFF8) - 8] < v126 && &v125[v120 - (v128 & 0xFFFFFFFFFFFFFFF8) - 8] < v117)
      {
        goto LABEL_699;
      }
      uint64_t v129 = (v128 >> 3) + 1;
      uint64_t v130 = 8 * (v129 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v131 = &v117[-v130];
      v126 -= v130;
      uint64_t v132 = &v125[8 * v121 - 16];
      unint64_t v133 = v117 - 16;
      uint64_t v134 = v129 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v136 = *((_OWORD *)v133 - 1);
        long long v135 = *(_OWORD *)v133;
        *((_OWORD *)v133 - 1) = 0uLL;
        *(_OWORD *)unint64_t v133 = 0uLL;
        *((_OWORD *)v132 - 1) = v136;
        *(_OWORD *)uint64_t v132 = v135;
        v132 -= 32;
        v133 -= 32;
        v134 -= 4;
      }
      while (v134);
      unint64_t v117 = v131;
      if (v129 != (v129 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_699:
        do
        {
          uint64_t v137 = *((void *)v117 - 1);
          v117 -= 8;
          *(void *)unint64_t v117 = 0;
          *((void *)v126 - 1) = v137;
          v126 -= 8;
        }
        while (v117 != v119);
      }
      unint64_t v117 = (char *)__p[0];
      uint64_t v138 = (char *)__p[1];
      __p[0] = v126;
      __p[1] = v118;
      v576[0] = v127;
      while (v138 != v117)
      {
        uint64_t v140 = *((void *)v138 - 1);
        v138 -= 8;
        uint64_t v139 = v140;
        *(void *)uint64_t v138 = 0;
        if (v140) {
          (*(void (**)(uint64_t))(*(void *)v139 + 8))(v139);
        }
      }
    }
    if (v117) {
      operator delete(v117);
    }
  }
  else
  {
    *(void *)__p[1] = v108;
    uint64_t v118 = v117 + 8;
  }
  __p[1] = v118;
  unint64_t v141 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v572, 1);
  mlir::Pattern::Pattern((uint64_t)(v141 + 1), (uint64_t)"mps.reduction_variance", 22, (__int16)v572, (uint64_t)Context, 0, 0);
  v141[12] = &v589;
  *unint64_t v141 = &unk_1EC9C91E0;
  if (!v141[9])
  {
    v572 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerReductionVariance]";
    unint64_t v573 = 106;
    unint64_t v142 = llvm::StringRef::find((uint64_t *)&v572, "DesiredTypeName = ", 0x12uLL, 0);
    if (v573 >= v142) {
      unint64_t v143 = v142;
    }
    else {
      unint64_t v143 = v573;
    }
    uint64_t v144 = &v572[v143];
    unint64_t v145 = v573 - v143;
    if (v573 - v143 >= 0x12) {
      uint64_t v146 = 18;
    }
    else {
      uint64_t v146 = v573 - v143;
    }
    uint64_t v147 = &v144[v146];
    unint64_t v148 = v145 - v146;
    if (v148 >= v148 - 1) {
      --v148;
    }
    v141[8] = v147;
    v141[9] = v148;
  }
  unint64_t v149 = *((unsigned int *)v141 + 22);
  if (v149 > *((_DWORD *)v141 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v141 + 10), v141 + 12, v149, 16);
    LODWORD(v149) = *((_DWORD *)v141 + 22);
  }
  *((_DWORD *)v141 + 22) = v149;
  uint64_t v150 = (char *)__p[1];
  if (__p[1] >= v576[0])
  {
    __int16 v152 = (char *)__p[0];
    int64_t v153 = (char *)__p[1] - (char *)__p[0];
    int64_t v154 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v155 = v154 + 1;
    if ((unint64_t)(v154 + 1) >> 61) {
      goto LABEL_692;
    }
    int64_t v156 = (char *)v576[0] - (char *)__p[0];
    if (((char *)v576[0] - (char *)__p[0]) >> 2 > v155) {
      unint64_t v155 = v156 >> 2;
    }
    if ((unint64_t)v156 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v157 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v157 = v155;
    }
    if (v157)
    {
      if (v157 >> 61) {
        goto LABEL_693;
      }
      char v158 = (char *)operator new(8 * v157);
    }
    else
    {
      char v158 = 0;
    }
    v159 = &v158[8 * v154];
    unint64_t v160 = (mlir::Operation *)&v158[8 * v157];
    *(void *)v159 = v141;
    uint64_t v151 = v159 + 8;
    if (v150 == v152)
    {
      __p[0] = &v158[8 * v154];
      __p[1] = v159 + 8;
      v576[0] = v160;
    }
    else
    {
      unint64_t v161 = v150 - v152 - 8;
      if (v161 < 0x78
        || &v150[-(v161 & 0xFFFFFFFFFFFFFFF8) - 8] < v159 && &v158[v153 - (v161 & 0xFFFFFFFFFFFFFFF8) - 8] < v150)
      {
        goto LABEL_700;
      }
      uint64_t v162 = (v161 >> 3) + 1;
      uint64_t v163 = 8 * (v162 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v164 = &v150[-v163];
      v159 -= v163;
      v165 = &v158[8 * v154 - 16];
      char v166 = v150 - 16;
      uint64_t v167 = v162 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v169 = *((_OWORD *)v166 - 1);
        long long v168 = *(_OWORD *)v166;
        *((_OWORD *)v166 - 1) = 0uLL;
        *(_OWORD *)char v166 = 0uLL;
        *((_OWORD *)v165 - 1) = v169;
        *(_OWORD *)v165 = v168;
        v165 -= 32;
        v166 -= 32;
        v167 -= 4;
      }
      while (v167);
      uint64_t v150 = v164;
      if (v162 != (v162 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_700:
        do
        {
          uint64_t v170 = *((void *)v150 - 1);
          v150 -= 8;
          *(void *)uint64_t v150 = 0;
          *((void *)v159 - 1) = v170;
          v159 -= 8;
        }
        while (v150 != v152);
      }
      uint64_t v150 = (char *)__p[0];
      int32x4_t v171 = (char *)__p[1];
      __p[0] = v159;
      __p[1] = v151;
      v576[0] = v160;
      while (v171 != v150)
      {
        uint64_t v173 = *((void *)v171 - 1);
        v171 -= 8;
        uint64_t v172 = v173;
        *(void *)int32x4_t v171 = 0;
        if (v173) {
          (*(void (**)(uint64_t))(*(void *)v172 + 8))(v172);
        }
      }
    }
    if (v150) {
      operator delete(v150);
    }
  }
  else
  {
    *(void *)__p[1] = v141;
    uint64_t v151 = v150 + 8;
  }
  __p[1] = v151;
  char v174 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v572, 1);
  mlir::Pattern::Pattern((uint64_t)(v174 + 1), (uint64_t)"mps.softplus", 12, (__int16)v572, (uint64_t)Context, 0, 0);
  v174[12] = &v589;
  *char v174 = &unk_1EC9C7B30;
  if (!v174[9])
  {
    v572 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerSoftplus]";
    unint64_t v573 = 97;
    unint64_t v175 = llvm::StringRef::find((uint64_t *)&v572, "DesiredTypeName = ", 0x12uLL, 0);
    if (v573 >= v175) {
      unint64_t v176 = v175;
    }
    else {
      unint64_t v176 = v573;
    }
    uint64_t v177 = &v572[v176];
    unint64_t v178 = v573 - v176;
    if (v573 - v176 >= 0x12) {
      uint64_t v179 = 18;
    }
    else {
      uint64_t v179 = v573 - v176;
    }
    unint64_t v180 = &v177[v179];
    unint64_t v181 = v178 - v179;
    if (v181 >= v181 - 1) {
      --v181;
    }
    v174[8] = v180;
    v174[9] = v181;
  }
  unint64_t v182 = *((unsigned int *)v174 + 22);
  if (v182 > *((_DWORD *)v174 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v174 + 10), v174 + 12, v182, 16);
    LODWORD(v182) = *((_DWORD *)v174 + 22);
  }
  *((_DWORD *)v174 + 22) = v182;
  v183 = (char *)__p[1];
  if (__p[1] >= v576[0])
  {
    uint64_t v185 = (char *)__p[0];
    int64_t v186 = (char *)__p[1] - (char *)__p[0];
    int64_t v187 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v188 = v187 + 1;
    if ((unint64_t)(v187 + 1) >> 61) {
      goto LABEL_692;
    }
    int64_t v189 = (char *)v576[0] - (char *)__p[0];
    if (((char *)v576[0] - (char *)__p[0]) >> 2 > v188) {
      unint64_t v188 = v189 >> 2;
    }
    if ((unint64_t)v189 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v190 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v190 = v188;
    }
    if (v190)
    {
      if (v190 >> 61) {
        goto LABEL_693;
      }
      v191 = (char *)operator new(8 * v190);
    }
    else
    {
      v191 = 0;
    }
    v192 = &v191[8 * v187];
    uint64_t v193 = (mlir::Operation *)&v191[8 * v190];
    *(void *)v192 = v174;
    v184 = v192 + 8;
    if (v183 == v185)
    {
      __p[0] = &v191[8 * v187];
      __p[1] = v192 + 8;
      v576[0] = v193;
    }
    else
    {
      unint64_t v194 = v183 - v185 - 8;
      if (v194 < 0x78
        || &v183[-(v194 & 0xFFFFFFFFFFFFFFF8) - 8] < v192 && &v191[v186 - (v194 & 0xFFFFFFFFFFFFFFF8) - 8] < v183)
      {
        goto LABEL_701;
      }
      uint64_t v195 = (v194 >> 3) + 1;
      uint64_t v196 = 8 * (v195 & 0x3FFFFFFFFFFFFFFCLL);
      int v197 = &v183[-v196];
      v192 -= v196;
      char v198 = &v191[8 * v187 - 16];
      unsigned int v199 = v183 - 16;
      uint64_t v200 = v195 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v202 = *((_OWORD *)v199 - 1);
        long long v201 = *(_OWORD *)v199;
        *((_OWORD *)v199 - 1) = 0uLL;
        *(_OWORD *)unsigned int v199 = 0uLL;
        *((_OWORD *)v198 - 1) = v202;
        *(_OWORD *)char v198 = v201;
        v198 -= 32;
        v199 -= 32;
        v200 -= 4;
      }
      while (v200);
      v183 = v197;
      if (v195 != (v195 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_701:
        do
        {
          uint64_t v203 = *((void *)v183 - 1);
          v183 -= 8;
          *(void *)v183 = 0;
          *((void *)v192 - 1) = v203;
          v192 -= 8;
        }
        while (v183 != v185);
      }
      v183 = (char *)__p[0];
      unint64_t v204 = (char *)__p[1];
      __p[0] = v192;
      __p[1] = v184;
      v576[0] = v193;
      while (v204 != v183)
      {
        uint64_t v206 = *((void *)v204 - 1);
        v204 -= 8;
        uint64_t v205 = v206;
        *(void *)unint64_t v204 = 0;
        if (v206) {
          (*(void (**)(uint64_t))(*(void *)v205 + 8))(v205);
        }
      }
    }
    if (v183) {
      operator delete(v183);
    }
  }
  else
  {
    *(void *)__p[1] = v174;
    v184 = v183 + 8;
  }
  __p[1] = v184;
  v207 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v572, 1);
  mlir::Pattern::Pattern((uint64_t)(v207 + 1), (uint64_t)"mps.softplus_parametric", 23, (__int16)v572, (uint64_t)Context, 0, 0);
  v207[12] = &v589;
  void *v207 = &unk_1EC9D1230;
  if (!v207[9])
  {
    v572 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerSoftplusParametric]";
    unint64_t v573 = 107;
    unint64_t v208 = llvm::StringRef::find((uint64_t *)&v572, "DesiredTypeName = ", 0x12uLL, 0);
    if (v573 >= v208) {
      unint64_t v209 = v208;
    }
    else {
      unint64_t v209 = v573;
    }
    uint64_t v210 = &v572[v209];
    unint64_t v211 = v573 - v209;
    if (v573 - v209 >= 0x12) {
      uint64_t v212 = 18;
    }
    else {
      uint64_t v212 = v573 - v209;
    }
    uint64_t v213 = &v210[v212];
    unint64_t v214 = v211 - v212;
    if (v214 >= v214 - 1) {
      --v214;
    }
    v207[8] = v213;
    v207[9] = v214;
  }
  unint64_t v215 = *((unsigned int *)v207 + 22);
  if (v215 > *((_DWORD *)v207 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v207 + 10), v207 + 12, v215, 16);
    LODWORD(v215) = *((_DWORD *)v207 + 22);
  }
  *((_DWORD *)v207 + 22) = v215;
  uint64_t v216 = (char *)__p[1];
  if (__p[1] >= v576[0])
  {
    uint64_t v218 = (char *)__p[0];
    int64_t v219 = (char *)__p[1] - (char *)__p[0];
    int64_t v220 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v221 = v220 + 1;
    if ((unint64_t)(v220 + 1) >> 61) {
      goto LABEL_692;
    }
    int64_t v222 = (char *)v576[0] - (char *)__p[0];
    if (((char *)v576[0] - (char *)__p[0]) >> 2 > v221) {
      unint64_t v221 = v222 >> 2;
    }
    if ((unint64_t)v222 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v223 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v223 = v221;
    }
    if (v223)
    {
      if (v223 >> 61) {
        goto LABEL_693;
      }
      v224 = (char *)operator new(8 * v223);
    }
    else
    {
      v224 = 0;
    }
    v225 = &v224[8 * v220];
    uint64_t v226 = (mlir::Operation *)&v224[8 * v223];
    *(void *)v225 = v207;
    uint64_t v217 = v225 + 8;
    if (v216 == v218)
    {
      __p[0] = &v224[8 * v220];
      __p[1] = v225 + 8;
      v576[0] = v226;
    }
    else
    {
      unint64_t v227 = v216 - v218 - 8;
      if (v227 < 0x78
        || &v216[-(v227 & 0xFFFFFFFFFFFFFFF8) - 8] < v225 && &v224[v219 - (v227 & 0xFFFFFFFFFFFFFFF8) - 8] < v216)
      {
        goto LABEL_702;
      }
      uint64_t v228 = (v227 >> 3) + 1;
      uint64_t v229 = 8 * (v228 & 0x3FFFFFFFFFFFFFFCLL);
      v230 = &v216[-v229];
      v225 -= v229;
      char v231 = &v224[8 * v220 - 16];
      v232 = v216 - 16;
      uint64_t v233 = v228 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v235 = *((_OWORD *)v232 - 1);
        long long v234 = *(_OWORD *)v232;
        *((_OWORD *)v232 - 1) = 0uLL;
        *(_OWORD *)v232 = 0uLL;
        *((_OWORD *)v231 - 1) = v235;
        *(_OWORD *)char v231 = v234;
        v231 -= 32;
        v232 -= 32;
        v233 -= 4;
      }
      while (v233);
      uint64_t v216 = v230;
      if (v228 != (v228 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_702:
        do
        {
          uint64_t v236 = *((void *)v216 - 1);
          v216 -= 8;
          *(void *)uint64_t v216 = 0;
          *((void *)v225 - 1) = v236;
          v225 -= 8;
        }
        while (v216 != v218);
      }
      uint64_t v216 = (char *)__p[0];
      unint64_t v237 = (char *)__p[1];
      __p[0] = v225;
      __p[1] = v217;
      v576[0] = v226;
      while (v237 != v216)
      {
        uint64_t v239 = *((void *)v237 - 1);
        v237 -= 8;
        uint64_t v238 = v239;
        *(void *)unint64_t v237 = 0;
        if (v239) {
          (*(void (**)(uint64_t))(*(void *)v238 + 8))(v238);
        }
      }
    }
    if (v216) {
      operator delete(v216);
    }
  }
  else
  {
    *(void *)__p[1] = v207;
    uint64_t v217 = v216 + 8;
  }
  __p[1] = v217;
  v240 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v572, 1);
  mlir::Pattern::Pattern((uint64_t)(v240 + 1), (uint64_t)"mps.non_zero", 12, (__int16)v572, (uint64_t)Context, 0, 0);
  v240[12] = &v589;
  void *v240 = &unk_1EC9C7958;
  if (!v240[9])
  {
    v572 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerNonZero]";
    unint64_t v573 = 96;
    unint64_t v241 = llvm::StringRef::find((uint64_t *)&v572, "DesiredTypeName = ", 0x12uLL, 0);
    if (v573 >= v241) {
      unint64_t v242 = v241;
    }
    else {
      unint64_t v242 = v573;
    }
    uint64_t v243 = &v572[v242];
    unint64_t v244 = v573 - v242;
    if (v573 - v242 >= 0x12) {
      uint64_t v245 = 18;
    }
    else {
      uint64_t v245 = v573 - v242;
    }
    v246 = &v243[v245];
    unint64_t v247 = v244 - v245;
    if (v247 >= v247 - 1) {
      --v247;
    }
    v240[8] = v246;
    v240[9] = v247;
  }
  unint64_t v248 = *((unsigned int *)v240 + 22);
  if (v248 > *((_DWORD *)v240 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v240 + 10), v240 + 12, v248, 16);
    LODWORD(v248) = *((_DWORD *)v240 + 22);
  }
  *((_DWORD *)v240 + 22) = v248;
  v249 = (char *)__p[1];
  if (__p[1] >= v576[0])
  {
    uint64_t v251 = (char *)__p[0];
    int64_t v252 = (char *)__p[1] - (char *)__p[0];
    int64_t v253 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v254 = v253 + 1;
    if ((unint64_t)(v253 + 1) >> 61) {
      goto LABEL_692;
    }
    int64_t v255 = (char *)v576[0] - (char *)__p[0];
    if (((char *)v576[0] - (char *)__p[0]) >> 2 > v254) {
      unint64_t v254 = v255 >> 2;
    }
    if ((unint64_t)v255 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v256 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v256 = v254;
    }
    if (v256)
    {
      if (v256 >> 61) {
        goto LABEL_693;
      }
      v257 = (char *)operator new(8 * v256);
    }
    else
    {
      v257 = 0;
    }
    uint64_t v258 = &v257[8 * v253];
    uint64_t v259 = (mlir::Operation *)&v257[8 * v256];
    *(void *)uint64_t v258 = v240;
    uint64_t v250 = v258 + 8;
    if (v249 == v251)
    {
      __p[0] = &v257[8 * v253];
      __p[1] = v258 + 8;
      v576[0] = v259;
    }
    else
    {
      unint64_t v260 = v249 - v251 - 8;
      if (v260 < 0x78
        || &v249[-(v260 & 0xFFFFFFFFFFFFFFF8) - 8] < v258 && &v257[v252 - (v260 & 0xFFFFFFFFFFFFFFF8) - 8] < v249)
      {
        goto LABEL_703;
      }
      uint64_t v261 = (v260 >> 3) + 1;
      uint64_t v262 = 8 * (v261 & 0x3FFFFFFFFFFFFFFCLL);
      v263 = &v249[-v262];
      v258 -= v262;
      char v264 = &v257[8 * v253 - 16];
      v265 = v249 - 16;
      uint64_t v266 = v261 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v268 = *((_OWORD *)v265 - 1);
        long long v267 = *(_OWORD *)v265;
        *((_OWORD *)v265 - 1) = 0uLL;
        *(_OWORD *)v265 = 0uLL;
        *((_OWORD *)v264 - 1) = v268;
        *(_OWORD *)char v264 = v267;
        v264 -= 32;
        v265 -= 32;
        v266 -= 4;
      }
      while (v266);
      v249 = v263;
      if (v261 != (v261 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_703:
        do
        {
          uint64_t v269 = *((void *)v249 - 1);
          v249 -= 8;
          *(void *)v249 = 0;
          *((void *)v258 - 1) = v269;
          v258 -= 8;
        }
        while (v249 != v251);
      }
      v249 = (char *)__p[0];
      unint64_t v270 = (char *)__p[1];
      __p[0] = v258;
      __p[1] = v250;
      v576[0] = v259;
      while (v270 != v249)
      {
        uint64_t v272 = *((void *)v270 - 1);
        v270 -= 8;
        uint64_t v271 = v272;
        *(void *)unint64_t v270 = 0;
        if (v272) {
          (*(void (**)(uint64_t))(*(void *)v271 + 8))(v271);
        }
      }
    }
    if (v249) {
      operator delete(v249);
    }
  }
  else
  {
    *(void *)__p[1] = v240;
    uint64_t v250 = v249 + 8;
  }
  __p[1] = v250;
  v273 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v572, 1);
  mlir::Pattern::Pattern((uint64_t)(v273 + 1), (uint64_t)"mps.sigmoid", 11, (__int16)v572, (uint64_t)Context, 0, 0);
  v273[12] = &v589;
  void *v273 = &unk_1EC9C79C0;
  if (!v273[9])
  {
    v572 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerSigmoid]";
    unint64_t v573 = 96;
    unint64_t v274 = llvm::StringRef::find((uint64_t *)&v572, "DesiredTypeName = ", 0x12uLL, 0);
    if (v573 >= v274) {
      unint64_t v275 = v274;
    }
    else {
      unint64_t v275 = v573;
    }
    uint64_t v276 = &v572[v275];
    unint64_t v277 = v573 - v275;
    if (v573 - v275 >= 0x12) {
      uint64_t v278 = 18;
    }
    else {
      uint64_t v278 = v573 - v275;
    }
    v279 = &v276[v278];
    unint64_t v280 = v277 - v278;
    if (v280 >= v280 - 1) {
      --v280;
    }
    v273[8] = v279;
    v273[9] = v280;
  }
  unint64_t v281 = *((unsigned int *)v273 + 22);
  if (v281 > *((_DWORD *)v273 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v273 + 10), v273 + 12, v281, 16);
    LODWORD(v281) = *((_DWORD *)v273 + 22);
  }
  *((_DWORD *)v273 + 22) = v281;
  v282 = (char *)__p[1];
  if (__p[1] >= v576[0])
  {
    uint64_t v284 = (char *)__p[0];
    int64_t v285 = (char *)__p[1] - (char *)__p[0];
    int64_t v286 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v287 = v286 + 1;
    if ((unint64_t)(v286 + 1) >> 61) {
      goto LABEL_692;
    }
    int64_t v288 = (char *)v576[0] - (char *)__p[0];
    if (((char *)v576[0] - (char *)__p[0]) >> 2 > v287) {
      unint64_t v287 = v288 >> 2;
    }
    if ((unint64_t)v288 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v289 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v289 = v287;
    }
    if (v289)
    {
      if (v289 >> 61) {
        goto LABEL_693;
      }
      v290 = (char *)operator new(8 * v289);
    }
    else
    {
      v290 = 0;
    }
    v291 = &v290[8 * v286];
    uint64_t v292 = (mlir::Operation *)&v290[8 * v289];
    *(void *)v291 = v273;
    v283 = v291 + 8;
    if (v282 == v284)
    {
      __p[0] = &v290[8 * v286];
      __p[1] = v291 + 8;
      v576[0] = v292;
    }
    else
    {
      unint64_t v293 = v282 - v284 - 8;
      if (v293 < 0x78
        || &v282[-(v293 & 0xFFFFFFFFFFFFFFF8) - 8] < v291 && &v290[v285 - (v293 & 0xFFFFFFFFFFFFFFF8) - 8] < v282)
      {
        goto LABEL_704;
      }
      uint64_t v294 = (v293 >> 3) + 1;
      uint64_t v295 = 8 * (v294 & 0x3FFFFFFFFFFFFFFCLL);
      v296 = &v282[-v295];
      v291 -= v295;
      char v297 = &v290[8 * v286 - 16];
      v298 = v282 - 16;
      uint64_t v299 = v294 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v301 = *((_OWORD *)v298 - 1);
        long long v300 = *(_OWORD *)v298;
        *((_OWORD *)v298 - 1) = 0uLL;
        *(_OWORD *)v298 = 0uLL;
        *((_OWORD *)v297 - 1) = v301;
        *(_OWORD *)char v297 = v300;
        v297 -= 32;
        v298 -= 32;
        v299 -= 4;
      }
      while (v299);
      v282 = v296;
      if (v294 != (v294 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_704:
        do
        {
          uint64_t v302 = *((void *)v282 - 1);
          v282 -= 8;
          *(void *)v282 = 0;
          *((void *)v291 - 1) = v302;
          v291 -= 8;
        }
        while (v282 != v284);
      }
      v282 = (char *)__p[0];
      unint64_t v303 = (char *)__p[1];
      __p[0] = v291;
      __p[1] = v283;
      v576[0] = v292;
      while (v303 != v282)
      {
        uint64_t v305 = *((void *)v303 - 1);
        v303 -= 8;
        uint64_t v304 = v305;
        *(void *)unint64_t v303 = 0;
        if (v305) {
          (*(void (**)(uint64_t))(*(void *)v304 + 8))(v304);
        }
      }
    }
    if (v282) {
      operator delete(v282);
    }
  }
  else
  {
    *(void *)__p[1] = v273;
    v283 = v282 + 8;
  }
  __p[1] = v283;
  v306 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v572, 1);
  mlir::Pattern::Pattern((uint64_t)(v306 + 1), (uint64_t)"arith.select", 12, (__int16)v572, (uint64_t)Context, 0, 0);
  v306[12] = &v589;
  void *v306 = &unk_1EC97ED88;
  if (!v306[9])
  {
    v572 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerArithSelect]";
    unint64_t v573 = 100;
    unint64_t v307 = llvm::StringRef::find((uint64_t *)&v572, "DesiredTypeName = ", 0x12uLL, 0);
    if (v573 >= v307) {
      unint64_t v308 = v307;
    }
    else {
      unint64_t v308 = v573;
    }
    uint64_t v309 = &v572[v308];
    unint64_t v310 = v573 - v308;
    if (v573 - v308 >= 0x12) {
      uint64_t v311 = 18;
    }
    else {
      uint64_t v311 = v573 - v308;
    }
    v312 = &v309[v311];
    unint64_t v313 = v310 - v311;
    if (v313 >= v313 - 1) {
      --v313;
    }
    v306[8] = v312;
    v306[9] = v313;
  }
  unint64_t v314 = *((unsigned int *)v306 + 22);
  if (v314 > *((_DWORD *)v306 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v306 + 10), v306 + 12, v314, 16);
    LODWORD(v314) = *((_DWORD *)v306 + 22);
  }
  *((_DWORD *)v306 + 22) = v314;
  v315 = (char *)__p[1];
  if (__p[1] >= v576[0])
  {
    uint64_t v317 = (char *)__p[0];
    int64_t v318 = (char *)__p[1] - (char *)__p[0];
    int64_t v319 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v320 = v319 + 1;
    if ((unint64_t)(v319 + 1) >> 61) {
      goto LABEL_692;
    }
    int64_t v321 = (char *)v576[0] - (char *)__p[0];
    if (((char *)v576[0] - (char *)__p[0]) >> 2 > v320) {
      unint64_t v320 = v321 >> 2;
    }
    if ((unint64_t)v321 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v322 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v322 = v320;
    }
    if (v322)
    {
      if (v322 >> 61) {
        goto LABEL_693;
      }
      v323 = (char *)operator new(8 * v322);
    }
    else
    {
      v323 = 0;
    }
    v324 = &v323[8 * v319];
    uint64_t v325 = (mlir::Operation *)&v323[8 * v322];
    *(void *)v324 = v306;
    v316 = v324 + 8;
    if (v315 == v317)
    {
      __p[0] = &v323[8 * v319];
      __p[1] = v324 + 8;
      v576[0] = v325;
    }
    else
    {
      unint64_t v326 = v315 - v317 - 8;
      if (v326 < 0x78
        || &v315[-(v326 & 0xFFFFFFFFFFFFFFF8) - 8] < v324 && &v323[v318 - (v326 & 0xFFFFFFFFFFFFFFF8) - 8] < v315)
      {
        goto LABEL_705;
      }
      uint64_t v327 = (v326 >> 3) + 1;
      uint64_t v328 = 8 * (v327 & 0x3FFFFFFFFFFFFFFCLL);
      v329 = &v315[-v328];
      v324 -= v328;
      char v330 = &v323[8 * v319 - 16];
      v331 = v315 - 16;
      uint64_t v332 = v327 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v334 = *((_OWORD *)v331 - 1);
        long long v333 = *(_OWORD *)v331;
        *((_OWORD *)v331 - 1) = 0uLL;
        *(_OWORD *)v331 = 0uLL;
        *((_OWORD *)v330 - 1) = v334;
        *(_OWORD *)char v330 = v333;
        v330 -= 32;
        v331 -= 32;
        v332 -= 4;
      }
      while (v332);
      v315 = v329;
      if (v327 != (v327 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_705:
        do
        {
          uint64_t v335 = *((void *)v315 - 1);
          v315 -= 8;
          *(void *)v315 = 0;
          *((void *)v324 - 1) = v335;
          v324 -= 8;
        }
        while (v315 != v317);
      }
      v315 = (char *)__p[0];
      unint64_t v336 = (char *)__p[1];
      __p[0] = v324;
      __p[1] = v316;
      v576[0] = v325;
      while (v336 != v315)
      {
        uint64_t v338 = *((void *)v336 - 1);
        v336 -= 8;
        uint64_t v337 = v338;
        *(void *)unint64_t v336 = 0;
        if (v338) {
          (*(void (**)(uint64_t))(*(void *)v337 + 8))(v337);
        }
      }
    }
    if (v315) {
      operator delete(v315);
    }
  }
  else
  {
    *(void *)__p[1] = v306;
    v316 = v315 + 8;
  }
  __p[1] = v316;
  v339 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v572, 1);
  mlir::Pattern::Pattern((uint64_t)(v339 + 1), (uint64_t)"mpsx.deinterleave", 17, (__int16)v572, (uint64_t)Context, 0, 0);
  v339[12] = 0;
  void *v339 = &unk_1EC9C8010;
  if (!v339[9])
  {
    v572 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerInterleave<mlir::mpsx"
           "::DeinterleaveOp>]";
    unint64_t v573 = 127;
    unint64_t v340 = llvm::StringRef::find((uint64_t *)&v572, "DesiredTypeName = ", 0x12uLL, 0);
    if (v573 >= v340) {
      unint64_t v341 = v340;
    }
    else {
      unint64_t v341 = v573;
    }
    uint64_t v342 = &v572[v341];
    unint64_t v343 = v573 - v341;
    if (v573 - v341 >= 0x12) {
      uint64_t v344 = 18;
    }
    else {
      uint64_t v344 = v573 - v341;
    }
    v345 = &v342[v344];
    unint64_t v346 = v343 - v344;
    if (v346 >= v346 - 1) {
      --v346;
    }
    v339[8] = v345;
    v339[9] = v346;
  }
  unint64_t v347 = *((unsigned int *)v339 + 22);
  if (v347 > *((_DWORD *)v339 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v339 + 10), v339 + 12, v347, 16);
    LODWORD(v347) = *((_DWORD *)v339 + 22);
  }
  *((_DWORD *)v339 + 22) = v347;
  v348 = (char *)__p[1];
  if (__p[1] >= v576[0])
  {
    uint64_t v350 = (char *)__p[0];
    int64_t v351 = (char *)__p[1] - (char *)__p[0];
    int64_t v352 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v353 = v352 + 1;
    if ((unint64_t)(v352 + 1) >> 61) {
      goto LABEL_692;
    }
    int64_t v354 = (char *)v576[0] - (char *)__p[0];
    if (((char *)v576[0] - (char *)__p[0]) >> 2 > v353) {
      unint64_t v353 = v354 >> 2;
    }
    if ((unint64_t)v354 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v355 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v355 = v353;
    }
    if (v355)
    {
      if (v355 >> 61) {
        goto LABEL_693;
      }
      v356 = (char *)operator new(8 * v355);
    }
    else
    {
      v356 = 0;
    }
    uint64_t v357 = &v356[8 * v352];
    uint64_t v358 = (mlir::Operation *)&v356[8 * v355];
    *(void *)uint64_t v357 = v339;
    uint64_t v349 = v357 + 8;
    if (v348 == v350)
    {
      __p[0] = &v356[8 * v352];
      __p[1] = v357 + 8;
      v576[0] = v358;
    }
    else
    {
      unint64_t v359 = v348 - v350 - 8;
      if (v359 < 0x78
        || &v348[-(v359 & 0xFFFFFFFFFFFFFFF8) - 8] < v357 && &v356[v351 - (v359 & 0xFFFFFFFFFFFFFFF8) - 8] < v348)
      {
        goto LABEL_706;
      }
      uint64_t v360 = (v359 >> 3) + 1;
      uint64_t v361 = 8 * (v360 & 0x3FFFFFFFFFFFFFFCLL);
      char v362 = &v348[-v361];
      v357 -= v361;
      v363 = &v356[8 * v352 - 16];
      v364 = v348 - 16;
      uint64_t v365 = v360 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v367 = *((_OWORD *)v364 - 1);
        long long v366 = *(_OWORD *)v364;
        *((_OWORD *)v364 - 1) = 0uLL;
        *(_OWORD *)v364 = 0uLL;
        *((_OWORD *)v363 - 1) = v367;
        *(_OWORD *)v363 = v366;
        v363 -= 32;
        v364 -= 32;
        v365 -= 4;
      }
      while (v365);
      v348 = v362;
      if (v360 != (v360 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_706:
        do
        {
          uint64_t v368 = *((void *)v348 - 1);
          v348 -= 8;
          *(void *)v348 = 0;
          *((void *)v357 - 1) = v368;
          v357 -= 8;
        }
        while (v348 != v350);
      }
      v348 = (char *)__p[0];
      v369 = (char *)__p[1];
      __p[0] = v357;
      __p[1] = v349;
      v576[0] = v358;
      while (v369 != v348)
      {
        uint64_t v371 = *((void *)v369 - 1);
        v369 -= 8;
        uint64_t v370 = v371;
        *(void *)v369 = 0;
        if (v371) {
          (*(void (**)(uint64_t))(*(void *)v370 + 8))(v370);
        }
      }
    }
    if (v348) {
      operator delete(v348);
    }
  }
  else
  {
    *(void *)__p[1] = v339;
    uint64_t v349 = v348 + 8;
  }
  __p[1] = v349;
  v372 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v572, 1);
  mlir::Pattern::Pattern((uint64_t)(v372 + 1), (uint64_t)"mpsx.interleave", 15, (__int16)v572, (uint64_t)Context, 0, 0);
  v372[12] = 0;
  void *v372 = &unk_1EC9C7FA8;
  if (!v372[9])
  {
    v572 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerInterleave<mlir::mpsx"
           "::InterleaveOp>]";
    unint64_t v573 = 125;
    unint64_t v373 = llvm::StringRef::find((uint64_t *)&v572, "DesiredTypeName = ", 0x12uLL, 0);
    if (v573 >= v373) {
      unint64_t v374 = v373;
    }
    else {
      unint64_t v374 = v573;
    }
    v375 = &v572[v374];
    unint64_t v376 = v573 - v374;
    if (v573 - v374 >= 0x12) {
      uint64_t v377 = 18;
    }
    else {
      uint64_t v377 = v573 - v374;
    }
    v378 = &v375[v377];
    unint64_t v379 = v376 - v377;
    if (v379 >= v379 - 1) {
      --v379;
    }
    v372[8] = v378;
    v372[9] = v379;
  }
  unint64_t v380 = *((unsigned int *)v372 + 22);
  if (v380 > *((_DWORD *)v372 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v372 + 10), v372 + 12, v380, 16);
    LODWORD(v380) = *((_DWORD *)v372 + 22);
  }
  *((_DWORD *)v372 + 22) = v380;
  v381 = (char *)__p[1];
  if (__p[1] >= v576[0])
  {
    uint64_t v383 = (char *)__p[0];
    int64_t v384 = (char *)__p[1] - (char *)__p[0];
    int64_t v385 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v386 = v385 + 1;
    if ((unint64_t)(v385 + 1) >> 61) {
      goto LABEL_692;
    }
    int64_t v387 = (char *)v576[0] - (char *)__p[0];
    if (((char *)v576[0] - (char *)__p[0]) >> 2 > v386) {
      unint64_t v386 = v387 >> 2;
    }
    if ((unint64_t)v387 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v388 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v388 = v386;
    }
    if (v388)
    {
      if (v388 >> 61) {
        goto LABEL_693;
      }
      v389 = (char *)operator new(8 * v388);
    }
    else
    {
      v389 = 0;
    }
    uint64_t v390 = &v389[8 * v385];
    uint64_t v391 = (mlir::Operation *)&v389[8 * v388];
    *(void *)uint64_t v390 = v372;
    uint64_t v382 = v390 + 8;
    if (v381 == v383)
    {
      __p[0] = &v389[8 * v385];
      __p[1] = v390 + 8;
      v576[0] = v391;
    }
    else
    {
      unint64_t v392 = v381 - v383 - 8;
      if (v392 < 0x78
        || &v381[-(v392 & 0xFFFFFFFFFFFFFFF8) - 8] < v390 && &v389[v384 - (v392 & 0xFFFFFFFFFFFFFFF8) - 8] < v381)
      {
        goto LABEL_707;
      }
      uint64_t v393 = (v392 >> 3) + 1;
      uint64_t v394 = 8 * (v393 & 0x3FFFFFFFFFFFFFFCLL);
      char v395 = &v381[-v394];
      v390 -= v394;
      v396 = &v389[8 * v385 - 16];
      v397 = v381 - 16;
      uint64_t v398 = v393 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v400 = *((_OWORD *)v397 - 1);
        long long v399 = *(_OWORD *)v397;
        *((_OWORD *)v397 - 1) = 0uLL;
        *(_OWORD *)v397 = 0uLL;
        *((_OWORD *)v396 - 1) = v400;
        *(_OWORD *)v396 = v399;
        v396 -= 32;
        v397 -= 32;
        v398 -= 4;
      }
      while (v398);
      v381 = v395;
      if (v393 != (v393 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_707:
        do
        {
          uint64_t v401 = *((void *)v381 - 1);
          v381 -= 8;
          *(void *)v381 = 0;
          *((void *)v390 - 1) = v401;
          v390 -= 8;
        }
        while (v381 != v383);
      }
      v381 = (char *)__p[0];
      v402 = (char *)__p[1];
      __p[0] = v390;
      __p[1] = v382;
      v576[0] = v391;
      while (v402 != v381)
      {
        uint64_t v404 = *((void *)v402 - 1);
        v402 -= 8;
        uint64_t v403 = v404;
        *(void *)v402 = 0;
        if (v404) {
          (*(void (**)(uint64_t))(*(void *)v403 + 8))(v403);
        }
      }
    }
    if (v381) {
      operator delete(v381);
    }
  }
  else
  {
    *(void *)__p[1] = v372;
    uint64_t v382 = v381 + 8;
  }
  __p[1] = v382;
  v405 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v572, 1);
  mlir::Pattern::Pattern((uint64_t)(v405 + 1), (uint64_t)"mps.dequantize", 14, (__int16)v572, (uint64_t)Context, 0, 0);
  v405[12] = 0;
  void *v405 = &unk_1EC9D1298;
  if (!v405[9])
  {
    v572 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerDequantize]";
    unint64_t v573 = 99;
    unint64_t v406 = llvm::StringRef::find((uint64_t *)&v572, "DesiredTypeName = ", 0x12uLL, 0);
    if (v573 >= v406) {
      unint64_t v407 = v406;
    }
    else {
      unint64_t v407 = v573;
    }
    v408 = &v572[v407];
    unint64_t v409 = v573 - v407;
    if (v573 - v407 >= 0x12) {
      uint64_t v410 = 18;
    }
    else {
      uint64_t v410 = v573 - v407;
    }
    char v411 = &v408[v410];
    unint64_t v412 = v409 - v410;
    if (v412 >= v412 - 1) {
      --v412;
    }
    v405[8] = v411;
    v405[9] = v412;
  }
  unint64_t v413 = *((unsigned int *)v405 + 22);
  if (v413 > *((_DWORD *)v405 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v405 + 10), v405 + 12, v413, 16);
    LODWORD(v413) = *((_DWORD *)v405 + 22);
  }
  *((_DWORD *)v405 + 22) = v413;
  uint64_t v414 = (char *)__p[1];
  if (__p[1] >= v576[0])
  {
    v416 = (char *)__p[0];
    int64_t v417 = (char *)__p[1] - (char *)__p[0];
    int64_t v418 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v419 = v418 + 1;
    if ((unint64_t)(v418 + 1) >> 61) {
      goto LABEL_692;
    }
    int64_t v420 = (char *)v576[0] - (char *)__p[0];
    if (((char *)v576[0] - (char *)__p[0]) >> 2 > v419) {
      unint64_t v419 = v420 >> 2;
    }
    if ((unint64_t)v420 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v421 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v421 = v419;
    }
    if (v421)
    {
      if (v421 >> 61) {
        goto LABEL_693;
      }
      uint64_t v422 = (char *)operator new(8 * v421);
    }
    else
    {
      uint64_t v422 = 0;
    }
    uint64_t v423 = &v422[8 * v418];
    v424 = (mlir::Operation *)&v422[8 * v421];
    *(void *)uint64_t v423 = v405;
    uint64_t v415 = v423 + 8;
    if (v414 == v416)
    {
      __p[0] = &v422[8 * v418];
      __p[1] = v423 + 8;
      v576[0] = v424;
    }
    else
    {
      unint64_t v425 = v414 - v416 - 8;
      if (v425 < 0x78
        || &v414[-(v425 & 0xFFFFFFFFFFFFFFF8) - 8] < v423 && &v422[v417 - (v425 & 0xFFFFFFFFFFFFFFF8) - 8] < v414)
      {
        goto LABEL_708;
      }
      uint64_t v426 = (v425 >> 3) + 1;
      uint64_t v427 = 8 * (v426 & 0x3FFFFFFFFFFFFFFCLL);
      v428 = &v414[-v427];
      v423 -= v427;
      v429 = &v422[8 * v418 - 16];
      uint64_t v430 = v414 - 16;
      uint64_t v431 = v426 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v433 = *((_OWORD *)v430 - 1);
        long long v432 = *(_OWORD *)v430;
        *((_OWORD *)v430 - 1) = 0uLL;
        *(_OWORD *)uint64_t v430 = 0uLL;
        *((_OWORD *)v429 - 1) = v433;
        *(_OWORD *)v429 = v432;
        v429 -= 32;
        v430 -= 32;
        v431 -= 4;
      }
      while (v431);
      uint64_t v414 = v428;
      if (v426 != (v426 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_708:
        do
        {
          uint64_t v434 = *((void *)v414 - 1);
          v414 -= 8;
          *(void *)uint64_t v414 = 0;
          *((void *)v423 - 1) = v434;
          v423 -= 8;
        }
        while (v414 != v416);
      }
      uint64_t v414 = (char *)__p[0];
      v435 = (char *)__p[1];
      __p[0] = v423;
      __p[1] = v415;
      v576[0] = v424;
      while (v435 != v414)
      {
        uint64_t v437 = *((void *)v435 - 1);
        v435 -= 8;
        uint64_t v436 = v437;
        *(void *)v435 = 0;
        if (v437) {
          (*(void (**)(uint64_t))(*(void *)v436 + 8))(v436);
        }
      }
    }
    if (v414) {
      operator delete(v414);
    }
  }
  else
  {
    *(void *)__p[1] = v405;
    uint64_t v415 = v414 + 8;
  }
  __p[1] = v415;
  v438 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v572, 1);
  mlir::Pattern::Pattern((uint64_t)(v438 + 1), (uint64_t)"mps.dequantize_lut", 18, (__int16)v572, (uint64_t)Context, 0, 0);
  v438[12] = 0;
  void *v438 = &unk_1EC9C8700;
  if (!v438[9])
  {
    v572 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerDequantizeLUT]";
    unint64_t v573 = 102;
    unint64_t v439 = llvm::StringRef::find((uint64_t *)&v572, "DesiredTypeName = ", 0x12uLL, 0);
    if (v573 >= v439) {
      unint64_t v440 = v439;
    }
    else {
      unint64_t v440 = v573;
    }
    v441 = &v572[v440];
    unint64_t v442 = v573 - v440;
    if (v573 - v440 >= 0x12) {
      uint64_t v443 = 18;
    }
    else {
      uint64_t v443 = v573 - v440;
    }
    char v444 = &v441[v443];
    unint64_t v445 = v442 - v443;
    if (v445 >= v445 - 1) {
      --v445;
    }
    v438[8] = v444;
    v438[9] = v445;
  }
  unint64_t v446 = *((unsigned int *)v438 + 22);
  if (v446 > *((_DWORD *)v438 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v438 + 10), v438 + 12, v446, 16);
    LODWORD(v446) = *((_DWORD *)v438 + 22);
  }
  *((_DWORD *)v438 + 22) = v446;
  uint64_t v447 = (char *)__p[1];
  if (__p[1] >= v576[0])
  {
    v449 = (char *)__p[0];
    int64_t v450 = (char *)__p[1] - (char *)__p[0];
    int64_t v451 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v452 = v451 + 1;
    if ((unint64_t)(v451 + 1) >> 61) {
      goto LABEL_692;
    }
    int64_t v453 = (char *)v576[0] - (char *)__p[0];
    if (((char *)v576[0] - (char *)__p[0]) >> 2 > v452) {
      unint64_t v452 = v453 >> 2;
    }
    if ((unint64_t)v453 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v454 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v454 = v452;
    }
    if (v454)
    {
      if (v454 >> 61) {
        goto LABEL_693;
      }
      uint64_t v455 = (char *)operator new(8 * v454);
    }
    else
    {
      uint64_t v455 = 0;
    }
    uint64_t v456 = &v455[8 * v451];
    v457 = (mlir::Operation *)&v455[8 * v454];
    *(void *)uint64_t v456 = v438;
    uint64_t v448 = v456 + 8;
    if (v447 == v449)
    {
      __p[0] = &v455[8 * v451];
      __p[1] = v456 + 8;
      v576[0] = v457;
    }
    else
    {
      unint64_t v458 = v447 - v449 - 8;
      if (v458 < 0x78
        || &v447[-(v458 & 0xFFFFFFFFFFFFFFF8) - 8] < v456 && &v455[v450 - (v458 & 0xFFFFFFFFFFFFFFF8) - 8] < v447)
      {
        goto LABEL_709;
      }
      uint64_t v459 = (v458 >> 3) + 1;
      uint64_t v460 = 8 * (v459 & 0x3FFFFFFFFFFFFFFCLL);
      v461 = &v447[-v460];
      v456 -= v460;
      v462 = &v455[8 * v451 - 16];
      uint64_t v463 = v447 - 16;
      uint64_t v464 = v459 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v466 = *((_OWORD *)v463 - 1);
        long long v465 = *(_OWORD *)v463;
        *((_OWORD *)v463 - 1) = 0uLL;
        *(_OWORD *)uint64_t v463 = 0uLL;
        *((_OWORD *)v462 - 1) = v466;
        *(_OWORD *)v462 = v465;
        v462 -= 32;
        v463 -= 32;
        v464 -= 4;
      }
      while (v464);
      uint64_t v447 = v461;
      if (v459 != (v459 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_709:
        do
        {
          uint64_t v467 = *((void *)v447 - 1);
          v447 -= 8;
          *(void *)uint64_t v447 = 0;
          *((void *)v456 - 1) = v467;
          v456 -= 8;
        }
        while (v447 != v449);
      }
      uint64_t v447 = (char *)__p[0];
      char v468 = (char *)__p[1];
      __p[0] = v456;
      __p[1] = v448;
      v576[0] = v457;
      while (v468 != v447)
      {
        uint64_t v470 = *((void *)v468 - 1);
        v468 -= 8;
        uint64_t v469 = v470;
        *(void *)char v468 = 0;
        if (v470) {
          (*(void (**)(uint64_t))(*(void *)v469 + 8))(v469);
        }
      }
    }
    if (v447) {
      operator delete(v447);
    }
  }
  else
  {
    *(void *)__p[1] = v438;
    uint64_t v448 = v447 + 8;
  }
  __p[1] = v448;
  uint64_t v471 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v572, 1);
  mlir::Pattern::Pattern((uint64_t)(v471 + 1), (uint64_t)"mps.dequantize", 14, (__int16)v572, (uint64_t)Context, 0, 0);
  v471[12] = 0;
  *uint64_t v471 = &unk_1EC9C8310;
  if (!v471[9])
  {
    v572 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerDequantizeND]";
    unint64_t v573 = 101;
    unint64_t v472 = llvm::StringRef::find((uint64_t *)&v572, "DesiredTypeName = ", 0x12uLL, 0);
    if (v573 >= v472) {
      unint64_t v473 = v472;
    }
    else {
      unint64_t v473 = v573;
    }
    unint64_t v474 = &v572[v473];
    unint64_t v475 = v573 - v473;
    if (v573 - v473 >= 0x12) {
      uint64_t v476 = 18;
    }
    else {
      uint64_t v476 = v573 - v473;
    }
    v477 = &v474[v476];
    unint64_t v478 = v475 - v476;
    if (v478 >= v478 - 1) {
      --v478;
    }
    v471[8] = v477;
    v471[9] = v478;
  }
  unint64_t v479 = *((unsigned int *)v471 + 22);
  if (v479 > *((_DWORD *)v471 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v471 + 10), v471 + 12, v479, 16);
    LODWORD(v479) = *((_DWORD *)v471 + 22);
  }
  *((_DWORD *)v471 + 22) = v479;
  uint64_t v480 = (char *)__p[1];
  if (__p[1] >= v576[0])
  {
    unint64_t v482 = (char *)__p[0];
    int64_t v483 = (char *)__p[1] - (char *)__p[0];
    int64_t v484 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v485 = v484 + 1;
    if ((unint64_t)(v484 + 1) >> 61) {
      goto LABEL_692;
    }
    int64_t v486 = (char *)v576[0] - (char *)__p[0];
    if (((char *)v576[0] - (char *)__p[0]) >> 2 > v485) {
      unint64_t v485 = v486 >> 2;
    }
    if ((unint64_t)v486 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v487 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v487 = v485;
    }
    if (v487)
    {
      if (v487 >> 61) {
        goto LABEL_693;
      }
      uint64_t v488 = (char *)operator new(8 * v487);
    }
    else
    {
      uint64_t v488 = 0;
    }
    v489 = &v488[8 * v484];
    unint64_t v490 = (mlir::Operation *)&v488[8 * v487];
    *(void *)v489 = v471;
    v481 = v489 + 8;
    if (v480 == v482)
    {
      __p[0] = &v488[8 * v484];
      __p[1] = v489 + 8;
      v576[0] = v490;
    }
    else
    {
      unint64_t v491 = v480 - v482 - 8;
      if (v491 < 0x78
        || &v480[-(v491 & 0xFFFFFFFFFFFFFFF8) - 8] < v489 && &v488[v483 - (v491 & 0xFFFFFFFFFFFFFFF8) - 8] < v480)
      {
        goto LABEL_710;
      }
      uint64_t v492 = (v491 >> 3) + 1;
      uint64_t v493 = 8 * (v492 & 0x3FFFFFFFFFFFFFFCLL);
      v494 = &v480[-v493];
      v489 -= v493;
      uint64_t v495 = &v488[8 * v484 - 16];
      uint64_t v496 = v480 - 16;
      uint64_t v497 = v492 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v499 = *((_OWORD *)v496 - 1);
        long long v498 = *(_OWORD *)v496;
        *((_OWORD *)v496 - 1) = 0uLL;
        *(_OWORD *)uint64_t v496 = 0uLL;
        *((_OWORD *)v495 - 1) = v499;
        *(_OWORD *)uint64_t v495 = v498;
        v495 -= 32;
        v496 -= 32;
        v497 -= 4;
      }
      while (v497);
      uint64_t v480 = v494;
      if (v492 != (v492 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_710:
        do
        {
          uint64_t v500 = *((void *)v480 - 1);
          v480 -= 8;
          *(void *)uint64_t v480 = 0;
          *((void *)v489 - 1) = v500;
          v489 -= 8;
        }
        while (v480 != v482);
      }
      uint64_t v480 = (char *)__p[0];
      v501 = (char *)__p[1];
      __p[0] = v489;
      __p[1] = v481;
      v576[0] = v490;
      while (v501 != v480)
      {
        uint64_t v503 = *((void *)v501 - 1);
        v501 -= 8;
        uint64_t v502 = v503;
        *(void *)v501 = 0;
        if (v503) {
          (*(void (**)(uint64_t))(*(void *)v502 + 8))(v502);
        }
      }
    }
    if (v480) {
      operator delete(v480);
    }
  }
  else
  {
    *(void *)__p[1] = v471;
    v481 = v480 + 8;
  }
  __p[1] = v481;
  uint64_t v504 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v572, 1);
  mlir::Pattern::Pattern((uint64_t)(v504 + 1), (uint64_t)"mps.dequantize", 14, (__int16)v572, (uint64_t)Context, 0, 0);
  v504[12] = 0;
  *uint64_t v504 = &unk_1EC9C9178;
  if (!v504[9])
  {
    v572 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerPerAxisDequantize]";
    unint64_t v573 = 106;
    unint64_t v505 = llvm::StringRef::find((uint64_t *)&v572, "DesiredTypeName = ", 0x12uLL, 0);
    if (v573 >= v505) {
      unint64_t v506 = v505;
    }
    else {
      unint64_t v506 = v573;
    }
    v507 = &v572[v506];
    unint64_t v508 = v573 - v506;
    if (v573 - v506 >= 0x12) {
      uint64_t v509 = 18;
    }
    else {
      uint64_t v509 = v573 - v506;
    }
    v510 = &v507[v509];
    unint64_t v511 = v508 - v509;
    if (v511 >= v511 - 1) {
      --v511;
    }
    v504[8] = v510;
    v504[9] = v511;
  }
  unint64_t v512 = *((unsigned int *)v504 + 22);
  if (v512 > *((_DWORD *)v504 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v504 + 10), v504 + 12, v512, 16);
    LODWORD(v512) = *((_DWORD *)v504 + 22);
  }
  *((_DWORD *)v504 + 22) = v512;
  v513 = (char *)__p[1];
  if (__p[1] >= v576[0])
  {
    v515 = (char *)__p[0];
    int64_t v516 = (char *)__p[1] - (char *)__p[0];
    int64_t v517 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v518 = v517 + 1;
    if ((unint64_t)(v517 + 1) >> 61) {
      goto LABEL_692;
    }
    int64_t v519 = (char *)v576[0] - (char *)__p[0];
    if (((char *)v576[0] - (char *)__p[0]) >> 2 > v518) {
      unint64_t v518 = v519 >> 2;
    }
    if ((unint64_t)v519 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v520 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v520 = v518;
    }
    if (v520)
    {
      if (v520 >> 61) {
        goto LABEL_693;
      }
      v521 = (char *)operator new(8 * v520);
    }
    else
    {
      v521 = 0;
    }
    unint64_t v522 = &v521[8 * v517];
    v523 = (mlir::Operation *)&v521[8 * v520];
    *(void *)unint64_t v522 = v504;
    unint64_t v514 = v522 + 8;
    if (v513 == v515)
    {
      __p[0] = &v521[8 * v517];
      __p[1] = v522 + 8;
      v576[0] = v523;
    }
    else
    {
      unint64_t v524 = v513 - v515 - 8;
      if (v524 < 0x78
        || &v513[-(v524 & 0xFFFFFFFFFFFFFFF8) - 8] < v522 && &v521[v516 - (v524 & 0xFFFFFFFFFFFFFFF8) - 8] < v513)
      {
        goto LABEL_711;
      }
      uint64_t v525 = (v524 >> 3) + 1;
      uint64_t v526 = 8 * (v525 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v527 = &v513[-v526];
      v522 -= v526;
      uint64_t v528 = &v521[8 * v517 - 16];
      v529 = v513 - 16;
      uint64_t v530 = v525 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v532 = *((_OWORD *)v529 - 1);
        long long v531 = *(_OWORD *)v529;
        *((_OWORD *)v529 - 1) = 0uLL;
        *(_OWORD *)v529 = 0uLL;
        *((_OWORD *)v528 - 1) = v532;
        *(_OWORD *)uint64_t v528 = v531;
        v528 -= 32;
        v529 -= 32;
        v530 -= 4;
      }
      while (v530);
      v513 = v527;
      if (v525 != (v525 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_711:
        do
        {
          uint64_t v533 = *((void *)v513 - 1);
          v513 -= 8;
          *(void *)v513 = 0;
          *((void *)v522 - 1) = v533;
          v522 -= 8;
        }
        while (v513 != v515);
      }
      v513 = (char *)__p[0];
      v534 = (char *)__p[1];
      __p[0] = v522;
      __p[1] = v514;
      v576[0] = v523;
      while (v534 != v513)
      {
        uint64_t v536 = *((void *)v534 - 1);
        v534 -= 8;
        uint64_t v535 = v536;
        *(void *)v534 = 0;
        if (v536) {
          (*(void (**)(uint64_t))(*(void *)v535 + 8))(v535);
        }
      }
    }
    if (v513) {
      operator delete(v513);
    }
  }
  else
  {
    *(void *)__p[1] = v504;
    unint64_t v514 = v513 + 8;
  }
  __p[1] = v514;
  v537 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v572, 1);
  mlir::Pattern::Pattern((uint64_t)(v537 + 1), (uint64_t)"mpsx.quantized_matmul", 21, (__int16)v572, (uint64_t)Context, 0, 0);
  v537[12] = 0;
  void *v537 = &unk_1EC9C8BC8;
  if (!v537[9])
  {
    v572 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerQuantizedMatmul]";
    unint64_t v573 = 104;
    unint64_t v538 = llvm::StringRef::find((uint64_t *)&v572, "DesiredTypeName = ", 0x12uLL, 0);
    if (v573 >= v538) {
      unint64_t v539 = v538;
    }
    else {
      unint64_t v539 = v573;
    }
    v540 = &v572[v539];
    unint64_t v541 = v573 - v539;
    if (v573 - v539 >= 0x12) {
      uint64_t v542 = 18;
    }
    else {
      uint64_t v542 = v573 - v539;
    }
    v543 = &v540[v542];
    unint64_t v544 = v541 - v542;
    if (v544 >= v544 - 1) {
      --v544;
    }
    v537[8] = v543;
    v537[9] = v544;
  }
  unint64_t v545 = *((unsigned int *)v537 + 22);
  if (v545 > *((_DWORD *)v537 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v537 + 10), v537 + 12, v545, 16);
    LODWORD(v545) = *((_DWORD *)v537 + 22);
  }
  *((_DWORD *)v537 + 22) = v545;
  v546 = (char *)__p[1];
  if (__p[1] < v576[0])
  {
    *(void *)__p[1] = v537;
    unint64_t v547 = v546 + 8;
    goto LABEL_690;
  }
  v548 = (char *)__p[0];
  int64_t v549 = (char *)__p[1] - (char *)__p[0];
  int64_t v550 = ((char *)__p[1] - (char *)__p[0]) >> 3;
  unint64_t v551 = v550 + 1;
  if (!((unint64_t)(v550 + 1) >> 61))
  {
    int64_t v552 = (char *)v576[0] - (char *)__p[0];
    if (((char *)v576[0] - (char *)__p[0]) >> 2 > v551) {
      unint64_t v551 = v552 >> 2;
    }
    if ((unint64_t)v552 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v553 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v553 = v551;
    }
    if (!v553)
    {
      v554 = 0;
      goto LABEL_675;
    }
    if (!(v553 >> 61))
    {
      v554 = (char *)operator new(8 * v553);
LABEL_675:
      unint64_t v555 = &v554[8 * v550];
      v556 = (mlir::Operation *)&v554[8 * v553];
      *(void *)unint64_t v555 = v537;
      unint64_t v547 = v555 + 8;
      if (v546 == v548)
      {
        __p[0] = &v554[8 * v550];
        __p[1] = v555 + 8;
        v576[0] = v556;
      }
      else
      {
        unint64_t v557 = v546 - v548 - 8;
        if (v557 < 0x78
          || &v546[-(v557 & 0xFFFFFFFFFFFFFFF8) - 8] < v555 && &v554[v549 - (v557 & 0xFFFFFFFFFFFFFFF8) - 8] < v546)
        {
          goto LABEL_712;
        }
        uint64_t v558 = (v557 >> 3) + 1;
        uint64_t v559 = 8 * (v558 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v560 = &v546[-v559];
        v555 -= v559;
        uint64_t v561 = &v554[8 * v550 - 16];
        v562 = v546 - 16;
        uint64_t v563 = v558 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v565 = *((_OWORD *)v562 - 1);
          long long v564 = *(_OWORD *)v562;
          *((_OWORD *)v562 - 1) = 0uLL;
          *(_OWORD *)v562 = 0uLL;
          *((_OWORD *)v561 - 1) = v565;
          *(_OWORD *)uint64_t v561 = v564;
          v561 -= 32;
          v562 -= 32;
          v563 -= 4;
        }
        while (v563);
        v546 = v560;
        if (v558 != (v558 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_712:
          do
          {
            uint64_t v566 = *((void *)v546 - 1);
            v546 -= 8;
            *(void *)v546 = 0;
            *((void *)v555 - 1) = v566;
            v555 -= 8;
          }
          while (v546 != v548);
        }
        v546 = (char *)__p[0];
        v567 = (char *)__p[1];
        __p[0] = v555;
        __p[1] = v547;
        v576[0] = v556;
        while (v567 != v546)
        {
          uint64_t v569 = *((void *)v567 - 1);
          v567 -= 8;
          uint64_t v568 = v569;
          *(void *)v567 = 0;
          if (v569) {
            (*(void (**)(uint64_t))(*(void *)v568 + 8))(v568);
          }
        }
      }
      if (v546) {
        operator delete(v546);
      }
LABEL_690:
      __p[1] = v547;
      mlir::FrozenRewritePatternSet::FrozenRewritePatternSet(&v572, &v574, 0, 0, 0, 0);
      mlir::applyFullConversion(a2, (mlir::Operation *)v607, (const mlir::ConversionTarget *)&v572, v570);
    }
LABEL_693:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
LABEL_692:
  abort();
}

void mlir::mps::anonymous namespace'::populateWithGenerated(uint64_t *a1)
{
  uint64_t v861 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  uint64_t v3 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v852, 1);
  long long v853 = xmmword_1E4FBF990;
  long long v854 = *(_OWORD *)&off_1E4FBF9A0;
  mlir::Pattern::Pattern((uint64_t)(v3 + 1), (uint64_t)"mps.bias_add", 12, v852, v2, &v853, 2uLL);
  void *v3 = &unk_1EC9C8C30;
  if (!v3[9])
  {
    *(void *)&long long v853 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerBiasAddNHWC]";
    *((void *)&v853 + 1) = 104;
    unint64_t v4 = llvm::StringRef::find((uint64_t *)&v853, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((void *)&v853 + 1) >= v4) {
      unint64_t v5 = v4;
    }
    else {
      unint64_t v5 = *((void *)&v853 + 1);
    }
    uint64_t v6 = v853 + v5;
    unint64_t v7 = *((void *)&v853 + 1) - v5;
    if (*((void *)&v853 + 1) - v5 >= 0x12) {
      uint64_t v8 = 18;
    }
    else {
      uint64_t v8 = *((void *)&v853 + 1) - v5;
    }
    uint64_t v9 = v6 + v8;
    unint64_t v10 = v7 - v8;
    if (v10 >= v10 - 1) {
      --v10;
    }
    v3[8] = v9;
    v3[9] = v10;
  }
  unint64_t v11 = *((unsigned int *)v3 + 22);
  if (v11 > *((_DWORD *)v3 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v3 + 10), v3 + 12, v11, 16);
    LODWORD(v11) = *((_DWORD *)v3 + 22);
  }
  *((_DWORD *)v3 + 22) = v11;
  unint64_t v13 = (char *)a1[2];
  unint64_t v12 = a1[3];
  if ((unint64_t)v13 >= v12)
  {
    uint64_t v15 = (char *)a1[1];
    uint64_t v16 = (v13 - v15) >> 3;
    unint64_t v17 = v16 + 1;
    if ((unint64_t)(v16 + 1) >> 61) {
      goto LABEL_977;
    }
    uint64_t v18 = v12 - (void)v15;
    if (v18 >> 2 > v17) {
      unint64_t v17 = v18 >> 2;
    }
    if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v19 = v17;
    }
    if (v19)
    {
      if (v19 >> 61) {
        goto LABEL_978;
      }
      uint64_t v20 = (char *)operator new(8 * v19);
    }
    else
    {
      uint64_t v20 = 0;
    }
    int64_t v21 = &v20[8 * v16];
    int64_t v22 = &v20[8 * v19];
    *(void *)int64_t v21 = v3;
    uint64_t v14 = v21 + 8;
    if (v13 == v15)
    {
      a1[1] = (uint64_t)v21;
      a1[2] = (uint64_t)v14;
      a1[3] = (uint64_t)v22;
    }
    else
    {
      unint64_t v23 = v13 - v15 - 8;
      if (v23 < 0x78
        || &v13[-(v23 & 0xFFFFFFFFFFFFFFF8) - 8] < v21 && &v20[v13 - v15 - (v23 & 0xFFFFFFFFFFFFFFF8) - 8] < v13)
      {
        goto LABEL_981;
      }
      uint64_t v24 = (v23 >> 3) + 1;
      uint64_t v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v26 = &v13[-v25];
      v21 -= v25;
      unint64_t v27 = &v20[8 * v16 - 16];
      unint64_t v28 = v13 - 16;
      uint64_t v29 = v24 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v31 = *((_OWORD *)v28 - 1);
        long long v30 = *(_OWORD *)v28;
        *((_OWORD *)v28 - 1) = 0uLL;
        *(_OWORD *)unint64_t v28 = 0uLL;
        *((_OWORD *)v27 - 1) = v31;
        *(_OWORD *)unint64_t v27 = v30;
        v27 -= 32;
        v28 -= 32;
        v29 -= 4;
      }
      while (v29);
      unint64_t v13 = v26;
      if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_981:
        do
        {
          uint64_t v32 = *((void *)v13 - 1);
          v13 -= 8;
          *(void *)unint64_t v13 = 0;
          *((void *)v21 - 1) = v32;
          v21 -= 8;
        }
        while (v13 != v15);
      }
      unint64_t v13 = (char *)a1[1];
      uint64_t v33 = (char *)a1[2];
      a1[1] = (uint64_t)v21;
      a1[2] = (uint64_t)v14;
      a1[3] = (uint64_t)v22;
      while (v33 != v13)
      {
        uint64_t v35 = *((void *)v33 - 1);
        v33 -= 8;
        uint64_t v34 = v35;
        *(void *)uint64_t v33 = 0;
        if (v35) {
          (*(void (**)(uint64_t))(*(void *)v34 + 8))(v34);
        }
      }
    }
    if (v13) {
      operator delete(v13);
    }
  }
  else
  {
    *(void *)unint64_t v13 = v3;
    uint64_t v14 = v13 + 8;
  }
  a1[2] = (uint64_t)v14;
  uint64_t v36 = *a1;
  long long v37 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v852, 1);
  *(void *)&long long v853 = "mps.power";
  *((void *)&v853 + 1) = 9;
  mlir::Pattern::Pattern((uint64_t)(v37 + 1), (uint64_t)"mps.degamma", 11, v852, v36, &v853, 1uLL);
  void *v37 = &unk_1EC9C81E0;
  if (!v37[9])
  {
    *(void *)&long long v853 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerDegamma]";
    *((void *)&v853 + 1) = 100;
    unint64_t v38 = llvm::StringRef::find((uint64_t *)&v853, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((void *)&v853 + 1) >= v38) {
      unint64_t v39 = v38;
    }
    else {
      unint64_t v39 = *((void *)&v853 + 1);
    }
    uint64_t v40 = v853 + v39;
    unint64_t v41 = *((void *)&v853 + 1) - v39;
    if (*((void *)&v853 + 1) - v39 >= 0x12) {
      uint64_t v42 = 18;
    }
    else {
      uint64_t v42 = *((void *)&v853 + 1) - v39;
    }
    uint64_t v43 = v40 + v42;
    unint64_t v44 = v41 - v42;
    if (v44 >= v44 - 1) {
      --v44;
    }
    v37[8] = v43;
    v37[9] = v44;
  }
  unint64_t v45 = *((unsigned int *)v37 + 22);
  if (v45 > *((_DWORD *)v37 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v37 + 10), v37 + 12, v45, 16);
    LODWORD(v45) = *((_DWORD *)v37 + 22);
  }
  *((_DWORD *)v37 + 22) = v45;
  uint64_t v47 = (char *)a1[2];
  unint64_t v46 = a1[3];
  if ((unint64_t)v47 >= v46)
  {
    unint64_t v49 = (char *)a1[1];
    uint64_t v50 = (v47 - v49) >> 3;
    unint64_t v51 = v50 + 1;
    if ((unint64_t)(v50 + 1) >> 61) {
      goto LABEL_977;
    }
    uint64_t v52 = v46 - (void)v49;
    if (v52 >> 2 > v51) {
      unint64_t v51 = v52 >> 2;
    }
    if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v53 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v53 = v51;
    }
    if (v53)
    {
      if (v53 >> 61) {
        goto LABEL_978;
      }
      int64_t v54 = (char *)operator new(8 * v53);
    }
    else
    {
      int64_t v54 = 0;
    }
    int64_t v55 = &v54[8 * v50];
    unint64_t v56 = &v54[8 * v53];
    *(void *)int64_t v55 = v37;
    uint64_t v48 = v55 + 8;
    if (v47 == v49)
    {
      a1[1] = (uint64_t)v55;
      a1[2] = (uint64_t)v48;
      a1[3] = (uint64_t)v56;
    }
    else
    {
      unint64_t v57 = v47 - v49 - 8;
      if (v57 < 0x78
        || &v47[-(v57 & 0xFFFFFFFFFFFFFFF8) - 8] < v55 && &v54[v47 - v49 - (v57 & 0xFFFFFFFFFFFFFFF8) - 8] < v47)
      {
        goto LABEL_982;
      }
      uint64_t v58 = (v57 >> 3) + 1;
      uint64_t v59 = 8 * (v58 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v60 = &v47[-v59];
      v55 -= v59;
      char v61 = &v54[8 * v50 - 16];
      unint64_t v62 = v47 - 16;
      uint64_t v63 = v58 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v65 = *((_OWORD *)v62 - 1);
        long long v64 = *(_OWORD *)v62;
        *((_OWORD *)v62 - 1) = 0uLL;
        *(_OWORD *)unint64_t v62 = 0uLL;
        *((_OWORD *)v61 - 1) = v65;
        *(_OWORD *)char v61 = v64;
        v61 -= 32;
        v62 -= 32;
        v63 -= 4;
      }
      while (v63);
      uint64_t v47 = v60;
      if (v58 != (v58 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_982:
        do
        {
          uint64_t v66 = *((void *)v47 - 1);
          v47 -= 8;
          *(void *)uint64_t v47 = 0;
          *((void *)v55 - 1) = v66;
          v55 -= 8;
        }
        while (v47 != v49);
      }
      uint64_t v47 = (char *)a1[1];
      unint64_t v67 = (char *)a1[2];
      a1[1] = (uint64_t)v55;
      a1[2] = (uint64_t)v48;
      a1[3] = (uint64_t)v56;
      while (v67 != v47)
      {
        uint64_t v69 = *((void *)v67 - 1);
        v67 -= 8;
        uint64_t v68 = v69;
        *(void *)unint64_t v67 = 0;
        if (v69) {
          (*(void (**)(uint64_t))(*(void *)v68 + 8))(v68);
        }
      }
    }
    if (v47) {
      operator delete(v47);
    }
  }
  else
  {
    *(void *)uint64_t v47 = v37;
    uint64_t v48 = v47 + 8;
  }
  a1[2] = (uint64_t)v48;
  uint64_t v70 = *a1;
  uint64_t v71 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v852, 1);
  long long v853 = xmmword_1E4FBF9B0;
  long long v854 = *(_OWORD *)&off_1E4FBF9C0;
  mlir::Pattern::Pattern((uint64_t)(v71 + 1), (uint64_t)"mps.dirac", 9, v852, v70, &v853, 2uLL);
  void *v71 = &unk_1EC9C7DB8;
  if (!v71[9])
  {
    *(void *)&long long v853 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerDirac]";
    *((void *)&v853 + 1) = 98;
    unint64_t v72 = llvm::StringRef::find((uint64_t *)&v853, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((void *)&v853 + 1) >= v72) {
      unint64_t v73 = v72;
    }
    else {
      unint64_t v73 = *((void *)&v853 + 1);
    }
    uint64_t v74 = v853 + v73;
    unint64_t v75 = *((void *)&v853 + 1) - v73;
    if (*((void *)&v853 + 1) - v73 >= 0x12) {
      uint64_t v76 = 18;
    }
    else {
      uint64_t v76 = *((void *)&v853 + 1) - v73;
    }
    uint64_t v77 = v74 + v76;
    unint64_t v78 = v75 - v76;
    if (v78 >= v78 - 1) {
      --v78;
    }
    v71[8] = v77;
    v71[9] = v78;
  }
  unint64_t v79 = *((unsigned int *)v71 + 22);
  if (v79 > *((_DWORD *)v71 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v71 + 10), v71 + 12, v79, 16);
    LODWORD(v79) = *((_DWORD *)v71 + 22);
  }
  *((_DWORD *)v71 + 22) = v79;
  uint64_t v81 = (char *)a1[2];
  unint64_t v80 = a1[3];
  if ((unint64_t)v81 >= v80)
  {
    unint64_t v83 = (char *)a1[1];
    uint64_t v84 = (v81 - v83) >> 3;
    unint64_t v85 = v84 + 1;
    if ((unint64_t)(v84 + 1) >> 61) {
      goto LABEL_977;
    }
    uint64_t v86 = v80 - (void)v83;
    if (v86 >> 2 > v85) {
      unint64_t v85 = v86 >> 2;
    }
    if ((unint64_t)v86 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v87 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v87 = v85;
    }
    if (v87)
    {
      if (v87 >> 61) {
        goto LABEL_978;
      }
      int64_t v88 = (char *)operator new(8 * v87);
    }
    else
    {
      int64_t v88 = 0;
    }
    unint64_t v89 = &v88[8 * v84];
    int64_t v90 = &v88[8 * v87];
    *(void *)unint64_t v89 = v71;
    unint64_t v82 = v89 + 8;
    if (v81 == v83)
    {
      a1[1] = (uint64_t)v89;
      a1[2] = (uint64_t)v82;
      a1[3] = (uint64_t)v90;
    }
    else
    {
      unint64_t v91 = v81 - v83 - 8;
      if (v91 < 0x78
        || &v81[-(v91 & 0xFFFFFFFFFFFFFFF8) - 8] < v89 && &v88[v81 - v83 - (v91 & 0xFFFFFFFFFFFFFFF8) - 8] < v81)
      {
        goto LABEL_983;
      }
      uint64_t v92 = (v91 >> 3) + 1;
      uint64_t v93 = 8 * (v92 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v94 = &v81[-v93];
      v89 -= v93;
      unint64_t v95 = &v88[8 * v84 - 16];
      uint64_t v96 = v81 - 16;
      uint64_t v97 = v92 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v99 = *((_OWORD *)v96 - 1);
        long long v98 = *(_OWORD *)v96;
        *((_OWORD *)v96 - 1) = 0uLL;
        *(_OWORD *)uint64_t v96 = 0uLL;
        *((_OWORD *)v95 - 1) = v99;
        *(_OWORD *)unint64_t v95 = v98;
        v95 -= 32;
        v96 -= 32;
        v97 -= 4;
      }
      while (v97);
      uint64_t v81 = v94;
      if (v92 != (v92 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_983:
        do
        {
          uint64_t v100 = *((void *)v81 - 1);
          v81 -= 8;
          *(void *)uint64_t v81 = 0;
          *((void *)v89 - 1) = v100;
          v89 -= 8;
        }
        while (v81 != v83);
      }
      uint64_t v81 = (char *)a1[1];
      uint64_t v101 = (char *)a1[2];
      a1[1] = (uint64_t)v89;
      a1[2] = (uint64_t)v82;
      a1[3] = (uint64_t)v90;
      while (v101 != v81)
      {
        uint64_t v103 = *((void *)v101 - 1);
        v101 -= 8;
        uint64_t v102 = v103;
        *(void *)uint64_t v101 = 0;
        if (v103) {
          (*(void (**)(uint64_t))(*(void *)v102 + 8))(v102);
        }
      }
    }
    if (v81) {
      operator delete(v81);
    }
  }
  else
  {
    *(void *)uint64_t v81 = v71;
    unint64_t v82 = v81 + 8;
  }
  a1[2] = (uint64_t)v82;
  uint64_t v104 = *a1;
  char v105 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v852, 1);
  long long v855 = xmmword_1E4FBF9F0;
  long long v856 = *(_OWORD *)&off_1E4FBFA00;
  long long v857 = xmmword_1E4FBFA10;
  long long v853 = xmmword_1E4FBF9D0;
  long long v854 = *(_OWORD *)&off_1E4FBF9E0;
  mlir::Pattern::Pattern((uint64_t)(v105 + 1), (uint64_t)"mps.elu", 7, v852, v104, &v853, 5uLL);
  *char v105 = &unk_1EC9C7A98;
  if (!v105[9])
  {
    *(void *)&long long v853 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerElu]";
    *((void *)&v853 + 1) = 96;
    unint64_t v106 = llvm::StringRef::find((uint64_t *)&v853, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((void *)&v853 + 1) >= v106) {
      unint64_t v107 = v106;
    }
    else {
      unint64_t v107 = *((void *)&v853 + 1);
    }
    uint64_t v108 = v853 + v107;
    unint64_t v109 = *((void *)&v853 + 1) - v107;
    if (*((void *)&v853 + 1) - v107 >= 0x12) {
      uint64_t v110 = 18;
    }
    else {
      uint64_t v110 = *((void *)&v853 + 1) - v107;
    }
    uint64_t v111 = v108 + v110;
    unint64_t v112 = v109 - v110;
    if (v112 >= v112 - 1) {
      --v112;
    }
    v105[8] = v111;
    v105[9] = v112;
  }
  unint64_t v113 = *((unsigned int *)v105 + 22);
  if (v113 > *((_DWORD *)v105 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v105 + 10), v105 + 12, v113, 16);
    LODWORD(v113) = *((_DWORD *)v105 + 22);
  }
  *((_DWORD *)v105 + 22) = v113;
  unint64_t v115 = (char *)a1[2];
  unint64_t v114 = a1[3];
  if ((unint64_t)v115 >= v114)
  {
    unint64_t v117 = (char *)a1[1];
    uint64_t v118 = (v115 - v117) >> 3;
    unint64_t v119 = v118 + 1;
    if ((unint64_t)(v118 + 1) >> 61) {
      goto LABEL_977;
    }
    uint64_t v120 = v114 - (void)v117;
    if (v120 >> 2 > v119) {
      unint64_t v119 = v120 >> 2;
    }
    if ((unint64_t)v120 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v121 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v121 = v119;
    }
    if (v121)
    {
      if (v121 >> 61) {
        goto LABEL_978;
      }
      unint64_t v122 = (char *)operator new(8 * v121);
    }
    else
    {
      unint64_t v122 = 0;
    }
    int64_t v123 = &v122[8 * v118];
    unint64_t v124 = &v122[8 * v121];
    *(void *)int64_t v123 = v105;
    unint64_t v116 = v123 + 8;
    if (v115 == v117)
    {
      a1[1] = (uint64_t)v123;
      a1[2] = (uint64_t)v116;
      a1[3] = (uint64_t)v124;
    }
    else
    {
      unint64_t v125 = v115 - v117 - 8;
      if (v125 < 0x78
        || &v115[-(v125 & 0xFFFFFFFFFFFFFFF8) - 8] < v123
        && &v122[v115 - v117 - (v125 & 0xFFFFFFFFFFFFFFF8) - 8] < v115)
      {
        goto LABEL_984;
      }
      uint64_t v126 = (v125 >> 3) + 1;
      uint64_t v127 = 8 * (v126 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v128 = &v115[-v127];
      v123 -= v127;
      uint64_t v129 = &v122[8 * v118 - 16];
      uint64_t v130 = v115 - 16;
      uint64_t v131 = v126 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v133 = *((_OWORD *)v130 - 1);
        long long v132 = *(_OWORD *)v130;
        *((_OWORD *)v130 - 1) = 0uLL;
        *(_OWORD *)uint64_t v130 = 0uLL;
        *((_OWORD *)v129 - 1) = v133;
        *(_OWORD *)uint64_t v129 = v132;
        v129 -= 32;
        v130 -= 32;
        v131 -= 4;
      }
      while (v131);
      unint64_t v115 = v128;
      if (v126 != (v126 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_984:
        do
        {
          uint64_t v134 = *((void *)v115 - 1);
          v115 -= 8;
          *(void *)unint64_t v115 = 0;
          *((void *)v123 - 1) = v134;
          v123 -= 8;
        }
        while (v115 != v117);
      }
      unint64_t v115 = (char *)a1[1];
      long long v135 = (char *)a1[2];
      a1[1] = (uint64_t)v123;
      a1[2] = (uint64_t)v116;
      a1[3] = (uint64_t)v124;
      while (v135 != v115)
      {
        uint64_t v137 = *((void *)v135 - 1);
        v135 -= 8;
        uint64_t v136 = v137;
        *(void *)long long v135 = 0;
        if (v137) {
          (*(void (**)(uint64_t))(*(void *)v136 + 8))(v136);
        }
      }
    }
    if (v115) {
      operator delete(v115);
    }
  }
  else
  {
    *(void *)unint64_t v115 = v105;
    unint64_t v116 = v115 + 8;
  }
  a1[2] = (uint64_t)v116;
  uint64_t v138 = *a1;
  uint64_t v139 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v852, 1);
  long long v853 = xmmword_1E4FBFA20;
  long long v854 = *(_OWORD *)&off_1E4FBFA30;
  mlir::Pattern::Pattern((uint64_t)(v139 + 1), (uint64_t)"mps.floor_divide", 16, v852, v138, &v853, 2uLL);
  void *v139 = &unk_1EC9C83B8;
  if (!v139[9])
  {
    *(void *)&long long v853 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerFloorDiv]";
    *((void *)&v853 + 1) = 101;
    unint64_t v140 = llvm::StringRef::find((uint64_t *)&v853, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((void *)&v853 + 1) >= v140) {
      unint64_t v141 = v140;
    }
    else {
      unint64_t v141 = *((void *)&v853 + 1);
    }
    uint64_t v142 = v853 + v141;
    unint64_t v143 = *((void *)&v853 + 1) - v141;
    if (*((void *)&v853 + 1) - v141 >= 0x12) {
      uint64_t v144 = 18;
    }
    else {
      uint64_t v144 = *((void *)&v853 + 1) - v141;
    }
    uint64_t v145 = v142 + v144;
    unint64_t v146 = v143 - v144;
    if (v146 >= v146 - 1) {
      --v146;
    }
    v139[8] = v145;
    v139[9] = v146;
  }
  unint64_t v147 = *((unsigned int *)v139 + 22);
  if (v147 > *((_DWORD *)v139 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v139 + 10), v139 + 12, v147, 16);
    LODWORD(v147) = *((_DWORD *)v139 + 22);
  }
  *((_DWORD *)v139 + 22) = v147;
  unint64_t v149 = (char *)a1[2];
  unint64_t v148 = a1[3];
  if ((unint64_t)v149 >= v148)
  {
    uint64_t v151 = (char *)a1[1];
    uint64_t v152 = (v149 - v151) >> 3;
    unint64_t v153 = v152 + 1;
    if ((unint64_t)(v152 + 1) >> 61) {
      goto LABEL_977;
    }
    uint64_t v154 = v148 - (void)v151;
    if (v154 >> 2 > v153) {
      unint64_t v153 = v154 >> 2;
    }
    if ((unint64_t)v154 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v155 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v155 = v153;
    }
    if (v155)
    {
      if (v155 >> 61) {
        goto LABEL_978;
      }
      int64_t v156 = (char *)operator new(8 * v155);
    }
    else
    {
      int64_t v156 = 0;
    }
    unint64_t v157 = &v156[8 * v152];
    char v158 = &v156[8 * v155];
    *(void *)unint64_t v157 = v139;
    uint64_t v150 = v157 + 8;
    if (v149 == v151)
    {
      a1[1] = (uint64_t)v157;
      a1[2] = (uint64_t)v150;
      a1[3] = (uint64_t)v158;
    }
    else
    {
      unint64_t v159 = v149 - v151 - 8;
      if (v159 < 0x78
        || &v149[-(v159 & 0xFFFFFFFFFFFFFFF8) - 8] < v157
        && &v156[v149 - v151 - (v159 & 0xFFFFFFFFFFFFFFF8) - 8] < v149)
      {
        goto LABEL_985;
      }
      uint64_t v160 = (v159 >> 3) + 1;
      uint64_t v161 = 8 * (v160 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v162 = &v149[-v161];
      v157 -= v161;
      uint64_t v163 = &v156[8 * v152 - 16];
      unint64_t v164 = v149 - 16;
      uint64_t v165 = v160 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v167 = *((_OWORD *)v164 - 1);
        long long v166 = *(_OWORD *)v164;
        *((_OWORD *)v164 - 1) = 0uLL;
        *(_OWORD *)unint64_t v164 = 0uLL;
        *((_OWORD *)v163 - 1) = v167;
        *(_OWORD *)uint64_t v163 = v166;
        v163 -= 32;
        v164 -= 32;
        v165 -= 4;
      }
      while (v165);
      unint64_t v149 = v162;
      if (v160 != (v160 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_985:
        do
        {
          uint64_t v168 = *((void *)v149 - 1);
          v149 -= 8;
          *(void *)unint64_t v149 = 0;
          *((void *)v157 - 1) = v168;
          v157 -= 8;
        }
        while (v149 != v151);
      }
      unint64_t v149 = (char *)a1[1];
      long long v169 = (char *)a1[2];
      a1[1] = (uint64_t)v157;
      a1[2] = (uint64_t)v150;
      a1[3] = (uint64_t)v158;
      while (v169 != v149)
      {
        uint64_t v171 = *((void *)v169 - 1);
        v169 -= 8;
        uint64_t v170 = v171;
        *(void *)long long v169 = 0;
        if (v171) {
          (*(void (**)(uint64_t))(*(void *)v170 + 8))(v170);
        }
      }
    }
    if (v149) {
      operator delete(v149);
    }
  }
  else
  {
    *(void *)unint64_t v149 = v139;
    uint64_t v150 = v149 + 8;
  }
  a1[2] = (uint64_t)v150;
  uint64_t v172 = *a1;
  uint64_t v173 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v852, 1);
  long long v853 = xmmword_1E4FBFA40;
  long long v854 = *(_OWORD *)&off_1E4FBFA50;
  long long v855 = xmmword_1E4FBFA60;
  long long v856 = *(_OWORD *)&off_1E4FBFA70;
  mlir::Pattern::Pattern((uint64_t)(v173 + 1), (uint64_t)"mps.gelu", 8, v852, v172, &v853, 4uLL);
  *uint64_t v173 = &unk_1EC9C7B98;
  if (!v173[9])
  {
    *(void *)&long long v853 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerGelu]";
    *((void *)&v853 + 1) = 97;
    unint64_t v174 = llvm::StringRef::find((uint64_t *)&v853, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((void *)&v853 + 1) >= v174) {
      unint64_t v175 = v174;
    }
    else {
      unint64_t v175 = *((void *)&v853 + 1);
    }
    uint64_t v176 = v853 + v175;
    unint64_t v177 = *((void *)&v853 + 1) - v175;
    if (*((void *)&v853 + 1) - v175 >= 0x12) {
      uint64_t v178 = 18;
    }
    else {
      uint64_t v178 = *((void *)&v853 + 1) - v175;
    }
    uint64_t v179 = v176 + v178;
    unint64_t v180 = v177 - v178;
    if (v180 >= v180 - 1) {
      --v180;
    }
    v173[8] = v179;
    v173[9] = v180;
  }
  unint64_t v181 = *((unsigned int *)v173 + 22);
  if (v181 > *((_DWORD *)v173 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v173 + 10), v173 + 12, v181, 16);
    LODWORD(v181) = *((_DWORD *)v173 + 22);
  }
  *((_DWORD *)v173 + 22) = v181;
  v183 = (char *)a1[2];
  unint64_t v182 = a1[3];
  if ((unint64_t)v183 >= v182)
  {
    uint64_t v185 = (char *)a1[1];
    uint64_t v186 = (v183 - v185) >> 3;
    unint64_t v187 = v186 + 1;
    if ((unint64_t)(v186 + 1) >> 61) {
      goto LABEL_977;
    }
    uint64_t v188 = v182 - (void)v185;
    if (v188 >> 2 > v187) {
      unint64_t v187 = v188 >> 2;
    }
    if ((unint64_t)v188 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v189 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v189 = v187;
    }
    if (v189)
    {
      if (v189 >> 61) {
        goto LABEL_978;
      }
      unint64_t v190 = (char *)operator new(8 * v189);
    }
    else
    {
      unint64_t v190 = 0;
    }
    v191 = &v190[8 * v186];
    v192 = &v190[8 * v189];
    *(void *)v191 = v173;
    v184 = v191 + 8;
    if (v183 == v185)
    {
      a1[1] = (uint64_t)v191;
      a1[2] = (uint64_t)v184;
      a1[3] = (uint64_t)v192;
    }
    else
    {
      unint64_t v193 = v183 - v185 - 8;
      if (v193 < 0x78
        || &v183[-(v193 & 0xFFFFFFFFFFFFFFF8) - 8] < v191
        && &v190[v183 - v185 - (v193 & 0xFFFFFFFFFFFFFFF8) - 8] < v183)
      {
        goto LABEL_986;
      }
      uint64_t v194 = (v193 >> 3) + 1;
      uint64_t v195 = 8 * (v194 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v196 = &v183[-v195];
      v191 -= v195;
      int v197 = &v190[8 * v186 - 16];
      char v198 = v183 - 16;
      uint64_t v199 = v194 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v201 = *((_OWORD *)v198 - 1);
        long long v200 = *(_OWORD *)v198;
        *((_OWORD *)v198 - 1) = 0uLL;
        *(_OWORD *)char v198 = 0uLL;
        *((_OWORD *)v197 - 1) = v201;
        *(_OWORD *)int v197 = v200;
        v197 -= 32;
        v198 -= 32;
        v199 -= 4;
      }
      while (v199);
      v183 = v196;
      if (v194 != (v194 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_986:
        do
        {
          uint64_t v202 = *((void *)v183 - 1);
          v183 -= 8;
          *(void *)v183 = 0;
          *((void *)v191 - 1) = v202;
          v191 -= 8;
        }
        while (v183 != v185);
      }
      v183 = (char *)a1[1];
      uint64_t v203 = (char *)a1[2];
      a1[1] = (uint64_t)v191;
      a1[2] = (uint64_t)v184;
      a1[3] = (uint64_t)v192;
      while (v203 != v183)
      {
        uint64_t v205 = *((void *)v203 - 1);
        v203 -= 8;
        uint64_t v204 = v205;
        *(void *)uint64_t v203 = 0;
        if (v205) {
          (*(void (**)(uint64_t))(*(void *)v204 + 8))(v204);
        }
      }
    }
    if (v183) {
      operator delete(v183);
    }
  }
  else
  {
    *(void *)v183 = v173;
    v184 = v183 + 8;
  }
  a1[2] = (uint64_t)v184;
  uint64_t v206 = *a1;
  v207 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v852, 1);
  long long v853 = xmmword_1E4FBFA80;
  long long v854 = *(_OWORD *)&off_1E4FBFA90;
  long long v855 = xmmword_1E4FBFAA0;
  mlir::Pattern::Pattern((uint64_t)(v207 + 1), (uint64_t)"mps.instance_norm", 17, v852, v206, &v853, 3uLL);
  void *v207 = &unk_1EC9C90A0;
  if (!v207[9])
  {
    *(void *)&long long v853 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerInstanceNorm]";
    *((void *)&v853 + 1) = 105;
    unint64_t v208 = llvm::StringRef::find((uint64_t *)&v853, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((void *)&v853 + 1) >= v208) {
      unint64_t v209 = v208;
    }
    else {
      unint64_t v209 = *((void *)&v853 + 1);
    }
    uint64_t v210 = v853 + v209;
    unint64_t v211 = *((void *)&v853 + 1) - v209;
    if (*((void *)&v853 + 1) - v209 >= 0x12) {
      uint64_t v212 = 18;
    }
    else {
      uint64_t v212 = *((void *)&v853 + 1) - v209;
    }
    uint64_t v213 = v210 + v212;
    unint64_t v214 = v211 - v212;
    if (v214 >= v214 - 1) {
      --v214;
    }
    v207[8] = v213;
    v207[9] = v214;
  }
  unint64_t v215 = *((unsigned int *)v207 + 22);
  if (v215 > *((_DWORD *)v207 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v207 + 10), v207 + 12, v215, 16);
    LODWORD(v215) = *((_DWORD *)v207 + 22);
  }
  *((_DWORD *)v207 + 22) = v215;
  uint64_t v217 = (char *)a1[2];
  unint64_t v216 = a1[3];
  if ((unint64_t)v217 >= v216)
  {
    int64_t v219 = (char *)a1[1];
    uint64_t v220 = (v217 - v219) >> 3;
    unint64_t v221 = v220 + 1;
    if ((unint64_t)(v220 + 1) >> 61) {
      goto LABEL_977;
    }
    uint64_t v222 = v216 - (void)v219;
    if (v222 >> 2 > v221) {
      unint64_t v221 = v222 >> 2;
    }
    if ((unint64_t)v222 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v223 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v223 = v221;
    }
    if (v223)
    {
      if (v223 >> 61) {
        goto LABEL_978;
      }
      v224 = (char *)operator new(8 * v223);
    }
    else
    {
      v224 = 0;
    }
    v225 = &v224[8 * v220];
    uint64_t v226 = &v224[8 * v223];
    *(void *)v225 = v207;
    uint64_t v218 = v225 + 8;
    if (v217 == v219)
    {
      a1[1] = (uint64_t)v225;
      a1[2] = (uint64_t)v218;
      a1[3] = (uint64_t)v226;
    }
    else
    {
      unint64_t v227 = v217 - v219 - 8;
      if (v227 < 0x78
        || &v217[-(v227 & 0xFFFFFFFFFFFFFFF8) - 8] < v225
        && &v224[v217 - v219 - (v227 & 0xFFFFFFFFFFFFFFF8) - 8] < v217)
      {
        goto LABEL_987;
      }
      uint64_t v228 = (v227 >> 3) + 1;
      uint64_t v229 = 8 * (v228 & 0x3FFFFFFFFFFFFFFCLL);
      v230 = &v217[-v229];
      v225 -= v229;
      char v231 = &v224[8 * v220 - 16];
      v232 = v217 - 16;
      uint64_t v233 = v228 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v235 = *((_OWORD *)v232 - 1);
        long long v234 = *(_OWORD *)v232;
        *((_OWORD *)v232 - 1) = 0uLL;
        *(_OWORD *)v232 = 0uLL;
        *((_OWORD *)v231 - 1) = v235;
        *(_OWORD *)char v231 = v234;
        v231 -= 32;
        v232 -= 32;
        v233 -= 4;
      }
      while (v233);
      uint64_t v217 = v230;
      if (v228 != (v228 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_987:
        do
        {
          uint64_t v236 = *((void *)v217 - 1);
          v217 -= 8;
          *(void *)uint64_t v217 = 0;
          *((void *)v225 - 1) = v236;
          v225 -= 8;
        }
        while (v217 != v219);
      }
      uint64_t v217 = (char *)a1[1];
      unint64_t v237 = (char *)a1[2];
      a1[1] = (uint64_t)v225;
      a1[2] = (uint64_t)v218;
      a1[3] = (uint64_t)v226;
      while (v237 != v217)
      {
        uint64_t v239 = *((void *)v237 - 1);
        v237 -= 8;
        uint64_t v238 = v239;
        *(void *)unint64_t v237 = 0;
        if (v239) {
          (*(void (**)(uint64_t))(*(void *)v238 + 8))(v238);
        }
      }
    }
    if (v217) {
      operator delete(v217);
    }
  }
  else
  {
    *(void *)uint64_t v217 = v207;
    uint64_t v218 = v217 + 8;
  }
  a1[2] = (uint64_t)v218;
  uint64_t v240 = *a1;
  unint64_t v241 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v852, 1);
  long long v857 = xmmword_1E4FBFAF0;
  long long v858 = *(_OWORD *)&off_1E4FBFB00;
  long long v859 = xmmword_1E4FBFB10;
  long long v853 = xmmword_1E4FBFAB0;
  long long v854 = *(_OWORD *)&off_1E4FBFAC0;
  long long v855 = xmmword_1E4FBFAD0;
  long long v856 = *(_OWORD *)&off_1E4FBFAE0;
  mlir::Pattern::Pattern((uint64_t)(v241 + 1), (uint64_t)"mps.lp_norm", 11, v852, v240, &v853, 7uLL);
  void *v241 = &unk_1EC9C8078;
  if (!v241[9])
  {
    *(void *)&long long v853 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerLPNorm]";
    *((void *)&v853 + 1) = 99;
    unint64_t v242 = llvm::StringRef::find((uint64_t *)&v853, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((void *)&v853 + 1) >= v242) {
      unint64_t v243 = v242;
    }
    else {
      unint64_t v243 = *((void *)&v853 + 1);
    }
    uint64_t v244 = v853 + v243;
    unint64_t v245 = *((void *)&v853 + 1) - v243;
    if (*((void *)&v853 + 1) - v243 >= 0x12) {
      uint64_t v246 = 18;
    }
    else {
      uint64_t v246 = *((void *)&v853 + 1) - v243;
    }
    uint64_t v247 = v244 + v246;
    unint64_t v248 = v245 - v246;
    if (v248 >= v248 - 1) {
      --v248;
    }
    v241[8] = v247;
    v241[9] = v248;
  }
  unint64_t v249 = *((unsigned int *)v241 + 22);
  if (v249 > *((_DWORD *)v241 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v241 + 10), v241 + 12, v249, 16);
    LODWORD(v249) = *((_DWORD *)v241 + 22);
  }
  *((_DWORD *)v241 + 22) = v249;
  uint64_t v251 = (char *)a1[2];
  unint64_t v250 = a1[3];
  if ((unint64_t)v251 >= v250)
  {
    int64_t v253 = (char *)a1[1];
    uint64_t v254 = (v251 - v253) >> 3;
    unint64_t v255 = v254 + 1;
    if ((unint64_t)(v254 + 1) >> 61) {
      goto LABEL_977;
    }
    uint64_t v256 = v250 - (void)v253;
    if (v256 >> 2 > v255) {
      unint64_t v255 = v256 >> 2;
    }
    if ((unint64_t)v256 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v257 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v257 = v255;
    }
    if (v257)
    {
      if (v257 >> 61) {
        goto LABEL_978;
      }
      uint64_t v258 = (char *)operator new(8 * v257);
    }
    else
    {
      uint64_t v258 = 0;
    }
    uint64_t v259 = &v258[8 * v254];
    unint64_t v260 = &v258[8 * v257];
    *(void *)uint64_t v259 = v241;
    int64_t v252 = v259 + 8;
    if (v251 == v253)
    {
      a1[1] = (uint64_t)v259;
      a1[2] = (uint64_t)v252;
      a1[3] = (uint64_t)v260;
    }
    else
    {
      unint64_t v261 = v251 - v253 - 8;
      if (v261 < 0x78
        || &v251[-(v261 & 0xFFFFFFFFFFFFFFF8) - 8] < v259
        && &v258[v251 - v253 - (v261 & 0xFFFFFFFFFFFFFFF8) - 8] < v251)
      {
        goto LABEL_988;
      }
      uint64_t v262 = (v261 >> 3) + 1;
      uint64_t v263 = 8 * (v262 & 0x3FFFFFFFFFFFFFFCLL);
      char v264 = &v251[-v263];
      v259 -= v263;
      v265 = &v258[8 * v254 - 16];
      uint64_t v266 = v251 - 16;
      uint64_t v267 = v262 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v269 = *((_OWORD *)v266 - 1);
        long long v268 = *(_OWORD *)v266;
        *((_OWORD *)v266 - 1) = 0uLL;
        *(_OWORD *)uint64_t v266 = 0uLL;
        *((_OWORD *)v265 - 1) = v269;
        *(_OWORD *)v265 = v268;
        v265 -= 32;
        v266 -= 32;
        v267 -= 4;
      }
      while (v267);
      uint64_t v251 = v264;
      if (v262 != (v262 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_988:
        do
        {
          uint64_t v270 = *((void *)v251 - 1);
          v251 -= 8;
          *(void *)uint64_t v251 = 0;
          *((void *)v259 - 1) = v270;
          v259 -= 8;
        }
        while (v251 != v253);
      }
      uint64_t v251 = (char *)a1[1];
      uint64_t v271 = (char *)a1[2];
      a1[1] = (uint64_t)v259;
      a1[2] = (uint64_t)v252;
      a1[3] = (uint64_t)v260;
      while (v271 != v251)
      {
        uint64_t v273 = *((void *)v271 - 1);
        v271 -= 8;
        uint64_t v272 = v273;
        *(void *)uint64_t v271 = 0;
        if (v273) {
          (*(void (**)(uint64_t))(*(void *)v272 + 8))(v272);
        }
      }
    }
    if (v251) {
      operator delete(v251);
    }
  }
  else
  {
    *(void *)uint64_t v251 = v241;
    int64_t v252 = v251 + 8;
  }
  a1[2] = (uint64_t)v252;
  uint64_t v274 = *a1;
  unint64_t v275 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v852, 1);
  long long v853 = xmmword_1E4FBFB20;
  long long v854 = *(_OWORD *)&off_1E4FBFB30;
  long long v855 = xmmword_1E4FBFB40;
  mlir::Pattern::Pattern((uint64_t)(v275 + 1), (uint64_t)"mps.leaky_relu", 14, v852, v274, &v853, 3uLL);
  *unint64_t v275 = &unk_1EC9C8890;
  if (!v275[9])
  {
    *(void *)&long long v853 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerLeakyRelu]";
    *((void *)&v853 + 1) = 102;
    unint64_t v276 = llvm::StringRef::find((uint64_t *)&v853, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((void *)&v853 + 1) >= v276) {
      unint64_t v277 = v276;
    }
    else {
      unint64_t v277 = *((void *)&v853 + 1);
    }
    uint64_t v278 = v853 + v277;
    unint64_t v279 = *((void *)&v853 + 1) - v277;
    if (*((void *)&v853 + 1) - v277 >= 0x12) {
      uint64_t v280 = 18;
    }
    else {
      uint64_t v280 = *((void *)&v853 + 1) - v277;
    }
    uint64_t v281 = v278 + v280;
    unint64_t v282 = v279 - v280;
    if (v282 >= v282 - 1) {
      --v282;
    }
    v275[8] = v281;
    v275[9] = v282;
  }
  unint64_t v283 = *((unsigned int *)v275 + 22);
  if (v283 > *((_DWORD *)v275 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v275 + 10), v275 + 12, v283, 16);
    LODWORD(v283) = *((_DWORD *)v275 + 22);
  }
  *((_DWORD *)v275 + 22) = v283;
  int64_t v285 = (char *)a1[2];
  unint64_t v284 = a1[3];
  if ((unint64_t)v285 >= v284)
  {
    unint64_t v287 = (char *)a1[1];
    uint64_t v288 = (v285 - v287) >> 3;
    unint64_t v289 = v288 + 1;
    if ((unint64_t)(v288 + 1) >> 61) {
      goto LABEL_977;
    }
    uint64_t v290 = v284 - (void)v287;
    if (v290 >> 2 > v289) {
      unint64_t v289 = v290 >> 2;
    }
    if ((unint64_t)v290 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v291 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v291 = v289;
    }
    if (v291)
    {
      if (v291 >> 61) {
        goto LABEL_978;
      }
      uint64_t v292 = (char *)operator new(8 * v291);
    }
    else
    {
      uint64_t v292 = 0;
    }
    unint64_t v293 = &v292[8 * v288];
    uint64_t v294 = &v292[8 * v291];
    *(void *)unint64_t v293 = v275;
    int64_t v286 = v293 + 8;
    if (v285 == v287)
    {
      a1[1] = (uint64_t)v293;
      a1[2] = (uint64_t)v286;
      a1[3] = (uint64_t)v294;
    }
    else
    {
      unint64_t v295 = v285 - v287 - 8;
      if (v295 < 0x78
        || &v285[-(v295 & 0xFFFFFFFFFFFFFFF8) - 8] < v293
        && &v292[v285 - v287 - (v295 & 0xFFFFFFFFFFFFFFF8) - 8] < v285)
      {
        goto LABEL_989;
      }
      uint64_t v296 = (v295 >> 3) + 1;
      uint64_t v297 = 8 * (v296 & 0x3FFFFFFFFFFFFFFCLL);
      v298 = &v285[-v297];
      v293 -= v297;
      uint64_t v299 = &v292[8 * v288 - 16];
      long long v300 = v285 - 16;
      uint64_t v301 = v296 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v303 = *((_OWORD *)v300 - 1);
        long long v302 = *(_OWORD *)v300;
        *((_OWORD *)v300 - 1) = 0uLL;
        *(_OWORD *)long long v300 = 0uLL;
        *((_OWORD *)v299 - 1) = v303;
        *(_OWORD *)uint64_t v299 = v302;
        v299 -= 32;
        v300 -= 32;
        v301 -= 4;
      }
      while (v301);
      int64_t v285 = v298;
      if (v296 != (v296 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_989:
        do
        {
          uint64_t v304 = *((void *)v285 - 1);
          v285 -= 8;
          *(void *)int64_t v285 = 0;
          *((void *)v293 - 1) = v304;
          v293 -= 8;
        }
        while (v285 != v287);
      }
      int64_t v285 = (char *)a1[1];
      uint64_t v305 = (char *)a1[2];
      a1[1] = (uint64_t)v293;
      a1[2] = (uint64_t)v286;
      a1[3] = (uint64_t)v294;
      while (v305 != v285)
      {
        uint64_t v307 = *((void *)v305 - 1);
        v305 -= 8;
        uint64_t v306 = v307;
        *(void *)uint64_t v305 = 0;
        if (v307) {
          (*(void (**)(uint64_t))(*(void *)v306 + 8))(v306);
        }
      }
    }
    if (v285) {
      operator delete(v285);
    }
  }
  else
  {
    *(void *)int64_t v285 = v275;
    int64_t v286 = v285 + 8;
  }
  a1[2] = (uint64_t)v286;
  uint64_t v308 = *a1;
  uint64_t v309 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v852, 1);
  long long v853 = xmmword_1E4FBFB50;
  long long v854 = *(_OWORD *)&off_1E4FBFB60;
  long long v855 = xmmword_1E4FBFB70;
  long long v856 = *(_OWORD *)&off_1E4FBFB80;
  mlir::Pattern::Pattern((uint64_t)(v309 + 1), (uint64_t)"mps.n_relu", 10, v852, v308, &v853, 4uLL);
  *uint64_t v309 = &unk_1EC9C7DF8;
  if (!v309[9])
  {
    *(void *)&long long v853 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerNRelu]";
    *((void *)&v853 + 1) = 98;
    unint64_t v310 = llvm::StringRef::find((uint64_t *)&v853, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((void *)&v853 + 1) >= v310) {
      unint64_t v311 = v310;
    }
    else {
      unint64_t v311 = *((void *)&v853 + 1);
    }
    uint64_t v312 = v853 + v311;
    unint64_t v313 = *((void *)&v853 + 1) - v311;
    if (*((void *)&v853 + 1) - v311 >= 0x12) {
      uint64_t v314 = 18;
    }
    else {
      uint64_t v314 = *((void *)&v853 + 1) - v311;
    }
    uint64_t v315 = v312 + v314;
    unint64_t v316 = v313 - v314;
    if (v316 >= v316 - 1) {
      --v316;
    }
    v309[8] = v315;
    v309[9] = v316;
  }
  unint64_t v317 = *((unsigned int *)v309 + 22);
  if (v317 > *((_DWORD *)v309 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v309 + 10), v309 + 12, v317, 16);
    LODWORD(v317) = *((_DWORD *)v309 + 22);
  }
  *((_DWORD *)v309 + 22) = v317;
  int64_t v319 = (char *)a1[2];
  unint64_t v318 = a1[3];
  if ((unint64_t)v319 >= v318)
  {
    int64_t v321 = (char *)a1[1];
    uint64_t v322 = (v319 - v321) >> 3;
    unint64_t v323 = v322 + 1;
    if ((unint64_t)(v322 + 1) >> 61) {
      goto LABEL_977;
    }
    uint64_t v324 = v318 - (void)v321;
    if (v324 >> 2 > v323) {
      unint64_t v323 = v324 >> 2;
    }
    if ((unint64_t)v324 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v325 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v325 = v323;
    }
    if (v325)
    {
      if (v325 >> 61) {
        goto LABEL_978;
      }
      unint64_t v326 = (char *)operator new(8 * v325);
    }
    else
    {
      unint64_t v326 = 0;
    }
    uint64_t v327 = &v326[8 * v322];
    uint64_t v328 = &v326[8 * v325];
    *(void *)uint64_t v327 = v309;
    unint64_t v320 = v327 + 8;
    if (v319 == v321)
    {
      a1[1] = (uint64_t)v327;
      a1[2] = (uint64_t)v320;
      a1[3] = (uint64_t)v328;
    }
    else
    {
      unint64_t v329 = v319 - v321 - 8;
      if (v329 < 0x78
        || &v319[-(v329 & 0xFFFFFFFFFFFFFFF8) - 8] < v327
        && &v326[v319 - v321 - (v329 & 0xFFFFFFFFFFFFFFF8) - 8] < v319)
      {
        goto LABEL_990;
      }
      uint64_t v330 = (v329 >> 3) + 1;
      uint64_t v331 = 8 * (v330 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v332 = &v319[-v331];
      v327 -= v331;
      long long v333 = &v326[8 * v322 - 16];
      long long v334 = v319 - 16;
      uint64_t v335 = v330 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v337 = *((_OWORD *)v334 - 1);
        long long v336 = *(_OWORD *)v334;
        *((_OWORD *)v334 - 1) = 0uLL;
        *(_OWORD *)long long v334 = 0uLL;
        *((_OWORD *)v333 - 1) = v337;
        *(_OWORD *)long long v333 = v336;
        v333 -= 32;
        v334 -= 32;
        v335 -= 4;
      }
      while (v335);
      int64_t v319 = v332;
      if (v330 != (v330 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_990:
        do
        {
          uint64_t v338 = *((void *)v319 - 1);
          v319 -= 8;
          *(void *)int64_t v319 = 0;
          *((void *)v327 - 1) = v338;
          v327 -= 8;
        }
        while (v319 != v321);
      }
      int64_t v319 = (char *)a1[1];
      v339 = (char *)a1[2];
      a1[1] = (uint64_t)v327;
      a1[2] = (uint64_t)v320;
      a1[3] = (uint64_t)v328;
      while (v339 != v319)
      {
        uint64_t v341 = *((void *)v339 - 1);
        v339 -= 8;
        uint64_t v340 = v341;
        *(void *)v339 = 0;
        if (v341) {
          (*(void (**)(uint64_t))(*(void *)v340 + 8))(v340);
        }
      }
    }
    if (v319) {
      operator delete(v319);
    }
  }
  else
  {
    *(void *)int64_t v319 = v309;
    unint64_t v320 = v319 + 8;
  }
  a1[2] = (uint64_t)v320;
  uint64_t v342 = *a1;
  unint64_t v343 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v852, 1);
  long long v855 = xmmword_1E4FBFBB0;
  long long v856 = *(_OWORD *)&off_1E4FBFBC0;
  long long v857 = xmmword_1E4FBFBD0;
  long long v858 = *(_OWORD *)&off_1E4FBFBE0;
  long long v853 = xmmword_1E4FBFB90;
  long long v854 = *(_OWORD *)&off_1E4FBFBA0;
  mlir::Pattern::Pattern((uint64_t)(v343 + 1), (uint64_t)"mps.normalization", 17, v852, v342, &v853, 6uLL);
  void *v343 = &unk_1EC9C9248;
  if (!v343[9])
  {
    *(void *)&long long v853 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerNormalization]";
    *((void *)&v853 + 1) = 106;
    unint64_t v344 = llvm::StringRef::find((uint64_t *)&v853, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((void *)&v853 + 1) >= v344) {
      unint64_t v345 = v344;
    }
    else {
      unint64_t v345 = *((void *)&v853 + 1);
    }
    uint64_t v346 = v853 + v345;
    unint64_t v347 = *((void *)&v853 + 1) - v345;
    if (*((void *)&v853 + 1) - v345 >= 0x12) {
      uint64_t v348 = 18;
    }
    else {
      uint64_t v348 = *((void *)&v853 + 1) - v345;
    }
    uint64_t v349 = v346 + v348;
    unint64_t v350 = v347 - v348;
    if (v350 >= v350 - 1) {
      --v350;
    }
    v343[8] = v349;
    v343[9] = v350;
  }
  unint64_t v351 = *((unsigned int *)v343 + 22);
  if (v351 > *((_DWORD *)v343 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v343 + 10), v343 + 12, v351, 16);
    LODWORD(v351) = *((_DWORD *)v343 + 22);
  }
  *((_DWORD *)v343 + 22) = v351;
  unint64_t v353 = (char *)a1[2];
  unint64_t v352 = a1[3];
  if ((unint64_t)v353 >= v352)
  {
    unint64_t v355 = (char *)a1[1];
    uint64_t v356 = (v353 - v355) >> 3;
    unint64_t v357 = v356 + 1;
    if ((unint64_t)(v356 + 1) >> 61) {
      goto LABEL_977;
    }
    uint64_t v358 = v352 - (void)v355;
    if (v358 >> 2 > v357) {
      unint64_t v357 = v358 >> 2;
    }
    if ((unint64_t)v358 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v359 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v359 = v357;
    }
    if (v359)
    {
      if (v359 >> 61) {
        goto LABEL_978;
      }
      uint64_t v360 = (char *)operator new(8 * v359);
    }
    else
    {
      uint64_t v360 = 0;
    }
    uint64_t v361 = &v360[8 * v356];
    char v362 = &v360[8 * v359];
    *(void *)uint64_t v361 = v343;
    int64_t v354 = v361 + 8;
    if (v353 == v355)
    {
      a1[1] = (uint64_t)v361;
      a1[2] = (uint64_t)v354;
      a1[3] = (uint64_t)v362;
    }
    else
    {
      unint64_t v363 = v353 - v355 - 8;
      if (v363 < 0x78
        || &v353[-(v363 & 0xFFFFFFFFFFFFFFF8) - 8] < v361
        && &v360[v353 - v355 - (v363 & 0xFFFFFFFFFFFFFFF8) - 8] < v353)
      {
        goto LABEL_991;
      }
      uint64_t v364 = (v363 >> 3) + 1;
      uint64_t v365 = 8 * (v364 & 0x3FFFFFFFFFFFFFFCLL);
      long long v366 = &v353[-v365];
      v361 -= v365;
      long long v367 = &v360[8 * v356 - 16];
      uint64_t v368 = v353 - 16;
      uint64_t v369 = v364 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v371 = *((_OWORD *)v368 - 1);
        long long v370 = *(_OWORD *)v368;
        *((_OWORD *)v368 - 1) = 0uLL;
        *(_OWORD *)uint64_t v368 = 0uLL;
        *((_OWORD *)v367 - 1) = v371;
        *(_OWORD *)long long v367 = v370;
        v367 -= 32;
        v368 -= 32;
        v369 -= 4;
      }
      while (v369);
      unint64_t v353 = v366;
      if (v364 != (v364 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_991:
        do
        {
          uint64_t v372 = *((void *)v353 - 1);
          v353 -= 8;
          *(void *)unint64_t v353 = 0;
          *((void *)v361 - 1) = v372;
          v361 -= 8;
        }
        while (v353 != v355);
      }
      unint64_t v353 = (char *)a1[1];
      unint64_t v373 = (char *)a1[2];
      a1[1] = (uint64_t)v361;
      a1[2] = (uint64_t)v354;
      a1[3] = (uint64_t)v362;
      while (v373 != v353)
      {
        uint64_t v375 = *((void *)v373 - 1);
        v373 -= 8;
        uint64_t v374 = v375;
        *(void *)unint64_t v373 = 0;
        if (v375) {
          (*(void (**)(uint64_t))(*(void *)v374 + 8))(v374);
        }
      }
    }
    if (v353) {
      operator delete(v353);
    }
  }
  else
  {
    *(void *)unint64_t v353 = v343;
    int64_t v354 = v353 + 8;
  }
  a1[2] = (uint64_t)v354;
  uint64_t v376 = *a1;
  uint64_t v377 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v852, 1);
  long long v853 = xmmword_1E4FBFBF0;
  long long v854 = *(_OWORD *)&off_1E4FBFC00;
  long long v855 = xmmword_1E4FBFC10;
  long long v856 = *(_OWORD *)&off_1E4FBFC20;
  mlir::Pattern::Pattern((uint64_t)(v377 + 1), (uint64_t)"mps.prelu", 9, v852, v376, &v853, 4uLL);
  void *v377 = &unk_1EC9C7E38;
  if (!v377[9])
  {
    *(void *)&long long v853 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerPRelu]";
    *((void *)&v853 + 1) = 98;
    unint64_t v378 = llvm::StringRef::find((uint64_t *)&v853, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((void *)&v853 + 1) >= v378) {
      unint64_t v379 = v378;
    }
    else {
      unint64_t v379 = *((void *)&v853 + 1);
    }
    uint64_t v380 = v853 + v379;
    unint64_t v381 = *((void *)&v853 + 1) - v379;
    if (*((void *)&v853 + 1) - v379 >= 0x12) {
      uint64_t v382 = 18;
    }
    else {
      uint64_t v382 = *((void *)&v853 + 1) - v379;
    }
    uint64_t v383 = v380 + v382;
    unint64_t v384 = v381 - v382;
    if (v384 >= v384 - 1) {
      --v384;
    }
    v377[8] = v383;
    v377[9] = v384;
  }
  unint64_t v385 = *((unsigned int *)v377 + 22);
  if (v385 > *((_DWORD *)v377 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v377 + 10), v377 + 12, v385, 16);
    LODWORD(v385) = *((_DWORD *)v377 + 22);
  }
  *((_DWORD *)v377 + 22) = v385;
  int64_t v387 = (char *)a1[2];
  unint64_t v386 = a1[3];
  if ((unint64_t)v387 >= v386)
  {
    v389 = (char *)a1[1];
    uint64_t v390 = (v387 - v389) >> 3;
    unint64_t v391 = v390 + 1;
    if ((unint64_t)(v390 + 1) >> 61) {
      goto LABEL_977;
    }
    uint64_t v392 = v386 - (void)v389;
    if (v392 >> 2 > v391) {
      unint64_t v391 = v392 >> 2;
    }
    if ((unint64_t)v392 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v393 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v393 = v391;
    }
    if (v393)
    {
      if (v393 >> 61) {
        goto LABEL_978;
      }
      uint64_t v394 = (char *)operator new(8 * v393);
    }
    else
    {
      uint64_t v394 = 0;
    }
    char v395 = &v394[8 * v390];
    v396 = &v394[8 * v393];
    *(void *)char v395 = v377;
    unint64_t v388 = v395 + 8;
    if (v387 == v389)
    {
      a1[1] = (uint64_t)v395;
      a1[2] = (uint64_t)v388;
      a1[3] = (uint64_t)v396;
    }
    else
    {
      unint64_t v397 = v387 - v389 - 8;
      if (v397 < 0x78
        || &v387[-(v397 & 0xFFFFFFFFFFFFFFF8) - 8] < v395
        && &v394[v387 - v389 - (v397 & 0xFFFFFFFFFFFFFFF8) - 8] < v387)
      {
        goto LABEL_992;
      }
      uint64_t v398 = (v397 >> 3) + 1;
      uint64_t v399 = 8 * (v398 & 0x3FFFFFFFFFFFFFFCLL);
      long long v400 = &v387[-v399];
      v395 -= v399;
      uint64_t v401 = &v394[8 * v390 - 16];
      v402 = v387 - 16;
      uint64_t v403 = v398 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v405 = *((_OWORD *)v402 - 1);
        long long v404 = *(_OWORD *)v402;
        *((_OWORD *)v402 - 1) = 0uLL;
        *(_OWORD *)v402 = 0uLL;
        *((_OWORD *)v401 - 1) = v405;
        *(_OWORD *)uint64_t v401 = v404;
        v401 -= 32;
        v402 -= 32;
        v403 -= 4;
      }
      while (v403);
      int64_t v387 = v400;
      if (v398 != (v398 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_992:
        do
        {
          uint64_t v406 = *((void *)v387 - 1);
          v387 -= 8;
          *(void *)int64_t v387 = 0;
          *((void *)v395 - 1) = v406;
          v395 -= 8;
        }
        while (v387 != v389);
      }
      int64_t v387 = (char *)a1[1];
      unint64_t v407 = (char *)a1[2];
      a1[1] = (uint64_t)v395;
      a1[2] = (uint64_t)v388;
      a1[3] = (uint64_t)v396;
      while (v407 != v387)
      {
        uint64_t v409 = *((void *)v407 - 1);
        v407 -= 8;
        uint64_t v408 = v409;
        *(void *)unint64_t v407 = 0;
        if (v409) {
          (*(void (**)(uint64_t))(*(void *)v408 + 8))(v408);
        }
      }
    }
    if (v387) {
      operator delete(v387);
    }
  }
  else
  {
    *(void *)int64_t v387 = v377;
    unint64_t v388 = v387 + 8;
  }
  a1[2] = (uint64_t)v388;
  uint64_t v410 = *a1;
  char v411 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v852, 1);
  long long v855 = xmmword_1E4FBFC50;
  long long v856 = *(_OWORD *)&off_1E4FBFC60;
  long long v857 = xmmword_1E4FBFC70;
  long long v853 = xmmword_1E4FBFC30;
  long long v854 = *(_OWORD *)&off_1E4FBFC40;
  mlir::Pattern::Pattern((uint64_t)(v411 + 1), (uint64_t)"mps.quantize", 12, v852, v410, &v853, 5uLL);
  *char v411 = &unk_1EC9C83F8;
  if (!v411[9])
  {
    *(void *)&long long v853 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerQuantize]";
    *((void *)&v853 + 1) = 101;
    unint64_t v412 = llvm::StringRef::find((uint64_t *)&v853, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((void *)&v853 + 1) >= v412) {
      unint64_t v413 = v412;
    }
    else {
      unint64_t v413 = *((void *)&v853 + 1);
    }
    uint64_t v414 = v853 + v413;
    unint64_t v415 = *((void *)&v853 + 1) - v413;
    if (*((void *)&v853 + 1) - v413 >= 0x12) {
      uint64_t v416 = 18;
    }
    else {
      uint64_t v416 = *((void *)&v853 + 1) - v413;
    }
    uint64_t v417 = v414 + v416;
    unint64_t v418 = v415 - v416;
    if (v418 >= v418 - 1) {
      --v418;
    }
    v411[8] = v417;
    v411[9] = v418;
  }
  unint64_t v419 = *((unsigned int *)v411 + 22);
  if (v419 > *((_DWORD *)v411 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v411 + 10), v411 + 12, v419, 16);
    LODWORD(v419) = *((_DWORD *)v411 + 22);
  }
  *((_DWORD *)v411 + 22) = v419;
  unint64_t v421 = (char *)a1[2];
  unint64_t v420 = a1[3];
  if ((unint64_t)v421 >= v420)
  {
    uint64_t v423 = (char *)a1[1];
    uint64_t v424 = (v421 - v423) >> 3;
    unint64_t v425 = v424 + 1;
    if ((unint64_t)(v424 + 1) >> 61) {
      goto LABEL_977;
    }
    uint64_t v426 = v420 - (void)v423;
    if (v426 >> 2 > v425) {
      unint64_t v425 = v426 >> 2;
    }
    if ((unint64_t)v426 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v427 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v427 = v425;
    }
    if (v427)
    {
      if (v427 >> 61) {
        goto LABEL_978;
      }
      v428 = (char *)operator new(8 * v427);
    }
    else
    {
      v428 = 0;
    }
    v429 = &v428[8 * v424];
    uint64_t v430 = &v428[8 * v427];
    *(void *)v429 = v411;
    uint64_t v422 = v429 + 8;
    if (v421 == v423)
    {
      a1[1] = (uint64_t)v429;
      a1[2] = (uint64_t)v422;
      a1[3] = (uint64_t)v430;
    }
    else
    {
      unint64_t v431 = v421 - v423 - 8;
      if (v431 < 0x78
        || &v421[-(v431 & 0xFFFFFFFFFFFFFFF8) - 8] < v429
        && &v428[v421 - v423 - (v431 & 0xFFFFFFFFFFFFFFF8) - 8] < v421)
      {
        goto LABEL_993;
      }
      uint64_t v432 = (v431 >> 3) + 1;
      uint64_t v433 = 8 * (v432 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v434 = &v421[-v433];
      v429 -= v433;
      v435 = &v428[8 * v424 - 16];
      uint64_t v436 = v421 - 16;
      uint64_t v437 = v432 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v439 = *((_OWORD *)v436 - 1);
        long long v438 = *(_OWORD *)v436;
        *((_OWORD *)v436 - 1) = 0uLL;
        *(_OWORD *)uint64_t v436 = 0uLL;
        *((_OWORD *)v435 - 1) = v439;
        *(_OWORD *)v435 = v438;
        v435 -= 32;
        v436 -= 32;
        v437 -= 4;
      }
      while (v437);
      unint64_t v421 = v434;
      if (v432 != (v432 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_993:
        do
        {
          uint64_t v440 = *((void *)v421 - 1);
          v421 -= 8;
          *(void *)unint64_t v421 = 0;
          *((void *)v429 - 1) = v440;
          v429 -= 8;
        }
        while (v421 != v423);
      }
      unint64_t v421 = (char *)a1[1];
      v441 = (char *)a1[2];
      a1[1] = (uint64_t)v429;
      a1[2] = (uint64_t)v422;
      a1[3] = (uint64_t)v430;
      while (v441 != v421)
      {
        uint64_t v443 = *((void *)v441 - 1);
        v441 -= 8;
        uint64_t v442 = v443;
        *(void *)v441 = 0;
        if (v443) {
          (*(void (**)(uint64_t))(*(void *)v442 + 8))(v442);
        }
      }
    }
    if (v421) {
      operator delete(v421);
    }
  }
  else
  {
    *(void *)unint64_t v421 = v411;
    uint64_t v422 = v421 + 8;
  }
  a1[2] = (uint64_t)v422;
  uint64_t v444 = *a1;
  unint64_t v445 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v852, 1);
  long long v853 = xmmword_1E4FBFC80;
  long long v854 = *(_OWORD *)&off_1E4FBFC90;
  long long v855 = xmmword_1E4FBFCA0;
  mlir::Pattern::Pattern((uint64_t)(v445 + 1), (uint64_t)"mps.quantize", 12, v852, v444, &v853, 3uLL);
  void *v445 = &unk_1EC9CA0F8;
  if (!v445[9])
  {
    *(void *)&long long v853 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerQuant"
                       "izeWithMPSXQuantDAG]";
    *((void *)&v853 + 1) = 117;
    unint64_t v446 = llvm::StringRef::find((uint64_t *)&v853, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((void *)&v853 + 1) >= v446) {
      unint64_t v447 = v446;
    }
    else {
      unint64_t v447 = *((void *)&v853 + 1);
    }
    uint64_t v448 = v853 + v447;
    unint64_t v449 = *((void *)&v853 + 1) - v447;
    if (*((void *)&v853 + 1) - v447 >= 0x12) {
      uint64_t v450 = 18;
    }
    else {
      uint64_t v450 = *((void *)&v853 + 1) - v447;
    }
    uint64_t v451 = v448 + v450;
    unint64_t v452 = v449 - v450;
    if (v452 >= v452 - 1) {
      --v452;
    }
    v445[8] = v451;
    v445[9] = v452;
  }
  unint64_t v453 = *((unsigned int *)v445 + 22);
  if (v453 > *((_DWORD *)v445 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v445 + 10), v445 + 12, v453, 16);
    LODWORD(v453) = *((_DWORD *)v445 + 22);
  }
  *((_DWORD *)v445 + 22) = v453;
  uint64_t v455 = (char *)a1[2];
  unint64_t v454 = a1[3];
  if ((unint64_t)v455 >= v454)
  {
    v457 = (char *)a1[1];
    uint64_t v458 = (v455 - v457) >> 3;
    unint64_t v459 = v458 + 1;
    if ((unint64_t)(v458 + 1) >> 61) {
      goto LABEL_977;
    }
    uint64_t v460 = v454 - (void)v457;
    if (v460 >> 2 > v459) {
      unint64_t v459 = v460 >> 2;
    }
    if ((unint64_t)v460 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v461 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v461 = v459;
    }
    if (v461)
    {
      if (v461 >> 61) {
        goto LABEL_978;
      }
      v462 = (char *)operator new(8 * v461);
    }
    else
    {
      v462 = 0;
    }
    uint64_t v463 = &v462[8 * v458];
    uint64_t v464 = &v462[8 * v461];
    *(void *)uint64_t v463 = v445;
    uint64_t v456 = v463 + 8;
    if (v455 == v457)
    {
      a1[1] = (uint64_t)v463;
      a1[2] = (uint64_t)v456;
      a1[3] = (uint64_t)v464;
    }
    else
    {
      unint64_t v465 = v455 - v457 - 8;
      if (v465 < 0x78
        || &v455[-(v465 & 0xFFFFFFFFFFFFFFF8) - 8] < v463
        && &v462[v455 - v457 - (v465 & 0xFFFFFFFFFFFFFFF8) - 8] < v455)
      {
        goto LABEL_994;
      }
      uint64_t v466 = (v465 >> 3) + 1;
      uint64_t v467 = 8 * (v466 & 0x3FFFFFFFFFFFFFFCLL);
      char v468 = &v455[-v467];
      v463 -= v467;
      uint64_t v469 = &v462[8 * v458 - 16];
      uint64_t v470 = v455 - 16;
      uint64_t v471 = v466 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v473 = *((_OWORD *)v470 - 1);
        long long v472 = *(_OWORD *)v470;
        *((_OWORD *)v470 - 1) = 0uLL;
        *(_OWORD *)uint64_t v470 = 0uLL;
        *((_OWORD *)v469 - 1) = v473;
        *(_OWORD *)uint64_t v469 = v472;
        v469 -= 32;
        v470 -= 32;
        v471 -= 4;
      }
      while (v471);
      uint64_t v455 = v468;
      if (v466 != (v466 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_994:
        do
        {
          uint64_t v474 = *((void *)v455 - 1);
          v455 -= 8;
          *(void *)uint64_t v455 = 0;
          *((void *)v463 - 1) = v474;
          v463 -= 8;
        }
        while (v455 != v457);
      }
      uint64_t v455 = (char *)a1[1];
      unint64_t v475 = (char *)a1[2];
      a1[1] = (uint64_t)v463;
      a1[2] = (uint64_t)v456;
      a1[3] = (uint64_t)v464;
      while (v475 != v455)
      {
        uint64_t v477 = *((void *)v475 - 1);
        v475 -= 8;
        uint64_t v476 = v477;
        *(void *)unint64_t v475 = 0;
        if (v477) {
          (*(void (**)(uint64_t))(*(void *)v476 + 8))(v476);
        }
      }
    }
    if (v455) {
      operator delete(v455);
    }
  }
  else
  {
    *(void *)uint64_t v455 = v445;
    uint64_t v456 = v455 + 8;
  }
  a1[2] = (uint64_t)v456;
  uint64_t v478 = *a1;
  unint64_t v479 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v852, 1);
  long long v857 = xmmword_1E4FBFCF0;
  long long v858 = *(_OWORD *)&off_1E4FBFD00;
  long long v859 = xmmword_1E4FBFD10;
  long long v860 = *(_OWORD *)&off_1E4FBFD20;
  long long v853 = xmmword_1E4FBFCB0;
  long long v854 = *(_OWORD *)&off_1E4FBFCC0;
  long long v855 = xmmword_1E4FBFCD0;
  long long v856 = *(_OWORD *)&off_1E4FBFCE0;
  mlir::Pattern::Pattern((uint64_t)(v479 + 1), (uint64_t)"mps.reduction_logsumexp", 23, v852, v478, &v853, 8uLL);
  *unint64_t v479 = &unk_1EC9C9D30;
  if (!v479[9])
  {
    *(void *)&long long v853 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerReductionLogSumExp]";
    *((void *)&v853 + 1) = 111;
    unint64_t v480 = llvm::StringRef::find((uint64_t *)&v853, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((void *)&v853 + 1) >= v480) {
      unint64_t v481 = v480;
    }
    else {
      unint64_t v481 = *((void *)&v853 + 1);
    }
    uint64_t v482 = v853 + v481;
    unint64_t v483 = *((void *)&v853 + 1) - v481;
    if (*((void *)&v853 + 1) - v481 >= 0x12) {
      uint64_t v484 = 18;
    }
    else {
      uint64_t v484 = *((void *)&v853 + 1) - v481;
    }
    uint64_t v485 = v482 + v484;
    unint64_t v486 = v483 - v484;
    if (v486 >= v486 - 1) {
      --v486;
    }
    v479[8] = v485;
    v479[9] = v486;
  }
  unint64_t v487 = *((unsigned int *)v479 + 22);
  if (v487 > *((_DWORD *)v479 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v479 + 10), v479 + 12, v487, 16);
    LODWORD(v487) = *((_DWORD *)v479 + 22);
  }
  *((_DWORD *)v479 + 22) = v487;
  v489 = (char *)a1[2];
  unint64_t v488 = a1[3];
  if ((unint64_t)v489 >= v488)
  {
    unint64_t v491 = (char *)a1[1];
    uint64_t v492 = (v489 - v491) >> 3;
    unint64_t v493 = v492 + 1;
    if ((unint64_t)(v492 + 1) >> 61) {
      goto LABEL_977;
    }
    uint64_t v494 = v488 - (void)v491;
    if (v494 >> 2 > v493) {
      unint64_t v493 = v494 >> 2;
    }
    if ((unint64_t)v494 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v495 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v495 = v493;
    }
    if (v495)
    {
      if (v495 >> 61) {
        goto LABEL_978;
      }
      uint64_t v496 = (char *)operator new(8 * v495);
    }
    else
    {
      uint64_t v496 = 0;
    }
    uint64_t v497 = &v496[8 * v492];
    long long v498 = &v496[8 * v495];
    *(void *)uint64_t v497 = v479;
    unint64_t v490 = v497 + 8;
    if (v489 == v491)
    {
      a1[1] = (uint64_t)v497;
      a1[2] = (uint64_t)v490;
      a1[3] = (uint64_t)v498;
    }
    else
    {
      unint64_t v499 = v489 - v491 - 8;
      if (v499 < 0x78
        || &v489[-(v499 & 0xFFFFFFFFFFFFFFF8) - 8] < v497
        && &v496[v489 - v491 - (v499 & 0xFFFFFFFFFFFFFFF8) - 8] < v489)
      {
        goto LABEL_995;
      }
      uint64_t v500 = (v499 >> 3) + 1;
      uint64_t v501 = 8 * (v500 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v502 = &v489[-v501];
      v497 -= v501;
      uint64_t v503 = &v496[8 * v492 - 16];
      uint64_t v504 = v489 - 16;
      uint64_t v505 = v500 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v507 = *((_OWORD *)v504 - 1);
        long long v506 = *(_OWORD *)v504;
        *((_OWORD *)v504 - 1) = 0uLL;
        *(_OWORD *)uint64_t v504 = 0uLL;
        *((_OWORD *)v503 - 1) = v507;
        *(_OWORD *)uint64_t v503 = v506;
        v503 -= 32;
        v504 -= 32;
        v505 -= 4;
      }
      while (v505);
      v489 = v502;
      if (v500 != (v500 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_995:
        do
        {
          uint64_t v508 = *((void *)v489 - 1);
          v489 -= 8;
          *(void *)v489 = 0;
          *((void *)v497 - 1) = v508;
          v497 -= 8;
        }
        while (v489 != v491);
      }
      v489 = (char *)a1[1];
      uint64_t v509 = (char *)a1[2];
      a1[1] = (uint64_t)v497;
      a1[2] = (uint64_t)v490;
      a1[3] = (uint64_t)v498;
      while (v509 != v489)
      {
        uint64_t v511 = *((void *)v509 - 1);
        v509 -= 8;
        uint64_t v510 = v511;
        *(void *)uint64_t v509 = 0;
        if (v511) {
          (*(void (**)(uint64_t))(*(void *)v510 + 8))(v510);
        }
      }
    }
    if (v489) {
      operator delete(v489);
    }
  }
  else
  {
    *(void *)v489 = v479;
    unint64_t v490 = v489 + 8;
  }
  a1[2] = (uint64_t)v490;
  uint64_t v512 = *a1;
  v513 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v852, 1);
  *(void *)&long long v853 = "mps.maximum";
  *((void *)&v853 + 1) = 11;
  mlir::Pattern::Pattern((uint64_t)(v513 + 1), (uint64_t)"mps.relu", 8, v852, v512, &v853, 1uLL);
  void *v513 = &unk_1EC9C7BD8;
  if (!v513[9])
  {
    *(void *)&long long v853 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerRelu]";
    *((void *)&v853 + 1) = 97;
    unint64_t v514 = llvm::StringRef::find((uint64_t *)&v853, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((void *)&v853 + 1) >= v514) {
      unint64_t v515 = v514;
    }
    else {
      unint64_t v515 = *((void *)&v853 + 1);
    }
    uint64_t v516 = v853 + v515;
    unint64_t v517 = *((void *)&v853 + 1) - v515;
    if (*((void *)&v853 + 1) - v515 >= 0x12) {
      uint64_t v518 = 18;
    }
    else {
      uint64_t v518 = *((void *)&v853 + 1) - v515;
    }
    uint64_t v519 = v516 + v518;
    unint64_t v520 = v517 - v518;
    if (v520 >= v520 - 1) {
      --v520;
    }
    v513[8] = v519;
    v513[9] = v520;
  }
  unint64_t v521 = *((unsigned int *)v513 + 22);
  if (v521 > *((_DWORD *)v513 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v513 + 10), v513 + 12, v521, 16);
    LODWORD(v521) = *((_DWORD *)v513 + 22);
  }
  *((_DWORD *)v513 + 22) = v521;
  v523 = (char *)a1[2];
  unint64_t v522 = a1[3];
  if ((unint64_t)v523 >= v522)
  {
    uint64_t v525 = (char *)a1[1];
    uint64_t v526 = (v523 - v525) >> 3;
    unint64_t v527 = v526 + 1;
    if ((unint64_t)(v526 + 1) >> 61) {
      goto LABEL_977;
    }
    uint64_t v528 = v522 - (void)v525;
    if (v528 >> 2 > v527) {
      unint64_t v527 = v528 >> 2;
    }
    if ((unint64_t)v528 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v529 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v529 = v527;
    }
    if (v529)
    {
      if (v529 >> 61) {
        goto LABEL_978;
      }
      uint64_t v530 = (char *)operator new(8 * v529);
    }
    else
    {
      uint64_t v530 = 0;
    }
    long long v531 = &v530[8 * v526];
    long long v532 = &v530[8 * v529];
    *(void *)long long v531 = v513;
    unint64_t v524 = v531 + 8;
    if (v523 == v525)
    {
      a1[1] = (uint64_t)v531;
      a1[2] = (uint64_t)v524;
      a1[3] = (uint64_t)v532;
    }
    else
    {
      unint64_t v533 = v523 - v525 - 8;
      if (v533 < 0x78
        || &v523[-(v533 & 0xFFFFFFFFFFFFFFF8) - 8] < v531
        && &v530[v523 - v525 - (v533 & 0xFFFFFFFFFFFFFFF8) - 8] < v523)
      {
        goto LABEL_996;
      }
      uint64_t v534 = (v533 >> 3) + 1;
      uint64_t v535 = 8 * (v534 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v536 = &v523[-v535];
      v531 -= v535;
      v537 = &v530[8 * v526 - 16];
      unint64_t v538 = v523 - 16;
      uint64_t v539 = v534 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v541 = *((_OWORD *)v538 - 1);
        long long v540 = *(_OWORD *)v538;
        *((_OWORD *)v538 - 1) = 0uLL;
        *(_OWORD *)unint64_t v538 = 0uLL;
        *((_OWORD *)v537 - 1) = v541;
        *(_OWORD *)v537 = v540;
        v537 -= 32;
        v538 -= 32;
        v539 -= 4;
      }
      while (v539);
      v523 = v536;
      if (v534 != (v534 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_996:
        do
        {
          uint64_t v542 = *((void *)v523 - 1);
          v523 -= 8;
          *(void *)v523 = 0;
          *((void *)v531 - 1) = v542;
          v531 -= 8;
        }
        while (v523 != v525);
      }
      v523 = (char *)a1[1];
      v543 = (char *)a1[2];
      a1[1] = (uint64_t)v531;
      a1[2] = (uint64_t)v524;
      a1[3] = (uint64_t)v532;
      while (v543 != v523)
      {
        uint64_t v545 = *((void *)v543 - 1);
        v543 -= 8;
        uint64_t v544 = v545;
        *(void *)v543 = 0;
        if (v545) {
          (*(void (**)(uint64_t))(*(void *)v544 + 8))(v544);
        }
      }
    }
    if (v523) {
      operator delete(v523);
    }
  }
  else
  {
    *(void *)v523 = v513;
    unint64_t v524 = v523 + 8;
  }
  a1[2] = (uint64_t)v524;
  uint64_t v546 = *a1;
  unint64_t v547 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v852, 1);
  long long v853 = xmmword_1E4FBFD30;
  long long v854 = *(_OWORD *)&off_1E4FBFD40;
  mlir::Pattern::Pattern((uint64_t)(v547 + 1), (uint64_t)"mps.relu6", 9, v852, v546, &v853, 2uLL);
  *unint64_t v547 = &unk_1EC9C7E78;
  if (!v547[9])
  {
    *(void *)&long long v853 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerRelu6]";
    *((void *)&v853 + 1) = 98;
    unint64_t v548 = llvm::StringRef::find((uint64_t *)&v853, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((void *)&v853 + 1) >= v548) {
      unint64_t v549 = v548;
    }
    else {
      unint64_t v549 = *((void *)&v853 + 1);
    }
    uint64_t v550 = v853 + v549;
    unint64_t v551 = *((void *)&v853 + 1) - v549;
    if (*((void *)&v853 + 1) - v549 >= 0x12) {
      uint64_t v552 = 18;
    }
    else {
      uint64_t v552 = *((void *)&v853 + 1) - v549;
    }
    uint64_t v553 = v550 + v552;
    unint64_t v554 = v551 - v552;
    if (v554 >= v554 - 1) {
      --v554;
    }
    v547[8] = v553;
    v547[9] = v554;
  }
  unint64_t v555 = *((unsigned int *)v547 + 22);
  if (v555 > *((_DWORD *)v547 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v547 + 10), v547 + 12, v555, 16);
    LODWORD(v555) = *((_DWORD *)v547 + 22);
  }
  *((_DWORD *)v547 + 22) = v555;
  unint64_t v557 = (char *)a1[2];
  unint64_t v556 = a1[3];
  if ((unint64_t)v557 >= v556)
  {
    uint64_t v559 = (char *)a1[1];
    uint64_t v560 = (v557 - v559) >> 3;
    unint64_t v561 = v560 + 1;
    if ((unint64_t)(v560 + 1) >> 61) {
      goto LABEL_977;
    }
    uint64_t v562 = v556 - (void)v559;
    if (v562 >> 2 > v561) {
      unint64_t v561 = v562 >> 2;
    }
    if ((unint64_t)v562 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v563 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v563 = v561;
    }
    if (v563)
    {
      if (v563 >> 61) {
        goto LABEL_978;
      }
      long long v564 = (char *)operator new(8 * v563);
    }
    else
    {
      long long v564 = 0;
    }
    long long v565 = &v564[8 * v560];
    uint64_t v566 = &v564[8 * v563];
    *(void *)long long v565 = v547;
    uint64_t v558 = v565 + 8;
    if (v557 == v559)
    {
      a1[1] = (uint64_t)v565;
      a1[2] = (uint64_t)v558;
      a1[3] = (uint64_t)v566;
    }
    else
    {
      unint64_t v567 = v557 - v559 - 8;
      if (v567 < 0x78
        || &v557[-(v567 & 0xFFFFFFFFFFFFFFF8) - 8] < v565
        && &v564[v557 - v559 - (v567 & 0xFFFFFFFFFFFFFFF8) - 8] < v557)
      {
        goto LABEL_997;
      }
      uint64_t v568 = (v567 >> 3) + 1;
      uint64_t v569 = 8 * (v568 & 0x3FFFFFFFFFFFFFFCLL);
      v570 = &v557[-v569];
      v565 -= v569;
      unint64_t v571 = &v564[8 * v560 - 16];
      v572 = v557 - 16;
      uint64_t v573 = v568 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v575 = *((_OWORD *)v572 - 1);
        long long v574 = *(_OWORD *)v572;
        *((_OWORD *)v572 - 1) = 0uLL;
        *(_OWORD *)v572 = 0uLL;
        *((_OWORD *)v571 - 1) = v575;
        *(_OWORD *)unint64_t v571 = v574;
        v571 -= 32;
        v572 -= 32;
        v573 -= 4;
      }
      while (v573);
      unint64_t v557 = v570;
      if (v568 != (v568 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_997:
        do
        {
          uint64_t v576 = *((void *)v557 - 1);
          v557 -= 8;
          *(void *)unint64_t v557 = 0;
          *((void *)v565 - 1) = v576;
          v565 -= 8;
        }
        while (v557 != v559);
      }
      unint64_t v557 = (char *)a1[1];
      uint64_t v577 = (char *)a1[2];
      a1[1] = (uint64_t)v565;
      a1[2] = (uint64_t)v558;
      a1[3] = (uint64_t)v566;
      while (v577 != v557)
      {
        uint64_t v579 = *((void *)v577 - 1);
        v577 -= 8;
        uint64_t v578 = v579;
        *(void *)uint64_t v577 = 0;
        if (v579) {
          (*(void (**)(uint64_t))(*(void *)v578 + 8))(v578);
        }
      }
    }
    if (v557) {
      operator delete(v557);
    }
  }
  else
  {
    *(void *)unint64_t v557 = v547;
    uint64_t v558 = v557 + 8;
  }
  a1[2] = (uint64_t)v558;
  uint64_t v580 = *a1;
  uint64_t v581 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v852, 1);
  long long v853 = xmmword_1E4FBFD50;
  long long v854 = *(_OWORD *)&off_1E4FBFD60;
  mlir::Pattern::Pattern((uint64_t)(v581 + 1), (uint64_t)"mps.relu_grad", 13, v852, v580, &v853, 2uLL);
  *uint64_t v581 = &unk_1EC9C8438;
  if (!v581[9])
  {
    *(void *)&long long v853 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerReluGrad]";
    *((void *)&v853 + 1) = 101;
    unint64_t v582 = llvm::StringRef::find((uint64_t *)&v853, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((void *)&v853 + 1) >= v582) {
      unint64_t v583 = v582;
    }
    else {
      unint64_t v583 = *((void *)&v853 + 1);
    }
    uint64_t v584 = v853 + v583;
    unint64_t v585 = *((void *)&v853 + 1) - v583;
    if (*((void *)&v853 + 1) - v583 >= 0x12) {
      uint64_t v586 = 18;
    }
    else {
      uint64_t v586 = *((void *)&v853 + 1) - v583;
    }
    uint64_t v587 = v584 + v586;
    unint64_t v588 = v585 - v586;
    if (v588 >= v588 - 1) {
      --v588;
    }
    v581[8] = v587;
    v581[9] = v588;
  }
  unint64_t v589 = *((unsigned int *)v581 + 22);
  if (v589 > *((_DWORD *)v581 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v581 + 10), v581 + 12, v589, 16);
    LODWORD(v589) = *((_DWORD *)v581 + 22);
  }
  *((_DWORD *)v581 + 22) = v589;
  uint64_t v591 = (char *)a1[2];
  unint64_t v590 = a1[3];
  if ((unint64_t)v591 >= v590)
  {
    long long v593 = (char *)a1[1];
    uint64_t v594 = (v591 - v593) >> 3;
    unint64_t v595 = v594 + 1;
    if ((unint64_t)(v594 + 1) >> 61) {
      goto LABEL_977;
    }
    uint64_t v596 = v590 - (void)v593;
    if (v596 >> 2 > v595) {
      unint64_t v595 = v596 >> 2;
    }
    if ((unint64_t)v596 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v597 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v597 = v595;
    }
    if (v597)
    {
      if (v597 >> 61) {
        goto LABEL_978;
      }
      v598 = (char *)operator new(8 * v597);
    }
    else
    {
      v598 = 0;
    }
    long long v599 = &v598[8 * v594];
    uint64_t v600 = &v598[8 * v597];
    *(void *)long long v599 = v581;
    uint64_t v592 = v599 + 8;
    if (v591 == v593)
    {
      a1[1] = (uint64_t)v599;
      a1[2] = (uint64_t)v592;
      a1[3] = (uint64_t)v600;
    }
    else
    {
      unint64_t v601 = v591 - v593 - 8;
      if (v601 < 0x78
        || &v591[-(v601 & 0xFFFFFFFFFFFFFFF8) - 8] < v599
        && &v598[v591 - v593 - (v601 & 0xFFFFFFFFFFFFFFF8) - 8] < v591)
      {
        goto LABEL_998;
      }
      uint64_t v602 = (v601 >> 3) + 1;
      uint64_t v603 = 8 * (v602 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v604 = &v591[-v603];
      v599 -= v603;
      long long v605 = &v598[8 * v594 - 16];
      long long v606 = v591 - 16;
      uint64_t v607 = v602 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v609 = *((_OWORD *)v606 - 1);
        long long v608 = *(_OWORD *)v606;
        *((_OWORD *)v606 - 1) = 0uLL;
        *(_OWORD *)long long v606 = 0uLL;
        *((_OWORD *)v605 - 1) = v609;
        *(_OWORD *)long long v605 = v608;
        v605 -= 32;
        v606 -= 32;
        v607 -= 4;
      }
      while (v607);
      uint64_t v591 = v604;
      if (v602 != (v602 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_998:
        do
        {
          uint64_t v610 = *((void *)v591 - 1);
          v591 -= 8;
          *(void *)uint64_t v591 = 0;
          *((void *)v599 - 1) = v610;
          v599 -= 8;
        }
        while (v591 != v593);
      }
      uint64_t v591 = (char *)a1[1];
      unint64_t v611 = (char *)a1[2];
      a1[1] = (uint64_t)v599;
      a1[2] = (uint64_t)v592;
      a1[3] = (uint64_t)v600;
      while (v611 != v591)
      {
        uint64_t v613 = *((void *)v611 - 1);
        v611 -= 8;
        uint64_t v612 = v613;
        *(void *)unint64_t v611 = 0;
        if (v613) {
          (*(void (**)(uint64_t))(*(void *)v612 + 8))(v612);
        }
      }
    }
    if (v591) {
      operator delete(v591);
    }
  }
  else
  {
    *(void *)uint64_t v591 = v581;
    uint64_t v592 = v591 + 8;
  }
  a1[2] = (uint64_t)v592;
  uint64_t v614 = *a1;
  v615 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v852, 1);
  long long v853 = xmmword_1E4FBFD70;
  long long v854 = *(_OWORD *)&off_1E4FBFD80;
  long long v855 = xmmword_1E4FBFD90;
  mlir::Pattern::Pattern((uint64_t)(v615 + 1), (uint64_t)"mps.sigmoid_gradient", 20, v852, v614, &v853, 3uLL);
  void *v615 = &unk_1EC9C9820;
  if (!v615[9])
  {
    *(void *)&long long v853 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerSigmoidGradient]";
    *((void *)&v853 + 1) = 108;
    unint64_t v616 = llvm::StringRef::find((uint64_t *)&v853, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((void *)&v853 + 1) >= v616) {
      unint64_t v617 = v616;
    }
    else {
      unint64_t v617 = *((void *)&v853 + 1);
    }
    uint64_t v618 = v853 + v617;
    unint64_t v619 = *((void *)&v853 + 1) - v617;
    if (*((void *)&v853 + 1) - v617 >= 0x12) {
      uint64_t v620 = 18;
    }
    else {
      uint64_t v620 = *((void *)&v853 + 1) - v617;
    }
    uint64_t v621 = v618 + v620;
    unint64_t v622 = v619 - v620;
    if (v622 >= v622 - 1) {
      --v622;
    }
    v615[8] = v621;
    v615[9] = v622;
  }
  unint64_t v623 = *((unsigned int *)v615 + 22);
  if (v623 > *((_DWORD *)v615 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v615 + 10), v615 + 12, v623, 16);
    LODWORD(v623) = *((_DWORD *)v615 + 22);
  }
  *((_DWORD *)v615 + 22) = v623;
  uint64_t v625 = (char *)a1[2];
  unint64_t v624 = a1[3];
  if ((unint64_t)v625 >= v624)
  {
    unint64_t v627 = (char *)a1[1];
    uint64_t v628 = (v625 - v627) >> 3;
    unint64_t v629 = v628 + 1;
    if ((unint64_t)(v628 + 1) >> 61) {
      goto LABEL_977;
    }
    uint64_t v630 = v624 - (void)v627;
    if (v630 >> 2 > v629) {
      unint64_t v629 = v630 >> 2;
    }
    if ((unint64_t)v630 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v631 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v631 = v629;
    }
    if (v631)
    {
      if (v631 >> 61) {
        goto LABEL_978;
      }
      uint64_t v632 = (char *)operator new(8 * v631);
    }
    else
    {
      uint64_t v632 = 0;
    }
    uint64_t v633 = &v632[8 * v628];
    v634 = &v632[8 * v631];
    *(void *)uint64_t v633 = v615;
    v626 = v633 + 8;
    if (v625 == v627)
    {
      a1[1] = (uint64_t)v633;
      a1[2] = (uint64_t)v626;
      a1[3] = (uint64_t)v634;
    }
    else
    {
      unint64_t v635 = v625 - v627 - 8;
      if (v635 < 0x78
        || &v625[-(v635 & 0xFFFFFFFFFFFFFFF8) - 8] < v633
        && &v632[v625 - v627 - (v635 & 0xFFFFFFFFFFFFFFF8) - 8] < v625)
      {
        goto LABEL_999;
      }
      uint64_t v636 = (v635 >> 3) + 1;
      uint64_t v637 = 8 * (v636 & 0x3FFFFFFFFFFFFFFCLL);
      v638 = &v625[-v637];
      v633 -= v637;
      v639 = &v632[8 * v628 - 16];
      uint64_t v640 = v625 - 16;
      uint64_t v641 = v636 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v643 = *((_OWORD *)v640 - 1);
        long long v642 = *(_OWORD *)v640;
        *((_OWORD *)v640 - 1) = 0uLL;
        *(_OWORD *)uint64_t v640 = 0uLL;
        *((_OWORD *)v639 - 1) = v643;
        *(_OWORD *)v639 = v642;
        v639 -= 32;
        v640 -= 32;
        v641 -= 4;
      }
      while (v641);
      uint64_t v625 = v638;
      if (v636 != (v636 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_999:
        do
        {
          uint64_t v644 = *((void *)v625 - 1);
          v625 -= 8;
          *(void *)uint64_t v625 = 0;
          *((void *)v633 - 1) = v644;
          v633 -= 8;
        }
        while (v625 != v627);
      }
      uint64_t v625 = (char *)a1[1];
      char v645 = (char *)a1[2];
      a1[1] = (uint64_t)v633;
      a1[2] = (uint64_t)v626;
      a1[3] = (uint64_t)v634;
      while (v645 != v625)
      {
        uint64_t v647 = *((void *)v645 - 1);
        v645 -= 8;
        uint64_t v646 = v647;
        *(void *)char v645 = 0;
        if (v647) {
          (*(void (**)(uint64_t))(*(void *)v646 + 8))(v646);
        }
      }
    }
    if (v625) {
      operator delete(v625);
    }
  }
  else
  {
    *(void *)uint64_t v625 = v615;
    v626 = v625 + 8;
  }
  a1[2] = (uint64_t)v626;
  uint64_t v648 = *a1;
  uint64_t v649 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v852, 1);
  long long v853 = xmmword_1E4FBFDA0;
  long long v854 = *(_OWORD *)&off_1E4FBFDB0;
  mlir::Pattern::Pattern((uint64_t)(v649 + 1), (uint64_t)"mps.sigmoid_gradient_with_sigmoid", 33, v852, v648, &v853, 2uLL);
  *uint64_t v649 = &unk_1EC9CA190;
  if (!v649[9])
  {
    *(void *)&long long v853 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerSigmo"
                       "idGradientWithSigmoid]";
    *((void *)&v853 + 1) = 119;
    unint64_t v650 = llvm::StringRef::find((uint64_t *)&v853, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((void *)&v853 + 1) >= v650) {
      unint64_t v651 = v650;
    }
    else {
      unint64_t v651 = *((void *)&v853 + 1);
    }
    uint64_t v652 = v853 + v651;
    unint64_t v653 = *((void *)&v853 + 1) - v651;
    if (*((void *)&v853 + 1) - v651 >= 0x12) {
      uint64_t v654 = 18;
    }
    else {
      uint64_t v654 = *((void *)&v853 + 1) - v651;
    }
    uint64_t v655 = v652 + v654;
    unint64_t v656 = v653 - v654;
    if (v656 >= v656 - 1) {
      --v656;
    }
    v649[8] = v655;
    v649[9] = v656;
  }
  unint64_t v657 = *((unsigned int *)v649 + 22);
  if (v657 > *((_DWORD *)v649 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v649 + 10), v649 + 12, v657, 16);
    LODWORD(v657) = *((_DWORD *)v649 + 22);
  }
  *((_DWORD *)v649 + 22) = v657;
  unint64_t v659 = (char *)a1[2];
  unint64_t v658 = a1[3];
  if ((unint64_t)v659 >= v658)
  {
    char v661 = (char *)a1[1];
    uint64_t v662 = (v659 - v661) >> 3;
    unint64_t v663 = v662 + 1;
    if ((unint64_t)(v662 + 1) >> 61) {
      goto LABEL_977;
    }
    uint64_t v664 = v658 - (void)v661;
    if (v664 >> 2 > v663) {
      unint64_t v663 = v664 >> 2;
    }
    if ((unint64_t)v664 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v665 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v665 = v663;
    }
    if (v665)
    {
      if (v665 >> 61) {
        goto LABEL_978;
      }
      v666 = (char *)operator new(8 * v665);
    }
    else
    {
      v666 = 0;
    }
    unint64_t v667 = &v666[8 * v662];
    v668 = &v666[8 * v665];
    *(void *)unint64_t v667 = v649;
    v660 = v667 + 8;
    if (v659 == v661)
    {
      a1[1] = (uint64_t)v667;
      a1[2] = (uint64_t)v660;
      a1[3] = (uint64_t)v668;
    }
    else
    {
      unint64_t v669 = v659 - v661 - 8;
      if (v669 < 0x78
        || &v659[-(v669 & 0xFFFFFFFFFFFFFFF8) - 8] < v667
        && &v666[v659 - v661 - (v669 & 0xFFFFFFFFFFFFFFF8) - 8] < v659)
      {
        goto LABEL_1000;
      }
      uint64_t v670 = (v669 >> 3) + 1;
      uint64_t v671 = 8 * (v670 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v672 = &v659[-v671];
      v667 -= v671;
      uint64_t v673 = &v666[8 * v662 - 16];
      v674 = v659 - 16;
      uint64_t v675 = v670 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v677 = *((_OWORD *)v674 - 1);
        long long v676 = *(_OWORD *)v674;
        *((_OWORD *)v674 - 1) = 0uLL;
        *(_OWORD *)v674 = 0uLL;
        *((_OWORD *)v673 - 1) = v677;
        *(_OWORD *)uint64_t v673 = v676;
        v673 -= 32;
        v674 -= 32;
        v675 -= 4;
      }
      while (v675);
      unint64_t v659 = v672;
      if (v670 != (v670 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1000:
        do
        {
          uint64_t v678 = *((void *)v659 - 1);
          v659 -= 8;
          *(void *)unint64_t v659 = 0;
          *((void *)v667 - 1) = v678;
          v667 -= 8;
        }
        while (v659 != v661);
      }
      unint64_t v659 = (char *)a1[1];
      v679 = (char *)a1[2];
      a1[1] = (uint64_t)v667;
      a1[2] = (uint64_t)v660;
      a1[3] = (uint64_t)v668;
      while (v679 != v659)
      {
        uint64_t v681 = *((void *)v679 - 1);
        v679 -= 8;
        uint64_t v680 = v681;
        *(void *)v679 = 0;
        if (v681) {
          (*(void (**)(uint64_t))(*(void *)v680 + 8))(v680);
        }
      }
    }
    if (v659) {
      operator delete(v659);
    }
  }
  else
  {
    *(void *)unint64_t v659 = v649;
    v660 = v659 + 8;
  }
  a1[2] = (uint64_t)v660;
  uint64_t v682 = *a1;
  unint64_t v683 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v852, 1);
  long long v853 = xmmword_1E4FBFDC0;
  long long v854 = *(_OWORD *)&off_1E4FBFDD0;
  long long v855 = xmmword_1E4FBFDE0;
  long long v856 = *(_OWORD *)&off_1E4FBFDF0;
  mlir::Pattern::Pattern((uint64_t)(v683 + 1), (uint64_t)"mps.sigmoid_hard", 16, v852, v682, &v853, 4uLL);
  *unint64_t v683 = &unk_1EC9C8C70;
  if (!v683[9])
  {
    *(void *)&long long v853 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerSigmoidHard]";
    *((void *)&v853 + 1) = 104;
    unint64_t v684 = llvm::StringRef::find((uint64_t *)&v853, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((void *)&v853 + 1) >= v684) {
      unint64_t v685 = v684;
    }
    else {
      unint64_t v685 = *((void *)&v853 + 1);
    }
    uint64_t v686 = v853 + v685;
    unint64_t v687 = *((void *)&v853 + 1) - v685;
    if (*((void *)&v853 + 1) - v685 >= 0x12) {
      uint64_t v688 = 18;
    }
    else {
      uint64_t v688 = *((void *)&v853 + 1) - v685;
    }
    uint64_t v689 = v686 + v688;
    unint64_t v690 = v687 - v688;
    if (v690 >= v690 - 1) {
      --v690;
    }
    v683[8] = v689;
    v683[9] = v690;
  }
  unint64_t v691 = *((unsigned int *)v683 + 22);
  if (v691 > *((_DWORD *)v683 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v683 + 10), v683 + 12, v691, 16);
    LODWORD(v691) = *((_DWORD *)v683 + 22);
  }
  *((_DWORD *)v683 + 22) = v691;
  v693 = (char *)a1[2];
  unint64_t v692 = a1[3];
  if ((unint64_t)v693 >= v692)
  {
    v695 = (char *)a1[1];
    uint64_t v696 = (v693 - v695) >> 3;
    unint64_t v697 = v696 + 1;
    if ((unint64_t)(v696 + 1) >> 61) {
      goto LABEL_977;
    }
    uint64_t v698 = v692 - (void)v695;
    if (v698 >> 2 > v697) {
      unint64_t v697 = v698 >> 2;
    }
    if ((unint64_t)v698 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v699 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v699 = v697;
    }
    if (v699)
    {
      if (v699 >> 61) {
        goto LABEL_978;
      }
      unint64_t v700 = (char *)operator new(8 * v699);
    }
    else
    {
      unint64_t v700 = 0;
    }
    v701 = &v700[8 * v696];
    char v702 = &v700[8 * v699];
    *(void *)v701 = v683;
    char v694 = v701 + 8;
    if (v693 == v695)
    {
      a1[1] = (uint64_t)v701;
      a1[2] = (uint64_t)v694;
      a1[3] = (uint64_t)v702;
    }
    else
    {
      unint64_t v703 = v693 - v695 - 8;
      if (v703 < 0x78
        || &v693[-(v703 & 0xFFFFFFFFFFFFFFF8) - 8] < v701
        && &v700[v693 - v695 - (v703 & 0xFFFFFFFFFFFFFFF8) - 8] < v693)
      {
        goto LABEL_1001;
      }
      uint64_t v704 = (v703 >> 3) + 1;
      uint64_t v705 = 8 * (v704 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v706 = &v693[-v705];
      v701 -= v705;
      v707 = &v700[8 * v696 - 16];
      unint64_t v708 = v693 - 16;
      uint64_t v709 = v704 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v711 = *((_OWORD *)v708 - 1);
        long long v710 = *(_OWORD *)v708;
        *((_OWORD *)v708 - 1) = 0uLL;
        *(_OWORD *)unint64_t v708 = 0uLL;
        *((_OWORD *)v707 - 1) = v711;
        *(_OWORD *)v707 = v710;
        v707 -= 32;
        v708 -= 32;
        v709 -= 4;
      }
      while (v709);
      v693 = v706;
      if (v704 != (v704 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1001:
        do
        {
          uint64_t v712 = *((void *)v693 - 1);
          v693 -= 8;
          *(void *)v693 = 0;
          *((void *)v701 - 1) = v712;
          v701 -= 8;
        }
        while (v693 != v695);
      }
      v693 = (char *)a1[1];
      uint64_t v713 = (char *)a1[2];
      a1[1] = (uint64_t)v701;
      a1[2] = (uint64_t)v694;
      a1[3] = (uint64_t)v702;
      while (v713 != v693)
      {
        uint64_t v715 = *((void *)v713 - 1);
        v713 -= 8;
        uint64_t v714 = v715;
        *(void *)uint64_t v713 = 0;
        if (v715) {
          (*(void (**)(uint64_t))(*(void *)v714 + 8))(v714);
        }
      }
    }
    if (v693) {
      operator delete(v693);
    }
  }
  else
  {
    *(void *)v693 = v683;
    char v694 = v693 + 8;
  }
  a1[2] = (uint64_t)v694;
  uint64_t v716 = *a1;
  v717 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v852, 1);
  long long v855 = xmmword_1E4FBFE20;
  long long v856 = *(_OWORD *)&off_1E4FBFE30;
  long long v857 = xmmword_1E4FBFE40;
  long long v853 = xmmword_1E4FBFE00;
  long long v854 = *(_OWORD *)&off_1E4FBFE10;
  mlir::Pattern::Pattern((uint64_t)(v717 + 1), (uint64_t)"mps.softmax", 11, v852, v716, &v853, 5uLL);
  void *v717 = &unk_1EC9C8220;
  if (!v717[9])
  {
    *(void *)&long long v853 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerSoftmax]";
    *((void *)&v853 + 1) = 100;
    unint64_t v718 = llvm::StringRef::find((uint64_t *)&v853, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((void *)&v853 + 1) >= v718) {
      unint64_t v719 = v718;
    }
    else {
      unint64_t v719 = *((void *)&v853 + 1);
    }
    uint64_t v720 = v853 + v719;
    unint64_t v721 = *((void *)&v853 + 1) - v719;
    if (*((void *)&v853 + 1) - v719 >= 0x12) {
      uint64_t v722 = 18;
    }
    else {
      uint64_t v722 = *((void *)&v853 + 1) - v719;
    }
    uint64_t v723 = v720 + v722;
    unint64_t v724 = v721 - v722;
    if (v724 >= v724 - 1) {
      --v724;
    }
    v717[8] = v723;
    v717[9] = v724;
  }
  unint64_t v725 = *((unsigned int *)v717 + 22);
  if (v725 > *((_DWORD *)v717 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v717 + 10), v717 + 12, v725, 16);
    LODWORD(v725) = *((_DWORD *)v717 + 22);
  }
  *((_DWORD *)v717 + 22) = v725;
  char v727 = (char *)a1[2];
  unint64_t v726 = a1[3];
  if ((unint64_t)v727 >= v726)
  {
    v729 = (char *)a1[1];
    uint64_t v730 = (v727 - v729) >> 3;
    unint64_t v731 = v730 + 1;
    if ((unint64_t)(v730 + 1) >> 61) {
      goto LABEL_977;
    }
    uint64_t v732 = v726 - (void)v729;
    if (v732 >> 2 > v731) {
      unint64_t v731 = v732 >> 2;
    }
    if ((unint64_t)v732 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v733 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v733 = v731;
    }
    if (v733)
    {
      if (v733 >> 61) {
        goto LABEL_978;
      }
      v734 = (char *)operator new(8 * v733);
    }
    else
    {
      v734 = 0;
    }
    char v735 = &v734[8 * v730];
    v736 = &v734[8 * v733];
    *(void *)char v735 = v717;
    v728 = v735 + 8;
    if (v727 == v729)
    {
      a1[1] = (uint64_t)v735;
      a1[2] = (uint64_t)v728;
      a1[3] = (uint64_t)v736;
    }
    else
    {
      unint64_t v737 = v727 - v729 - 8;
      if (v737 < 0x78
        || &v727[-(v737 & 0xFFFFFFFFFFFFFFF8) - 8] < v735
        && &v734[v727 - v729 - (v737 & 0xFFFFFFFFFFFFFFF8) - 8] < v727)
      {
        goto LABEL_1002;
      }
      uint64_t v738 = (v737 >> 3) + 1;
      uint64_t v739 = 8 * (v738 & 0x3FFFFFFFFFFFFFFCLL);
      v740 = &v727[-v739];
      v735 -= v739;
      unint64_t v741 = &v734[8 * v730 - 16];
      v742 = v727 - 16;
      uint64_t v743 = v738 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v745 = *((_OWORD *)v742 - 1);
        long long v744 = *(_OWORD *)v742;
        *((_OWORD *)v742 - 1) = 0uLL;
        *(_OWORD *)v742 = 0uLL;
        *((_OWORD *)v741 - 1) = v745;
        *(_OWORD *)unint64_t v741 = v744;
        v741 -= 32;
        v742 -= 32;
        v743 -= 4;
      }
      while (v743);
      char v727 = v740;
      if (v738 != (v738 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1002:
        do
        {
          uint64_t v746 = *((void *)v727 - 1);
          v727 -= 8;
          *(void *)char v727 = 0;
          *((void *)v735 - 1) = v746;
          v735 -= 8;
        }
        while (v727 != v729);
      }
      char v727 = (char *)a1[1];
      uint64_t v747 = (char *)a1[2];
      a1[1] = (uint64_t)v735;
      a1[2] = (uint64_t)v728;
      a1[3] = (uint64_t)v736;
      while (v747 != v727)
      {
        uint64_t v749 = *((void *)v747 - 1);
        v747 -= 8;
        uint64_t v748 = v749;
        *(void *)uint64_t v747 = 0;
        if (v749) {
          (*(void (**)(uint64_t))(*(void *)v748 + 8))(v748);
        }
      }
    }
    if (v727) {
      operator delete(v727);
    }
  }
  else
  {
    *(void *)char v727 = v717;
    v728 = v727 + 8;
  }
  a1[2] = (uint64_t)v728;
  uint64_t v750 = *a1;
  char v751 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v852, 1);
  long long v853 = xmmword_1E4FBFE50;
  long long v854 = *(_OWORD *)&off_1E4FBFE60;
  long long v855 = xmmword_1E4FBFE70;
  mlir::Pattern::Pattern((uint64_t)(v751 + 1), (uint64_t)"mps.softsign", 12, v852, v750, &v853, 3uLL);
  *char v751 = &unk_1EC9C8478;
  if (!v751[9])
  {
    *(void *)&long long v853 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerSoftsign]";
    *((void *)&v853 + 1) = 101;
    unint64_t v752 = llvm::StringRef::find((uint64_t *)&v853, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((void *)&v853 + 1) >= v752) {
      unint64_t v753 = v752;
    }
    else {
      unint64_t v753 = *((void *)&v853 + 1);
    }
    uint64_t v754 = v853 + v753;
    unint64_t v755 = *((void *)&v853 + 1) - v753;
    if (*((void *)&v853 + 1) - v753 >= 0x12) {
      uint64_t v756 = 18;
    }
    else {
      uint64_t v756 = *((void *)&v853 + 1) - v753;
    }
    uint64_t v757 = v754 + v756;
    unint64_t v758 = v755 - v756;
    if (v758 >= v758 - 1) {
      --v758;
    }
    v751[8] = v757;
    v751[9] = v758;
  }
  unint64_t v759 = *((unsigned int *)v751 + 22);
  if (v759 > *((_DWORD *)v751 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v751 + 10), v751 + 12, v759, 16);
    LODWORD(v759) = *((_DWORD *)v751 + 22);
  }
  *((_DWORD *)v751 + 22) = v759;
  v761 = (char *)a1[2];
  unint64_t v760 = a1[3];
  if ((unint64_t)v761 >= v760)
  {
    uint64_t v763 = (char *)a1[1];
    uint64_t v764 = (v761 - v763) >> 3;
    unint64_t v765 = v764 + 1;
    if ((unint64_t)(v764 + 1) >> 61) {
      goto LABEL_977;
    }
    uint64_t v766 = v760 - (void)v763;
    if (v766 >> 2 > v765) {
      unint64_t v765 = v766 >> 2;
    }
    if ((unint64_t)v766 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v767 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v767 = v765;
    }
    if (v767)
    {
      if (v767 >> 61) {
        goto LABEL_978;
      }
      v768 = (char *)operator new(8 * v767);
    }
    else
    {
      v768 = 0;
    }
    v769 = &v768[8 * v764];
    uint64_t v770 = &v768[8 * v767];
    *(void *)v769 = v751;
    uint64_t v762 = v769 + 8;
    if (v761 == v763)
    {
      a1[1] = (uint64_t)v769;
      a1[2] = (uint64_t)v762;
      a1[3] = (uint64_t)v770;
    }
    else
    {
      unint64_t v771 = v761 - v763 - 8;
      if (v771 < 0x78
        || &v761[-(v771 & 0xFFFFFFFFFFFFFFF8) - 8] < v769
        && &v768[v761 - v763 - (v771 & 0xFFFFFFFFFFFFFFF8) - 8] < v761)
      {
        goto LABEL_1003;
      }
      uint64_t v772 = (v771 >> 3) + 1;
      uint64_t v773 = 8 * (v772 & 0x3FFFFFFFFFFFFFFCLL);
      v774 = &v761[-v773];
      v769 -= v773;
      char v775 = &v768[8 * v764 - 16];
      v776 = v761 - 16;
      uint64_t v777 = v772 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v779 = *((_OWORD *)v776 - 1);
        long long v778 = *(_OWORD *)v776;
        *((_OWORD *)v776 - 1) = 0uLL;
        *(_OWORD *)v776 = 0uLL;
        *((_OWORD *)v775 - 1) = v779;
        *(_OWORD *)char v775 = v778;
        v775 -= 32;
        v776 -= 32;
        v777 -= 4;
      }
      while (v777);
      v761 = v774;
      if (v772 != (v772 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1003:
        do
        {
          uint64_t v780 = *((void *)v761 - 1);
          v761 -= 8;
          *(void *)v761 = 0;
          *((void *)v769 - 1) = v780;
          v769 -= 8;
        }
        while (v761 != v763);
      }
      v761 = (char *)a1[1];
      unint64_t v781 = (char *)a1[2];
      a1[1] = (uint64_t)v769;
      a1[2] = (uint64_t)v762;
      a1[3] = (uint64_t)v770;
      while (v781 != v761)
      {
        uint64_t v783 = *((void *)v781 - 1);
        v781 -= 8;
        uint64_t v782 = v783;
        *(void *)unint64_t v781 = 0;
        if (v783) {
          (*(void (**)(uint64_t))(*(void *)v782 + 8))(v782);
        }
      }
    }
    if (v761) {
      operator delete(v761);
    }
  }
  else
  {
    *(void *)v761 = v751;
    uint64_t v762 = v761 + 8;
  }
  a1[2] = (uint64_t)v762;
  uint64_t v784 = *a1;
  v785 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v852, 1);
  long long v853 = xmmword_1E4FBFE80;
  long long v854 = *(_OWORD *)&off_1E4FBFE90;
  mlir::Pattern::Pattern((uint64_t)(v785 + 1), (uint64_t)"mps.swish", 9, v852, v784, &v853, 2uLL);
  void *v785 = &unk_1EC9C7EB8;
  if (!v785[9])
  {
    *(void *)&long long v853 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerSwish]";
    *((void *)&v853 + 1) = 98;
    unint64_t v786 = llvm::StringRef::find((uint64_t *)&v853, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((void *)&v853 + 1) >= v786) {
      unint64_t v787 = v786;
    }
    else {
      unint64_t v787 = *((void *)&v853 + 1);
    }
    uint64_t v788 = v853 + v787;
    unint64_t v789 = *((void *)&v853 + 1) - v787;
    if (*((void *)&v853 + 1) - v787 >= 0x12) {
      uint64_t v790 = 18;
    }
    else {
      uint64_t v790 = *((void *)&v853 + 1) - v787;
    }
    uint64_t v791 = v788 + v790;
    unint64_t v792 = v789 - v790;
    if (v792 >= v792 - 1) {
      --v792;
    }
    v785[8] = v791;
    v785[9] = v792;
  }
  unint64_t v793 = *((unsigned int *)v785 + 22);
  if (v793 > *((_DWORD *)v785 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v785 + 10), v785 + 12, v793, 16);
    LODWORD(v793) = *((_DWORD *)v785 + 22);
  }
  *((_DWORD *)v785 + 22) = v793;
  uint64_t v795 = (char *)a1[2];
  unint64_t v794 = a1[3];
  if ((unint64_t)v795 >= v794)
  {
    unint64_t v797 = (char *)a1[1];
    uint64_t v798 = (v795 - v797) >> 3;
    unint64_t v799 = v798 + 1;
    if ((unint64_t)(v798 + 1) >> 61) {
      goto LABEL_977;
    }
    uint64_t v800 = v794 - (void)v797;
    if (v800 >> 2 > v799) {
      unint64_t v799 = v800 >> 2;
    }
    if ((unint64_t)v800 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v801 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v801 = v799;
    }
    if (v801)
    {
      if (v801 >> 61) {
        goto LABEL_978;
      }
      uint64_t v802 = (char *)operator new(8 * v801);
    }
    else
    {
      uint64_t v802 = 0;
    }
    uint64_t v803 = &v802[8 * v798];
    v804 = &v802[8 * v801];
    *(void *)uint64_t v803 = v785;
    v796 = v803 + 8;
    if (v795 == v797)
    {
      a1[1] = (uint64_t)v803;
      a1[2] = (uint64_t)v796;
      a1[3] = (uint64_t)v804;
    }
    else
    {
      unint64_t v805 = v795 - v797 - 8;
      if (v805 < 0x78
        || &v795[-(v805 & 0xFFFFFFFFFFFFFFF8) - 8] < v803
        && &v802[v795 - v797 - (v805 & 0xFFFFFFFFFFFFFFF8) - 8] < v795)
      {
        goto LABEL_1004;
      }
      uint64_t v806 = (v805 >> 3) + 1;
      uint64_t v807 = 8 * (v806 & 0x3FFFFFFFFFFFFFFCLL);
      char v808 = &v795[-v807];
      v803 -= v807;
      v809 = &v802[8 * v798 - 16];
      v810 = v795 - 16;
      uint64_t v811 = v806 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v813 = *((_OWORD *)v810 - 1);
        long long v812 = *(_OWORD *)v810;
        *((_OWORD *)v810 - 1) = 0uLL;
        *(_OWORD *)v810 = 0uLL;
        *((_OWORD *)v809 - 1) = v813;
        *(_OWORD *)v809 = v812;
        v809 -= 32;
        v810 -= 32;
        v811 -= 4;
      }
      while (v811);
      uint64_t v795 = v808;
      if (v806 != (v806 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1004:
        do
        {
          uint64_t v814 = *((void *)v795 - 1);
          v795 -= 8;
          *(void *)uint64_t v795 = 0;
          *((void *)v803 - 1) = v814;
          v803 -= 8;
        }
        while (v795 != v797);
      }
      uint64_t v795 = (char *)a1[1];
      v815 = (char *)a1[2];
      a1[1] = (uint64_t)v803;
      a1[2] = (uint64_t)v796;
      a1[3] = (uint64_t)v804;
      while (v815 != v795)
      {
        uint64_t v817 = *((void *)v815 - 1);
        v815 -= 8;
        uint64_t v816 = v817;
        *(void *)v815 = 0;
        if (v817) {
          (*(void (**)(uint64_t))(*(void *)v816 + 8))(v816);
        }
      }
    }
    if (v795) {
      operator delete(v795);
    }
  }
  else
  {
    *(void *)uint64_t v795 = v785;
    v796 = v795 + 8;
  }
  a1[2] = (uint64_t)v796;
  uint64_t v818 = *a1;
  uint64_t v819 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v852, 1);
  long long v853 = xmmword_1E4FBFEA0;
  long long v854 = *(_OWORD *)&off_1E4FBFEB0;
  long long v855 = xmmword_1E4FBFEC0;
  long long v856 = *(_OWORD *)&off_1E4FBFED0;
  mlir::Pattern::Pattern((uint64_t)(v819 + 1), (uint64_t)"mps.truncate", 12, v852, v818, &v853, 4uLL);
  *uint64_t v819 = &unk_1EC9C84B8;
  if (!v819[9])
  {
    *(void *)&long long v853 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerTruncate]";
    *((void *)&v853 + 1) = 101;
    unint64_t v820 = llvm::StringRef::find((uint64_t *)&v853, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((void *)&v853 + 1) >= v820) {
      unint64_t v821 = v820;
    }
    else {
      unint64_t v821 = *((void *)&v853 + 1);
    }
    uint64_t v822 = v853 + v821;
    unint64_t v823 = *((void *)&v853 + 1) - v821;
    if (*((void *)&v853 + 1) - v821 >= 0x12) {
      uint64_t v824 = 18;
    }
    else {
      uint64_t v824 = *((void *)&v853 + 1) - v821;
    }
    uint64_t v825 = v822 + v824;
    unint64_t v826 = v823 - v824;
    if (v826 >= v826 - 1) {
      --v826;
    }
    v819[8] = v825;
    v819[9] = v826;
  }
  unint64_t v827 = *((unsigned int *)v819 + 22);
  if (v827 > *((_DWORD *)v819 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v819 + 10), v819 + 12, v827, 16);
    LODWORD(v827) = *((_DWORD *)v819 + 22);
  }
  *((_DWORD *)v819 + 22) = v827;
  v829 = (char *)a1[2];
  unint64_t v828 = a1[3];
  if ((unint64_t)v829 < v828)
  {
    *(void *)v829 = v819;
    unint64_t v830 = v829 + 8;
    goto LABEL_976;
  }
  v831 = (char *)a1[1];
  uint64_t v832 = (v829 - v831) >> 3;
  unint64_t v833 = v832 + 1;
  if ((unint64_t)(v832 + 1) >> 61) {
LABEL_977:
  }
    abort();
  uint64_t v834 = v828 - (void)v831;
  if (v834 >> 2 > v833) {
    unint64_t v833 = v834 >> 2;
  }
  if ((unint64_t)v834 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v835 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v835 = v833;
  }
  if (!v835)
  {
    uint64_t v836 = 0;
    goto LABEL_961;
  }
  if (v835 >> 61) {
LABEL_978:
  }
    std::__throw_bad_array_new_length[abi:nn180100]();
  uint64_t v836 = (char *)operator new(8 * v835);
LABEL_961:
  v837 = &v836[8 * v832];
  unint64_t v838 = &v836[8 * v835];
  *(void *)v837 = v819;
  unint64_t v830 = v837 + 8;
  if (v829 == v831)
  {
    a1[1] = (uint64_t)v837;
    a1[2] = (uint64_t)v830;
    a1[3] = (uint64_t)v838;
  }
  else
  {
    unint64_t v839 = v829 - v831 - 8;
    if (v839 < 0x78
      || &v829[-(v839 & 0xFFFFFFFFFFFFFFF8) - 8] < v837
      && &v836[v829 - v831 - (v839 & 0xFFFFFFFFFFFFFFF8) - 8] < v829)
    {
      goto LABEL_1005;
    }
    uint64_t v840 = (v839 >> 3) + 1;
    uint64_t v841 = 8 * (v840 & 0x3FFFFFFFFFFFFFFCLL);
    v842 = &v829[-v841];
    v837 -= v841;
    uint64_t v843 = &v836[8 * v832 - 16];
    uint64_t v844 = v829 - 16;
    uint64_t v845 = v840 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v847 = *((_OWORD *)v844 - 1);
      long long v846 = *(_OWORD *)v844;
      *((_OWORD *)v844 - 1) = 0uLL;
      *(_OWORD *)uint64_t v844 = 0uLL;
      *((_OWORD *)v843 - 1) = v847;
      *(_OWORD *)uint64_t v843 = v846;
      v843 -= 32;
      v844 -= 32;
      v845 -= 4;
    }
    while (v845);
    v829 = v842;
    if (v840 != (v840 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_1005:
      do
      {
        uint64_t v848 = *((void *)v829 - 1);
        v829 -= 8;
        *(void *)v829 = 0;
        *((void *)v837 - 1) = v848;
        v837 -= 8;
      }
      while (v829 != v831);
    }
    v829 = (char *)a1[1];
    v849 = (char *)a1[2];
    a1[1] = (uint64_t)v837;
    a1[2] = (uint64_t)v830;
    a1[3] = (uint64_t)v838;
    while (v849 != v829)
    {
      uint64_t v851 = *((void *)v849 - 1);
      v849 -= 8;
      uint64_t v850 = v851;
      *(void *)v849 = 0;
      if (v851) {
        (*(void (**)(uint64_t))(*(void *)v850 + 8))(v850);
      }
    }
  }
  if (v829) {
    operator delete(v829);
  }
LABEL_976:
  a1[2] = (uint64_t)v830;
}

mlir::mps::MPSConversionTarget *mlir::mps::MPSConversionTarget::MPSConversionTarget(mlir::mps::MPSConversionTarget *this, mlir::MLIRContext *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((_DWORD *)this + 6) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 4) = (char *)this + 48;
  *((void *)this + 5) = 0;
  *((void *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((void *)this + 11) = 0x1000000000;
  *((void *)this + 12) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0x2800000000;
  *((void *)this + 18) = 0;
  *((void *)this + 19) = a2;
  *(void *)this = &unk_1EC9CA718;
  unint64_t v5 = "mps";
  uint64_t v6 = 3;
  mlir::ConversionTarget::setDialectAction((uint64_t *)this, (uint64_t)&v5, 1, 0);
  unint64_t v5 = "mpsx";
  uint64_t v6 = 4;
  mlir::ConversionTarget::setDialectAction((uint64_t *)this, (uint64_t)&v5, 1, 0);
  v4[0] = &v5;
  unint64_t v5 = "scf";
  uint64_t v6 = 3;
  v4[1] = (void *)0x200000001;
  mlir::ConversionTarget::setDialectAction((uint64_t *)this, (uint64_t)&v5, 1, 0);
  mlir::OperationName::OperationName(v4, "tensor.extract", 14, *((void *)this + 19));
  mlir::ConversionTarget::setOpAction((uint64_t)this, (uint64_t)v4[0], 0);
  mlir::OperationName::OperationName(v4, "func.func", 9, *((void *)this + 19));
  mlir::ConversionTarget::setOpAction((uint64_t)this, (uint64_t)v4[0], 0);
  mlir::OperationName::OperationName(v4, "builtin.module", 14, *((void *)this + 19));
  mlir::ConversionTarget::setOpAction((uint64_t)this, (uint64_t)v4[0], 0);
  mlir::OperationName::OperationName(v4, "func.return", 11, *((void *)this + 19));
  mlir::ConversionTarget::setOpAction((uint64_t)this, (uint64_t)v4[0], 0);
  mlir::OperationName::OperationName(v4, "tensor.cast", 11, *((void *)this + 19));
  mlir::ConversionTarget::setOpAction((uint64_t)this, (uint64_t)v4[0], 0);
  mlir::OperationName::OperationName(v4, "tensor.from_elements", 20, *((void *)this + 19));
  mlir::ConversionTarget::setOpAction((uint64_t)this, (uint64_t)v4[0], 0);
  mlir::OperationName::OperationName(v4, "placement.region_call", 21, *((void *)this + 19));
  mlir::ConversionTarget::setOpAction((uint64_t)this, (uint64_t)v4[0], 0);
  mlir::OperationName::OperationName(v4, "placement.tensor_to_memref", 26, *((void *)this + 19));
  mlir::ConversionTarget::setOpAction((uint64_t)this, (uint64_t)v4[0], 0);
  mlir::OperationName::OperationName(v4, "placement.memref_to_tensor", 26, *((void *)this + 19));
  mlir::ConversionTarget::setOpAction((uint64_t)this, (uint64_t)v4[0], 0);
  return this;
}

void mlir::mps::MPSConversionTarget::~MPSConversionTarget(mlir::mps::MPSConversionTarget *this)
{
}

void sub_180585B74(void *__p)
{
  operator delete(__p);
}

void mlir::ConversionTarget::~ConversionTarget(mlir::ConversionTarget *this)
{
}

{
  char *v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  llvm *v6;
  llvm *v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;

  *(void *)this = &unk_1EC9AA748;
  uint64_t v2 = (char *)this + 120;
  uint64_t v3 = (char *)*((void *)this + 18);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  llvm::StringMap<std::function<std::optional<BOOL> ()(mlir::Operation *)>,llvm::MallocAllocator>::~StringMap((uint64_t)this + 96);
  if (*((_DWORD *)this + 21))
  {
    unint64_t v4 = *((unsigned int *)this + 20);
    if (v4)
    {
      unint64_t v5 = 0;
      do
      {
        uint64_t v6 = *(llvm **)(*((void *)this + 9) + v5);
        if (v6 != (llvm *)-8 && v6 != 0) {
          llvm::deallocate_buffer(v6, (void *)(*(void *)v6 + 17));
        }
        v5 += 8;
      }
      while (8 * v4 != v5);
    }
  }
  free(*((void **)this + 9));
  uint64_t v8 = (llvm *)*((void *)this + 6);
  uint64_t v9 = *((unsigned int *)this + 16);
  if (v9)
  {
    unint64_t v10 = (void *)((char *)v8 + 8);
    unint64_t v11 = 40 * v9;
    do
    {
      if ((*(void *)v8 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        unint64_t v12 = (void *)*((void *)v8 + 4);
        if ((void *)((char *)v8 + 8) == v12)
        {
          (*(void (**)(void *))(*((void *)v8 + 1) + 32))((void *)v8 + 1);
        }
        else if (v12)
        {
          (*(void (**)(void *))(*v12 + 40))(v12);
        }
      }
      uint64_t v8 = (llvm *)((char *)v8 + 40);
      v10 += 5;
      v11 -= 40;
    }
    while (v11);
    uint64_t v8 = (llvm *)*((void *)this + 6);
    unint64_t v13 = 40 * *((unsigned int *)this + 16);
  }
  else
  {
    unint64_t v13 = 0;
  }
  llvm::deallocate_buffer(v8, (void *)v13);
}

void sub_180585BA0(void *__p)
{
  operator delete(__p);
}

uint64_t sub_180585E28()
{
  return v0;
}

uint64_t llvm::StringMap<std::function<std::optional<BOOL> ()(mlir::Operation *)>,llvm::MallocAllocator>::~StringMap(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 12))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 8);
    if (v2)
    {
      uint64_t v3 = 0;
      do
      {
        unint64_t v4 = *(llvm **)(*(void *)a1 + v3);
        if (v4 != (llvm *)-8 && v4 != 0)
        {
          uint64_t v6 = *(void *)v4;
          uint64_t v7 = (void *)*((void *)v4 + 4);
          if (v7 == (void *)((char *)v4 + 8))
          {
            (*(void (**)(void *))(*((void *)v4 + 1) + 32))((void *)v4 + 1);
          }
          else if (v7)
          {
            (*(void (**)(void *))(*v7 + 40))(v7);
          }
          llvm::deallocate_buffer(v4, (void *)(v6 + 41));
        }
        v3 += 8;
      }
      while (8 * v2 != v3);
    }
  }
  free(*(void **)a1);
  return a1;
}

unsigned char *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4mpsx17QuantizedMatMulOpEZNS2_3mps12_GLOBAL__N_112LoweringPass5lowerEPNS2_9OperationEE3__0EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_SB_EEvE4typeEOSE_EUlSB_E_NS_9allocatorISI_EEFNS_8optionalIbEESB_EE7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  *(void *)uint64_t result = &unk_1EC9CF250;
  result[8] = *(unsigned char *)(a1 + 8);
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4mpsx17QuantizedMatMulOpEZNS2_3mps12_GLOBAL__N_112LoweringPass5lowerEPNS2_9OperationEE3__0EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_SB_EEvE4typeEOSE_EUlSB_E_NS_9allocatorISI_EEFNS_8optionalIbEESB_EE7__cloneEPNS0_6__baseISN_EE(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EC9CF250;
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(result + 8);
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4mpsx17QuantizedMatMulOpEZNS2_3mps12_GLOBAL__N_112LoweringPass5lowerEPNS2_9OperationEE3__0EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_SB_EEvE4typeEOSE_EUlSB_E_NS_9allocatorISI_EEFNS_8optionalIbEESB_EEclEOSB_(uint64_t a1, mlir::Operation **a2)
{
  unint64_t v128 = *a2;
  if (mlir::mpsx::QuantizedMatMulOp::isInputAffneQuantized(&v128)
    && mlir::mpsx::QuantizedMatMulOp::getInputQuantParamsAxisAttr(&v128))
  {
    uint64_t v2 = (void *)(*(void *)(mlir::mpsx::QuantizedMatMulOp::getInput(&v128) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v2) {
      goto LABEL_12;
    }
    uint64_t v3 = *v2;
    unint64_t v4 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v5 = *(unsigned int *)(v3 + 16);
    if (!v5) {
      goto LABEL_12;
    }
    uint64_t v6 = *(void **)(v3 + 8);
    uint64_t v7 = &v6[2 * v5];
    do
    {
      unint64_t v8 = v5 >> 1;
      uint64_t v9 = &v6[2 * (v5 >> 1)];
      unint64_t v11 = *v9;
      unint64_t v10 = v9 + 2;
      v5 += ~(v5 >> 1);
      if (v11 < v4) {
        uint64_t v6 = v10;
      }
      else {
        unint64_t v5 = v8;
      }
    }
    while (v5);
    if (v6 != v7 && *v6 == v4) {
      uint64_t v12 = v6[1];
    }
    else {
LABEL_12:
    }
      uint64_t v12 = 0;
    uint64_t v126 = v2;
    uint64_t v127 = v12;
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v126))
    {
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v126);
      uint64_t v14 = v13;
      uint64_t v15 = (void *)(*(void *)(mlir::mpsx::QuantizedMatMulOp::getInputScale(&v128) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v15) {
        goto LABEL_23;
      }
      uint64_t v16 = *v15;
      unint64_t v17 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v18 = *(unsigned int *)(v16 + 16);
      if (!v18) {
        goto LABEL_23;
      }
      unint64_t v19 = *(void **)(v16 + 8);
      uint64_t v20 = &v19[2 * v18];
      do
      {
        unint64_t v21 = v18 >> 1;
        int64_t v22 = &v19[2 * (v18 >> 1)];
        unint64_t v24 = *v22;
        unint64_t v23 = v22 + 2;
        v18 += ~(v18 >> 1);
        if (v24 < v17) {
          unint64_t v19 = v23;
        }
        else {
          unint64_t v18 = v21;
        }
      }
      while (v18);
      if (v19 != v20 && *v19 == v17) {
        uint64_t v25 = v19[1];
      }
      else {
LABEL_23:
      }
        uint64_t v25 = 0;
      uint64_t v129 = v15;
      uint64_t v130 = v25;
      if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v129))
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v129);
        if (v14 != 1 && v26 == 1) {
          goto LABEL_133;
        }
      }
      unint64_t v27 = (void *)(*(void *)(mlir::mpsx::QuantizedMatMulOp::getInputZeroPoint(&v128) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v27) {
        goto LABEL_36;
      }
      uint64_t v28 = *v27;
      unint64_t v29 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v30 = *(unsigned int *)(v28 + 16);
      if (!v30) {
        goto LABEL_36;
      }
      long long v31 = *(void **)(v28 + 8);
      uint64_t v32 = &v31[2 * v30];
      do
      {
        unint64_t v33 = v30 >> 1;
        uint64_t v34 = &v31[2 * (v30 >> 1)];
        unint64_t v36 = *v34;
        uint64_t v35 = v34 + 2;
        v30 += ~(v30 >> 1);
        if (v36 < v29) {
          long long v31 = v35;
        }
        else {
          unint64_t v30 = v33;
        }
      }
      while (v30);
      if (v31 != v32 && *v31 == v29) {
        uint64_t v37 = v31[1];
      }
      else {
LABEL_36:
      }
        uint64_t v37 = 0;
      uint64_t v129 = v27;
      uint64_t v130 = v37;
      if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v129))
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v129);
        if (v14 != 1 && v38 == 1) {
          goto LABEL_133;
        }
      }
      unint64_t v39 = (void *)(*(void *)(mlir::mpsx::QuantizedMatMulOp::getInputMin(&v128) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v39) {
        goto LABEL_49;
      }
      uint64_t v40 = *v39;
      unint64_t v41 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v42 = *(unsigned int *)(v40 + 16);
      if (!v42) {
        goto LABEL_49;
      }
      uint64_t v43 = *(void **)(v40 + 8);
      unint64_t v44 = &v43[2 * v42];
      do
      {
        unint64_t v45 = v42 >> 1;
        unint64_t v46 = &v43[2 * (v42 >> 1)];
        unint64_t v48 = *v46;
        uint64_t v47 = v46 + 2;
        v42 += ~(v42 >> 1);
        if (v48 < v41) {
          uint64_t v43 = v47;
        }
        else {
          unint64_t v42 = v45;
        }
      }
      while (v42);
      if (v43 != v44 && *v43 == v41) {
        uint64_t v49 = v43[1];
      }
      else {
LABEL_49:
      }
        uint64_t v49 = 0;
      uint64_t v129 = v39;
      uint64_t v130 = v49;
      if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v129))
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v129);
        if (v14 != 1 && v50 == 1) {
          goto LABEL_133;
        }
      }
    }
  }
  if (!mlir::mpsx::QuantizedMatMulOp::isWeightsAffineQuantized(&v128)
    && !mlir::mpsx::QuantizedMatMulOp::isWeightsDoubleAffineQuantized(&v128)
    || !mlir::mpsx::QuantizedMatMulOp::getWeightsQuantParamsAxisAttr(&v128))
  {
    goto LABEL_134;
  }
  unint64_t v51 = (void *)(*(void *)(mlir::mpsx::QuantizedMatMulOp::getWeights(&v128) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v51) {
    goto LABEL_65;
  }
  uint64_t v52 = *v51;
  unint64_t v53 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v54 = *(unsigned int *)(v52 + 16);
  if (!v54) {
    goto LABEL_65;
  }
  int64_t v55 = *(void **)(v52 + 8);
  unint64_t v56 = &v55[2 * v54];
  do
  {
    unint64_t v57 = v54 >> 1;
    uint64_t v58 = &v55[2 * (v54 >> 1)];
    unint64_t v60 = *v58;
    uint64_t v59 = v58 + 2;
    v54 += ~(v54 >> 1);
    if (v60 < v53) {
      int64_t v55 = v59;
    }
    else {
      unint64_t v54 = v57;
    }
  }
  while (v54);
  if (v55 != v56 && *v55 == v53) {
    uint64_t v61 = v55[1];
  }
  else {
LABEL_65:
  }
    uint64_t v61 = 0;
  uint64_t v126 = v51;
  uint64_t v127 = v61;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v126)) {
    goto LABEL_134;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v126);
  uint64_t v63 = v62;
  long long v64 = (void *)(*(void *)(mlir::mpsx::QuantizedMatMulOp::getWeightsScale(&v128) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v64) {
    goto LABEL_76;
  }
  uint64_t v65 = *v64;
  unint64_t v66 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v67 = *(unsigned int *)(v65 + 16);
  if (!v67) {
    goto LABEL_76;
  }
  uint64_t v68 = *(void **)(v65 + 8);
  uint64_t v69 = &v68[2 * v67];
  do
  {
    unint64_t v70 = v67 >> 1;
    uint64_t v71 = &v68[2 * (v67 >> 1)];
    unint64_t v73 = *v71;
    unint64_t v72 = v71 + 2;
    v67 += ~(v67 >> 1);
    if (v73 < v66) {
      uint64_t v68 = v72;
    }
    else {
      unint64_t v67 = v70;
    }
  }
  while (v67);
  if (v68 != v69 && *v68 == v66) {
    uint64_t v74 = v68[1];
  }
  else {
LABEL_76:
  }
    uint64_t v74 = 0;
  uint64_t v129 = v64;
  uint64_t v130 = v74;
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v129))
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v129);
    if (v63 != 1 && v75 == 1) {
      goto LABEL_133;
    }
  }
  uint64_t v76 = (void *)(*(void *)(mlir::mpsx::QuantizedMatMulOp::getWeightsZeroPoint(&v128) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v76) {
    goto LABEL_89;
  }
  uint64_t v77 = *v76;
  unint64_t v78 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v79 = *(unsigned int *)(v77 + 16);
  if (!v79) {
    goto LABEL_89;
  }
  unint64_t v80 = *(void **)(v77 + 8);
  uint64_t v81 = &v80[2 * v79];
  do
  {
    unint64_t v82 = v79 >> 1;
    unint64_t v83 = &v80[2 * (v79 >> 1)];
    unint64_t v85 = *v83;
    uint64_t v84 = v83 + 2;
    v79 += ~(v79 >> 1);
    if (v85 < v78) {
      unint64_t v80 = v84;
    }
    else {
      unint64_t v79 = v82;
    }
  }
  while (v79);
  if (v80 != v81 && *v80 == v78) {
    uint64_t v86 = v80[1];
  }
  else {
LABEL_89:
  }
    uint64_t v86 = 0;
  uint64_t v129 = v76;
  uint64_t v130 = v86;
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v129))
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v129);
    if (v63 != 1 && v87 == 1) {
      goto LABEL_133;
    }
  }
  int64_t v88 = (void *)(*(void *)(mlir::mpsx::QuantizedMatMulOp::getWeightsMin(&v128) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v88) {
    goto LABEL_102;
  }
  uint64_t v89 = *v88;
  unint64_t v90 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v91 = *(unsigned int *)(v89 + 16);
  if (!v91) {
    goto LABEL_102;
  }
  uint64_t v92 = *(void **)(v89 + 8);
  uint64_t v93 = &v92[2 * v91];
  do
  {
    unint64_t v94 = v91 >> 1;
    unint64_t v95 = &v92[2 * (v91 >> 1)];
    unint64_t v97 = *v95;
    uint64_t v96 = v95 + 2;
    v91 += ~(v91 >> 1);
    if (v97 < v90) {
      uint64_t v92 = v96;
    }
    else {
      unint64_t v91 = v94;
    }
  }
  while (v91);
  if (v92 != v93 && *v92 == v90) {
    uint64_t v98 = v92[1];
  }
  else {
LABEL_102:
  }
    uint64_t v98 = 0;
  uint64_t v129 = v88;
  uint64_t v130 = v98;
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v129))
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v129);
    if (v63 != 1 && v99 == 1) {
      goto LABEL_133;
    }
  }
  if (!mlir::mpsx::QuantizedMatMulOp::isWeightsDoubleAffineQuantized(&v128)) {
    goto LABEL_134;
  }
  uint64_t v100 = (void *)(*(void *)(mlir::mpsx::QuantizedMatMulOp::getBiquantWeightsScale(&v128) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v100) {
    goto LABEL_116;
  }
  uint64_t v101 = *v100;
  unint64_t v102 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v103 = *(unsigned int *)(v101 + 16);
  if (!v103) {
    goto LABEL_116;
  }
  uint64_t v104 = *(void **)(v101 + 8);
  char v105 = &v104[2 * v103];
  do
  {
    unint64_t v106 = v103 >> 1;
    unint64_t v107 = &v104[2 * (v103 >> 1)];
    unint64_t v109 = *v107;
    uint64_t v108 = v107 + 2;
    v103 += ~(v103 >> 1);
    if (v109 < v102) {
      uint64_t v104 = v108;
    }
    else {
      unint64_t v103 = v106;
    }
  }
  while (v103);
  if (v104 != v105 && *v104 == v102) {
    uint64_t v110 = v104[1];
  }
  else {
LABEL_116:
  }
    uint64_t v110 = 0;
  uint64_t v129 = v100;
  uint64_t v130 = v110;
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v129))
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v129);
    if (v63 != 1 && v111 == 1) {
      goto LABEL_133;
    }
  }
  unint64_t v112 = (void *)(*(void *)(mlir::mpsx::QuantizedMatMulOp::getBiquantWeightsZeroPoint(&v128) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v112) {
    goto LABEL_129;
  }
  uint64_t v113 = *v112;
  unint64_t v114 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v115 = *(unsigned int *)(v113 + 16);
  if (!v115) {
    goto LABEL_129;
  }
  unint64_t v116 = *(void **)(v113 + 8);
  unint64_t v117 = &v116[2 * v115];
  do
  {
    unint64_t v118 = v115 >> 1;
    unint64_t v119 = &v116[2 * (v115 >> 1)];
    unint64_t v121 = *v119;
    uint64_t v120 = v119 + 2;
    v115 += ~(v115 >> 1);
    if (v121 < v114) {
      unint64_t v116 = v120;
    }
    else {
      unint64_t v115 = v118;
    }
  }
  while (v115);
  if (v116 != v117 && *v116 == v114) {
    uint64_t v122 = v116[1];
  }
  else {
LABEL_129:
  }
    uint64_t v122 = 0;
  uint64_t v129 = v112;
  uint64_t v130 = v122;
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v129) & 1) != 0
    && (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v129), v63 != 1)
    && v123 == 1)
  {
LABEL_133:
    int v124 = 0;
  }
  else
  {
LABEL_134:
    int v124 = 1;
  }
  return v124 | 0x100u;
}

unsigned char *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps9SoftmaxOpEZNS5_12_GLOBAL__N_112LoweringPass5lowerEPNS2_9OperationEE3__1EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_SA_EEvE4typeEOSD_EUlSA_E_NS_9allocatorISH_EEFNS_8optionalIbEESA_EE7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  *(void *)uint64_t result = &unk_1EC9CF208;
  result[8] = *(unsigned char *)(a1 + 8);
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps9SoftmaxOpEZNS5_12_GLOBAL__N_112LoweringPass5lowerEPNS2_9OperationEE3__1EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_SA_EEvE4typeEOSD_EUlSA_E_NS_9allocatorISH_EEFNS_8optionalIbEESA_EE7__cloneEPNS0_6__baseISM_EE(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EC9CF208;
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(result + 8);
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps9SoftmaxOpEZNS5_12_GLOBAL__N_112LoweringPass5lowerEPNS2_9OperationEE3__1EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_SA_EEvE4typeEOSD_EUlSA_E_NS_9allocatorISH_EEFNS_8optionalIbEESA_EEclEOSA_(uint64_t a1, uint64_t *a2)
{
  uint64_t v18 = *a2;
  uint64_t v2 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v18) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v2) {
    goto LABEL_10;
  }
  uint64_t v3 = *v2;
  unint64_t v4 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v5 = *(unsigned int *)(v3 + 16);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *(void **)(v3 + 8);
  uint64_t v7 = &v6[2 * v5];
  do
  {
    unint64_t v8 = v5 >> 1;
    uint64_t v9 = &v6[2 * (v5 >> 1)];
    unint64_t v11 = *v9;
    unint64_t v10 = v9 + 2;
    v5 += ~(v5 >> 1);
    if (v11 < v4) {
      uint64_t v6 = v10;
    }
    else {
      unint64_t v5 = v8;
    }
  }
  while (v5);
  if (v6 != v7 && *v6 == v4) {
    uint64_t v12 = v6[1];
  }
  else {
LABEL_10:
  }
    uint64_t v12 = 0;
  v17[0] = v2;
  v17[1] = v12;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v17)) {
    goto LABEL_15;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v17);
  if (!v13)
  {
    BOOL v15 = 1;
    return v15 | 0x100u;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v17);
  if (v14 == 1) {
    BOOL v15 = *(void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v17) == 1;
  }
  else {
LABEL_15:
  }
    BOOL v15 = 0;
  return v15 | 0x100u;
}

void *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps12DequantizeOpEZNS5_12_GLOBAL__N_112LoweringPass5lowerEPNS2_9OperationEE3__2EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_SA_EEvE4typeEOSD_EUlSA_E_NS_9allocatorISH_EEFNS_8optionalIbEESA_EE7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EC9CF1C0;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps12DequantizeOpEZNS5_12_GLOBAL__N_112LoweringPass5lowerEPNS2_9OperationEE3__2EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_SA_EEvE4typeEOSD_EUlSA_E_NS_9allocatorISH_EEFNS_8optionalIbEESA_EE7__cloneEPNS0_6__baseISM_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EC9CF1C0;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps12DequantizeOpEZNS5_12_GLOBAL__N_112LoweringPass5lowerEPNS2_9OperationEE3__2EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_SA_EEvE4typeEOSD_EUlSA_E_NS_9allocatorISH_EEFNS_8optionalIbEESA_EEclEOSA_(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a1 + 8);
  uint64_t v12 = *a2;
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v12);
  uint64_t ElementTypeOrSelf = (unsigned __int8 *)mlir::getElementTypeOrSelf(Input);
  if (*(_UNKNOWN **)(*(void *)ElementTypeOrSelf + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id
    || mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 4)
  {
    unint64_t v5 = *(void **)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v12);
    if (!v5)
    {
LABEL_35:
      int v4 = 1;
      return v4 | 0x100u;
    }
    while (1)
    {
      uint64_t v6 = v5[2];
      uint64_t v7 = *(void **)(*(void *)(v6 + 48) + 16);
      if (v6) {
        BOOL v8 = v7 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id;
      }
      else {
        BOOL v8 = 0;
      }
      if (v8)
      {
        int v4 = *v2;
        if (!*v2) {
          return v4 | 0x100u;
        }
        uint64_t v14 = &v15;
        uint64_t v15 = v6;
        uint64_t ElementTypeOrSelf = v2;
        {
          goto LABEL_34;
        }
      }
      else
      {
        if (v6) {
          BOOL v9 = v7 == &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id;
        }
        else {
          BOOL v9 = 0;
        }
        if (v9)
        {
          int v4 = v2[1];
          if (!v2[1]) {
            return v4 | 0x100u;
          }
          uint64_t v14 = &v15;
          uint64_t v15 = v6;
          uint64_t ElementTypeOrSelf = v2;
          {
            goto LABEL_34;
          }
        }
        else
        {
          if (v6) {
            BOOL v10 = v7 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
          }
          else {
            BOOL v10 = 0;
          }
          if (v10)
          {
            {
              goto LABEL_34;
            }
          }
          else
          {
            int v4 = 0;
            if (!v6 || v7 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id) {
              return v4 | 0x100u;
            }
            {
LABEL_34:
              int v4 = 0;
              return v4 | 0x100u;
            }
          }
        }
      }
      unint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_35;
      }
    }
  }
  int v4 = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v12) == 0;
  return v4 | 0x100u;
}

uint64_t mlir::mps::anonymous namespace'::isDequantSupportedForLayer<mlir::mps::Conv2DOp>(mlir::mps::MPSRuntimeCapabilities const&,mlir::mps::Conv2DOp)::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t *a1, uint64_t a2, char a3)
{
  uint64_t v35 = a2;
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v35);
  if (result)
  {
    uint64_t v6 = *(void **)(*(void *)(result + 48) + 16);
    BOOL v7 = v6 == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id;
    if (v6 == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id) {
      BOOL v8 = (uint64_t **)result;
    }
    else {
      BOOL v8 = 0;
    }
    uint64_t v34 = v8;
    if (!v7) {
      return 0;
    }
    uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v34);
    __p = 0;
    uint64_t v37 = 0;
    uint64_t p_p = &__p;
    unint64_t v39 = (void **)Filter;
    uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v39);
    if (!DefiningOp || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_p, DefiningOp)) {
      return 0;
    }
    uint64_t SplatFloat = mlir::getSplatFloatValue<float>((uint64_t)__p, v37);
    uint64_t result = 0;
    if ((SplatFloat & 0xFF00000000) != 0 && *(float *)&SplatFloat == 1.0)
    {
      uint64_t p_p = (void **)mlir::anec::GOC::getBias((mlir::anec::GOC *)&v34);
      uint64_t v12 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&p_p);
      if (v12)
      {
        LODWORD(v37) = 1;
        __p = 0;
        unint64_t v39 = &__p;
        if (mlir::detail::constant_int_value_binder::match((mlir::detail::constant_int_value_binder *)&v39, v12)) {
          BOOL v13 = mlir::m_Zero(void)::{lambda(llvm::APInt const&)#1}::__invoke((llvm::APInt *)&__p);
        }
        else {
          BOOL v13 = 0;
        }
        if (v37 >= 0x41 && __p) {
          operator delete[](__p);
        }
        if (v13) {
          return 1;
        }
      }
      uint64_t v14 = *a1;
      uint64_t v15 = *(void ***)a1[1];
      uint64_t p_p = (void **)v34;
      unint64_t v39 = v15;
      if (*(unsigned char *)(v14 + 2))
      {
        if (*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&p_p) + 8) >= 8uLL) {
          mlir::TypeID::get<mlir::ShapedType>();
        }
        uint64_t v16 = (uint64_t *)(*(void *)(mlir::anec::GOC::getBias((mlir::anec::GOC *)&p_p) + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!v16) {
          goto LABEL_32;
        }
        uint64_t v17 = *v16;
        unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v19 = *(unsigned int *)(v17 + 16);
        if (!v19) {
          goto LABEL_32;
        }
        uint64_t v20 = *(void **)(v17 + 8);
        unint64_t v21 = &v20[2 * v19];
        do
        {
          unint64_t v22 = v19 >> 1;
          unint64_t v23 = &v20[2 * (v19 >> 1)];
          unint64_t v25 = *v23;
          unint64_t v24 = v23 + 2;
          v19 += ~(v19 >> 1);
          if (v25 < v18) {
            uint64_t v20 = v24;
          }
          else {
            unint64_t v19 = v22;
          }
        }
        while (v19);
        if (v20 != v21 && *v20 == v18) {
          uint64_t v26 = v20[1];
        }
        else {
LABEL_32:
        }
          uint64_t v26 = 0;
        __p = v16;
        uint64_t v37 = v26;
        uint64_t ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__p);
        uint64_t NumElements = mlir::ShapedType::getNumElements(ArgAttrsAttr, v28);
        if (NumElements == 1 || (a3 & 1) != 0)
        {
          if (NumElements == 1) {
            return 1;
          }
        }
        else
        {
          int Axis = mlir::mps::DequantizeLUTOp::getAxis((mlir::mps::DequantizeLUTOp *)&p_p);
          if (Axis < 0) {
            uint64_t v31 = Axis;
          }
          else {
            uint64_t v31 = Axis - 4;
          }
          int WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v39);
          uint64_t v33 = -4;
          if (WeightsLayout != 2) {
            uint64_t v33 = -1;
          }
          if (v31 == v33) {
            return 1;
          }
        }
      }
      return 0;
    }
  }
  return result;
}

uint64_t mlir::mps::anonymous namespace'::isDequantSupportedForLayer<mlir::mps::MatMulOp>(mlir::mps::MPSRuntimeCapabilities const&,mlir::mps::MatMulOp)::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t *a1, uint64_t a2, char a3)
{
  uint64_t v36 = a2;
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v36);
  if (result)
  {
    uint64_t v6 = *(void **)(*(void *)(result + 48) + 16);
    BOOL v7 = v6 == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id;
    if (v6 == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id) {
      uint64_t v8 = result;
    }
    else {
      uint64_t v8 = 0;
    }
    uint64_t v35 = v8;
    if (!v7) {
      return 0;
    }
    uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v35);
    __p = 0;
    uint64_t v39 = 0;
    uint64_t p_p = &__p;
    v37[0] = Filter;
    uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v37);
    if (!DefiningOp || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_p, DefiningOp)) {
      return 0;
    }
    uint64_t SplatFloat = mlir::getSplatFloatValue<float>((uint64_t)__p, v39);
    uint64_t result = 0;
    if ((SplatFloat & 0xFF00000000) != 0 && *(float *)&SplatFloat == 1.0)
    {
      uint64_t p_p = (void **)mlir::anec::GOC::getBias((mlir::anec::GOC *)&v35);
      uint64_t v12 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&p_p);
      if (v12)
      {
        LODWORD(v39) = 1;
        __p = 0;
        v37[0] = &__p;
        if (mlir::detail::constant_int_value_binder::match((mlir::detail::constant_int_value_binder *)v37, v12)) {
          BOOL v13 = mlir::m_Zero(void)::{lambda(llvm::APInt const&)#1}::__invoke((llvm::APInt *)&__p);
        }
        else {
          BOOL v13 = 0;
        }
        if (v39 >= 0x41 && __p) {
          operator delete[](__p);
        }
        if (v13) {
          return 1;
        }
      }
      uint64_t v14 = *a1;
      uint64_t p_p = *(void ***)a1[1];
      uint64_t v40 = v35;
      if (*(unsigned char *)(v14 + 3))
      {
        uint64_t v15 = (uint64_t *)(*(void *)(mlir::anec::GOC::getBias((mlir::anec::GOC *)&v40) + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!v15) {
          goto LABEL_30;
        }
        uint64_t v16 = *v15;
        unint64_t v17 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v18 = *(unsigned int *)(v16 + 16);
        if (!v18) {
          goto LABEL_30;
        }
        unint64_t v19 = *(void **)(v16 + 8);
        uint64_t v20 = &v19[2 * v18];
        do
        {
          unint64_t v21 = v18 >> 1;
          unint64_t v22 = &v19[2 * (v18 >> 1)];
          unint64_t v24 = *v22;
          unint64_t v23 = v22 + 2;
          v18 += ~(v18 >> 1);
          if (v24 < v17) {
            unint64_t v19 = v23;
          }
          else {
            unint64_t v18 = v21;
          }
        }
        while (v18);
        if (v19 != v20 && *v19 == v17) {
          uint64_t v25 = v19[1];
        }
        else {
LABEL_30:
        }
          uint64_t v25 = 0;
        __p = v15;
        uint64_t v39 = v25;
        uint64_t ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__p);
        uint64_t NumElements = mlir::ShapedType::getNumElements(ArgAttrsAttr, v27);
        if (NumElements == 1 || (a3 & 1) != 0) {
          return NumElements == 1;
        }
        int Axis = mlir::mps::DequantizeLUTOp::getAxis((mlir::mps::DequantizeLUTOp *)&v40);
        uint64_t v30 = Axis;
        if (Axis < 0) {
          goto LABEL_37;
        }
        v37[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v40 - 8) & 0xFFFFFFFFFFFFFFF8));
        v37[1] = v31;
        if (v37[0] && (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v37) & 1) != 0)
        {
          mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v37);
          v30 -= v32;
LABEL_37:
          if (v30 >= -2)
          {
            BOOL TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&p_p);
            uint64_t v34 = -2;
            if (!TransposeRhs) {
              uint64_t v34 = -1;
            }
            if (v30 == v34) {
              return 1;
            }
          }
        }
      }
      return 0;
    }
  }
  return result;
}

uint64_t mlir::mps::anonymous namespace'::isDequantSupportedForLayer<mlir::mps::DepthwiseConv3DOp>(mlir::mps::MPSRuntimeCapabilities const&,mlir::mps::DepthwiseConv3DOp)::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t a1)
{
  uint64_t v11 = a1;
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (result)
  {
    uint64_t v2 = *(void **)(*(void *)(result + 48) + 16);
    BOOL v3 = v2 == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id;
    if (v2 == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id) {
      uint64_t v4 = result;
    }
    else {
      uint64_t v4 = 0;
    }
    uint64_t v10 = v4;
    if (!v3) {
      return 0;
    }
    uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v10);
    __p = 0;
    uint64_t v15 = 0;
    uint64_t p_p = &__p;
    BOOL v13 = (void **)Filter;
    uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v13);
    if (!DefiningOp || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_p, DefiningOp)) {
      return 0;
    }
    uint64_t SplatFloat = mlir::getSplatFloatValue<float>((uint64_t)__p, v15);
    uint64_t result = 0;
    if ((SplatFloat & 0xFF00000000) != 0 && *(float *)&SplatFloat == 1.0)
    {
      uint64_t p_p = (void **)mlir::anec::GOC::getBias((mlir::anec::GOC *)&v10);
      uint64_t v8 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&p_p);
      if (v8)
      {
        LODWORD(v15) = 1;
        BOOL v13 = &__p;
        __p = 0;
        BOOL v9 = mlir::detail::constant_int_value_binder::match((mlir::detail::constant_int_value_binder *)&v13, v8)
          && mlir::m_Zero(void)::{lambda(llvm::APInt const&)#1}::__invoke((llvm::APInt *)&__p);
        if (v15 >= 0x41)
        {
          if (__p) {
            operator delete[](__p);
          }
        }
        if (v9) {
          return 1;
        }
      }
      return 0;
    }
  }
  return result;
}

unsigned char *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps15DequantizeLUTOpEZNS5_12_GLOBAL__N_112LoweringPass5lowerEPNS2_9OperationEE3__3EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_SA_EEvE4typeEOSD_EUlSA_E_NS_9allocatorISH_EEFNS_8optionalIbEESA_EE7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  *(void *)uint64_t result = &unk_1EC9D1118;
  result[8] = *(unsigned char *)(a1 + 8);
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps15DequantizeLUTOpEZNS5_12_GLOBAL__N_112LoweringPass5lowerEPNS2_9OperationEE3__3EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_SA_EEvE4typeEOSD_EUlSA_E_NS_9allocatorISH_EEFNS_8optionalIbEESA_EE7__cloneEPNS0_6__baseISM_EE(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EC9D1118;
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(result + 8);
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps15DequantizeLUTOpEZNS5_12_GLOBAL__N_112LoweringPass5lowerEPNS2_9OperationEE3__3EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_SA_EEvE4typeEOSD_EUlSA_E_NS_9allocatorISH_EEFNS_8optionalIbEESA_EEclEOSA_(uint64_t a1, uint64_t *a2)
{
  uint64_t v6 = *a2;
  unint64_t v4 = *(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v6) + 8) & 0xFFFFFFFFFFFFFFF8;
  Elementuint64_t Type = mlir::TensorType::getElementType((mlir::TensorType *)&v4);
  BOOL v2 = mlir::Type::isUnsignedInteger((mlir::Type *)&ElementType, 4)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&ElementType, 8);
  return v2 | 0x100u;
}

char *mlir::mps::anonymous namespace'::LoweringTypeConverter::materializeTypeConstraint(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void v12[2] = *MEMORY[0x1E4F143B8];
  uint64_t v11 = a2;
  v12[0] = a3;
  v12[1] = a4;
  uint64_t v10 = mlir::ValueRange::dereference_iterator(v12, 0);
  uint64_t v9 = mlir::TypeAttr::get(a2);
  return (char *)mlir::OpBuilder::create<mlir::mps::TypeConstraintOp,mlir::Type &,mlir::Value,mlir::TypeAttr>(a1, a5, &v11, &v10, &v9)- 16;
}

void mlir::mps::anonymous namespace'::LoweringTypeConverter::~LoweringTypeConverter(pthread_rwlock_t **this)
{
}

void sub_180587148(void *__p)
{
  operator delete(__p);
}

void mlir::TypeConverter::~TypeConverter(pthread_rwlock_t **this)
{
}

{
  uint64_t v2;
  llvm *v3;
  char *v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;

  *this = (pthread_rwlock_t *)&unk_1EC9AA670;
  llvm::sys::RWMutexImpl::~RWMutexImpl(this + 65);
  BOOL v2 = *((unsigned int *)this + 128);
  BOOL v3 = (llvm *)this[62];
  if (v2)
  {
    unint64_t v4 = (char *)v3 + 24;
    unint64_t v5 = 40 * v2;
    do
    {
      if ((*((void *)v4 - 3) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v6 = (char *)*((void *)v4 - 2);
        if (v4 != v6) {
          free(v6);
        }
      }
      v4 += 40;
      v5 -= 40;
    }
    while (v5);
    BOOL v3 = (llvm *)this[62];
    BOOL v7 = 40 * *((unsigned int *)this + 128);
  }
  else
  {
    BOOL v7 = 0;
  }
  llvm::deallocate_buffer(v3, (void *)v7);
}

void sub_180587174(void *__p)
{
  operator delete(__p);
}

void mlir::TypeConverter::registerConversion(unsigned int *a1, uint64_t a2)
{
  BOOL v3 = a1 + 2;
  uint64_t v4 = a1[4];
  if (v4 >= a1[5])
  {
    llvm::SmallVectorTemplateBase<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>,false>::growAndEmplaceBack<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>>((uint64_t)v3, a2);
    unsigned int v7 = a1[120];
    if (v7) {
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v5 = *v3 + 32 * v4;
    uint64_t v6 = *(void *)(a2 + 24);
    if (v6)
    {
      if (v6 == a2)
      {
        *(void *)(v5 + 24) = v5;
        (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), v5);
        LODWORD(v4) = a1[4];
      }
      else
      {
        *(void *)(v5 + 24) = v6;
        *(void *)(a2 + 24) = 0;
      }
    }
    else
    {
      *(void *)(v5 + 24) = 0;
    }
    a1[4] = v4 + 1;
    unsigned int v7 = a1[120];
    if (v7) {
      goto LABEL_9;
    }
  }
  if (!a1[121]) {
    goto LABEL_12;
  }
LABEL_9:
  uint64_t v8 = a1 + 118;
  uint64_t v9 = a1[122];
  if (v9 > 4 * v7 && v9 >= 0x41)
  {
    llvm::DenseMap<mlir::Type,mlir::Type,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::Type>>::shrink_and_clear((uint64_t)v8);
LABEL_12:
    unsigned int v10 = a1[126];
    if (v10) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  if (v9)
  {
    uint64_t v11 = (void *)*v8;
    uint64_t v12 = (v9 - 1) & 0xFFFFFFFFFFFFFFFLL;
    if (v12)
    {
      uint64_t v13 = v12 + 1;
      uint64_t v14 = (v12 + 1) & 0x1FFFFFFFFFFFFFFELL;
      uint64_t v15 = &v11[2 * v14];
      uint64_t v16 = v11 + 2;
      uint64_t v17 = v14;
      do
      {
        *(v16 - 2) = -4096;
        void *v16 = -4096;
        v16 += 4;
        v17 -= 2;
      }
      while (v17);
      if (v13 == v14) {
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v15 = (void *)*v8;
    }
    unint64_t v18 = &v11[2 * v9];
    do
    {
      void *v15 = -4096;
      v15 += 2;
    }
    while (v15 != v18);
  }
LABEL_23:
  *((void *)a1 + 60) = 0;
  unsigned int v10 = a1[126];
  if (v10) {
    goto LABEL_25;
  }
LABEL_24:
  if (!a1[127]) {
    return;
  }
LABEL_25:
  unint64_t v19 = a1 + 124;
  uint64_t v20 = a1[128];
  if (v20 <= 4 * v10 || v20 < 0x41)
  {
    if (!v20)
    {
LABEL_38:
      *((void *)a1 + 63) = 0;
      return;
    }
    uint64_t v21 = *v19 + 24;
    uint64_t v22 = 40 * v20;
    while (1)
    {
      uint64_t v23 = *(void *)(v21 - 24);
      if (v23 != -8192)
      {
        if (v23 == -4096) {
          goto LABEL_33;
        }
        unint64_t v24 = *(void **)(v21 - 16);
        if ((void *)v21 != v24) {
          free(v24);
        }
      }
      *(void *)(v21 - 24) = -4096;
LABEL_33:
      v21 += 40;
      v22 -= 40;
      if (!v22) {
        goto LABEL_38;
      }
    }
  }

  llvm::DenseMap<mlir::Type,llvm::SmallVector<mlir::Type,2u>,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,llvm::SmallVector<mlir::Type,2u>>>::shrink_and_clear((uint64_t)v19);
}

uint64_t llvm::SmallVectorTemplateBase<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>,false>::growAndEmplaceBack<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>>(uint64_t a1, uint64_t a2)
{
  unint64_t v20 = 0;
  uint64_t v4 = (void *)(a1 + 16);
  uint64_t v5 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), 0, 32, &v20);
  uint64_t v6 = *(unsigned int *)(a1 + 8);
  unsigned int v7 = &v5[32 * v6];
  uint64_t v8 = *(void *)(a2 + 24);
  if (v8)
  {
    if (v8 == a2)
    {
      *((void *)v7 + 3) = v7;
      (*(void (**)(void))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24));
      uint64_t v6 = *(unsigned int *)(a1 + 8);
      uint64_t v9 = *(void **)a1;
      if (!v6) {
        goto LABEL_23;
      }
    }
    else
    {
      *((void *)v7 + 3) = v8;
      *(void *)(a2 + 24) = 0;
      uint64_t v9 = *(void **)a1;
      if (!v6) {
        goto LABEL_23;
      }
    }
  }
  else
  {
    *((void *)v7 + 3) = 0;
    uint64_t v9 = *(void **)a1;
    if (!v6) {
      goto LABEL_23;
    }
  }
  uint64_t v10 = 32 * v6;
  uint64_t v11 = v5;
  do
  {
    uint64_t v12 = (void *)v9[3];
    if (v12)
    {
      if (v9 == v12)
      {
        *((void *)v11 + 3) = v11;
        (*(void (**)(void, char *))(*(void *)v9[3] + 24))(v9[3], v11);
      }
      else
      {
        *((void *)v11 + 3) = v12;
        v9[3] = 0;
      }
    }
    else
    {
      *((void *)v11 + 3) = 0;
    }
    v11 += 32;
    v9 += 4;
    v10 -= 32;
  }
  while (v10);
  uint64_t v9 = *(void **)a1;
  uint64_t v13 = *(unsigned int *)(a1 + 8);
  if (v13)
  {
    uint64_t v14 = 4 * v13;
    uint64_t v15 = v9 - 4;
    do
    {
      uint64_t v16 = (void *)v15[v14 + 3];
      if (&v15[v14] == v16)
      {
        (*(void (**)(void *))(v15[v14] + 32))(&v15[v14]);
      }
      else if (v16)
      {
        (*(void (**)(void *))(*v16 + 40))(v16);
      }
      v14 -= 4;
    }
    while (v14 * 8);
    uint64_t v9 = *(void **)a1;
  }
LABEL_23:
  int v17 = v20;
  if (v9 != v4) {
    free(v9);
  }
  *(void *)a1 = v5;
  uint64_t v18 = (*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = v18;
  *(_DWORD *)(a1 + 12) = v17;
  return (uint64_t)&v5[32 * v18 - 32];
}

uint64_t llvm::DenseMap<mlir::Type,mlir::Type,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::Type>>::shrink_and_clear(uint64_t result)
{
  uint64_t v1 = *(unsigned int *)(result + 16);
  int v2 = *(_DWORD *)(result + 8);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    int v4 = v3;
  }
  else {
    int v4 = 0;
  }
  if (v4 != v1) {
    llvm::deallocate_buffer(*(llvm **)result, (void *)(16 * v1));
  }
  *(void *)(result + 8) = 0;
  if (v1)
  {
    uint64_t v5 = *(llvm **)result;
    uint64_t v6 = (v1 - 1) & 0xFFFFFFFFFFFFFFFLL;
    if (v6)
    {
      uint64_t v7 = v6 + 1;
      uint64_t v8 = (v6 + 1) & 0x1FFFFFFFFFFFFFFELL;
      uint64_t v9 = (llvm *)((char *)v5 + 16 * v8);
      uint64_t v10 = (void *)((char *)v5 + 16);
      uint64_t v11 = v8;
      do
      {
        *(v10 - 2) = -4096;
        void *v10 = -4096;
        v10 += 4;
        v11 -= 2;
      }
      while (v11);
      if (v7 == v8) {
        return result;
      }
    }
    else
    {
      uint64_t v9 = *(llvm **)result;
    }
    uint64_t v12 = (llvm *)((char *)v5 + 16 * v1);
    do
    {
      *(void *)uint64_t v9 = -4096;
      uint64_t v9 = (llvm *)((char *)v9 + 16);
    }
    while (v9 != v12);
  }
  return result;
}

void llvm::DenseMap<mlir::Type,llvm::SmallVector<mlir::Type,2u>,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,llvm::SmallVector<mlir::Type,2u>>>::shrink_and_clear(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 16);
  int v3 = *(_DWORD *)(a1 + 8);
  if (v2)
  {
    uint64_t v4 = *(void *)a1 + 24;
    uint64_t v5 = 40 * v2;
    do
    {
      if ((*(void *)(v4 - 24) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v6 = *(void **)(v4 - 16);
        if ((void *)v4 != v6) {
          free(v6);
        }
      }
      v4 += 40;
      v5 -= 40;
    }
    while (v5);
  }
  int v7 = 1 << (33 - __clz(v3 - 1));
  if (v7 <= 64) {
    int v7 = 64;
  }
  if (v3) {
    unsigned int v8 = v7;
  }
  else {
    unsigned int v8 = 0;
  }
  if (v8 != *(_DWORD *)(a1 + 16)) {
    llvm::deallocate_buffer(*(llvm **)a1, (void *)(40 * v2));
  }
  *(void *)(a1 + 8) = 0;
  if (v8)
  {
    uint64_t v9 = *(llvm **)a1;
    unint64_t v10 = 40 * v8 - 40;
    if (v10 < 0x28)
    {
      uint64_t v11 = *(llvm **)a1;
LABEL_20:
      uint64_t v15 = (llvm *)((char *)v9 + 40 * v8);
      do
      {
        *(void *)uint64_t v11 = -4096;
        uint64_t v11 = (llvm *)((char *)v11 + 40);
      }
      while (v11 != v15);
      return;
    }
    unint64_t v12 = v10 / 0x28 + 1;
    uint64_t v11 = (llvm *)((char *)v9 + 40 * (v12 & 0xFFFFFFFFFFFFFFELL));
    uint64_t v13 = v12 & 0xFFFFFFFFFFFFFFELL;
    uint64_t v14 = *(llvm **)a1;
    do
    {
      *(void *)uint64_t v14 = -4096;
      *((void *)v14 + 5) = -4096;
      uint64_t v14 = (llvm *)((char *)v14 + 80);
      v13 -= 2;
    }
    while (v13);
    if (v12 != (v12 & 0xFFFFFFFFFFFFFFELL)) {
      goto LABEL_20;
    }
  }
}

void *_ZNKSt3__110__function6__funcIZNK4mlir13TypeConverter12wrapCallbackINS2_4TypeEZNKS3_12wrapCallbackIS5_ZNS2_3mps12_GLOBAL__N_121LoweringTypeConverterC1EvEUlS5_E_EENS_9enable_ifIXsr3stdE14is_invocable_vIT0_T_EENS_8functionIFNS_8optionalINS2_13LogicalResultEEES5_RN4llvm15SmallVectorImplIS5_EEEEEE4typeEOSC_EUlS5_SL_E_EENSB_IXsr3stdE14is_invocable_vISC_SD_SL_EESN_E4typeESQ_EUlS5_SL_E_NS_9allocatorISU_EESM_E7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EC9CFC88;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZNK4mlir13TypeConverter12wrapCallbackINS2_4TypeEZNKS3_12wrapCallbackIS5_ZNS2_3mps12_GLOBAL__N_121LoweringTypeConverterC1EvEUlS5_E_EENS_9enable_ifIXsr3stdE14is_invocable_vIT0_T_EENS_8functionIFNS_8optionalINS2_13LogicalResultEEES5_RN4llvm15SmallVectorImplIS5_EEEEEE4typeEOSC_EUlS5_SL_E_EENSB_IXsr3stdE14is_invocable_vISC_SD_SL_EESN_E4typeESQ_EUlS5_SL_E_NS_9allocatorISU_EESM_E7__cloneEPNS0_6__baseISM_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EC9CFC88;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZNK4mlir13TypeConverter12wrapCallbackINS2_4TypeEZNKS3_12wrapCallbackIS5_ZNS2_3mps12_GLOBAL__N_121LoweringTypeConverterC1EvEUlS5_E_EENS_9enable_ifIXsr3stdE14is_invocable_vIT0_T_EENS_8functionIFNS_8optionalINS2_13LogicalResultEEES5_RN4llvm15SmallVectorImplIS5_EEEEEE4typeEOSC_EUlS5_SL_E_EENSB_IXsr3stdE14is_invocable_vISC_SD_SL_EESN_E4typeESQ_EUlS5_SL_E_NS_9allocatorISU_EESM_EclEOS5_SL_(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *a2;
  if (*a2)
  {
    uint64_t v5 = *(unsigned int *)(a3 + 8);
    if (v5 >= *(_DWORD *)(a3 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v5 + 1, 8);
      LODWORD(v5) = *(_DWORD *)(a3 + 8);
    }
    *(void *)(*(void *)a3 + 8 * v5) = v3;
    ++*(_DWORD *)(a3 + 8);
    int v6 = 1;
  }
  else
  {
    int v6 = 0;
  }
  return v6 | (v6 << 8);
}

uint64_t llvm::SmallVectorTemplateBase<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>,false>::growAndEmplaceBack<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>>(uint64_t a1, uint64_t a2)
{
  unint64_t v20 = 0;
  uint64_t v4 = (void *)(a1 + 16);
  uint64_t v5 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), 0, 32, &v20);
  uint64_t v6 = *(unsigned int *)(a1 + 8);
  int v7 = &v5[32 * v6];
  uint64_t v8 = *(void *)(a2 + 24);
  if (v8)
  {
    if (v8 == a2)
    {
      *((void *)v7 + 3) = v7;
      (*(void (**)(void))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24));
      uint64_t v6 = *(unsigned int *)(a1 + 8);
      uint64_t v9 = *(void **)a1;
      if (!v6) {
        goto LABEL_23;
      }
    }
    else
    {
      *((void *)v7 + 3) = v8;
      *(void *)(a2 + 24) = 0;
      uint64_t v9 = *(void **)a1;
      if (!v6) {
        goto LABEL_23;
      }
    }
  }
  else
  {
    *((void *)v7 + 3) = 0;
    uint64_t v9 = *(void **)a1;
    if (!v6) {
      goto LABEL_23;
    }
  }
  uint64_t v10 = 32 * v6;
  uint64_t v11 = v5;
  do
  {
    unint64_t v12 = (void *)v9[3];
    if (v12)
    {
      if (v9 == v12)
      {
        *((void *)v11 + 3) = v11;
        (*(void (**)(void, char *))(*(void *)v9[3] + 24))(v9[3], v11);
      }
      else
      {
        *((void *)v11 + 3) = v12;
        v9[3] = 0;
      }
    }
    else
    {
      *((void *)v11 + 3) = 0;
    }
    v11 += 32;
    v9 += 4;
    v10 -= 32;
  }
  while (v10);
  uint64_t v9 = *(void **)a1;
  uint64_t v13 = *(unsigned int *)(a1 + 8);
  if (v13)
  {
    uint64_t v14 = 4 * v13;
    uint64_t v15 = v9 - 4;
    do
    {
      uint64_t v16 = (void *)v15[v14 + 3];
      if (&v15[v14] == v16)
      {
        (*(void (**)(void *))(v15[v14] + 32))(&v15[v14]);
      }
      else if (v16)
      {
        (*(void (**)(void *))(*v16 + 40))(v16);
      }
      v14 -= 4;
    }
    while (v14 * 8);
    uint64_t v9 = *(void **)a1;
  }
LABEL_23:
  int v17 = v20;
  if (v9 != v4) {
    free(v9);
  }
  *(void *)a1 = v5;
  uint64_t v18 = (*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = v18;
  *(_DWORD *)(a1 + 12) = v17;
  return (uint64_t)&v5[32 * v18 - 32];
}

void *std::__function::__func<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)> mlir::TypeConverter::wrapMaterialization<mlir::Type,std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>(std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location) &&)::{lambda(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)#1},std::allocator<std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location) &&>,std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EC9CFCD0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)> mlir::TypeConverter::wrapMaterialization<mlir::Type,std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>(std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location) &&)::{lambda(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)#1},std::allocator<std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location) &&>,std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EC9CFCD0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)> mlir::TypeConverter::wrapMaterialization<mlir::Type,std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>(std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location) &&)::{lambda(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)#1},std::allocator<std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location) &&>,std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>::operator()(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  if (*a3) {
    return (*(uint64_t (**)(uint64_t, void, void, void, void))(a1 + 8))(a2, *a3, *a4, a4[1], *a5);
  }
  else {
    return 0;
  }
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::TypeConstraintOp,mlir::Type &,mlir::Value,mlir::TypeAttr>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.type_constraint", (const unsigned __int8 *)0x13, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    void v19[2] = (uint64_t)"mps.type_constraint";
    void v19[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::TypeConstraintOp::build((uint64_t)a1, (uint64_t)v21, *a3, *a4, *a5);
  uint64_t v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::TypeConstraintOp,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void mlir::mps::anonymous namespace'::LowerBiasAddGradNCHW::~LowerBiasAddGradNCHW(mlir::mps::_anonymous_namespace_::LowerBiasAddGradNCHW *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BiasAddGradOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::BiasAddGradOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::BiasAddGradOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BiasAddGradOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::BiasAddGradOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::mps::anonymous namespace'::LowerBiasAddGradNCHW::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4)
{
  void v37[2] = *(uint64_t **)MEMORY[0x1E4F143B8];
  uint64_t v35 = a2;
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v35);
  if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v35)) {
    return 0;
  }
  uint64_t v33 = mlir::OpBuilder::create<mlir::mps::RankOp,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *((void *)v35 + 3), &Input);
  uint64_t v7 = *((void *)v35 + 3);
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x20u, 1);
  unint64_t v9 = (void *)mlir::RankedTensorType::get(0, 0, IntegerType, 0);
  uint64_t v10 = v9;
  if (!v9) {
    goto LABEL_12;
  }
  uint64_t v11 = *v9;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_12;
  }
  unint64_t v14 = *(void **)(v11 + 8);
  uint64_t v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    int v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    __int16 v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      unint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_12:
  }
    uint64_t v20 = 0;
  LODWORD(v36[0]) = 0;
  uint64_t v6 = 1;
  v37[0] = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v10, v20, v36, 4, 4, 1, 1);
  uint64_t v32 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v7, v37);
  uint64_t v31 = mlir::OpBuilder::create<mlir::mps::GetCoordOp,mlir::mps::RankOp &,mlir::mps::ConstantOp &>((uint64_t *)(a4 + 8), *((void *)v35 + 3), &v33, &v32);
  uint64_t v21 = *((void *)v35 + 3);
  LODWORD(v37[0]) = 0;
  LODWORD(v36[0]) = 0;
  LODWORD(v30) = 3;
  Coord = mlir::OpBuilder::create<mlir::mps::CropOp,mlir::mps::GetCoordOp &,int,int,int>((mlir::mps::ConstantOp *)(a4 + 8), v21, &v31, (unsigned int *)v37, (unsigned int *)v36, (unsigned int *)&v30);
  uint64_t v23 = *((void *)v35 + 3);
  LODWORD(v37[0]) = 0;
  LODWORD(v36[0]) = -2;
  LODWORD(v30) = 2;
  unint64_t v24 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::mps::GetCoordOp &,int,int,int>((mlir::mps::ConstantOp *)(a4 + 8), v23, &v31, (unsigned int *)v37, (unsigned int *)v36, (unsigned int *)&v30);
  uint64_t v25 = *((void *)v35 + 3);
  v36[0] = (char *)Coord - 16;
  v36[1] = (char *)v24 - 16;
  mlir::ValueRange::ValueRange((unint64_t *)v37, (uint64_t)v36, 2uLL);
  unsigned __int8 v29 = 0;
  uint64_t v30 = mlir::OpBuilder::create<mlir::mps::ConcatOp,mlir::ValueRange,mlir::mps::ConstantOp &,BOOL>((mlir::UnitAttr **)(a4 + 8), v25, (uint64_t *)v37, &v32, &v29);
  uint64_t v26 = *((void *)v35 + 3);
  LOBYTE(v37[0]) = 0;
  uint64_t v27 = mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::Value &,mlir::mps::ConcatOp &,BOOL>((mlir::UnitAttr **)(a4 + 8), v26, &Input, &v30, (unsigned __int8 *)v37);
  mlir::ConversionPatternRewriter::replaceOp((mlir::ConversionPatternRewriter *)a4, a2, v27);
  return v6;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::RankOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.rank", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    void v15[2] = (uint64_t)"mps.rank";
    v15[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::RankOp::build((uint64_t)a1, (uint64_t)v17, *a3);
  unint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::RankOp,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::GetCoordOp,mlir::mps::RankOp &,mlir::mps::ConstantOp &>(uint64_t *a1, uint64_t a2, void *a3, void *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.get_coordinates", (const unsigned __int8 *)0x13, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.get_coordinates";
    v17[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::GetCoordOp::build(a1, (uint64_t)v19, *a3 - 16, *a4 - 16);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::GetCoordOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::CropOp,mlir::mps::GetCoordOp &,int,int,int>(mlir::mps::ConstantOp *a1, uint64_t a2, void *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.crop", (const unsigned __int8 *)8, Context);
  if (!v14)
  {
    __int16 v22 = 1283;
    unint64_t v21[2] = (uint64_t)"mps.crop";
    v21[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::mps::CropOp::build(a1, v23, *a3 - 16, *a4, *a5, *a6);
  uint64_t v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::CropOp,void>::id) {
    __int16 v16 = v15;
  }
  else {
    __int16 v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::mps::GetCoordOp &,int,int,int>(mlir::mps::ConstantOp *a1, uint64_t a2, void *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.slice", (const unsigned __int8 *)9, Context);
  if (!v14)
  {
    __int16 v22 = 1283;
    unint64_t v21[2] = (uint64_t)"mps.slice";
    v21[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::mps::SliceOp::build(a1, v23, *a3 - 16, *a4, *a5, *a6);
  uint64_t v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SliceOp,void>::id) {
    __int16 v16 = v15;
  }
  else {
    __int16 v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ConcatOp,mlir::ValueRange,mlir::mps::ConstantOp &,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, void *a4, unsigned __int8 *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.concat", (const unsigned __int8 *)0xA, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    void v19[2] = (uint64_t)"mps.concat";
    void v19[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::ConcatOp::build(a1, (uint64_t)v21, *a3, a3[1], *a4 - 16, *a5);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConcatOp,void>::id) {
    char v14 = v13;
  }
  else {
    char v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::Value &,mlir::mps::ConcatOp &,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, void *a4, unsigned __int8 *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_sum", (const unsigned __int8 *)0x11, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    void v19[2] = (uint64_t)"mps.reduction_sum";
    void v19[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::ReductionSumOp::build(a1, (uint64_t)v21, *a3, *a4 - 16, *a5);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionSumOp,void>::id) {
    char v14 = v13;
  }
  else {
    char v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void mlir::mps::anonymous namespace'::LowerBiasAddGradNHWC::~LowerBiasAddGradNHWC(mlir::mps::_anonymous_namespace_::LowerBiasAddGradNHWC *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::mps::anonymous namespace'::LowerBiasAddGradNHWC::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v45 = a2;
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v45) != 1) {
    return 0;
  }
  uint64_t v43 = mlir::OpBuilder::create<mlir::mps::RankOp,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *((void *)v45 + 3), &Input);
  uint64_t v6 = *((void *)v45 + 3);
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x20u, 1);
  char v8 = (void *)mlir::RankedTensorType::get(0, 0, IntegerType, 0);
  uint64_t v9 = v8;
  if (!v8) {
    goto LABEL_11;
  }
  uint64_t v10 = *v8;
  unint64_t v11 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v12 = *(unsigned int *)(v10 + 16);
  if (!v12) {
    goto LABEL_11;
  }
  uint64_t v13 = *(void **)(v10 + 8);
  char v14 = &v13[2 * v12];
  do
  {
    unint64_t v15 = v12 >> 1;
    uint64_t v16 = &v13[2 * (v12 >> 1)];
    unint64_t v18 = *v16;
    int v17 = v16 + 2;
    v12 += ~(v12 >> 1);
    if (v18 < v11) {
      uint64_t v13 = v17;
    }
    else {
      unint64_t v12 = v15;
    }
  }
  while (v12);
  if (v13 != v14 && *v13 == v11) {
    uint64_t v19 = v13[1];
  }
  else {
LABEL_11:
  }
    uint64_t v19 = 0;
  LODWORD(v40) = 0;
  uint64_t v20 = 1;
  unint64_t v41 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v9, v19, &v40, 4, 4, 1, 1);
  unint64_t v42 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v6, (uint64_t **)&v41);
  unint64_t v41 = mlir::OpBuilder::create<mlir::mps::GetCoordOp,mlir::mps::RankOp &,mlir::mps::ConstantOp &>((uint64_t *)(a4 + 8), *((void *)v45 + 3), &v43, &v42);
  uint64_t v21 = *((void *)v45 + 3);
  uint64_t v22 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x20u, 1);
  uint64_t v23 = (void *)mlir::RankedTensorType::get(0, 0, v22, 0);
  unint64_t v24 = v23;
  if (!v23) {
    goto LABEL_21;
  }
  uint64_t v25 = *v23;
  unint64_t v26 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v27 = *(unsigned int *)(v25 + 16);
  if (!v27) {
    goto LABEL_21;
  }
  uint64_t v28 = *(void **)(v25 + 8);
  unsigned __int8 v29 = &v28[2 * v27];
  do
  {
    unint64_t v30 = v27 >> 1;
    uint64_t v31 = &v28[2 * (v27 >> 1)];
    unint64_t v33 = *v31;
    uint64_t v32 = v31 + 2;
    v27 += ~(v27 >> 1);
    if (v33 < v26) {
      uint64_t v28 = v32;
    }
    else {
      unint64_t v27 = v30;
    }
  }
  while (v27);
  if (v28 != v29 && *v28 == v26) {
    uint64_t v34 = v28[1];
  }
  else {
LABEL_21:
  }
    uint64_t v34 = 0;
  int v38 = 1;
  uint64_t v39 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v24, v34, &v38, 4, 4, 1, 1);
  uint64_t v40 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v21, (uint64_t **)&v39);
  uint64_t v39 = mlir::OpBuilder::create<mlir::mps::CropOp,mlir::mps::GetCoordOp &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>((mlir::UnknownLoc **)(a4 + 8), *((void *)v45 + 3), &v41, &v42, &v42, &v40);
  uint64_t v35 = *((void *)v45 + 3);
  LOBYTE(v38) = 0;
  uint64_t v36 = mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::Value &,mlir::mps::ConcatOp &,BOOL>((mlir::UnitAttr **)(a4 + 8), v35, &Input, &v39, (unsigned __int8 *)&v38);
  mlir::ConversionPatternRewriter::replaceOp((mlir::ConversionPatternRewriter *)a4, a2, v36);
  return v20;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::CropOp,mlir::mps::GetCoordOp &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>(mlir::UnknownLoc **a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.crop", (const unsigned __int8 *)8, Context);
  if (!v14)
  {
    __int16 v22 = 1283;
    unint64_t v21[2] = (uint64_t)"mps.crop";
    v21[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::mps::CropOp::build(a1, (uint64_t)v23, *a3 - 16, *a4 - 16, *a5 - 16, *a6 - 16);
  unint64_t v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::CropOp,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::mps::anonymous namespace'::LowerBiasAddNCHW::~LowerBiasAddNCHW(mlir::mps::_anonymous_namespace_::LowerBiasAddNCHW *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BiasAddOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::BiasAddOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::BiasAddOpGenericAdaptorBase::BiasAddOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BiasAddOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::BiasAddOpGenericAdaptorBase::BiasAddOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::mps::anonymous namespace'::LowerBiasAddNCHW::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::UnknownLoc **a4)
{
  unint64_t v80 = a2;
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v80);
  uint64_t v79 = Input;
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v80);
  if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v80)) {
    return 0;
  }
  uint64_t v8 = *((void *)v80 + 3);
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(Input);
  uint64_t v77 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a4 + 1, v8, &Filter, &ElementTypeOrSelf);
  uint64_t ElementTypeOrSelf = (uint64_t)mlir::OpBuilder::create<mlir::mps::RankOp,mlir::Value &>((mlir::OpBuilder *)(a4 + 1), *((void *)v80 + 3), &v79);
  uint64_t v9 = *((void *)v80 + 3);
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x20u, 1);
  unint64_t v11 = (void *)mlir::RankedTensorType::get(0, 0, IntegerType, 0);
  unint64_t v12 = v11;
  if (!v11) {
    goto LABEL_12;
  }
  uint64_t v13 = *v11;
  unint64_t v14 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v15 = *(unsigned int *)(v13 + 16);
  if (!v15) {
    goto LABEL_12;
  }
  uint64_t v16 = *(void **)(v13 + 8);
  int v17 = &v16[2 * v15];
  do
  {
    unint64_t v18 = v15 >> 1;
    uint64_t v19 = &v16[2 * (v15 >> 1)];
    unint64_t v21 = *v19;
    __int16 v20 = v19 + 2;
    v15 += ~(v15 >> 1);
    if (v21 < v14) {
      uint64_t v16 = v20;
    }
    else {
      unint64_t v15 = v18;
    }
  }
  while (v15);
  if (v16 != v17 && *v16 == v14) {
    uint64_t v22 = v16[1];
  }
  else {
LABEL_12:
  }
    uint64_t v22 = 0;
  LODWORD(v73) = 0;
  uint64_t v74 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v12, v22, &v73, 4, 4, 1, 1);
  uint64_t v75 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 1), v9, (uint64_t **)&v74);
  uint64_t v74 = mlir::OpBuilder::create<mlir::mps::GetCoordOp,mlir::mps::RankOp &,mlir::mps::ConstantOp &>((uint64_t *)a4 + 1, *((void *)v80 + 3), &ElementTypeOrSelf, &v75);
  uint64_t v23 = *((void *)v80 + 3);
  uint64_t v24 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x20u, 1);
  uint64_t v25 = (void *)mlir::RankedTensorType::get(0, 0, v24, 0);
  unint64_t v26 = v25;
  if (!v25) {
    goto LABEL_22;
  }
  uint64_t v27 = *v25;
  unint64_t v28 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v29 = *(unsigned int *)(v27 + 16);
  if (!v29) {
    goto LABEL_22;
  }
  unint64_t v30 = *(void **)(v27 + 8);
  uint64_t v31 = &v30[2 * v29];
  do
  {
    unint64_t v32 = v29 >> 1;
    unint64_t v33 = &v30[2 * (v29 >> 1)];
    unint64_t v35 = *v33;
    uint64_t v34 = v33 + 2;
    v29 += ~(v29 >> 1);
    if (v35 < v28) {
      unint64_t v30 = v34;
    }
    else {
      unint64_t v29 = v32;
    }
  }
  while (v29);
  if (v30 != v31 && *v30 == v28) {
    uint64_t v36 = v30[1];
  }
  else {
LABEL_22:
  }
    uint64_t v36 = 0;
  LODWORD(v71) = 1;
  unint64_t v72 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v26, v36, &v71, 4, 4, 1, 1);
  unint64_t v73 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 1), v23, (uint64_t **)&v72);
  unint64_t v72 = mlir::OpBuilder::create<mlir::mps::CropOp,mlir::mps::GetCoordOp &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>(a4 + 1, *((void *)v80 + 3), &v74, &v75, &v75, &v73);
  uint64_t v71 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::mps::CastOp &,mlir::mps::CropOp &>((mlir::OpBuilder *)(a4 + 1), *((void *)v80 + 3), &v77, &v72);
  uint64_t v37 = *((void *)v80 + 3);
  uint64_t v38 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x20u, 1);
  uint64_t v39 = (void *)mlir::RankedTensorType::get(0, 0, v38, 0);
  uint64_t v40 = v39;
  if (!v39) {
    goto LABEL_32;
  }
  uint64_t v41 = *v39;
  unint64_t v42 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v43 = *(unsigned int *)(v41 + 16);
  if (!v43) {
    goto LABEL_32;
  }
  unint64_t v44 = *(void **)(v41 + 8);
  unint64_t v45 = &v44[2 * v43];
  do
  {
    unint64_t v46 = v43 >> 1;
    uint64_t v47 = &v44[2 * (v43 >> 1)];
    unint64_t v49 = *v47;
    unint64_t v48 = v47 + 2;
    v43 += ~(v43 >> 1);
    if (v49 < v42) {
      unint64_t v44 = v48;
    }
    else {
      unint64_t v43 = v46;
    }
  }
  while (v43);
  if (v44 != v45 && *v44 == v42) {
    uint64_t v50 = v44[1];
  }
  else {
LABEL_32:
  }
    uint64_t v50 = 0;
  LODWORD(v68) = -1;
  uint64_t v69 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v40, v50, &v68, 4, 4, 1, 1);
  unint64_t v70 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 1), v37, (uint64_t **)&v69);
  uint64_t v51 = *((void *)v80 + 3);
  uint64_t v52 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x20u, 1);
  unint64_t v53 = (void *)mlir::RankedTensorType::get(0, 0, v52, 0);
  unint64_t v54 = v53;
  if (!v53) {
    goto LABEL_42;
  }
  uint64_t v55 = *v53;
  unint64_t v56 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v57 = *(unsigned int *)(v55 + 16);
  if (!v57) {
    goto LABEL_42;
  }
  uint64_t v58 = *(void **)(v55 + 8);
  uint64_t v59 = &v58[2 * v57];
  do
  {
    unint64_t v60 = v57 >> 1;
    uint64_t v61 = &v58[2 * (v57 >> 1)];
    unint64_t v63 = *v61;
    uint64_t v62 = v61 + 2;
    v57 += ~(v57 >> 1);
    if (v63 < v56) {
      uint64_t v58 = v62;
    }
    else {
      unint64_t v57 = v60;
    }
  }
  while (v57);
  if (v58 != v59 && *v58 == v56) {
    uint64_t v64 = v58[1];
  }
  else {
LABEL_42:
  }
    uint64_t v64 = 0;
  int v67 = -3;
  uint64_t v7 = 1;
  uint64_t v68 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v54, v64, &v67, 4, 4, 1, 1);
  uint64_t v69 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 1), v51, (uint64_t **)&v68);
  uint64_t v68 = mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::mps::ExpandDimsOp &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>(a4 + 1, *((void *)v80 + 3), &v71, &v69, &v70);
  uint64_t v65 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value &,mlir::mps::TransposeOp &>(a4 + 1, *((void *)v80 + 3), &v79, &v68);
  mlir::ConversionPatternRewriter::replaceOp((mlir::ConversionPatternRewriter *)a4, a2, v65);
  return v7;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::mps::CastOp &,mlir::mps::CropOp &>(mlir::OpBuilder *a1, uint64_t a2, void *a3, void *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.expand_dims", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.expand_dims";
    v17[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ExpandDimsOp::build((uint64_t)a1, (uint64_t)v19, *a3 - 16, *a4 - 16);
  unint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ExpandDimsOp,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::mps::ExpandDimsOp &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>(mlir::Float32Type **a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.transpose", (const unsigned __int8 *)0xD, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    void v19[2] = (uint64_t)"mps.transpose";
    void v19[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::TransposeOp::build(a1, (uint64_t)v21, *a3 - 16, *a4 - 16, *a5 - 16);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value &,mlir::mps::TransposeOp &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, void *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.add";
    v17[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3, *a4 - 16);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::mps::anonymous namespace'::LowerReductionMean::~LowerReductionMean(mlir::mps::_anonymous_namespace_::LowerReductionMean *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMeanOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMeanOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReductionMeanOpGenericAdaptorBase::ReductionMeanOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMeanOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReductionMeanOpGenericAdaptorBase::ReductionMeanOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::mps::anonymous namespace'::LowerReductionMean::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v27[1] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = a2;
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v25);
  uint64_t Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v25);
  BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v25);
  uint64_t v6 = *(void *)(a2 + 24);
  if (Axes) {
    uint64_t v7 = mlir::OpBuilder::create<mlir::mps::DimensionSizeOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(void *)(a2 + 24), &Input, &Axes);
  }
  else {
    uint64_t v7 = mlir::OpBuilder::create<mlir::mps::ShapeOp,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(a2 + 24), &Input);
  }
  unint64_t v21 = (char *)v7 - 16;
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(Input);
  if (mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf))
  {
    uint64_t IntegerType = mlir::Float32Type::get(*(mlir::Float32Type **)(a4 + 8), v8);
LABEL_9:
    uint64_t v19 = mlir::TypeAttr::get(IntegerType);
    uint64_t Input = (uint64_t)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>((mlir::UnknownLoc **)(a4 + 8), v6, &Input, &v19)- 16;
    int v11 = 1;
    goto LABEL_10;
  }
  if (mlir::Type::isInteger((mlir::Type *)&ElementTypeOrSelf, 8)
    || mlir::Type::isInteger((mlir::Type *)&ElementTypeOrSelf, 16))
  {
    BOOL isSignedInteger = mlir::Type::isSignedInteger((mlir::Type *)&ElementTypeOrSelf);
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x20u, isSignedInteger);
    goto LABEL_9;
  }
  int v11 = 0;
LABEL_10:
  char v12 = mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::Value &,mlir::Value &,BOOL &>((mlir::UnitAttr **)(a4 + 8), v6, &Input, &Axes, (unsigned __int8 *)&InferredResultTypes);
  uint64_t v19 = (uint64_t)v12;
  __int16 v18 = mlir::OpBuilder::create<mlir::mps::ReductionProdOp,mlir::Value &>((mlir::UnknownLoc **)(a4 + 8), v6, (uint64_t)&v21);
  uint64_t v13 = mlir::getElementTypeOrSelf((uint64_t)v12 - 16);
  __int16 v16 = (char *)mlir::TypeAttr::get(v13);
  int v17 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::mps::ReductionProdOp &,mlir::TypeAttr>((mlir::UnknownLoc **)(a4 + 8), v6, &v18, (uint64_t *)&v16);
  unint64_t v14 = (char *)mlir::OpBuilder::create<mlir::mps::DivideOp,mlir::mps::ReductionSumOp &,mlir::mps::CastOp &>((mlir::Float32Type **)(a4 + 8), v6, &v19, &v17)- 16;
  __int16 v16 = v14;
  if (v11)
  {
    v27[0] = mlir::TypeAttr::get(ElementTypeOrSelf);
    unint64_t v14 = (char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>((mlir::UnknownLoc **)(a4 + 8), v6, (uint64_t *)&v16, v27)- 16;
    __int16 v16 = v14;
  }
  v27[0] = (uint64_t)v14;
  mlir::ValueRange::ValueRange(v26, (uint64_t)v27, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, v26[0], v26[1]);
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::DimensionSizeOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dimension_size", (const unsigned __int8 *)0x12, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.dimension_size";
    v17[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::DimensionSizeOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  int v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DimensionSizeOp,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::Value &,mlir::Value &,BOOL &>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned __int8 *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_sum", (const unsigned __int8 *)0x11, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    void v19[2] = (uint64_t)"mps.reduction_sum";
    void v19[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::ReductionSumOp::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionSumOp,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReductionProdOp,mlir::Value &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_prod", (const unsigned __int8 *)0x12, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    void v15[2] = (uint64_t)"mps.reduction_prod";
    v15[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ReductionProdOp::build(a1, (uint64_t)v17, a3, 1, 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionProdOp,void>::id) {
    char v10 = v9;
  }
  else {
    char v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::CastOp,mlir::mps::ReductionProdOp &,mlir::TypeAttr>(mlir::UnknownLoc **a1, uint64_t a2, void *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.cast";
    v17[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::CastOp::build(a1, (uint64_t)v19, *a3 - 16, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::CastOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::DivideOp,mlir::mps::ReductionSumOp &,mlir::mps::CastOp &>(mlir::Float32Type **a1, uint64_t a2, void *a3, void *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.divide", (const unsigned __int8 *)0xA, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.divide";
    v17[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3 - 16, *a4 - 16);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DivideOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::mps::anonymous namespace'::LowerReductionVariance::~LowerReductionVariance(mlir::mps::_anonymous_namespace_::LowerReductionVariance *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionVarianceOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionVarianceOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReductionVarianceOpGenericAdaptorBase::ReductionVarianceOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionVarianceOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReductionVarianceOpGenericAdaptorBase::ReductionVarianceOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::mps::anonymous namespace'::LowerReductionVariance::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::UnitAttr **a4)
{
  uint64_t v15 = a2;
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v15);
  uint64_t Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v15);
  BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v15);
  uint64_t v6 = *((void *)a2 + 3);
  LOBYTE(v10) = 1;
  uint64_t v11 = mlir::OpBuilder::create<mlir::mps::ReductionMeanOp,mlir::Value &,mlir::Value &,BOOL>(a4 + 1, v6, &Input, &Axes, (unsigned __int8 *)&v10);
  char v10 = mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::mps::ReductionMeanOp &>(a4 + 1, v6, &Input, &v11);
  unint64_t v9 = mlir::OpBuilder::create<mlir::mps::SquareOp,mlir::mps::SubtractOp &>((mlir::OpBuilder *)(a4 + 1), v6, &v10);
  uint64_t v7 = mlir::OpBuilder::create<mlir::mps::ReductionMeanOp,mlir::mps::SquareOp &,mlir::Value &,BOOL &>(a4 + 1, v6, &v9, &Axes, (unsigned __int8 *)&InferredResultTypes);
  mlir::ConversionPatternRewriter::replaceOp((mlir::ConversionPatternRewriter *)a4, a2, v7);
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReductionMeanOp,mlir::Value &,mlir::Value &,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned __int8 *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_mean", (const unsigned __int8 *)0x12, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    void v19[2] = (uint64_t)"mps.reduction_mean";
    void v19[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::ReductionMeanOp::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  unint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionMeanOp,void>::id) {
    unint64_t v14 = v13;
  }
  else {
    unint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::mps::ReductionMeanOp &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, void *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.subtract", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.subtract";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3, *a4 - 16);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SubtractOp,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SquareOp,mlir::mps::SubtractOp &>(mlir::OpBuilder *a1, uint64_t a2, void *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.square", (const unsigned __int8 *)0xA, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    void v15[2] = (uint64_t)"mps.square";
    v15[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3 - 16);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SquareOp,void>::id) {
    char v10 = v9;
  }
  else {
    char v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReductionMeanOp,mlir::mps::SquareOp &,mlir::Value &,BOOL &>(mlir::UnitAttr **a1, uint64_t a2, void *a3, uint64_t *a4, unsigned __int8 *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_mean", (const unsigned __int8 *)0x12, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    void v19[2] = (uint64_t)"mps.reduction_mean";
    void v19[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::ReductionMeanOp::build(a1, (uint64_t)v21, *a3 - 16, *a4, *a5);
  unint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionMeanOp,void>::id) {
    __int16 v14 = v13;
  }
  else {
    __int16 v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void mlir::mps::anonymous namespace'::LowerSoftplus::~LowerSoftplus(mlir::mps::_anonymous_namespace_::LowerSoftplus *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SoftplusOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SoftplusOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SoftplusOpGenericAdaptorBase::SoftplusOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SoftplusOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SoftplusOpGenericAdaptorBase::SoftplusOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::mps::anonymous namespace'::LowerSoftplus::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v19 = a2;
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v19);
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(Input);
  uint64_t v6 = *((void *)a2 + 3);
  uint64_t v16 = mlir::OpBuilder::create<mlir::mps::ExponentOp,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), v6, &Input);
  uint64_t Constant = 1;
  uint64_t v7 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&Constant, 1, ElementTypeOrSelf, 0);
  uint64_t Constant = mlir::mps::getConstantAttr<int>(v7, 1);
  uint64_t v15 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v6, (uint64_t **)&Constant);
  unint64_t v14 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::mps::SubtractOp &,mlir::mps::ConstantOp>((mlir::Float32Type **)(a4 + 8), v6, &v16, &v15);
  unint64_t v13 = mlir::OpBuilder::create<mlir::mps::LogarithmOp,mlir::mps::AddOp &>((mlir::OpBuilder *)(a4 + 8), v6, &v14);
  if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) >= 0x11) {
    float v8 = 20.0;
  }
  else {
    float v8 = 10.0;
  }
  uint64_t Constant = 1;
  unint64_t v9 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&Constant, 1, ElementTypeOrSelf, 0);
  uint64_t Constant = mlir::mps::getConstantAttr<float>(v9, v8);
  uint64_t Constant = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v6, (uint64_t **)&Constant);
  char v12 = mlir::OpBuilder::create<mlir::mps::GreaterThanOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(a4 + 8), v6, &Input, &Constant);
  char v10 = mlir::OpBuilder::create<mlir::mps::SelectOp,mlir::mps::GreaterThanOp &,mlir::Value &,mlir::mps::LogarithmOp &>((mlir::OpBuilder *)(a4 + 8), v6, &v12, &Input, &v13);
  mlir::ConversionPatternRewriter::replaceOp((mlir::ConversionPatternRewriter *)a4, a2, v10);
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ExponentOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.exponent", (const unsigned __int8 *)0xC, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    void v15[2] = (uint64_t)"mps.exponent";
    v15[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3);
  unint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ExponentOp,void>::id) {
    char v10 = v9;
  }
  else {
    char v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::LogarithmOp,mlir::mps::AddOp &>(mlir::OpBuilder *a1, uint64_t a2, void *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.logarithm", (const unsigned __int8 *)0xD, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    void v15[2] = (uint64_t)"mps.logarithm";
    v15[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3 - 16);
  unint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::LogarithmOp,void>::id) {
    char v10 = v9;
  }
  else {
    char v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::GreaterThanOp,mlir::Value &,mlir::mps::ConstantOp &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, void *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.greater", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.greater";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::EqualToOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4 - 16);
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::GreaterThanOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SelectOp,mlir::mps::GreaterThanOp &,mlir::Value &,mlir::mps::LogarithmOp &>(mlir::OpBuilder *a1, uint64_t a2, void *a3, uint64_t *a4, void *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.select", (const unsigned __int8 *)0xA, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    void v19[2] = (uint64_t)"mps.select";
    void v19[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::SelectOp::build((uint64_t)a1, (uint64_t)v21, *a3 - 16, *a4, *a5 - 16);
  unint64_t v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SelectOp,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

uint64_t mlir::mps::getConstantAttr<int>(uint64_t *a1, int a2)
{
  int v31 = a2;
  uint64_t v32 = 0;
  if (!a1) {
    goto LABEL_10;
  }
  uint64_t v3 = *a1;
  unint64_t v4 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v5 = *(unsigned int *)(v3 + 16);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *(void **)(v3 + 8);
  uint64_t v7 = &v6[2 * v5];
  do
  {
    unint64_t v8 = v5 >> 1;
    uint64_t v9 = &v6[2 * (v5 >> 1)];
    unint64_t v11 = *v9;
    char v10 = v9 + 2;
    v5 += ~(v5 >> 1);
    if (v11 < v4) {
      uint64_t v6 = v10;
    }
    else {
      unint64_t v5 = v8;
    }
  }
  while (v5);
  if (v6 != v7 && *v6 == v4) {
    uint64_t v12 = v6[1];
  }
  else {
LABEL_10:
  }
    uint64_t v12 = 0;
  v30[0] = a1;
  v30[1] = v12;
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(a1);
  v29[0] = &v32;
  v29[1] = v30;
  void v29[2] = &v31;
  uint64_t v14 = *(void **)(*(void *)ElementTypeOrSelf + 136);
  if (v14 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
  {
    mlir::mps::getConstantAttr<int>(mlir::Type,int)::{lambda(mlir::Type)#1}::operator()((uint64_t)v29, ElementTypeOrSelf);
  }
  else
  {
    v28[0] = &v32;
    v28[1] = v30;
    v28[2] = &v31;
    if (v14 == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
    {
      mlir::mps::getConstantAttr<int>(mlir::Type,int)::{lambda(mlir::Type)#2}::operator()((uint64_t)v28, ElementTypeOrSelf);
    }
    else
    {
      v27[0] = &v32;
      v27[1] = v30;
      uint64_t v27[2] = &v31;
      if (v14 == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id) {
        mlir::mps::getConstantAttr<int>(mlir::Type,int)::{lambda(mlir::ComplexType)#1}::operator()((uint64_t)v27, ElementTypeOrSelf);
      }
    }
  }
  return v32;
}

void mlir::mps::getConstantAttr<int>(mlir::Type,int)::{lambda(mlir::Type)#1}::operator()(uint64_t a1, uint64_t a2)
{
  v24[3] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = a2;
  BOOL isF16 = mlir::Type::isF16((mlir::Type *)&v22);
  if (isF16)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    unint64_t v5 = *(llvm::APFloatBase **)v4;
    uint64_t v6 = *(void *)(v4 + 8);
    uint64_t v7 = llvm::APFloatBase::IEEEhalf((llvm::APFloatBase *)isF16);
  }
  else
  {
    BOOL isBF16 = mlir::Type::isBF16((mlir::Type *)&v22);
    if (!isBF16)
    {
      if (mlir::Type::isF32((mlir::Type *)&v22))
      {
        uint64_t v15 = *(uint64_t **)(a1 + 8);
        *(float *)&double v23 = (float)**(int **)(a1 + 16);
        uint64_t v16 = *v15;
        uint64_t v17 = v15[1];
        uint64_t v18 = 4;
        uint64_t v19 = 4;
      }
      else
      {
        mlir::Type::isF64((mlir::Type *)&v22);
        __int16 v20 = *(uint64_t **)(a1 + 8);
        double v23 = (double)**(int **)(a1 + 16);
        uint64_t v16 = *v20;
        uint64_t v17 = v20[1];
        uint64_t v18 = 8;
        uint64_t v19 = 8;
      }
      **(void **)a1 = mlir::DenseElementsAttr::getFromRawBuffer(v16, v17, &v23, v18, v19, 0, 1);
      return;
    }
    uint64_t v9 = *(void *)(a1 + 8);
    unint64_t v5 = *(llvm::APFloatBase **)v9;
    uint64_t v6 = *(void *)(v9 + 8);
    uint64_t v7 = llvm::APFloatBase::BFloat((llvm::APFloatBase *)isBF16);
  }
  char v10 = v7;
  std::to_string(&v21, **(_DWORD **)(a1 + 16));
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v11 = &v21;
  }
  else {
    unint64_t v11 = (std::string *)v21.__r_.__value_.__r.__words[0];
  }
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v21.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v21.__r_.__value_.__l.__size_;
  }
  llvm::APFloat::APFloat((llvm::APFloatBase *)&v23, v10, (unsigned __int8 *)v11, size);
  unint64_t v13 = (llvm::APFloatBase *)mlir::DenseElementsAttr::get(v5, v6, (uint64_t)&v23, 1);
  **(void **)a1 = v13;
  uint64_t v14 = (void *)v24[0];
  if (llvm::APFloatBase::PPCDoubleDouble(v13) == v14)
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v24);
    if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
  }
  else
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v24);
    if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
  }
  operator delete(v21.__r_.__value_.__l.__data_);
}

void mlir::mps::getConstantAttr<int>(mlir::Type,int)::{lambda(mlir::Type)#2}::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = a2;
  BOOL isInteger = mlir::Type::isInteger((mlir::Type *)&v11, 1);
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  if (isInteger)
  {
    LOBYTE(__p) = **(_DWORD **)(a1 + 16) != 0;
    **(void **)a1 = mlir::DenseElementsAttr::get(*v4, v4[1], &__p, 1);
  }
  else
  {
    unsigned int IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&v11);
    uint64_t v6 = **(int **)(a1 + 16);
    BOOL isSignedInteger = mlir::Type::isSignedInteger((mlir::Type *)&v11);
    unsigned int v10 = IntOrFloatBitWidth;
    if (IntOrFloatBitWidth > 0x40)
    {
      llvm::APInt::initSlowCase((llvm::APInt *)&__p, v6, isSignedInteger);
    }
    else
    {
      unint64_t v8 = 0xFFFFFFFFFFFFFFFFLL >> -(char)IntOrFloatBitWidth;
      if (!IntOrFloatBitWidth) {
        unint64_t v8 = 0;
      }
      __p = (void *)(v8 & v6);
    }
    **(void **)a1 = mlir::DenseElementsAttr::get(*v4, v4[1], (llvm::APInt *)&__p, 1);
    if (v10 >= 0x41)
    {
      if (__p) {
        operator delete[](__p);
      }
    }
  }
}

void mlir::mps::getConstantAttr<int>(mlir::Type,int)::{lambda(mlir::ComplexType)#1}::operator()(uint64_t a1, uint64_t a2)
{
  v31[3] = *MEMORY[0x1E4F143B8];
  uint64_t v24 = a2;
  uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v24);
  if (mlir::Type::isF32((mlir::Type *)&Value))
  {
    uint64_t v3 = *(void **)(a1 + 8);
    v27[0] = (float)**(int **)(a1 + 16);
    v27[1] = 0.0;
    **(void **)a1 = mlir::DenseElementsAttr::getFromRawBuffer(*v3, v3[1], v27, 8, 8, 0, 1);
    return;
  }
  BOOL isF16 = mlir::Type::isF16((mlir::Type *)&Value);
  uint64_t v5 = *(void *)(a1 + 8);
  _S0 = (float)**(int **)(a1 + 16);
  __asm { FCVT            H8, S0 }
  uint64_t v12 = llvm::APFloatBase::IEEEhalf((llvm::APFloatBase *)isF16);
  __asm { FCVT            S0, H8; __val }
  std::to_string(&v22, _S0);
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v14 = &v22;
  }
  else {
    uint64_t v14 = (std::string *)v22.__r_.__value_.__r.__words[0];
  }
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v22.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v22.__r_.__value_.__l.__size_;
  }
  llvm::APFloat::APFloat((llvm::APFloatBase *)v27, v12, (unsigned __int8 *)v14, size);
  std::to_string(&v21, 0.0);
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v16 = &v21;
  }
  else {
    uint64_t v16 = (std::string *)v21.__r_.__value_.__r.__words[0];
  }
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v17 = HIBYTE(v21.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v17 = v21.__r_.__value_.__l.__size_;
  }
  uint64_t v18 = llvm::APFloat::APFloat((llvm::APFloatBase *)v25, v12, (unsigned __int8 *)v16, v17);
  uint64_t v19 = (void *)v28[0];
  __int16 v20 = llvm::APFloatBase::PPCDoubleDouble(v18);
  if (v20 == v19) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v30, (const llvm::detail::DoubleAPFloat *)v28);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v30, (const llvm::detail::IEEEFloat *)v28);
  }
  if (v20 == (void *)v26[0]) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v31, (const llvm::detail::DoubleAPFloat *)v26);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v31, (const llvm::detail::IEEEFloat *)v26);
  }
  **(void **)a1 = mlir::DenseElementsAttr::get(*(llvm::APFloatBase **)v5, *(void *)(v5 + 8), (uint64_t)v29, 1);
  if (v20 == (void *)v31[0]) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v31);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v31);
  }
  if (v20 == (void *)v30[0]) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v30);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v30);
  }
  if (v20 != (void *)v26[0])
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v26);
    if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_30;
    }
    goto LABEL_29;
  }
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v26);
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
LABEL_29:
  }
    operator delete(v21.__r_.__value_.__l.__data_);
LABEL_30:
  if (v20 != (void *)v28[0])
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v28);
    if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_32;
  }
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v28);
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
LABEL_32:
  }
    operator delete(v22.__r_.__value_.__l.__data_);
}

uint64_t mlir::mps::getConstantAttr<float>(uint64_t *a1, float a2)
{
  float v31 = a2;
  uint64_t v32 = 0;
  if (!a1) {
    goto LABEL_10;
  }
  uint64_t v3 = *a1;
  unint64_t v4 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v5 = *(unsigned int *)(v3 + 16);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *(void **)(v3 + 8);
  uint64_t v7 = &v6[2 * v5];
  do
  {
    unint64_t v8 = v5 >> 1;
    uint64_t v9 = &v6[2 * (v5 >> 1)];
    unint64_t v11 = *v9;
    unsigned int v10 = v9 + 2;
    v5 += ~(v5 >> 1);
    if (v11 < v4) {
      uint64_t v6 = v10;
    }
    else {
      unint64_t v5 = v8;
    }
  }
  while (v5);
  if (v6 != v7 && *v6 == v4) {
    uint64_t v12 = v6[1];
  }
  else {
LABEL_10:
  }
    uint64_t v12 = 0;
  v30[0] = a1;
  v30[1] = v12;
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(a1);
  v29[0] = &v32;
  v29[1] = v30;
  void v29[2] = &v31;
  uint64_t v14 = *(void **)(*(void *)ElementTypeOrSelf + 136);
  if (v14 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
  {
    mlir::mps::getConstantAttr<float>(mlir::Type,float)::{lambda(mlir::Type)#1}::operator()((uint64_t)v29, ElementTypeOrSelf);
  }
  else
  {
    v28[0] = &v32;
    v28[1] = v30;
    v28[2] = &v31;
    if (v14 == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
    {
      mlir::mps::getConstantAttr<float>(mlir::Type,float)::{lambda(mlir::Type)#2}::operator()((uint64_t)v28, ElementTypeOrSelf);
    }
    else
    {
      v27[0] = &v32;
      v27[1] = v30;
      float v27[2] = &v31;
      if (v14 == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id) {
        mlir::mps::getConstantAttr<float>(mlir::Type,float)::{lambda(mlir::ComplexType)#1}::operator()((uint64_t)v27, ElementTypeOrSelf);
      }
    }
  }
  return v32;
}

void mlir::mps::getConstantAttr<float>(mlir::Type,float)::{lambda(mlir::Type)#1}::operator()(uint64_t a1, uint64_t a2)
{
  v24[3] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = a2;
  BOOL isF16 = mlir::Type::isF16((mlir::Type *)&v22);
  if (isF16)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    unint64_t v5 = *(llvm::APFloatBase **)v4;
    uint64_t v6 = *(void *)(v4 + 8);
    uint64_t v7 = llvm::APFloatBase::IEEEhalf((llvm::APFloatBase *)isF16);
  }
  else
  {
    BOOL isBF16 = mlir::Type::isBF16((mlir::Type *)&v22);
    if (!isBF16)
    {
      if (mlir::Type::isF32((mlir::Type *)&v22))
      {
        uint64_t v15 = *(uint64_t **)(a1 + 8);
        LODWORD(v23) = **(_DWORD **)(a1 + 16);
        uint64_t v16 = *v15;
        uint64_t v17 = v15[1];
        uint64_t v18 = 4;
        uint64_t v19 = 4;
      }
      else
      {
        mlir::Type::isF64((mlir::Type *)&v22);
        __int16 v20 = *(uint64_t **)(a1 + 8);
        double v23 = **(float **)(a1 + 16);
        uint64_t v16 = *v20;
        uint64_t v17 = v20[1];
        uint64_t v18 = 8;
        uint64_t v19 = 8;
      }
      **(void **)a1 = mlir::DenseElementsAttr::getFromRawBuffer(v16, v17, &v23, v18, v19, 0, 1);
      return;
    }
    uint64_t v9 = *(void *)(a1 + 8);
    unint64_t v5 = *(llvm::APFloatBase **)v9;
    uint64_t v6 = *(void *)(v9 + 8);
    uint64_t v7 = llvm::APFloatBase::BFloat((llvm::APFloatBase *)isBF16);
  }
  unsigned int v10 = v7;
  std::to_string(&v21, **(float **)(a1 + 16));
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v11 = &v21;
  }
  else {
    unint64_t v11 = (std::string *)v21.__r_.__value_.__r.__words[0];
  }
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v21.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v21.__r_.__value_.__l.__size_;
  }
  llvm::APFloat::APFloat((llvm::APFloatBase *)&v23, v10, (unsigned __int8 *)v11, size);
  unint64_t v13 = (llvm::APFloatBase *)mlir::DenseElementsAttr::get(v5, v6, (uint64_t)&v23, 1);
  **(void **)a1 = v13;
  uint64_t v14 = (void *)v24[0];
  if (llvm::APFloatBase::PPCDoubleDouble(v13) == v14)
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v24);
    if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
  }
  else
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v24);
    if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
  }
  operator delete(v21.__r_.__value_.__l.__data_);
}

void mlir::mps::getConstantAttr<float>(mlir::Type,float)::{lambda(mlir::Type)#2}::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = a2;
  BOOL isInteger = mlir::Type::isInteger((mlir::Type *)&v11, 1);
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  if (isInteger)
  {
    LOBYTE(__p) = **(float **)(a1 + 16) != 0.0;
    **(void **)a1 = mlir::DenseElementsAttr::get(*v4, v4[1], &__p, 1);
  }
  else
  {
    unsigned int IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&v11);
    uint64_t v6 = (unint64_t)**(float **)(a1 + 16);
    BOOL isSignedInteger = mlir::Type::isSignedInteger((mlir::Type *)&v11);
    unsigned int v10 = IntOrFloatBitWidth;
    if (IntOrFloatBitWidth > 0x40)
    {
      llvm::APInt::initSlowCase((llvm::APInt *)&__p, v6, isSignedInteger);
    }
    else
    {
      unint64_t v8 = 0xFFFFFFFFFFFFFFFFLL >> -(char)IntOrFloatBitWidth;
      if (!IntOrFloatBitWidth) {
        unint64_t v8 = 0;
      }
      __p = (void *)(v8 & v6);
    }
    **(void **)a1 = mlir::DenseElementsAttr::get(*v4, v4[1], (llvm::APInt *)&__p, 1);
    if (v10 >= 0x41)
    {
      if (__p) {
        operator delete[](__p);
      }
    }
  }
}

void mlir::mps::getConstantAttr<float>(mlir::Type,float)::{lambda(mlir::ComplexType)#1}::operator()(uint64_t a1, uint64_t a2)
{
  v31[3] = *MEMORY[0x1E4F143B8];
  uint64_t v24 = a2;
  uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v24);
  if (mlir::Type::isF32((mlir::Type *)&Value))
  {
    uint64_t v3 = *(void **)(a1 + 8);
    v27[0] = **(_DWORD **)(a1 + 16);
    v27[1] = 0;
    **(void **)a1 = mlir::DenseElementsAttr::getFromRawBuffer(*v3, v3[1], v27, 8, 8, 0, 1);
    return;
  }
  BOOL isF16 = mlir::Type::isF16((mlir::Type *)&Value);
  uint64_t v5 = *(void *)(a1 + 8);
  _S0 = **(_DWORD **)(a1 + 16);
  __asm { FCVT            H8, S0 }
  uint64_t v12 = llvm::APFloatBase::IEEEhalf((llvm::APFloatBase *)isF16);
  __asm { FCVT            S0, H8; __val }
  std::to_string(&v22, _S0);
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v14 = &v22;
  }
  else {
    uint64_t v14 = (std::string *)v22.__r_.__value_.__r.__words[0];
  }
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v22.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v22.__r_.__value_.__l.__size_;
  }
  llvm::APFloat::APFloat((llvm::APFloatBase *)v27, v12, (unsigned __int8 *)v14, size);
  std::to_string(&v21, 0.0);
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v16 = &v21;
  }
  else {
    uint64_t v16 = (std::string *)v21.__r_.__value_.__r.__words[0];
  }
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v17 = HIBYTE(v21.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v17 = v21.__r_.__value_.__l.__size_;
  }
  uint64_t v18 = llvm::APFloat::APFloat((llvm::APFloatBase *)v25, v12, (unsigned __int8 *)v16, v17);
  uint64_t v19 = (void *)v28[0];
  __int16 v20 = llvm::APFloatBase::PPCDoubleDouble(v18);
  if (v20 == v19) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v30, (const llvm::detail::DoubleAPFloat *)v28);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v30, (const llvm::detail::IEEEFloat *)v28);
  }
  if (v20 == (void *)v26[0]) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v31, (const llvm::detail::DoubleAPFloat *)v26);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v31, (const llvm::detail::IEEEFloat *)v26);
  }
  **(void **)a1 = mlir::DenseElementsAttr::get(*(llvm::APFloatBase **)v5, *(void *)(v5 + 8), (uint64_t)v29, 1);
  if (v20 == (void *)v31[0]) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v31);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v31);
  }
  if (v20 == (void *)v30[0]) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v30);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v30);
  }
  if (v20 != (void *)v26[0])
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v26);
    if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_30;
    }
    goto LABEL_29;
  }
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v26);
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
LABEL_29:
  }
    operator delete(v21.__r_.__value_.__l.__data_);
LABEL_30:
  if (v20 != (void *)v28[0])
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v28);
    if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_32;
  }
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v28);
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
LABEL_32:
  }
    operator delete(v22.__r_.__value_.__l.__data_);
}

void mlir::mps::anonymous namespace'::LowerSoftplusParametric::~LowerSoftplusParametric(mlir::mps::_anonymous_namespace_::LowerSoftplusParametric *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SoftplusParametricOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SoftplusParametricOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SoftplusParametricOpGenericAdaptorBase::SoftplusParametricOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SoftplusParametricOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SoftplusParametricOpGenericAdaptorBase::SoftplusParametricOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::mps::anonymous namespace'::LowerSoftplusParametric::matchAndRewrite(int a1, uint64_t a2, mlir::scf::detail::IfOpGenericAdaptorBase *this, uint64_t a4)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  unsigned int ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 0);
  unint64_t v8 = *((void *)this + 5);
  unint64_t v58 = v8;
  uint64_t v59 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    unint64_t v8 = mlir::ValueRange::offset_base(&v58, ODSOperandIndexAndLength);
  }
  unint64_t v58 = v8;
  uint64_t v59 = 0;
  uint64_t v9 = mlir::ValueRange::dereference_iterator(&v58, 0);
  uint64_t v55 = v9;
  unsigned int v10 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 3u);
  unint64_t v11 = *((void *)this + 5);
  unint64_t v58 = v11;
  uint64_t v59 = v10;
  if (v10) {
    unint64_t v11 = mlir::ValueRange::offset_base(&v58, v10);
  }
  unint64_t v58 = v11;
  uint64_t v59 = 0;
  uint64_t v12 = mlir::ValueRange::dereference_iterator(&v58, 0);
  uint64_t v54 = v12;
  unsigned int v13 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 1u);
  unint64_t v14 = *((void *)this + 5);
  unint64_t v58 = v14;
  uint64_t v59 = v13;
  if (v13) {
    unint64_t v14 = mlir::ValueRange::offset_base(&v58, v13);
  }
  unint64_t v58 = v14;
  uint64_t v59 = 0;
  uint64_t v53 = mlir::ValueRange::dereference_iterator(&v58, 0);
  unsigned int v15 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 2u);
  unint64_t v16 = *((void *)this + 5);
  unint64_t v58 = v16;
  uint64_t v59 = v15;
  if (v15) {
    unint64_t v16 = mlir::ValueRange::offset_base(&v58, v15);
  }
  unint64_t v58 = v16;
  uint64_t v59 = 0;
  unint64_t v58 = mlir::ValueRange::dereference_iterator(&v58, 0);
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v9);
  uint64_t v52 = ElementTypeOrSelf;
  uint64_t v51 = mlir::getElementTypeOrSelf(v12);
  uint64_t v18 = (char *)mlir::OpBuilder::create<mlir::mps::RankOp,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(void *)(a2 + 24), &v55)- 16;
  uint64_t v50 = v18;
  uint64_t v19 = *(void *)(a2 + 24);
  long long v20 = *(_OWORD *)(a4 + 24);
  v47[0] = *(_OWORD *)(a4 + 8);
  v47[1] = v20;
  LODWORD(v46) = 0;
  SI32TensorAttr = (uint64_t *)mlir::getSI32TensorAttr((mlir::Builder *)v47, (uint64_t)&v46, 1);
  std::string v21 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v19, &SI32TensorAttr)- 16);
  unint64_t v49 = v21;
  long long v22 = *(_OWORD *)(a4 + 24);
  v45[0] = *(_OWORD *)(a4 + 8);
  v45[1] = v22;
  LODWORD(v44) = 1;
  unint64_t v46 = (uint64_t *)mlir::getSI32TensorAttr((mlir::Builder *)v45, (uint64_t)&v44, 1);
  double v23 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v19, &v46)- 16);
  SI32TensorAttr = v23;
  v43[0] = *(_OWORD *)(a4 + 8);
  v43[1] = *(_OWORD *)(a4 + 24);
  LODWORD(v42) = -1;
  unint64_t v44 = (uint64_t *)mlir::getSI32TensorAttr((mlir::Builder *)v43, (uint64_t)&v42, 1);
  unint64_t v46 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v19, &v44)- 16);
  unint64_t v44 = v21;
  uint64_t v41 = v18;
  unint64_t v42 = v23;
  if (!mlir::Type::isInteger((mlir::Type *)&v51, 32) || !mlir::Type::isSignedInteger((mlir::Type *)&v51))
  {
    unint64_t v44 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)(a4 + 8), v19, (uint64_t *)&v49, &v51)- 16);
    unint64_t v42 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)(a4 + 8), v19, (uint64_t *)&SI32TensorAttr, &v51)- 16);
    mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)(a4 + 8), v19, (uint64_t *)&v46, &v51);
  }
  uint64_t v24 = mlir::getElementTypeOrSelf((uint64_t)v18);
  if (v51 != v24) {
    uint64_t v41 = (char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)(a4 + 8), v19, (uint64_t *)&v50, &v51)- 16;
  }
  uint64_t v40 = (uint64_t)mlir::OpBuilder::create<mlir::mps::LessThanOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), v19, &v54, (uint64_t *)&v44)- 16;
  uint64_t v39 = (uint64_t)mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)(a4 + 8), v19, &v54, (uint64_t *)&v41)- 16;
  uint64_t v38 = (uint64_t)mlir::OpBuilder::create<mlir::mps::SelectOp,mlir::Value &,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), v19, &v40, &v39, &v54)- 16;
  uint64_t v37 = (uint64_t)mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::Value &>((mlir::Float32Type **)(a4 + 8), v19, (uint64_t *)&v41, &v38)- 16;
  uint64_t v36 = (uint64_t)mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::Value &>((mlir::Float32Type **)(a4 + 8), v19, &v37, (uint64_t *)&v42)- 16;
  uint64_t v35 = (uint64_t)mlir::OpBuilder::create<mlir::mps::GetCoordOp,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), v19, &v36, (uint64_t *)&v49)- 16;
  uint64_t v34 = (uint64_t)mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)(a4 + 8), v19, &v35, (uint64_t *)&SI32TensorAttr)- 16;
  uint64_t v33 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), v19, &v53, &v34)- 16;
  uint64_t v25 = (char *)mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), v19, (uint64_t *)&v58, &v34)- 16;
  uint64_t v31 = v33;
  uint64_t v32 = v25;
  if (ElementTypeOrSelf != mlir::getElementTypeOrSelf(v33)) {
    uint64_t v31 = (uint64_t)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)(a4 + 8), v19, &v33, &v52)- 16;
  }
  unint64_t v30 = v25;
  uint64_t v26 = mlir::getElementTypeOrSelf((uint64_t)v25);
  if (v52 != v26) {
    unint64_t v30 = (char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)(a4 + 8), v19, (uint64_t *)&v32, &v52)- 16;
  }
  uint64_t v29 = (uint64_t)mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)(a4 + 8), v19, (uint64_t *)&v30, &v55)- 16;
  uint64_t v28 = (uint64_t)mlir::OpBuilder::create<mlir::mps::SoftplusOp,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), v19, &v29)
      - 16;
  unint64_t v56 = (char *)mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)(a4 + 8), v19, &v31, &v28)- 16;
  mlir::ValueRange::ValueRange(v57, (uint64_t)&v56, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, v57[0], v57[1]);
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::LessThanOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.less", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.less";
    v17[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::EqualToOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  unint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::LessThanOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SelectOp,mlir::Value &,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.select", (const unsigned __int8 *)0xA, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    void v19[2] = (uint64_t)"mps.select";
    void v19[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::SelectOp::build((uint64_t)a1, (uint64_t)v21, *a3, *a4, *a5);
  unsigned int v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SelectOp,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.subtract", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.subtract";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SubtractOp,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::GetCoordOp,mlir::Value &,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.get_coordinates", (const unsigned __int8 *)0x13, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.get_coordinates";
    v17[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::GetCoordOp::build(a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::GetCoordOp,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SoftplusOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.softplus", (const unsigned __int8 *)0xC, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    void v15[2] = (uint64_t)"mps.softplus";
    v15[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SoftplusOp,void>::id) {
    char v10 = v9;
  }
  else {
    char v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

void mlir::mps::anonymous namespace'::LowerNonZero::~LowerNonZero(mlir::mps::_anonymous_namespace_::LowerNonZero *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::NonZeroOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::NonZeroOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::NonZeroOpGenericAdaptorBase::NonZeroOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::NonZeroOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::NonZeroOpGenericAdaptorBase::NonZeroOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::mps::anonymous namespace'::LowerNonZero::matchAndRewrite(int a1, uint64_t a2, uint64_t **this, uint64_t a4)
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  unsigned int ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)this, 0);
  unint64_t v8 = this[5];
  SI32TensorAttr = v8;
  uint64_t v83 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    unint64_t v8 = (uint64_t *)mlir::ValueRange::offset_base(&SI32TensorAttr, ODSOperandIndexAndLength);
  }
  SI32TensorAttr = v8;
  uint64_t v83 = 0;
  unint64_t v9 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&SI32TensorAttr, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v9) {
    goto LABEL_12;
  }
  uint64_t v10 = *v9;
  unint64_t v11 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v12 = *(unsigned int *)(v10 + 16);
  if (!v12) {
    goto LABEL_12;
  }
  unint64_t v13 = *(void **)(v10 + 8);
  unint64_t v14 = &v13[2 * v12];
  do
  {
    unint64_t v15 = v12 >> 1;
    __int16 v16 = &v13[2 * (v12 >> 1)];
    unint64_t v18 = *v16;
    std::string::size_type v17 = v16 + 2;
    v12 += ~(v12 >> 1);
    if (v18 < v11) {
      unint64_t v13 = v17;
    }
    else {
      unint64_t v12 = v15;
    }
  }
  while (v12);
  if (v13 != v14 && *v13 == v11) {
    uint64_t v19 = v13[1];
  }
  else {
LABEL_12:
  }
    uint64_t v19 = 0;
  v79[0] = v9;
  v79[1] = v19;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v79)) {
    return 0;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v79);
  uint64_t v21 = v20;
  uint64_t v22 = *(void *)(a2 + 24);
  long long v23 = *(_OWORD *)(a4 + 24);
  v77[0] = *(_OWORD *)(a4 + 8);
  v77[1] = v23;
  LODWORD(v81[0]) = -1;
  SI32TensorAttr = (uint64_t *)mlir::getSI32TensorAttr((mlir::Builder *)v77, (uint64_t)v81, 1);
  uint64_t v78 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v22, &SI32TensorAttr)- 16;
  uint64_t v24 = *(void *)(a2 + 24);
  long long v25 = *(_OWORD *)(a4 + 24);
  v75[0] = *(_OWORD *)(a4 + 8);
  v75[1] = v25;
  LODWORD(v81[0]) = 0;
  SI32TensorAttr = (uint64_t *)mlir::getSI32TensorAttr((mlir::Builder *)v75, (uint64_t)v81, 1);
  uint64_t v76 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v24, &SI32TensorAttr)- 16;
  uint64_t v26 = *(void *)(a2 + 24);
  long long v27 = *(_OWORD *)(a4 + 24);
  v73[0] = *(_OWORD *)(a4 + 8);
  v73[1] = v27;
  LODWORD(v81[0]) = 1;
  SI32TensorAttr = (uint64_t *)mlir::getSI32TensorAttr((mlir::Builder *)v73, (uint64_t)v81, 1);
  uint64_t v74 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v26, &SI32TensorAttr)- 16;
  uint64_t v28 = *(void *)(a2 + 24);
  long long v29 = *(_OWORD *)(a4 + 24);
  v71[0] = *(_OWORD *)(a4 + 8);
  v71[1] = v29;
  LODWORD(v81[0]) = -1;
  SI32TensorAttr = (uint64_t *)mlir::getSI32TensorAttr((mlir::Builder *)v71, (uint64_t)v81, 1);
  uint64_t v72 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v28, &SI32TensorAttr)- 16;
  uint64_t v30 = *(void *)(a2 + 24);
  unsigned int v31 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)this, 0);
  uint64_t v32 = this[5];
  SI32TensorAttr = v32;
  uint64_t v83 = v31;
  if (v31) {
    uint64_t v32 = (uint64_t *)mlir::ValueRange::offset_base(&SI32TensorAttr, v31);
  }
  SI32TensorAttr = v32;
  uint64_t v83 = 0;
  uint64_t v33 = mlir::ValueRange::dereference_iterator(&SI32TensorAttr, 0);
  SI32TensorAttr = (uint64_t *)mlir::getElementTypeOrSelf(v33);
  uint64_t v70 = (uint64_t)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)(a4 + 8), v30, &v76, (uint64_t *)&SI32TensorAttr)- 16;
  uint64_t v34 = *(void *)(a2 + 24);
  unsigned int v35 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)this, 0);
  uint64_t v36 = this[5];
  SI32TensorAttr = v36;
  uint64_t v83 = v35;
  if (v35) {
    uint64_t v36 = (uint64_t *)mlir::ValueRange::offset_base(&SI32TensorAttr, v35);
  }
  SI32TensorAttr = v36;
  uint64_t v83 = 0;
  SI32TensorAttr = (uint64_t *)mlir::ValueRange::dereference_iterator(&SI32TensorAttr, 0);
  uint64_t v69 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,mlir::Value&>((mlir::UnitAttr **)(a4 + 8), v34, (uint64_t *)&SI32TensorAttr, &v78)- 16;
  uint64_t v68 = (uint64_t)mlir::OpBuilder::create<mlir::mps::NotEqualToOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(void *)(a2 + 24), &v69, &v70)- 16;
  uint64_t v67 = (uint64_t)mlir::OpBuilder::create<mlir::mps::SelectOp,mlir::Value &,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(void *)(a2 + 24), &v68, &v74, &v76)- 16;
  uint64_t v37 = *(void *)(a2 + 24);
  SI32TensorAttr = (uint64_t *)mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x20u, 1);
  uint64_t v66 = (uint64_t)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)(a4 + 8), v37, &v67, (uint64_t *)&SI32TensorAttr)- 16;
  uint64_t v38 = *(void *)(a2 + 24);
  LOBYTE(SI32TensorAttr) = 0;
  uint64_t v65 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::Value &,mlir::Value &,BOOL &>((mlir::UnitAttr **)(a4 + 8), v38, &v66, &v76, (unsigned __int8 *)&SI32TensorAttr)- 16;
  uint64_t v39 = *(void *)(a2 + 24);
  unsigned int v40 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)this, 0);
  uint64_t v41 = this[5];
  SI32TensorAttr = v41;
  uint64_t v83 = v40;
  if (v40) {
    uint64_t v41 = (uint64_t *)mlir::ValueRange::offset_base(&SI32TensorAttr, v40);
  }
  SI32TensorAttr = v41;
  uint64_t v83 = 0;
  SI32TensorAttr = (uint64_t *)mlir::ValueRange::dereference_iterator(&SI32TensorAttr, 0);
  uint64_t v64 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ShapeOp,mlir::Value>((mlir::OpBuilder *)(a4 + 8), v39, (uint64_t *)&SI32TensorAttr)- 16;
  int v63 = 0;
  if (v21 < 1)
  {
    unint64_t v49 = 0;
  }
  else
  {
    unint64_t v42 = 0;
    do
    {
      uint64_t v43 = *(void *)(a2 + 24);
      long long v44 = *(_OWORD *)(a4 + 24);
      v61[0] = *(_OWORD *)(a4 + 8);
      v61[1] = v44;
      SI32TensorAttr = (uint64_t *)mlir::getSI32TensorAttr((mlir::Builder *)v61, (uint64_t)&v63, 1);
      uint64_t v62 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v43, &SI32TensorAttr)- 16;
      uint64_t v60 = (uint64_t)mlir::OpBuilder::create<mlir::mps::GetCoordOp,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v64, &v62)- 16;
      uint64_t v59 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,mlir::Value&>((mlir::UnitAttr **)(a4 + 8), *(void *)(a2 + 24), &v60, &v78)- 16;
      uint64_t v45 = *(void *)(a2 + 24);
      LOBYTE(SI32TensorAttr) = 1;
      LOBYTE(v81[0]) = 0;
      uint64_t v58 = (uint64_t)mlir::OpBuilder::create<mlir::mps::CumulativeSumOp,mlir::Value &,mlir::Value &,BOOL,BOOL>((mlir::UnitAttr **)(a4 + 8), v45, &v67, &v76, (unsigned __int8 *)&SI32TensorAttr, (unsigned __int8 *)v81)- 16;
      uint64_t v57 = (uint64_t)mlir::OpBuilder::create<mlir::mps::SelectOp,mlir::Value &,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(void *)(a2 + 24), &v68, &v58, &v72)- 16;
      uint64_t v56 = (uint64_t)mlir::OpBuilder::create<mlir::mps::BroadcastToOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(void *)(a2 + 24), &v76, &v65)- 16;
      uint64_t v46 = *(void *)(a2 + 24);
      SI32TensorAttr = (uint64_t *)mlir::getElementTypeOrSelf(v59);
      uint64_t v56 = (uint64_t)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)(a4 + 8), v46, &v56, (uint64_t *)&SI32TensorAttr)- 16;
      uint64_t v47 = *(void *)(a2 + 24);
      LODWORD(SI32TensorAttr) = 6;
      uint64_t v55 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::ScatterOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,mlir::mps::ScatterMode>((mlir::MLIRContext **)(a4 + 8), v47, &v56, &v59, &v57, &v76, (unsigned int *)&SI32TensorAttr)- 16);
      uint64_t v55 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(void *)(a2 + 24), (uint64_t *)&v55, &v74)- 16);
      uint64_t v48 = *(void *)(a2 + 24);
      SI32TensorAttr = (uint64_t *)mlir::getElementTypeOrSelf((void *)(*(void *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8));
      unint64_t v49 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)(a4 + 8), v48, (uint64_t *)&v55, (uint64_t *)&SI32TensorAttr)- 16);
      uint64_t v55 = v49;
      int v50 = v63;
      if (v63)
      {
        uint64_t v51 = *(void *)(a2 + 24);
        v81[0] = v42;
        v81[1] = v49;
        mlir::ValueRange::ValueRange((unint64_t *)&SI32TensorAttr, (uint64_t)v81, 2uLL);
        unsigned __int8 v54 = 0;
        unint64_t v49 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::ConcatOp,mlir::ValueRange,mlir::Value &,BOOL>((mlir::UnitAttr **)(a4 + 8), v51, (uint64_t *)&SI32TensorAttr, &v74, &v54)- 16);
        int v50 = v63;
      }
      int v63 = v50 + 1;
      unint64_t v42 = v49;
    }
    while (v21 > v50 + 1);
  }
  SI32TensorAttr = v49;
  uint64_t v52 = 1;
  mlir::ValueRange::ValueRange(v80, (uint64_t)&SI32TensorAttr, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, v80[0], v80[1]);
  return v52;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::NotEqualToOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.not_equal", (const unsigned __int8 *)0xD, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.not_equal";
    v17[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::EqualToOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  unint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::NotEqualToOp,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::CumulativeSumOp,mlir::Value &,mlir::Value &,BOOL,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned __int8 *a5, unsigned __int8 *a6)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cumulative_sum", (const unsigned __int8 *)0x12, Context);
  if (!v14)
  {
    __int16 v22 = 1283;
    unint64_t v21[2] = (uint64_t)"mps.cumulative_sum";
    v21[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::mps::CumulativeSumOp::build(a1, (uint64_t)v23, *a3, *a4, *a5, *a6);
  unint64_t v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::CumulativeSumOp,void>::id) {
    __int16 v16 = v15;
  }
  else {
    __int16 v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::BroadcastToOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.broadcast_to", (const unsigned __int8 *)0x10, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.broadcast_to";
    v17[3] = 16;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::BroadcastToOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  unint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::BroadcastToOp,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ScatterOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,mlir::mps::ScatterMode>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, unsigned int *a7)
{
  v25[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.scatter", (const unsigned __int8 *)0xB, Context);
  if (!v16)
  {
    __int16 v24 = 1283;
    uint64_t v23[2] = (uint64_t)"mps.scatter";
    v23[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a2, v15);
  mlir::mps::ScatterOp::build(a1, (uint64_t)v25, *a3, *a4, *a5, *a6, *a7);
  std::string::size_type v17 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v25);
  if (*(_UNKNOWN **)(*((void *)v17 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ScatterOp,void>::id) {
    __int16 v18 = v17;
  }
  else {
    __int16 v18 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
  return v18;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ConcatOp,mlir::ValueRange,mlir::Value &,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned __int8 *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.concat", (const unsigned __int8 *)0xA, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    void v19[2] = (uint64_t)"mps.concat";
    void v19[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::ConcatOp::build(a1, (uint64_t)v21, *a3, a3[1], *a4, *a5);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConcatOp,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void mlir::mps::anonymous namespace'::LowerSigmoid::~LowerSigmoid(mlir::mps::_anonymous_namespace_::LowerSigmoid *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SigmoidOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SigmoidOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SigmoidOpGenericAdaptorBase::SigmoidOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SigmoidOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SigmoidOpGenericAdaptorBase::SigmoidOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::mps::anonymous namespace'::LowerSigmoid::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::scf::detail::IfOpGenericAdaptorBase *a3, uint64_t a4)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a2 + 24);
  unint64_t v8 = (mlir::OpBuilder *)(a4 + 8);
  LODWORD(v17) = 1;
  uint64_t v16 = mlir::OpBuilder::create<mlir::mps::ConstantOp,int>((mlir::mps::ConstantOp *)(a4 + 8), v7, (unsigned int *)&v17);
  unsigned int ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(a3, 0);
  unint64_t v10 = *((void *)a3 + 5);
  std::string::size_type v17 = (mlir::GenericProgramPoint *)v10;
  uint64_t v18 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    unint64_t v10 = mlir::ValueRange::offset_base(&v17, ODSOperandIndexAndLength);
  }
  std::string::size_type v17 = (mlir::GenericProgramPoint *)v10;
  uint64_t v18 = 0;
  uint64_t v15 = mlir::ValueRange::dereference_iterator(&v17, 0);
  std::string::size_type v17 = mlir::OpBuilder::create<mlir::mps::NegativeOp,mlir::Value>(v8, v7, &v15);
  uint64_t v15 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ExponentOp,mlir::mps::NegativeOp &>(v8, v7, &v17);
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v15 - 16);
  unint64_t v14 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::mps::ConstantOp &,mlir::Type>((mlir::UnknownLoc **)v8, v7, &v16, &ElementTypeOrSelf);
  uint64_t ElementTypeOrSelf = (uint64_t)mlir::OpBuilder::create<mlir::mps::AddOp,mlir::mps::SubtractOp &,mlir::mps::ConstantOp>((mlir::Float32Type **)v8, v7, &v15, &v14);
  uint64_t v11 = mlir::OpBuilder::create<mlir::mps::ReciprocalOp,mlir::mps::AddOp &>(v8, *(void *)(a2 + 24), &ElementTypeOrSelf);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, a2, v11);
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::NegativeOp,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.negative", (const unsigned __int8 *)0xC, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    void v15[2] = (uint64_t)"mps.negative";
    v15[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3);
  unint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::NegativeOp,void>::id) {
    unint64_t v10 = v9;
  }
  else {
    unint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ExponentOp,mlir::mps::NegativeOp &>(mlir::OpBuilder *a1, uint64_t a2, void *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.exponent", (const unsigned __int8 *)0xC, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    void v15[2] = (uint64_t)"mps.exponent";
    v15[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3 - 16);
  unint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ExponentOp,void>::id) {
    unint64_t v10 = v9;
  }
  else {
    unint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::CastOp,mlir::mps::ConstantOp &,mlir::Type>(mlir::UnknownLoc **a1, uint64_t a2, void *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.cast";
    v17[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::CastOp::build(a1, (uint64_t)v19, *a3 - 16, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::CastOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReciprocalOp,mlir::mps::AddOp &>(mlir::OpBuilder *a1, uint64_t a2, void *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reciprocal", (const unsigned __int8 *)0xE, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    void v15[2] = (uint64_t)"mps.reciprocal";
    v15[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3 - 16);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReciprocalOp,void>::id) {
    char v10 = v9;
  }
  else {
    char v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

void mlir::mps::anonymous namespace'::LowerArithSelect::~LowerArithSelect(mlir::mps::_anonymous_namespace_::LowerArithSelect *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::arith::SelectOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::arith::SelectOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::arith::detail::SelectOpGenericAdaptorBase::SelectOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::arith::SelectOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::arith::detail::SelectOpGenericAdaptorBase::SelectOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

BOOL mlir::mps::anonymous namespace'::LowerArithSelect::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v24 = a2;
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v24);
  __int16 v22 = (uint64_t *)(*(void *)(Input + 8) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v23 = Input;
  uint64_t v6 = *v22;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  unint64_t v9 = *(void **)(v6 + 8);
  char v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    unint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      unint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 == v10 || *v9 != v7 || !v9[1])
  {
LABEL_10:
    BOOL result = mlir::Type::isInteger((mlir::Type *)&v22, 1);
    if (!result) {
      return result;
    }
    uint64_t Loc = mlir::Value::getLoc((mlir::Value *)&v23);
    uint64_t v23 = (uint64_t)mlir::OpBuilder::create<mlir::tensor::FromElementsOp,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), Loc, (uint64_t)&v23)- 16;
    uint64_t v17 = mlir::Value::getLoc((mlir::Value *)&v23);
    v21[0] = 0;
    v21[1] = 0;
    uint64_t v23 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::ArrayRef<long long>>((mlir::Builder *)(a4 + 8), v17, &v23, (uint64_t)v21)- 16;
  }
  uint64_t v18 = v24;
  v21[0] = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v24);
  uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v24);
  uint64_t v19 = mlir::OpBuilder::create<mlir::mps::SelectOp,mlir::Value &,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(void *)(v18 + 24), &v23, v21, &Bias);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v18, v19);
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::tensor::FromElementsOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.from_elements", (const unsigned __int8 *)0x14, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    void v15[2] = (uint64_t)"tensor.from_elements";
    v15[3] = 20;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::tensor::FromElementsOp::build((uint64_t)a1, (uint64_t)v17, a3, 1);
  unint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::FromElementsOp,void>::id) {
    char v10 = v9;
  }
  else {
    char v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::ArrayRef<long long>>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reshape", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.reshape";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ReshapeOp::build(a1, v19, *a3, *(void *)a4, *(uint64_t **)(a4 + 8));
  unint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *mlir::mps::anonymous namespace'::LowerInterleave<mlir::mpsx::DeinterleaveOp>::~LowerInterleave(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::mps::anonymous namespace'::LowerInterleave<mlir::mpsx::DeinterleaveOp>::~LowerInterleave(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mpsx::DeinterleaveOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mpsx::DeinterleaveOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mpsx::detail::DeinterleaveOpGenericAdaptorBase::DeinterleaveOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mpsx::DeinterleaveOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mpsx::detail::DeinterleaveOpGenericAdaptorBase::DeinterleaveOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::mps::anonymous namespace'::LowerInterleave<mlir::mpsx::DeinterleaveOp>::matchAndRewrite(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  unsigned __int8 v54 = a2;
  long long v62 = *(_OWORD *)(a3 + 40);
  uint64_t v5 = a2[3];
  signed int Axis = mlir::anec::Concat::getAxis((mlir::Operation **)&v54);
  if (mlir::getANENextSupportedInterleaveValue(Axis) == Axis)
  {
    uint64_t v56 = 1;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x20u, 1);
    unint64_t v8 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&v56, 1, IntegerType, 0);
    unint64_t v9 = v8;
    if (!v8) {
      goto LABEL_11;
    }
    uint64_t v10 = *v8;
    unint64_t v11 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v12 = *(unsigned int *)(v10 + 16);
    if (!v12) {
      goto LABEL_11;
    }
    unint64_t v13 = *(void **)(v10 + 8);
    unint64_t v14 = &v13[2 * v12];
    do
    {
      unint64_t v15 = v12 >> 1;
      __int16 v16 = &v13[2 * (v12 >> 1)];
      unint64_t v18 = *v16;
      uint64_t v17 = v16 + 2;
      v12 += ~(v12 >> 1);
      if (v18 < v11) {
        unint64_t v13 = v17;
      }
      else {
        unint64_t v12 = v15;
      }
    }
    while (v12);
    if (v13 != v14 && *v13 == v11) {
      uint64_t v19 = v13[1];
    }
    else {
LABEL_11:
    }
      uint64_t v19 = 0;
    LODWORD(v55[0]) = -1;
    v52[0] = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v9, v19, v55, 4, 4, 1, 1);
    uint64_t v56 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v5, v52)- 16;
    if (!v9) {
      goto LABEL_21;
    }
    uint64_t v20 = *v9;
    unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v22 = *(unsigned int *)(v20 + 16);
    if (!v22) {
      goto LABEL_21;
    }
    uint64_t v23 = *(void **)(v20 + 8);
    uint64_t v24 = &v23[2 * v22];
    do
    {
      unint64_t v25 = v22 >> 1;
      uint64_t v26 = &v23[2 * (v22 >> 1)];
      unint64_t v28 = *v26;
      long long v27 = v26 + 2;
      v22 += ~(v22 >> 1);
      if (v28 < v21) {
        uint64_t v23 = v27;
      }
      else {
        unint64_t v22 = v25;
      }
    }
    while (v22);
    if (v23 != v24 && *v23 == v21) {
      uint64_t v29 = v23[1];
    }
    else {
LABEL_21:
    }
      uint64_t v29 = 0;
    LODWORD(v51) = -3;
    uint64_t v30 = 1;
    v55[0] = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v9, v29, &v51, 4, 4, 1, 1);
    v52[0] = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v5, v55)- 16);
    if (!v9) {
      goto LABEL_31;
    }
    uint64_t v31 = *v9;
    unint64_t v32 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v33 = *(unsigned int *)(v31 + 16);
    if (!v33) {
      goto LABEL_31;
    }
    uint64_t v34 = *(void **)(v31 + 8);
    unsigned int v35 = &v34[2 * v33];
    do
    {
      unint64_t v36 = v33 >> 1;
      uint64_t v37 = &v34[2 * (v33 >> 1)];
      unint64_t v39 = *v37;
      uint64_t v38 = v37 + 2;
      v33 += ~(v33 >> 1);
      if (v39 < v32) {
        uint64_t v34 = v38;
      }
      else {
        unint64_t v33 = v36;
      }
    }
    while (v33);
    if (v34 != v35 && *v34 == v32) {
      uint64_t v40 = v34[1];
    }
    else {
LABEL_31:
    }
      uint64_t v40 = 0;
    signed int v50 = Axis;
    uint64_t v51 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v9, v40, &v50, 4, 4, 1, 1);
    v55[0] = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v5, &v51)- 16);
    uint64_t v51 = (uint64_t *)mlir::ValueRange::dereference_iterator(&v62, 0);
    uint64_t v41 = v54;
    LOBYTE(v50) = 1;
    unint64_t v42 = mlir::OpBuilder::create<mlir::mps::SpaceToBatchOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,BOOL>((mlir::UnitAttr **)(a4 + 8), v54[3], (uint64_t *)&v51, &v56, (uint64_t *)v52, (uint64_t *)v55, (unsigned __int8 *)&v50);
    (*(void (**)(uint64_t, uint64_t *, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v41, v42);
  }
  else
  {
    __int16 v53 = 257;
    mlir::OpState::emitOpError(&v54, (const void ***)v52, (uint64_t)&v56);
    if (v56)
    {
      mlir::Diagnostic::operator<<((uint64_t)v57, "Unsupported interleave factor ");
      if (v56)
      {
        LODWORD(v55[0]) = 2;
        v55[1] = (uint64_t *)Axis;
        uint64_t v43 = v55;
        unint64_t v44 = v58;
        if (v59 >= v60)
        {
          unint64_t v48 = v59 + 1;
          if (v58 <= (unint64_t)v55 && v58 + 24 * v59 > (unint64_t)v55)
          {
            unint64_t v49 = (char *)v55 - v58;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, v61, v48, 24);
            unint64_t v44 = v58;
            uint64_t v43 = (uint64_t **)&v49[v58];
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, v61, v48, 24);
            uint64_t v43 = v55;
            unint64_t v44 = v58;
          }
        }
        unint64_t v45 = v44 + 24 * v59;
        long long v46 = *(_OWORD *)v43;
        *(void *)(v45 + 16) = v43[2];
        *(_OWORD *)unint64_t v45 = v46;
        ++v59;
        if (v56) {
          mlir::Diagnostic::operator<<((uint64_t)v57, ": the model must be placed on ANE to work properly");
        }
      }
    }
    uint64_t v30 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v56);
    if (v56) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v56);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v57);
  }
  return v30;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SpaceToBatchOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, unsigned __int8 *a7)
{
  v25[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.space_to_batch", (const unsigned __int8 *)0x12, Context);
  if (!v16)
  {
    __int16 v24 = 1283;
    uint64_t v23[2] = (uint64_t)"mps.space_to_batch";
    v23[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a2, v15);
  mlir::mps::SpaceToBatchOp::build(a1, (uint64_t)v25, *a3, *a4, *a5, *a6, *a7);
  uint64_t v17 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v25);
  if (*(_UNKNOWN **)(*((void *)v17 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SpaceToBatchOp,void>::id) {
    unint64_t v18 = v17;
  }
  else {
    unint64_t v18 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
  return v18;
}

void *mlir::mps::anonymous namespace'::LowerInterleave<mlir::mpsx::InterleaveOp>::~LowerInterleave(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::mps::anonymous namespace'::LowerInterleave<mlir::mpsx::InterleaveOp>::~LowerInterleave(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mpsx::InterleaveOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mpsx::InterleaveOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mpsx::detail::InterleaveOpGenericAdaptorBase::InterleaveOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mpsx::InterleaveOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mpsx::detail::InterleaveOpGenericAdaptorBase::InterleaveOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::mps::anonymous namespace'::LowerInterleave<mlir::mpsx::InterleaveOp>::matchAndRewrite(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  unsigned __int8 v54 = a2;
  long long v62 = *(_OWORD *)(a3 + 40);
  uint64_t v5 = a2[3];
  signed int Axis = mlir::anec::Concat::getAxis((mlir::Operation **)&v54);
  if (mlir::getANENextSupportedInterleaveValue(Axis) == Axis)
  {
    uint64_t v56 = 1;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x20u, 1);
    unint64_t v8 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&v56, 1, IntegerType, 0);
    unint64_t v9 = v8;
    if (!v8) {
      goto LABEL_11;
    }
    uint64_t v10 = *v8;
    unint64_t v11 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v12 = *(unsigned int *)(v10 + 16);
    if (!v12) {
      goto LABEL_11;
    }
    unint64_t v13 = *(void **)(v10 + 8);
    unint64_t v14 = &v13[2 * v12];
    do
    {
      unint64_t v15 = v12 >> 1;
      char v16 = &v13[2 * (v12 >> 1)];
      unint64_t v18 = *v16;
      uint64_t v17 = v16 + 2;
      v12 += ~(v12 >> 1);
      if (v18 < v11) {
        unint64_t v13 = v17;
      }
      else {
        unint64_t v12 = v15;
      }
    }
    while (v12);
    if (v13 != v14 && *v13 == v11) {
      uint64_t v19 = v13[1];
    }
    else {
LABEL_11:
    }
      uint64_t v19 = 0;
    LODWORD(v55[0]) = -1;
    v52[0] = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v9, v19, v55, 4, 4, 1, 1);
    uint64_t v56 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v5, v52)- 16;
    if (!v9) {
      goto LABEL_21;
    }
    uint64_t v20 = *v9;
    unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v22 = *(unsigned int *)(v20 + 16);
    if (!v22) {
      goto LABEL_21;
    }
    uint64_t v23 = *(void **)(v20 + 8);
    __int16 v24 = &v23[2 * v22];
    do
    {
      unint64_t v25 = v22 >> 1;
      uint64_t v26 = &v23[2 * (v22 >> 1)];
      unint64_t v28 = *v26;
      long long v27 = v26 + 2;
      v22 += ~(v22 >> 1);
      if (v28 < v21) {
        uint64_t v23 = v27;
      }
      else {
        unint64_t v22 = v25;
      }
    }
    while (v22);
    if (v23 != v24 && *v23 == v21) {
      uint64_t v29 = v23[1];
    }
    else {
LABEL_21:
    }
      uint64_t v29 = 0;
    LODWORD(v51) = -3;
    uint64_t v30 = 1;
    v55[0] = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v9, v29, &v51, 4, 4, 1, 1);
    v52[0] = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v5, v55)- 16);
    if (!v9) {
      goto LABEL_31;
    }
    uint64_t v31 = *v9;
    unint64_t v32 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v33 = *(unsigned int *)(v31 + 16);
    if (!v33) {
      goto LABEL_31;
    }
    uint64_t v34 = *(void **)(v31 + 8);
    unsigned int v35 = &v34[2 * v33];
    do
    {
      unint64_t v36 = v33 >> 1;
      uint64_t v37 = &v34[2 * (v33 >> 1)];
      unint64_t v39 = *v37;
      uint64_t v38 = v37 + 2;
      v33 += ~(v33 >> 1);
      if (v39 < v32) {
        uint64_t v34 = v38;
      }
      else {
        unint64_t v33 = v36;
      }
    }
    while (v33);
    if (v34 != v35 && *v34 == v32) {
      uint64_t v40 = v34[1];
    }
    else {
LABEL_31:
    }
      uint64_t v40 = 0;
    signed int v50 = Axis;
    uint64_t v51 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v9, v40, &v50, 4, 4, 1, 1);
    v55[0] = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v5, &v51)- 16);
    uint64_t v51 = (uint64_t *)mlir::ValueRange::dereference_iterator(&v62, 0);
    uint64_t v41 = v54;
    LOBYTE(v50) = 1;
    unint64_t v42 = mlir::OpBuilder::create<mlir::mps::BatchToSpaceOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,BOOL>((mlir::UnitAttr **)(a4 + 8), v54[3], (uint64_t *)&v51, &v56, (uint64_t *)v52, (uint64_t *)v55, (unsigned __int8 *)&v50);
    (*(void (**)(uint64_t, uint64_t *, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v41, v42);
  }
  else
  {
    __int16 v53 = 257;
    mlir::OpState::emitOpError(&v54, (const void ***)v52, (uint64_t)&v56);
    if (v56)
    {
      mlir::Diagnostic::operator<<((uint64_t)v57, "Unsupported interleave factor ");
      if (v56)
      {
        LODWORD(v55[0]) = 2;
        v55[1] = (uint64_t *)Axis;
        uint64_t v43 = v55;
        unint64_t v44 = v58;
        if (v59 >= v60)
        {
          unint64_t v48 = v59 + 1;
          if (v58 <= (unint64_t)v55 && v58 + 24 * v59 > (unint64_t)v55)
          {
            unint64_t v49 = (char *)v55 - v58;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, v61, v48, 24);
            unint64_t v44 = v58;
            uint64_t v43 = (uint64_t **)&v49[v58];
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, v61, v48, 24);
            uint64_t v43 = v55;
            unint64_t v44 = v58;
          }
        }
        unint64_t v45 = v44 + 24 * v59;
        long long v46 = *(_OWORD *)v43;
        *(void *)(v45 + 16) = v43[2];
        *(_OWORD *)unint64_t v45 = v46;
        ++v59;
        if (v56) {
          mlir::Diagnostic::operator<<((uint64_t)v57, ": the model must be placed on ANE to work properly");
        }
      }
    }
    uint64_t v30 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v56);
    if (v56) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v56);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v57);
  }
  return v30;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::BatchToSpaceOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, unsigned __int8 *a7)
{
  v25[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.batch_to_space", (const unsigned __int8 *)0x12, Context);
  if (!v16)
  {
    __int16 v24 = 1283;
    uint64_t v23[2] = (uint64_t)"mps.batch_to_space";
    v23[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a2, v15);
  mlir::mps::BatchToSpaceOp::build(a1, (uint64_t)v25, *a3, *a4, *a5, *a6, *a7);
  uint64_t v17 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v25);
  if (*(_UNKNOWN **)(*((void *)v17 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::BatchToSpaceOp,void>::id) {
    unint64_t v18 = v17;
  }
  else {
    unint64_t v18 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
  return v18;
}

void mlir::mps::anonymous namespace'::LowerDequantize::~LowerDequantize(mlir::mps::_anonymous_namespace_::LowerDequantize *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DequantizeOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::DequantizeOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::DequantizeOpGenericAdaptorBase::DequantizeOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DequantizeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::DequantizeOpGenericAdaptorBase::DequantizeOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::mps::anonymous namespace'::LowerDequantize::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, mlir::Float32Type **a4)
{
  uint64_t v24 = a2;
  if (mlir::mps::DequantizeOp::hasNDParams((mlir::mps::DequantizeOp *)&v24)) {
    return 0;
  }
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v24);
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(Input);
  if (*(_UNKNOWN **)(*(void *)ElementTypeOrSelf + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id
    && mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) == 4)
  {
    return 0;
  }
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v24);
  uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v24);
  uint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v24);
  uint64_t v10 = *(void *)(v24 + 24);
  uint64_t FunctionType = (uint64_t *)mlir::func::FuncOp::getFunctionType((mlir::func::FuncOp *)&v24);
  uint64_t ElementTypeOrSelf = (uint64_t)v12;
  uint64_t FastmathAttr = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v24);
  uint64_t v20 = mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::Value &>(a4 + 1, v10, &ElementTypeOrSelf, (uint64_t *)&v22);
  uint64_t v19 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::InstanceNormOp &,mlir::Value>(a4 + 1, v10, &v20, (uint64_t *)&v23);
  uint64_t v17 = v24;
  unint64_t v18 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::mps::MultiplyOp &,mlir::Value>(a4 + 1, *(void *)(v24 + 24), &v19, (uint64_t *)&v21);
  (*((void (**)(mlir::Float32Type **, uint64_t, mlir::GenericProgramPoint *))*a4 + 4))(a4, v17, v18);
  return 1;
}

char *mlir::mps::anonymous namespace'::createOrFoldConstant(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v28 = a3;
  uint64_t v26 = 0;
  long long v27 = a4;
  uint64_t v24 = (uint64_t **)&v25;
  uint64_t v25 = 0;
  v23[0] = a3;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v23);
  if (DefiningOp
    && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v24, DefiningOp)
    && (unint64_t v8 = mlir::mps::foldCastAttribute(v25, v26, a4, 0), (v8 & 4) == 0))
  {
    unint64_t v9 = (mlir::OpBuilder *)(a1 + 8);
    uint64_t v10 = (uint64_t *)(v8 & 0xFFFFFFFFFFFFFFF8);
    if ((v8 & 0xFFFFFFFFFFFFFFF8) == 0) {
      goto LABEL_13;
    }
    uint64_t v11 = *v10;
    unint64_t v12 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v13 = *(unsigned int *)(v11 + 16);
    if (!v13) {
      goto LABEL_13;
    }
    unint64_t v14 = *(void **)(v11 + 8);
    uint64_t v15 = &v14[2 * v13];
    do
    {
      unint64_t v16 = v13 >> 1;
      uint64_t v17 = &v14[2 * (v13 >> 1)];
      unint64_t v19 = *v17;
      unint64_t v18 = v17 + 2;
      v13 += ~(v13 >> 1);
      if (v19 < v12) {
        unint64_t v14 = v18;
      }
      else {
        unint64_t v13 = v16;
      }
    }
    while (v13);
    if (v14 != v15 && *v14 == v12) {
      uint64_t v20 = v14[1];
    }
    else {
LABEL_13:
    }
      uint64_t v20 = 0;
    v23[0] = v10;
    v23[1] = v20;
    unint64_t v21 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ElementsAttr &>(v9, a2, (uint64_t)v23);
  }
  else
  {
    unint64_t v21 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)(a1 + 8), a2, &v28, (uint64_t *)&v27);
  }
  return (char *)v21 - 16;
}

char *mlir::mps::anonymous namespace'::reshapeQuantizeScaleZp(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v83[3] = *MEMORY[0x1E4F143B8];
  uint64_t v78 = a3;
  uint64_t v79 = a2;
  uint64_t v77 = a4;
  uint64_t Loc = mlir::Value::getLoc((mlir::Value *)&v79);
  uint64_t v7 = (uint64_t *)(*(void *)(v79 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v7) {
    goto LABEL_10;
  }
  uint64_t v8 = *v7;
  unint64_t v9 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v10 = *(unsigned int *)(v8 + 16);
  if (!v10) {
    goto LABEL_10;
  }
  uint64_t v11 = *(void **)(v8 + 8);
  unint64_t v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    unint64_t v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    uint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      uint64_t v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_10:
  }
    uint64_t v17 = 0;
  v76[0] = v7;
  v76[1] = v17;
  if (!v78) {
    return (char *)v79;
  }
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v76))
  {
    uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v76);
    if (v19)
    {
      uint64_t v20 = 8 * v19;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v20 -= 8;
        if (!v20) {
          goto LABEL_17;
        }
      }
      goto LABEL_19;
    }
LABEL_17:
    unint64_t v21 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v76);
    if (mlir::ShapedType::getNumElements(v21, v22) == 1) {
      return (char *)v79;
    }
  }
LABEL_19:
  uint64_t v24 = (uint64_t *)(*(void *)(a4 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v24) {
    goto LABEL_28;
  }
  uint64_t v25 = *v24;
  unint64_t v26 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v27 = *(unsigned int *)(v25 + 16);
  if (!v27) {
    goto LABEL_28;
  }
  uint64_t v28 = *(void **)(v25 + 8);
  uint64_t v29 = &v28[2 * v27];
  do
  {
    unint64_t v30 = v27 >> 1;
    uint64_t v31 = &v28[2 * (v27 >> 1)];
    unint64_t v33 = *v31;
    unint64_t v32 = v31 + 2;
    v27 += ~(v27 >> 1);
    if (v33 < v26) {
      uint64_t v28 = v32;
    }
    else {
      unint64_t v27 = v30;
    }
  }
  while (v27);
  if (v28 != v29 && *v28 == v26) {
    uint64_t v34 = v28[1];
  }
  else {
LABEL_28:
  }
    uint64_t v34 = 0;
  __p = v24;
  uint64_t v82 = v34;
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&__p))
  {
    unsigned int v35 = (uint64_t *)(*(void *)(a4 + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v35) {
      goto LABEL_39;
    }
    uint64_t v36 = *v35;
    unint64_t v37 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v38 = *(unsigned int *)(v36 + 16);
    if (!v38) {
      goto LABEL_39;
    }
    unint64_t v39 = *(void **)(v36 + 8);
    uint64_t v40 = &v39[2 * v38];
    do
    {
      unint64_t v41 = v38 >> 1;
      unint64_t v42 = &v39[2 * (v38 >> 1)];
      unint64_t v44 = *v42;
      uint64_t v43 = v42 + 2;
      v38 += ~(v38 >> 1);
      if (v44 < v37) {
        unint64_t v39 = v43;
      }
      else {
        unint64_t v38 = v41;
      }
    }
    while (v38);
    if (v39 != v40 && *v39 == v37) {
      uint64_t v45 = v39[1];
    }
    else {
LABEL_39:
    }
      uint64_t v45 = 0;
    __p = v35;
    uint64_t v82 = v45;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__p);
    uint64_t v47 = v46;
    mlir::IntegerAttr::getValue(&v78, (llvm::APInt *)&__p);
    if (v82 > 0x40) {
      uint64_t v48 = *(void *)__p;
    }
    else {
      uint64_t v48 = (uint64_t)((void)__p << -(uint64_t)v82) >> -(uint64_t)v82;
    }
    uint64_t PositiveAxis = mlir::getPositiveAxis(v48, v47);
    if (v82 >= 0x41 && __p) {
      operator delete[](__p);
    }
    uint64_t v52 = v47 + ~PositiveAxis;
    __p = v83;
    uint64_t v82 = 0x500000000;
    if (v52 >= 1)
    {
      unsigned int v53 = 0;
      uint64_t v54 = v47 - PositiveAxis;
      uint64_t v55 = 1;
      do
      {
        if (v53 >= HIDWORD(v82))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__p, v83, v53 + 1, 4);
          unsigned int v53 = v82;
        }
        *((_DWORD *)__p + v53) = v55;
        unsigned int v53 = v82 + 1;
        LODWORD(v82) = v82 + 1;
        ++v55;
      }
      while (v54 != v55);
    }
    unint64_t v80 = (mlir::GenericProgramPoint *)v52;
    uint64_t v56 = (mlir::Builder *)(a1 + 8);
    uint64_t IntegerType = mlir::Builder::getIntegerType(v56, 0x20u, 1);
    unint64_t v58 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&v80, 1, IntegerType, 0);
    uint64_t v59 = mlir::Value::getLoc((mlir::Value *)&v79);
    if (!v58) {
      goto LABEL_62;
    }
    uint64_t v60 = *v58;
    unint64_t v61 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v62 = *(unsigned int *)(v60 + 16);
    if (!v62) {
      goto LABEL_62;
    }
    uint64_t v63 = *(void **)(v60 + 8);
    uint64_t v64 = &v63[2 * v62];
    do
    {
      unint64_t v65 = v62 >> 1;
      uint64_t v66 = &v63[2 * (v62 >> 1)];
      unint64_t v68 = *v66;
      uint64_t v67 = v66 + 2;
      v62 += ~(v62 >> 1);
      if (v68 < v61) {
        uint64_t v63 = v67;
      }
      else {
        unint64_t v62 = v65;
      }
    }
    while (v62);
    if (v63 != v64 && *v63 == v61) {
      uint64_t v69 = v63[1];
    }
    else {
LABEL_62:
    }
      uint64_t v69 = 0;
    uint64_t v75 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v58, v69, __p, 4 * v82, 4, 1, 1);
    unint64_t v80 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v56, v59, &v75);
    uint64_t v23 = (char *)mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::mps::ConstantOp &>(v56, Loc, &v79, &v80)- 16;
    if (__p != v83) {
      free(__p);
    }
  }
  else
  {
    unint64_t v49 = (mlir::mps::ConstantOp *)(a1 + 8);
    LODWORD(__p) = 0;
    unint64_t v80 = (mlir::GenericProgramPoint *)((char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,int>(v49, Loc, (unsigned int *)&__p)- 16);
    LODWORD(__p) = 1;
    uint64_t v75 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,int>(v49, Loc, (unsigned int *)&__p) - 16);
    LODWORD(__p) = -1;
    uint64_t v74 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,int>(v49, Loc, (unsigned int *)&__p) - 16;
    mlir::IntegerAttr::getValue(&v78, (llvm::APInt *)&__p);
    if (v82 > 0x40) {
      uint64_t v50 = *(void *)__p;
    }
    else {
      uint64_t v50 = (uint64_t)((void)__p << -(uint64_t)v82) >> -(uint64_t)v82;
    }
    LODWORD(v72) = v50;
    uint64_t v73 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,int>(v49, Loc, (unsigned int *)&v72) - 16;
    if (v82 >= 0x41 && __p) {
      operator delete[](__p);
    }
    __p = (char *)mlir::OpBuilder::create<mlir::mps::RankOp,mlir::Value &>(v49, Loc, &v77) - 16;
    uint64_t v71 = mlir::OpBuilder::create<mlir::mps::GetCoordOp,mlir::Value &,mlir::Value &>((uint64_t *)v49, Loc, (uint64_t *)&__p, (uint64_t *)&v80);
    uint64_t v72 = (uint64_t)mlir::OpBuilder::create<mlir::mps::CropOp,mlir::mps::GetCoordOp,mlir::Value &,mlir::Value &,mlir::Value &>((mlir::UnknownLoc **)v49, Loc, &v71, (uint64_t *)&v80, (uint64_t *)&v80, (uint64_t *)&v75)- 16;
    uint64_t v71 = (mlir::GenericProgramPoint *)((char *)mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::Value &>(v49, Loc, &v79, &v72)- 16);
    return (char *)mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,mlir::Value &,mlir::Value &>((mlir::Float32Type **)v49, Loc, (uint64_t *)&v71, &v74, &v73)- 16;
  }
  return v23;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::mps::ConstantOp &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, void *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.expand_dims", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.expand_dims";
    v17[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ExpandDimsOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4 - 16);
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ExpandDimsOp,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::CropOp,mlir::mps::GetCoordOp,mlir::Value &,mlir::Value &,mlir::Value &>(mlir::UnknownLoc **a1, uint64_t a2, void *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.crop", (const unsigned __int8 *)8, Context);
  if (!v14)
  {
    __int16 v22 = 1283;
    uint64_t v21[2] = (uint64_t)"mps.crop";
    v21[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::mps::CropOp::build(a1, (uint64_t)v23, *a3 - 16, *a4, *a5, *a6);
  uint64_t v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::CropOp,void>::id) {
    __int16 v16 = v15;
  }
  else {
    __int16 v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,mlir::Value &,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.transpose", (const unsigned __int8 *)0xD, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    void v19[2] = (uint64_t)"mps.transpose";
    void v19[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::TransposeOp::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id) {
    char v14 = v13;
  }
  else {
    char v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void mlir::mps::anonymous namespace'::LowerDequantizeLUT::~LowerDequantizeLUT(mlir::mps::_anonymous_namespace_::LowerDequantizeLUT *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DequantizeLUTOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::DequantizeLUTOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::DequantizeLUTOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DequantizeLUTOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::DequantizeLUTOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::mps::anonymous namespace'::LowerDequantizeLUT::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase *a3, mlir::Float32Type **a4)
{
  uint64_t v224 = *MEMORY[0x1E4F143B8];
  uint64_t v192 = 0;
  uint64_t v193 = a2;
  long long v223 = *((_OWORD *)a3 + 3);
  uint64_t v191 = 0;
  v221[0] = v222;
  v221[1] = (void *)0xC00000000;
  unint64_t v215 = &v191;
  uint64_t v218 = (char *)mlir::ValueRange::dereference_iterator(&v223, 0);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v218);
  if (!DefiningOp
    || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&v215, DefiningOp)
    || (uint64_t v7 = mlir::ValueRange::dereference_iterator(&v223, 1),
        !mlir::matchConstantWithFloatVector<float>(v7, (uint64_t)v221)))
  {
    uint64_t v46 = 0;
    goto LABEL_38;
  }
  uint64_t v179 = a4;
  unint64_t v8 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v223, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v8) {
    goto LABEL_13;
  }
  uint64_t v9 = *v8;
  unint64_t v10 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v11 = *(unsigned int *)(v9 + 16);
  if (!v11) {
    goto LABEL_13;
  }
  char v12 = *(void **)(v9 + 8);
  unint64_t v13 = &v12[2 * v11];
  do
  {
    unint64_t v14 = v11 >> 1;
    uint64_t v15 = &v12[2 * (v11 >> 1)];
    unint64_t v17 = *v15;
    uint64_t v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10) {
      char v12 = v16;
    }
    else {
      unint64_t v11 = v14;
    }
  }
  while (v11);
  if (v12 != v13 && *v12 == v10) {
    uint64_t v18 = v12[1];
  }
  else {
LABEL_13:
  }
    uint64_t v18 = 0;
  v190[0] = v8;
  v190[1] = v18;
  uint64_t v19 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v223, 1) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v19) {
    goto LABEL_23;
  }
  uint64_t v20 = *v19;
  unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v22 = *(unsigned int *)(v20 + 16);
  if (!v22) {
    goto LABEL_23;
  }
  uint64_t v23 = *(void **)(v20 + 8);
  uint64_t v24 = &v23[2 * v22];
  do
  {
    unint64_t v25 = v22 >> 1;
    unint64_t v26 = &v23[2 * (v22 >> 1)];
    unint64_t v28 = *v26;
    unint64_t v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21) {
      uint64_t v23 = v27;
    }
    else {
      unint64_t v22 = v25;
    }
  }
  while (v22);
  if (v23 != v24 && *v23 == v21) {
    uint64_t v29 = v23[1];
  }
  else {
LABEL_23:
  }
    uint64_t v29 = 0;
  v189[0] = v19;
  v189[1] = v29;
  unint64_t v30 = (void *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v193) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v30) {
    goto LABEL_33;
  }
  uint64_t v31 = *v30;
  unint64_t v32 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v33 = *(unsigned int *)(v31 + 16);
  if (!v33) {
    goto LABEL_33;
  }
  uint64_t v34 = *(void **)(v31 + 8);
  unsigned int v35 = &v34[2 * v33];
  do
  {
    unint64_t v36 = v33 >> 1;
    unint64_t v37 = &v34[2 * (v33 >> 1)];
    unint64_t v39 = *v37;
    unint64_t v38 = v37 + 2;
    v33 += ~(v33 >> 1);
    if (v39 < v32) {
      uint64_t v34 = v38;
    }
    else {
      unint64_t v33 = v36;
    }
  }
  while (v33);
  if (v34 != v35 && *v34 == v32) {
    uint64_t v40 = v34[1];
  }
  else {
LABEL_33:
  }
    uint64_t v40 = 0;
  unint64_t v187 = v30;
  uint64_t v188 = v40;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v190);
  unint64_t v42 = v41;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v189);
  uint64_t v44 = v43;
  if (v43 == 1 || (mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::getAxis(a3) & 0xFF00000000) == 0) {
    uint64_t v45 = 1;
  }
  else {
    uint64_t v45 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v189)
  }
                    + 8 * (v44 - 1));
  if ((mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::getAxis(a3) & 0xFF00000000) == 0)
  {
    unsigned int v48 = v44 - 1;
    goto LABEL_46;
  }
  if (v44 >= 3)
  {
    unsigned int v48 = v44 - 2;
LABEL_46:
    uint64_t ArgAttrsAttr = (uint64_t *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v189) + 8 * v48);
    goto LABEL_48;
  }
  uint64_t ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v189);
LABEL_48:
  uint64_t v50 = *ArgAttrsAttr;
  if (mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::getAxisAttr(a3))
  {
    int Axis = mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::getAxis(a3);
    uint64_t PositiveAxis = mlir::getPositiveAxis(Axis, v42);
  }
  else
  {
    uint64_t PositiveAxis = v42 - 1;
  }
  if ((mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::getAxis(a3) & 0xFF00000000) != 0) {
    uint64_t v53 = -2;
  }
  else {
    uint64_t v53 = -1;
  }
  uint64_t v54 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v190);
  unint64_t NumElements = mlir::ShapedType::getNumElements(v54, v55);
  uint64_t v218 = v220;
  uint64_t v219 = 0xC00000000;
  if (NumElements)
  {
    unint64_t v57 = NumElements;
    if (NumElements < 0xD)
    {
      uint64_t v58 = 0;
      unint64_t v59 = NumElements;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v218, v220, NumElements, 4);
      uint64_t v58 = v219;
      unint64_t v59 = v57 - v219;
      if (v57 == v219) {
        goto LABEL_60;
      }
    }
    bzero(&v218[4 * v58], 4 * v59);
LABEL_60:
    LODWORD(v219) = v57;
  }
  unint64_t v60 = v42 + ~PositiveAxis;
  unint64_t v61 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v190);
  uint64_t v63 = mlir::ShapedType::getNumElements(v61, v62);
  unint64_t v64 = v63 * v45;
  unint64_t v215 = v217;
  uint64_t v216 = 0xC00000000;
  if (!(v63 * v45)) {
    goto LABEL_68;
  }
  if (v64 >= 0xD)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v217, v64, 4);
    uint64_t v65 = v216;
    unint64_t v66 = v64 - v216;
    if (v64 == v216) {
      goto LABEL_67;
    }
    goto LABEL_66;
  }
  uint64_t v65 = 0;
  unint64_t v66 = v63 * v45;
  if (v64) {
LABEL_66:
  }
    bzero((char *)v215 + 4 * v65, 4 * v66);
LABEL_67:
  LODWORD(v216) = v64;
LABEL_68:
  mlir::getIntValues<int>(v191, v192, (uint64_t)&v218, 1);
  uint64_t v212 = v214;
  uint64_t v213 = 0x600000000;
  if (!v42)
  {
    unint64_t v209 = v211;
    uint64_t v210 = 0x600000000;
    uint64_t v206 = v208;
    uint64_t v207 = 0x600000000;
    uint64_t v203 = v205;
    uint64_t v204 = 0x600000000;
    long long v200 = v202;
    uint64_t v201 = 0x600000000;
    int v197 = v199;
    uint64_t v198 = 0x600000000;
    uint64_t v194 = v196;
    uint64_t v195 = 0x600000000;
    goto LABEL_114;
  }
  if (v42 < 7)
  {
    uint64_t v67 = 0;
    unint64_t v68 = v42;
    goto LABEL_74;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v212, v214, v42, 8);
  uint64_t v67 = v213;
  unint64_t v68 = v42 - v213;
  if (v42 != v213) {
LABEL_74:
  }
    bzero((char *)v212 + 8 * v67, 8 * v68);
  LODWORD(v213) = v42;
  unint64_t v209 = v211;
  uint64_t v210 = 0x600000000;
  if (v42 < 7)
  {
    uint64_t v69 = 0;
    unint64_t v70 = v42;
    goto LABEL_79;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v209, v211, v42, 8);
  uint64_t v69 = v210;
  unint64_t v70 = v42 - v210;
  if (v42 != v210) {
LABEL_79:
  }
    bzero((char *)v209 + 8 * v69, 8 * v70);
  LODWORD(v210) = v42;
  uint64_t v206 = v208;
  uint64_t v207 = 0x600000000;
  if (v42 < 7)
  {
    uint64_t v71 = 0;
    unint64_t v72 = v42;
    goto LABEL_84;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v206, v208, v42, 8);
  uint64_t v71 = v207;
  unint64_t v72 = v42 - v207;
  if (v42 != v207) {
LABEL_84:
  }
    bzero((char *)v206 + 8 * v71, 8 * v72);
  LODWORD(v207) = v42;
  uint64_t v203 = v205;
  uint64_t v204 = 0x600000000;
  if (v42 < 7)
  {
    uint64_t v73 = 0;
    unint64_t v74 = v42;
    goto LABEL_89;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v203, v205, v42, 8);
  uint64_t v73 = v204;
  unint64_t v74 = v42 - v204;
  if (v42 != v204) {
LABEL_89:
  }
    bzero((char *)v203 + 8 * v73, 8 * v74);
  LODWORD(v204) = v42;
  long long v200 = v202;
  uint64_t v201 = 0x600000000;
  if (v42 < 7)
  {
    uint64_t v75 = 0;
    unint64_t v76 = v42;
    goto LABEL_94;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v200, v202, v42, 8);
  uint64_t v75 = v201;
  unint64_t v76 = v42 - v201;
  if (v42 != v201) {
LABEL_94:
  }
    bzero((char *)v200 + 8 * v75, 8 * v76);
  LODWORD(v201) = v42;
  int v197 = v199;
  uint64_t v198 = 0x600000000;
  if (v42 < 7)
  {
    uint64_t v77 = 0;
    unint64_t v78 = v42;
    goto LABEL_99;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v197, v199, v42, 8);
  uint64_t v77 = v198;
  unint64_t v78 = v42 - v198;
  if (v42 != v198) {
LABEL_99:
  }
    bzero((char *)v197 + 8 * v77, 8 * v78);
  LODWORD(v198) = v42;
  uint64_t v194 = v196;
  uint64_t v195 = 0x600000000;
  if (v42 < 7)
  {
    uint64_t v79 = 0;
    unint64_t v80 = v42;
    goto LABEL_104;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v194, v196, v42, 8);
  uint64_t v79 = v195;
  unint64_t v80 = v42 - v195;
  if (v42 != v195) {
LABEL_104:
  }
    bzero((char *)v194 + 8 * v79, 8 * v80);
  LODWORD(v195) = v42;
  BOOL v185 = (uint64_t)v42 > 0;
  if ((uint64_t)v42 >= 1)
  {
    uint64_t v81 = 0;
    uint64_t v181 = PositiveAxis;
    uint64_t v182 = v53 + v44;
    uint64_t v82 = v50 * v45;
    int v83 = -1;
    uint64_t v84 = 1;
    uint64_t v85 = 1;
    uint64_t v178 = v82;
    unint64_t v180 = v42;
    unint64_t v184 = v60;
    do
    {
      uint64_t v87 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v190)
                      + 8 * (v42 + v83));
      int64_t v88 = v212;
      uint64_t v89 = 8 * v81;
      *(void *)((char *)v212 + v89) = v87;
      *(void *)((char *)v206 + v89) = v84;
      *(void *)((char *)v203 + v89) = v85;
      uint64_t v90 = v88[v81];
      if (v60 == v81) {
        uint64_t v91 = v45;
      }
      else {
        uint64_t v91 = 1;
      }
      if (v81 < v182)
      {
        uint64_t v86 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v189)
                        + 8 * (v182 + v83));
        unint64_t v42 = v180;
      }
      else
      {
        uint64_t v86 = 1;
      }
      v84 *= v90;
      v85 *= v91 * v90;
      *((void *)v200 + v81) = v86;
      *((void *)v197 + v81) = v82;
      v82 *= v86;
      ++v81;
      --v83;
      unint64_t v60 = v184;
    }
    while (v42 != v81);
    uint64_t v183 = *((void *)v203 + v184);
    BOOL v92 = v82 > v178;
    if (v82 <= v178)
    {
      uint64_t PositiveAxis = v181;
    }
    else
    {
      uint64_t v93 = (char *)v212;
      unint64_t v94 = (char *)v200;
      unint64_t v95 = (char *)v194;
      uint64_t PositiveAxis = v181;
      uint64_t v96 = 0;
      if (v42 < 4) {
        goto LABEL_117;
      }
      if ((unint64_t)((unsigned char *)v194 - (unsigned char *)v212) < 0x20) {
        goto LABEL_117;
      }
      if ((unint64_t)((unsigned char *)v194 - (unsigned char *)v200) < 0x20) {
        goto LABEL_117;
      }
      uint64_t v96 = v42 & 0x7FFFFFFFFFFFFFFCLL;
      uint64_t v173 = (int64x2_t *)((char *)v212 + 16);
      unint64_t v174 = (int64x2_t *)((char *)v200 + 16);
      unint64_t v175 = (int64x2_t *)((char *)v194 + 16);
      unint64_t v176 = v42 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        int64x2_t v177 = vcvtq_s64_f64(vrndpq_f64(vdivq_f64(vcvtq_f64_s64(*v173), vcvtq_f64_s64(*v174))));
        v175[-1] = vcvtq_s64_f64(vrndpq_f64(vdivq_f64(vcvtq_f64_s64(v173[-1]), vcvtq_f64_s64(v174[-1]))));
        int64x2_t *v175 = v177;
        v173 += 2;
        v174 += 2;
        v175 += 2;
        v176 -= 4;
      }
      while (v176);
      if (v42 != v96)
      {
LABEL_117:
        unint64_t v97 = v42 - v96;
        uint64_t v98 = 8 * v96;
        uint64_t v99 = (uint64_t *)&v93[v98];
        uint64_t v100 = (uint64_t *)&v94[v98];
        uint64_t v101 = &v95[v98];
        do
        {
          uint64_t v102 = *v99++;
          double v103 = (double)v102;
          uint64_t v104 = *v100++;
          *(void *)uint64_t v101 = vcvtpd_s64_f64(v103 / (double)v104);
          v101 += 8;
          --v97;
        }
        while (v97);
      }
      BOOL v92 = 1;
    }
    goto LABEL_121;
  }
LABEL_114:
  BOOL v92 = 0;
  BOOL v185 = 0;
  uint64_t v183 = *((void *)v203 + v60);
LABEL_121:
  if (v219)
  {
    uint64_t v105 = 0;
    int v106 = v92 && v185;
    unint64_t v107 = v42 & 0xFFFFFFFFFFFFFFFELL;
    BOOL v109 = (unint64_t)v45 > 0xB && v183 == 1;
    while (1)
    {
      if (!v42)
      {
        uint64_t v113 = 0;
        goto LABEL_148;
      }
      if (v42 == 1) {
        break;
      }
      uint64_t v114 = 0;
      uint64_t v115 = 0;
      uint64_t v116 = 0;
      unint64_t v117 = (char *)v209 + 8;
      unint64_t v118 = (char *)v203 + 8;
      unint64_t v119 = v60;
      do
      {
        if (v119) {
          uint64_t v120 = 1;
        }
        else {
          uint64_t v120 = v45;
        }
        if ((v114 | 1) == v60) {
          uint64_t v121 = v45;
        }
        else {
          uint64_t v121 = 1;
        }
        v115 += *(v117 - 1) * v120 * *(v118 - 1);
        v116 += *v117 * v121 * *v118;
        v114 += 2;
        v117 += 2;
        v118 += 2;
        v119 -= 2;
      }
      while (v114 != v107);
      uint64_t v113 = v116 + v115;
      unint64_t v112 = v42 & 0xFFFFFFFFFFFFFFFELL;
      if (v42 != v107) {
        goto LABEL_143;
      }
LABEL_148:
      if (!v106)
      {
        uint64_t v131 = 0;
        goto LABEL_157;
      }
      if (v42 < 2)
      {
        unint64_t v130 = 0;
        uint64_t v131 = 0;
LABEL_155:
        uint64_t v138 = (uint64_t *)((char *)v197 + 8 * v130);
        uint64_t v139 = (uint64_t *)((char *)v194 + 8 * v130);
        unint64_t v140 = (uint64_t *)((char *)v209 + 8 * v130);
        unint64_t v141 = v42 - v130;
        do
        {
          uint64_t v143 = *v140++;
          uint64_t v142 = v143;
          uint64_t v144 = *v139++;
          uint64_t v145 = v142 / v144;
          uint64_t v146 = *v138++;
          v131 += v146 * v145;
          --v141;
        }
        while (v141);
        goto LABEL_157;
      }
      uint64_t v132 = 0;
      uint64_t v133 = 0;
      uint64_t v134 = (uint64_t *)((char *)v194 + 8);
      long long v135 = (char *)v197 + 8;
      uint64_t v136 = (char *)v209 + 8;
      unint64_t v137 = v42 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        v132 += *(v135 - 1) * (*(v136 - 1) / *(v134 - 1));
        v133 += *v135 * (*v136 / *v134);
        v134 += 2;
        v135 += 2;
        v136 += 2;
        v137 -= 2;
      }
      while (v137);
      uint64_t v131 = v133 + v132;
      unint64_t v130 = v42 & 0xFFFFFFFFFFFFFFFELL;
      if (v42 != v107) {
        goto LABEL_155;
      }
LABEL_157:
      if (v45 >= 1)
      {
        uint64_t v147 = v45 * *(int *)&v218[4 * v105];
        unint64_t v148 = (char *)v221[0];
        unint64_t v149 = (char *)v215;
        if (v109
          && (uint64_t v150 = 4 * (v131 + v147), (unint64_t)((unsigned char *)v215 + 4 * v113 - (char *)v221[0] - v150) >= 0x20))
        {
          unint64_t v159 = (char *)v215 + 4 * v113 + 16;
          uint64_t v160 = (long long *)((char *)v221[0] + v150 + 16);
          unint64_t v161 = v45 & 0xFFFFFFFFFFFFFFF8;
          do
          {
            long long v162 = *v160;
            *(v159 - 1) = *(v160 - 1);
            _OWORD *v159 = v162;
            v159 += 2;
            v160 += 2;
            v161 -= 8;
          }
          while (v161);
          uint64_t v151 = v45 & 0x7FFFFFFFFFFFFFF8;
          if (v45 == (v45 & 0xFFFFFFFFFFFFFFF8)) {
            goto LABEL_163;
          }
        }
        else
        {
          uint64_t v151 = 0;
        }
        uint64_t v152 = v45 - v151;
        unint64_t v153 = &v149[4 * v113 + 4 * v183 * v151];
        uint64_t v154 = &v148[4 * v151 + 4 * v131 + 4 * v147];
        do
        {
          int v155 = *(_DWORD *)v154;
          v154 += 4;
          *(_DWORD *)unint64_t v153 = v155;
          v153 += 4 * v183;
          --v152;
        }
        while (v152);
      }
LABEL_163:
      if (v185)
      {
        unint64_t v110 = 0;
        int64_t v156 = v209;
        unint64_t v157 = v212;
        while (1)
        {
          uint64_t v158 = v156[v110] + 1;
          if (v158 < v157[v110]) {
            break;
          }
          v156[v110++] = 0;
          if (v42 == v110)
          {
            unint64_t v110 = v42;
            goto LABEL_129;
          }
        }
        v156[v110] = v158;
      }
      else
      {
        unint64_t v110 = 0;
      }
LABEL_129:
      ++v105;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v190);
      if (v111 == v110) {
        goto LABEL_173;
      }
    }
    unint64_t v112 = 0;
    uint64_t v113 = 0;
LABEL_143:
    unint64_t v122 = v42 - v112;
    uint64_t v123 = 8 * v112;
    int v124 = (uint64_t *)((char *)v209 + v123);
    unint64_t v125 = (uint64_t *)((char *)v203 + v123);
    do
    {
      uint64_t v127 = *v124++;
      uint64_t v126 = v127;
      if (PositiveAxis + 1 == v122) {
        uint64_t v128 = v45;
      }
      else {
        uint64_t v128 = 1;
      }
      uint64_t v129 = *v125++;
      v113 += v126 * v128 * v129;
      --v122;
    }
    while (v122);
    goto LABEL_148;
  }
LABEL_173:
  uint64_t v163 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v187);
  uint64_t v165 = (uint64_t)v164;
  F32uint64_t Type = mlir::Builder::getF32Type(v179 + 1, v164);
  long long v167 = (void *)mlir::RankedTensorType::get(v163, v165, F32Type, 0);
  RawElementsAttr = mlir::createRawElementsAttr(v167, v215, (const void *)(4 * v216));
  v186[0] = mlir::rewriteElementsAttr((uint64_t)RawElementsAttr, v169, (uint64_t)v187, v188, 0);
  v186[1] = v170;
  uint64_t v171 = v193;
  uint64_t v172 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ElementsAttr &>((mlir::OpBuilder *)(v179 + 1), *(void *)(v193 + 24), (uint64_t)v186);
  (*((void (**)(mlir::Float32Type **, uint64_t, mlir::GenericProgramPoint *))*v179 + 4))(v179, v171, v172);
  if (v194 != v196) {
    free(v194);
  }
  if (v197 != v199) {
    free(v197);
  }
  if (v200 != v202) {
    free(v200);
  }
  if (v203 != v205) {
    free(v203);
  }
  if (v206 != v208) {
    free(v206);
  }
  if (v209 != v211) {
    free(v209);
  }
  if (v212 != v214) {
    free(v212);
  }
  if (v215 != v217) {
    free(v215);
  }
  if (v218 != v220) {
    free(v218);
  }
  uint64_t v46 = 1;
LABEL_38:
  if (v221[0] != v222) {
    free(v221[0]);
  }
  return v46;
}

float mlir::getIntValues<int>(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  v128[5] = *MEMORY[0x1E4F143B8];
  *(void *)&long long v122 = a1;
  *((void *)&v122 + 1) = a2;
  if (!mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v122) || a4) {
    unint64_t NumElements = mlir::ElementsAttr::getNumElements(v122, *((uint64_t *)&v122 + 1));
  }
  else {
    unint64_t NumElements = 1;
  }
  unint64_t v7 = *(unsigned int *)(a3 + 8);
  if (NumElements != v7)
  {
    if (NumElements >= v7)
    {
      if (NumElements > *(unsigned int *)(a3 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), NumElements, 4);
        unint64_t v7 = *(unsigned int *)(a3 + 8);
      }
      if (NumElements != v7) {
        bzero((void *)(*(void *)a3 + 4 * v7), 4 * (NumElements - v7));
      }
    }
    *(_DWORD *)(a3 + 8) = NumElements;
  }
  unint64_t v8 = *(double **)a3;
  long long v125 = v122;
  uint64_t Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v125);
  unint64_t v10 = Type;
  if (!Type) {
    goto LABEL_21;
  }
  uint64_t v11 = *Type;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_21;
  }
  unint64_t v14 = *(void **)(v11 + 8);
  uint64_t v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    unint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    uint64_t v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      unint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_21:
  }
    uint64_t v20 = 0;
  v124[0] = v10;
  v124[1] = v20;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v124);
  int v21 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v125);
  ElementsAttrRawData = (unsigned __int8 *)mlir::getElementsAttrRawData(v125);
  uint64_t v24 = v23;
  if (!v21 || a4)
  {
    uint64_t v26 = mlir::ElementsAttr::getNumElements(v125, *((uint64_t *)&v125 + 1));
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
    {
      if (v26 < 1) {
        return *(float *)&v25;
      }
      goto LABEL_28;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 8))
    {
      if (v26 < 1) {
        return *(float *)&v25;
      }
      goto LABEL_39;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16))
    {
      if (v26 < 1) {
        return *(float *)&v25;
      }
      if ((unint64_t)v26 >= 2)
      {
        unint64_t v32 = 0;
        unint64_t v31 = v26 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v21) {
            unint64_t v33 = 0;
          }
          else {
            unint64_t v33 = v32;
          }
          if (v21) {
            unint64_t v34 = 0;
          }
          else {
            unint64_t v34 = v32 + 1;
          }
          int v35 = *(unsigned __int16 *)&ElementsAttrRawData[2 * v34];
          unint64_t v36 = &v8[v32 / 2];
          *(_DWORD *)unint64_t v36 = *(unsigned __int16 *)&ElementsAttrRawData[2 * v33];
          *((_DWORD *)v36 + 1) = v35;
          v32 += 2;
        }
        while (v32 != v31);
        goto LABEL_280;
      }
      goto LABEL_48;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 16))
    {
      if (v26 < 1) {
        return *(float *)&v25;
      }
      goto LABEL_66;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32))
    {
      if (v26 < 1) {
        return *(float *)&v25;
      }
      goto LABEL_73;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 32))
    {
      if (v26 < 1) {
        return *(float *)&v25;
      }
      goto LABEL_93;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
    {
      if (v26 < 1) {
        return *(float *)&v25;
      }
      goto LABEL_104;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 64))
    {
      if (v26 < 1) {
        return *(float *)&v25;
      }
      goto LABEL_111;
    }
    if (mlir::Type::isF16((mlir::Type *)&OperandRange))
    {
      if (v26 < 1) {
        return *(float *)&v25;
      }
      goto LABEL_127;
    }
    if (mlir::Type::isF32((mlir::Type *)&OperandRange))
    {
      if (v26 < 1) {
        return *(float *)&v25;
      }
      goto LABEL_143;
    }
    if (mlir::Type::isF64((mlir::Type *)&OperandRange))
    {
      if (v26 < 1) {
        return *(float *)&v25;
      }
      goto LABEL_159;
    }
    if (mlir::Type::isBF16((mlir::Type *)&OperandRange))
    {
      if (v26 < 1) {
        return *(float *)&v25;
      }
      goto LABEL_174;
    }
    goto LABEL_176;
  }
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
  {
    uint64_t v26 = 1;
LABEL_28:
    for (uint64_t i = 0; i != v26; ++i)
    {
      if (v21) {
        uint64_t v28 = 0;
      }
      else {
        uint64_t v28 = i;
      }
      *((_DWORD *)v8 + i) = ElementsAttrRawData[v28];
    }
    return *(float *)&v25;
  }
  if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 8))
  {
    uint64_t v26 = 1;
LABEL_39:
    for (uint64_t j = 0; j != v26; ++j)
    {
      if (v21) {
        uint64_t v30 = 0;
      }
      else {
        uint64_t v30 = j;
      }
      *((_DWORD *)v8 + j) = (char)ElementsAttrRawData[v30];
    }
    return *(float *)&v25;
  }
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16))
  {
    uint64_t v26 = 1;
LABEL_48:
    unint64_t v31 = 0;
    do
    {
      if (v21) {
        unint64_t v112 = 0;
      }
      else {
        unint64_t v112 = v31;
      }
      *((_DWORD *)v8 + v31++) = *(unsigned __int16 *)&ElementsAttrRawData[2 * v112];
LABEL_280:
      ;
    }
    while (v26 != v31);
    return *(float *)&v25;
  }
  if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 16))
  {
    uint64_t v26 = 1;
LABEL_66:
    if ((unint64_t)v26 >= 2)
    {
      unint64_t v40 = 0;
      unint64_t v37 = v26 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v21) {
          unint64_t v41 = 0;
        }
        else {
          unint64_t v41 = v40;
        }
        if (v21) {
          unint64_t v42 = 0;
        }
        else {
          unint64_t v42 = v40 + 1;
        }
        int v43 = *(__int16 *)&ElementsAttrRawData[2 * v42];
        uint64_t v44 = &v8[v40 / 2];
        *(_DWORD *)uint64_t v44 = *(__int16 *)&ElementsAttrRawData[2 * v41];
        *((_DWORD *)v44 + 1) = v43;
        v40 += 2;
      }
      while (v40 != v37);
      goto LABEL_286;
    }
    unint64_t v37 = 0;
    do
    {
      if (v21) {
        unint64_t v113 = 0;
      }
      else {
        unint64_t v113 = v37;
      }
      *((_DWORD *)v8 + v37++) = *(__int16 *)&ElementsAttrRawData[2 * v113];
LABEL_286:
      ;
    }
    while (v26 != v37);
    return *(float *)&v25;
  }
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32))
  {
    uint64_t v26 = 1;
LABEL_73:
    for (uint64_t k = 0; k != v26; ++k)
    {
      if (v21) {
        uint64_t v39 = 0;
      }
      else {
        uint64_t v39 = k;
      }
      *((_DWORD *)v8 + k) = *(_DWORD *)&ElementsAttrRawData[4 * v39];
    }
    return *(float *)&v25;
  }
  if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 32))
  {
    uint64_t v26 = 1;
LABEL_93:
    for (uint64_t m = 0; m != v26; ++m)
    {
      if (v21) {
        uint64_t v46 = 0;
      }
      else {
        uint64_t v46 = m;
      }
      *((_DWORD *)v8 + m) = *(_DWORD *)&ElementsAttrRawData[4 * v46];
    }
    return *(float *)&v25;
  }
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
  {
    uint64_t v26 = 1;
LABEL_104:
    if ((unint64_t)v26 >= 2)
    {
      unint64_t v49 = 0;
      unint64_t v47 = v26 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v21) {
          unint64_t v50 = 0;
        }
        else {
          unint64_t v50 = v49;
        }
        if (v21) {
          unint64_t v51 = 0;
        }
        else {
          unint64_t v51 = v49 + 1;
        }
        uint64_t v52 = *(void *)&ElementsAttrRawData[8 * v51];
        uint64_t v53 = &v8[v49 / 2];
        *(_DWORD *)uint64_t v53 = *(void *)&ElementsAttrRawData[8 * v50];
        *((_DWORD *)v53 + 1) = v52;
        v49 += 2;
      }
      while (v49 != v47);
      goto LABEL_292;
    }
    unint64_t v47 = 0;
    do
    {
      if (v21) {
        unint64_t v114 = 0;
      }
      else {
        unint64_t v114 = v47;
      }
      *((_DWORD *)v8 + v47++) = *(void *)&ElementsAttrRawData[8 * v114];
LABEL_292:
      ;
    }
    while (v26 != v47);
    return *(float *)&v25;
  }
  if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 64))
  {
    uint64_t v26 = 1;
LABEL_111:
    if ((unint64_t)v26 >= 2)
    {
      unint64_t v55 = 0;
      unint64_t v48 = v26 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v21) {
          unint64_t v56 = 0;
        }
        else {
          unint64_t v56 = v55;
        }
        if (v21) {
          unint64_t v57 = 0;
        }
        else {
          unint64_t v57 = v55 + 1;
        }
        uint64_t v58 = *(void *)&ElementsAttrRawData[8 * v57];
        unint64_t v59 = &v8[v55 / 2];
        *(_DWORD *)unint64_t v59 = *(void *)&ElementsAttrRawData[8 * v56];
        *((_DWORD *)v59 + 1) = v58;
        v55 += 2;
      }
      while (v55 != v48);
      goto LABEL_298;
    }
    unint64_t v48 = 0;
    do
    {
      if (v21) {
        unint64_t v115 = 0;
      }
      else {
        unint64_t v115 = v48;
      }
      *((_DWORD *)v8 + v48++) = *(void *)&ElementsAttrRawData[8 * v115];
LABEL_298:
      ;
    }
    while (v26 != v48);
    return *(float *)&v25;
  }
  if (mlir::Type::isF16((mlir::Type *)&OperandRange))
  {
    uint64_t v26 = 1;
LABEL_127:
    if ((unint64_t)v26 >= 2)
    {
      unint64_t v61 = 0;
      unint64_t v54 = v26 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v21) {
          unint64_t v62 = 0;
        }
        else {
          unint64_t v62 = v61;
        }
        if (v21) {
          unint64_t v63 = 0;
        }
        else {
          unint64_t v63 = v61 + 1;
        }
        LOWORD(v25) = *(_WORD *)&ElementsAttrRawData[2 * v62];
        int v64 = (int)*(short float *)&ElementsAttrRawData[2 * v63];
        uint64_t v65 = &v8[v61 / 2];
        *(_DWORD *)uint64_t v65 = (int)*(short float *)&v25;
        *((_DWORD *)v65 + 1) = v64;
        v61 += 2;
      }
      while (v61 != v54);
      goto LABEL_304;
    }
    unint64_t v54 = 0;
    do
    {
      if (v21) {
        unint64_t v116 = 0;
      }
      else {
        unint64_t v116 = v54;
      }
      LOWORD(v25) = *(_WORD *)&ElementsAttrRawData[2 * v116];
      *((_DWORD *)v8 + v54++) = (int)*(short float *)&v25;
LABEL_304:
      ;
    }
    while (v26 != v54);
    return *(float *)&v25;
  }
  if (mlir::Type::isF32((mlir::Type *)&OperandRange))
  {
    uint64_t v26 = 1;
LABEL_143:
    if ((unint64_t)v26 >= 2)
    {
      unint64_t v67 = 0;
      unint64_t v60 = v26 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v21) {
          unint64_t v68 = 0;
        }
        else {
          unint64_t v68 = v67;
        }
        if (v21) {
          unint64_t v69 = 0;
        }
        else {
          unint64_t v69 = v67 + 1;
        }
        LODWORD(v25) = *(_DWORD *)&ElementsAttrRawData[4 * v68];
        int v70 = (int)*(float *)&ElementsAttrRawData[4 * v69];
        uint64_t v71 = &v8[v67 / 2];
        *(_DWORD *)uint64_t v71 = (int)*(float *)&v25;
        *((_DWORD *)v71 + 1) = v70;
        v67 += 2;
      }
      while (v67 != v60);
      goto LABEL_310;
    }
    unint64_t v60 = 0;
    do
    {
      if (v21) {
        unint64_t v117 = 0;
      }
      else {
        unint64_t v117 = v60;
      }
      LODWORD(v25) = *(_DWORD *)&ElementsAttrRawData[4 * v117];
      *((_DWORD *)v8 + v60++) = (int)*(float *)&v25;
LABEL_310:
      ;
    }
    while (v26 != v60);
    return *(float *)&v25;
  }
  if (mlir::Type::isF64((mlir::Type *)&OperandRange))
  {
    uint64_t v26 = 1;
LABEL_159:
    if ((unint64_t)v26 >= 2)
    {
      unint64_t v76 = 0;
      unint64_t v66 = v26 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v21) {
          unint64_t v77 = 0;
        }
        else {
          unint64_t v77 = v76;
        }
        if (v21) {
          unint64_t v78 = 0;
        }
        else {
          unint64_t v78 = v76 + 1;
        }
        double v25 = *(double *)&ElementsAttrRawData[8 * v77];
        int v79 = (int)*(double *)&ElementsAttrRawData[8 * v78];
        unint64_t v80 = &v8[v76 / 2];
        *(_DWORD *)unint64_t v80 = (int)v25;
        *((_DWORD *)v80 + 1) = v79;
        v76 += 2;
      }
      while (v76 != v66);
      goto LABEL_316;
    }
    unint64_t v66 = 0;
    do
    {
      if (v21) {
        unint64_t v118 = 0;
      }
      else {
        unint64_t v118 = v66;
      }
      double v25 = *(double *)&ElementsAttrRawData[8 * v118];
      *((_DWORD *)v8 + v66++) = (int)v25;
LABEL_316:
      ;
    }
    while (v26 != v66);
    return *(float *)&v25;
  }
  uint64_t v26 = 1;
  if (!mlir::Type::isBF16((mlir::Type *)&OperandRange))
  {
LABEL_176:
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 1))
    {
      uint64_t v121 = v8;
      if (v21) {
        unint64_t v73 = 1;
      }
      else {
        unint64_t v73 = v26;
      }
      uint64_t v126 = v128;
      LODWORD(v25) = 0;
      long long v127 = xmmword_1810FE310;
      if (v73)
      {
        if (v73 < 0x29)
        {
          uint64_t v75 = 0;
          unint64_t v74 = v128;
        }
        else
        {
          llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v126, v128, v73, 1);
          unint64_t v74 = v126;
          uint64_t v75 = v127;
        }
        if (v73 != v75)
        {
          bzero((char *)v74 + v75, v73 - v75);
          unint64_t v74 = v126;
        }
        *(void *)&long long v127 = v73;
      }
      else
      {
        unint64_t v74 = v128;
      }
      if (!v24)
      {
LABEL_268:
        if (v26 >= 1)
        {
          for (uint64_t n = 0; n != v26; ++n)
          {
            if (v21) {
              uint64_t v111 = 0;
            }
            else {
              uint64_t v111 = n;
            }
            *((_DWORD *)v121 + n) = *((char *)v74 + v111);
          }
        }
        if (v74 != v128) {
          free(v74);
        }
        return *(float *)&v25;
      }
      uint64_t v100 = (BOOL *)v74 + 3;
      LODWORD(v25) = 0;
      while (1)
      {
        if (v73 >= 8) {
          uint64_t v101 = 8;
        }
        else {
          uint64_t v101 = v73;
        }
        if (!v101) {
          goto LABEL_238;
        }
        if (v73 >= 8) {
          uint64_t v102 = 8;
        }
        else {
          uint64_t v102 = v73;
        }
        unsigned int v103 = *ElementsAttrRawData;
        uint64x2_t v104 = (uint64x2_t)vdupq_n_s64(v102 - 1);
        int32x2_t v105 = vmovn_s64((int64x2_t)vcgeq_u64(v104, (uint64x2_t)xmmword_1810FE2E0));
        if (v105.i8[0]) {
          *(v100 - 3) = v103 & 1;
        }
        if (v105.i8[4]) {
          *(v100 - 2) = (v103 & 2) != 0;
        }
        uint64_t v106 = ((_BYTE)v102 + 1) & 0x1E;
        if (v106 == 2) {
          goto LABEL_238;
        }
        int32x2_t v107 = vmovn_s64((int64x2_t)vcgtq_u64(v104, (uint64x2_t)xmmword_1810FE320));
        if (v107.i8[0])
        {
          *(v100 - 1) = (v103 & 4) != 0;
          if (v107.i8[4]) {
            goto LABEL_256;
          }
        }
        else if (v107.i8[4])
        {
LABEL_256:
          BOOL *v100 = (v103 & 8) != 0;
          if (v106 == 4) {
            goto LABEL_238;
          }
          goto LABEL_257;
        }
        if (v106 == 4) {
          goto LABEL_238;
        }
LABEL_257:
        int32x2_t v108 = vmovn_s64((int64x2_t)vcgtq_u64(v104, (uint64x2_t)xmmword_1810FE330));
        if (v108.i8[0])
        {
          v100[1] = (v103 & 0x10) != 0;
          if ((v108.i8[4] & 1) == 0) {
            goto LABEL_259;
          }
        }
        else if ((v108.i8[4] & 1) == 0)
        {
LABEL_259:
          if (v106 != 6) {
            goto LABEL_263;
          }
          goto LABEL_238;
        }
        v100[2] = (v103 & 0x20) != 0;
        if (v106 != 6)
        {
LABEL_263:
          int32x2_t v109 = vmovn_s64((int64x2_t)vcgtq_u64(v104, (uint64x2_t)xmmword_1810FE340));
          if (v109.i8[0]) {
            v100[3] = (v103 & 0x40) != 0;
          }
          if (v109.i8[4]) {
            v100[4] = v103 >> 7;
          }
        }
LABEL_238:
        ++ElementsAttrRawData;
        v100 += 8;
        v73 -= 8;
        if (!--v24)
        {
          unint64_t v74 = v126;
          goto LABEL_268;
        }
      }
    }
    mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange);
    unsigned int IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange);
    if (!v24) {
      return *(float *)&v25;
    }
    uint64_t v82 = 0;
    int v83 = ~(-1 << IntOrFloatBitWidth);
    LODWORD(v25) = 0;
    unint64_t v84 = v26;
    unint64_t v85 = 8 / IntOrFloatBitWidth;
    while (1)
    {
      unint64_t v86 = v82 * v85;
      unint64_t v87 = v26 - v82 * v85;
      if (v87 >= v85) {
        unint64_t v87 = 8 / IntOrFloatBitWidth;
      }
      if (!v87) {
        goto LABEL_194;
      }
      unsigned int v88 = *ElementsAttrRawData;
      if (v84 >= v85) {
        unint64_t v89 = 8 / IntOrFloatBitWidth;
      }
      else {
        unint64_t v89 = v84;
      }
      uint64x2_t v90 = (uint64x2_t)vdupq_n_s64(v89 - 1);
      int32x2_t v91 = vmovn_s64((int64x2_t)vcgeq_u64(v90, (uint64x2_t)xmmword_1810FE2E0));
      if (v91.i8[0]) {
        *((_DWORD *)v8 + v86) = v83 & v88;
      }
      if (v91.i8[4]) {
        *((_DWORD *)v8 + v86 + 1) = (v88 >> IntOrFloatBitWidth) & v83;
      }
      uint64_t v92 = ((_BYTE)v89 + 1) & 0x1E;
      if (v92 == 2) {
        goto LABEL_194;
      }
      int32x2_t v93 = vmovn_s64((int64x2_t)vcgtq_u64(v90, (uint64x2_t)xmmword_1810FE320));
      if (v93.i8[0])
      {
        *((_DWORD *)v8 + v86 + 2) = (v88 >> (2 * IntOrFloatBitWidth)) & v83;
        if (v93.i8[4]) {
          goto LABEL_211;
        }
      }
      else if (v93.i8[4])
      {
LABEL_211:
        *((_DWORD *)v8 + v86 + 3) = (v88 >> (3 * IntOrFloatBitWidth)) & v83;
        if (v92 == 4) {
          goto LABEL_194;
        }
        goto LABEL_212;
      }
      if (v92 == 4) {
        goto LABEL_194;
      }
LABEL_212:
      int32x2_t v94 = vmovn_s64((int64x2_t)vcgtq_u64(v90, (uint64x2_t)xmmword_1810FE330));
      if (v94.i8[0])
      {
        *((_DWORD *)v8 + v86 + 4) = (v88 >> (4 * IntOrFloatBitWidth)) & v83;
        if ((v94.i8[4] & 1) == 0) {
          goto LABEL_214;
        }
      }
      else if ((v94.i8[4] & 1) == 0)
      {
LABEL_214:
        if (v92 != 6) {
          goto LABEL_218;
        }
        goto LABEL_194;
      }
      *((_DWORD *)v8 + v86 + 5) = (v88 >> (5 * IntOrFloatBitWidth)) & v83;
      if (v92 != 6)
      {
LABEL_218:
        int32x2_t v95 = vmovn_s64((int64x2_t)vcgtq_u64(v90, (uint64x2_t)xmmword_1810FE340));
        if (v95.i8[0]) {
          *((_DWORD *)v8 + v86 + 6) = (v88 >> (6 * IntOrFloatBitWidth)) & v83;
        }
        if (v95.i8[4]) {
          *((_DWORD *)v8 + v86 + 7) = (v88 >> (7 * IntOrFloatBitWidth)) & v83;
        }
      }
LABEL_194:
      ++v82;
      v84 -= v85;
      ++ElementsAttrRawData;
      if (!--v24) {
        return *(float *)&v25;
      }
    }
  }
LABEL_174:
  if ((unint64_t)v26 >= 2)
  {
    uint64_t v96 = 0;
    unint64_t v72 = v26 & 0xFFFFFFFFFFFFFFFELL;
    unint64_t v97 = v8;
    do
    {
      if (v21) {
        uint64_t v98 = 0;
      }
      else {
        uint64_t v98 = v96;
      }
      if (v21) {
        uint64_t v99 = 0;
      }
      else {
        uint64_t v99 = v96 + 1;
      }
      LOWORD(v25) = *(_WORD *)&ElementsAttrRawData[2 * v98];
      WORD2(v25) = *(_WORD *)&ElementsAttrRawData[2 * v99];
      double v25 = COERCE_DOUBLE(vcvt_s32_f32((float32x2_t)vshl_n_s32(*(int32x2_t *)&v25, 0x10uLL)));
      *v97++ = v25;
      v96 += 2;
    }
    while (v96 != v72);
    goto LABEL_322;
  }
  unint64_t v72 = 0;
  do
  {
    if (v21) {
      unint64_t v119 = 0;
    }
    else {
      unint64_t v119 = v72;
    }
    LODWORD(v25) = *(unsigned __int16 *)&ElementsAttrRawData[2 * v119] << 16;
    *((_DWORD *)v8 + v72++) = (int)*(float *)&v25;
LABEL_322:
    ;
  }
  while (v26 != v72);
  return *(float *)&v25;
}

void mlir::mps::anonymous namespace'::LowerDequantizeND::~LowerDequantizeND(mlir::mps::_anonymous_namespace_::LowerDequantizeND *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::mps::anonymous namespace'::LowerDequantizeND::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v214[6] = *MEMORY[0x1E4F143B8];
  uint64_t v196 = a2;
  if (!mlir::mps::DequantizeOp::hasNDParams((mlir::mps::DequantizeOp *)&v196)) {
    return 0;
  }
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v196);
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v196);
  uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v196);
  uint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v196);
  uint64_t FunctionType = (uint64_t *)mlir::func::FuncOp::getFunctionType((mlir::func::FuncOp *)&v196);
  unint64_t v10 = (uint64_t *)(*(void *)(Input + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_11;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_11;
  }
  unint64_t v14 = *(void **)(v11 + 8);
  uint64_t v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    unint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    uint64_t v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      unint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_11:
  }
    uint64_t v20 = 0;
  v195[0] = v10;
  v195[1] = v20;
  int v21 = (uint64_t *)(*(void *)(Filter + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v21) {
    goto LABEL_21;
  }
  uint64_t v22 = *v21;
  unint64_t v23 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v24 = *(unsigned int *)(v22 + 16);
  if (!v24) {
    goto LABEL_21;
  }
  double v25 = *(void **)(v22 + 8);
  uint64_t v26 = &v25[2 * v24];
  do
  {
    unint64_t v27 = v24 >> 1;
    uint64_t v28 = &v25[2 * (v24 >> 1)];
    unint64_t v30 = *v28;
    uint64_t v29 = v28 + 2;
    v24 += ~(v24 >> 1);
    if (v30 < v23) {
      double v25 = v29;
    }
    else {
      unint64_t v24 = v27;
    }
  }
  while (v24);
  if (v25 != v26 && *v25 == v23) {
    uint64_t v31 = v25[1];
  }
  else {
LABEL_21:
  }
    uint64_t v31 = 0;
  v194[0] = v21;
  v194[1] = v31;
  unint64_t v32 = (uint64_t *)(*(void *)(Bias + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v32) {
    goto LABEL_31;
  }
  uint64_t v33 = *v32;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_31;
  }
  unint64_t v36 = *(void **)(v33 + 8);
  unint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      unint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_31:
  }
    uint64_t v42 = 0;
  v193[0] = v32;
  v193[1] = v42;
  int v43 = (uint64_t *)(*(void *)(SparseShape + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v43) {
    goto LABEL_41;
  }
  uint64_t v44 = *v43;
  unint64_t v45 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v46 = *(unsigned int *)(v44 + 16);
  if (!v46) {
    goto LABEL_41;
  }
  unint64_t v47 = *(void **)(v44 + 8);
  unint64_t v48 = &v47[2 * v46];
  do
  {
    unint64_t v49 = v46 >> 1;
    unint64_t v50 = &v47[2 * (v46 >> 1)];
    unint64_t v52 = *v50;
    unint64_t v51 = v50 + 2;
    v46 += ~(v46 >> 1);
    if (v52 < v45) {
      unint64_t v47 = v51;
    }
    else {
      unint64_t v46 = v49;
    }
  }
  while (v46);
  if (v47 != v48 && *v47 == v45) {
    uint64_t v53 = v47[1];
  }
  else {
LABEL_41:
  }
    uint64_t v53 = 0;
  v192[0] = v43;
  v192[1] = v53;
  uint64_t v54 = *(void *)(v196 + 24);
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v195)) {
    return 0;
  }
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v195);
  if (v56)
  {
    uint64_t v57 = 8 * v56;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v57 -= 8;
      if (!v57) {
        goto LABEL_47;
      }
    }
    return 0;
  }
LABEL_47:
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v194)) {
    return 0;
  }
  uint64_t v58 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v194);
  if (v59)
  {
    uint64_t v60 = 8 * v59;
    while (*v58 != 0x8000000000000000)
    {
      ++v58;
      v60 -= 8;
      if (!v60) {
        goto LABEL_52;
      }
    }
    return 0;
  }
LABEL_52:
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v193)) {
    return 0;
  }
  unint64_t v61 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v193);
  if (v62)
  {
    uint64_t v63 = 8 * v62;
    while (*v61 != 0x8000000000000000)
    {
      ++v61;
      v63 -= 8;
      if (!v63) {
        goto LABEL_57;
      }
    }
    return 0;
  }
LABEL_57:
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v192)) {
    return 0;
  }
  int v64 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v192);
  if (v65)
  {
    uint64_t v66 = 8 * v65;
    while (*v64 != 0x8000000000000000)
    {
      ++v64;
      v66 -= 8;
      if (!v66) {
        goto LABEL_62;
      }
    }
    return 0;
  }
LABEL_62:
  uint64_t v206 = v67;
  uint64_t v207 = v54;
  uint64_t v205 = v69;
  uint64_t v71 = (void *)(*((void *)v67 + 1) & 0xFFFFFFFFFFFFFFF8);
  if (!v71) {
    goto LABEL_71;
  }
  uint64_t v72 = *v71;
  unint64_t v73 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v74 = *(unsigned int *)(v72 + 16);
  if (!v74) {
    goto LABEL_71;
  }
  uint64_t v75 = *(void **)(v72 + 8);
  unint64_t v76 = &v75[2 * v74];
  do
  {
    unint64_t v77 = v74 >> 1;
    unint64_t v78 = &v75[2 * (v74 >> 1)];
    unint64_t v80 = *v78;
    int v79 = v78 + 2;
    v74 += ~(v74 >> 1);
    if (v80 < v73) {
      uint64_t v75 = v79;
    }
    else {
      unint64_t v74 = v77;
    }
  }
  while (v74);
  if (v75 != v76 && *v75 == v73) {
    uint64_t v81 = v75[1];
  }
  else {
LABEL_71:
  }
    uint64_t v81 = 0;
  uint64_t v203 = v71;
  uint64_t v204 = v81;
  uint64_t v82 = (void *)(*((void *)v69 + 1) & 0xFFFFFFFFFFFFFFF8);
  if (!v82) {
    goto LABEL_81;
  }
  uint64_t v83 = *v82;
  unint64_t v84 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v85 = *(unsigned int *)(v83 + 16);
  if (!v85) {
    goto LABEL_81;
  }
  unint64_t v86 = *(void **)(v83 + 8);
  unint64_t v87 = &v86[2 * v85];
  do
  {
    unint64_t v88 = v85 >> 1;
    unint64_t v89 = &v86[2 * (v85 >> 1)];
    unint64_t v91 = *v89;
    uint64x2_t v90 = v89 + 2;
    v85 += ~(v85 >> 1);
    if (v91 < v84) {
      unint64_t v86 = v90;
    }
    else {
      unint64_t v85 = v88;
    }
  }
  while (v85);
  if (v86 != v87 && *v86 == v84) {
    uint64_t v92 = v86[1];
  }
  else {
LABEL_81:
  }
    uint64_t v92 = 0;
  uint64_t v201 = v82;
  uint64_t v202 = v92;
  int32x2_t v93 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v201);
  if (mlir::ShapedType::getNumElements(v93, v94) == 1)
  {
    int32x2_t v95 = (char *)mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::Value &>((mlir::Float32Type **)(a4 + 8), v54, (uint64_t *)&v206, (uint64_t *)&v205)- 16;
  }
  else
  {
    uint64_t v191 = v70;
    uint64_t v212 = (char *)v214;
    uint64_t v213 = 0x600000000;
    unint64_t v209 = v211;
    uint64_t v210 = 0x600000000;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v203);
    if (v98)
    {
      for (unint64_t i = 0; i < v108; ++i)
      {
        uint64_t v100 = 8 * i;
        uint64_t v101 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v203) + v100);
        uint64_t v102 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v201) + v100);
        uint64_t v103 = v213;
        if (v101 == v102)
        {
          if (v213 >= (unint64_t)HIDWORD(v213))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v212, v214, v213 + 1, 8);
            uint64_t v103 = v213;
          }
          *(void *)&v212[8 * v103] = v101;
          LODWORD(v213) = v213 + 1;
          unsigned int v104 = v210;
          unsigned int v105 = HIDWORD(v210);
        }
        else
        {
          if (v213 >= (unint64_t)HIDWORD(v213))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v212, v214, v213 + 1, 8);
            uint64_t v103 = v213;
          }
          *(void *)&v212[8 * v103] = v102;
          uint64_t v106 = (v213 + 1);
          LODWORD(v213) = v106;
          if (v106 >= HIDWORD(v213))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v212, v214, v106 + 1, 8);
            LODWORD(v106) = v213;
          }
          *(void *)&v212[8 * v106] = v101 / v102;
          LODWORD(v213) = v213 + 1;
          uint64_t v107 = v210;
          if (v210 >= (unint64_t)HIDWORD(v210))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v209, v211, v210 + 1, 8);
            uint64_t v107 = v210;
          }
          *((void *)v209 + v107) = v102;
          unsigned int v105 = HIDWORD(v210);
          unsigned int v104 = v210 + 1;
          LODWORD(v210) = v210 + 1;
          uint64_t v101 = 1;
        }
        if (v104 >= v105)
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v209, v211, v104 + 1, 8);
          unsigned int v104 = v210;
        }
        *((void *)v209 + v104) = v101;
        LODWORD(v210) = v210 + 1;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v203);
      }
    }
    uint64_t v199 = (uint64_t *)a4;
    long long v200 = &v207;
    int32x2_t v109 = (char *)mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::Value &>((mlir::Float32Type **)(a4 + 8), v207, (uint64_t *)&v198, (uint64_t *)&v197)- 16;
    uint64_t v110 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v203);
    if (v209 != v211) {
      free(v209);
    }
    if (v212 != (char *)v214) {
      free(v212);
    }
    int v70 = v191;
  }
  uint64_t v206 = v95;
  uint64_t v207 = v54;
  uint64_t v205 = v68;
  unint64_t v112 = (void *)(*((void *)v95 + 1) & 0xFFFFFFFFFFFFFFF8);
  if (!v112) {
    goto LABEL_120;
  }
  uint64_t v113 = *v112;
  unint64_t v114 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v115 = *(unsigned int *)(v113 + 16);
  if (!v115) {
    goto LABEL_120;
  }
  unint64_t v116 = *(void **)(v113 + 8);
  unint64_t v117 = &v116[2 * v115];
  do
  {
    unint64_t v118 = v115 >> 1;
    unint64_t v119 = &v116[2 * (v115 >> 1)];
    unint64_t v121 = *v119;
    uint64_t v120 = v119 + 2;
    v115 += ~(v115 >> 1);
    if (v121 < v114) {
      unint64_t v116 = v120;
    }
    else {
      unint64_t v115 = v118;
    }
  }
  while (v115);
  if (v116 != v117 && *v116 == v114) {
    uint64_t v122 = v116[1];
  }
  else {
LABEL_120:
  }
    uint64_t v122 = 0;
  uint64_t v203 = v112;
  uint64_t v204 = v122;
  uint64_t v123 = (void *)(*((void *)v68 + 1) & 0xFFFFFFFFFFFFFFF8);
  if (!v123) {
    goto LABEL_130;
  }
  uint64_t v124 = *v123;
  unint64_t v125 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v126 = *(unsigned int *)(v124 + 16);
  if (!v126) {
    goto LABEL_130;
  }
  long long v127 = *(void **)(v124 + 8);
  uint64_t v128 = &v127[2 * v126];
  do
  {
    unint64_t v129 = v126 >> 1;
    unint64_t v130 = &v127[2 * (v126 >> 1)];
    unint64_t v132 = *v130;
    uint64_t v131 = v130 + 2;
    v126 += ~(v126 >> 1);
    if (v132 < v125) {
      long long v127 = v131;
    }
    else {
      unint64_t v126 = v129;
    }
  }
  while (v126);
  if (v127 != v128 && *v127 == v125) {
    uint64_t v133 = v127[1];
  }
  else {
LABEL_130:
  }
    uint64_t v133 = 0;
  uint64_t v201 = v123;
  uint64_t v202 = v133;
  uint64_t v134 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v201);
  if (mlir::ShapedType::getNumElements(v134, v135) == 1)
  {
    uint64_t v136 = (char *)mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)(a4 + 8), v54, (uint64_t *)&v206, (uint64_t *)&v205)- 16;
  }
  else
  {
    uint64_t v212 = (char *)v214;
    uint64_t v213 = 0x600000000;
    unint64_t v209 = v211;
    uint64_t v210 = 0x600000000;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v203);
    if (v137)
    {
      for (unint64_t j = 0; j < v147; ++j)
      {
        uint64_t v139 = 8 * j;
        uint64_t v140 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v203) + v139);
        uint64_t v141 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v201) + v139);
        uint64_t v142 = v213;
        if (v140 == v141)
        {
          if (v213 >= (unint64_t)HIDWORD(v213))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v212, v214, v213 + 1, 8);
            uint64_t v142 = v213;
          }
          *(void *)&v212[8 * v142] = v140;
          LODWORD(v213) = v213 + 1;
          unsigned int v143 = v210;
          unsigned int v144 = HIDWORD(v210);
        }
        else
        {
          if (v213 >= (unint64_t)HIDWORD(v213))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v212, v214, v213 + 1, 8);
            uint64_t v142 = v213;
          }
          *(void *)&v212[8 * v142] = v141;
          uint64_t v145 = (v213 + 1);
          LODWORD(v213) = v145;
          if (v145 >= HIDWORD(v213))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v212, v214, v145 + 1, 8);
            LODWORD(v145) = v213;
          }
          *(void *)&v212[8 * v145] = v140 / v141;
          LODWORD(v213) = v213 + 1;
          uint64_t v146 = v210;
          if (v210 >= (unint64_t)HIDWORD(v210))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v209, v211, v210 + 1, 8);
            uint64_t v146 = v210;
          }
          *((void *)v209 + v146) = v141;
          unsigned int v144 = HIDWORD(v210);
          unsigned int v143 = v210 + 1;
          LODWORD(v210) = v210 + 1;
          uint64_t v140 = 1;
        }
        if (v143 >= v144)
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v209, v211, v143 + 1, 8);
          unsigned int v143 = v210;
        }
        *((void *)v209 + v143) = v140;
        LODWORD(v210) = v210 + 1;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v203);
      }
    }
    uint64_t v199 = (uint64_t *)a4;
    long long v200 = &v207;
    unint64_t v148 = (char *)mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)(a4 + 8), v207, (uint64_t *)&v198, (uint64_t *)&v197)- 16;
    uint64_t v149 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v203);
    if (v209 != v211) {
      free(v209);
    }
    if (v212 != (char *)v214) {
      free(v212);
    }
  }
  uint64_t v206 = v136;
  uint64_t v207 = v54;
  uint64_t v205 = v70;
  uint64_t v151 = (void *)(*((void *)v136 + 1) & 0xFFFFFFFFFFFFFFF8);
  if (!v151) {
    goto LABEL_162;
  }
  uint64_t v152 = *v151;
  unint64_t v153 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v154 = *(unsigned int *)(v152 + 16);
  if (!v154) {
    goto LABEL_162;
  }
  int v155 = *(void **)(v152 + 8);
  int64_t v156 = &v155[2 * v154];
  do
  {
    unint64_t v157 = v154 >> 1;
    uint64_t v158 = &v155[2 * (v154 >> 1)];
    unint64_t v160 = *v158;
    unint64_t v159 = v158 + 2;
    v154 += ~(v154 >> 1);
    if (v160 < v153) {
      int v155 = v159;
    }
    else {
      unint64_t v154 = v157;
    }
  }
  while (v154);
  if (v155 != v156 && *v155 == v153) {
    uint64_t v161 = v155[1];
  }
  else {
LABEL_162:
  }
    uint64_t v161 = 0;
  uint64_t v203 = v151;
  uint64_t v204 = v161;
  long long v162 = (void *)(*((void *)v70 + 1) & 0xFFFFFFFFFFFFFFF8);
  if (!v162) {
    goto LABEL_172;
  }
  uint64_t v163 = *v162;
  unint64_t v164 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v165 = *(unsigned int *)(v163 + 16);
  if (!v165) {
    goto LABEL_172;
  }
  long long v166 = *(void **)(v163 + 8);
  long long v167 = &v166[2 * v165];
  do
  {
    unint64_t v168 = v165 >> 1;
    uint64_t v169 = &v166[2 * (v165 >> 1)];
    unint64_t v171 = *v169;
    uint64_t v170 = v169 + 2;
    v165 += ~(v165 >> 1);
    if (v171 < v164) {
      long long v166 = v170;
    }
    else {
      unint64_t v165 = v168;
    }
  }
  while (v165);
  if (v166 != v167 && *v166 == v164) {
    uint64_t v172 = v166[1];
  }
  else {
LABEL_172:
  }
    uint64_t v172 = 0;
  uint64_t v201 = v162;
  uint64_t v202 = v172;
  uint64_t v173 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v201);
  if (mlir::ShapedType::getNumElements(v173, v174) == 1)
  {
    unint64_t v175 = (char *)mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)(a4 + 8), v54, (uint64_t *)&v206, (uint64_t *)&v205)- 16;
  }
  else
  {
    uint64_t v212 = (char *)v214;
    uint64_t v213 = 0x600000000;
    unint64_t v209 = v211;
    uint64_t v210 = 0x600000000;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v203);
    if (v176)
    {
      for (unint64_t k = 0; k < v186; ++k)
      {
        uint64_t v178 = 8 * k;
        uint64_t v179 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v203) + v178);
        uint64_t v180 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v201) + v178);
        uint64_t v181 = v213;
        if (v179 == v180)
        {
          if (v213 >= (unint64_t)HIDWORD(v213))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v212, v214, v213 + 1, 8);
            uint64_t v181 = v213;
          }
          *(void *)&v212[8 * v181] = v179;
          LODWORD(v213) = v213 + 1;
          unsigned int v182 = v210;
          unsigned int v183 = HIDWORD(v210);
        }
        else
        {
          if (v213 >= (unint64_t)HIDWORD(v213))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v212, v214, v213 + 1, 8);
            uint64_t v181 = v213;
          }
          *(void *)&v212[8 * v181] = v180;
          uint64_t v184 = (v213 + 1);
          LODWORD(v213) = v184;
          if (v184 >= HIDWORD(v213))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v212, v214, v184 + 1, 8);
            LODWORD(v184) = v213;
          }
          *(void *)&v212[8 * v184] = v179 / v180;
          LODWORD(v213) = v213 + 1;
          uint64_t v185 = v210;
          if (v210 >= (unint64_t)HIDWORD(v210))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v209, v211, v210 + 1, 8);
            uint64_t v185 = v210;
          }
          *((void *)v209 + v185) = v180;
          unsigned int v183 = HIDWORD(v210);
          unsigned int v182 = v210 + 1;
          LODWORD(v210) = v210 + 1;
          uint64_t v179 = 1;
        }
        if (v182 >= v183)
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v209, v211, v182 + 1, 8);
          unsigned int v182 = v210;
        }
        *((void *)v209 + v182) = v179;
        LODWORD(v210) = v210 + 1;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v203);
      }
    }
    uint64_t v199 = (uint64_t *)a4;
    long long v200 = &v207;
    unint64_t v187 = (char *)mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)(a4 + 8), v207, (uint64_t *)&v198, (uint64_t *)&v197)- 16;
    uint64_t v188 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v203);
    if (v209 != v211) {
      free(v209);
    }
    if (v212 != (char *)v214) {
      free(v212);
    }
  }
  unint64_t v190 = (unsigned int *)v196;
  uint64_t v212 = v175;
  uint64_t v96 = 1;
  mlir::ValueRange::ValueRange(v208, (uint64_t)&v212, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, v190, v208[0], v208[1]);
  return v96;
}

char *mlir::mps::anonymous namespace'::LowerDequantizeND::broadcastGrouped<mlir::mps::SubtractOp>(mlir::ConversionPatternRewriter &,mlir::Location,mlir::Value,mlir::Value)const::{lambda(mlir::Value,llvm::ArrayRef<long long>)#1}::operator()(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v26[1] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = a2;
  unint64_t v7 = (mlir::Builder *)(*a1 + 1);
  uint64_t v8 = *a1[1];
  v26[0] = a4;
  uint64_t IntegerType = mlir::Builder::getIntegerType(v7, 0x40u, 1);
  unint64_t v10 = (void *)mlir::RankedTensorType::get((uint64_t)v26, 1, IntegerType, 0);
  uint64_t v11 = v10;
  if (!v10) {
    goto LABEL_10;
  }
  uint64_t v12 = *v10;
  unint64_t v13 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v14 = *(unsigned int *)(v12 + 16);
  if (!v14) {
    goto LABEL_10;
  }
  uint64_t v15 = *(void **)(v12 + 8);
  unint64_t v16 = &v15[2 * v14];
  do
  {
    unint64_t v17 = v14 >> 1;
    uint64_t v18 = &v15[2 * (v14 >> 1)];
    unint64_t v20 = *v18;
    unint64_t v19 = v18 + 2;
    v14 += ~(v14 >> 1);
    if (v20 < v13) {
      uint64_t v15 = v19;
    }
    else {
      unint64_t v14 = v17;
    }
  }
  while (v14);
  if (v15 != v16 && *v15 == v13) {
    uint64_t v21 = v15[1];
  }
  else {
LABEL_10:
  }
    uint64_t v21 = 0;
  unint64_t v23 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v11, v21, a3, 8 * a4, 8, 1, 1);
  unint64_t v24 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v7, v8, &v23);
  return (char *)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::UnitAttr **)*a1 + 1, *a1[1], &v25, &v24)- 16;
}

void mlir::mps::anonymous namespace'::LowerPerAxisDequantize::~LowerPerAxisDequantize(mlir::mps::_anonymous_namespace_::LowerPerAxisDequantize *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::mps::anonymous namespace'::LowerPerAxisDequantize::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  v48[4] = *MEMORY[0x1E4F143B8];
  uint64_t v44 = a2;
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v44);
  uint64_t v43 = Input;
  __b = (void *)mlir::getElementTypeOrSelf(Input);
  if (*(_UNKNOWN **)(*(void *)__b + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id
    || mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&__b) != 4
    || !mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v44))
  {
    return 0;
  }
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v44);
  uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v44);
  uint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v44);
  uint64_t v9 = (uint64_t *)(*(void *)(Input + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v9) {
    goto LABEL_13;
  }
  uint64_t v10 = *v9;
  unint64_t v11 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v12 = *(unsigned int *)(v10 + 16);
  if (!v12) {
    goto LABEL_13;
  }
  unint64_t v13 = *(void **)(v10 + 8);
  unint64_t v14 = &v13[2 * v12];
  do
  {
    unint64_t v15 = v12 >> 1;
    unint64_t v16 = &v13[2 * (v12 >> 1)];
    unint64_t v18 = *v16;
    unint64_t v17 = v16 + 2;
    v12 += ~(v12 >> 1);
    if (v18 < v11) {
      unint64_t v13 = v17;
    }
    else {
      unint64_t v12 = v15;
    }
  }
  while (v12);
  if (v13 != v14 && *v13 == v11) {
    uint64_t v19 = v13[1];
  }
  else {
LABEL_13:
  }
    uint64_t v19 = 0;
  v42[0] = v9;
  v42[1] = v19;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v42)) {
    return 0;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v42);
  unint64_t v21 = v20;
  int Axis = mlir::mps::DequantizeLUTOp::getAxis((mlir::mps::DequantizeLUTOp *)&v44);
  uint64_t PositiveAxis = mlir::getPositiveAxis(Axis, v21);
  uint64_t v41 = PositiveAxis;
  __b = v48;
  int v47 = 4;
  if (v21 < 5)
  {
    if (v21) {
      memset_pattern16(v48, &unk_1810FE350, 8 * v21);
    }
    unint64_t v24 = v48;
  }
  else
  {
    int v46 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__b, v48, v21, 8);
    unint64_t v24 = __b;
    memset_pattern16(__b, &unk_1810FE350, 8 * v21);
  }
  int v46 = v21;
  v24[PositiveAxis] = -1;
  v40[0] = a4;
  v40[1] = &v44;
  v40[2] = &__b;
  v40[3] = &v41;
  char v29 = v28;
  v39[0] = v27;
  v39[1] = v28;
  char v32 = v31;
  v38[0] = v30;
  v38[1] = v31;
  uint64_t v25 = 0;
  v37[0] = v33;
  v37[1] = v34;
  if (v29 && v32 && (_BYTE)v34)
  {
    uint64_t v35 = v44;
    uint64_t InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v44);
    mlir::RewriterBase::replaceOpWithNewOp<mlir::mps::DequantizeOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,mlir::TypeAttr,decltype(nullptr)>((mlir::UnknownLoc **)a4, v35, &v43, v39, v38, v37, &InputAttributeNames);
    uint64_t v25 = 1;
  }
  if (__b != v48) {
    free(__b);
  }
  return v25;
}

unint64_t mlir::mps::anonymous namespace'::LowerPerAxisDequantize::matchAndRewrite(mlir::mps::DequantizeOp,mlir::mps::DequantizeOpAdaptor,mlir::ConversionPatternRewriter &)const::{lambda(mlir::Value)#1}::operator()(void **a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v48 = a2;
  uint64_t v4 = (uint64_t *)(*(void *)(a2 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v4) {
    goto LABEL_10;
  }
  uint64_t v5 = *v4;
  unint64_t v6 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v7 = *(unsigned int *)(v5 + 16);
  if (!v7) {
    goto LABEL_10;
  }
  uint64_t v8 = *(void **)(v5 + 8);
  uint64_t v9 = &v8[2 * v7];
  do
  {
    unint64_t v10 = v7 >> 1;
    unint64_t v11 = &v8[2 * (v7 >> 1)];
    unint64_t v13 = *v11;
    unint64_t v12 = v11 + 2;
    v7 += ~(v7 >> 1);
    if (v13 < v6) {
      uint64_t v8 = v12;
    }
    else {
      unint64_t v7 = v10;
    }
  }
  while (v7);
  if (v8 != v9 && *v8 == v6) {
    uint64_t v14 = v8[1];
  }
  else {
LABEL_10:
  }
    uint64_t v14 = 0;
  v47[0] = v4;
  v47[1] = v14;
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v47))
  {
    uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v47);
    if (v16)
    {
      uint64_t v17 = 8 * v16;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v17 -= 8;
        if (!v17) {
          goto LABEL_16;
        }
      }
    }
    else
    {
LABEL_16:
      unint64_t v18 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v47);
      if (mlir::ShapedType::getNumElements(v18, v19) == 1)
      {
        unint64_t DefiningOp = v2 & 0xFFFFFFFFFFFFFF00;
        return DefiningOp & 0xFFFFFFFFFFFFFF00 | v2;
      }
    }
  }
  *(void *)&long long v49 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v47);
  if (*(_UNKNOWN **)(*(void *)v49 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id
    && mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&v49) == 4)
  {
    unint64_t v45 = 0;
    uint64_t v46 = 0;
    v44[0] = &v45;
    *(void *)&long long v49 = v2;
    unint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v49);
    if (DefiningOp)
    {
      if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(v44, DefiningOp))
      {
        *(void *)(*a1[2] + 8 * *a1[3]) = mlir::ElementsAttr::getNumElements((uint64_t)v45, v46);
        uint64_t v2 = (uint64_t)v45;
        uint64_t v21 = v46;
        uint64_t Type = (uint64_t **)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v45);
        unint64_t v23 = Type;
        if (!Type) {
          goto LABEL_31;
        }
        unint64_t v24 = *Type;
        unint64_t v25 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v26 = *((unsigned int *)v24 + 4);
        if (!v26) {
          goto LABEL_31;
        }
        unint64_t v27 = (void *)v24[1];
        uint64_t v28 = &v27[2 * v26];
        do
        {
          unint64_t v29 = v26 >> 1;
          unint64_t v30 = &v27[2 * (v26 >> 1)];
          unint64_t v32 = *v30;
          uint64_t v31 = v30 + 2;
          v26 += ~(v26 >> 1);
          if (v32 < v25) {
            unint64_t v27 = v31;
          }
          else {
            unint64_t v26 = v29;
          }
        }
        while (v26);
        if (v27 != v28 && *v27 == v25) {
          unint64_t v33 = (uint64_t **)v27[1];
        }
        else {
LABEL_31:
        }
          unint64_t v33 = 0;
        v44[0] = v23;
        v44[1] = v33;
        uint64_t v34 = a1[2];
        uint64_t v35 = *v34;
        uint64_t v36 = *((unsigned int *)v34 + 2);
        *(void *)&long long v49 = v35;
        *((void *)&v49 + 1) = v36;
        char v50 = 1;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v44);
        uint64_t v38 = mlir::ShapedType::cloneWith((uint64_t *)v44, &v49, OperandRange);
        unint64_t v45 = mlir::reshapeElementsAttr(v2, v21, v38, v39);
        uint64_t v46 = v40;
        *(void *)&long long v49 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ElementsAttr &>((mlir::OpBuilder *)(*a1 + 1), *(void *)(*a1[1] + 24), (uint64_t)&v45);
        uint64_t v41 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v49);
        LOBYTE(v2) = v41;
        unint64_t DefiningOp = v41 & 0xFFFFFFFFFFFFFF00;
      }
      else
      {
        LOBYTE(v2) = 0;
        unint64_t DefiningOp = 0;
      }
    }
    else
    {
      LOBYTE(v2) = 0;
    }
  }
  else
  {
    *(void *)&long long v49 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::SmallVector<long long,6u>>((mlir::Builder *)(*a1 + 1), *(void *)(*a1[1] + 24), &v48, (uint64_t)a1[2]);
    uint64_t v42 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v49);
    LOBYTE(v2) = v42;
    unint64_t DefiningOp = v42 & 0xFFFFFFFFFFFFFF00;
  }
  return DefiningOp & 0xFFFFFFFFFFFFFF00 | v2;
}

mlir::GenericProgramPoint *mlir::RewriterBase::replaceOpWithNewOp<mlir::mps::DequantizeOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,mlir::TypeAttr,decltype(nullptr)>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  uint64_t v9 = mlir::OpBuilder::create<mlir::mps::DequantizeOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,mlir::TypeAttr,decltype(nullptr)>(a1 + 1, *(void *)(a2 + 24), a3, a4, a5, a6, a7);
  (*((void (**)(mlir::UnknownLoc **, uint64_t, mlir::GenericProgramPoint *))*a1 + 4))(a1, a2, v9);
  return v9;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::DequantizeOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,mlir::TypeAttr,decltype(nullptr)>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  v25[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dequantize", (const unsigned __int8 *)0xE, Context);
  if (!v16)
  {
    __int16 v24 = 1283;
    void v23[2] = (uint64_t)"mps.dequantize";
    v23[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a2, v15);
  mlir::mps::DequantizeOp::build(a1, (uint64_t)v25, *a3, *a4, *a5, *a6, *a7, 0);
  uint64_t v17 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v25);
  if (*(_UNKNOWN **)(*((void *)v17 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id) {
    unint64_t v18 = v17;
  }
  else {
    unint64_t v18 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
  return v18;
}

void mlir::mps::anonymous namespace'::LowerQuantizedMatmul::~LowerQuantizedMatmul(mlir::mps::_anonymous_namespace_::LowerQuantizedMatmul *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mpsx::QuantizedMatMulOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mpsx::QuantizedMatMulOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mpsx::detail::QuantizedMatMulOpGenericAdaptorBase::QuantizedMatMulOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mpsx::QuantizedMatMulOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mpsx::detail::QuantizedMatMulOpGenericAdaptorBase::QuantizedMatMulOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::mps::anonymous namespace'::LowerQuantizedMatmul::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::MLIRContext **a4)
{
  uint64_t v62 = a2;
  uint64_t InputScale = mlir::mpsx::QuantizedMatMulOp::getInputScale(&v62);
  unint64_t v61 = (char *)InputScale;
  uint64_t InputZeroPoint = mlir::mpsx::QuantizedMatMulOp::getInputZeroPoint(&v62);
  uint64_t v60 = (char *)InputZeroPoint;
  InputMiuint64_t n = mlir::mpsx::QuantizedMatMulOp::getInputMin(&v62);
  uint64_t v59 = (char *)InputMin;
  uint64_t InputQuantParamsAxisAttr = mlir::mpsx::QuantizedMatMulOp::getInputQuantParamsAxisAttr(&v62);
  if (mlir::mpsx::QuantizedMatMulOp::isInputAffneQuantized(&v62)
    && mlir::mpsx::QuantizedMatMulOp::getInputQuantParamsAxisAttr(&v62))
  {
    unint64_t v8 = (void *)(*(void *)(mlir::mpsx::QuantizedMatMulOp::getInput(&v62) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v8) {
      goto LABEL_12;
    }
    uint64_t v9 = *v8;
    unint64_t v10 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v11 = *(unsigned int *)(v9 + 16);
    if (!v11) {
      goto LABEL_12;
    }
    unint64_t v12 = *(void **)(v9 + 8);
    unint64_t v13 = &v12[2 * v11];
    do
    {
      unint64_t v14 = v11 >> 1;
      uint64_t v15 = &v12[2 * (v11 >> 1)];
      unint64_t v17 = *v15;
      char v16 = v15 + 2;
      v11 += ~(v11 >> 1);
      if (v17 < v10) {
        unint64_t v12 = v16;
      }
      else {
        unint64_t v11 = v14;
      }
    }
    while (v11);
    if (v12 != v13 && *v12 == v10) {
      uint64_t v18 = v12[1];
    }
    else {
LABEL_12:
    }
      uint64_t v18 = 0;
    uint64_t Input = v8;
    uint64_t v57 = v18;
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&Input))
    {
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&Input);
      unint64_t v20 = v19;
      mlir::IntegerAttr::getValue(&InputQuantParamsAxisAttr, (llvm::APInt *)&__p);
      if (v55 > 0x40)
      {
        uint64_t v21 = *(void *)__p;
        operator delete[](__p);
      }
      else
      {
        uint64_t v21 = (uint64_t)((void)__p << -(uint64_t)v55) >> -(uint64_t)v55;
      }
      uint64_t InputQuantParamsAxisAttr = 0;
    }
  }
  uint64_t WeightsScale = mlir::mpsx::QuantizedMatMulOp::getWeightsScale(&v62);
  uint64_t v53 = (char *)WeightsScale;
  uint64_t WeightsZeroPoint = mlir::mpsx::QuantizedMatMulOp::getWeightsZeroPoint(&v62);
  unint64_t v52 = (char *)WeightsZeroPoint;
  WeightsMiuint64_t n = mlir::mpsx::QuantizedMatMulOp::getWeightsMin(&v62);
  unint64_t v51 = (char *)WeightsMin;
  uint64_t BiquantWeightsScale = mlir::mpsx::QuantizedMatMulOp::getBiquantWeightsScale(&v62);
  char v50 = (char *)BiquantWeightsScale;
  uint64_t BiquantWeightsZeroPoint = mlir::mpsx::QuantizedMatMulOp::getBiquantWeightsZeroPoint(&v62);
  long long v49 = (char *)BiquantWeightsZeroPoint;
  uint64_t WeightsQuantParamsAxisAttr = mlir::mpsx::QuantizedMatMulOp::getWeightsQuantParamsAxisAttr(&v62);
  if ((mlir::mpsx::QuantizedMatMulOp::isWeightsAffineQuantized(&v62)
     || mlir::mpsx::QuantizedMatMulOp::isWeightsDoubleAffineQuantized(&v62))
    && mlir::mpsx::QuantizedMatMulOp::getWeightsQuantParamsAxisAttr(&v62))
  {
    unint64_t v27 = (void *)(*(void *)(mlir::mpsx::QuantizedMatMulOp::getWeights(&v62) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v27) {
      goto LABEL_30;
    }
    uint64_t v28 = *v27;
    unint64_t v29 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v30 = *(unsigned int *)(v28 + 16);
    if (!v30) {
      goto LABEL_30;
    }
    uint64_t v31 = *(void **)(v28 + 8);
    unint64_t v32 = &v31[2 * v30];
    do
    {
      unint64_t v33 = v30 >> 1;
      uint64_t v34 = &v31[2 * (v30 >> 1)];
      unint64_t v36 = *v34;
      uint64_t v35 = v34 + 2;
      v30 += ~(v30 >> 1);
      if (v36 < v29) {
        uint64_t v31 = v35;
      }
      else {
        unint64_t v30 = v33;
      }
    }
    while (v30);
    if (v31 != v32 && *v31 == v29) {
      uint64_t v37 = v31[1];
    }
    else {
LABEL_30:
    }
      uint64_t v37 = 0;
    uint64_t Input = v27;
    uint64_t v57 = v37;
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&Input))
    {
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&Input);
      unint64_t v39 = v38;
      mlir::IntegerAttr::getValue(&WeightsQuantParamsAxisAttr, (llvm::APInt *)&__p);
      if (v55 > 0x40)
      {
        uint64_t v40 = *(void *)__p;
        operator delete[](__p);
      }
      else
      {
        uint64_t v40 = (uint64_t)((void)__p << -(uint64_t)v55) >> -(uint64_t)v55;
      }
      uint64_t WeightsQuantParamsAxisAttr = 0;
      if (mlir::mpsx::QuantizedMatMulOp::isWeightsDoubleAffineQuantized(&v62))
      {
      }
    }
  }
  uint64_t v41 = v62;
  uint64_t Input = (void *)mlir::mpsx::QuantizedMatMulOp::getInput(&v62);
  __p = (void *)mlir::mpsx::QuantizedMatMulOp::getWeights(&v62);
  uint64_t WeightsPaletteLut = mlir::mpsx::QuantizedMatMulOp::getWeightsPaletteLut(&v62);
  uint64_t OutputType = mlir::mpsx::QuantizedMatMulOp::getOutputType(&v62);
  BOOL TransposeLhs = mlir::mpsx::QuantizedMatMulOp::getTransposeLhs(&v62);
  BOOL TransposeRhs = mlir::mpsx::QuantizedMatMulOp::getTransposeRhs(&v62);
  uint64_t v42 = mlir::OpBuilder::create<mlir::mpsx::QuantizedMatMulOp,mlir::Value,mlir::Value&,mlir::Value&,mlir::Value&,mlir::IntegerAttr &,mlir::Value&,mlir::Value&,mlir::Value&,mlir::Value&,mlir::IntegerAttr &,mlir::Value,mlir::detail::TypedValue<mlir::RankedTensorType>,mlir::detail::TypedValue<mlir::RankedTensorType>,mlir::Type,BOOL,BOOL>(a4 + 1, *((void *)v41 + 3), (uint64_t *)&Input, (uint64_t *)&v61, (uint64_t *)&v60, (uint64_t *)&v59, &InputQuantParamsAxisAttr, (uint64_t *)&__p, (uint64_t *)&v53, (uint64_t *)&v52, (uint64_t *)&v51, &WeightsQuantParamsAxisAttr, &WeightsPaletteLut, (uint64_t *)&v50, (uint64_t *)&v49, &OutputType, (unsigned __int8 *)&TransposeLhs, (unsigned __int8 *)&TransposeRhs);
  (*((void (**)(mlir::MLIRContext **, mlir::Operation *, mlir::GenericProgramPoint *))*a4 + 4))(a4, v41, v42);
  return 1;
}

char *mlir::mps::anonymous namespace'::LowerQuantizedMatmul::convertParamToND(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v6 = (char *)a2;
  v87[4] = *MEMORY[0x1E4F143B8];
  uint64_t v81 = a2;
  unint64_t v8 = (uint64_t *)(*(void *)(a2 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *v8;
  unint64_t v10 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v11 = *(unsigned int *)(v9 + 16);
  if (!v11) {
    goto LABEL_10;
  }
  unint64_t v12 = *(void **)(v9 + 8);
  unint64_t v13 = &v12[2 * v11];
  do
  {
    unint64_t v14 = v11 >> 1;
    uint64_t v15 = &v12[2 * (v11 >> 1)];
    unint64_t v17 = *v15;
    char v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10) {
      unint64_t v12 = v16;
    }
    else {
      unint64_t v11 = v14;
    }
  }
  while (v11);
  if (v12 != v13 && *v12 == v10) {
    uint64_t v18 = v12[1];
  }
  else {
LABEL_10:
  }
    uint64_t v18 = 0;
  __b = v8;
  uint64_t v86 = v18;
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&__b))
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__b);
    if (a3 != 1 && v19 == 1)
    {
      unint64_t v20 = (a3 & (a4 >> 63)) + a4;
      __b = v87;
      HIDWORD(v86) = 4;
      if (a3 < 5)
      {
        if (a3) {
          memset_pattern16(v87, &unk_1810FE350, 8 * a3);
        }
        uint64_t v21 = v87;
      }
      else
      {
        LODWORD(v86) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__b, v87, a3, 8);
        uint64_t v21 = __b;
        memset_pattern16(__b, &unk_1810FE350, 8 * a3);
      }
      LODWORD(v86) = a3;
      v21[v20] = -1;
      int v79 = 0;
      uint64_t v80 = 0;
      v78[0] = (uint64_t *)&v79;
      *(void *)&long long v82 = v6;
      uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v82);
      if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)v78, DefiningOp))
      {
        uint64_t Type = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v79);
        __int16 v24 = Type;
        if (!Type) {
          goto LABEL_30;
        }
        uint64_t v25 = *Type;
        unint64_t v26 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v27 = *(unsigned int *)(v25 + 16);
        if (!v27) {
          goto LABEL_30;
        }
        uint64_t v28 = *(void **)(v25 + 8);
        unint64_t v29 = &v28[2 * v27];
        do
        {
          unint64_t v30 = v27 >> 1;
          uint64_t v31 = &v28[2 * (v27 >> 1)];
          unint64_t v33 = *v31;
          unint64_t v32 = v31 + 2;
          v27 += ~(v27 >> 1);
          if (v33 < v26) {
            uint64_t v28 = v32;
          }
          else {
            unint64_t v27 = v30;
          }
        }
        while (v27);
        if (v28 != v29 && *v28 == v26) {
          uint64_t v34 = (uint64_t *)v28[1];
        }
        else {
LABEL_30:
        }
          uint64_t v34 = 0;
        v78[0] = v24;
        v78[1] = v34;
        uint64_t ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v78);
        uint64_t NumElements = mlir::ShapedType::getNumElements(ArgAttrsAttr, v36);
        unint64_t v38 = __b;
        *((void *)__b + v20) = NumElements;
        unint64_t v39 = v79;
        uint64_t v40 = v80;
        *(void *)&long long v82 = v38;
        *((void *)&v82 + 1) = v86;
        char v83 = 1;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v78);
        uint64_t v42 = mlir::ShapedType::cloneWith((uint64_t *)v78, &v82, OperandRange);
        int v79 = mlir::reshapeElementsAttr((uint64_t)v39, v40, v42, v43);
        uint64_t v80 = v44;
        unint64_t v45 = (mlir::OpBuilder *)(a1 + 8);
        uint64_t Loc = mlir::Value::getLoc((mlir::Value *)&v81);
        int v47 = (uint64_t *)(*(void *)(v81 + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!v47) {
          goto LABEL_40;
        }
        uint64_t v48 = *v47;
        unint64_t v49 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v50 = *(unsigned int *)(v48 + 16);
        if (!v50) {
          goto LABEL_40;
        }
        unint64_t v51 = *(void **)(v48 + 8);
        unint64_t v52 = &v51[2 * v50];
        do
        {
          unint64_t v53 = v50 >> 1;
          uint64_t v54 = &v51[2 * (v50 >> 1)];
          unint64_t v56 = *v54;
          unsigned int v55 = v54 + 2;
          v50 += ~(v50 >> 1);
          if (v56 < v49) {
            unint64_t v51 = v55;
          }
          else {
            unint64_t v50 = v53;
          }
        }
        while (v50);
        if (v51 != v52 && *v51 == v49) {
          uint64_t v57 = v51[1];
        }
        else {
LABEL_40:
        }
          uint64_t v57 = 0;
        v84[0] = (uint64_t)v47;
        v84[1] = v57;
        *(void *)&long long v82 = __b;
        *((void *)&v82 + 1) = v86;
        char v83 = 1;
        uint64_t v58 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v84);
        *(void *)&long long v82 = mlir::ShapedType::cloneWith(v84, &v82, v58);
        *((void *)&v82 + 1) = v59;
        uint64_t v60 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>(v45, Loc, (uint64_t *)&v82, &v79);
      }
      else
      {
        unint64_t v61 = (mlir::Builder *)(a1 + 8);
        uint64_t v62 = mlir::Value::getLoc((mlir::Value *)&v81);
        v84[0] = a3;
        uint64_t IntegerType = mlir::Builder::getIntegerType(v61, 0x40u, 1);
        int v64 = (void *)mlir::RankedTensorType::get((uint64_t)v84, 1, IntegerType, 0);
        uint64_t v65 = v64;
        if (!v64) {
          goto LABEL_51;
        }
        uint64_t v66 = *v64;
        unint64_t v67 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v68 = *(unsigned int *)(v66 + 16);
        if (!v68) {
          goto LABEL_51;
        }
        unint64_t v69 = *(void **)(v66 + 8);
        int v70 = &v69[2 * v68];
        do
        {
          unint64_t v71 = v68 >> 1;
          uint64_t v72 = &v69[2 * (v68 >> 1)];
          unint64_t v74 = *v72;
          unint64_t v73 = v72 + 2;
          v68 += ~(v68 >> 1);
          if (v74 < v67) {
            unint64_t v69 = v73;
          }
          else {
            unint64_t v68 = v71;
          }
        }
        while (v68);
        if (v69 != v70 && *v69 == v67) {
          uint64_t v75 = v69[1];
        }
        else {
LABEL_51:
        }
          uint64_t v75 = 0;
        v78[0] = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v65, v75, __b, 8 * v86, 8, 1, 1);
        *(void *)&long long v82 = (char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v61, v62, v78)- 16;
        uint64_t v76 = mlir::Value::getLoc((mlir::Value *)&v81);
        uint64_t v60 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,mlir::Value&>((mlir::UnitAttr **)v61, v76, &v81, (uint64_t *)&v82);
      }
      unint64_t v6 = (char *)v60 - 16;
      if (__b != v87) {
        free(__b);
      }
    }
  }
  return v6;
}

void mlir::mps::anonymous namespace'::MPS_LowerBiasAddNHWC::~MPS_LowerBiasAddNHWC(mlir::mps::_anonymous_namespace_::MPS_LowerBiasAddNHWC *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::mps::anonymous namespace'::MPS_LowerBiasAddNHWC::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerBiasAddNHWC *this, mlir::Operation *a2, mlir::MLIRContext **a3)
{
  uint64_t v16[4] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = 0;
  unint64_t v14 = v16;
  v16[0] = a2;
  uint64_t v15 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::BiasAddOp,void>::id) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = 0;
  }
  unint64_t v11 = v5;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v11, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v11, 1u);
  if (*((unsigned char *)a2 + 47))
  {
    uint64_t InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"data_format", 11);
    if (v7)
    {
      if (!InherentAttr) {
        goto LABEL_10;
      }
LABEL_9:
      if (*(_UNKNOWN **)(*(void *)InherentAttr + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
  }
  uint64_t InherentAttr = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "data_format", 0xBuLL);
  if (InherentAttr) {
    goto LABEL_9;
  }
LABEL_10:
  uint64_t InherentAttr = mlir::mps::TensorDataLayoutAttr::get(a3[1], 1u);
LABEL_11:
  uint64_t v12 = InherentAttr;
  if (mlir::AffineExpr::getKind((mlir::AffineExpr *)&v12) == 1)
  {
    unint64_t v13 = *(void **)(*v14 + 24);
    mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v13, (mlir::MLIRContext *)1, 0);
  }
  uint64_t v8 = (uint64_t)a3[2];
  if (v8 && mlir::RewriterBase::Listener::classof(v8)) {
  else
  }
    uint64_t v9 = 0;
  if (v14 != v16) {
    free(v14);
  }
  return v9;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::AddOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    void v19[2] = (uint64_t)"mps.add";
    void v19[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(void *)a4, *(unsigned int *)(a4 + 8));
  mlir::arith::CmpIOp::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  unint64_t v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id) {
    unint64_t v14 = v13;
  }
  else {
    unint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::anonymous namespace'::MPS_LowerBiasAddNHWC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'data_format' failed to satisfy constraint: 'is NHWC'");
}

void mlir::mps::anonymous namespace'::MPS_LowerDegamma::~MPS_LowerDegamma(mlir::mps::_anonymous_namespace_::MPS_LowerDegamma *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

void mlir::mps::anonymous namespace'::MPS_LowerDegamma::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerDegamma *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  v9[4] = *MEMORY[0x1E4F143B8];
  char v7 = v9;
  v9[0] = a2;
  uint64_t v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DegammaOp,void>::id) {
    uint64_t v4 = a2;
  }
  else {
    uint64_t v4 = 0;
  }
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  unint64_t v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::PowerOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.power", (const unsigned __int8 *)9, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    void v19[2] = (uint64_t)"mps.power";
    void v19[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(void *)a4, *(unsigned int *)(a4 + 8));
  mlir::arith::CmpIOp::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  unint64_t v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::PowerOp,void>::id) {
    unint64_t v14 = v13;
  }
  else {
    unint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

uint64_t mlir::mps::getConstantAttr<double>(uint64_t *a1, double a2)
{
  double v31 = a2;
  uint64_t v32 = 0;
  if (!a1) {
    goto LABEL_10;
  }
  uint64_t v3 = *a1;
  unint64_t v4 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v5 = *(unsigned int *)(v3 + 16);
  if (!v5) {
    goto LABEL_10;
  }
  unint64_t v6 = *(void **)(v3 + 8);
  char v7 = &v6[2 * v5];
  do
  {
    unint64_t v8 = v5 >> 1;
    uint64_t v9 = &v6[2 * (v5 >> 1)];
    unint64_t v11 = *v9;
    unint64_t v10 = v9 + 2;
    v5 += ~(v5 >> 1);
    if (v11 < v4) {
      unint64_t v6 = v10;
    }
    else {
      unint64_t v5 = v8;
    }
  }
  while (v5);
  if (v6 != v7 && *v6 == v4) {
    uint64_t v12 = v6[1];
  }
  else {
LABEL_10:
  }
    uint64_t v12 = 0;
  v30[0] = a1;
  v30[1] = v12;
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(a1);
  v29[0] = &v32;
  v29[1] = v30;
  void v29[2] = &v31;
  unint64_t v14 = *(void **)(*(void *)ElementTypeOrSelf + 136);
  if (v14 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
  {
    mlir::mps::getConstantAttr<double>(mlir::Type,double)::{lambda(mlir::Type)#1}::operator()((uint64_t)v29, ElementTypeOrSelf);
  }
  else
  {
    v28[0] = &v32;
    v28[1] = v30;
    v28[2] = &v31;
    if (v14 == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
    {
      mlir::mps::getConstantAttr<double>(mlir::Type,double)::{lambda(mlir::Type)#2}::operator()((uint64_t)v28, ElementTypeOrSelf);
    }
    else
    {
      v27[0] = &v32;
      v27[1] = v30;
      _DWORD v27[2] = &v31;
      if (v14 == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id) {
        mlir::mps::getConstantAttr<double>(mlir::Type,double)::{lambda(mlir::ComplexType)#1}::operator()((uint64_t)v27, ElementTypeOrSelf);
      }
    }
  }
  return v32;
}

void mlir::mps::getConstantAttr<double>(mlir::Type,double)::{lambda(mlir::Type)#1}::operator()(uint64_t a1, uint64_t a2)
{
  v25[3] = *MEMORY[0x1E4F143B8];
  uint64_t v23 = a2;
  BOOL isF16 = mlir::Type::isF16((mlir::Type *)&v23);
  if (isF16)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    unint64_t v5 = *(llvm::APFloatBase **)v4;
    uint64_t v6 = *(void *)(v4 + 8);
    char v7 = llvm::APFloatBase::IEEEhalf((llvm::APFloatBase *)isF16);
  }
  else
  {
    BOOL isBF16 = mlir::Type::isBF16((mlir::Type *)&v23);
    if (!isBF16)
    {
      if (mlir::Type::isF32((mlir::Type *)&v23))
      {
        uint64_t v15 = *(uint64_t **)(a1 + 8);
        float v16 = **(double **)(a1 + 16);
        *(float *)&uint64_t v24 = v16;
        uint64_t v17 = *v15;
        uint64_t v18 = v15[1];
        uint64_t v19 = 4;
        uint64_t v20 = 4;
      }
      else
      {
        mlir::Type::isF64((mlir::Type *)&v23);
        uint64_t v21 = *(uint64_t **)(a1 + 8);
        uint64_t v24 = **(void **)(a1 + 16);
        uint64_t v17 = *v21;
        uint64_t v18 = v21[1];
        uint64_t v19 = 8;
        uint64_t v20 = 8;
      }
      **(void **)a1 = mlir::DenseElementsAttr::getFromRawBuffer(v17, v18, &v24, v19, v20, 0, 1);
      return;
    }
    uint64_t v9 = *(void *)(a1 + 8);
    unint64_t v5 = *(llvm::APFloatBase **)v9;
    uint64_t v6 = *(void *)(v9 + 8);
    char v7 = llvm::APFloatBase::BFloat((llvm::APFloatBase *)isBF16);
  }
  unint64_t v10 = v7;
  std::to_string(&v22, **(double **)(a1 + 16));
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v11 = &v22;
  }
  else {
    unint64_t v11 = (std::string *)v22.__r_.__value_.__r.__words[0];
  }
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v22.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v22.__r_.__value_.__l.__size_;
  }
  llvm::APFloat::APFloat((llvm::APFloatBase *)&v24, v10, (unsigned __int8 *)v11, size);
  unint64_t v13 = (llvm::APFloatBase *)mlir::DenseElementsAttr::get(v5, v6, (uint64_t)&v24, 1);
  **(void **)a1 = v13;
  unint64_t v14 = (void *)v25[0];
  if (llvm::APFloatBase::PPCDoubleDouble(v13) == v14)
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v25);
    if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
  }
  else
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v25);
    if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
  }
  operator delete(v22.__r_.__value_.__l.__data_);
}

void mlir::mps::getConstantAttr<double>(mlir::Type,double)::{lambda(mlir::Type)#2}::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = a2;
  BOOL isInteger = mlir::Type::isInteger((mlir::Type *)&v11, 1);
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  if (isInteger)
  {
    LOBYTE(__p) = **(double **)(a1 + 16) != 0.0;
    **(void **)a1 = mlir::DenseElementsAttr::get(*v4, v4[1], &__p, 1);
  }
  else
  {
    unsigned int IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&v11);
    uint64_t v6 = (unint64_t)**(double **)(a1 + 16);
    BOOL isSignedInteger = mlir::Type::isSignedInteger((mlir::Type *)&v11);
    unsigned int v10 = IntOrFloatBitWidth;
    if (IntOrFloatBitWidth > 0x40)
    {
      llvm::APInt::initSlowCase((llvm::APInt *)&__p, v6, isSignedInteger);
    }
    else
    {
      unint64_t v8 = 0xFFFFFFFFFFFFFFFFLL >> -(char)IntOrFloatBitWidth;
      if (!IntOrFloatBitWidth) {
        unint64_t v8 = 0;
      }
      __p = (void *)(v8 & v6);
    }
    **(void **)a1 = mlir::DenseElementsAttr::get(*v4, v4[1], (llvm::APInt *)&__p, 1);
    if (v10 >= 0x41)
    {
      if (__p) {
        operator delete[](__p);
      }
    }
  }
}

void mlir::mps::getConstantAttr<double>(mlir::Type,double)::{lambda(mlir::ComplexType)#1}::operator()(uint64_t a1, uint64_t a2)
{
  v32[3] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = a2;
  uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v25);
  if (mlir::Type::isF32((mlir::Type *)&Value))
  {
    uint64_t v3 = *(void **)(a1 + 8);
    float v4 = **(double **)(a1 + 16);
    *(float *)uint64_t v28 = v4;
    v28[1] = 0;
    **(void **)a1 = mlir::DenseElementsAttr::getFromRawBuffer(*v3, v3[1], v28, 8, 8, 0, 1);
    return;
  }
  BOOL isF16 = mlir::Type::isF16((mlir::Type *)&Value);
  uint64_t v6 = *(void *)(a1 + 8);
  _S0 = **(double **)(a1 + 16);
  __asm { FCVT            H8, S0 }
  unint64_t v13 = llvm::APFloatBase::IEEEhalf((llvm::APFloatBase *)isF16);
  __asm { FCVT            S0, H8; __val }
  std::to_string(&v23, _S0);
  if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v15 = &v23;
  }
  else {
    uint64_t v15 = (std::string *)v23.__r_.__value_.__r.__words[0];
  }
  if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v23.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v23.__r_.__value_.__l.__size_;
  }
  llvm::APFloat::APFloat((llvm::APFloatBase *)v28, v13, (unsigned __int8 *)v15, size);
  std::to_string(&v22, 0.0);
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v17 = &v22;
  }
  else {
    uint64_t v17 = (std::string *)v22.__r_.__value_.__r.__words[0];
  }
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v18 = HIBYTE(v22.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v18 = v22.__r_.__value_.__l.__size_;
  }
  uint64_t v19 = llvm::APFloat::APFloat((llvm::APFloatBase *)v26, v13, (unsigned __int8 *)v17, v18);
  uint64_t v20 = (void *)v29[0];
  uint64_t v21 = llvm::APFloatBase::PPCDoubleDouble(v19);
  if (v21 == v20) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v31, (const llvm::detail::DoubleAPFloat *)v29);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v31, (const llvm::detail::IEEEFloat *)v29);
  }
  if (v21 == (void *)v27[0]) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v32, (const llvm::detail::DoubleAPFloat *)v27);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v32, (const llvm::detail::IEEEFloat *)v27);
  }
  **(void **)a1 = mlir::DenseElementsAttr::get(*(llvm::APFloatBase **)v6, *(void *)(v6 + 8), (uint64_t)v30, 1);
  if (v21 == (void *)v32[0]) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v32);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v32);
  }
  if (v21 == (void *)v31[0]) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v31);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v31);
  }
  if (v21 != (void *)v27[0])
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v27);
    if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_30;
    }
    goto LABEL_29;
  }
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v27);
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
LABEL_29:
  }
    operator delete(v22.__r_.__value_.__l.__data_);
LABEL_30:
  if (v21 != (void *)v29[0])
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v29);
    if ((SHIBYTE(v23.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_32;
  }
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v29);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
LABEL_32:
  }
    operator delete(v23.__r_.__value_.__l.__data_);
}

void mlir::mps::anonymous namespace'::MPS_LowerDirac::~MPS_LowerDirac(mlir::mps::_anonymous_namespace_::MPS_LowerDirac *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

void mlir::mps::anonymous namespace'::MPS_LowerDirac::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerDirac *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  v9[4] = *MEMORY[0x1E4F143B8];
  char v7 = v9;
  v9[0] = a2;
  uint64_t v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DiracOp,void>::id) {
    float v4 = a2;
  }
  else {
    float v4 = 0;
  }
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  uint64_t v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::EqualToOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.equal", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.equal";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::EqualToOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::EqualToOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SelectOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.select", (const unsigned __int8 *)0xA, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    void v19[2] = (uint64_t)"mps.select";
    void v19[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(void *)a4, *(unsigned int *)(a4 + 8));
  mlir::arith::CmpIOp::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  unint64_t v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SelectOp,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

void mlir::mps::anonymous namespace'::MPS_LowerElu::~MPS_LowerElu(mlir::mps::_anonymous_namespace_::MPS_LowerElu *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

void mlir::mps::anonymous namespace'::MPS_LowerElu::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerElu *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  v9[4] = *MEMORY[0x1E4F143B8];
  char v7 = v9;
  v9[0] = a2;
  uint64_t v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::EluOp,void>::id) {
    float v4 = a2;
  }
  else {
    float v4 = 0;
  }
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 1u);
  uint64_t v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::GreaterThanOrEqualToOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.greater_equal", (const unsigned __int8 *)0x11, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.greater_equal";
    v17[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::EqualToOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::GreaterThanOrEqualToOp,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ExponentOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v20[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.exponent", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.exponent";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ExponentOp,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

void mlir::mps::anonymous namespace'::MPS_LowerFloorDiv::~MPS_LowerFloorDiv(mlir::mps::_anonymous_namespace_::MPS_LowerFloorDiv *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

void mlir::mps::anonymous namespace'::MPS_LowerFloorDiv::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerFloorDiv *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  v9[4] = *MEMORY[0x1E4F143B8];
  char v7 = v9;
  v9[0] = a2;
  uint64_t v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::FloorDivideOp,void>::id) {
    float v4 = a2;
  }
  else {
    float v4 = 0;
  }
  unint64_t v5 = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v5, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v5, 1u);
  uint64_t v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::DivideOp,mlir::Value &,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.divide", (const unsigned __int8 *)0xA, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.divide";
    v17[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DivideOp,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::FloorOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v20[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.floor", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.floor";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::FloorOp,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

void mlir::mps::anonymous namespace'::MPS_LowerGelu::~MPS_LowerGelu(mlir::mps::_anonymous_namespace_::MPS_LowerGelu *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

void mlir::mps::anonymous namespace'::MPS_LowerGelu::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerGelu *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  v9[4] = *MEMORY[0x1E4F143B8];
  char v7 = v9;
  v9[0] = a2;
  uint64_t v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::GeluOp,void>::id) {
    float v4 = a2;
  }
  else {
    float v4 = 0;
  }
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  uint64_t v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SquareRootOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v20[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.square_root", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.square_root";
    v17[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SquareRootOp,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ErfOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v20[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.erf", (const unsigned __int8 *)7, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.erf";
    v17[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ErfOp,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::MultiplyOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"mps.multiply";
    void v19[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(void *)a4, *(unsigned int *)(a4 + 8));
  mlir::arith::CmpIOp::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  unint64_t v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

void mlir::mps::anonymous namespace'::MPS_LowerInstanceNorm::~MPS_LowerInstanceNorm(mlir::mps::_anonymous_namespace_::MPS_LowerInstanceNorm *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

void mlir::mps::anonymous namespace'::MPS_LowerInstanceNorm::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerInstanceNorm *this, mlir::Operation *a2, mlir::Float32Type **a3)
{
  v13[4] = *MEMORY[0x1E4F143B8];
  uint64_t v11 = v13;
  v13[0] = a2;
  uint64_t v12 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::InstanceNormOp,void>::id) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = 0;
  }
  v9[0] = v5;
  v9[1] = v5;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v9, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v9, 1u);
  if (!*((unsigned char *)a2 + 47)
    || (uint64_t InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"epsilon", 7), !(_BYTE)v7))
  {
    uint64_t InherentAttr = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "epsilon", 7uLL);
  }
  if (!InherentAttr
    || *(_UNKNOWN **)(*(void *)InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    F32uint64_t Type = mlir::Builder::getF32Type(a3 + 1, v7);
    mlir::Builder::getFloatAttr(0.0, (uint64_t)(a3 + 1), F32Type);
  }
  char v10 = *(void **)(*v11 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v10, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReductionMeanOp,mlir::Value &,mlir::Value &,mlir::UnitAttr>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_mean", (const unsigned __int8 *)0x12, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"mps.reduction_mean";
    void v19[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::ReductionMeanOp::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  unint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionMeanOp,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReductionVarianceOp,mlir::Value &,mlir::Value &,mlir::UnitAttr>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_variance", (const unsigned __int8 *)0x16, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"mps.reduction_variance";
    void v19[3] = 22;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::ReductionVarianceOp::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  unint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionVarianceOp,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::NormalizationOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.normalization", (const unsigned __int8 *)0x11, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"mps.normalization";
    void v19[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(void *)a4, *(unsigned int *)(a4 + 8));
  mlir::arith::CmpIOp::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  unint64_t v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::NormalizationOp,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

void mlir::mps::anonymous namespace'::MPS_LowerLPNorm::~MPS_LowerLPNorm(mlir::mps::_anonymous_namespace_::MPS_LowerLPNorm *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

void mlir::mps::anonymous namespace'::MPS_LowerLPNorm::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerLPNorm *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  v9[4] = *MEMORY[0x1E4F143B8];
  char v7 = v9;
  v9[0] = a2;
  uint64_t v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::LPNormOp,void>::id) {
    float v4 = a2;
  }
  else {
    float v4 = 0;
  }
  unint64_t v5 = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v5, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v5, 1u);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v5, 2u);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v5, 3u);
  uint64_t v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::AbsoluteOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v20[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.absolute", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.absolute";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::AbsoluteOp,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::PowerOp,mlir::Value &,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.power", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.power";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::PowerOp,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::Value &,mlir::Value &,mlir::UnitAttr>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_sum", (const unsigned __int8 *)0x11, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"mps.reduction_sum";
    void v19[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::ReductionSumOp::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  unint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionSumOp,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReciprocalOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v20[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reciprocal", (const unsigned __int8 *)0xE, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.reciprocal";
    v17[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReciprocalOp,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::DivideOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.divide", (const unsigned __int8 *)0xA, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"mps.divide";
    void v19[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(void *)a4, *(unsigned int *)(a4 + 8));
  mlir::arith::CmpIOp::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  unint64_t v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DivideOp,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

void mlir::mps::anonymous namespace'::MPS_LowerLeakyRelu::~MPS_LowerLeakyRelu(mlir::mps::_anonymous_namespace_::MPS_LowerLeakyRelu *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

void mlir::mps::anonymous namespace'::MPS_LowerLeakyRelu::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerLeakyRelu *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  v9[4] = *MEMORY[0x1E4F143B8];
  char v7 = v9;
  v9[0] = a2;
  uint64_t v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::LeakyReluOp,void>::id) {
    float v4 = a2;
  }
  else {
    float v4 = 0;
  }
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 1u);
  uint64_t v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

void mlir::mps::anonymous namespace'::MPS_LowerNRelu::~MPS_LowerNRelu(mlir::mps::_anonymous_namespace_::MPS_LowerNRelu *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

void mlir::mps::anonymous namespace'::MPS_LowerNRelu::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerNRelu *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  v9[4] = *MEMORY[0x1E4F143B8];
  char v7 = v9;
  v9[0] = a2;
  uint64_t v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::NReluOp,void>::id) {
    float v4 = a2;
  }
  else {
    float v4 = 0;
  }
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 1u);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 2u);
  uint64_t v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::MinimumOp,mlir::Value &,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.minimum", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.minimum";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MinimumOp,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::mps::anonymous namespace'::MPS_LowerNormalization::~MPS_LowerNormalization(mlir::mps::_anonymous_namespace_::MPS_LowerNormalization *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::mps::anonymous namespace'::MPS_LowerNormalization::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerNormalization *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  uint64_t v16[4] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = 0;
  uint64_t v14 = v16;
  v16[0] = a2;
  uint64_t v15 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::NormalizationOp,void>::id) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = 0;
  }
  uint64_t v11 = v5;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v11, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v11, 1u);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v11, 2u);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v11, 3u);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v11, 4u);
  if (*((unsigned char *)a2 + 47)
    && (uint64_t InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"epsilon", 7), v7))
  {
    if (!InherentAttr) {
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t InherentAttr = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "epsilon", 7uLL);
    if (!InherentAttr) {
      goto LABEL_10;
    }
  }
  if (*(_UNKNOWN **)(*(void *)InherentAttr + 136) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    uint64_t v12 = InherentAttr;
    unint64_t v13 = *(void **)(*v14 + 24);
    mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v13, (mlir::MLIRContext *)1, 0);
  }
LABEL_10:
  uint64_t v8 = (uint64_t)a3[2];
  if (v8 && mlir::RewriterBase::Listener::classof(v8)) {
  else
  }
    uint64_t v9 = 0;
  if (v14 != v16) {
    free(v14);
  }
  return v9;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReciprocalSquareRootOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v20[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reciprocal_square_root", (const unsigned __int8 *)0x1A, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.reciprocal_square_root";
    v17[3] = 26;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReciprocalSquareRootOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::anonymous namespace'::MPS_LowerNormalization::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'mps.normalization' to have attribute 'epsilon' of type '::mlir::FloatAttr'");
}

void mlir::mps::anonymous namespace'::MPS_LowerPRelu::~MPS_LowerPRelu(mlir::mps::_anonymous_namespace_::MPS_LowerPRelu *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

void mlir::mps::anonymous namespace'::MPS_LowerPRelu::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerPRelu *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  v9[4] = *MEMORY[0x1E4F143B8];
  char v7 = v9;
  v9[0] = a2;
  uint64_t v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::PReluOp,void>::id) {
    float v4 = a2;
  }
  else {
    float v4 = 0;
  }
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 1u);
  *(void *)&long long v6 = *(void *)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::Value &,BOOL &>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned __int8 *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reshape", (const unsigned __int8 *)0xB, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"mps.reshape";
    void v19[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::ReshapeOp::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  unint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void mlir::mps::anonymous namespace'::MPS_LowerQuantize::~MPS_LowerQuantize(mlir::mps::_anonymous_namespace_::MPS_LowerQuantize *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::mps::anonymous namespace'::MPS_LowerQuantize::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerQuantize *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  void v22[4] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = 0;
  if ((*((unsigned char *)a2 + 46) & 0x80) != 0)
  {
    uint64_t v5 = *((void *)a2 + 9);
    uint64_t v6 = *((unsigned int *)a2 + 17);
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
  }
  v17[0] = v5;
  v17[1] = v6;
  v16[0] = v5;
  v16[1] = v6;
  v14[1] = v6;
  uint64_t v15 = 0;
  uint64_t v13 = 0;
  v14[0] = v5;
  __int16 v20 = v22;
  v22[0] = a2;
  uint64_t v21 = 0x400000001;
  char v7 = (void *)(*(void *)(*(void *)(v16[0] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  uint64_t ODSResults = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v15, 0);
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(ODSResults, 0);
  if (!mlir::mpsx::FPToIntClampedOp::isSupportedForTypes(v7, (void *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8)))
  {
    uint64_t v19 = *(void **)(*v20 + 24);
    mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v19, (mlir::MLIRContext *)1, 0);
  }
  uint64_t v10 = (uint64_t)a3[2];
  if (v10 && mlir::RewriterBase::Listener::classof(v10)) {
  else
  }
LABEL_8:
    uint64_t v11 = 0;
  if (v20 != v22) {
    free(v20);
  }
  return v11;
}

uint64_t mlir::mps::anonymous namespace'::static_dag_matcher_0(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4, void *a5, uint64_t *a6, void *a7, uint64_t *a8)
{
  if (*(_UNKNOWN **)(*(void *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::QuantizeOp,void>::id) {
    uint64_t v10 = a2;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v29 = v10;
  if (v10)
  {
    *a6 = v10;
    *a5 = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v29, 0);
    a5[1] = v16;
    *a7 = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v29, 1u);
    a7[1] = v17;
    *a4 = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v29, 2u);
    a4[1] = v18;
    if (*(unsigned char *)(a2 + 47) && (uint64_t InherentAttr = mlir::Operation::getInherentAttr(a2, (uint64_t)"dtype", 5), v20))
    {
      if (!InherentAttr)
      {
LABEL_11:
        uint64_t v21 = *(void *)(a1 + 16);
        if (v21)
        {
          uint64_t result = mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16));
          if (result) {
          return result;
          }
        }
        return 0;
      }
    }
    else
    {
      uint64_t InherentAttr = mlir::DictionaryAttr::get(a2 + 56, "dtype", 5uLL);
      if (!InherentAttr) {
        goto LABEL_11;
      }
    }
    if (*(_UNKNOWN **)(*(void *)InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id) {
      goto LABEL_11;
    }
    *a8 = InherentAttr;
    if (!*(unsigned char *)(a2 + 47) || (uint64_t v24 = mlir::Operation::getInherentAttr(a2, (uint64_t)"axis", 4), !v25)) {
      uint64_t v24 = mlir::DictionaryAttr::get(a2 + 56, "axis", 4uLL);
    }
    if (v24)
    {
      if (*(_UNKNOWN **)(*(void *)v24 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
        uint64_t v26 = v24;
      }
      else {
        uint64_t v26 = 0;
      }
    }
    else
    {
      uint64_t v26 = 0;
    }
    *a3 = v26;
    return 1;
  }
  else
  {
    uint64_t v23 = *(void *)(a1 + 16);
    if (!v23) {
      return 0;
    }
    uint64_t result = mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16));
    if (result) {
  }
    }
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::RoundOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v20[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.round", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.round";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::RoundOp,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

char *mlir::mps::anonymous namespace'::getBoundDatatypeValue(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  v28[1] = *MEMORY[0x1E4F143B8];
  uint64_t v26 = a3;
  uint64_t v27 = a2;
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&v26, 8))
  {
    if (a4) {
      int v6 = 255;
    }
    else {
      int v6 = 0;
    }
  }
  else
  {
    mlir::Type::isInteger((mlir::Type *)&v26, 8);
    if (a4) {
      int v6 = 127;
    }
    else {
      int v6 = -128;
    }
  }
  int v25 = v6;
  v28[0] = 1;
  char v7 = (mlir::Builder *)(a1 + 8);
  uint64_t IntegerType = mlir::Builder::getIntegerType(v7, 0x20u, 1);
  uint64_t v9 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v28, 1, IntegerType, 0);
  uint64_t Loc = mlir::Value::getLoc((mlir::Value *)&v27);
  if (!v9) {
    goto LABEL_17;
  }
  uint64_t v11 = *v9;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_17;
  }
  uint64_t v14 = *(void **)(v11 + 8);
  uint64_t v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    uint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    __int16 v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      uint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_17:
  }
    uint64_t v20 = 0;
  uint64_t v24 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v9, v20, &v25, 4, 4, 1, 1);
  v28[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v7, Loc, &v24);
  uint64_t v21 = mlir::Value::getLoc((mlir::Value *)&v27);
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v27);
  uint64_t v24 = (uint64_t *)mlir::TypeAttr::get(ElementTypeOrSelf);
  return (char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::mps::ReductionProdOp &,mlir::TypeAttr>((mlir::UnknownLoc **)v7, v21, v28, (uint64_t *)&v24)- 16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ClampOp,mlir::Value &,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.clamp", (const unsigned __int8 *)9, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"mps.clamp";
    void v19[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::ClampOp::build((uint64_t)a1, (uint64_t)v21, *a3, *a4, *a5);
  unint64_t v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ClampOp,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::CastOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"mps.cast";
    void v19[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(void *)a4, *(unsigned int *)(a4 + 8));
  mlir::arith::CmpIOp::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  unint64_t v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::CastOp,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::IntegerAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::mps::QuantizeOp &,mlir::OperandRange &,mlir::TypeAttr &)::$_0>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp1 is not ::mlir::mps::QuantizeOp type");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::IntegerAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::mps::QuantizeOp &,mlir::OperandRange &,mlir::TypeAttr &)::$_1>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'mps.quantize' to have attribute 'dtype' of type '::mlir::TypeAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::anonymous namespace'::MPS_LowerQuantize::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'input, old' failed to satisfy constraint: 'mpsx dag op for quantize not supported'");
}

void mlir::mps::anonymous namespace'::MPS_LowerQuantizeWithMPSXQuantDAG::~MPS_LowerQuantizeWithMPSXQuantDAG(mlir::mps::_anonymous_namespace_::MPS_LowerQuantizeWithMPSXQuantDAG *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::mps::anonymous namespace'::MPS_LowerQuantizeWithMPSXQuantDAG::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerQuantizeWithMPSXQuantDAG *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  void v22[4] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = 0;
  if ((*((unsigned char *)a2 + 46) & 0x80) != 0)
  {
    uint64_t v5 = *((void *)a2 + 9);
    uint64_t v6 = *((unsigned int *)a2 + 17);
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
  }
  v17[0] = v5;
  v17[1] = v6;
  v16[0] = v5;
  v16[1] = v6;
  v14[1] = v6;
  uint64_t v15 = 0;
  uint64_t v13 = 0;
  v14[0] = v5;
  __int16 v20 = v22;
  v22[0] = a2;
  uint64_t v21 = 0x400000001;
  char v7 = (void *)(*(void *)(*(void *)(v16[0] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  uint64_t ODSResults = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v15, 0);
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(ODSResults, 0);
  if (mlir::mpsx::FPToIntClampedOp::isSupportedForTypes(v7, (void *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8)))
  {
    unint64_t v19 = *(void **)(*v20 + 24);
    mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v19, (mlir::MLIRContext *)1, 0);
  }
  uint64_t v10 = (uint64_t)a3[2];
  if (v10 && mlir::RewriterBase::Listener::classof(v10)) {
  else
  }
LABEL_9:
    uint64_t v11 = 0;
  if (v20 != v22) {
    free(v20);
  }
  return v11;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mpsx::FPToIntClampedOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.fp_to_int_clamped", (const unsigned __int8 *)0x16, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"mpsx.fp_to_int_clamped";
    void v19[3] = 22;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(void *)a4, *(unsigned int *)(a4 + 8));
  mlir::anec::GOC::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  uint64_t v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::FPToIntClampedOp,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::anonymous namespace'::MPS_LowerQuantizeWithMPSXQuantDAG::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'input, old' failed to satisfy constraint: 'mpsx dag op for quantize supported'");
}

void mlir::mps::anonymous namespace'::MPS_LowerReductionLogSumExp::~MPS_LowerReductionLogSumExp(mlir::mps::_anonymous_namespace_::MPS_LowerReductionLogSumExp *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

void mlir::mps::anonymous namespace'::MPS_LowerReductionLogSumExp::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerReductionLogSumExp *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  v13[4] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = 0;
  uint64_t v11 = v13;
  v13[0] = a2;
  uint64_t v12 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionLogSumExpOp,void>::id) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v8 = v5;
  mlir::memref::PrefetchOp::getODSOperands((mlir::memref::PrefetchOp *)&v8, 0);
  mlir::memref::PrefetchOp::getODSOperands((mlir::memref::PrefetchOp *)&v8, 1u);
  if (*((unsigned char *)a2 + 47)
    && (uint64_t InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"keep_dims", 9), v7))
  {
    if (!InherentAttr) {
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t InherentAttr = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "keep_dims", 9uLL);
    if (!InherentAttr)
    {
LABEL_10:
      uint64_t InherentAttr = 0;
LABEL_11:
      uint64_t v9 = InherentAttr;
      uint64_t v10 = *(void **)(*v11 + 24);
      mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v10, (mlir::MLIRContext *)1, 0);
    }
  }
  if (*(_UNKNOWN **)(*(void *)InherentAttr + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
    goto LABEL_11;
  }
  goto LABEL_10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReductionMaxOp,mlir::Value &,mlir::Value &,mlir::UnitAttr,mlir::UnitAttr>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_max", (const unsigned __int8 *)0x11, Context);
  if (!v14)
  {
    __int16 v22 = 1283;
    unint64_t v21[2] = (uint64_t)"mps.reduction_max";
    v21[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::mps::ReductionMaxOp::build(a1, (uint64_t)v23, *a3, *a4, *a5, *a6);
  uint64_t v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionMaxOp,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::LogarithmOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v20[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.logarithm", (const unsigned __int8 *)0xD, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.logarithm";
    v17[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::LogarithmOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

void mlir::mps::anonymous namespace'::MPS_LowerRelu::~MPS_LowerRelu(mlir::mps::_anonymous_namespace_::MPS_LowerRelu *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

void mlir::mps::anonymous namespace'::MPS_LowerRelu::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerRelu *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  v9[4] = *MEMORY[0x1E4F143B8];
  char v7 = v9;
  v9[0] = a2;
  uint64_t v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReluOp,void>::id) {
    float v4 = a2;
  }
  else {
    float v4 = 0;
  }
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  uint64_t v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::MaximumOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.maximum", (const unsigned __int8 *)0xB, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"mps.maximum";
    void v19[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(void *)a4, *(unsigned int *)(a4 + 8));
  mlir::arith::CmpIOp::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  uint64_t v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MaximumOp,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

void mlir::mps::anonymous namespace'::MPS_LowerRelu6::~MPS_LowerRelu6(mlir::mps::_anonymous_namespace_::MPS_LowerRelu6 *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

void mlir::mps::anonymous namespace'::MPS_LowerRelu6::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerRelu6 *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  v9[4] = *MEMORY[0x1E4F143B8];
  char v7 = v9;
  v9[0] = a2;
  uint64_t v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::Relu6Op,void>::id) {
    float v4 = a2;
  }
  else {
    float v4 = 0;
  }
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  uint64_t v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReluOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v20[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.relu", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.relu";
    v17[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReluOp,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::MinimumOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.minimum", (const unsigned __int8 *)0xB, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"mps.minimum";
    void v19[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(void *)a4, *(unsigned int *)(a4 + 8));
  mlir::arith::CmpIOp::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  uint64_t v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MinimumOp,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

void mlir::mps::anonymous namespace'::MPS_LowerReluGrad::~MPS_LowerReluGrad(mlir::mps::_anonymous_namespace_::MPS_LowerReluGrad *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

void mlir::mps::anonymous namespace'::MPS_LowerReluGrad::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerReluGrad *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  v9[4] = *MEMORY[0x1E4F143B8];
  char v7 = v9;
  v9[0] = a2;
  uint64_t v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReluGradOp,void>::id) {
    float v4 = a2;
  }
  else {
    float v4 = 0;
  }
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 1u);
  uint64_t v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::GreaterThanOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.greater", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.greater";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::EqualToOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::GreaterThanOp,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::mps::anonymous namespace'::MPS_LowerSigmoidGradient::~MPS_LowerSigmoidGradient(mlir::mps::_anonymous_namespace_::MPS_LowerSigmoidGradient *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

void mlir::mps::anonymous namespace'::MPS_LowerSigmoidGradient::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerSigmoidGradient *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  v9[4] = *MEMORY[0x1E4F143B8];
  char v7 = v9;
  v9[0] = a2;
  uint64_t v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SigmoidGradientOp,void>::id) {
    float v4 = a2;
  }
  else {
    float v4 = 0;
  }
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 1u);
  uint64_t v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SigmoidOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v20[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sigmoid", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.sigmoid";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SigmoidOp,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

void mlir::mps::anonymous namespace'::MPS_LowerSigmoidGradientWithSigmoid::~MPS_LowerSigmoidGradientWithSigmoid(mlir::mps::_anonymous_namespace_::MPS_LowerSigmoidGradientWithSigmoid *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

void mlir::mps::anonymous namespace'::MPS_LowerSigmoidGradientWithSigmoid::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerSigmoidGradientWithSigmoid *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  v9[4] = *MEMORY[0x1E4F143B8];
  char v7 = v9;
  v9[0] = a2;
  uint64_t v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SigmoidGradientWithSigmoidOp,void>::id) {
    float v4 = a2;
  }
  else {
    float v4 = 0;
  }
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 1u);
  uint64_t v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

void mlir::mps::anonymous namespace'::MPS_LowerSigmoidHard::~MPS_LowerSigmoidHard(mlir::mps::_anonymous_namespace_::MPS_LowerSigmoidHard *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

void mlir::mps::anonymous namespace'::MPS_LowerSigmoidHard::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerSigmoidHard *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  v9[4] = *MEMORY[0x1E4F143B8];
  char v7 = v9;
  v9[0] = a2;
  uint64_t v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SigmoidHardOp,void>::id) {
    float v4 = a2;
  }
  else {
    float v4 = 0;
  }
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 1u);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 2u);
  uint64_t v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::MaximumOp,mlir::Value &,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.maximum", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.maximum";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MaximumOp,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::mps::anonymous namespace'::MPS_LowerSoftmax::~MPS_LowerSoftmax(mlir::mps::_anonymous_namespace_::MPS_LowerSoftmax *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

void mlir::mps::anonymous namespace'::MPS_LowerSoftmax::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerSoftmax *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  v9[4] = *MEMORY[0x1E4F143B8];
  char v7 = v9;
  v9[0] = a2;
  uint64_t v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SoftmaxOp,void>::id) {
    float v4 = a2;
  }
  else {
    float v4 = 0;
  }
  uint64_t v5 = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v5, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v5, 1u);
  uint64_t v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

void mlir::mps::anonymous namespace'::MPS_LowerSoftsign::~MPS_LowerSoftsign(mlir::mps::_anonymous_namespace_::MPS_LowerSoftsign *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

void mlir::mps::anonymous namespace'::MPS_LowerSoftsign::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerSoftsign *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  v9[4] = *MEMORY[0x1E4F143B8];
  char v7 = v9;
  v9[0] = a2;
  uint64_t v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SoftsignOp,void>::id) {
    float v4 = a2;
  }
  else {
    float v4 = 0;
  }
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  uint64_t v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

void mlir::mps::anonymous namespace'::MPS_LowerSwish::~MPS_LowerSwish(mlir::mps::_anonymous_namespace_::MPS_LowerSwish *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

void mlir::mps::anonymous namespace'::MPS_LowerSwish::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerSwish *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  v9[4] = *MEMORY[0x1E4F143B8];
  char v7 = v9;
  v9[0] = a2;
  uint64_t v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SwishOp,void>::id) {
    float v4 = a2;
  }
  else {
    float v4 = 0;
  }
  uint64_t v5 = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v5, 0);
  uint64_t v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

void mlir::mps::anonymous namespace'::MPS_LowerTruncate::~MPS_LowerTruncate(mlir::mps::_anonymous_namespace_::MPS_LowerTruncate *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

void mlir::mps::anonymous namespace'::MPS_LowerTruncate::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerTruncate *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  v9[4] = *MEMORY[0x1E4F143B8];
  char v7 = v9;
  v9[0] = a2;
  uint64_t v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::TruncateOp,void>::id) {
    float v4 = a2;
  }
  else {
    float v4 = 0;
  }
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  uint64_t v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::CeilOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v20[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.ceil", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"mps.ceil";
    v17[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::CeilOp,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

uint64_t mlir::mps::createGPURegionFormationPass@<X0>(unsigned char *a1@<X0>, void *a2@<X8>)
{
  float v4 = operator new(0x3C8uLL);
  *(void *)uint64_t v5 = &unk_1EC988B70;
  *(unsigned char *)(v5 + 888) = *a1;
  uint64_t v6 = *(void *)(v5 + 944);
  if (v6)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)v6 + 48))(v6, a1);
    *a2 = v4;
  }
  else
  {
    uint64_t v8 = std::__throw_bad_function_call[abi:nn180100]();
  }
  return result;
}

uint64_t mlir::mps::MPSGPURegionFormationBase<mlir::mps::anonymous namespace'::GPURegionFormationPass>::MPSGPURegionFormationBase(uint64_t a1)
{
  *(void *)(a1 + 16) = "builtin.module";
  *(void *)(a1 + 24) = 14;
  *(unsigned char *)(a1 + 32) = 1;
  *(unsigned char *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 120) = 0;
  uint64_t v2 = (void *)(a1 + 152);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = a1 + 200;
  *(void *)(a1 + 192) = 0x400000000;
  *(void *)(a1 + 232) = a1 + 248;
  *(void *)(a1 + 240) = 0x400000000;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 296) = 0x1000000000;
  *(void *)(a1 + 336) = 0;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(void *)a1 = &unk_1EC988BE0;
  v6.n128_u64[0] = (unint64_t)"Device placement hints are strict.";
  v6.n128_u64[1] = 34;
  char v4 = 0;
  uint64_t v5 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 344), (void *)(a1 + 152), (uint64_t)"strict-hints", 12, &v6, &v5);
  *(void *)(a1 + 344) = &unk_1EC9CB060;
  *(void *)(a1 + 536) = &unk_1EC9CB0E0;
  v6.n128_u64[0] = (unint64_t)"Insert instrumentation for perf recording.";
  v6.n128_u64[1] = 42;
  char v4 = 0;
  uint64_t v5 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 552), v2, (uint64_t)"insert-instrumentation", 22, &v6, &v5);
  *(void *)(a1 + 552) = &unk_1EC9CB060;
  *(void *)(a1 + 744) = &unk_1EC9CB0E0;
  v6.n128_u64[0] = (unint64_t)"Whether to duplicate variable creating operations for each region they are used in.";
  v6.n128_u64[1] = 83;
  char v4 = 0;
  uint64_t v5 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 760), v2, (uint64_t)"duplicate-var-operations", 24, &v6, &v5);
  *(void *)(a1 + 760) = &unk_1EC9CB060;
  *(void *)(a1 + 952) = &unk_1EC9CB0E0;
  return a1;
}

void mlir::mps::anonymous namespace'::GPURegionFormationPass::~GPURegionFormationPass(mlir::mps::_anonymous_namespace_::GPURegionFormationPass *this)
{
  *(void *)this = &unk_1EC988BE0;
  *((void *)this + 95) = &unk_1EC9A3F00;
  uint64_t v2 = (char *)this + 920;
  uint64_t v3 = (char *)*((void *)this + 118);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  *((void *)this + 95) = &unk_1EC9A42A8;
  char v4 = (void *)*((void *)this + 107);
  if (v4 != *((void **)this + 106)) {
    free(v4);
  }
  uint64_t v5 = (char *)*((void *)this + 103);
  if (v5 != (char *)this + 840) {
    free(v5);
  }
  *((void *)this + 69) = &unk_1EC9A3F00;
  __n128 v6 = (mlir::mps::_anonymous_namespace_::GPURegionFormationPass *)*((void *)this + 92);
  if (v6 == (mlir::mps::_anonymous_namespace_::GPURegionFormationPass *)((char *)this + 712))
  {
    (*(void (**)(char *))(*((void *)this + 89) + 32))((char *)this + 712);
  }
  else if (v6)
  {
    (*(void (**)(mlir::mps::_anonymous_namespace_::GPURegionFormationPass *))(*(void *)v6 + 40))(v6);
  }
  *((void *)this + 69) = &unk_1EC9A42A8;
  char v7 = (void *)*((void *)this + 81);
  if (v7 != *((void **)this + 80)) {
    free(v7);
  }
  uint64_t v8 = (char *)*((void *)this + 77);
  if (v8 != (char *)this + 632) {
    free(v8);
  }
  *((void *)this + 43) = &unk_1EC9A3F00;
  uint64_t v9 = (mlir::mps::_anonymous_namespace_::GPURegionFormationPass *)*((void *)this + 66);
  if (v9 == (mlir::mps::_anonymous_namespace_::GPURegionFormationPass *)((char *)this + 504))
  {
    (*(void (**)(char *))(*((void *)this + 63) + 32))((char *)this + 504);
  }
  else if (v9)
  {
    (*(void (**)(mlir::mps::_anonymous_namespace_::GPURegionFormationPass *))(*(void *)v9 + 40))(v9);
  }
  *((void *)this + 43) = &unk_1EC9A42A8;
  char v10 = (void *)*((void *)this + 55);
  if (v10 != *((void **)this + 54)) {
    free(v10);
  }
  uint64_t v11 = (char *)*((void *)this + 51);
  if (v11 != (char *)this + 424) {
    free(v11);
  }

  mlir::Pass::~Pass(this);
}

{
  void *v1;
  uint64_t vars8;

  operator delete(v1);
}

const char *mlir::mps::MPSGPURegionFormationBase<mlir::mps::anonymous namespace'::GPURegionFormationPass>::getName()
{
  return "MPSGPURegionFormation";
}

uint64_t mlir::mps::anonymous namespace'::GPURegionFormationPass::getDependentDialects(mlir::mps::_anonymous_namespace_::GPURegionFormationPass *this, uint64_t **a2)
{
  return mlir::DialectRegistry::insert<mlir::placement::PlacementDialect,mlir::mpsx::MPSXDialect,mlir::tensor::TensorDialect,mlir::scf::SCFDialect>(a2);
}

const char *mlir::mps::MPSGPURegionFormationBase<mlir::mps::anonymous namespace'::GPURegionFormationPass>::getArgument()
{
  return "mps-gpu-region-formation";
}

const char *mlir::mps::MPSGPURegionFormationBase<mlir::mps::anonymous namespace'::GPURegionFormationPass>::getDescription()
{
  return "Form GPU regions.";
}

void mlir::mps::anonymous namespace'::GPURegionFormationPass::runOnOperation(mlir::mps::_anonymous_namespace_::GPURegionFormationPass *this)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (void *)(*((void *)this + 5) & 0xFFFFFFFFFFFFFFF8);
  v8[0] = mlir::Attribute::getContext((mlir::Attribute *)(v2 + 3));
  v8[1] = 0;
  uint64_t v3 = v2[2];
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)v2);
  void v8[2] = v3;
  v8[3] = v4;
  char v5 = *((unsigned char *)this + 472);
  char v6 = *((unsigned char *)this + 680);
  char v7 = *((unsigned char *)this + 888);
  v9[1] = v8;
  int64x2_t v10 = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
  char v11 = 0;
  v9[0] = &unk_1EC988A28;
  v12[1] = 0;
  void v12[2] = 0;
  v12[0] = (uint64_t)&unk_1EC9AA748;
  int v13 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v14 = v16;
  uint64_t v15 = 0;
  v16[0] = 0;
  v16[1] = 0;
  int v17 = 0;
  int v20 = 0;
  int v21 = 16;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v24 = 0x2800000000;
  uint64_t v25 = 0;
  uint64_t v26 = v8[0];
  char v27 = v5;
  char v28 = v6;
  char v29 = v7;
  unint64_t v30 = &v32;
  uint64_t v32 = "func";
  uint64_t v33 = 4;
  uint64_t v31 = 0x200000001;
  mlir::ConversionTarget::setDialectAction(v12, (uint64_t)&v32, 1, 2);
  if (v30 != &v32) {
    free(v30);
  }
  mlir::OperationName::OperationName(&v30, "placement.region_call", 21, v26);
  mlir::ConversionTarget::setOpAction((uint64_t)v12, (uint64_t)v30, 2);
  mlir::OperationName::OperationName(&v30, "placement.tensor_to_memref", 26, v26);
  mlir::ConversionTarget::setOpAction((uint64_t)v12, (uint64_t)v30, 2);
  mlir::OperationName::OperationName(&v30, "placement.memref_to_tensor", 26, v26);
  mlir::ConversionTarget::setOpAction((uint64_t)v12, (uint64_t)v30, 2);
  unint64_t v30 = &v32;
  uint64_t v32 = "mpsx";
  uint64_t v33 = 4;
  uint64_t v31 = 0x200000001;
  mlir::ConversionTarget::setDialectAction(v12, (uint64_t)&v32, 1, 0);
  if (v30 != &v32) {
    free(v30);
  }
  unint64_t v30 = &v32;
  uint64_t v32 = "mps";
  uint64_t v33 = 3;
  uint64_t v31 = 0x200000001;
  mlir::ConversionTarget::setDialectAction(v12, (uint64_t)&v32, 1, 0);
  if (v30 != &v32) {
    free(v30);
  }
  unint64_t v30 = &v32;
  uint64_t v32 = "tensor";
  uint64_t v33 = 6;
  uint64_t v31 = 0x200000001;
  mlir::ConversionTarget::setDialectAction(v12, (uint64_t)&v32, 1, 2);
  if (v30 != &v32) {
    free(v30);
  }
  unint64_t v30 = &v32;
  uint64_t v32 = "scf";
  uint64_t v33 = 3;
  uint64_t v31 = 0x200000001;
  mlir::ConversionTarget::setDialectAction(v12, (uint64_t)&v32, 1, 2);
  if (v30 != &v32) {
    free(v30);
  }
  if (!mlir::collectRegions((mlir::ForwardIterator *)(*((void *)this + 5) & 0xFFFFFFFFFFFFFFF8), (uint64_t)v9, 0))*((void *)this + 5) |= 4uLL; {
  v9[0] = &unk_1EC988A28;
  }
  mlir::ConversionTarget::~ConversionTarget((mlir::ConversionTarget *)v12);
}

void *mlir::mps::MPSGPURegionFormationBase<mlir::mps::anonymous namespace'::GPURegionFormationPass>::clonePass@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x3C8uLL);
  uint64_t v5 = *(void *)(a1 + 8);
  v4[1] = *(_OWORD *)(a1 + 16);
  *((void *)v4 + 4) = *(void *)(a1 + 32);
  *((void *)v4 + 1) = v5;
  *((unsigned char *)v4 + 40) = 0;
  *((unsigned char *)v4 + 120) = 0;
  v4[8] = 0u;
  v4[9] = 0u;
  v4[10] = 0u;
  *((void *)v4 + 22) = 0;
  *((void *)v4 + 23) = (char *)v4 + 200;
  *((void *)v4 + 24) = 0x400000000;
  *((void *)v4 + 29) = (char *)v4 + 248;
  *((void *)v4 + 30) = 0x400000000;
  *((void *)v4 + 35) = 0;
  *((void *)v4 + 36) = 0;
  *((_DWORD *)v4 + 74) = 0;
  *((_DWORD *)v4 + 75) = 16;
  v4[19] = 0u;
  v4[20] = 0u;
  *((void *)v4 + 42) = 0;
  *(void *)uint64_t v4 = &unk_1EC988BE0;
  v9.n128_u64[0] = (unint64_t)"Device placement hints are strict.";
  v9.n128_u64[1] = 34;
  char v7 = 0;
  uint64_t v8 = &v7;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)v4 + 43, (void *)v4 + 19, (uint64_t)"strict-hints", 12, &v9, &v8);
  *((void *)v4 + 43) = &unk_1EC9CB060;
  *((void *)v4 + 67) = &unk_1EC9CB0E0;
  v9.n128_u64[0] = (unint64_t)"Insert instrumentation for perf recording.";
  v9.n128_u64[1] = 42;
  char v7 = 0;
  uint64_t v8 = &v7;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)v4 + 69, (void *)v4 + 19, (uint64_t)"insert-instrumentation", 22, &v9, &v8);
  *((void *)v4 + 69) = &unk_1EC9CB060;
  *((void *)v4 + 93) = &unk_1EC9CB0E0;
  v9.n128_u64[0] = (unint64_t)"Whether to duplicate variable creating operations for each region they are used in.";
  v9.n128_u64[1] = 83;
  char v7 = 0;
  uint64_t v8 = &v7;
  uint64_t result = mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)v4 + 95, (void *)v4 + 19, (uint64_t)"duplicate-var-operations", 24, &v9, &v8);
  *((void *)v4 + 95) = &unk_1EC9CB060;
  *((void *)v4 + 119) = &unk_1EC9CB0E0;
  *(void *)uint64_t v4 = &unk_1EC988B70;
  *a2 = v4;
  return result;
}

uint64_t mlir::DialectRegistry::insert<mlir::placement::PlacementDialect,mlir::mpsx::MPSXDialect,mlir::tensor::TensorDialect,mlir::scf::SCFDialect>(uint64_t **a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  v3[0] = &unk_1EC9CF0D8;
  uint64_t v4 = v3;
  mlir::DialectRegistry::insert(a1, &mlir::detail::TypeIDResolver<mlir::placement::PlacementDialect,void>::id, "placement", 9uLL, v3);
  if (v4 == v3)
  {
    (*(void (**)(void *))(v3[0] + 32))(v3);
  }
  else if (v4)
  {
    (*(void (**)(void))(*v4 + 40))();
  }
  v3[0] = &unk_1EC9CF000;
  uint64_t v4 = v3;
  mlir::DialectRegistry::insert(a1, &mlir::detail::TypeIDResolver<mlir::mpsx::MPSXDialect,void>::id, "mpsx", 4uLL, v3);
  if (v4 == v3)
  {
    (*(void (**)(void *))(v3[0] + 32))(v3);
  }
  else if (v4)
  {
    (*(void (**)(void))(*v4 + 40))();
  }
  return mlir::DialectRegistry::insert<mlir::tensor::TensorDialect,mlir::scf::SCFDialect>(a1);
}

void *std::__function::__func<void mlir::DialectRegistry::insert<mlir::placement::PlacementDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::placement::PlacementDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EC9CF0D8;
  return result;
}

void std::__function::__func<void mlir::DialectRegistry::insert<mlir::placement::PlacementDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::placement::PlacementDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EC9CF0D8;
}

mlir::Dialect *std::__function::__func<void mlir::DialectRegistry::insert<mlir::placement::PlacementDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::placement::PlacementDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::operator()(uint64_t a1, void **a2)
{
  return mlir::MLIRContext::getOrLoadDialect(*a2, (uint64_t)"placement", 9, (uint64_t)&mlir::detail::TypeIDResolver<mlir::placement::PlacementDialect,void>::id, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::placement::PlacementDialect * mlir::MLIRContext::getOrLoadDialect<mlir::placement::PlacementDialect>(void)::{lambda(void)#1}>, (uint64_t)&v3);
}

mlir::placement::PlacementDialect *llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::placement::PlacementDialect * mlir::MLIRContext::getOrLoadDialect<mlir::placement::PlacementDialect>(void)::{lambda(void)#1}>@<X0>(mlir::MLIRContext **a1@<X0>, mlir::placement::PlacementDialect **a2@<X8>)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (mlir::placement::PlacementDialect *)operator new(0x60uLL);
  uint64_t result = mlir::placement::PlacementDialect::PlacementDialect(v4, v3);
  *a2 = result;
  return result;
}

uint64_t mlir::DialectRegistry::insert<mlir::tensor::TensorDialect,mlir::scf::SCFDialect>(uint64_t **a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  v3[0] = &unk_1EC9CF090;
  uint64_t v4 = v3;
  mlir::DialectRegistry::insert(a1, &mlir::detail::TypeIDResolver<mlir::tensor::TensorDialect,void>::id, "tensor", 6uLL, v3);
  if (v4 == v3)
  {
    (*(void (**)(void *))(v3[0] + 32))(v3);
  }
  else if (v4)
  {
    (*(void (**)(void))(*v4 + 40))();
  }
  v3[0] = &unk_1EC9CEF28;
  uint64_t v4 = v3;
  mlir::DialectRegistry::insert(a1, &mlir::detail::TypeIDResolver<mlir::scf::SCFDialect,void>::id, "scf", 3uLL, v3);
  uint64_t result = (uint64_t)v4;
  if (v4 == v3) {
    return (*(uint64_t (**)(void *))(v3[0] + 32))(v3);
  }
  if (v4) {
    return (*(uint64_t (**)(void))(*v4 + 40))();
  }
  return result;
}

void *std::__function::__func<void mlir::DialectRegistry::insert<mlir::scf::SCFDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::scf::SCFDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EC9CEF28;
  return result;
}

void std::__function::__func<void mlir::DialectRegistry::insert<mlir::scf::SCFDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::scf::SCFDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EC9CEF28;
}

mlir::Dialect *std::__function::__func<void mlir::DialectRegistry::insert<mlir::scf::SCFDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::scf::SCFDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::operator()(uint64_t a1, void **a2)
{
  return mlir::MLIRContext::getOrLoadDialect(*a2, (uint64_t)"scf", 3, (uint64_t)&mlir::detail::TypeIDResolver<mlir::scf::SCFDialect,void>::id, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::scf::SCFDialect * mlir::MLIRContext::getOrLoadDialect<mlir::scf::SCFDialect>(void)::{lambda(void)#1}>, (uint64_t)&v3);
}

mlir::scf::SCFDialect *llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::scf::SCFDialect * mlir::MLIRContext::getOrLoadDialect<mlir::scf::SCFDialect>(void)::{lambda(void)#1}>@<X0>(mlir::MLIRContext **a1@<X0>, mlir::scf::SCFDialect **a2@<X8>)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (mlir::scf::SCFDialect *)operator new(0x60uLL);
  uint64_t result = mlir::scf::SCFDialect::SCFDialect(v4, v3);
  *a2 = result;
  return result;
}

void mlir::mps::anonymous namespace'::GPURegionOpCreator::~GPURegionOpCreator(mlir::mps::_anonymous_namespace_::GPURegionOpCreator *this)
{
  *(void *)this = &unk_1EC988A28;
  mlir::ConversionTarget::~ConversionTarget((mlir::mps::_anonymous_namespace_::GPURegionOpCreator *)((char *)this + 40));
}

{
  *(void *)this = &unk_1EC988A28;
  mlir::ConversionTarget::~ConversionTarget((mlir::mps::_anonymous_namespace_::GPURegionOpCreator *)((char *)this + 40));
}

uint64_t sub_1805A3948()
{
  return v0;
}

void sub_1805A398C()
{
  operator delete(v0);
}

uint64_t mlir::mps::anonymous namespace'::GPURegionOpCreator::getMarkAttrID(mlir::mps::_anonymous_namespace_::GPURegionOpCreator *this)
{
  uint64_t v1 = (mlir::StringAttr **)*((void *)this + 1);
  uint64_t v3 = "GPU_region";
  __int16 v4 = 259;
  return mlir::Builder::getStringAttr(v1, (mlir::MLIRContext *)&v3);
}

BOOL mlir::mps::anonymous namespace'::GPURegionOpCreator::isOpCompatible(mlir::mps::_anonymous_namespace_::GPURegionOpCreator *this, mlir::Operation *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  unsigned __int16 isLegal = mlir::ConversionTarget::isLegal((mlir::mps::_anonymous_namespace_::GPURegionOpCreator *)((char *)this + 40), a2);
  BOOL v5 = isLegal > 0xFFu;
  if (*((unsigned char *)a2 + 47)
    && (uint64_t InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"device_hint", 11), v7))
  {
    if (!InherentAttr) {
      return v5;
    }
  }
  else
  {
    uint64_t InherentAttr = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "device_hint", 0xBuLL);
    if (!InherentAttr) {
      return v5;
    }
  }
  uint64_t v8 = *(void **)(*(void *)InherentAttr + 136);
  BOOL v9 = v8 == &mlir::detail::TypeIDResolver<mlir::mps::DeviceHintAttr,void>::id;
  if (v8 == &mlir::detail::TypeIDResolver<mlir::mps::DeviceHintAttr,void>::id) {
    uint64_t v10 = InherentAttr;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v13 = v10;
  if (v9)
  {
    if (mlir::AffineExpr::getKind((mlir::AffineExpr *)&v13) == 1
      && *((unsigned char *)this + 200)
      && isLegal <= 0xFFu)
    {
    }
    if (mlir::AffineExpr::getKind((mlir::AffineExpr *)&v13) != 1) {
      return 0;
    }
  }
  return v5;
}

uint64_t mlir::RegionOpCreator::isOpCompatible(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 24))();
}

uint64_t mlir::mps::anonymous namespace'::GPURegionOpCreator::isRegionProfitable()
{
  return 1;
}

mlir::GenericProgramPoint *mlir::mps::anonymous namespace'::GPURegionOpCreator::getRegionOp(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  void v32[2] = *MEMORY[0x1E4F143B8];
  v32[0] = a6;
  v32[1] = a7;
  v31[0] = a9;
  v31[1] = a10;
  v30[0] = a11;
  v30[1] = a12;
  v29[0] = a13;
  v29[1] = a14;
  v28[0] = a15;
  v28[1] = a16;
  __int16 v24 = 773;
  v23[0] = a3;
  v23[1] = a4;
  void v23[2] = "_GPU_region_";
  v25[0] = v23;
  void v25[2] = &a17;
  __int16 v26 = 2818;
  llvm::Twine::str((llvm::Twine *)v25, &__p);
  int v20 = *(mlir::OpBuilder **)(a1 + 8);
  v25[0] = 0;
  v25[1] = 0;
  int v21 = mlir::OpBuilder::create<mlir::mpsx::GPUOp,std::string &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute>>(v20, a2, (void **)&__p.__r_.__value_.__l.__data_, a5, (uint64_t)v30, v29, (uint64_t)v32, v31, (uint64_t)v28, (uint64_t)v25);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v21;
}

mlir::FrozenRewritePatternSet *mlir::mps::anonymous namespace'::GPURegionOpCreator::getCanonicalizationPatterns@<X0>(mlir::FrozenRewritePatternSet *a1@<X8>)
{
  return mlir::FrozenRewritePatternSet::FrozenRewritePatternSet(a1);
}

mlir::GenericProgramPoint *mlir::mps::anonymous namespace'::GPURegionOpCreator::getRegionTerminator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v5[0] = a3;
  v5[1] = a4;
  return mlir::OpBuilder::create<mlir::mpsx::RegionReturnOp,llvm::ArrayRef<mlir::Value> &>(*(mlir::OpBuilder **)(a1 + 8), a2, (uint64_t)v5);
}

uint64_t mlir::mps::anonymous namespace'::GPURegionOpCreator::getBody(mlir::mps::_anonymous_namespace_::GPURegionOpCreator *this, mlir::Operation *a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t result = mlir::OpInterface<mlir::FormableRegionOpInterface,mlir::detail::FormableRegionOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)a2);
  if (result)
  {
    mlir::OpInterface<mlir::FormableRegionOpInterface,mlir::detail::FormableRegionOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)a2);
    return *((void *)a2 + 2);
  }
  return result;
}

void mlir::mps::anonymous namespace'::GPURegionOpCreator::getInitializedConversionTarget(uint64_t a1@<X8>)
{
}

double mlir::RegionOpCreator::computeDeviceRegionCost()
{
  return 0.0;
}

double mlir::RegionOpCreator::computeDeviceRegionCost(mlir::RegionOpCreator *this, mlir::Operation *a2)
{
  return 0.0;
}

double mlir::RegionOpCreator::computeHostRegionCost()
{
  return 0.0;
}

double mlir::RegionOpCreator::computeHostRegionCost(mlir::RegionOpCreator *this, mlir::Operation *a2)
{
  return 0.0;
}

double mlir::RegionOpCreator::computeModuleCost(mlir::RegionOpCreator *this, mlir::Operation *a2)
{
  return 0.0;
}

double mlir::RegionOpCreator::synchronizationCost(mlir::RegionOpCreator *this, mlir::Operation *a2)
{
  return 0.0;
}

BOOL mlir::mps::anonymous namespace'::GPURegionOpCreator::replaceOutOfRegionUses(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = *(unsigned int *)(a2 + 36);
  uint64_t v7 = a2 - 16;
  if (v6) {
    uint64_t v8 = a2 - 16;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v26 = v8;
  uint64_t v27 = v6;
  mlir::ResultRange::use_begin(&v26, (uint64_t *)&v28);
  uint64_t v9 = *(unsigned int *)(a2 + 36);
  if (v9) {
    uint64_t v10 = v7;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v26 = v10;
  uint64_t v27 = v9;
  mlir::ResultRange::use_end(&v26, v25);
  uint64_t v11 = v29;
  uint64_t v12 = v25[4];
  while (1)
  {
    if (v11 == v12) {
      return 1;
    }
    uint64_t v14 = *(void *)(v11 + 16);
    uint64_t v15 = mlir::TypeID::get<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>>();
    if (((*(uint64_t (**)(void, uint64_t))(**(void **)(v14 + 48) + 32))(*(void *)(v14 + 48), v15) & 1) == 0) {
      break;
    }
LABEL_10:
    mlir::ResultRange::UseIterator::operator++((uint64_t *)&v28);
    uint64_t v11 = v29;
  }
  uint64_t v16 = *a3;
  uint64_t v17 = *((unsigned int *)a3 + 4);
  if (!v17) {
    goto LABEL_8;
  }
  LODWORD(v18) = (v17 - 1) & ((v14 >> 4) ^ (v14 >> 9));
  uint64_t v13 = (uint64_t *)(v16 + 8 * v18);
  uint64_t v19 = *v13;
  if (*v13 != v14)
  {
    int v20 = 1;
    while (v19 != -4096)
    {
      int v21 = v18 + v20++;
      uint64_t v18 = v21 & (v17 - 1);
      uint64_t v19 = *(void *)(v16 + 8 * v18);
      if (v19 == v14)
      {
        uint64_t v13 = (uint64_t *)(v16 + 8 * v18);
        goto LABEL_9;
      }
    }
LABEL_8:
    uint64_t v13 = (uint64_t *)(v16 + 8 * v17);
  }
LABEL_9:
  if (v13 != (uint64_t *)(v16 + 8 * v17)) {
    goto LABEL_10;
  }
  BOOL result = 1;
  if (a2 && *(unsigned char *)(a1 + 202))
  {
    uint64_t v23 = *(void **)(*(void *)(a2 + 48) + 16);
    return v23 != &mlir::detail::TypeIDResolver<mlir::mps::VariableFromTensorOp,void>::id
        && v23 != &mlir::detail::TypeIDResolver<mlir::mpsx::VarHandleOp,void>::id;
  }
  return result;
}

mlir::GenericProgramPoint *mlir::mps::anonymous namespace'::GPURegionOpCreator::getCallOp(uint64_t a1, uint64_t a2, mlir::SymbolRefAttr *a3, uint64_t a4, uint64_t a5)
{
  void v9[2] = *MEMORY[0x1E4F143B8];
  v9[0] = a4;
  v9[1] = a5;
  uint64_t v8 = a3;
  BOOL v5 = *(mlir::MLIRContext ***)(a1 + 8);
  int v7 = 0;
  return mlir::OpBuilder::create<mlir::placement::RegionCall,mlir::Operation *&,mlir::placement::RegionType,mlir::ValueRange &>(v5, a2, &v8, &v7, v9);
}

uint64_t mlir::RegionOpCreator::getHostReshape()
{
  return 0;
}

uint64_t mlir::RegionOpCreator::getHostCast()
{
  return 0;
}

uint64_t *mlir::RegionOpCreator::getConvertedType(uint64_t a1, uint64_t *a2)
{
  if (a2)
  {
    uint64_t v3 = *a2;
    unint64_t v4 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v5 = *(unsigned int *)(v3 + 16);
    if (v5)
    {
      uint64_t v6 = *(void **)(v3 + 8);
      do
      {
        unint64_t v7 = v5 >> 1;
        uint64_t v8 = &v6[2 * (v5 >> 1)];
        unint64_t v10 = *v8;
        uint64_t v9 = v8 + 2;
        v5 += ~(v5 >> 1);
        if (v10 < v4) {
          uint64_t v6 = v9;
        }
        else {
          unint64_t v5 = v7;
        }
      }
      while (v5);
    }
  }
  return a2;
}

uint64_t mlir::RegionOpCreator::getPromotedType(uint64_t a1, uint64_t a2)
{
  return a2;
}

void mlir::RegionOpCreator::getPromotedTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)(a4 + 8) = 0;
  uint64_t v13 = a2;
  uint64_t v14 = 0;
  if (a3)
  {
    uint64_t v8 = 0;
    uint64_t v9 = (void *)(a4 + 16);
    do
    {
      uint64_t v10 = mlir::ValueRange::dereference_iterator(&v13, v8);
      uint64_t v11 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)a1 + 184))(a1, *(void *)(v10 + 8) & 0xFFFFFFFFFFFFFFF8);
      unint64_t v12 = *(unsigned int *)(a4 + 8);
      if (v12 >= *(unsigned int *)(a4 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a4, v9, v12 + 1, 8);
        unint64_t v12 = *(unsigned int *)(a4 + 8);
      }
      *(void *)(*(void *)a4 + 8 * v12) = v11;
      ++*(_DWORD *)(a4 + 8);
      uint64_t v8 = ++v14;
    }
    while (v13 != a2 || v8 != a3);
  }
}

{
  uint64_t v8;
  void *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;

  *(_DWORD *)(a4 + 8) = 0;
  if (a3)
  {
    uint64_t v8 = 0;
    uint64_t v9 = (void *)(a4 + 16);
    do
    {
      uint64_t v10 = mlir::TypeRange::dereference_iterator(a2, v8);
      uint64_t v11 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)a1 + 184))(a1, v10);
      unint64_t v12 = *(unsigned int *)(a4 + 8);
      if (v12 >= *(unsigned int *)(a4 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a4, v9, v12 + 1, 8);
        unint64_t v12 = *(unsigned int *)(a4 + 8);
      }
      *(void *)(*(void *)a4 + 8 * v12) = v11;
      ++*(_DWORD *)(a4 + 8);
      ++v8;
    }
    while (a3 != v8);
  }
}

uint64_t mlir::mps::anonymous namespace'::GPURegionOpCreator::insertInstrumentation(mlir::mps::_anonymous_namespace_::GPURegionOpCreator *this)
{
  return *((unsigned __int8 *)this + 201);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mpsx::GPUOp,std::string &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute>>(mlir::OpBuilder *a1, uint64_t a2, void **a3, uint64_t *a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t *a8, uint64_t a9, uint64_t a10)
{
  v33[38] = *MEMORY[0x1E4F143B8];
  uint64_t v28 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v28);
  uint64_t v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.gpu", (const unsigned __int8 *)8, Context);
  if (!v20)
  {
    __int16 v32 = 1283;
    uint64_t v31[2] = (uint64_t)"mpsx.gpu";
    v31[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v30 = 259;
    llvm::operator+(v31, (uint64_t *)&v29, (uint64_t)v33);
    llvm::report_fatal_error((llvm::Twine *)v33, 1);
  }
  mlir::OperationState::OperationState(v33, a2, v19);
  int v22 = *((char *)a3 + 23);
  if (v22 >= 0) {
    uint64_t v23 = a3;
  }
  else {
    uint64_t v23 = *a3;
  }
  if (v22 >= 0) {
    uint64_t v24 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    uint64_t v24 = (uint64_t)a3[1];
  }
  mlir::mpsx::ANEOp::build((uint64_t)a1, (uint64_t)v33, v23, v24, a4, *(void **)a5, *(void *)(a5 + 8), v21, *a6, a6[1], *(void **)a7, *(void *)(a7 + 8), *a8, a8[1], *(mlir::Operation ***)a9, *(void *)(a9 + 8), *(void **)a10, *(void *)(a10 + 8));
  uint64_t v25 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v33);
  if (*(_UNKNOWN **)(*((void *)v25 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::GPUOp,void>::id) {
    uint64_t v26 = v25;
  }
  else {
    uint64_t v26 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v33);
  return v26;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mpsx::RegionReturnOp,llvm::ArrayRef<mlir::Value> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.region_return", (const unsigned __int8 *)0x12, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    void v15[2] = (uint64_t)"mpsx.region_return";
    v15[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(void *)(a3 + 8));
  mlir::anec::RegionReturn::build((uint64_t)a1, (uint64_t)v18, v17[0], v17[1]);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::RegionReturnOp,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

uint64_t mlir::OpInterface<mlir::FormableRegionOpInterface,mlir::detail::FormableRegionOpInterfaceInterfaceTraits>::getInterfaceFor(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  BOOL v3 = v2 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 48);
  }
  if (v3)
  {
    uint64_t v22 = *(void *)(v1 + 8);
    uint64_t result = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v22);
    if (result)
    {
      uint64_t v20 = result;
      uint64_t v21 = mlir::TypeID::get<mlir::FormableRegionOpInterface>();
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v20 + 104))(v20, v21, v1);
    }
  }
  else
  {
    unint64_t v6 = v4 | v1 & 0xFFFFFFFFFFFFFF00;
    unint64_t v7 = mlir::TypeID::get<mlir::FormableRegionOpInterface>();
    unint64_t v8 = *(unsigned int *)(v6 + 40);
    if (!v8) {
      goto LABEL_14;
    }
    uint64_t v9 = *(void **)(v6 + 32);
    uint64_t v10 = &v9[2 * v8];
    do
    {
      unint64_t v11 = v8 >> 1;
      uint64_t v12 = &v9[2 * (v8 >> 1)];
      unint64_t v14 = *v12;
      uint64_t v13 = v12 + 2;
      v8 += ~(v8 >> 1);
      if (v14 < v7) {
        uint64_t v9 = v13;
      }
      else {
        unint64_t v8 = v11;
      }
    }
    while (v8);
    if (v9 == v10 || *v9 != v7 || (uint64_t result = v9[1]) == 0)
    {
LABEL_14:
      uint64_t v16 = *(void *)(v6 + 24);
      uint64_t v17 = *(void *)(a1 + 48);
      uint64_t v18 = mlir::TypeID::get<mlir::FormableRegionOpInterface>();
      uint64_t v19 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v16 + 104);
      return v19(v16, v18, v17);
    }
  }
  return result;
}

void mlir::ConversionTarget::ConversionTarget(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA748;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  llvm::deallocate_buffer(0, 0);
}

void sub_1805A4628()
{
  uint64_t v3 = *(unsigned int *)(v1 + 24);
  *(_DWORD *)(v0 + 24) = v3;
  if (v3)
  {
    buffer = llvm::allocate_buffer(16 * v3, (std::align_val_t)8uLL);
    *(void *)(v0 + 8) = buffer;
    *(void *)(v0 + 16) = *(void *)(v1 + 16);
    memcpy(buffer, *(const void **)(v1 + 8), 16 * *(unsigned int *)(v0 + 24));
  }
  else
  {
    void *v2 = 0;
    v2[1] = 0;
  }
  *(void *)(v0 + 32) = v0 + 48;
  *(void *)(v0 + 40) = 0;
  if (*(_DWORD *)(v1 + 40)) {
    llvm::SmallVectorImpl<std::pair<mlir::OperationName,mlir::ConversionTarget::LegalizationInfo>>::operator=((unsigned int *)(v0 + 32), v1 + 32);
  }
  *(void *)(v0 + 48) = 0;
  *(void *)(v0 + 56) = 0;
  *(_DWORD *)(v0 + 64) = 0;
  llvm::DenseMap<mlir::OperationName,std::function<std::optional<BOOL> ()(mlir::Operation *)>,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,std::function<std::optional<BOOL> ()(mlir::Operation *)>>>::copyFrom(v0 + 48);
}

void *sub_1805A4694()
{
  llvm::StringMap<mlir::ConversionTarget::LegalizationAction,llvm::MallocAllocator>::StringMap((llvm::StringMapImpl *)(v0 + 9), v1 + 9);
  llvm::StringMap<std::function<std::optional<BOOL> ()(mlir::Operation *)>,llvm::MallocAllocator>::StringMap((llvm::StringMapImpl *)(v0 + 12), v1 + 12);
  uint64_t v2 = (uint64_t *)v1[18];
  if (v2)
  {
    if (v2 == v1 + 15)
    {
      v0[18] = v0 + 15;
      (*(void (**)(uint64_t))(*(void *)v1[18] + 24))(v1[18]);
    }
    else
    {
      v0[18] = (*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
    }
  }
  else
  {
    v0[18] = 0;
  }
  v0[19] = v1[19];
  return v0;
}

unsigned int *llvm::SmallVectorImpl<std::pair<mlir::OperationName,mlir::ConversionTarget::LegalizationInfo>>::operator=(unsigned int *a1, uint64_t a2)
{
  if (a1 != (unsigned int *)a2)
  {
    unint64_t v4 = *(unsigned int *)(a2 + 8);
    uint64_t v5 = a1[2];
    if (v5 >= v4)
    {
      if (v4)
      {
        uint64_t v9 = *(void *)a2;
        uint64_t v10 = *(void *)a1;
        uint64_t v11 = 48 * v4;
        do
        {
          std::pair<mlir::OperationName,mlir::ConversionTarget::LegalizationInfo>::operator=[abi:nn180100](v10, v9);
          v9 += 48;
          v10 += 48;
          v11 -= 48;
        }
        while (v11);
        uint64_t v12 = *(void *)a1;
        LODWORD(v5) = a1[2];
      }
      else
      {
        uint64_t v12 = *(void *)a1;
        uint64_t v10 = *(void *)a1;
      }
      if (v12 + 48 * v5 != v10)
      {
        uint64_t v17 = v12 + 48 * v5 - 32;
        uint64_t v18 = (void *)v17;
        do
        {
          uint64_t v20 = (void *)v18[3];
          if (v18 == v20)
          {
            (*(void (**)(void *))(*v18 + 32))(v18);
          }
          else if (v20)
          {
            (*(void (**)(void *))(*v20 + 40))(v20);
          }
          uint64_t v19 = v18 - 2;
          v18 -= 6;
          v17 -= 48;
        }
        while (v19 != (void *)v10);
      }
    }
    else
    {
      if (a1[3] >= v4)
      {
        uint64_t v13 = *(char **)a1;
        if (v5)
        {
          uint64_t v14 = *(void *)a2;
          uint64_t v15 = 48 * v5;
          do
          {
            std::pair<mlir::OperationName,mlir::ConversionTarget::LegalizationInfo>::operator=[abi:nn180100]((uint64_t)v13, v14);
            v14 += 48;
            v13 += 48;
            v15 -= 48;
          }
          while (v15);
          uint64_t v13 = *(char **)a1;
        }
        else
        {
          uint64_t v5 = 0;
        }
      }
      else
      {
        if (v5)
        {
          uint64_t v6 = 48 * v5;
          uint64_t v7 = *(void *)a1 - 32;
          do
          {
            uint64_t v8 = *(void *)(v7 + v6 + 24);
            if (v7 + v6 == v8)
            {
              (*(void (**)(uint64_t))(*(void *)(v7 + v6) + 32))(v7 + v6);
            }
            else if (v8)
            {
              (*(void (**)(uint64_t))(*(void *)v8 + 40))(v8);
            }
            v6 -= 48;
          }
          while (v6);
        }
        a1[2] = 0;
        unint64_t v30 = 0;
        uint64_t v13 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow((uint64_t)a1, a1 + 4, v4, 48, &v30);
        llvm::SmallVectorTemplateBase<std::pair<mlir::OperationName,mlir::ConversionTarget::LegalizationInfo>,false>::moveElementsForGrow(a1, (uint64_t)v13);
        unsigned int v16 = v30;
        if (*(unsigned int **)a1 != a1 + 4) {
          free(*(void **)a1);
        }
        uint64_t v5 = 0;
        *(void *)a1 = v13;
        a1[3] = v16;
      }
      uint64_t v21 = *(unsigned int *)(a2 + 8);
      if (v5 != v21)
      {
        uint64_t v23 = *(void *)a2;
        uint64_t v24 = 48 * v5;
        uint64_t v25 = 48 * v21;
        do
        {
          uint64_t v26 = &v13[v24];
          uint64_t v27 = v23 + v24;
          *(void *)uint64_t v26 = *(void *)(v23 + v24);
          int v28 = *(_DWORD *)(v23 + v24 + 8);
          v26[12] = *(unsigned char *)(v23 + v24 + 12);
          *((_DWORD *)v26 + 2) = v28;
          uint64_t v29 = *(void *)(v23 + v24 + 40);
          if (v29)
          {
            if (v27 + 16 == v29)
            {
              *(void *)&v13[v24 + 40] = v26 + 16;
              (*(void (**)(void))(**(void **)(v27 + 40) + 24))(*(void *)(v27 + 40));
            }
            else
            {
              *(void *)&v13[v24 + 40] = (*(uint64_t (**)(uint64_t))(*(void *)v29 + 16))(v29);
            }
          }
          else
          {
            *((void *)v26 + 5) = 0;
          }
          v13 += 48;
          v25 -= 48;
          v23 += 48;
        }
        while (v24 != v25);
      }
    }
    a1[2] = v4;
  }
  return a1;
}

uint64_t std::pair<mlir::OperationName,mlir::ConversionTarget::LegalizationInfo>::operator=[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  *(void *)a1 = *(void *)a2;
  int v3 = *(_DWORD *)(a2 + 8);
  *(unsigned char *)(a1 + 12) = *(unsigned char *)(a2 + 12);
  *(_DWORD *)(a1 + 8) = v3;
  unint64_t v4 = (void *)(a1 + 16);
  uint64_t v5 = *(void *)(a2 + 40);
  if (v5)
  {
    if (v5 == a2 + 16)
    {
      uint64_t v8 = v7;
      (*(void (**)(uint64_t, void *))(*(void *)(a2 + 16) + 24))(a2 + 16, v7);
    }
    else
    {
      uint64_t v8 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  std::__function::__value_func<std::optional<BOOL> ()(mlir::Operation *)>::swap[abi:nn180100](v7, v4);
  if (v8 == v7)
  {
    (*(void (**)(void *))(v7[0] + 32))(v7);
  }
  else if (v8)
  {
    (*(void (**)(void))(*v8 + 40))();
  }
  return a1;
}

void *std::__function::__value_func<std::optional<BOOL> ()(mlir::Operation *)>::swap[abi:nn180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    int v3 = result;
    unint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        void v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        void v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        void v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      void v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

unsigned int *llvm::SmallVectorTemplateBase<std::pair<mlir::OperationName,mlir::ConversionTarget::LegalizationInfo>,false>::moveElementsForGrow(unsigned int *result, uint64_t a2)
{
  uint64_t v2 = result[2];
  if (v2)
  {
    int v3 = result;
    unint64_t v4 = (void *)(a2 + 40);
    uint64_t v5 = 48 * v2;
    uint64_t v6 = *(void *)result + 40;
    do
    {
      *(v4 - 5) = *(void *)(v6 - 40);
      int v7 = *(_DWORD *)(v6 - 32);
      *((unsigned char *)v4 - 28) = *(unsigned char *)(v6 - 28);
      *((_DWORD *)v4 - 8) = v7;
      uint64_t v8 = *(void *)v6;
      if (*(void *)v6)
      {
        if (v6 - 24 == v8)
        {
          void *v4 = v4 - 3;
          uint64_t result = (unsigned int *)(*(uint64_t (**)(void))(**(void **)v6 + 24))();
        }
        else
        {
          void *v4 = v8;
          *(void *)uint64_t v6 = 0;
        }
      }
      else
      {
        void *v4 = 0;
      }
      v4 += 6;
      v6 += 48;
      v5 -= 48;
    }
    while (v5);
    uint64_t v9 = v3[2];
    if (v9)
    {
      uint64_t v10 = *(void *)v3;
      uint64_t v11 = 48 * v9;
      uint64_t v12 = v10 - 32;
      do
      {
        uint64_t result = *(unsigned int **)(v12 + v11 + 24);
        if ((unsigned int *)(v12 + v11) == result)
        {
          uint64_t result = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)(v12 + v11) + 32))(v12 + v11);
        }
        else if (result)
        {
          uint64_t result = (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(void *)result + 40))(result);
        }
        v11 -= 48;
      }
      while (v11);
    }
  }
  return result;
}

void llvm::DenseMap<mlir::OperationName,std::function<std::optional<BOOL> ()(mlir::Operation *)>,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,std::function<std::optional<BOOL> ()(mlir::Operation *)>>>::copyFrom(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 16);
  int v3 = *(llvm **)a1;
  if (v2)
  {
    unint64_t v4 = (void *)((char *)v3 + 8);
    uint64_t v5 = 40 * v2;
    do
    {
      if ((*(void *)v3 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v6 = (void *)*((void *)v3 + 4);
        if ((void *)((char *)v3 + 8) == v6)
        {
          (*(void (**)(void *))(*((void *)v3 + 1) + 32))((void *)v3 + 1);
        }
        else if (v6)
        {
          (*(void (**)(void *))(*v6 + 40))(v6);
        }
      }
      int v3 = (llvm *)((char *)v3 + 40);
      v4 += 5;
      v5 -= 40;
    }
    while (v5);
    int v3 = *(llvm **)a1;
    uint64_t v7 = 40 * *(unsigned int *)(a1 + 16);
  }
  else
  {
    uint64_t v7 = 0;
  }
  llvm::deallocate_buffer(v3, (void *)v7);
}

llvm::StringMapImpl *llvm::StringMap<mlir::ConversionTarget::LegalizationAction,llvm::MallocAllocator>::StringMap(llvm::StringMapImpl *this, uint64_t *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0x1000000000;
  if (*((_DWORD *)a2 + 3))
  {
    llvm::StringMapImpl::init(this, *((_DWORD *)a2 + 2));
    uint64_t v4 = *(void *)this;
    uint64_t v5 = *((unsigned int *)this + 2);
    uint64_t v6 = *a2;
    *(void *)((char *)this + 12) = *(uint64_t *)((char *)a2 + 12);
    if (v5)
    {
      uint64_t v7 = 0;
      uint64_t v8 = v4 + 8 * v5 + 8;
      uint64_t v9 = v6 + 8 * v5 + 8;
      do
      {
        uint64_t v10 = *(void *)(*a2 + 8 * v7);
        if (v10) {
          BOOL v11 = v10 == -8;
        }
        else {
          BOOL v11 = 1;
        }
        if (v11)
        {
          *(void *)(*(void *)this + 8 * v7) = v10;
        }
        else
        {
          size_t v12 = *(void *)v10;
          buffer = (char *)llvm::allocate_buffer(*(void *)v10 + 17, (std::align_val_t)8uLL);
          uint64_t v14 = buffer;
          uint64_t v15 = buffer + 16;
          if (v12) {
            memcpy(buffer + 16, (const void *)(v10 + 16), v12);
          }
          v15[v12] = 0;
          *(void *)uint64_t v14 = v12;
          int v16 = *(_DWORD *)(v10 + 8);
          *(void *)(*(void *)this + 8 * v7) = v14;
          *((_DWORD *)v14 + 2) = v16;
          *(_DWORD *)(v8 + 4 * v7) = *(_DWORD *)(v9 + 4 * v7);
        }
        ++v7;
      }
      while (v5 != v7);
    }
  }
  return this;
}

llvm::StringMapImpl *llvm::StringMap<std::function<std::optional<BOOL> ()(mlir::Operation *)>,llvm::MallocAllocator>::StringMap(llvm::StringMapImpl *this, uint64_t *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0x2800000000;
  if (*((_DWORD *)a2 + 3))
  {
    llvm::StringMapImpl::init(this, *((_DWORD *)a2 + 2));
    uint64_t v4 = *(void *)this;
    uint64_t v5 = *((unsigned int *)this + 2);
    uint64_t v6 = *a2;
    *(void *)((char *)this + 12) = *(uint64_t *)((char *)a2 + 12);
    if (v5)
    {
      uint64_t v7 = 0;
      uint64_t v19 = v4 + 8 * v5 + 8;
      uint64_t v8 = v6 + 8 * v5 + 8;
      do
      {
        uint64_t v9 = *(size_t **)(*a2 + 8 * v7);
        if (v9) {
          BOOL v10 = v9 + 1 == 0;
        }
        else {
          BOOL v10 = 1;
        }
        if (v10)
        {
          *(void *)(*(void *)this + 8 * v7) = v9;
        }
        else
        {
          size_t v12 = v9 + 1;
          size_t v11 = *v9;
          buffer = llvm::allocate_buffer(*v9 + 41, (std::align_val_t)8uLL);
          uint64_t v14 = buffer;
          uint64_t v15 = (char *)(buffer + 5);
          if (v11) {
            memcpy(buffer + 5, v9 + 5, v11);
          }
          v15[v11] = 0;
          *uint64_t v14 = v11;
          int v16 = v14 + 1;
          size_t v17 = v9[4];
          if (v17)
          {
            if ((size_t *)v17 == v12)
            {
              v14[4] = (size_t)v16;
              (*(void (**)(size_t *))(*v12 + 24))(v9 + 1);
            }
            else
            {
              v14[4] = (*(uint64_t (**)(size_t, void *))(*(void *)v17 + 16))(v17, v16);
            }
          }
          else
          {
            v14[4] = 0;
          }
          *(void *)(*(void *)this + 8 * v7) = v14;
          *(_DWORD *)(v19 + 4 * v7) = *(_DWORD *)(v8 + 4 * v7);
        }
        ++v7;
      }
      while (v5 != v7);
    }
  }
  return this;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::placement::RegionCall,mlir::Operation *&,mlir::placement::RegionType,mlir::ValueRange &>(mlir::MLIRContext **a1, uint64_t a2, mlir::SymbolRefAttr **a3, int *a4, uint64_t *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"placement.region_call", (const unsigned __int8 *)0x15, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"placement.region_call";
    void v19[3] = 21;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::placement::RegionCall::build(a1, (uint64_t)v21, *a3, *a4, *a5, a5[1]);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::placement::RegionCall,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

uint64_t mlir::RegionOpCreator::replaceOutOfRegionUses()
{
  return 1;
}

_OWORD *mlir::detail::FunctionOpInterfaceTrait<mlir::func::FuncOp>::addEntryBlock(mlir::func::FuncOp *a1)
{
  v19[6] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = operator new(0x48uLL);
  _OWORD *v2 = 0u;
  v2[1] = 0u;
  *((void *)v2 + 4) = v2 + 2;
  *((void *)v2 + 5) = v2 + 2;
  *((void *)v2 + 7) = 0;
  *((void *)v2 + 8) = 0;
  *((void *)v2 + 6) = 0;
  unint64_t v3 = *(unsigned int *)(*(void *)a1 + 44);
  if ((v3 & 0x7FFFFF) != 0) {
    uint64_t v4 = (uint64_t *)(((*(void *)a1 + 16 * ((v3 >> 23) & 1) + ((v3 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
  }
                   + 32 * *(unsigned int *)(*(void *)a1 + 40));
  else {
    uint64_t v4 = 0;
  }
  llvm::ilist_traits<mlir::Block>::addNodeToList((uint64_t)v4, (uint64_t)v2);
  uint64_t v5 = *v4;
  *((void *)v2 + 1) = *v4;
  *((void *)v2 + 2) = v4;
  *(void *)(v5 + 8) = (char *)v2 + 8;
  uint64_t *v4 = (uint64_t)v2 + 8;
  uint64_t FunctionType = (void *)mlir::func::FuncOp::getFunctionType(a1);
  uint64_t Inputs = mlir::FunctionType::getInputs((mlir::FunctionType *)&FunctionType);
  unint64_t v8 = v6;
  unint64_t v9 = *(void *)(*(void *)a1 + 24);
  uint64_t FunctionType = v19;
  uint64_t v18 = 0x600000000;
  if (v6 < 7)
  {
    if (v6)
    {
      v19[0] = v9;
      if (v6 != 1)
      {
        v19[1] = v9;
        if (v6 != 2)
        {
          unint64_t v19[2] = v9;
          if (v6 != 3)
          {
            void v19[3] = v9;
            if (v6 != 4)
            {
              uint64_t v19[4] = v9;
              if (v6 != 5) {
                v19[5] = v9;
              }
            }
          }
        }
      }
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&FunctionType, v19, v6, 8);
    BOOL v10 = (unint64_t *)((char *)FunctionType + 8 * (v8 & 0xFFFFFFFFFFFFFFFCLL));
    unint64_t v11 = v8 & 3;
    int64x2_t v12 = vdupq_n_s64(v9);
    uint64_t v13 = (int64x2_t *)((char *)FunctionType + 16);
    unint64_t v14 = v8 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v13[-1] = v12;
      *uint64_t v13 = v12;
      v13 += 2;
      v14 -= 4;
    }
    while (v14);
    if (v8 != (v8 & 0xFFFFFFFFFFFFFFFCLL))
    {
      do
      {
        *v10++ = v9;
        --v11;
      }
      while (v11);
    }
  }
  LODWORD(v18) = v8;
  mlir::ValueRange::ValueRange(v16, Inputs, v8);
  mlir::Block::addArguments(v2, v16[0], v16[1], (uint64_t)FunctionType, v18);
  if (FunctionType != v19) {
    free(FunctionType);
  }
  return v2;
}

void OUTLINED_FUNCTION_0_0(uint64_t a1@<X0>, const void ***a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  *(void *)a1 = a4;
  *(_WORD *)(a1 + 32) = 259;
  mlir::Operation::emitOpError(a3, a2, v4);
}

double mlir::mps::createRefineDynamicShapeInfoPass@<D0>(void *a1@<X8>)
{
  unint64_t v3 = operator new(0x178uLL);
  double result = 0.0;
  v3[2] = 0u;
  void v3[3] = 0u;
  v3[4] = 0u;
  v3[5] = 0u;
  v3[6] = 0u;
  v3[7] = 0u;
  v3[8] = 0u;
  v3[9] = 0u;
  v3[10] = 0u;
  v3[11] = 0u;
  v3[12] = 0u;
  v3[13] = 0u;
  v3[14] = 0u;
  v3[15] = 0u;
  v3[16] = 0u;
  v3[17] = 0u;
  v3[18] = 0u;
  v3[19] = 0u;
  v3[22] = 0u;
  *((void *)v3 + 46) = 0;
  *((void *)v3 + 2) = "func.func";
  *((void *)v3 + 3) = 9;
  *((unsigned char *)v3 + 32) = 1;
  v3[8] = 0u;
  v3[9] = 0u;
  v3[10] = 0u;
  *((void *)v3 + 22) = 0;
  *((void *)v3 + 23) = (char *)v3 + 200;
  *((_DWORD *)v3 + 49) = 4;
  *((void *)v3 + 29) = (char *)v3 + 248;
  *((_DWORD *)v3 + 61) = 4;
  *((void *)v3 + 35) = 0;
  *((void *)v3 + 36) = 0;
  *((void *)v3 + 37) = 0x1000000000;
  v3[19] = 0u;
  v3[20] = 0u;
  v3[20] = 0u;
  v3[21] = 0u;
  *((void *)v3 + 42) = 0;
  *((void *)v3 + 43) = 0;
  *(void *)unint64_t v3 = &unk_1EC9C89E8;
  *((void *)v3 + 44) = 0;
  *((void *)v3 + 45) = 0;
  *((_DWORD *)v3 + 92) = 0;
  *a1 = v3;
  return result;
}

void mlir::mps::anonymous namespace'::RefineDynamicShapes::~RefineDynamicShapes(llvm **this)
{
  *this = (llvm *)&unk_1EC9C89E8;
  llvm::deallocate_buffer(this[44], (void *)(16 * *((unsigned int *)this + 92)));
}

{
  *this = (llvm *)&unk_1EC9C89E8;
  llvm::deallocate_buffer(this[44], (void *)(16 * *((unsigned int *)this + 92)));
}

void sub_1805A58E4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  mlir::Pass::~Pass(v12);
}

void sub_1805A5948(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  mlir::Pass::~Pass(v12);
  operator delete(v13);
}

const char *mlir::mps::MPSRefineDynamicShapesBase<mlir::mps::anonymous namespace'::RefineDynamicShapes>::getName()
{
  return "MPSRefineDynamicShapes";
}

const char *mlir::mps::MPSRefineDynamicShapesBase<mlir::mps::anonymous namespace'::RefineDynamicShapes>::getArgument()
{
  return "mps-refine-dynamic-shapes";
}

const char *mlir::mps::MPSRefineDynamicShapesBase<mlir::mps::anonymous namespace'::RefineDynamicShapes>::getDescription()
{
  return "Refine dynamic shape info to enable more stitching";
}

uint64_t mlir::mps::anonymous namespace'::RefineDynamicShapes::runOnOperation(mlir::mps::_anonymous_namespace_::RefineDynamicShapes *this)
{
  uint64_t v2 = (unsigned int *)(*((void *)this + 5) & 0xFFFFFFFFFFFFFFF8);
  unint64_t v3 = v2[11];
  if ((v3 & 0x7FFFFF) != 0) {
    uint64_t v4 = (void *)((((unint64_t)&v2[4 * ((v3 >> 23) & 1) + 16] + ((v3 >> 21) & 0x7F8)) & 0xFFFFFFFFFFFFFFF8)
  }
                  + 32 * v2[10]);
  else {
    uint64_t v4 = 0;
  }
  if ((void *)*v4 != v4)
  {
    uint64_t v5 = v4[1];
    uint64_t v6 = v5 ? v5 - 8 : 0;
    uint64_t v7 = *(uint64_t **)(v6 + 48);
    unint64_t v8 = *(uint64_t **)(v6 + 56);
    if (v8 != v7)
    {
      while (1)
      {
        uint64_t v16 = *v7;
        v28[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(*v7 + 8) & 0xFFFFFFFFFFFFFFF8));
        v28[1] = v17;
        if (!v28[0]) {
          goto LABEL_13;
        }
        if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v28))
        {
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v28);
          if (!v19) {
            goto LABEL_13;
          }
          uint64_t v20 = 8 * v19;
          while (*ArgAttrsAttr != 0x8000000000000000)
          {
            ++ArgAttrsAttr;
            v20 -= 8;
            if (!v20) {
              goto LABEL_13;
            }
          }
        }
        uint64_t v9 = *((void *)this + 43);
        *((void *)this + 43) = v9 + 1;
        uint64_t v27 = v16;
        int v10 = *((_DWORD *)this + 92);
        if (!v10) {
          break;
        }
        uint64_t v11 = *((void *)this + 44);
        int v12 = v10 - 1;
        unsigned int v13 = v12 & ((v16 >> 4) ^ (v16 >> 9));
        inserted = (uint64_t *)(v11 + 16 * v13);
        uint64_t v15 = *inserted;
        if (*inserted != v16)
        {
          uint64_t v22 = 0;
          int v23 = 1;
          while (v15 != -4096)
          {
            if (v22) {
              BOOL v24 = 0;
            }
            else {
              BOOL v24 = v15 == -8192;
            }
            if (v24) {
              uint64_t v22 = inserted;
            }
            unsigned int v25 = v13 + v23++;
            unsigned int v13 = v25 & v12;
            inserted = (uint64_t *)(v11 + 16 * v13);
            uint64_t v15 = *inserted;
            if (*inserted == v16) {
              goto LABEL_12;
            }
          }
          if (v22) {
            uint64_t v21 = v22;
          }
          else {
            uint64_t v21 = inserted;
          }
          goto LABEL_22;
        }
LABEL_12:
        inserted[1] = v9;
LABEL_13:
        if (++v7 == v8) {
          goto LABEL_35;
        }
      }
      uint64_t v21 = 0;
LABEL_22:
      inserted = llvm::DenseMapBase<llvm::DenseMap<void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>,void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>::InsertIntoBucket<void *>((uint64_t)this + 352, v21, &v27);
      goto LABEL_12;
    }
  }
LABEL_35:
  v28[0] = this;
}

double mlir::mps::MPSRefineDynamicShapesBase<mlir::mps::anonymous namespace'::RefineDynamicShapes>::clonePass@<D0>(void *a1@<X8>)
{
  uint64_t v2 = operator new(0x178uLL);
  v2[2] = "func.func";
  v2[3] = 9;
  *((unsigned char *)v2 + 32) = 1;
  *((unsigned char *)v2 + 40) = 0;
  *((unsigned char *)v2 + 120) = 0;
  double result = 0.0;
  *((_OWORD *)v2 + 8) = 0u;
  *((_OWORD *)v2 + 9) = 0u;
  *((_OWORD *)v2 + 10) = 0u;
  v2[22] = 0;
  v2[23] = v2 + 25;
  v2[24] = 0x400000000;
  v2[29] = v2 + 31;
  v2[30] = 0x400000000;
  v2[35] = 0;
  v2[36] = 0;
  v2[37] = 0x1000000000;
  v2[42] = 0;
  v2[43] = 0;
  *((_OWORD *)v2 + 19) = 0u;
  *((_OWORD *)v2 + 20) = 0u;
  void *v2 = &unk_1EC9C89E8;
  v2[44] = 0;
  v2[45] = 0;
  *((_DWORD *)v2 + 92) = 0;
  *a1 = v2;
  return result;
}

uint64_t *llvm::DenseMapBase<llvm::DenseMap<void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>,void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>::InsertIntoBucket<void *>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
LABEL_3:
    uint64_t v8 = *a2;
    goto LABEL_4;
  }
  llvm::DenseMap<void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>::grow(a1, v7);
  uint64_t v8 = *a3;
  int v10 = *(_DWORD *)(a1 + 16) - 1;
  unsigned int v11 = ((*a3 >> 4) ^ (*a3 >> 9)) & v10;
  a2 = (uint64_t *)(*(void *)a1 + 16 * v11);
  uint64_t v12 = *a2;
  if (*a3 != *a2)
  {
    unsigned int v13 = 0;
    int v14 = 1;
    while (v12 != -4096)
    {
      if (v13) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v12 == -8192;
      }
      if (v15) {
        unsigned int v13 = a2;
      }
      unsigned int v16 = v11 + v14++;
      unsigned int v11 = v16 & v10;
      a2 = (uint64_t *)(*(void *)a1 + 16 * (v16 & v10));
      uint64_t v12 = *a2;
      if (v8 == *a2) {
        goto LABEL_4;
      }
    }
    if (v13) {
      a2 = v13;
    }
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v8 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  *a2 = *a3;
  a2[1] = 0;
  return a2;
}

void *llvm::DenseMap<void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  double result = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  int v10 = result;
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v11 = *(unsigned int *)(a1 + 16);
    if (v11)
    {
      if (((v11 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0) {
        goto LABEL_41;
      }
      uint64_t v12 = ((v11 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
      int v10 = &result[2 * (v12 & 0x1FFFFFFFFFFFFFFELL)];
      unsigned int v13 = result + 2;
      uint64_t v14 = v12 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        *(v13 - 2) = -4096;
        *unsigned int v13 = -4096;
        v13 += 4;
        v14 -= 2;
      }
      while (v14);
      if (v12 != (v12 & 0x1FFFFFFFFFFFFFFELL))
      {
LABEL_41:
        do
        {
          void *v10 = -4096;
          v10 += 2;
        }
        while (v10 != &result[2 * v11]);
      }
    }
    if (v3)
    {
      int v15 = 0;
      int v16 = v11 - 1;
      uint64_t v17 = v4;
      do
      {
        uint64_t v25 = *(void *)v17;
        if ((*(void *)v17 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          unsigned int v26 = ((v25 >> 4) ^ (v25 >> 9)) & v16;
          int v23 = (void *)(*(void *)a1 + 16 * v26);
          uint64_t v27 = *v23;
          if (v25 != *v23)
          {
            int v28 = 0;
            int v29 = 1;
            while (v27 != -4096)
            {
              if (v28) {
                BOOL v30 = 0;
              }
              else {
                BOOL v30 = v27 == -8192;
              }
              if (v30) {
                int v28 = v23;
              }
              unsigned int v31 = v26 + v29++;
              unsigned int v26 = v31 & v16;
              int v23 = (void *)(*(void *)a1 + 16 * (v31 & v16));
              uint64_t v27 = *v23;
              if (v25 == *v23) {
                goto LABEL_23;
              }
            }
            if (v28) {
              int v23 = v28;
            }
          }
LABEL_23:
          uint64_t v24 = *((void *)v17 + 1);
          *int v23 = v25;
          v23[1] = v24;
          *(_DWORD *)(a1 + 8) = ++v15;
        }
        uint64_t v17 = (llvm *)((char *)v17 + 16);
      }
      while (v17 != (llvm *)((char *)v4 + 16 * v3));
    }
    llvm::deallocate_buffer(v4, (void *)(16 * v3));
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v18 = *(unsigned int *)(a1 + 16);
  if (v18)
  {
    if (((v18 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0) {
      goto LABEL_18;
    }
    uint64_t v19 = ((v18 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
    int v10 = &result[2 * (v19 & 0x1FFFFFFFFFFFFFFELL)];
    uint64_t v20 = result + 2;
    uint64_t v21 = v19 & 0x1FFFFFFFFFFFFFFELL;
    do
    {
      *(v20 - 2) = -4096;
      *uint64_t v20 = -4096;
      v20 += 4;
      v21 -= 2;
    }
    while (v21);
    if (v19 != (v19 & 0x1FFFFFFFFFFFFFFELL))
    {
LABEL_18:
      uint64_t v22 = &result[2 * v18];
      do
      {
        void *v10 = -4096;
        v10 += 2;
      }
      while (v10 != v22);
    }
  }
  return result;
}

uint64_t llvm::function_ref<mlir::WalkResult ()(mlir::Operation *)>::callback_fn<mlir::mps::anonymous namespace'::RefineDynamicShapes::runOnOperation(void)::$_0>(uint64_t *a1, uint64_t a2)
{
  v110[8] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(unsigned int *)(a2 + 36);
  uint64_t v3 = a2 - 16;
  if (v2) {
    uint64_t v4 = a2 - 16;
  }
  else {
    uint64_t v4 = 0;
  }
  if (!v2) {
    return 1;
  }
  uint64_t v6 = 0;
  uint64_t v7 = *a1;
  uint64_t v8 = v2 - 1;
  do
  {
    uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, v6);
    if (hasDynamicShapes) {
      break;
    }
    BOOL v30 = v8 == v6++;
  }
  while (!v30);
  if (!hasDynamicShapes) {
    return 1;
  }
  if ((*(unsigned char *)(a2 + 46) & 0x80) != 0 && (uint64_t v11 = *(unsigned int *)(a2 + 68), v11))
  {
    uint64_t v12 = 0;
    unsigned int v13 = (uint64_t *)(*(void *)(a2 + 72) + 24);
    do
    {
      uint64_t v14 = *v13;
      v13 += 4;
      --v11;
    }
    while (v11);
  }
  else
  {
    uint64_t v12 = 0;
  }
  if (!mlir::OpInterface<mlir::MapDynamicShapeOpInterface,mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits>::getInterfaceFor(a2))
  {
    uint64_t v104 = 0;
    uint64_t v105 = 0;
LABEL_20:
    uint64_t v16 = *(unsigned int *)(a2 + 36);
    if (v16) {
      uint64_t v17 = v3;
    }
    else {
      uint64_t v17 = 0;
    }
    if (!v16) {
      return 1;
    }
    uint64_t v18 = 0;
    while (1)
    {
      uint64_t v24 = (void *)mlir::detail::OpResultImpl::getNextResultAtOffset(v17, v18);
        goto LABEL_27;
      uint64_t v25 = *(void *)(v7 + 344);
      *(void *)(v7 + 344) = v25 + 1;
      unint64_t v108 = v24;
      int v26 = *(_DWORD *)(v7 + 368);
      if (!v26) {
        break;
      }
      uint64_t v19 = *(void *)(v7 + 352);
      int v20 = v26 - 1;
      unsigned int v21 = v20 & ((v24 >> 4) ^ (v24 >> 9));
      inserted = (uint64_t *)(v19 + 16 * v21);
      uint64_t v23 = *inserted;
      if (v24 != (void *)*inserted)
      {
        int v28 = 0;
        int v29 = 1;
        while (v23 != -4096)
        {
          if (v28) {
            BOOL v30 = 0;
          }
          else {
            BOOL v30 = v23 == -8192;
          }
          if (v30) {
            int v28 = inserted;
          }
          unsigned int v31 = v21 + v29++;
          unsigned int v21 = v31 & v20;
          inserted = (uint64_t *)(v19 + 16 * v21);
          uint64_t v23 = *inserted;
          if (v24 == (void *)*inserted) {
            goto LABEL_26;
          }
        }
        if (v28) {
          uint64_t v27 = v28;
        }
        else {
          uint64_t v27 = inserted;
        }
        goto LABEL_31;
      }
LABEL_26:
      inserted[1] = v25;
LABEL_27:
      if (++v18 == v16) {
        return 1;
      }
    }
    uint64_t v27 = 0;
LABEL_31:
    inserted = llvm::DenseMapBase<llvm::DenseMap<void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>,void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>::InsertIntoBucket<void *>(v7 + 352, v27, (uint64_t *)&v108);
    goto LABEL_26;
  }
  if (a2) {
    uint64_t InterfaceFor = mlir::OpInterface<mlir::MapDynamicShapeOpInterface,mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits>::getInterfaceFor(a2);
  }
  else {
    uint64_t InterfaceFor = 0;
  }
  uint64_t v104 = a2;
  uint64_t v105 = InterfaceFor;
  if (!a2) {
    goto LABEL_20;
  }
  mlir::MapDynamicShapeOpInterface::mapDynamicShape((uint64_t *)&v108, (mlir::MapDynamicShapeOpInterface *)&v104);
  int v32 = *(_DWORD *)(a2 + 36);
  if (v32) {
    uint64_t v33 = (mlir::detail::OpResultImpl *)v3;
  }
  else {
    uint64_t v33 = 0;
  }
  uint64_t v101 = v33;
  uint64_t v102 = *(unsigned int *)(a2 + 36);
  uint64_t v34 = (char *)v108;
  unsigned int v35 = v109;
  if (v32 && v109)
  {
    uint64_t v36 = 0;
    uint64_t v103 = v7 + 352;
    uint64_t v100 = (char *)v108 + 64 * (unint64_t)v109;
    while (1)
    {
      uint64_t v37 = mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v101, v36);
      uint64_t v38 = *((unsigned int *)v34 + 2);
      if (!v38) {
        goto LABEL_124;
      }
      uint64_t v39 = v37;
      uint64_t v40 = *(void **)v34;
      uint64_t v41 = *(void *)v34 + 8 * v38;
      uint64_t v42 = -1;
      while (*v40 != -1)
      {
        uint64_t v43 = *(void *)(*(void *)(a2 + 72) + 32 * *v40 + 24);
          goto LABEL_55;
        v106[0] = v43;
        int v44 = *(_DWORD *)(v7 + 368);
        if (v44)
        {
          uint64_t v45 = *(void *)(v7 + 352);
          int v46 = v44 - 1;
          unsigned int v47 = v46 & ((v43 >> 4) ^ (v43 >> 9));
          uint64_t v48 = (uint64_t *)(v45 + 16 * v47);
          uint64_t v49 = *v48;
          if (v43 == *v48) {
            goto LABEL_71;
          }
          unint64_t v50 = 0;
          int v51 = 1;
          while (v49 != -4096)
          {
            if (v50) {
              BOOL v52 = 0;
            }
            else {
              BOOL v52 = v49 == -8192;
            }
            if (v52) {
              unint64_t v50 = v48;
            }
            unsigned int v53 = v47 + v51++;
            unsigned int v47 = v53 & v46;
            uint64_t v48 = (uint64_t *)(v45 + 16 * v47);
            uint64_t v49 = *v48;
            if (v43 == *v48) {
              goto LABEL_71;
            }
          }
          if (v50) {
            uint64_t v54 = v50;
          }
          else {
            uint64_t v54 = v48;
          }
        }
        else
        {
          uint64_t v54 = 0;
        }
        uint64_t v48 = llvm::DenseMapBase<llvm::DenseMap<void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>,void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>::InsertIntoBucket<void *>(v103, v54, v106);
LABEL_71:
        if (v42 == -1)
        {
          uint64_t v42 = v48[1];
        }
        else if (v42 != v48[1])
        {
          uint64_t v85 = *(void *)(v7 + 344);
          *(void *)(v7 + 344) = v85 + 1;
          v106[0] = v39;
          int v86 = *(_DWORD *)(v7 + 368);
          if (v86)
          {
            uint64_t v87 = *(void *)(v7 + 352);
            int v88 = v86 - 1;
            unsigned int v89 = v88 & ((v39 >> 4) ^ (v39 >> 9));
            uint64x2_t v90 = (uint64_t *)(v87 + 16 * v89);
            uint64_t v91 = *v90;
            if (v39 != *v90)
            {
              uint64_t v92 = 0;
              int v93 = 1;
              while (v91 != -4096)
              {
                if (v92) {
                  BOOL v94 = 0;
                }
                else {
                  BOOL v94 = v91 == -8192;
                }
                if (v94) {
                  uint64_t v92 = v90;
                }
                unsigned int v95 = v89 + v93++;
                unsigned int v89 = v95 & v88;
                uint64x2_t v90 = (uint64_t *)(v87 + 16 * v89);
                uint64_t v91 = *v90;
                if (v39 == *v90) {
                  goto LABEL_123;
                }
              }
              if (v92) {
                uint64_t v96 = v92;
              }
              else {
                uint64_t v96 = v90;
              }
LABEL_122:
              uint64x2_t v90 = llvm::DenseMapBase<llvm::DenseMap<void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>,void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>::InsertIntoBucket<void *>(v103, v96, v106);
            }
LABEL_123:
            v90[1] = v85;
            goto LABEL_124;
          }
          uint64_t v96 = 0;
          goto LABEL_122;
        }
LABEL_55:
        if (++v40 == (void *)v41) {
          goto LABEL_91;
        }
      }
      uint64_t v55 = *(void *)(v7 + 344);
      *(void *)(v7 + 344) = v55 + 1;
      v106[0] = v39;
      int v56 = *(_DWORD *)(v7 + 368);
      if (!v56)
      {
        uint64_t v66 = 0;
        goto LABEL_89;
      }
      uint64_t v57 = *(void *)(v7 + 352);
      int v58 = v56 - 1;
      unsigned int v59 = v58 & ((v39 >> 4) ^ (v39 >> 9));
      uint64_t v60 = (uint64_t *)(v57 + 16 * v59);
      uint64_t v61 = *v60;
      if (v39 != *v60)
      {
        uint64_t v62 = 0;
        int v63 = 1;
        while (v61 != -4096)
        {
          if (v62) {
            BOOL v64 = 0;
          }
          else {
            BOOL v64 = v61 == -8192;
          }
          if (v64) {
            uint64_t v62 = v60;
          }
          unsigned int v65 = v59 + v63++;
          unsigned int v59 = v65 & v58;
          uint64_t v60 = (uint64_t *)(v57 + 16 * v59);
          uint64_t v61 = *v60;
          if (v39 == *v60) {
            goto LABEL_90;
          }
        }
        if (v62) {
          uint64_t v66 = v62;
        }
        else {
          uint64_t v66 = v60;
        }
LABEL_89:
        uint64_t v60 = llvm::DenseMapBase<llvm::DenseMap<void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>,void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>::InsertIntoBucket<void *>(v103, v66, v106);
      }
LABEL_90:
      v60[1] = v55;
LABEL_91:
      if (v42 == -1) {
        goto LABEL_124;
      }
      v106[0] = v39;
      int v67 = *(_DWORD *)(v7 + 368);
      if (!v67)
      {
        unint64_t v77 = 0;
        goto LABEL_104;
      }
      uint64_t v68 = *(void *)(v7 + 352);
      int v69 = v67 - 1;
      unsigned int v70 = v69 & ((v39 >> 4) ^ (v39 >> 9));
      unint64_t v71 = (uint64_t *)(v68 + 16 * v70);
      uint64_t v72 = *v71;
      if (v39 != *v71)
      {
        unint64_t v73 = 0;
        int v74 = 1;
        while (v72 != -4096)
        {
          if (v73) {
            BOOL v75 = 0;
          }
          else {
            BOOL v75 = v72 == -8192;
          }
          if (v75) {
            unint64_t v73 = v71;
          }
          unsigned int v76 = v70 + v74++;
          unsigned int v70 = v76 & v69;
          unint64_t v71 = (uint64_t *)(v68 + 16 * v70);
          uint64_t v72 = *v71;
          if (v39 == *v71) {
            goto LABEL_105;
          }
        }
        if (v73) {
          unint64_t v77 = v73;
        }
        else {
          unint64_t v77 = v71;
        }
LABEL_104:
        unint64_t v71 = llvm::DenseMapBase<llvm::DenseMap<void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>,void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>::InsertIntoBucket<void *>(v103, v77, v106);
      }
LABEL_105:
      v71[1] = v42;
      uint64_t v78 = mlir::TypeID::get<mlir::OpTrait::ResultsBroadcastableShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ResultsBroadcastableShape>(void)::Empty>>();
      if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 48) + 32))(*(void *)(a2 + 48), v78)) {
        BOOL v79 = v12 < 2;
      }
      else {
        BOOL v79 = 1;
      }
      if (!v79)
      {
        uint64_t Context = (mlir::UnitAttr *)mlir::Attribute::getContext((mlir::Attribute *)((*(void *)(v7 + 40) & 0xFFFFFFFFFFFFFFF8)
                                                                                  + 24));
        uint64_t v82 = mlir::UnitAttr::get(Context, v81);
        char v83 = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
        __int16 v107 = 261;
        v106[0] = (uint64_t)"__no_dynamic_broadcast";
        v106[1] = 22;
        uint64_t v84 = mlir::StringAttr::get(v83, (mlir::MLIRContext *)v106);
        mlir::Operation::setAttr(a2, v84, v82);
      }
LABEL_124:
      if (++v36 != v102)
      {
        v34 += 64;
        if (v34 != v100) {
          continue;
        }
      }
      uint64_t v34 = (char *)v108;
      unsigned int v35 = v109;
      break;
    }
  }
  if (v35)
  {
    unint64_t v97 = (unint64_t)v35 << 6;
    do
    {
      uint64_t v98 = *(char **)&v34[v97 - 64];
      if (&v34[v97 - 48] != v98) {
        free(v98);
      }
      v97 -= 64;
    }
    while (v97);
    uint64_t v34 = (char *)v108;
  }
  if (v34 != (char *)v110) {
    free(v34);
  }
  return 1;
}

uint64_t mlir::mps::anonymous namespace'::hasDynamicShapes(uint64_t a1)
{
  for (unint64_t i = (uint64_t *)(*(void *)(a1 + 8) & 0xFFFFFFFFFFFFFFF8); i; unint64_t i = (uint64_t *)i[1])
  {
    uint64_t v2 = *(void *)(*i + 136);
    if (v2 != mlir::TypeID::get<mlir::mpsx::ListType>()) {
      break;
    }
  }
  uint64_t v4 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible(i);
  v12[0] = v4;
  v12[1] = v5;
  if (v4)
  {
    if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v12)) {
      goto LABEL_16;
    }
    if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v12))
    {
      BOOL v3 = 1;
      return (v4 != 0) & v3;
    }
    uint64_t ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v12);
    if (v7)
    {
      uint64_t v8 = 8 * v7 - 8;
      do
      {
        uint64_t v9 = *ArgAttrsAttr++;
        BOOL v3 = v9 == 0x8000000000000000;
        BOOL v10 = v9 == 0x8000000000000000 || v8 == 0;
        v8 -= 8;
      }
      while (!v10);
    }
    else
    {
LABEL_16:
      BOOL v3 = 0;
    }
  }
  return (v4 != 0) & v3;
}

uint64_t mlir::OpInterface<mlir::MapDynamicShapeOpInterface,mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits>::getInterfaceFor(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  BOOL v3 = v2 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 48);
  }
  if (v3)
  {
    uint64_t v22 = *(void *)(v1 + 8);
    uint64_t result = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v22);
    if (result)
    {
      uint64_t v20 = result;
      uint64_t v21 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v20 + 104))(v20, v21, v1);
    }
  }
  else
  {
    unint64_t v6 = v4 | v1 & 0xFFFFFFFFFFFFFF00;
    unint64_t v7 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
    unint64_t v8 = *(unsigned int *)(v6 + 40);
    if (!v8) {
      goto LABEL_14;
    }
    uint64_t v9 = *(void **)(v6 + 32);
    BOOL v10 = &v9[2 * v8];
    do
    {
      unint64_t v11 = v8 >> 1;
      uint64_t v12 = &v9[2 * (v8 >> 1)];
      unint64_t v14 = *v12;
      unsigned int v13 = v12 + 2;
      v8 += ~(v8 >> 1);
      if (v14 < v7) {
        uint64_t v9 = v13;
      }
      else {
        unint64_t v8 = v11;
      }
    }
    while (v8);
    if (v9 == v10 || *v9 != v7 || (uint64_t result = v9[1]) == 0)
    {
LABEL_14:
      uint64_t v16 = *(void *)(v6 + 24);
      uint64_t v17 = *(void *)(a1 + 48);
      uint64_t v18 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
      uint64_t v19 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v16 + 104);
      return v19(v16, v18, v17);
    }
  }
  return result;
}

uint64_t mlir::TypeID::get<mlir::mpsx::ListType>()
{
  unint64_t v0 = 0x1E8EB8000uLL;
  {
    unint64_t v0 = 0x1E8EB8000;
    if (v2)
    {
      BOOL v10 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mpsx::ListType]";
      unint64_t v11 = 70;
      unint64_t v3 = llvm::StringRef::find((uint64_t *)&v10, "DesiredTypeName = ", 0x12uLL, 0);
      if (v11 >= v3) {
        unint64_t v4 = v3;
      }
      else {
        unint64_t v4 = v11;
      }
      uint64_t v5 = &v10[v4];
      unint64_t v6 = v11 - v4;
      if (v11 - v4 >= 0x12) {
        uint64_t v7 = 18;
      }
      else {
        uint64_t v7 = v11 - v4;
      }
      unint64_t v8 = v6 - v7;
      if (v8 >= v8 - 1) {
        uint64_t v9 = v8 - 1;
      }
      else {
        uint64_t v9 = v8;
      }
      mlir::detail::TypeIDResolver<mlir::mpsx::ListType,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v5[v7], v9);
      unint64_t v0 = 0x1E8EB8000;
    }
  }
  return *(void *)(v0 + 2024);
}

uint64_t mlir::TypeID::get<mlir::OpTrait::ResultsBroadcastableShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ResultsBroadcastableShape>(void)::Empty>>()
{
  unint64_t v0 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    unint64_t v0 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    if (v2)
    {
      BOOL v10 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ResultsBroadcastableShape<Empty>]";
      unint64_t v11 = 97;
      unint64_t v3 = llvm::StringRef::find((uint64_t *)&v10, "DesiredTypeName = ", 0x12uLL, 0);
      if (v11 >= v3) {
        unint64_t v4 = v3;
      }
      else {
        unint64_t v4 = v11;
      }
      uint64_t v5 = &v10[v4];
      unint64_t v6 = v11 - v4;
      if (v11 - v4 >= 0x12) {
        uint64_t v7 = 18;
      }
      else {
        uint64_t v7 = v11 - v4;
      }
      unint64_t v8 = v6 - v7;
      if (v8 >= v8 - 1) {
        uint64_t v9 = v8 - 1;
      }
      else {
        uint64_t v9 = v8;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ResultsBroadcastableShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ResultsBroadcastableShape>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v5[v7], v9);
      unint64_t v0 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    }
  }
  return v0[20];
}

uint64_t mlir::mps::createRuntimeCanonicalizationPass@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  unint64_t v4 = operator new(0x568uLL);
  *(void *)uint64_t v5 = &unk_1EC9C9D70;
  *(unsigned char *)(v5 + 472) = *(unsigned char *)a1;
  uint64_t v6 = *(void *)(v5 + 528);
  if (!v6) {
    goto LABEL_7;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 48))(v6, a1);
  v4[680] = *(unsigned char *)(a1 + 1);
  uint64_t v7 = *((void *)v4 + 92);
  if (!v7) {
    goto LABEL_7;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 48))(v7, a1 + 1);
  *((_DWORD *)v4 + 222) = *(_DWORD *)(a1 + 4);
  uint64_t v8 = *((void *)v4 + 118);
  if (!v8) {
    goto LABEL_7;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 48))(v8, a1 + 4);
  v4[1096] = *(unsigned char *)(a1 + 8);
  uint64_t v9 = *((void *)v4 + 144);
  if (!v9) {
    goto LABEL_7;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v9 + 48))(v9, a1 + 8);
  char v11 = *(unsigned char *)(a1 + 9);
  uint64_t v10 = a1 + 9;
  v4[1304] = v11;
  uint64_t v12 = *((void *)v4 + 170);
  if (v12)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 48))(v12, v10);
    *a2 = v4;
  }
  else
  {
LABEL_7:
    uint64_t v14 = std::__throw_bad_function_call[abi:nn180100]();
  }
  return result;
}

uint64_t mlir::mps::MPSRuntimeCanonicalizationBase<mlir::mps::anonymous namespace'::RuntimeCanonicalizationPass>::MPSRuntimeCanonicalizationBase(uint64_t a1)
{
  *(void *)(a1 + 16) = "func.func";
  *(void *)(a1 + 24) = 9;
  *(unsigned char *)(a1 + 32) = 1;
  *(unsigned char *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 120) = 0;
  int v2 = (void *)(a1 + 152);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = a1 + 200;
  *(void *)(a1 + 192) = 0x400000000;
  *(void *)(a1 + 232) = a1 + 248;
  *(void *)(a1 + 240) = 0x400000000;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 296) = 0x1000000000;
  *(void *)(a1 + 336) = 0;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(void *)a1 = &unk_1EC9CA9F0;
  v6.n128_u64[0] = (unint64_t)"Enables the folding of a matmul RHS input, where RHS is a transpose of a constant.";
  v6.n128_u64[1] = 82;
  LOBYTE(v4) = 0;
  uint64_t v5 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 344), (void *)(a1 + 152), (uint64_t)"enable-matmul-nt-to-nn-fold", 27, &v6, (unsigned char **)&v5);
  *(void *)(a1 + 344) = &unk_1EC9CB060;
  *(void *)(a1 + 536) = &unk_1EC9CB0E0;
  v6.n128_u64[0] = (unint64_t)"Use legacy quantization patterns";
  v6.n128_u64[1] = 32;
  LOBYTE(v4) = 1;
  uint64_t v5 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 552), v2, (uint64_t)"legacy-quantization", 19, &v6, (unsigned char **)&v5);
  *(void *)(a1 + 552) = &unk_1EC9CB060;
  *(void *)(a1 + 744) = &unk_1EC9CB0E0;
  v6.n128_u64[0] = (unint64_t)"Maximum number of inputs supported by MPS quantization kernels.";
  v6.n128_u64[1] = 63;
  int v4 = 32;
  uint64_t v5 = &v4;
  mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::initializer<int>>((void *)(a1 + 760), v2, (uint64_t)"quant-ops-max-inputs-count", 26, &v6, &v5);
  *(void *)(a1 + 760) = &unk_1EC9CB120;
  *(void *)(a1 + 952) = &unk_1EC9CB1A0;
  v6.n128_u64[0] = (unint64_t)"Enables the canonicalization of 2D (de)convolutions to matmuls.";
  v6.n128_u64[1] = 63;
  LOBYTE(v4) = 0;
  uint64_t v5 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 968), v2, (uint64_t)"enable-conv2d-to-matmul", 23, &v6, (unsigned char **)&v5);
  *(void *)(a1 + 968) = &unk_1EC9CB060;
  *(void *)(a1 + 1160) = &unk_1EC9CB0E0;
  v6.n128_u64[0] = (unint64_t)"Enables the canonicalization of reshaped convolutions to matmuls.";
  v6.n128_u64[1] = 65;
  LOBYTE(v4) = 0;
  uint64_t v5 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 1176), v2, (uint64_t)"enable-reshape-conv2d-biasadd-reshape", 37, &v6, (unsigned char **)&v5);
  *(void *)(a1 + 1176) = &unk_1EC9CB060;
  *(void *)(a1 + 1368) = &unk_1EC9CB0E0;
  return a1;
}

void mlir::mps::anonymous namespace'::RuntimeCanonicalizationPass::~RuntimeCanonicalizationPass(mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *this)
{
  *(void *)this = &unk_1EC9CA9F0;
  *((void *)this + 147) = &unk_1EC9A3F00;
  int v2 = (char *)this + 1336;
  unint64_t v3 = (char *)*((void *)this + 170);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  *((void *)this + 147) = &unk_1EC9A42A8;
  int v4 = (void *)*((void *)this + 159);
  if (v4 != *((void **)this + 158)) {
    free(v4);
  }
  uint64_t v5 = (char *)*((void *)this + 155);
  if (v5 != (char *)this + 1256) {
    free(v5);
  }
  *((void *)this + 121) = &unk_1EC9A3F00;
  __n128 v6 = (mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *)*((void *)this + 144);
  if (v6 == (mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *)((char *)this + 1128))
  {
    (*(void (**)(char *))(*((void *)this + 141) + 32))((char *)this + 1128);
  }
  else if (v6)
  {
    (*(void (**)(mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *))(*(void *)v6 + 40))(v6);
  }
  *((void *)this + 121) = &unk_1EC9A42A8;
  uint64_t v7 = (void *)*((void *)this + 133);
  if (v7 != *((void **)this + 132)) {
    free(v7);
  }
  uint64_t v8 = (char *)*((void *)this + 129);
  if (v8 != (char *)this + 1048) {
    free(v8);
  }
  *((void *)this + 95) = &unk_1EC9A3FD0;
  uint64_t v9 = (mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *)*((void *)this + 118);
  if (v9 == (mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *)((char *)this + 920))
  {
    (*(void (**)(char *))(*((void *)this + 115) + 32))((char *)this + 920);
  }
  else if (v9)
  {
    (*(void (**)(mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *))(*(void *)v9 + 40))(v9);
  }
  *((void *)this + 95) = &unk_1EC9A42A8;
  uint64_t v10 = (void *)*((void *)this + 107);
  if (v10 != *((void **)this + 106)) {
    free(v10);
  }
  char v11 = (char *)*((void *)this + 103);
  if (v11 != (char *)this + 840) {
    free(v11);
  }
  *((void *)this + 69) = &unk_1EC9A3F00;
  uint64_t v12 = (mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *)*((void *)this + 92);
  if (v12 == (mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *)((char *)this + 712))
  {
    (*(void (**)(char *))(*((void *)this + 89) + 32))((char *)this + 712);
  }
  else if (v12)
  {
    (*(void (**)(mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *))(*(void *)v12 + 40))(v12);
  }
  *((void *)this + 69) = &unk_1EC9A42A8;
  unsigned int v13 = (void *)*((void *)this + 81);
  if (v13 != *((void **)this + 80)) {
    free(v13);
  }
  uint64_t v14 = (char *)*((void *)this + 77);
  if (v14 != (char *)this + 632) {
    free(v14);
  }
  *((void *)this + 43) = &unk_1EC9A3F00;
  int v15 = (mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *)*((void *)this + 66);
  if (v15 == (mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *)((char *)this + 504))
  {
    (*(void (**)(char *))(*((void *)this + 63) + 32))((char *)this + 504);
  }
  else if (v15)
  {
    (*(void (**)(mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *))(*(void *)v15 + 40))(v15);
  }
  *((void *)this + 43) = &unk_1EC9A42A8;
  uint64_t v16 = (void *)*((void *)this + 55);
  if (v16 != *((void **)this + 54)) {
    free(v16);
  }
  uint64_t v17 = (char *)*((void *)this + 51);
  if (v17 != (char *)this + 424) {
    free(v17);
  }

  mlir::Pass::~Pass(this);
}

{
  void *v1;
  uint64_t vars8;

  operator delete(v1);
}

const char *mlir::mps::MPSRuntimeCanonicalizationBase<mlir::mps::anonymous namespace'::RuntimeCanonicalizationPass>::getName()
{
  return "MPSRuntimeCanonicalization";
}

void *mlir::mps::MPSRuntimeCanonicalizationBase<mlir::mps::anonymous namespace'::RuntimeCanonicalizationPass>::getDependentDialects(int a1, uint64_t **a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  v3[0] = &unk_1EC9CF000;
  int v4 = v3;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::mpsx::MPSXDialect,void>::id, "mpsx", 4uLL, v3);
  uint64_t result = v4;
  if (v4 == v3) {
    return (void *)(*(uint64_t (**)(void *))(v3[0] + 32))(v3);
  }
  if (v4) {
    return (void *)(*(uint64_t (**)(void))(*v4 + 40))();
  }
  return result;
}

const char *mlir::mps::MPSRuntimeCanonicalizationBase<mlir::mps::anonymous namespace'::RuntimeCanonicalizationPass>::getArgument()
{
  return "mps-runtime-canonicalization";
}

const char *mlir::mps::MPSRuntimeCanonicalizationBase<mlir::mps::anonymous namespace'::RuntimeCanonicalizationPass>::getDescription()
{
  return "Canonicalize operations as required by the MPS runtime for execution.";
}

void mlir::mps::anonymous namespace'::RuntimeCanonicalizationPass::runOnOperation(mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *this)
{
}

void *mlir::mps::MPSRuntimeCanonicalizationBase<mlir::mps::anonymous namespace'::RuntimeCanonicalizationPass>::clonePass@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  int v4 = operator new(0x568uLL);
  uint64_t v5 = *(void *)(a1 + 8);
  v4[1] = *(_OWORD *)(a1 + 16);
  *((void *)v4 + 4) = *(void *)(a1 + 32);
  *((void *)v4 + 1) = v5;
  *((unsigned char *)v4 + 40) = 0;
  *((unsigned char *)v4 + 120) = 0;
  v4[8] = 0u;
  v4[9] = 0u;
  v4[10] = 0u;
  *((void *)v4 + 22) = 0;
  *((void *)v4 + 23) = (char *)v4 + 200;
  *((void *)v4 + 24) = 0x400000000;
  *((void *)v4 + 29) = (char *)v4 + 248;
  *((void *)v4 + 30) = 0x400000000;
  *((void *)v4 + 35) = 0;
  *((void *)v4 + 36) = 0;
  *((_DWORD *)v4 + 74) = 0;
  *((_DWORD *)v4 + 75) = 16;
  v4[19] = 0u;
  v4[20] = 0u;
  *((void *)v4 + 42) = 0;
  *(void *)int v4 = &unk_1EC9CA9F0;
  v9.n128_u64[0] = (unint64_t)"Enables the folding of a matmul RHS input, where RHS is a transpose of a constant.";
  v9.n128_u64[1] = 82;
  LOBYTE(v7) = 0;
  uint64_t v8 = &v7;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)v4 + 43, (void *)v4 + 19, (uint64_t)"enable-matmul-nt-to-nn-fold", 27, &v9, (unsigned char **)&v8);
  *((void *)v4 + 43) = &unk_1EC9CB060;
  *((void *)v4 + 67) = &unk_1EC9CB0E0;
  v9.n128_u64[0] = (unint64_t)"Use legacy quantization patterns";
  v9.n128_u64[1] = 32;
  LOBYTE(v7) = 1;
  uint64_t v8 = &v7;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)v4 + 69, (void *)v4 + 19, (uint64_t)"legacy-quantization", 19, &v9, (unsigned char **)&v8);
  *((void *)v4 + 69) = &unk_1EC9CB060;
  *((void *)v4 + 93) = &unk_1EC9CB0E0;
  v9.n128_u64[0] = (unint64_t)"Maximum number of inputs supported by MPS quantization kernels.";
  v9.n128_u64[1] = 63;
  int v7 = 32;
  uint64_t v8 = &v7;
  mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::initializer<int>>((void *)v4 + 95, (void *)v4 + 19, (uint64_t)"quant-ops-max-inputs-count", 26, &v9, &v8);
  *((void *)v4 + 95) = &unk_1EC9CB120;
  *((void *)v4 + 119) = &unk_1EC9CB1A0;
  v9.n128_u64[0] = (unint64_t)"Enables the canonicalization of 2D (de)convolutions to matmuls.";
  v9.n128_u64[1] = 63;
  LOBYTE(v7) = 0;
  uint64_t v8 = &v7;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)v4 + 121, (void *)v4 + 19, (uint64_t)"enable-conv2d-to-matmul", 23, &v9, (unsigned char **)&v8);
  *((void *)v4 + 121) = &unk_1EC9CB060;
  *((void *)v4 + 145) = &unk_1EC9CB0E0;
  v9.n128_u64[0] = (unint64_t)"Enables the canonicalization of reshaped convolutions to matmuls.";
  v9.n128_u64[1] = 65;
  LOBYTE(v7) = 0;
  uint64_t v8 = &v7;
  uint64_t result = mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)v4 + 147, (void *)v4 + 19, (uint64_t)"enable-reshape-conv2d-biasadd-reshape", 37, &v9, (unsigned char **)&v8);
  *((void *)v4 + 147) = &unk_1EC9CB060;
  *((void *)v4 + 171) = &unk_1EC9CB0E0;
  *(void *)int v4 = &unk_1EC9C9D70;
  *a2 = v4;
  return result;
}

void *mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::initializer<int>>(void *a1, void *a2, uint64_t a3, uint64_t a4, __n128 *a5, int **a6)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  v31[0] = a3;
  v31[1] = a4;
  v34[0] = a2;
  uint64_t v8 = llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>>((uint64_t)a1, (uint64_t)v31, v34, a5, a6);
  uint64_t v9 = v8 + 192;
  *(unsigned char *)(v8 + 200) = 0;
  *(void *)uint64_t v8 = &unk_1EC9CCEC8;
  *(void *)(v8 + 192) = &unk_1EC9CCF48;
  char v11 = (uint64_t *)a2[21];
  unint64_t v10 = a2[22];
  uint64_t v12 = v11;
  if ((unint64_t)v11 >= v10)
  {
    uint64_t v14 = (uint64_t *)a2[20];
    uint64_t v15 = v11 - v14;
    unint64_t v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 61) {
      abort();
    }
    uint64_t v17 = v10 - (void)v14;
    if (v17 >> 2 > v16) {
      unint64_t v16 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v16;
    }
    if (v18)
    {
      if (v18 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v19 = (char *)operator new(8 * v18);
    }
    else
    {
      uint64_t v19 = 0;
    }
    uint64_t v20 = (uint64_t *)&v19[8 * v15];
    uint64_t v21 = &v19[8 * v18];
    *uint64_t v20 = v9;
    unsigned int v13 = v20 + 1;
    if (v11 != v14)
    {
      unint64_t v22 = (char *)v11 - (char *)v14 - 8;
      if (v22 < 0x58) {
        goto LABEL_36;
      }
      if ((unint64_t)((char *)v14 - v19) < 0x20) {
        goto LABEL_36;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v12 = &v11[v24 / 0xFFFFFFFFFFFFFFF8];
      uint64_t v20 = (uint64_t *)((char *)v20 - v24);
      uint64_t v25 = &v19[8 * v15 - 16];
      int v26 = v11 - 2;
      uint64_t v27 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v28 = *(_OWORD *)v26;
        *((_OWORD *)v25 - 1) = *((_OWORD *)v26 - 1);
        *(_OWORD *)uint64_t v25 = v28;
        v25 -= 32;
        v26 -= 4;
        v27 -= 4;
      }
      while (v27);
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_36:
        do
        {
          uint64_t v29 = *--v12;
          *--uint64_t v20 = v29;
        }
        while (v12 != v14);
      }
      uint64_t v12 = (uint64_t *)a2[20];
    }
    a2[20] = v20;
    a2[21] = v13;
    a2[22] = v21;
    if (v12) {
      operator delete(v12);
    }
  }
  else
  {
    *char v11 = v9;
    unsigned int v13 = v11 + 1;
  }
  a2[21] = v13;
  v32[0] = &unk_1EC9CF988;
  v32[1] = a1;
  unsigned int v35 = v34;
  uint64_t v33 = v32;
  v34[0] = &unk_1EC9CF988;
  v34[1] = a1;
  std::__function::__value_func<void ()(unsigned int const&)>::swap[abi:nn180100](v34, a1 + 20);
  if (v35 == v34)
  {
    (*((void (**)(const void **))v34[0] + 4))(v34);
  }
  else if (v35)
  {
    (*((void (**)(void))*v35 + 5))();
  }
  if (v33 == v32)
  {
    (*(void (**)(void *))(v32[0] + 32))(v32);
  }
  else if (v33)
  {
    (*(void (**)(void))(*v33 + 40))();
  }
  return a1;
}

void *mlir::Pass::Option<unsigned int,llvm::cl::parser<unsigned int>>::~Option(void *a1)
{
  *a1 = &unk_1EC9A3FD0;
  int v2 = a1 + 20;
  unint64_t v3 = (void *)a1[23];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  *a1 = &unk_1EC9A42A8;
  int v4 = (void *)a1[12];
  if (v4 != (void *)a1[11]) {
    free(v4);
  }
  uint64_t v5 = (void *)a1[8];
  if (v5 != a1 + 10) {
    free(v5);
  }
  return a1;
}

void mlir::Pass::Option<unsigned int,llvm::cl::parser<unsigned int>>::~Option(char *__p)
{
  *(void *)std::string __p = &unk_1EC9A3FD0;
  int v2 = __p + 160;
  unint64_t v3 = (char *)*((void *)__p + 23);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  *(void *)std::string __p = &unk_1EC9A42A8;
  int v4 = (void *)*((void *)__p + 12);
  if (v4 != *((void **)__p + 11)) {
    free(v4);
  }
  uint64_t v5 = (char *)*((void *)__p + 8);
  if (v5 != __p + 80) {
    free(v5);
  }

  operator delete(__p);
}

llvm::raw_ostream *mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::print(uint64_t a1, llvm::raw_ostream *this)
{
  int v4 = *(const void **)(a1 + 16);
  size_t v5 = *(void *)(a1 + 24);
  __n128 v6 = (unsigned char *)*((void *)this + 4);
  if (v5 <= *((void *)this + 3) - (void)v6)
  {
    if (v5)
    {
      memcpy(v6, v4, v5);
      __n128 v6 = (unsigned char *)(*((void *)this + 4) + v5);
      *((void *)this + 4) = v6;
    }
    int v7 = this;
  }
  else
  {
    int v7 = llvm::raw_ostream::write(this, (const char *)v4, v5);
    __n128 v6 = (unsigned char *)*((void *)v7 + 4);
  }
  if ((unint64_t)v6 >= *((void *)v7 + 3))
  {
    llvm::raw_ostream::write(v7, 61);
  }
  else
  {
    *((void *)v7 + 4) = v6 + 1;
    *__n128 v6 = 61;
  }
  unint64_t v8 = *(unsigned int *)(a1 + 128);

  return llvm::raw_ostream::operator<<(this, v8);
}

uint64_t mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::copyValueFrom(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 128) = *(_DWORD *)(a2 - 64);
  *(unsigned char *)(result + 200) = *(unsigned char *)(a2 + 8);
  return result;
}

void non-virtual thunk to'mlir::Pass::Option<unsigned int,llvm::cl::parser<unsigned int>>::~Option(uint64_t a1)
{
  *(void *)(a1 - 192) = &unk_1EC9A3FD0;
  uint64_t v2 = a1 - 32;
  uint64_t v3 = *(void *)(a1 - 8);
  if (v3 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  *(void *)(a1 - 192) = &unk_1EC9A42A8;
  int v4 = *(void **)(a1 - 96);
  if (v4 != *(void **)(a1 - 104)) {
    free(v4);
  }
  size_t v5 = *(void **)(a1 - 128);
  if (v5 != (void *)(a1 - 112)) {
    free(v5);
  }
}

{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;
  uint64_t vars8;

  uint64_t v2 = (void *)(a1 - 192);
  *(void *)(a1 - 192) = &unk_1EC9A3FD0;
  uint64_t v3 = a1 - 32;
  int v4 = *(void *)(a1 - 8);
  if (v4 == v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 32))(v3);
  }
  else if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
  }
  *(void *)(a1 - 192) = &unk_1EC9A42A8;
  size_t v5 = *(void **)(a1 - 96);
  if (v5 != *(void **)(a1 - 104)) {
    free(v5);
  }
  __n128 v6 = *(void **)(a1 - 128);
  if (v6 != (void *)(a1 - 112)) {
    free(v6);
  }

  operator delete(v2);
}

llvm::raw_ostream *non-virtual thunk to'mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::print(uint64_t a1, llvm::raw_ostream *this)
{
  int v4 = *(const void **)(a1 - 176);
  size_t v5 = *(void *)(a1 - 168);
  __n128 v6 = (unsigned char *)*((void *)this + 4);
  if (v5 <= *((void *)this + 3) - (void)v6)
  {
    if (v5)
    {
      memcpy(v6, v4, v5);
      __n128 v6 = (unsigned char *)(*((void *)this + 4) + v5);
      *((void *)this + 4) = v6;
    }
    int v7 = this;
  }
  else
  {
    int v7 = llvm::raw_ostream::write(this, (const char *)v4, v5);
    __n128 v6 = (unsigned char *)*((void *)v7 + 4);
  }
  if ((unint64_t)v6 >= *((void *)v7 + 3))
  {
    llvm::raw_ostream::write(v7, 61);
  }
  else
  {
    *((void *)v7 + 4) = v6 + 1;
    *__n128 v6 = 61;
  }
  unint64_t v8 = *(unsigned int *)(a1 - 64);

  return llvm::raw_ostream::operator<<(this, v8);
}

uint64_t non-virtual thunk to'mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::getOption(uint64_t a1)
{
  return a1 - 192;
}

uint64_t non-virtual thunk to'mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::copyValueFrom(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result - 64) = *(_DWORD *)(a2 - 64);
  *(unsigned char *)(result + 8) = *(unsigned char *)(a2 + 8);
  return result;
}

uint64_t llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>>(uint64_t a1, uint64_t a2, const void **a3, __n128 *a4, int **a5)
{
  *(void *)a1 = &unk_1EC9A42A8;
  *(_WORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 10) &= 0x8000u;
  unint64_t v10 = (void *)(a1 + 80);
  *(void *)(a1 + 64) = a1 + 80;
  uint64_t v11 = a1 + 64;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_DWORD *)(a1 + 60) = 0;
  *(void *)(a1 + 72) = 0x100000000;
  *(void *)(a1 + 88) = a1 + 120;
  *(void *)(a1 + 96) = a1 + 120;
  *(void *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 112) = 0;
  GeneralCategory = llvm::cl::getGeneralCategory((llvm::cl *)a1);
  uint64_t v13 = *(unsigned int *)(a1 + 72);
  if (v13 >= *(_DWORD *)(a1 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v11, v10, v13 + 1, 8);
    LODWORD(v13) = *(_DWORD *)(a1 + 72);
  }
  *(void *)(*(void *)(a1 + 64) + 8 * v13) = GeneralCategory;
  ++*(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = &unk_1EC9A3B00;
  *(void *)(a1 + 144) = 0;
  *(void *)a1 = &unk_1EC9A3FD0;
  *(void *)(a1 + 152) = &unk_1EC9A4470;
  *(void *)(a1 + 160) = &unk_1EC9CE720;
  *(void *)(a1 + 184) = a1 + 160;
  llvm::cl::apply<llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>>(a1, a2, a3, a4, a5);
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

void *mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::~Option(void *a1)
{
  *a1 = &unk_1EC9A3FD0;
  uint64_t v2 = a1 + 20;
  uint64_t v3 = (void *)a1[23];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  *a1 = &unk_1EC9A42A8;
  int v4 = (void *)a1[12];
  if (v4 != (void *)a1[11]) {
    free(v4);
  }
  size_t v5 = (void *)a1[8];
  if (v5 != a1 + 10) {
    free(v5);
  }
  return a1;
}

void mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::~Option(char *__p)
{
  *(void *)std::string __p = &unk_1EC9A3FD0;
  uint64_t v2 = __p + 160;
  uint64_t v3 = (char *)*((void *)__p + 23);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  *(void *)std::string __p = &unk_1EC9A42A8;
  int v4 = (void *)*((void *)__p + 12);
  if (v4 != *((void **)__p + 11)) {
    free(v4);
  }
  size_t v5 = (char *)*((void *)__p + 8);
  if (v5 != __p + 80) {
    free(v5);
  }

  operator delete(__p);
}

void non-virtual thunk to'mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::~Option(uint64_t a1)
{
  *(void *)(a1 - 192) = &unk_1EC9A3FD0;
  uint64_t v2 = a1 - 32;
  uint64_t v3 = *(void *)(a1 - 8);
  if (v3 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  *(void *)(a1 - 192) = &unk_1EC9A42A8;
  int v4 = *(void **)(a1 - 96);
  if (v4 != *(void **)(a1 - 104)) {
    free(v4);
  }
  size_t v5 = *(void **)(a1 - 128);
  if (v5 != (void *)(a1 - 112)) {
    free(v5);
  }
}

{
  mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::~Option((char *)(a1 - 192));
}

__n128 llvm::cl::apply<llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>>(uint64_t a1, uint64_t a2, const void **a3, __n128 *a4, int **a5)
{
  llvm::cl::Option::setArgStr(a1, *(int8x16_t **)a2, *(const unsigned __int8 **)(a2 + 8));
  uint64_t v9 = *a3;
  uint64_t v10 = *(void *)(a1 + 96);
  if (v10 != *(void *)(a1 + 88))
  {
LABEL_2:
    llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)(a1 + 88), v9);
    goto LABEL_3;
  }
  uint64_t v13 = *(unsigned int *)(a1 + 108);
  if (!v13)
  {
LABEL_12:
    if (v13 < *(_DWORD *)(a1 + 104))
    {
      *(_DWORD *)(a1 + 108) = v13 + 1;
      *(void *)(v10 + 8 * v13) = v9;
      goto LABEL_3;
    }
    goto LABEL_2;
  }
  uint64_t v14 = 0;
  uint64_t v15 = 8 * v13;
  unint64_t v16 = *(void **)(a1 + 96);
  while ((const void *)*v16 != v9)
  {
    if (*v16 == -2) {
      uint64_t v14 = v16;
    }
    ++v16;
    v15 -= 8;
    if (!v15)
    {
      if (!v14) {
        goto LABEL_12;
      }
      *uint64_t v14 = v9;
      --*(_DWORD *)(a1 + 112);
      break;
    }
  }
LABEL_3:
  __n128 result = *a4;
  *(__n128 *)(a1 + 32) = *a4;
  int v12 = **a5;
  *(_DWORD *)(a1 + 128) = v12;
  *(unsigned char *)(a1 + 148) = 1;
  *(_DWORD *)(a1 + 144) = v12;
  return result;
}

void *std::__function::__value_func<void ()(unsigned int const&)>::swap[abi:nn180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    uint64_t v3 = result;
    int v4 = (void *)result[3];
    size_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        void v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        void v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        __n128 result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        void v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      void v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void *_ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIjN4llvm2cl6parserIjEEEC1IJNS7_4descENS7_11initializerIiEEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISN_EEFvRKjEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EC9CF988;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIjN4llvm2cl6parserIjEEEC1IJNS7_4descENS7_11initializerIiEEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISN_EEFvRKjEE7__cloneEPNS0_6__baseISS_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EC9CF988;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIjN4llvm2cl6parserIjEEEC1IJNS7_4descENS7_11initializerIiEEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISN_EEFvRKjEEclESR_(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 8) + 200) = 1;
  return result;
}

void mlir::mps::anonymous namespace'::RuntimeCanonicalizationPass::canonicalize(mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *this, mlir::Operation *a2)
{
  uint64_t v857 = *MEMORY[0x1E4F143B8];
  uint64_t Context = mlir::Attribute::getContext((mlir::Operation *)((char *)a2 + 24));
  uint64_t v835 = Context;
  uint64_t v837 = Context;
  *(_OWORD *)std::string __p = 0u;
  *(_OWORD *)unint64_t v839 = 0u;
  uint64_t v840 = &v842;
  uint64_t v841 = 0x600000000;
  uint64_t v843 = 0;
  uint64_t v844 = 0;
  unsigned int v845 = 0;
  long long v846 = 0;
  uint64_t v847 = 0;
  uint64_t v848 = 0x2800000000;
  v849 = 0;
  uint64_t v850 = 0;
  uint64_t v851 = 0x2800000000;
  size_t v5 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(v834, 1);
  long long v853 = xmmword_1E4FBFF00;
  long long v854 = *(_OWORD *)&off_1E4FBFF10;
  long long v855 = xmmword_1E4FBFF20;
  long long v856 = *(_OWORD *)&off_1E4FBFF30;
  *(_OWORD *)__int16 v852 = xmmword_1E4FBFEE0;
  *(_OWORD *)&v852[16] = *(_OWORD *)&off_1E4FBFEF0;
  mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.matmul", 10, v834[0], Context, v852, 6uLL);
  *size_t v5 = &unk_1EC9C87D0;
  if (!v5[9])
  {
    *(void *)__int16 v852 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_ComplexGEMM_CC]";
    *(void *)&v852[8] = 102;
    unint64_t v6 = llvm::StringRef::find((uint64_t *)v852, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(void *)&v852[8] >= v6) {
      unint64_t v7 = v6;
    }
    else {
      unint64_t v7 = *(void *)&v852[8];
    }
    unint64_t v8 = *(void *)v852 + v7;
    unint64_t v9 = *(void *)&v852[8] - v7;
    if (*(void *)&v852[8] - v7 >= 0x12) {
      uint64_t v10 = 18;
    }
    else {
      uint64_t v10 = *(void *)&v852[8] - v7;
    }
    unint64_t v11 = v8 + v10;
    unint64_t v12 = v9 - v10;
    if (v12 >= v12 - 1) {
      --v12;
    }
    unsigned char v5[8] = v11;
    v5[9] = v12;
  }
  unint64_t v13 = *((unsigned int *)v5 + 22);
  if (v13 > *((_DWORD *)v5 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v5 + 10), v5 + 12, v13, 16);
    LODWORD(v13) = *((_DWORD *)v5 + 22);
  }
  *((_DWORD *)v5 + 22) = v13;
  uint64_t v14 = (char *)__p[1];
  if (__p[1] >= v839[0])
  {
    unint64_t v16 = (char *)__p[0];
    int64_t v17 = (char *)__p[1] - (char *)__p[0];
    int64_t v18 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v19 = v18 + 1;
    if ((unint64_t)(v18 + 1) >> 61) {
      goto LABEL_967;
    }
    int64_t v20 = (char *)v839[0] - (char *)__p[0];
    if (((char *)v839[0] - (char *)__p[0]) >> 2 > v19) {
      unint64_t v19 = v20 >> 2;
    }
    if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v21 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v21 = v19;
    }
    if (v21)
    {
      if (v21 >> 61) {
        goto LABEL_968;
      }
      unint64_t v22 = (char *)operator new(8 * v21);
    }
    else
    {
      unint64_t v22 = 0;
    }
    uint64_t v23 = &v22[8 * v18];
    uint64_t v24 = (mlir::Operation *)&v22[8 * v21];
    *(void *)uint64_t v23 = v5;
    uint64_t v15 = v23 + 8;
    if (v14 == v16)
    {
      __p[0] = &v22[8 * v18];
      __p[1] = v23 + 8;
      v839[0] = v24;
    }
    else
    {
      unint64_t v25 = v14 - v16 - 8;
      if (v25 < 0x78
        || &v14[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v23 && &v22[v17 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v14)
      {
        goto LABEL_971;
      }
      uint64_t v26 = (v25 >> 3) + 1;
      uint64_t v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      long long v28 = &v14[-v27];
      v23 -= v27;
      uint64_t v29 = &v22[8 * v18 - 16];
      BOOL v30 = v14 - 16;
      uint64_t v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v33 = *((_OWORD *)v30 - 1);
        long long v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)BOOL v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)uint64_t v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      uint64_t v14 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_971:
        do
        {
          uint64_t v34 = *((void *)v14 - 1);
          v14 -= 8;
          *(void *)uint64_t v14 = 0;
          *((void *)v23 - 1) = v34;
          v23 -= 8;
        }
        while (v14 != v16);
      }
      uint64_t v14 = (char *)__p[0];
      unsigned int v35 = (char *)__p[1];
      __p[0] = v23;
      __p[1] = v15;
      v839[0] = v24;
      while (v35 != v14)
      {
        uint64_t v37 = *((void *)v35 - 1);
        v35 -= 8;
        uint64_t v36 = v37;
        *(void *)unsigned int v35 = 0;
        if (v37) {
          (*(void (**)(uint64_t))(*(void *)v36 + 8))(v36);
        }
      }
    }
    if (v14) {
      operator delete(v14);
    }
  }
  else
  {
    *(void *)__p[1] = v5;
    uint64_t v15 = v14 + 8;
  }
  __p[1] = v15;
  uint64_t v38 = v837;
  uint64_t v39 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(v834, 1);
  *(_OWORD *)__int16 v852 = xmmword_1E4FBFF40;
  *(_OWORD *)&v852[16] = *(_OWORD *)&off_1E4FBFF50;
  long long v853 = xmmword_1E4FBFF60;
  long long v854 = *(_OWORD *)&off_1E4FBFF70;
  mlir::Pattern::Pattern((uint64_t)(v39 + 1), (uint64_t)"mps.matmul", 10, v834[0], v38, v852, 4uLL);
  *uint64_t v39 = &unk_1EC9C8810;
  if (!v39[9])
  {
    *(void *)__int16 v852 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_ComplexGEMM_CR]";
    *(void *)&v852[8] = 102;
    unint64_t v40 = llvm::StringRef::find((uint64_t *)v852, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(void *)&v852[8] >= v40) {
      unint64_t v41 = v40;
    }
    else {
      unint64_t v41 = *(void *)&v852[8];
    }
    unint64_t v42 = *(void *)v852 + v41;
    unint64_t v43 = *(void *)&v852[8] - v41;
    if (*(void *)&v852[8] - v41 >= 0x12) {
      uint64_t v44 = 18;
    }
    else {
      uint64_t v44 = *(void *)&v852[8] - v41;
    }
    unint64_t v45 = v42 + v44;
    unint64_t v46 = v43 - v44;
    if (v46 >= v46 - 1) {
      --v46;
    }
    v39[8] = v45;
    v39[9] = v46;
  }
  unint64_t v47 = *((unsigned int *)v39 + 22);
  if (v47 > *((_DWORD *)v39 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v39 + 10), v39 + 12, v47, 16);
    LODWORD(v47) = *((_DWORD *)v39 + 22);
  }
  *((_DWORD *)v39 + 22) = v47;
  uint64_t v48 = (char *)__p[1];
  if (__p[1] >= v839[0])
  {
    unint64_t v50 = (char *)__p[0];
    int64_t v51 = (char *)__p[1] - (char *)__p[0];
    int64_t v52 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v53 = v52 + 1;
    if ((unint64_t)(v52 + 1) >> 61) {
      goto LABEL_967;
    }
    int64_t v54 = (char *)v839[0] - (char *)__p[0];
    if (((char *)v839[0] - (char *)__p[0]) >> 2 > v53) {
      unint64_t v53 = v54 >> 2;
    }
    if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v55 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v55 = v53;
    }
    if (v55)
    {
      if (v55 >> 61) {
        goto LABEL_968;
      }
      int v56 = (char *)operator new(8 * v55);
    }
    else
    {
      int v56 = 0;
    }
    uint64_t v57 = &v56[8 * v52];
    int v58 = (mlir::Operation *)&v56[8 * v55];
    *(void *)uint64_t v57 = v39;
    uint64_t v49 = v57 + 8;
    if (v48 == v50)
    {
      __p[0] = &v56[8 * v52];
      __p[1] = v57 + 8;
      v839[0] = v58;
    }
    else
    {
      unint64_t v59 = v48 - v50 - 8;
      if (v59 < 0x78
        || &v48[-(v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v57 && &v56[v51 - (v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v48)
      {
        goto LABEL_972;
      }
      uint64_t v60 = (v59 >> 3) + 1;
      uint64_t v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v62 = &v48[-v61];
      v57 -= v61;
      int v63 = &v56[8 * v52 - 16];
      BOOL v64 = v48 - 16;
      uint64_t v65 = v60 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v67 = *((_OWORD *)v64 - 1);
        long long v66 = *(_OWORD *)v64;
        *((_OWORD *)v64 - 1) = 0uLL;
        *(_OWORD *)BOOL v64 = 0uLL;
        *((_OWORD *)v63 - 1) = v67;
        *(_OWORD *)int v63 = v66;
        v63 -= 32;
        v64 -= 32;
        v65 -= 4;
      }
      while (v65);
      uint64_t v48 = v62;
      if (v60 != (v60 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_972:
        do
        {
          uint64_t v68 = *((void *)v48 - 1);
          v48 -= 8;
          *(void *)uint64_t v48 = 0;
          *((void *)v57 - 1) = v68;
          v57 -= 8;
        }
        while (v48 != v50);
      }
      uint64_t v48 = (char *)__p[0];
      int v69 = (char *)__p[1];
      __p[0] = v57;
      __p[1] = v49;
      v839[0] = v58;
      while (v69 != v48)
      {
        uint64_t v71 = *((void *)v69 - 1);
        v69 -= 8;
        uint64_t v70 = v71;
        *(void *)int v69 = 0;
        if (v71) {
          (*(void (**)(uint64_t))(*(void *)v70 + 8))(v70);
        }
      }
    }
    if (v48) {
      operator delete(v48);
    }
  }
  else
  {
    *(void *)__p[1] = v39;
    uint64_t v49 = v48 + 8;
  }
  __p[1] = v49;
  uint64_t v72 = v837;
  unint64_t v73 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(v834, 1);
  *(_OWORD *)__int16 v852 = xmmword_1E4FBFF40;
  *(_OWORD *)&v852[16] = *(_OWORD *)&off_1E4FBFF50;
  long long v853 = xmmword_1E4FBFF60;
  long long v854 = *(_OWORD *)&off_1E4FBFF70;
  mlir::Pattern::Pattern((uint64_t)(v73 + 1), (uint64_t)"mps.matmul", 10, v834[0], v72, v852, 4uLL);
  *unint64_t v73 = &unk_1EC9C8850;
  if (!v73[9])
  {
    *(void *)__int16 v852 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_ComplexGEMM_RC]";
    *(void *)&v852[8] = 102;
    unint64_t v74 = llvm::StringRef::find((uint64_t *)v852, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(void *)&v852[8] >= v74) {
      unint64_t v75 = v74;
    }
    else {
      unint64_t v75 = *(void *)&v852[8];
    }
    unint64_t v76 = *(void *)v852 + v75;
    unint64_t v77 = *(void *)&v852[8] - v75;
    if (*(void *)&v852[8] - v75 >= 0x12) {
      uint64_t v78 = 18;
    }
    else {
      uint64_t v78 = *(void *)&v852[8] - v75;
    }
    unint64_t v79 = v76 + v78;
    unint64_t v80 = v77 - v78;
    if (v80 >= v80 - 1) {
      --v80;
    }
    v73[8] = v79;
    v73[9] = v80;
  }
  unint64_t v81 = *((unsigned int *)v73 + 22);
  if (v81 > *((_DWORD *)v73 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v73 + 10), v73 + 12, v81, 16);
    LODWORD(v81) = *((_DWORD *)v73 + 22);
  }
  *((_DWORD *)v73 + 22) = v81;
  uint64_t v82 = (char *)__p[1];
  if (__p[1] >= v839[0])
  {
    uint64_t v84 = (char *)__p[0];
    int64_t v85 = (char *)__p[1] - (char *)__p[0];
    int64_t v86 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v87 = v86 + 1;
    if ((unint64_t)(v86 + 1) >> 61) {
      goto LABEL_967;
    }
    int64_t v88 = (char *)v839[0] - (char *)__p[0];
    if (((char *)v839[0] - (char *)__p[0]) >> 2 > v87) {
      unint64_t v87 = v88 >> 2;
    }
    if ((unint64_t)v88 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v89 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v89 = v87;
    }
    if (v89)
    {
      if (v89 >> 61) {
        goto LABEL_968;
      }
      uint64x2_t v90 = (char *)operator new(8 * v89);
    }
    else
    {
      uint64x2_t v90 = 0;
    }
    uint64_t v91 = &v90[8 * v86];
    uint64_t v92 = (mlir::Operation *)&v90[8 * v89];
    *(void *)uint64_t v91 = v73;
    char v83 = v91 + 8;
    if (v82 == v84)
    {
      __p[0] = &v90[8 * v86];
      __p[1] = v91 + 8;
      v839[0] = v92;
    }
    else
    {
      unint64_t v93 = v82 - v84 - 8;
      if (v93 < 0x78
        || &v82[-(v93 & 0xFFFFFFFFFFFFFFF8) - 8] < v91 && &v90[v85 - (v93 & 0xFFFFFFFFFFFFFFF8) - 8] < v82)
      {
        goto LABEL_973;
      }
      uint64_t v94 = (v93 >> 3) + 1;
      uint64_t v95 = 8 * (v94 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v96 = &v82[-v95];
      v91 -= v95;
      unint64_t v97 = &v90[8 * v86 - 16];
      uint64_t v98 = v82 - 16;
      uint64_t v99 = v94 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v101 = *((_OWORD *)v98 - 1);
        long long v100 = *(_OWORD *)v98;
        *((_OWORD *)v98 - 1) = 0uLL;
        *(_OWORD *)uint64_t v98 = 0uLL;
        *((_OWORD *)v97 - 1) = v101;
        *(_OWORD *)unint64_t v97 = v100;
        v97 -= 32;
        v98 -= 32;
        v99 -= 4;
      }
      while (v99);
      uint64_t v82 = v96;
      if (v94 != (v94 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_973:
        do
        {
          uint64_t v102 = *((void *)v82 - 1);
          v82 -= 8;
          *(void *)uint64_t v82 = 0;
          *((void *)v91 - 1) = v102;
          v91 -= 8;
        }
        while (v82 != v84);
      }
      uint64_t v82 = (char *)__p[0];
      uint64_t v103 = (char *)__p[1];
      __p[0] = v91;
      __p[1] = v83;
      v839[0] = v92;
      while (v103 != v82)
      {
        uint64_t v105 = *((void *)v103 - 1);
        v103 -= 8;
        uint64_t v104 = v105;
        *(void *)uint64_t v103 = 0;
        if (v105) {
          (*(void (**)(uint64_t))(*(void *)v104 + 8))(v104);
        }
      }
    }
    if (v82) {
      operator delete(v82);
    }
  }
  else
  {
    *(void *)__p[1] = v73;
    char v83 = v82 + 8;
  }
  __p[1] = v83;
  uint64_t v106 = v837;
  __int16 v107 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(v834, 2);
  *(_OWORD *)__int16 v852 = xmmword_1E4FBFF80;
  *(_OWORD *)&v852[16] = *(_OWORD *)&off_1E4FBFF90;
  long long v853 = xmmword_1E4FBFFA0;
  mlir::Pattern::Pattern((uint64_t)(v107 + 1), (uint64_t)"mps.divide", 10, v834[0], v106, v852, 3uLL);
  *__int16 v107 = &unk_1EC9C8378;
  if (!v107[9])
  {
    *(void *)__int16 v852 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_DivideOfPower]";
    *(void *)&v852[8] = 101;
    unint64_t v108 = llvm::StringRef::find((uint64_t *)v852, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(void *)&v852[8] >= v108) {
      unint64_t v109 = v108;
    }
    else {
      unint64_t v109 = *(void *)&v852[8];
    }
    unint64_t v110 = *(void *)v852 + v109;
    unint64_t v111 = *(void *)&v852[8] - v109;
    if (*(void *)&v852[8] - v109 >= 0x12) {
      uint64_t v112 = 18;
    }
    else {
      uint64_t v112 = *(void *)&v852[8] - v109;
    }
    unint64_t v113 = v110 + v112;
    unint64_t v114 = v111 - v112;
    if (v114 >= v114 - 1) {
      --v114;
    }
    v107[8] = v113;
    v107[9] = v114;
  }
  unint64_t v115 = *((unsigned int *)v107 + 22);
  if (v115 > *((_DWORD *)v107 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v107 + 10), v107 + 12, v115, 16);
    LODWORD(v115) = *((_DWORD *)v107 + 22);
  }
  *((_DWORD *)v107 + 22) = v115;
  unint64_t v116 = (char *)__p[1];
  if (__p[1] >= v839[0])
  {
    unint64_t v118 = (char *)__p[0];
    int64_t v119 = (char *)__p[1] - (char *)__p[0];
    int64_t v120 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v121 = v120 + 1;
    if ((unint64_t)(v120 + 1) >> 61) {
      goto LABEL_967;
    }
    int64_t v122 = (char *)v839[0] - (char *)__p[0];
    if (((char *)v839[0] - (char *)__p[0]) >> 2 > v121) {
      unint64_t v121 = v122 >> 2;
    }
    if ((unint64_t)v122 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v123 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v123 = v121;
    }
    if (v123)
    {
      if (v123 >> 61) {
        goto LABEL_968;
      }
      uint64_t v124 = (char *)operator new(8 * v123);
    }
    else
    {
      uint64_t v124 = 0;
    }
    unint64_t v125 = &v124[8 * v120];
    unint64_t v126 = (mlir::Operation *)&v124[8 * v123];
    *(void *)unint64_t v125 = v107;
    unint64_t v117 = v125 + 8;
    if (v116 == v118)
    {
      __p[0] = &v124[8 * v120];
      __p[1] = v125 + 8;
      v839[0] = v126;
    }
    else
    {
      unint64_t v127 = v116 - v118 - 8;
      if (v127 < 0x78
        || &v116[-(v127 & 0xFFFFFFFFFFFFFFF8) - 8] < v125 && &v124[v119 - (v127 & 0xFFFFFFFFFFFFFFF8) - 8] < v116)
      {
        goto LABEL_974;
      }
      uint64_t v128 = (v127 >> 3) + 1;
      uint64_t v129 = 8 * (v128 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v130 = &v116[-v129];
      v125 -= v129;
      uint64_t v131 = &v124[8 * v120 - 16];
      unint64_t v132 = v116 - 16;
      uint64_t v133 = v128 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v135 = *((_OWORD *)v132 - 1);
        long long v134 = *(_OWORD *)v132;
        *((_OWORD *)v132 - 1) = 0uLL;
        *(_OWORD *)unint64_t v132 = 0uLL;
        *((_OWORD *)v131 - 1) = v135;
        *(_OWORD *)uint64_t v131 = v134;
        v131 -= 32;
        v132 -= 32;
        v133 -= 4;
      }
      while (v133);
      unint64_t v116 = v130;
      if (v128 != (v128 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_974:
        do
        {
          uint64_t v136 = *((void *)v116 - 1);
          v116 -= 8;
          *(void *)unint64_t v116 = 0;
          *((void *)v125 - 1) = v136;
          v125 -= 8;
        }
        while (v116 != v118);
      }
      unint64_t v116 = (char *)__p[0];
      uint64_t v137 = (char *)__p[1];
      __p[0] = v125;
      __p[1] = v117;
      v839[0] = v126;
      while (v137 != v116)
      {
        uint64_t v139 = *((void *)v137 - 1);
        v137 -= 8;
        uint64_t v138 = v139;
        *(void *)uint64_t v137 = 0;
        if (v139) {
          (*(void (**)(uint64_t))(*(void *)v138 + 8))(v138);
        }
      }
    }
    if (v116) {
      operator delete(v116);
    }
  }
  else
  {
    *(void *)__p[1] = v107;
    unint64_t v117 = v116 + 8;
  }
  __p[1] = v117;
  uint64_t v140 = v837;
  uint64_t v141 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(v834, 2);
  *(_OWORD *)__int16 v852 = xmmword_1E4FBFFB0;
  *(_OWORD *)&v852[16] = *(_OWORD *)&off_1E4FBFFC0;
  mlir::Pattern::Pattern((uint64_t)(v141 + 1), (uint64_t)"mps.divide", 10, v834[0], v140, v852, 2uLL);
  *uint64_t v141 = &unk_1EC9C9E38;
  if (!v141[9])
  {
    *(void *)__int16 v852 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_DivideSqrtToMultiplyRsqrt]";
    *(void *)&v852[8] = 113;
    unint64_t v142 = llvm::StringRef::find((uint64_t *)v852, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(void *)&v852[8] >= v142) {
      unint64_t v143 = v142;
    }
    else {
      unint64_t v143 = *(void *)&v852[8];
    }
    unint64_t v144 = *(void *)v852 + v143;
    unint64_t v145 = *(void *)&v852[8] - v143;
    if (*(void *)&v852[8] - v143 >= 0x12) {
      uint64_t v146 = 18;
    }
    else {
      uint64_t v146 = *(void *)&v852[8] - v143;
    }
    unint64_t v147 = v144 + v146;
    unint64_t v148 = v145 - v146;
    if (v148 >= v148 - 1) {
      --v148;
    }
    v141[8] = v147;
    v141[9] = v148;
  }
  unint64_t v149 = *((unsigned int *)v141 + 22);
  if (v149 > *((_DWORD *)v141 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v141 + 10), v141 + 12, v149, 16);
    LODWORD(v149) = *((_DWORD *)v141 + 22);
  }
  *((_DWORD *)v141 + 22) = v149;
  uint64_t v150 = (char *)__p[1];
  if (__p[1] >= v839[0])
  {
    uint64_t v152 = (char *)__p[0];
    int64_t v153 = (char *)__p[1] - (char *)__p[0];
    int64_t v154 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v155 = v154 + 1;
    if ((unint64_t)(v154 + 1) >> 61) {
      goto LABEL_967;
    }
    int64_t v156 = (char *)v839[0] - (char *)__p[0];
    if (((char *)v839[0] - (char *)__p[0]) >> 2 > v155) {
      unint64_t v155 = v156 >> 2;
    }
    if ((unint64_t)v156 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v157 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v157 = v155;
    }
    if (v157)
    {
      if (v157 >> 61) {
        goto LABEL_968;
      }
      uint64_t v158 = (char *)operator new(8 * v157);
    }
    else
    {
      uint64_t v158 = 0;
    }
    unint64_t v159 = &v158[8 * v154];
    unint64_t v160 = (mlir::Operation *)&v158[8 * v157];
    *(void *)unint64_t v159 = v141;
    uint64_t v151 = v159 + 8;
    if (v150 == v152)
    {
      __p[0] = &v158[8 * v154];
      __p[1] = v159 + 8;
      v839[0] = v160;
    }
    else
    {
      unint64_t v161 = v150 - v152 - 8;
      if (v161 < 0x78
        || &v150[-(v161 & 0xFFFFFFFFFFFFFFF8) - 8] < v159 && &v158[v153 - (v161 & 0xFFFFFFFFFFFFFFF8) - 8] < v150)
      {
        goto LABEL_975;
      }
      uint64_t v162 = (v161 >> 3) + 1;
      uint64_t v163 = 8 * (v162 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v164 = &v150[-v163];
      v159 -= v163;
      unint64_t v165 = &v158[8 * v154 - 16];
      long long v166 = v150 - 16;
      uint64_t v167 = v162 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v169 = *((_OWORD *)v166 - 1);
        long long v168 = *(_OWORD *)v166;
        *((_OWORD *)v166 - 1) = 0uLL;
        *(_OWORD *)long long v166 = 0uLL;
        *((_OWORD *)v165 - 1) = v169;
        *(_OWORD *)unint64_t v165 = v168;
        v165 -= 32;
        v166 -= 32;
        v167 -= 4;
      }
      while (v167);
      uint64_t v150 = v164;
      if (v162 != (v162 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_975:
        do
        {
          uint64_t v170 = *((void *)v150 - 1);
          v150 -= 8;
          *(void *)uint64_t v150 = 0;
          *((void *)v159 - 1) = v170;
          v159 -= 8;
        }
        while (v150 != v152);
      }
      uint64_t v150 = (char *)__p[0];
      unint64_t v171 = (char *)__p[1];
      __p[0] = v159;
      __p[1] = v151;
      v839[0] = v160;
      while (v171 != v150)
      {
        uint64_t v173 = *((void *)v171 - 1);
        v171 -= 8;
        uint64_t v172 = v173;
        *(void *)unint64_t v171 = 0;
        if (v173) {
          (*(void (**)(uint64_t))(*(void *)v172 + 8))(v172);
        }
      }
    }
    if (v150) {
      operator delete(v150);
    }
  }
  else
  {
    *(void *)__p[1] = v141;
    uint64_t v151 = v150 + 8;
  }
  __p[1] = v151;
  uint64_t v174 = v837;
  unint64_t v175 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(v834, 4);
  *(_OWORD *)__int16 v852 = xmmword_1E4FBFFD0;
  *(_OWORD *)&v852[16] = *(_OWORD *)&off_1E4FBFFE0;
  mlir::Pattern::Pattern((uint64_t)(v175 + 1), (uint64_t)"mps.permute", 11, v834[0], v174, v852, 2uLL);
  void *v175 = &unk_1EC9C9288;
  if (!v175[9])
  {
    *(void *)__int16 v852 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_NCHW_ConvBias_NHWC]";
    *(void *)&v852[8] = 106;
    unint64_t v176 = llvm::StringRef::find((uint64_t *)v852, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(void *)&v852[8] >= v176) {
      unint64_t v177 = v176;
    }
    else {
      unint64_t v177 = *(void *)&v852[8];
    }
    unint64_t v178 = *(void *)v852 + v177;
    unint64_t v179 = *(void *)&v852[8] - v177;
    if (*(void *)&v852[8] - v177 >= 0x12) {
      uint64_t v180 = 18;
    }
    else {
      uint64_t v180 = *(void *)&v852[8] - v177;
    }
    unint64_t v181 = v178 + v180;
    unint64_t v182 = v179 - v180;
    if (v182 >= v182 - 1) {
      --v182;
    }
    v175[8] = v181;
    v175[9] = v182;
  }
  unint64_t v183 = *((unsigned int *)v175 + 22);
  if (v183 > *((_DWORD *)v175 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v175 + 10), v175 + 12, v183, 16);
    LODWORD(v183) = *((_DWORD *)v175 + 22);
  }
  *((_DWORD *)v175 + 22) = v183;
  uint64_t v184 = (char *)__p[1];
  if (__p[1] >= v839[0])
  {
    unint64_t v186 = (char *)__p[0];
    int64_t v187 = (char *)__p[1] - (char *)__p[0];
    int64_t v188 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v189 = v188 + 1;
    if ((unint64_t)(v188 + 1) >> 61) {
      goto LABEL_967;
    }
    int64_t v190 = (char *)v839[0] - (char *)__p[0];
    if (((char *)v839[0] - (char *)__p[0]) >> 2 > v189) {
      unint64_t v189 = v190 >> 2;
    }
    if ((unint64_t)v190 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v191 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v191 = v189;
    }
    if (v191)
    {
      if (v191 >> 61) {
        goto LABEL_968;
      }
      uint64_t v192 = (char *)operator new(8 * v191);
    }
    else
    {
      uint64_t v192 = 0;
    }
    uint64_t v193 = &v192[8 * v188];
    uint64_t v194 = (mlir::Operation *)&v192[8 * v191];
    *(void *)uint64_t v193 = v175;
    uint64_t v185 = v193 + 8;
    if (v184 == v186)
    {
      __p[0] = &v192[8 * v188];
      __p[1] = v193 + 8;
      v839[0] = v194;
    }
    else
    {
      unint64_t v195 = v184 - v186 - 8;
      if (v195 < 0x78
        || &v184[-(v195 & 0xFFFFFFFFFFFFFFF8) - 8] < v193 && &v192[v187 - (v195 & 0xFFFFFFFFFFFFFFF8) - 8] < v184)
      {
        goto LABEL_976;
      }
      uint64_t v196 = (v195 >> 3) + 1;
      uint64_t v197 = 8 * (v196 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v198 = &v184[-v197];
      v193 -= v197;
      uint64_t v199 = &v192[8 * v188 - 16];
      long long v200 = v184 - 16;
      uint64_t v201 = v196 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v203 = *((_OWORD *)v200 - 1);
        long long v202 = *(_OWORD *)v200;
        *((_OWORD *)v200 - 1) = 0uLL;
        *(_OWORD *)long long v200 = 0uLL;
        *((_OWORD *)v199 - 1) = v203;
        *(_OWORD *)uint64_t v199 = v202;
        v199 -= 32;
        v200 -= 32;
        v201 -= 4;
      }
      while (v201);
      uint64_t v184 = v198;
      if (v196 != (v196 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_976:
        do
        {
          uint64_t v204 = *((void *)v184 - 1);
          v184 -= 8;
          *(void *)uint64_t v184 = 0;
          *((void *)v193 - 1) = v204;
          v193 -= 8;
        }
        while (v184 != v186);
      }
      uint64_t v184 = (char *)__p[0];
      uint64_t v205 = (char *)__p[1];
      __p[0] = v193;
      __p[1] = v185;
      v839[0] = v194;
      while (v205 != v184)
      {
        uint64_t v207 = *((void *)v205 - 1);
        v205 -= 8;
        uint64_t v206 = v207;
        *(void *)uint64_t v205 = 0;
        if (v207) {
          (*(void (**)(uint64_t))(*(void *)v206 + 8))(v206);
        }
      }
    }
    if (v184) {
      operator delete(v184);
    }
  }
  else
  {
    *(void *)__p[1] = v175;
    uint64_t v185 = v184 + 8;
  }
  __p[1] = v185;
  uint64_t v208 = v837;
  unint64_t v209 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(v834, 3);
  *(void *)__int16 v852 = "mps.conv_2d";
  *(void *)&v852[8] = 11;
  mlir::Pattern::Pattern((uint64_t)(v209 + 1), (uint64_t)"mps.permute", 11, v834[0], v208, v852, 1uLL);
  void *v209 = &unk_1EC9C88D0;
  if (!v209[9])
  {
    *(void *)__int16 v852 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_NCHW_Conv_NHWC]";
    *(void *)&v852[8] = 102;
    unint64_t v210 = llvm::StringRef::find((uint64_t *)v852, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(void *)&v852[8] >= v210) {
      unint64_t v211 = v210;
    }
    else {
      unint64_t v211 = *(void *)&v852[8];
    }
    unint64_t v212 = *(void *)v852 + v211;
    unint64_t v213 = *(void *)&v852[8] - v211;
    if (*(void *)&v852[8] - v211 >= 0x12) {
      uint64_t v214 = 18;
    }
    else {
      uint64_t v214 = *(void *)&v852[8] - v211;
    }
    unint64_t v215 = v212 + v214;
    unint64_t v216 = v213 - v214;
    if (v216 >= v216 - 1) {
      --v216;
    }
    v209[8] = v215;
    v209[9] = v216;
  }
  unint64_t v217 = *((unsigned int *)v209 + 22);
  if (v217 > *((_DWORD *)v209 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v209 + 10), v209 + 12, v217, 16);
    LODWORD(v217) = *((_DWORD *)v209 + 22);
  }
  *((_DWORD *)v209 + 22) = v217;
  uint64_t v218 = (char *)__p[1];
  if (__p[1] >= v839[0])
  {
    uint64_t v220 = (char *)__p[0];
    int64_t v221 = (char *)__p[1] - (char *)__p[0];
    int64_t v222 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v223 = v222 + 1;
    if ((unint64_t)(v222 + 1) >> 61) {
      goto LABEL_967;
    }
    int64_t v224 = (char *)v839[0] - (char *)__p[0];
    if (((char *)v839[0] - (char *)__p[0]) >> 2 > v223) {
      unint64_t v223 = v224 >> 2;
    }
    if ((unint64_t)v224 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v225 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v225 = v223;
    }
    if (v225)
    {
      if (v225 >> 61) {
        goto LABEL_968;
      }
      uint64_t v226 = (char *)operator new(8 * v225);
    }
    else
    {
      uint64_t v226 = 0;
    }
    unint64_t v227 = &v226[8 * v222];
    uint64_t v228 = (mlir::Operation *)&v226[8 * v225];
    *(void *)unint64_t v227 = v209;
    uint64_t v219 = v227 + 8;
    if (v218 == v220)
    {
      __p[0] = &v226[8 * v222];
      __p[1] = v227 + 8;
      v839[0] = v228;
    }
    else
    {
      unint64_t v229 = v218 - v220 - 8;
      if (v229 < 0x78
        || &v218[-(v229 & 0xFFFFFFFFFFFFFFF8) - 8] < v227 && &v226[v221 - (v229 & 0xFFFFFFFFFFFFFFF8) - 8] < v218)
      {
        goto LABEL_977;
      }
      uint64_t v230 = (v229 >> 3) + 1;
      uint64_t v231 = 8 * (v230 & 0x3FFFFFFFFFFFFFFCLL);
      v232 = &v218[-v231];
      v227 -= v231;
      uint64_t v233 = &v226[8 * v222 - 16];
      long long v234 = v218 - 16;
      uint64_t v235 = v230 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v237 = *((_OWORD *)v234 - 1);
        long long v236 = *(_OWORD *)v234;
        *((_OWORD *)v234 - 1) = 0uLL;
        *(_OWORD *)long long v234 = 0uLL;
        *((_OWORD *)v233 - 1) = v237;
        *(_OWORD *)uint64_t v233 = v236;
        v233 -= 32;
        v234 -= 32;
        v235 -= 4;
      }
      while (v235);
      uint64_t v218 = v232;
      if (v230 != (v230 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_977:
        do
        {
          uint64_t v238 = *((void *)v218 - 1);
          v218 -= 8;
          *(void *)uint64_t v218 = 0;
          *((void *)v227 - 1) = v238;
          v227 -= 8;
        }
        while (v218 != v220);
      }
      uint64_t v218 = (char *)__p[0];
      uint64_t v239 = (char *)__p[1];
      __p[0] = v227;
      __p[1] = v219;
      v839[0] = v228;
      while (v239 != v218)
      {
        uint64_t v241 = *((void *)v239 - 1);
        v239 -= 8;
        uint64_t v240 = v241;
        *(void *)uint64_t v239 = 0;
        if (v241) {
          (*(void (**)(uint64_t))(*(void *)v240 + 8))(v240);
        }
      }
    }
    if (v218) {
      operator delete(v218);
    }
  }
  else
  {
    *(void *)__p[1] = v209;
    uint64_t v219 = v218 + 8;
  }
  __p[1] = v219;
  uint64_t v242 = v837;
  unint64_t v243 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(v834, 2);
  *(_OWORD *)__int16 v852 = xmmword_1E4FBFFF0;
  *(_OWORD *)&v852[16] = *(_OWORD *)&off_1E4FC0000;
  mlir::Pattern::Pattern((uint64_t)(v243 + 1), (uint64_t)"mps.pad", 7, v834[0], v242, v852, 2uLL);
  *unint64_t v243 = &unk_1EC9C90E0;
  if (!v243[9])
  {
    *(void *)__int16 v852 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_ReorderDequantPad]";
    *(void *)&v852[8] = 105;
    unint64_t v244 = llvm::StringRef::find((uint64_t *)v852, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(void *)&v852[8] >= v244) {
      unint64_t v245 = v244;
    }
    else {
      unint64_t v245 = *(void *)&v852[8];
    }
    unint64_t v246 = *(void *)v852 + v245;
    unint64_t v247 = *(void *)&v852[8] - v245;
    if (*(void *)&v852[8] - v245 >= 0x12) {
      uint64_t v248 = 18;
    }
    else {
      uint64_t v248 = *(void *)&v852[8] - v245;
    }
    unint64_t v249 = v246 + v248;
    unint64_t v250 = v247 - v248;
    if (v250 >= v250 - 1) {
      --v250;
    }
    v243[8] = v249;
    v243[9] = v250;
  }
  unint64_t v251 = *((unsigned int *)v243 + 22);
  if (v251 > *((_DWORD *)v243 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v243 + 10), v243 + 12, v251, 16);
    LODWORD(v251) = *((_DWORD *)v243 + 22);
  }
  *((_DWORD *)v243 + 22) = v251;
  int64_t v252 = (char *)__p[1];
  if (__p[1] >= v839[0])
  {
    uint64_t v254 = (char *)__p[0];
    int64_t v255 = (char *)__p[1] - (char *)__p[0];
    int64_t v256 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v257 = v256 + 1;
    if ((unint64_t)(v256 + 1) >> 61) {
      goto LABEL_967;
    }
    int64_t v258 = (char *)v839[0] - (char *)__p[0];
    if (((char *)v839[0] - (char *)__p[0]) >> 2 > v257) {
      unint64_t v257 = v258 >> 2;
    }
    if ((unint64_t)v258 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v259 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v259 = v257;
    }
    if (v259)
    {
      if (v259 >> 61) {
        goto LABEL_968;
      }
      unint64_t v260 = (char *)operator new(8 * v259);
    }
    else
    {
      unint64_t v260 = 0;
    }
    unint64_t v261 = &v260[8 * v256];
    uint64_t v262 = (mlir::Operation *)&v260[8 * v259];
    *(void *)unint64_t v261 = v243;
    int64_t v253 = v261 + 8;
    if (v252 == v254)
    {
      __p[0] = &v260[8 * v256];
      __p[1] = v261 + 8;
      v839[0] = v262;
    }
    else
    {
      unint64_t v263 = v252 - v254 - 8;
      if (v263 < 0x78
        || &v252[-(v263 & 0xFFFFFFFFFFFFFFF8) - 8] < v261 && &v260[v255 - (v263 & 0xFFFFFFFFFFFFFFF8) - 8] < v252)
      {
        goto LABEL_978;
      }
      uint64_t v264 = (v263 >> 3) + 1;
      uint64_t v265 = 8 * (v264 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v266 = &v252[-v265];
      v261 -= v265;
      uint64_t v267 = &v260[8 * v256 - 16];
      long long v268 = v252 - 16;
      uint64_t v269 = v264 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v271 = *((_OWORD *)v268 - 1);
        long long v270 = *(_OWORD *)v268;
        *((_OWORD *)v268 - 1) = 0uLL;
        *(_OWORD *)long long v268 = 0uLL;
        *((_OWORD *)v267 - 1) = v271;
        *(_OWORD *)uint64_t v267 = v270;
        v267 -= 32;
        v268 -= 32;
        v269 -= 4;
      }
      while (v269);
      int64_t v252 = v266;
      if (v264 != (v264 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_978:
        do
        {
          uint64_t v272 = *((void *)v252 - 1);
          v252 -= 8;
          *(void *)int64_t v252 = 0;
          *((void *)v261 - 1) = v272;
          v261 -= 8;
        }
        while (v252 != v254);
      }
      int64_t v252 = (char *)__p[0];
      uint64_t v273 = (char *)__p[1];
      __p[0] = v261;
      __p[1] = v253;
      v839[0] = v262;
      while (v273 != v252)
      {
        uint64_t v275 = *((void *)v273 - 1);
        v273 -= 8;
        uint64_t v274 = v275;
        *(void *)uint64_t v273 = 0;
        if (v275) {
          (*(void (**)(uint64_t))(*(void *)v274 + 8))(v274);
        }
      }
    }
    if (v252) {
      operator delete(v252);
    }
  }
  else
  {
    *(void *)__p[1] = v243;
    int64_t v253 = v252 + 8;
  }
  __p[1] = v253;
  uint64_t v276 = v837;
  unint64_t v277 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(v834, 2);
  *(void *)__int16 v852 = "mps.reshape";
  *(void *)&v852[8] = 11;
  mlir::Pattern::Pattern((uint64_t)(v277 + 1), (uint64_t)"mps.reshape", 11, v834[0], v276, v852, 1uLL);
  void *v277 = &unk_1EC9C8910;
  if (!v277[9])
  {
    *(void *)__int16 v852 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_ReshapeReshape]";
    *(void *)&v852[8] = 102;
    unint64_t v278 = llvm::StringRef::find((uint64_t *)v852, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(void *)&v852[8] >= v278) {
      unint64_t v279 = v278;
    }
    else {
      unint64_t v279 = *(void *)&v852[8];
    }
    unint64_t v280 = *(void *)v852 + v279;
    unint64_t v281 = *(void *)&v852[8] - v279;
    if (*(void *)&v852[8] - v279 >= 0x12) {
      uint64_t v282 = 18;
    }
    else {
      uint64_t v282 = *(void *)&v852[8] - v279;
    }
    unint64_t v283 = v280 + v282;
    unint64_t v284 = v281 - v282;
    if (v284 >= v284 - 1) {
      --v284;
    }
    v277[8] = v283;
    v277[9] = v284;
  }
  unint64_t v285 = *((unsigned int *)v277 + 22);
  if (v285 > *((_DWORD *)v277 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v277 + 10), v277 + 12, v285, 16);
    LODWORD(v285) = *((_DWORD *)v277 + 22);
  }
  *((_DWORD *)v277 + 22) = v285;
  int64_t v286 = (char *)__p[1];
  if (__p[1] >= v839[0])
  {
    uint64_t v288 = (char *)__p[0];
    int64_t v289 = (char *)__p[1] - (char *)__p[0];
    int64_t v290 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v291 = v290 + 1;
    if ((unint64_t)(v290 + 1) >> 61) {
      goto LABEL_967;
    }
    int64_t v292 = (char *)v839[0] - (char *)__p[0];
    if (((char *)v839[0] - (char *)__p[0]) >> 2 > v291) {
      unint64_t v291 = v292 >> 2;
    }
    if ((unint64_t)v292 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v293 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v293 = v291;
    }
    if (v293)
    {
      if (v293 >> 61) {
        goto LABEL_968;
      }
      uint64_t v294 = (char *)operator new(8 * v293);
    }
    else
    {
      uint64_t v294 = 0;
    }
    unint64_t v295 = &v294[8 * v290];
    uint64_t v296 = (mlir::Operation *)&v294[8 * v293];
    *(void *)unint64_t v295 = v277;
    unint64_t v287 = v295 + 8;
    if (v286 == v288)
    {
      __p[0] = &v294[8 * v290];
      __p[1] = v295 + 8;
      v839[0] = v296;
    }
    else
    {
      unint64_t v297 = v286 - v288 - 8;
      if (v297 < 0x78
        || &v286[-(v297 & 0xFFFFFFFFFFFFFFF8) - 8] < v295 && &v294[v289 - (v297 & 0xFFFFFFFFFFFFFFF8) - 8] < v286)
      {
        goto LABEL_979;
      }
      uint64_t v298 = (v297 >> 3) + 1;
      uint64_t v299 = 8 * (v298 & 0x3FFFFFFFFFFFFFFCLL);
      long long v300 = &v286[-v299];
      v295 -= v299;
      uint64_t v301 = &v294[8 * v290 - 16];
      long long v302 = v286 - 16;
      uint64_t v303 = v298 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v305 = *((_OWORD *)v302 - 1);
        long long v304 = *(_OWORD *)v302;
        *((_OWORD *)v302 - 1) = 0uLL;
        *(_OWORD *)long long v302 = 0uLL;
        *((_OWORD *)v301 - 1) = v305;
        *(_OWORD *)uint64_t v301 = v304;
        v301 -= 32;
        v302 -= 32;
        v303 -= 4;
      }
      while (v303);
      int64_t v286 = v300;
      if (v298 != (v298 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_979:
        do
        {
          uint64_t v306 = *((void *)v286 - 1);
          v286 -= 8;
          *(void *)int64_t v286 = 0;
          *((void *)v295 - 1) = v306;
          v295 -= 8;
        }
        while (v286 != v288);
      }
      int64_t v286 = (char *)__p[0];
      uint64_t v307 = (char *)__p[1];
      __p[0] = v295;
      __p[1] = v287;
      v839[0] = v296;
      while (v307 != v286)
      {
        uint64_t v309 = *((void *)v307 - 1);
        v307 -= 8;
        uint64_t v308 = v309;
        *(void *)uint64_t v307 = 0;
        if (v309) {
          (*(void (**)(uint64_t))(*(void *)v308 + 8))(v308);
        }
      }
    }
    if (v286) {
      operator delete(v286);
    }
  }
  else
  {
    *(void *)__p[1] = v277;
    unint64_t v287 = v286 + 8;
  }
  __p[1] = v287;
  uint64_t v310 = v837;
  unint64_t v311 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(v834, 1);
  *(_OWORD *)__int16 v852 = xmmword_1E4FC0010;
  *(_OWORD *)&v852[16] = *(_OWORD *)&off_1E4FC0020;
  mlir::Pattern::Pattern((uint64_t)(v311 + 1), (uint64_t)"mps.select", 10, v834[0], v310, v852, 2uLL);
  *unint64_t v311 = &unk_1EC9C8950;
  if (!v311[9])
  {
    *(void *)__int16 v852 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_SelectCondCast]";
    *(void *)&v852[8] = 102;
    unint64_t v312 = llvm::StringRef::find((uint64_t *)v852, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(void *)&v852[8] >= v312) {
      unint64_t v313 = v312;
    }
    else {
      unint64_t v313 = *(void *)&v852[8];
    }
    unint64_t v314 = *(void *)v852 + v313;
    unint64_t v315 = *(void *)&v852[8] - v313;
    if (*(void *)&v852[8] - v313 >= 0x12) {
      uint64_t v316 = 18;
    }
    else {
      uint64_t v316 = *(void *)&v852[8] - v313;
    }
    unint64_t v317 = v314 + v316;
    unint64_t v318 = v315 - v316;
    if (v318 >= v318 - 1) {
      --v318;
    }
    v311[8] = v317;
    v311[9] = v318;
  }
  unint64_t v319 = *((unsigned int *)v311 + 22);
  if (v319 > *((_DWORD *)v311 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v311 + 10), v311 + 12, v319, 16);
    LODWORD(v319) = *((_DWORD *)v311 + 22);
  }
  *((_DWORD *)v311 + 22) = v319;
  unint64_t v320 = (char *)__p[1];
  if (__p[1] >= v839[0])
  {
    uint64_t v322 = (char *)__p[0];
    int64_t v323 = (char *)__p[1] - (char *)__p[0];
    int64_t v324 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v325 = v324 + 1;
    if ((unint64_t)(v324 + 1) >> 61) {
      goto LABEL_967;
    }
    int64_t v326 = (char *)v839[0] - (char *)__p[0];
    if (((char *)v839[0] - (char *)__p[0]) >> 2 > v325) {
      unint64_t v325 = v326 >> 2;
    }
    if ((unint64_t)v326 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v327 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v327 = v325;
    }
    if (v327)
    {
      if (v327 >> 61) {
        goto LABEL_968;
      }
      uint64_t v328 = (char *)operator new(8 * v327);
    }
    else
    {
      uint64_t v328 = 0;
    }
    unint64_t v329 = &v328[8 * v324];
    uint64_t v330 = (mlir::Operation *)&v328[8 * v327];
    *(void *)unint64_t v329 = v311;
    int64_t v321 = v329 + 8;
    if (v320 == v322)
    {
      __p[0] = &v328[8 * v324];
      __p[1] = v329 + 8;
      v839[0] = v330;
    }
    else
    {
      unint64_t v331 = v320 - v322 - 8;
      if (v331 < 0x78
        || &v320[-(v331 & 0xFFFFFFFFFFFFFFF8) - 8] < v329 && &v328[v323 - (v331 & 0xFFFFFFFFFFFFFFF8) - 8] < v320)
      {
        goto LABEL_980;
      }
      uint64_t v332 = (v331 >> 3) + 1;
      uint64_t v333 = 8 * (v332 & 0x3FFFFFFFFFFFFFFCLL);
      long long v334 = &v320[-v333];
      v329 -= v333;
      uint64_t v335 = &v328[8 * v324 - 16];
      long long v336 = v320 - 16;
      uint64_t v337 = v332 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v339 = *((_OWORD *)v336 - 1);
        long long v338 = *(_OWORD *)v336;
        *((_OWORD *)v336 - 1) = 0uLL;
        *(_OWORD *)long long v336 = 0uLL;
        *((_OWORD *)v335 - 1) = v339;
        *(_OWORD *)uint64_t v335 = v338;
        v335 -= 32;
        v336 -= 32;
        v337 -= 4;
      }
      while (v337);
      unint64_t v320 = v334;
      if (v332 != (v332 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_980:
        do
        {
          uint64_t v340 = *((void *)v320 - 1);
          v320 -= 8;
          *(void *)unint64_t v320 = 0;
          *((void *)v329 - 1) = v340;
          v329 -= 8;
        }
        while (v320 != v322);
      }
      unint64_t v320 = (char *)__p[0];
      uint64_t v341 = (char *)__p[1];
      __p[0] = v329;
      __p[1] = v321;
      v839[0] = v330;
      while (v341 != v320)
      {
        uint64_t v343 = *((void *)v341 - 1);
        v341 -= 8;
        uint64_t v342 = v343;
        *(void *)uint64_t v341 = 0;
        if (v343) {
          (*(void (**)(uint64_t))(*(void *)v342 + 8))(v342);
        }
      }
    }
    if (v320) {
      operator delete(v320);
    }
  }
  else
  {
    *(void *)__p[1] = v311;
    int64_t v321 = v320 + 8;
  }
  __p[1] = v321;
  uint64_t v344 = v837;
  unint64_t v345 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(v834, 2);
  *(void *)__int16 v852 = "mps.square";
  *(void *)&v852[8] = 10;
  mlir::Pattern::Pattern((uint64_t)(v345 + 1), (uint64_t)"mps.square", 10, v834[0], v344, v852, 1uLL);
  void *v345 = &unk_1EC9C8CB0;
  if (!v345[9])
  {
    *(void *)__int16 v852 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_SquareOfAbsolute]";
    *(void *)&v852[8] = 104;
    unint64_t v346 = llvm::StringRef::find((uint64_t *)v852, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(void *)&v852[8] >= v346) {
      unint64_t v347 = v346;
    }
    else {
      unint64_t v347 = *(void *)&v852[8];
    }
    unint64_t v348 = *(void *)v852 + v347;
    unint64_t v349 = *(void *)&v852[8] - v347;
    if (*(void *)&v852[8] - v347 >= 0x12) {
      uint64_t v350 = 18;
    }
    else {
      uint64_t v350 = *(void *)&v852[8] - v347;
    }
    unint64_t v351 = v348 + v350;
    unint64_t v352 = v349 - v350;
    if (v352 >= v352 - 1) {
      --v352;
    }
    v345[8] = v351;
    v345[9] = v352;
  }
  unint64_t v353 = *((unsigned int *)v345 + 22);
  if (v353 > *((_DWORD *)v345 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v345 + 10), v345 + 12, v353, 16);
    LODWORD(v353) = *((_DWORD *)v345 + 22);
  }
  *((_DWORD *)v345 + 22) = v353;
  int64_t v354 = (char *)__p[1];
  if (__p[1] >= v839[0])
  {
    uint64_t v356 = (char *)__p[0];
    int64_t v357 = (char *)__p[1] - (char *)__p[0];
    int64_t v358 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v359 = v358 + 1;
    if ((unint64_t)(v358 + 1) >> 61) {
      goto LABEL_967;
    }
    int64_t v360 = (char *)v839[0] - (char *)__p[0];
    if (((char *)v839[0] - (char *)__p[0]) >> 2 > v359) {
      unint64_t v359 = v360 >> 2;
    }
    if ((unint64_t)v360 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v361 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v361 = v359;
    }
    if (v361)
    {
      if (v361 >> 61) {
        goto LABEL_968;
      }
      char v362 = (char *)operator new(8 * v361);
    }
    else
    {
      char v362 = 0;
    }
    unint64_t v363 = &v362[8 * v358];
    uint64_t v364 = (mlir::Operation *)&v362[8 * v361];
    *(void *)unint64_t v363 = v345;
    unint64_t v355 = v363 + 8;
    if (v354 == v356)
    {
      __p[0] = &v362[8 * v358];
      __p[1] = v363 + 8;
      v839[0] = v364;
    }
    else
    {
      unint64_t v365 = v354 - v356 - 8;
      if (v365 < 0x78
        || &v354[-(v365 & 0xFFFFFFFFFFFFFFF8) - 8] < v363 && &v362[v357 - (v365 & 0xFFFFFFFFFFFFFFF8) - 8] < v354)
      {
        goto LABEL_981;
      }
      uint64_t v366 = (v365 >> 3) + 1;
      uint64_t v367 = 8 * (v366 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v368 = &v354[-v367];
      v363 -= v367;
      uint64_t v369 = &v362[8 * v358 - 16];
      long long v370 = v354 - 16;
      uint64_t v371 = v366 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v373 = *((_OWORD *)v370 - 1);
        long long v372 = *(_OWORD *)v370;
        *((_OWORD *)v370 - 1) = 0uLL;
        *(_OWORD *)long long v370 = 0uLL;
        *((_OWORD *)v369 - 1) = v373;
        *(_OWORD *)uint64_t v369 = v372;
        v369 -= 32;
        v370 -= 32;
        v371 -= 4;
      }
      while (v371);
      int64_t v354 = v368;
      if (v366 != (v366 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_981:
        do
        {
          uint64_t v374 = *((void *)v354 - 1);
          v354 -= 8;
          *(void *)int64_t v354 = 0;
          *((void *)v363 - 1) = v374;
          v363 -= 8;
        }
        while (v354 != v356);
      }
      int64_t v354 = (char *)__p[0];
      uint64_t v375 = (char *)__p[1];
      __p[0] = v363;
      __p[1] = v355;
      v839[0] = v364;
      while (v375 != v354)
      {
        uint64_t v377 = *((void *)v375 - 1);
        v375 -= 8;
        uint64_t v376 = v377;
        *(void *)uint64_t v375 = 0;
        if (v377) {
          (*(void (**)(uint64_t))(*(void *)v376 + 8))(v376);
        }
      }
    }
    if (v354) {
      operator delete(v354);
    }
  }
  else
  {
    *(void *)__p[1] = v345;
    unint64_t v355 = v354 + 8;
  }
  __p[1] = v355;
  _ZN4mlir17RewritePatternSet6insertIJNS_3mps12_GLOBAL__N_121CanonicalizeReductionINS2_17ReductionArgMaxOpEEENS4_INS2_17ReductionArgMinOpEEENS4_INS2_14ReductionMaxOpEEENS4_INS2_14ReductionMinOpEEENS4_INS2_15ReductionProdOpEEENS4_INS2_14ReductionSumOpEEENS3_25CanonicalizeReductionAxesIS5_EENSH_IS7_EENSH_IS9_EENSH_ISB_EENSH_ISD_EENSH_ISF_EENS3_27CanonicalizeMatMulTransposeENS3_20CanonicalizeMatMul1DENS3_27CanonicalizeConvToDepthwiseINS2_8Conv2DOpEEENSQ_INS2_20Conv2DDataGradientOpEEENS3_33CanonicalizeSparseMatMulTransposeENS3_35CanonicalizeQuantizedMatmulTranposeENS3_7FuseRMSINS2_10MultiplyOpEEENSX_INS2_8DivideOpEEENS3_16CanonicalizeRoPEENS3_24CanonicalizeReadVariableEERPNS_11MLIRContextEJEvEERS0_OT0_DpOT1_(&v837, &v835);
  if (*((unsigned char *)this + 680))
  {
    unint64_t v378 = operator new(0x60uLL);
    uint64_t v379 = v835;
    mlir::PatternBenefit::PatternBenefit(v852, 2);
    mlir::Pattern::Pattern((uint64_t)(v378 + 1), (uint64_t)"mps.conv_2d", 11, *(__int16 *)v852, v379, 0, 0);
    void *v378 = &unk_1EC9C9F80;
    if (!v378[9])
    {
      *(void *)__int16 v852 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeQ"
                        "uantizedLayerScale<mlir::mps::Conv2DOp>]";
      *(void *)&v852[8] = 136;
      unint64_t v380 = llvm::StringRef::find((uint64_t *)v852, "DesiredTypeName = ", 0x12uLL, 0);
      if (*(void *)&v852[8] >= v380) {
        unint64_t v381 = v380;
      }
      else {
        unint64_t v381 = *(void *)&v852[8];
      }
      unint64_t v382 = *(void *)v852 + v381;
      unint64_t v383 = *(void *)&v852[8] - v381;
      if (*(void *)&v852[8] - v381 >= 0x12) {
        uint64_t v384 = 18;
      }
      else {
        uint64_t v384 = *(void *)&v852[8] - v381;
      }
      unint64_t v385 = v382 + v384;
      unint64_t v386 = v383 - v384;
      if (v386 >= v386 - 1) {
        --v386;
      }
      v378[8] = v385;
      v378[9] = v386;
    }
    unint64_t v387 = *((unsigned int *)v378 + 22);
    if (v387 > *((_DWORD *)v378 + 23))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v378 + 10), v378 + 12, v387, 16);
      LODWORD(v387) = *((_DWORD *)v378 + 22);
    }
    *((_DWORD *)v378 + 22) = v387;
    unint64_t v388 = (char *)__p[1];
    if (__p[1] >= v839[0])
    {
      uint64_t v409 = (char *)__p[0];
      int64_t v410 = (char *)__p[1] - (char *)__p[0];
      int64_t v411 = ((char *)__p[1] - (char *)__p[0]) >> 3;
      unint64_t v412 = v411 + 1;
      if ((unint64_t)(v411 + 1) >> 61) {
        goto LABEL_967;
      }
      int64_t v413 = (char *)v839[0] - (char *)__p[0];
      if (((char *)v839[0] - (char *)__p[0]) >> 2 > v412) {
        unint64_t v412 = v413 >> 2;
      }
      if ((unint64_t)v413 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v414 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v414 = v412;
      }
      if (v414)
      {
        if (v414 >> 61) {
          goto LABEL_968;
        }
        unint64_t v415 = (char *)operator new(8 * v414);
      }
      else
      {
        unint64_t v415 = 0;
      }
      uint64_t v416 = &v415[8 * v411];
      uint64_t v417 = (mlir::Operation *)&v415[8 * v414];
      *(void *)uint64_t v416 = v378;
      v389 = v416 + 8;
      if (v388 == v409)
      {
        __p[0] = &v415[8 * v411];
        __p[1] = v416 + 8;
        v839[0] = v417;
      }
      else
      {
        unint64_t v418 = v388 - v409 - 8;
        if (v418 < 0x78
          || &v388[-(v418 & 0xFFFFFFFFFFFFFFF8) - 8] < v416 && &v415[v410 - (v418 & 0xFFFFFFFFFFFFFFF8) - 8] < v388)
        {
          goto LABEL_982;
        }
        uint64_t v419 = (v418 >> 3) + 1;
        uint64_t v420 = 8 * (v419 & 0x3FFFFFFFFFFFFFFCLL);
        unint64_t v421 = &v388[-v420];
        v416 -= v420;
        uint64_t v422 = &v415[8 * v411 - 16];
        uint64_t v423 = v388 - 16;
        uint64_t v424 = v419 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v426 = *((_OWORD *)v423 - 1);
          long long v425 = *(_OWORD *)v423;
          *((_OWORD *)v423 - 1) = 0uLL;
          *(_OWORD *)uint64_t v423 = 0uLL;
          *((_OWORD *)v422 - 1) = v426;
          *(_OWORD *)uint64_t v422 = v425;
          v422 -= 32;
          v423 -= 32;
          v424 -= 4;
        }
        while (v424);
        unint64_t v388 = v421;
        if (v419 != (v419 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_982:
          do
          {
            uint64_t v427 = *((void *)v388 - 1);
            v388 -= 8;
            *(void *)unint64_t v388 = 0;
            *((void *)v416 - 1) = v427;
            v416 -= 8;
          }
          while (v388 != v409);
        }
        unint64_t v388 = (char *)__p[0];
        v428 = (char *)__p[1];
        __p[0] = v416;
        __p[1] = v389;
        v839[0] = v417;
        while (v428 != v388)
        {
          uint64_t v430 = *((void *)v428 - 1);
          v428 -= 8;
          uint64_t v429 = v430;
          *(void *)v428 = 0;
          if (v430) {
            (*(void (**)(uint64_t))(*(void *)v429 + 8))(v429);
          }
        }
      }
      if (v388) {
        operator delete(v388);
      }
    }
    else
    {
      *(void *)__p[1] = v378;
      v389 = v388 + 8;
    }
    __p[1] = v389;
    unint64_t v431 = operator new(0x60uLL);
    uint64_t v432 = v835;
    mlir::PatternBenefit::PatternBenefit(v852, 2);
    mlir::Pattern::Pattern((uint64_t)(v431 + 1), (uint64_t)"mps.depthwise_conv_3d", 21, *(__int16 *)v852, v432, 0, 0);
    *unint64_t v431 = &unk_1EC9C9ED0;
    if (!v431[9])
    {
      *(void *)__int16 v852 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeQ"
                        "uantizedLayerScale<mlir::mps::DepthwiseConv3DOp>]";
      *(void *)&v852[8] = 145;
      unint64_t v433 = llvm::StringRef::find((uint64_t *)v852, "DesiredTypeName = ", 0x12uLL, 0);
      if (*(void *)&v852[8] >= v433) {
        unint64_t v434 = v433;
      }
      else {
        unint64_t v434 = *(void *)&v852[8];
      }
      unint64_t v435 = *(void *)v852 + v434;
      unint64_t v436 = *(void *)&v852[8] - v434;
      if (*(void *)&v852[8] - v434 >= 0x12) {
        uint64_t v437 = 18;
      }
      else {
        uint64_t v437 = *(void *)&v852[8] - v434;
      }
      unint64_t v438 = v435 + v437;
      unint64_t v439 = v436 - v437;
      if (v439 >= v439 - 1) {
        --v439;
      }
      v431[8] = v438;
      v431[9] = v439;
    }
    unint64_t v440 = *((unsigned int *)v431 + 22);
    if (v440 > *((_DWORD *)v431 + 23))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v431 + 10), v431 + 12, v440, 16);
      LODWORD(v440) = *((_DWORD *)v431 + 22);
    }
    *((_DWORD *)v431 + 22) = v440;
    v441 = (char *)__p[1];
    if (__p[1] >= v839[0])
    {
      uint64_t v443 = (char *)__p[0];
      int64_t v444 = (char *)__p[1] - (char *)__p[0];
      int64_t v445 = ((char *)__p[1] - (char *)__p[0]) >> 3;
      unint64_t v446 = v445 + 1;
      if ((unint64_t)(v445 + 1) >> 61) {
        goto LABEL_967;
      }
      int64_t v447 = (char *)v839[0] - (char *)__p[0];
      if (((char *)v839[0] - (char *)__p[0]) >> 2 > v446) {
        unint64_t v446 = v447 >> 2;
      }
      if ((unint64_t)v447 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v448 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v448 = v446;
      }
      if (v448)
      {
        if (v448 >> 61) {
          goto LABEL_968;
        }
        unint64_t v449 = (char *)operator new(8 * v448);
      }
      else
      {
        unint64_t v449 = 0;
      }
      uint64_t v450 = &v449[8 * v445];
      uint64_t v451 = (mlir::Operation *)&v449[8 * v448];
      *(void *)uint64_t v450 = v431;
      uint64_t v442 = v450 + 8;
      if (v441 == v443)
      {
        __p[0] = &v449[8 * v445];
        __p[1] = v450 + 8;
        v839[0] = v451;
      }
      else
      {
        unint64_t v452 = v441 - v443 - 8;
        if (v452 < 0x78
          || &v441[-(v452 & 0xFFFFFFFFFFFFFFF8) - 8] < v450 && &v449[v444 - (v452 & 0xFFFFFFFFFFFFFFF8) - 8] < v441)
        {
          goto LABEL_983;
        }
        uint64_t v453 = (v452 >> 3) + 1;
        uint64_t v454 = 8 * (v453 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v455 = &v441[-v454];
        v450 -= v454;
        uint64_t v456 = &v449[8 * v445 - 16];
        v457 = v441 - 16;
        uint64_t v458 = v453 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v460 = *((_OWORD *)v457 - 1);
          long long v459 = *(_OWORD *)v457;
          *((_OWORD *)v457 - 1) = 0uLL;
          *(_OWORD *)v457 = 0uLL;
          *((_OWORD *)v456 - 1) = v460;
          *(_OWORD *)uint64_t v456 = v459;
          v456 -= 32;
          v457 -= 32;
          v458 -= 4;
        }
        while (v458);
        v441 = v455;
        if (v453 != (v453 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_983:
          do
          {
            uint64_t v461 = *((void *)v441 - 1);
            v441 -= 8;
            *(void *)v441 = 0;
            *((void *)v450 - 1) = v461;
            v450 -= 8;
          }
          while (v441 != v443);
        }
        v441 = (char *)__p[0];
        v462 = (char *)__p[1];
        __p[0] = v450;
        __p[1] = v442;
        v839[0] = v451;
        while (v462 != v441)
        {
          uint64_t v464 = *((void *)v462 - 1);
          v462 -= 8;
          uint64_t v463 = v464;
          *(void *)v462 = 0;
          if (v464) {
            (*(void (**)(uint64_t))(*(void *)v463 + 8))(v463);
          }
        }
      }
      if (v441) {
        operator delete(v441);
      }
    }
    else
    {
      *(void *)__p[1] = v431;
      uint64_t v442 = v441 + 8;
    }
    __p[1] = v442;
    unint64_t v465 = operator new(0x60uLL);
    uint64_t v466 = v835;
    mlir::PatternBenefit::PatternBenefit(v852, 2);
    mlir::Pattern::Pattern((uint64_t)(v465 + 1), (uint64_t)"mps.depthwise_conv_3d_data_gradient", 35, *(__int16 *)v852, v466, 0, 0);
    void *v465 = &unk_1EC9C9F28;
    if (!v465[9])
    {
      *(void *)__int16 v852 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeQ"
                        "uantizedLayerScale<mlir::mps::DepthwiseConv3DDataGradientOp>]";
      *(void *)&v852[8] = 157;
      unint64_t v467 = llvm::StringRef::find((uint64_t *)v852, "DesiredTypeName = ", 0x12uLL, 0);
      if (*(void *)&v852[8] >= v467) {
        unint64_t v468 = v467;
      }
      else {
        unint64_t v468 = *(void *)&v852[8];
      }
      unint64_t v469 = *(void *)v852 + v468;
      unint64_t v470 = *(void *)&v852[8] - v468;
      if (*(void *)&v852[8] - v468 >= 0x12) {
        uint64_t v471 = 18;
      }
      else {
        uint64_t v471 = *(void *)&v852[8] - v468;
      }
      unint64_t v472 = v469 + v471;
      unint64_t v473 = v470 - v471;
      if (v473 >= v473 - 1) {
        --v473;
      }
      v465[8] = v472;
      v465[9] = v473;
    }
    unint64_t v474 = *((unsigned int *)v465 + 22);
    if (v474 > *((_DWORD *)v465 + 23))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v465 + 10), v465 + 12, v474, 16);
      LODWORD(v474) = *((_DWORD *)v465 + 22);
    }
    *((_DWORD *)v465 + 22) = v474;
    unint64_t v475 = (char *)__p[1];
    if (__p[1] >= v839[0])
    {
      uint64_t v477 = (char *)__p[0];
      int64_t v478 = (char *)__p[1] - (char *)__p[0];
      int64_t v479 = ((char *)__p[1] - (char *)__p[0]) >> 3;
      unint64_t v480 = v479 + 1;
      if ((unint64_t)(v479 + 1) >> 61) {
        goto LABEL_967;
      }
      int64_t v481 = (char *)v839[0] - (char *)__p[0];
      if (((char *)v839[0] - (char *)__p[0]) >> 2 > v480) {
        unint64_t v480 = v481 >> 2;
      }
      if ((unint64_t)v481 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v482 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v482 = v480;
      }
      if (v482)
      {
        if (v482 >> 61) {
          goto LABEL_968;
        }
        unint64_t v483 = (char *)operator new(8 * v482);
      }
      else
      {
        unint64_t v483 = 0;
      }
      uint64_t v484 = &v483[8 * v479];
      uint64_t v485 = (mlir::Operation *)&v483[8 * v482];
      *(void *)uint64_t v484 = v465;
      uint64_t v476 = v484 + 8;
      if (v475 == v477)
      {
        __p[0] = &v483[8 * v479];
        __p[1] = v484 + 8;
        v839[0] = v485;
      }
      else
      {
        unint64_t v486 = v475 - v477 - 8;
        if (v486 < 0x78
          || &v475[-(v486 & 0xFFFFFFFFFFFFFFF8) - 8] < v484 && &v483[v478 - (v486 & 0xFFFFFFFFFFFFFFF8) - 8] < v475)
        {
          goto LABEL_984;
        }
        uint64_t v487 = (v486 >> 3) + 1;
        uint64_t v488 = 8 * (v487 & 0x3FFFFFFFFFFFFFFCLL);
        v489 = &v475[-v488];
        v484 -= v488;
        unint64_t v490 = &v483[8 * v479 - 16];
        unint64_t v491 = v475 - 16;
        uint64_t v492 = v487 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v494 = *((_OWORD *)v491 - 1);
          long long v493 = *(_OWORD *)v491;
          *((_OWORD *)v491 - 1) = 0uLL;
          *(_OWORD *)unint64_t v491 = 0uLL;
          *((_OWORD *)v490 - 1) = v494;
          *(_OWORD *)unint64_t v490 = v493;
          v490 -= 32;
          v491 -= 32;
          v492 -= 4;
        }
        while (v492);
        unint64_t v475 = v489;
        if (v487 != (v487 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_984:
          do
          {
            uint64_t v495 = *((void *)v475 - 1);
            v475 -= 8;
            *(void *)unint64_t v475 = 0;
            *((void *)v484 - 1) = v495;
            v484 -= 8;
          }
          while (v475 != v477);
        }
        unint64_t v475 = (char *)__p[0];
        uint64_t v496 = (char *)__p[1];
        __p[0] = v484;
        __p[1] = v476;
        v839[0] = v485;
        while (v496 != v475)
        {
          uint64_t v498 = *((void *)v496 - 1);
          v496 -= 8;
          uint64_t v497 = v498;
          *(void *)uint64_t v496 = 0;
          if (v498) {
            (*(void (**)(uint64_t))(*(void *)v497 + 8))(v497);
          }
        }
      }
      if (v475) {
        operator delete(v475);
      }
    }
    else
    {
      *(void *)__p[1] = v465;
      uint64_t v476 = v475 + 8;
    }
    __p[1] = v476;
    uint64_t v390 = operator new(0x60uLL);
    uint64_t v499 = v835;
    mlir::PatternBenefit::PatternBenefit(v852, 2);
    mlir::Pattern::Pattern((uint64_t)(v390 + 1), (uint64_t)"mps.matmul", 10, *(__int16 *)v852, v499, 0, 0);
    *uint64_t v390 = &unk_1EC9C9FD8;
    if (!v390[9])
    {
      *(void *)__int16 v852 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeQ"
                        "uantizedLayerScale<mlir::mps::MatMulOp>]";
      *(void *)&v852[8] = 136;
      unint64_t v500 = llvm::StringRef::find((uint64_t *)v852, "DesiredTypeName = ", 0x12uLL, 0);
      if (*(void *)&v852[8] >= v500) {
        unint64_t v501 = v500;
      }
      else {
        unint64_t v501 = *(void *)&v852[8];
      }
      unint64_t v502 = *(void *)v852 + v501;
      unint64_t v503 = *(void *)&v852[8] - v501;
      if (*(void *)&v852[8] - v501 >= 0x12) {
        uint64_t v504 = 18;
      }
      else {
        uint64_t v504 = *(void *)&v852[8] - v501;
      }
      unint64_t v505 = v502 + v504;
      unint64_t v506 = v503 - v504;
      if (v506 >= v506 - 1) {
        --v506;
      }
      v390[8] = v505;
      v390[9] = v506;
    }
    unint64_t v507 = *((unsigned int *)v390 + 22);
    if (v507 > *((_DWORD *)v390 + 23))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v390 + 10), v390 + 12, v507, 16);
      LODWORD(v507) = *((_DWORD *)v390 + 22);
    }
    *((_DWORD *)v390 + 22) = v507;
    uint64_t v401 = (char *)__p[1];
    if (__p[1] < v839[0]) {
      goto LABEL_583;
    }
    uint64_t v509 = (char *)__p[0];
    int64_t v510 = (char *)__p[1] - (char *)__p[0];
    int64_t v511 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v512 = v511 + 1;
    if ((unint64_t)(v511 + 1) >> 61) {
      goto LABEL_967;
    }
    int64_t v513 = (char *)v839[0] - (char *)__p[0];
    if (((char *)v839[0] - (char *)__p[0]) >> 2 > v512) {
      unint64_t v512 = v513 >> 2;
    }
    if ((unint64_t)v513 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v514 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v514 = v512;
    }
    if (v514)
    {
      if (v514 >> 61) {
        goto LABEL_968;
      }
      unint64_t v515 = (char *)operator new(8 * v514);
    }
    else
    {
      unint64_t v515 = 0;
    }
    uint64_t v516 = &v515[8 * v511];
    unint64_t v517 = (mlir::Operation *)&v515[8 * v514];
    *(void *)uint64_t v516 = v390;
    uint64_t v508 = v516 + 8;
    if (v401 != v509)
    {
      unint64_t v518 = v401 - v509 - 8;
      if (v518 < 0x78
        || &v401[-(v518 & 0xFFFFFFFFFFFFFFF8) - 8] < v516 && &v515[v510 - (v518 & 0xFFFFFFFFFFFFFFF8) - 8] < v401)
      {
        goto LABEL_985;
      }
      uint64_t v519 = (v518 >> 3) + 1;
      uint64_t v520 = 8 * (v519 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v521 = &v401[-v520];
      v516 -= v520;
      unint64_t v522 = &v515[8 * v511 - 16];
      v523 = v401 - 16;
      uint64_t v524 = v519 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v526 = *((_OWORD *)v523 - 1);
        long long v525 = *(_OWORD *)v523;
        *((_OWORD *)v523 - 1) = 0uLL;
        *(_OWORD *)v523 = 0uLL;
        *((_OWORD *)v522 - 1) = v526;
        *(_OWORD *)unint64_t v522 = v525;
        v522 -= 32;
        v523 -= 32;
        v524 -= 4;
      }
      while (v524);
      uint64_t v401 = v521;
      if (v519 != (v519 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_985:
        do
        {
          uint64_t v527 = *((void *)v401 - 1);
          v401 -= 8;
          *(void *)uint64_t v401 = 0;
          *((void *)v516 - 1) = v527;
          v516 -= 8;
        }
        while (v401 != v509);
      }
      uint64_t v401 = (char *)__p[0];
      uint64_t v528 = (char *)__p[1];
      __p[0] = v516;
      __p[1] = v508;
      v839[0] = v517;
      while (v528 != v401)
      {
        uint64_t v530 = *((void *)v528 - 1);
        v528 -= 8;
        uint64_t v529 = v530;
        *(void *)uint64_t v528 = 0;
        if (v530) {
          (*(void (**)(uint64_t))(*(void *)v529 + 8))(v529);
        }
      }
      goto LABEL_620;
    }
  }
  else
  {
    uint64_t v390 = operator new(0x68uLL);
    uint64_t v391 = v835;
    int v392 = *((_DWORD *)this + 222);
    mlir::PatternBenefit::PatternBenefit(v852, 2);
    mlir::Pattern::Pattern((uint64_t)(v390 + 1), (uint64_t)"mps.matmul", 10, *(__int16 *)v852, v391, 0, 0);
    *uint64_t v390 = &unk_1EC97F108;
    *((_DWORD *)v390 + 24) = v392;
    if (!v390[9])
    {
      *(void *)__int16 v852 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::Conditionally"
                        "CanonicalizeQuantizedOp<mlir::mps::MatMulOp>]";
      *(void *)&v852[8] = 141;
      unint64_t v393 = llvm::StringRef::find((uint64_t *)v852, "DesiredTypeName = ", 0x12uLL, 0);
      if (*(void *)&v852[8] >= v393) {
        unint64_t v394 = v393;
      }
      else {
        unint64_t v394 = *(void *)&v852[8];
      }
      unint64_t v395 = *(void *)v852 + v394;
      unint64_t v396 = *(void *)&v852[8] - v394;
      if (*(void *)&v852[8] - v394 >= 0x12) {
        uint64_t v397 = 18;
      }
      else {
        uint64_t v397 = *(void *)&v852[8] - v394;
      }
      unint64_t v398 = v395 + v397;
      unint64_t v399 = v396 - v397;
      if (v399 >= v399 - 1) {
        --v399;
      }
      v390[8] = v398;
      v390[9] = v399;
    }
    unint64_t v400 = *((unsigned int *)v390 + 22);
    if (v400 > *((_DWORD *)v390 + 23))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v390 + 10), v390 + 12, v400, 16);
      LODWORD(v400) = *((_DWORD *)v390 + 22);
    }
    *((_DWORD *)v390 + 22) = v400;
    uint64_t v401 = (char *)__p[1];
    if (__p[1] < v839[0])
    {
LABEL_583:
      *(void *)uint64_t v401 = v390;
      uint64_t v508 = v401 + 8;
      goto LABEL_622;
    }
    v402 = (char *)__p[0];
    int64_t v403 = (char *)__p[1] - (char *)__p[0];
    int64_t v404 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v405 = v404 + 1;
    if ((unint64_t)(v404 + 1) >> 61) {
      goto LABEL_967;
    }
    int64_t v406 = (char *)v839[0] - (char *)__p[0];
    if (((char *)v839[0] - (char *)__p[0]) >> 2 > v405) {
      unint64_t v405 = v406 >> 2;
    }
    if ((unint64_t)v406 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v407 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v407 = v405;
    }
    if (v407)
    {
      if (v407 >> 61) {
        goto LABEL_968;
      }
      uint64_t v408 = (char *)operator new(8 * v407);
    }
    else
    {
      uint64_t v408 = 0;
    }
    uint64_t v516 = &v408[8 * v404];
    unint64_t v517 = (mlir::Operation *)&v408[8 * v407];
    *(void *)uint64_t v516 = v390;
    uint64_t v508 = v516 + 8;
    if (v401 != v402)
    {
      unint64_t v531 = v401 - v402 - 8;
      if (v531 < 0x78
        || &v401[-(v531 & 0xFFFFFFFFFFFFFFF8) - 8] < v516 && &v408[v403 - (v531 & 0xFFFFFFFFFFFFFFF8) - 8] < v401)
      {
        goto LABEL_986;
      }
      uint64_t v532 = (v531 >> 3) + 1;
      uint64_t v533 = 8 * (v532 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v534 = &v401[-v533];
      v516 -= v533;
      uint64_t v535 = &v408[8 * v404 - 16];
      uint64_t v536 = v401 - 16;
      uint64_t v537 = v532 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v539 = *((_OWORD *)v536 - 1);
        long long v538 = *(_OWORD *)v536;
        *((_OWORD *)v536 - 1) = 0uLL;
        *(_OWORD *)uint64_t v536 = 0uLL;
        *((_OWORD *)v535 - 1) = v539;
        *(_OWORD *)uint64_t v535 = v538;
        v535 -= 32;
        v536 -= 32;
        v537 -= 4;
      }
      while (v537);
      uint64_t v401 = v534;
      if (v532 != (v532 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_986:
        do
        {
          uint64_t v540 = *((void *)v401 - 1);
          v401 -= 8;
          *(void *)uint64_t v401 = 0;
          *((void *)v516 - 1) = v540;
          v516 -= 8;
        }
        while (v401 != v402);
      }
      uint64_t v401 = (char *)__p[0];
      long long v541 = (char *)__p[1];
      __p[0] = v516;
      __p[1] = v508;
      v839[0] = v517;
      while (v541 != v401)
      {
        uint64_t v543 = *((void *)v541 - 1);
        v541 -= 8;
        uint64_t v542 = v543;
        *(void *)long long v541 = 0;
        if (v543) {
          (*(void (**)(uint64_t))(*(void *)v542 + 8))(v542);
        }
      }
      goto LABEL_620;
    }
  }
  __p[0] = v516;
  __p[1] = v508;
  v839[0] = v517;
LABEL_620:
  if (v401) {
    operator delete(v401);
  }
LABEL_622:
  __p[1] = v508;
  if (*((unsigned char *)this + 472))
  {
    uint64_t v544 = operator new(0x60uLL);
    uint64_t v545 = v835;
    mlir::PatternBenefit::PatternBenefit(v852, 1);
    mlir::Pattern::Pattern((uint64_t)(v544 + 1), (uint64_t)"mps.transpose", 13, *(__int16 *)v852, v545, 0, 0);
    *uint64_t v544 = &unk_1EC9C95F8;
    if (!v544[9])
    {
      *(void *)__int16 v852 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeMatMulNNToNT]";
      *(void *)&v852[8] = 108;
      unint64_t v546 = llvm::StringRef::find((uint64_t *)v852, "DesiredTypeName = ", 0x12uLL, 0);
      if (*(void *)&v852[8] >= v546) {
        unint64_t v547 = v546;
      }
      else {
        unint64_t v547 = *(void *)&v852[8];
      }
      unint64_t v548 = *(void *)v852 + v547;
      unint64_t v549 = *(void *)&v852[8] - v547;
      if (*(void *)&v852[8] - v547 >= 0x12) {
        uint64_t v550 = 18;
      }
      else {
        uint64_t v550 = *(void *)&v852[8] - v547;
      }
      unint64_t v551 = v548 + v550;
      unint64_t v552 = v549 - v550;
      if (v552 >= v552 - 1) {
        --v552;
      }
      v544[8] = v551;
      v544[9] = v552;
    }
    unint64_t v553 = *((unsigned int *)v544 + 22);
    if (v553 > *((_DWORD *)v544 + 23))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v544 + 10), v544 + 12, v553, 16);
      LODWORD(v553) = *((_DWORD *)v544 + 22);
    }
    *((_DWORD *)v544 + 22) = v553;
    unint64_t v554 = (char *)__p[1];
    if (__p[1] >= v839[0])
    {
      unint64_t v556 = (char *)__p[0];
      int64_t v557 = (char *)__p[1] - (char *)__p[0];
      int64_t v558 = ((char *)__p[1] - (char *)__p[0]) >> 3;
      unint64_t v559 = v558 + 1;
      if ((unint64_t)(v558 + 1) >> 61) {
        goto LABEL_967;
      }
      int64_t v560 = (char *)v839[0] - (char *)__p[0];
      if (((char *)v839[0] - (char *)__p[0]) >> 2 > v559) {
        unint64_t v559 = v560 >> 2;
      }
      if ((unint64_t)v560 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v561 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v561 = v559;
      }
      if (v561)
      {
        if (v561 >> 61) {
          goto LABEL_968;
        }
        uint64_t v562 = (char *)operator new(8 * v561);
      }
      else
      {
        uint64_t v562 = 0;
      }
      unint64_t v563 = &v562[8 * v558];
      long long v564 = (mlir::Operation *)&v562[8 * v561];
      *(void *)unint64_t v563 = v544;
      unint64_t v555 = v563 + 8;
      if (v554 == v556)
      {
        __p[0] = &v562[8 * v558];
        __p[1] = v563 + 8;
        v839[0] = v564;
      }
      else
      {
        unint64_t v565 = v554 - v556 - 8;
        if (v565 < 0x78
          || &v554[-(v565 & 0xFFFFFFFFFFFFFFF8) - 8] < v563 && &v562[v557 - (v565 & 0xFFFFFFFFFFFFFFF8) - 8] < v554)
        {
          goto LABEL_987;
        }
        uint64_t v566 = (v565 >> 3) + 1;
        uint64_t v567 = 8 * (v566 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v568 = &v554[-v567];
        v563 -= v567;
        uint64_t v569 = &v562[8 * v558 - 16];
        v570 = v554 - 16;
        uint64_t v571 = v566 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v573 = *((_OWORD *)v570 - 1);
          long long v572 = *(_OWORD *)v570;
          *((_OWORD *)v570 - 1) = 0uLL;
          *(_OWORD *)v570 = 0uLL;
          *((_OWORD *)v569 - 1) = v573;
          *(_OWORD *)uint64_t v569 = v572;
          v569 -= 32;
          v570 -= 32;
          v571 -= 4;
        }
        while (v571);
        unint64_t v554 = v568;
        if (v566 != (v566 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_987:
          do
          {
            uint64_t v574 = *((void *)v554 - 1);
            v554 -= 8;
            *(void *)unint64_t v554 = 0;
            *((void *)v563 - 1) = v574;
            v563 -= 8;
          }
          while (v554 != v556);
        }
        unint64_t v554 = (char *)__p[0];
        long long v575 = (char *)__p[1];
        __p[0] = v563;
        __p[1] = v555;
        v839[0] = v564;
        while (v575 != v554)
        {
          uint64_t v577 = *((void *)v575 - 1);
          v575 -= 8;
          uint64_t v576 = v577;
          *(void *)long long v575 = 0;
          if (v577) {
            (*(void (**)(uint64_t))(*(void *)v576 + 8))(v576);
          }
        }
      }
      if (v554) {
        operator delete(v554);
      }
    }
    else
    {
      *(void *)__p[1] = v544;
      unint64_t v555 = v554 + 8;
    }
    __p[1] = v555;
  }
  if (*((unsigned char *)this + 1304))
  {
    uint64_t v578 = operator new(0x60uLL);
    uint64_t v579 = v835;
    mlir::PatternBenefit::PatternBenefit(v852, 1);
    mlir::Pattern::Pattern((uint64_t)(v578 + 1), (uint64_t)"mps.reshape", 11, *(__int16 *)v852, v579, 0, 0);
    void *v578 = &unk_1EC9D1300;
    if (!v578[9])
    {
      *(void *)__int16 v852 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::ReshapeConvBiasReshape]";
      *(void *)&v852[8] = 106;
      unint64_t v580 = llvm::StringRef::find((uint64_t *)v852, "DesiredTypeName = ", 0x12uLL, 0);
      if (*(void *)&v852[8] >= v580) {
        unint64_t v581 = v580;
      }
      else {
        unint64_t v581 = *(void *)&v852[8];
      }
      unint64_t v582 = *(void *)v852 + v581;
      unint64_t v583 = *(void *)&v852[8] - v581;
      if (*(void *)&v852[8] - v581 >= 0x12) {
        uint64_t v584 = 18;
      }
      else {
        uint64_t v584 = *(void *)&v852[8] - v581;
      }
      unint64_t v585 = v582 + v584;
      unint64_t v586 = v583 - v584;
      if (v586 >= v586 - 1) {
        --v586;
      }
      v578[8] = v585;
      v578[9] = v586;
    }
    unint64_t v587 = *((unsigned int *)v578 + 22);
    if (v587 > *((_DWORD *)v578 + 23))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v578 + 10), v578 + 12, v587, 16);
      LODWORD(v587) = *((_DWORD *)v578 + 22);
    }
    *((_DWORD *)v578 + 22) = v587;
    unint64_t v588 = (char *)__p[1];
    if (__p[1] >= v839[0])
    {
      unint64_t v590 = (char *)__p[0];
      int64_t v591 = (char *)__p[1] - (char *)__p[0];
      int64_t v592 = ((char *)__p[1] - (char *)__p[0]) >> 3;
      unint64_t v593 = v592 + 1;
      if ((unint64_t)(v592 + 1) >> 61) {
        goto LABEL_967;
      }
      int64_t v594 = (char *)v839[0] - (char *)__p[0];
      if (((char *)v839[0] - (char *)__p[0]) >> 2 > v593) {
        unint64_t v593 = v594 >> 2;
      }
      if ((unint64_t)v594 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v595 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v595 = v593;
      }
      if (v595)
      {
        if (v595 >> 61) {
          goto LABEL_968;
        }
        uint64_t v596 = (char *)operator new(8 * v595);
      }
      else
      {
        uint64_t v596 = 0;
      }
      unint64_t v597 = &v596[8 * v592];
      v598 = (mlir::Operation *)&v596[8 * v595];
      *(void *)unint64_t v597 = v578;
      unint64_t v589 = v597 + 8;
      if (v588 == v590)
      {
        __p[0] = &v596[8 * v592];
        __p[1] = v597 + 8;
        v839[0] = v598;
      }
      else
      {
        unint64_t v599 = v588 - v590 - 8;
        if (v599 < 0x78
          || &v588[-(v599 & 0xFFFFFFFFFFFFFFF8) - 8] < v597 && &v596[v591 - (v599 & 0xFFFFFFFFFFFFFFF8) - 8] < v588)
        {
          goto LABEL_988;
        }
        uint64_t v600 = (v599 >> 3) + 1;
        uint64_t v601 = 8 * (v600 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v602 = &v588[-v601];
        v597 -= v601;
        uint64_t v603 = &v596[8 * v592 - 16];
        uint64_t v604 = v588 - 16;
        uint64_t v605 = v600 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v607 = *((_OWORD *)v604 - 1);
          long long v606 = *(_OWORD *)v604;
          *((_OWORD *)v604 - 1) = 0uLL;
          *(_OWORD *)uint64_t v604 = 0uLL;
          *((_OWORD *)v603 - 1) = v607;
          *(_OWORD *)uint64_t v603 = v606;
          v603 -= 32;
          v604 -= 32;
          v605 -= 4;
        }
        while (v605);
        unint64_t v588 = v602;
        if (v600 != (v600 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_988:
          do
          {
            uint64_t v608 = *((void *)v588 - 1);
            v588 -= 8;
            *(void *)unint64_t v588 = 0;
            *((void *)v597 - 1) = v608;
            v597 -= 8;
          }
          while (v588 != v590);
        }
        unint64_t v588 = (char *)__p[0];
        long long v609 = (char *)__p[1];
        __p[0] = v597;
        __p[1] = v589;
        v839[0] = v598;
        while (v609 != v588)
        {
          uint64_t v611 = *((void *)v609 - 1);
          v609 -= 8;
          uint64_t v610 = v611;
          *(void *)long long v609 = 0;
          if (v611) {
            (*(void (**)(uint64_t))(*(void *)v610 + 8))(v610);
          }
        }
      }
      if (v588) {
        operator delete(v588);
      }
    }
    else
    {
      *(void *)__p[1] = v578;
      unint64_t v589 = v588 + 8;
    }
    __p[1] = v589;
  }
  uint64_t v612 = operator new(0x68uLL);
  uint64_t v613 = v835;
  char v614 = *((unsigned char *)this + 1096);
  mlir::PatternBenefit::PatternBenefit(v852, 1);
  mlir::Pattern::Pattern((uint64_t)(v612 + 8), (uint64_t)"mps.conv_2d", 11, *(__int16 *)v852, v613, 0, 0);
  *(void *)uint64_t v612 = &unk_1EC97EEF8;
  v612[96] = v614;
  if (!*((void *)v612 + 9))
  {
    *(void *)__int16 v852 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeCon"
                      "vToMatMul<mlir::mps::Conv2DOp>]";
    *(void *)&v852[8] = 129;
    unint64_t v615 = llvm::StringRef::find((uint64_t *)v852, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(void *)&v852[8] >= v615) {
      unint64_t v616 = v615;
    }
    else {
      unint64_t v616 = *(void *)&v852[8];
    }
    unint64_t v617 = *(void *)v852 + v616;
    unint64_t v618 = *(void *)&v852[8] - v616;
    if (*(void *)&v852[8] - v616 >= 0x12) {
      uint64_t v619 = 18;
    }
    else {
      uint64_t v619 = *(void *)&v852[8] - v616;
    }
    unint64_t v620 = v617 + v619;
    unint64_t v621 = v618 - v619;
    if (v621 >= v621 - 1) {
      --v621;
    }
    *((void *)v612 + 8) = v620;
    *((void *)v612 + 9) = v621;
  }
  unint64_t v622 = *((unsigned int *)v612 + 22);
  if (v622 > *((_DWORD *)v612 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v612 + 80), v612 + 96, v622, 16);
    LODWORD(v622) = *((_DWORD *)v612 + 22);
  }
  *((_DWORD *)v612 + 22) = v622;
  unint64_t v623 = (char *)__p[1];
  if (__p[1] >= v839[0])
  {
    uint64_t v625 = (char *)__p[0];
    int64_t v626 = (char *)__p[1] - (char *)__p[0];
    int64_t v627 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v628 = v627 + 1;
    if ((unint64_t)(v627 + 1) >> 61) {
      goto LABEL_967;
    }
    int64_t v629 = (char *)v839[0] - (char *)__p[0];
    if (((char *)v839[0] - (char *)__p[0]) >> 2 > v628) {
      unint64_t v628 = v629 >> 2;
    }
    if ((unint64_t)v629 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v630 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v630 = v628;
    }
    if (v630)
    {
      if (v630 >> 61) {
        goto LABEL_968;
      }
      unint64_t v631 = (char *)operator new(8 * v630);
    }
    else
    {
      unint64_t v631 = 0;
    }
    uint64_t v632 = &v631[8 * v627];
    uint64_t v633 = (mlir::Operation *)&v631[8 * v630];
    *(void *)uint64_t v632 = v612;
    unint64_t v624 = v632 + 8;
    if (v623 == v625)
    {
      __p[0] = &v631[8 * v627];
      __p[1] = v632 + 8;
      v839[0] = v633;
    }
    else
    {
      unint64_t v634 = v623 - v625 - 8;
      if (v634 < 0x78
        || &v623[-(v634 & 0xFFFFFFFFFFFFFFF8) - 8] < v632 && &v631[v626 - (v634 & 0xFFFFFFFFFFFFFFF8) - 8] < v623)
      {
        goto LABEL_989;
      }
      uint64_t v635 = (v634 >> 3) + 1;
      uint64_t v636 = 8 * (v635 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v637 = &v623[-v636];
      v632 -= v636;
      v638 = &v631[8 * v627 - 16];
      v639 = v623 - 16;
      uint64_t v640 = v635 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v642 = *((_OWORD *)v639 - 1);
        long long v641 = *(_OWORD *)v639;
        *((_OWORD *)v639 - 1) = 0uLL;
        *(_OWORD *)v639 = 0uLL;
        *((_OWORD *)v638 - 1) = v642;
        *(_OWORD *)v638 = v641;
        v638 -= 32;
        v639 -= 32;
        v640 -= 4;
      }
      while (v640);
      unint64_t v623 = v637;
      if (v635 != (v635 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_989:
        do
        {
          uint64_t v643 = *((void *)v623 - 1);
          v623 -= 8;
          *(void *)unint64_t v623 = 0;
          *((void *)v632 - 1) = v643;
          v632 -= 8;
        }
        while (v623 != v625);
      }
      unint64_t v623 = (char *)__p[0];
      uint64_t v644 = (char *)__p[1];
      __p[0] = v632;
      __p[1] = v624;
      v839[0] = v633;
      while (v644 != v623)
      {
        uint64_t v646 = *((void *)v644 - 1);
        v644 -= 8;
        uint64_t v645 = v646;
        *(void *)uint64_t v644 = 0;
        if (v646) {
          (*(void (**)(uint64_t))(*(void *)v645 + 8))(v645);
        }
      }
    }
    if (v623) {
      operator delete(v623);
    }
  }
  else
  {
    *(void *)__p[1] = v612;
    unint64_t v624 = v623 + 8;
  }
  __p[1] = v624;
  uint64_t v647 = operator new(0x68uLL);
  uint64_t v648 = v835;
  char v649 = *((unsigned char *)this + 1096);
  mlir::PatternBenefit::PatternBenefit(v852, 1);
  mlir::Pattern::Pattern((uint64_t)(v647 + 8), (uint64_t)"mps.conv_2d_data_gradient", 25, *(__int16 *)v852, v648, 0, 0);
  *(void *)uint64_t v647 = &unk_1EC97EDF0;
  v647[96] = v649;
  if (!*((void *)v647 + 9))
  {
    *(void *)__int16 v852 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeCon"
                      "vToMatMul<mlir::mps::Conv2DDataGradientOp>]";
    *(void *)&v852[8] = 141;
    unint64_t v650 = llvm::StringRef::find((uint64_t *)v852, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(void *)&v852[8] >= v650) {
      unint64_t v651 = v650;
    }
    else {
      unint64_t v651 = *(void *)&v852[8];
    }
    unint64_t v652 = *(void *)v852 + v651;
    unint64_t v653 = *(void *)&v852[8] - v651;
    if (*(void *)&v852[8] - v651 >= 0x12) {
      uint64_t v654 = 18;
    }
    else {
      uint64_t v654 = *(void *)&v852[8] - v651;
    }
    unint64_t v655 = v652 + v654;
    unint64_t v656 = v653 - v654;
    if (v656 >= v656 - 1) {
      --v656;
    }
    *((void *)v647 + 8) = v655;
    *((void *)v647 + 9) = v656;
  }
  unint64_t v657 = *((unsigned int *)v647 + 22);
  if (v657 > *((_DWORD *)v647 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v647 + 80), v647 + 96, v657, 16);
    LODWORD(v657) = *((_DWORD *)v647 + 22);
  }
  *((_DWORD *)v647 + 22) = v657;
  unint64_t v658 = (char *)__p[1];
  if (__p[1] >= v839[0])
  {
    v660 = (char *)__p[0];
    int64_t v661 = (char *)__p[1] - (char *)__p[0];
    int64_t v662 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v663 = v662 + 1;
    if ((unint64_t)(v662 + 1) >> 61) {
      goto LABEL_967;
    }
    int64_t v664 = (char *)v839[0] - (char *)__p[0];
    if (((char *)v839[0] - (char *)__p[0]) >> 2 > v663) {
      unint64_t v663 = v664 >> 2;
    }
    if ((unint64_t)v664 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v665 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v665 = v663;
    }
    if (v665)
    {
      if (v665 >> 61) {
        goto LABEL_968;
      }
      v666 = (char *)operator new(8 * v665);
    }
    else
    {
      v666 = 0;
    }
    unint64_t v667 = &v666[8 * v662];
    v668 = (mlir::Operation *)&v666[8 * v665];
    *(void *)unint64_t v667 = v647;
    unint64_t v659 = v667 + 8;
    if (v658 == v660)
    {
      __p[0] = &v666[8 * v662];
      __p[1] = v667 + 8;
      v839[0] = v668;
    }
    else
    {
      unint64_t v669 = v658 - v660 - 8;
      if (v669 < 0x78
        || &v658[-(v669 & 0xFFFFFFFFFFFFFFF8) - 8] < v667 && &v666[v661 - (v669 & 0xFFFFFFFFFFFFFFF8) - 8] < v658)
      {
        goto LABEL_990;
      }
      uint64_t v670 = (v669 >> 3) + 1;
      uint64_t v671 = 8 * (v670 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v672 = &v658[-v671];
      v667 -= v671;
      uint64_t v673 = &v666[8 * v662 - 16];
      v674 = v658 - 16;
      uint64_t v675 = v670 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v677 = *((_OWORD *)v674 - 1);
        long long v676 = *(_OWORD *)v674;
        *((_OWORD *)v674 - 1) = 0uLL;
        *(_OWORD *)v674 = 0uLL;
        *((_OWORD *)v673 - 1) = v677;
        *(_OWORD *)uint64_t v673 = v676;
        v673 -= 32;
        v674 -= 32;
        v675 -= 4;
      }
      while (v675);
      unint64_t v658 = v672;
      if (v670 != (v670 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_990:
        do
        {
          uint64_t v678 = *((void *)v658 - 1);
          v658 -= 8;
          *(void *)unint64_t v658 = 0;
          *((void *)v667 - 1) = v678;
          v667 -= 8;
        }
        while (v658 != v660);
      }
      unint64_t v658 = (char *)__p[0];
      v679 = (char *)__p[1];
      __p[0] = v667;
      __p[1] = v659;
      v839[0] = v668;
      while (v679 != v658)
      {
        uint64_t v681 = *((void *)v679 - 1);
        v679 -= 8;
        uint64_t v680 = v681;
        *(void *)v679 = 0;
        if (v681) {
          (*(void (**)(uint64_t))(*(void *)v680 + 8))(v680);
        }
      }
    }
    if (v658) {
      operator delete(v658);
    }
  }
  else
  {
    *(void *)__p[1] = v647;
    unint64_t v659 = v658 + 8;
  }
  __p[1] = v659;
  uint64_t v682 = operator new(0x68uLL);
  uint64_t v683 = v835;
  char v684 = *((unsigned char *)this + 1096);
  mlir::PatternBenefit::PatternBenefit(v852, 1);
  mlir::Pattern::Pattern((uint64_t)(v682 + 8), (uint64_t)"mps.conv_3d", 11, *(__int16 *)v852, v683, 0, 0);
  *(void *)uint64_t v682 = &unk_1EC97EF50;
  v682[96] = v684;
  if (!*((void *)v682 + 9))
  {
    *(void *)__int16 v852 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeCon"
                      "vToMatMul<mlir::mps::Conv3DOp>]";
    *(void *)&v852[8] = 129;
    unint64_t v685 = llvm::StringRef::find((uint64_t *)v852, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(void *)&v852[8] >= v685) {
      unint64_t v686 = v685;
    }
    else {
      unint64_t v686 = *(void *)&v852[8];
    }
    unint64_t v687 = *(void *)v852 + v686;
    unint64_t v688 = *(void *)&v852[8] - v686;
    if (*(void *)&v852[8] - v686 >= 0x12) {
      uint64_t v689 = 18;
    }
    else {
      uint64_t v689 = *(void *)&v852[8] - v686;
    }
    unint64_t v690 = v687 + v689;
    unint64_t v691 = v688 - v689;
    if (v691 >= v691 - 1) {
      --v691;
    }
    *((void *)v682 + 8) = v690;
    *((void *)v682 + 9) = v691;
  }
  unint64_t v692 = *((unsigned int *)v682 + 22);
  if (v692 > *((_DWORD *)v682 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v682 + 80), v682 + 96, v692, 16);
    LODWORD(v692) = *((_DWORD *)v682 + 22);
  }
  *((_DWORD *)v682 + 22) = v692;
  v693 = (char *)__p[1];
  if (__p[1] >= v839[0])
  {
    v695 = (char *)__p[0];
    int64_t v696 = (char *)__p[1] - (char *)__p[0];
    int64_t v697 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v698 = v697 + 1;
    if ((unint64_t)(v697 + 1) >> 61) {
      goto LABEL_967;
    }
    int64_t v699 = (char *)v839[0] - (char *)__p[0];
    if (((char *)v839[0] - (char *)__p[0]) >> 2 > v698) {
      unint64_t v698 = v699 >> 2;
    }
    if ((unint64_t)v699 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v700 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v700 = v698;
    }
    if (v700)
    {
      if (v700 >> 61) {
        goto LABEL_968;
      }
      v701 = (char *)operator new(8 * v700);
    }
    else
    {
      v701 = 0;
    }
    char v702 = &v701[8 * v697];
    unint64_t v703 = (mlir::Operation *)&v701[8 * v700];
    *(void *)char v702 = v682;
    char v694 = v702 + 8;
    if (v693 == v695)
    {
      __p[0] = &v701[8 * v697];
      __p[1] = v702 + 8;
      v839[0] = v703;
    }
    else
    {
      unint64_t v704 = v693 - v695 - 8;
      if (v704 < 0x78
        || &v693[-(v704 & 0xFFFFFFFFFFFFFFF8) - 8] < v702 && &v701[v696 - (v704 & 0xFFFFFFFFFFFFFFF8) - 8] < v693)
      {
        goto LABEL_991;
      }
      uint64_t v705 = (v704 >> 3) + 1;
      uint64_t v706 = 8 * (v705 & 0x3FFFFFFFFFFFFFFCLL);
      v707 = &v693[-v706];
      v702 -= v706;
      unint64_t v708 = &v701[8 * v697 - 16];
      uint64_t v709 = v693 - 16;
      uint64_t v710 = v705 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v712 = *((_OWORD *)v709 - 1);
        long long v711 = *(_OWORD *)v709;
        *((_OWORD *)v709 - 1) = 0uLL;
        *(_OWORD *)uint64_t v709 = 0uLL;
        *((_OWORD *)v708 - 1) = v712;
        *(_OWORD *)unint64_t v708 = v711;
        v708 -= 32;
        v709 -= 32;
        v710 -= 4;
      }
      while (v710);
      v693 = v707;
      if (v705 != (v705 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_991:
        do
        {
          uint64_t v713 = *((void *)v693 - 1);
          v693 -= 8;
          *(void *)v693 = 0;
          *((void *)v702 - 1) = v713;
          v702 -= 8;
        }
        while (v693 != v695);
      }
      v693 = (char *)__p[0];
      uint64_t v714 = (char *)__p[1];
      __p[0] = v702;
      __p[1] = v694;
      v839[0] = v703;
      while (v714 != v693)
      {
        uint64_t v716 = *((void *)v714 - 1);
        v714 -= 8;
        uint64_t v715 = v716;
        *(void *)uint64_t v714 = 0;
        if (v716) {
          (*(void (**)(uint64_t))(*(void *)v715 + 8))(v715);
        }
      }
    }
    if (v693) {
      operator delete(v693);
    }
  }
  else
  {
    *(void *)__p[1] = v682;
    char v694 = v693 + 8;
  }
  __p[1] = v694;
  v717 = operator new(0x68uLL);
  uint64_t v718 = v835;
  char v719 = *((unsigned char *)this + 1096);
  mlir::PatternBenefit::PatternBenefit(v852, 1);
  mlir::Pattern::Pattern((uint64_t)(v717 + 8), (uint64_t)"mps.conv_3d_data_gradient", 25, *(__int16 *)v852, v718, 0, 0);
  *(void *)v717 = &unk_1EC97EE48;
  v717[96] = v719;
  if (!*((void *)v717 + 9))
  {
    *(void *)__int16 v852 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeCon"
                      "vToMatMul<mlir::mps::Conv3DDataGradientOp>]";
    *(void *)&v852[8] = 141;
    unint64_t v720 = llvm::StringRef::find((uint64_t *)v852, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(void *)&v852[8] >= v720) {
      unint64_t v721 = v720;
    }
    else {
      unint64_t v721 = *(void *)&v852[8];
    }
    unint64_t v722 = *(void *)v852 + v721;
    unint64_t v723 = *(void *)&v852[8] - v721;
    if (*(void *)&v852[8] - v721 >= 0x12) {
      uint64_t v724 = 18;
    }
    else {
      uint64_t v724 = *(void *)&v852[8] - v721;
    }
    unint64_t v725 = v722 + v724;
    unint64_t v726 = v723 - v724;
    if (v726 >= v726 - 1) {
      --v726;
    }
    *((void *)v717 + 8) = v725;
    *((void *)v717 + 9) = v726;
  }
  unint64_t v727 = *((unsigned int *)v717 + 22);
  if (v727 > *((_DWORD *)v717 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v717 + 80), v717 + 96, v727, 16);
    LODWORD(v727) = *((_DWORD *)v717 + 22);
  }
  *((_DWORD *)v717 + 22) = v727;
  v728 = (char *)__p[1];
  if (__p[1] >= v839[0])
  {
    uint64_t v730 = (char *)__p[0];
    int64_t v731 = (char *)__p[1] - (char *)__p[0];
    int64_t v732 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v733 = v732 + 1;
    if ((unint64_t)(v732 + 1) >> 61) {
      goto LABEL_967;
    }
    int64_t v734 = (char *)v839[0] - (char *)__p[0];
    if (((char *)v839[0] - (char *)__p[0]) >> 2 > v733) {
      unint64_t v733 = v734 >> 2;
    }
    if ((unint64_t)v734 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v735 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v735 = v733;
    }
    if (v735)
    {
      if (v735 >> 61) {
        goto LABEL_968;
      }
      v736 = (char *)operator new(8 * v735);
    }
    else
    {
      v736 = 0;
    }
    unint64_t v737 = &v736[8 * v732];
    uint64_t v738 = (mlir::Operation *)&v736[8 * v735];
    *(void *)unint64_t v737 = v717;
    v729 = v737 + 8;
    if (v728 == v730)
    {
      __p[0] = &v736[8 * v732];
      __p[1] = v737 + 8;
      v839[0] = v738;
    }
    else
    {
      unint64_t v739 = v728 - v730 - 8;
      if (v739 < 0x78
        || &v728[-(v739 & 0xFFFFFFFFFFFFFFF8) - 8] < v737 && &v736[v731 - (v739 & 0xFFFFFFFFFFFFFFF8) - 8] < v728)
      {
        goto LABEL_992;
      }
      uint64_t v740 = (v739 >> 3) + 1;
      uint64_t v741 = 8 * (v740 & 0x3FFFFFFFFFFFFFFCLL);
      v742 = &v728[-v741];
      v737 -= v741;
      uint64_t v743 = &v736[8 * v732 - 16];
      long long v744 = v728 - 16;
      uint64_t v745 = v740 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v747 = *((_OWORD *)v744 - 1);
        long long v746 = *(_OWORD *)v744;
        *((_OWORD *)v744 - 1) = 0uLL;
        *(_OWORD *)long long v744 = 0uLL;
        *((_OWORD *)v743 - 1) = v747;
        *(_OWORD *)uint64_t v743 = v746;
        v743 -= 32;
        v744 -= 32;
        v745 -= 4;
      }
      while (v745);
      v728 = v742;
      if (v740 != (v740 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_992:
        do
        {
          uint64_t v748 = *((void *)v728 - 1);
          v728 -= 8;
          *(void *)v728 = 0;
          *((void *)v737 - 1) = v748;
          v737 -= 8;
        }
        while (v728 != v730);
      }
      v728 = (char *)__p[0];
      uint64_t v749 = (char *)__p[1];
      __p[0] = v737;
      __p[1] = v729;
      v839[0] = v738;
      while (v749 != v728)
      {
        uint64_t v751 = *((void *)v749 - 1);
        v749 -= 8;
        uint64_t v750 = v751;
        *(void *)uint64_t v749 = 0;
        if (v751) {
          (*(void (**)(uint64_t))(*(void *)v750 + 8))(v750);
        }
      }
    }
    if (v728) {
      operator delete(v728);
    }
  }
  else
  {
    *(void *)__p[1] = v717;
    v729 = v728 + 8;
  }
  __p[1] = v729;
  unint64_t v752 = operator new(0x68uLL);
  uint64_t v753 = v835;
  char v754 = *((unsigned char *)this + 1096);
  mlir::PatternBenefit::PatternBenefit(v852, 1);
  mlir::Pattern::Pattern((uint64_t)(v752 + 8), (uint64_t)"mps.bias_add", 12, *(__int16 *)v852, v753, 0, 0);
  *(void *)unint64_t v752 = &unk_1EC97EFA8;
  v752[96] = v754;
  if (!*((void *)v752 + 9))
  {
    *(void *)__int16 v852 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeCon"
                      "vToMatMul<mlir::mps::BiasAddOp>]";
    *(void *)&v852[8] = 130;
    unint64_t v755 = llvm::StringRef::find((uint64_t *)v852, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(void *)&v852[8] >= v755) {
      unint64_t v756 = v755;
    }
    else {
      unint64_t v756 = *(void *)&v852[8];
    }
    unint64_t v757 = *(void *)v852 + v756;
    unint64_t v758 = *(void *)&v852[8] - v756;
    if (*(void *)&v852[8] - v756 >= 0x12) {
      uint64_t v759 = 18;
    }
    else {
      uint64_t v759 = *(void *)&v852[8] - v756;
    }
    unint64_t v760 = v757 + v759;
    unint64_t v761 = v758 - v759;
    if (v761 >= v761 - 1) {
      --v761;
    }
    *((void *)v752 + 8) = v760;
    *((void *)v752 + 9) = v761;
  }
  unint64_t v762 = *((unsigned int *)v752 + 22);
  if (v762 > *((_DWORD *)v752 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v752 + 80), v752 + 96, v762, 16);
    LODWORD(v762) = *((_DWORD *)v752 + 22);
  }
  *((_DWORD *)v752 + 22) = v762;
  uint64_t v763 = (char *)__p[1];
  if (__p[1] >= v839[0])
  {
    unint64_t v765 = (char *)__p[0];
    int64_t v766 = (char *)__p[1] - (char *)__p[0];
    int64_t v767 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    unint64_t v768 = v767 + 1;
    if ((unint64_t)(v767 + 1) >> 61) {
      goto LABEL_967;
    }
    int64_t v769 = (char *)v839[0] - (char *)__p[0];
    if (((char *)v839[0] - (char *)__p[0]) >> 2 > v768) {
      unint64_t v768 = v769 >> 2;
    }
    if ((unint64_t)v769 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v770 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v770 = v768;
    }
    if (v770)
    {
      if (v770 >> 61) {
        goto LABEL_968;
      }
      unint64_t v771 = (char *)operator new(8 * v770);
    }
    else
    {
      unint64_t v771 = 0;
    }
    uint64_t v772 = &v771[8 * v767];
    uint64_t v773 = (mlir::Operation *)&v771[8 * v770];
    *(void *)uint64_t v772 = v752;
    uint64_t v764 = v772 + 8;
    if (v763 == v765)
    {
      __p[0] = &v771[8 * v767];
      __p[1] = v772 + 8;
      v839[0] = v773;
    }
    else
    {
      unint64_t v774 = v763 - v765 - 8;
      if (v774 < 0x78
        || &v763[-(v774 & 0xFFFFFFFFFFFFFFF8) - 8] < v772 && &v771[v766 - (v774 & 0xFFFFFFFFFFFFFFF8) - 8] < v763)
      {
        goto LABEL_993;
      }
      uint64_t v775 = (v774 >> 3) + 1;
      uint64_t v776 = 8 * (v775 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v777 = &v763[-v776];
      v772 -= v776;
      long long v778 = &v771[8 * v767 - 16];
      long long v779 = v763 - 16;
      uint64_t v780 = v775 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v782 = *((_OWORD *)v779 - 1);
        long long v781 = *(_OWORD *)v779;
        *((_OWORD *)v779 - 1) = 0uLL;
        *(_OWORD *)long long v779 = 0uLL;
        *((_OWORD *)v778 - 1) = v782;
        *(_OWORD *)long long v778 = v781;
        v778 -= 32;
        v779 -= 32;
        v780 -= 4;
      }
      while (v780);
      uint64_t v763 = v777;
      if (v775 != (v775 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_993:
        do
        {
          uint64_t v783 = *((void *)v763 - 1);
          v763 -= 8;
          *(void *)uint64_t v763 = 0;
          *((void *)v772 - 1) = v783;
          v772 -= 8;
        }
        while (v763 != v765);
      }
      uint64_t v763 = (char *)__p[0];
      uint64_t v784 = (char *)__p[1];
      __p[0] = v772;
      __p[1] = v764;
      v839[0] = v773;
      while (v784 != v763)
      {
        uint64_t v786 = *((void *)v784 - 1);
        v784 -= 8;
        uint64_t v785 = v786;
        *(void *)uint64_t v784 = 0;
        if (v786) {
          (*(void (**)(uint64_t))(*(void *)v785 + 8))(v785);
        }
      }
    }
    if (v763) {
      operator delete(v763);
    }
  }
  else
  {
    *(void *)__p[1] = v752;
    uint64_t v764 = v763 + 8;
  }
  __p[1] = v764;
  unint64_t v787 = operator new(0x68uLL);
  uint64_t v788 = v835;
  char v789 = *((unsigned char *)this + 1096);
  mlir::PatternBenefit::PatternBenefit(v852, 1);
  mlir::Pattern::Pattern((uint64_t)(v787 + 8), (uint64_t)"mps.add", 7, *(__int16 *)v852, v788, 0, 0);
  *(void *)unint64_t v787 = &unk_1EC97EEA0;
  v787[96] = v789;
  if (!*((void *)v787 + 9))
  {
    *(void *)__int16 v852 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeCon"
                      "vToMatMul<mlir::mps::AddOp>]";
    *(void *)&v852[8] = 126;
    unint64_t v790 = llvm::StringRef::find((uint64_t *)v852, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(void *)&v852[8] >= v790) {
      unint64_t v791 = v790;
    }
    else {
      unint64_t v791 = *(void *)&v852[8];
    }
    unint64_t v792 = *(void *)v852 + v791;
    unint64_t v793 = *(void *)&v852[8] - v791;
    if (*(void *)&v852[8] - v791 >= 0x12) {
      uint64_t v794 = 18;
    }
    else {
      uint64_t v794 = *(void *)&v852[8] - v791;
    }
    unint64_t v795 = v792 + v794;
    unint64_t v796 = v793 - v794;
    if (v796 >= v796 - 1) {
      --v796;
    }
    *((void *)v787 + 8) = v795;
    *((void *)v787 + 9) = v796;
  }
  unint64_t v797 = *((unsigned int *)v787 + 22);
  if (v797 > *((_DWORD *)v787 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v787 + 80), v787 + 96, v797, 16);
    LODWORD(v797) = *((_DWORD *)v787 + 22);
  }
  *((_DWORD *)v787 + 22) = v797;
  uint64_t v798 = (char *)__p[1];
  if (__p[1] < v839[0])
  {
    *(void *)__p[1] = v787;
    unint64_t v799 = v798 + 8;
    goto LABEL_938;
  }
  uint64_t v800 = (char *)__p[0];
  int64_t v801 = (char *)__p[1] - (char *)__p[0];
  int64_t v802 = ((char *)__p[1] - (char *)__p[0]) >> 3;
  unint64_t v803 = v802 + 1;
  if (!((unint64_t)(v802 + 1) >> 61))
  {
    int64_t v804 = (char *)v839[0] - (char *)__p[0];
    if (((char *)v839[0] - (char *)__p[0]) >> 2 > v803) {
      unint64_t v803 = v804 >> 2;
    }
    if ((unint64_t)v804 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v805 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v805 = v803;
    }
    if (!v805)
    {
      uint64_t v806 = 0;
      goto LABEL_923;
    }
    if (!(v805 >> 61))
    {
      uint64_t v806 = (char *)operator new(8 * v805);
LABEL_923:
      uint64_t v807 = &v806[8 * v802];
      char v808 = (mlir::Operation *)&v806[8 * v805];
      *(void *)uint64_t v807 = v787;
      unint64_t v799 = v807 + 8;
      if (v798 == v800)
      {
        __p[0] = &v806[8 * v802];
        __p[1] = v807 + 8;
        v839[0] = v808;
      }
      else
      {
        unint64_t v809 = v798 - v800 - 8;
        if (v809 < 0x78
          || &v798[-(v809 & 0xFFFFFFFFFFFFFFF8) - 8] < v807 && &v806[v801 - (v809 & 0xFFFFFFFFFFFFFFF8) - 8] < v798)
        {
          goto LABEL_994;
        }
        uint64_t v810 = (v809 >> 3) + 1;
        uint64_t v811 = 8 * (v810 & 0x3FFFFFFFFFFFFFFCLL);
        long long v812 = &v798[-v811];
        v807 -= v811;
        long long v813 = &v806[8 * v802 - 16];
        uint64_t v814 = v798 - 16;
        uint64_t v815 = v810 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v817 = *((_OWORD *)v814 - 1);
          long long v816 = *(_OWORD *)v814;
          *((_OWORD *)v814 - 1) = 0uLL;
          *(_OWORD *)uint64_t v814 = 0uLL;
          *((_OWORD *)v813 - 1) = v817;
          *(_OWORD *)long long v813 = v816;
          v813 -= 32;
          v814 -= 32;
          v815 -= 4;
        }
        while (v815);
        uint64_t v798 = v812;
        if (v810 != (v810 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_994:
          do
          {
            uint64_t v818 = *((void *)v798 - 1);
            v798 -= 8;
            *(void *)uint64_t v798 = 0;
            *((void *)v807 - 1) = v818;
            v807 -= 8;
          }
          while (v798 != v800);
        }
        uint64_t v798 = (char *)__p[0];
        uint64_t v819 = (char *)__p[1];
        __p[0] = v807;
        __p[1] = v799;
        v839[0] = v808;
        while (v819 != v798)
        {
          uint64_t v821 = *((void *)v819 - 1);
          v819 -= 8;
          uint64_t v820 = v821;
          *(void *)uint64_t v819 = 0;
          if (v821) {
            (*(void (**)(uint64_t))(*(void *)v820 + 8))(v820);
          }
        }
      }
      if (v798) {
        operator delete(v798);
      }
LABEL_938:
      __p[1] = v799;
      mlir::FrozenRewritePatternSet::FrozenRewritePatternSet(v834, &v837, 0, 0, 0, 0);
      unint64_t v822 = *((unsigned int *)a2 + 11);
      if ((v822 & 0x7FFFFF) != 0)
      {
        unint64_t v823 = (mlir::Region **)((((unint64_t)a2
                                 + 16 * ((v822 >> 23) & 1)
                                 + ((v822 >> 21) & 0x7F8)
                                 + 71) & 0xFFFFFFFFFFFFFFF8)
                               + 32 * *((unsigned int *)a2 + 10));
        BOOL v836 = 0;
        *(_WORD *)__int16 v852 = 256;
        *(_DWORD *)&v852[2] = 0;
        *(_WORD *)&v852[6] = 0;
        *(_OWORD *)&v852[8] = xmmword_1810FE4B0;
        long long v853 = 0uLL;
        *(void *)&v852[24] = 0;
        mlir::applyPatternsAndFoldGreedily(v823, (const mlir::FrozenRewritePatternSet *)v834, (long long *)v852, &v836);
      }
      mlir::FrozenRewritePatternSet::~FrozenRewritePatternSet((mlir::FrozenRewritePatternSet *)v834);
      if (HIDWORD(v850) && v850)
      {
        uint64_t v824 = 0;
        do
        {
          uint64_t v825 = *(llvm **)((char *)v849 + v824);
          if (v825 != (llvm *)-8 && v825 != 0)
          {
            uint64_t v827 = *(void *)v825;
            unint64_t v828 = (void *)*((void *)v825 + 4);
            if (v828 == (void *)((char *)v825 + 8))
            {
              (*(void (**)(void *))(*((void *)v825 + 1) + 32))((void *)v825 + 1);
            }
            else if (v828)
            {
              (*(void (**)(void *))(*v828 + 40))(v828);
            }
            llvm::deallocate_buffer(v825, (void *)(v827 + 41));
          }
          v824 += 8;
        }
        while (8 * v850 != v824);
      }
      free(v849);
      if (HIDWORD(v847) && v847)
      {
        uint64_t v829 = 0;
        do
        {
          unint64_t v830 = *(llvm **)((char *)v846 + v829);
          if (v830 != (llvm *)-8 && v830 != 0)
          {
            uint64_t v832 = *(void *)v830;
            unint64_t v833 = (void *)*((void *)v830 + 4);
            if (v833 == (void *)((char *)v830 + 8))
            {
              (*(void (**)(void *))(*((void *)v830 + 1) + 32))((void *)v830 + 1);
            }
            else if (v833)
            {
              (*(void (**)(void *))(*v833 + 40))(v833);
            }
            llvm::deallocate_buffer(v830, (void *)(v832 + 41));
          }
          v829 += 8;
        }
        while (8 * v847 != v829);
      }
      free(v846);
      llvm::deallocate_buffer(v843, (void *)(16 * v845));
    }
LABEL_968:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
LABEL_967:
  abort();
}

void *_ZN4mlir17RewritePatternSet6insertIJNS_3mps12_GLOBAL__N_121CanonicalizeReductionINS2_17ReductionArgMaxOpEEENS4_INS2_17ReductionArgMinOpEEENS4_INS2_14ReductionMaxOpEEENS4_INS2_14ReductionMinOpEEENS4_INS2_15ReductionProdOpEEENS4_INS2_14ReductionSumOpEEENS3_25CanonicalizeReductionAxesIS5_EENSH_IS7_EENSH_IS9_EENSH_ISB_EENSH_ISD_EENSH_ISF_EENS3_27CanonicalizeMatMulTransposeENS3_20CanonicalizeMatMul1DENS3_27CanonicalizeConvToDepthwiseINS2_8Conv2DOpEEENSQ_INS2_20Conv2DDataGradientOpEEENS3_33CanonicalizeSparseMatMulTransposeENS3_35CanonicalizeQuantizedMatmulTranposeENS3_7FuseRMSINS2_10MultiplyOpEEENSX_INS2_8DivideOpEEENS3_16CanonicalizeRoPEENS3_24CanonicalizeReadVariableEERPNS_11MLIRContextEJEvEERS0_OT0_DpOT1_(void *a1, uint64_t *a2)
{
  int v4 = operator new(0x60uLL);
  uint64_t v5 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v753, 1);
  mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.reduction_argmax", 20, (__int16)v753, v5, 0, 0);
  void *v4 = &unk_1EC9C8EA8;
  if (!v4[9])
  {
    uint64_t v753 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReduction<mlir"
           "::mps::ReductionArgMaxOp>]";
    unint64_t v754 = 135;
    unint64_t v6 = llvm::StringRef::find((uint64_t *)&v753, "DesiredTypeName = ", 0x12uLL, 0);
    if (v754 >= v6) {
      unint64_t v7 = v6;
    }
    else {
      unint64_t v7 = v754;
    }
    unint64_t v8 = &v753[v7];
    unint64_t v9 = v754 - v7;
    if (v754 - v7 >= 0x12) {
      uint64_t v10 = 18;
    }
    else {
      uint64_t v10 = v754 - v7;
    }
    unint64_t v11 = &v8[v10];
    unint64_t v12 = v9 - v10;
    if (v12 >= v12 - 1) {
      --v12;
    }
    v4[8] = v11;
    v4[9] = v12;
  }
  unint64_t v13 = *((unsigned int *)v4 + 22);
  if (v13 > *((_DWORD *)v4 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v4 + 10), v4 + 12, v13, 16);
    LODWORD(v13) = *((_DWORD *)v4 + 22);
  }
  *((_DWORD *)v4 + 22) = v13;
  uint64_t v15 = (char *)a1[2];
  unint64_t v14 = a1[3];
  if ((unint64_t)v15 >= v14)
  {
    int64_t v17 = (char *)a1[1];
    uint64_t v18 = (v15 - v17) >> 3;
    unint64_t v19 = v18 + 1;
    if ((unint64_t)(v18 + 1) >> 61) {
      goto LABEL_860;
    }
    uint64_t v20 = v14 - (void)v17;
    if (v20 >> 2 > v19) {
      unint64_t v19 = v20 >> 2;
    }
    if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v21 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v21 = v19;
    }
    if (v21)
    {
      if (v21 >> 61) {
        goto LABEL_861;
      }
      unint64_t v22 = (char *)operator new(8 * v21);
    }
    else
    {
      unint64_t v22 = 0;
    }
    uint64_t v23 = &v22[8 * v18];
    uint64_t v24 = &v22[8 * v21];
    *(void *)uint64_t v23 = v4;
    unint64_t v16 = v23 + 8;
    if (v15 == v17)
    {
      a1[1] = v23;
      a1[2] = v16;
      a1[3] = v24;
    }
    else
    {
      unint64_t v25 = v15 - v17 - 8;
      if (v25 < 0x78
        || &v15[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v23 && &v22[v15 - v17 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v15)
      {
        goto LABEL_864;
      }
      uint64_t v26 = (v25 >> 3) + 1;
      uint64_t v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      long long v28 = &v15[-v27];
      v23 -= v27;
      uint64_t v29 = &v22[8 * v18 - 16];
      BOOL v30 = v15 - 16;
      uint64_t v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v33 = *((_OWORD *)v30 - 1);
        long long v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)BOOL v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)uint64_t v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      uint64_t v15 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_864:
        do
        {
          uint64_t v34 = *((void *)v15 - 1);
          v15 -= 8;
          *(void *)uint64_t v15 = 0;
          *((void *)v23 - 1) = v34;
          v23 -= 8;
        }
        while (v15 != v17);
      }
      uint64_t v15 = (char *)a1[1];
      unsigned int v35 = (char *)a1[2];
      a1[1] = v23;
      a1[2] = v16;
      a1[3] = v24;
      while (v35 != v15)
      {
        uint64_t v37 = *((void *)v35 - 1);
        v35 -= 8;
        uint64_t v36 = v37;
        *(void *)unsigned int v35 = 0;
        if (v37) {
          (*(void (**)(uint64_t))(*(void *)v36 + 8))(v36);
        }
      }
    }
    if (v15) {
      operator delete(v15);
    }
  }
  else
  {
    *(void *)uint64_t v15 = v4;
    unint64_t v16 = v15 + 8;
  }
  a1[2] = v16;
  uint64_t v38 = operator new(0x60uLL);
  uint64_t v39 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v753, 1);
  mlir::Pattern::Pattern((uint64_t)(v38 + 1), (uint64_t)"mps.reduction_argmin", 20, (__int16)v753, v39, 0, 0);
  *uint64_t v38 = &unk_1EC9C8F00;
  if (!v38[9])
  {
    uint64_t v753 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReduction<mlir"
           "::mps::ReductionArgMinOp>]";
    unint64_t v754 = 135;
    unint64_t v40 = llvm::StringRef::find((uint64_t *)&v753, "DesiredTypeName = ", 0x12uLL, 0);
    if (v754 >= v40) {
      unint64_t v41 = v40;
    }
    else {
      unint64_t v41 = v754;
    }
    unint64_t v42 = &v753[v41];
    unint64_t v43 = v754 - v41;
    if (v754 - v41 >= 0x12) {
      uint64_t v44 = 18;
    }
    else {
      uint64_t v44 = v754 - v41;
    }
    unint64_t v45 = &v42[v44];
    unint64_t v46 = v43 - v44;
    if (v46 >= v46 - 1) {
      --v46;
    }
    v38[8] = v45;
    v38[9] = v46;
  }
  unint64_t v47 = *((unsigned int *)v38 + 22);
  if (v47 > *((_DWORD *)v38 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v38 + 10), v38 + 12, v47, 16);
    LODWORD(v47) = *((_DWORD *)v38 + 22);
  }
  *((_DWORD *)v38 + 22) = v47;
  uint64_t v49 = (char *)a1[2];
  unint64_t v48 = a1[3];
  if ((unint64_t)v49 >= v48)
  {
    int64_t v51 = (char *)a1[1];
    uint64_t v52 = (v49 - v51) >> 3;
    unint64_t v53 = v52 + 1;
    if ((unint64_t)(v52 + 1) >> 61) {
      goto LABEL_860;
    }
    uint64_t v54 = v48 - (void)v51;
    if (v54 >> 2 > v53) {
      unint64_t v53 = v54 >> 2;
    }
    if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v55 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v55 = v53;
    }
    if (v55)
    {
      if (v55 >> 61) {
        goto LABEL_861;
      }
      int v56 = (char *)operator new(8 * v55);
    }
    else
    {
      int v56 = 0;
    }
    uint64_t v57 = &v56[8 * v52];
    int v58 = &v56[8 * v55];
    *(void *)uint64_t v57 = v38;
    unint64_t v50 = v57 + 8;
    if (v49 == v51)
    {
      a1[1] = v57;
      a1[2] = v50;
      a1[3] = v58;
    }
    else
    {
      unint64_t v59 = v49 - v51 - 8;
      if (v59 < 0x78
        || &v49[-(v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v57 && &v56[v49 - v51 - (v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v49)
      {
        goto LABEL_865;
      }
      uint64_t v60 = (v59 >> 3) + 1;
      uint64_t v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v62 = &v49[-v61];
      v57 -= v61;
      int v63 = &v56[8 * v52 - 16];
      BOOL v64 = v49 - 16;
      uint64_t v65 = v60 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v67 = *((_OWORD *)v64 - 1);
        long long v66 = *(_OWORD *)v64;
        *((_OWORD *)v64 - 1) = 0uLL;
        *(_OWORD *)BOOL v64 = 0uLL;
        *((_OWORD *)v63 - 1) = v67;
        *(_OWORD *)int v63 = v66;
        v63 -= 32;
        v64 -= 32;
        v65 -= 4;
      }
      while (v65);
      uint64_t v49 = v62;
      if (v60 != (v60 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_865:
        do
        {
          uint64_t v68 = *((void *)v49 - 1);
          v49 -= 8;
          *(void *)uint64_t v49 = 0;
          *((void *)v57 - 1) = v68;
          v57 -= 8;
        }
        while (v49 != v51);
      }
      uint64_t v49 = (char *)a1[1];
      int v69 = (char *)a1[2];
      a1[1] = v57;
      a1[2] = v50;
      a1[3] = v58;
      while (v69 != v49)
      {
        uint64_t v71 = *((void *)v69 - 1);
        v69 -= 8;
        uint64_t v70 = v71;
        *(void *)int v69 = 0;
        if (v71) {
          (*(void (**)(uint64_t))(*(void *)v70 + 8))(v70);
        }
      }
    }
    if (v49) {
      operator delete(v49);
    }
  }
  else
  {
    *(void *)uint64_t v49 = v38;
    unint64_t v50 = v49 + 8;
  }
  a1[2] = v50;
  uint64_t v72 = operator new(0x60uLL);
  uint64_t v73 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v753, 1);
  mlir::Pattern::Pattern((uint64_t)(v72 + 1), (uint64_t)"mps.reduction_max", 17, (__int16)v753, v73, 0, 0);
  *uint64_t v72 = &unk_1EC9C8D48;
  if (!v72[9])
  {
    uint64_t v753 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReduction<mlir"
           "::mps::ReductionMaxOp>]";
    unint64_t v754 = 132;
    unint64_t v74 = llvm::StringRef::find((uint64_t *)&v753, "DesiredTypeName = ", 0x12uLL, 0);
    if (v754 >= v74) {
      unint64_t v75 = v74;
    }
    else {
      unint64_t v75 = v754;
    }
    unint64_t v76 = &v753[v75];
    unint64_t v77 = v754 - v75;
    if (v754 - v75 >= 0x12) {
      uint64_t v78 = 18;
    }
    else {
      uint64_t v78 = v754 - v75;
    }
    unint64_t v79 = &v76[v78];
    unint64_t v80 = v77 - v78;
    if (v80 >= v80 - 1) {
      --v80;
    }
    v72[8] = v79;
    v72[9] = v80;
  }
  unint64_t v81 = *((unsigned int *)v72 + 22);
  if (v81 > *((_DWORD *)v72 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v72 + 10), v72 + 12, v81, 16);
    LODWORD(v81) = *((_DWORD *)v72 + 22);
  }
  *((_DWORD *)v72 + 22) = v81;
  char v83 = (char *)a1[2];
  unint64_t v82 = a1[3];
  if ((unint64_t)v83 >= v82)
  {
    int64_t v85 = (char *)a1[1];
    uint64_t v86 = (v83 - v85) >> 3;
    unint64_t v87 = v86 + 1;
    if ((unint64_t)(v86 + 1) >> 61) {
      goto LABEL_860;
    }
    uint64_t v88 = v82 - (void)v85;
    if (v88 >> 2 > v87) {
      unint64_t v87 = v88 >> 2;
    }
    if ((unint64_t)v88 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v89 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v89 = v87;
    }
    if (v89)
    {
      if (v89 >> 61) {
        goto LABEL_861;
      }
      uint64x2_t v90 = (char *)operator new(8 * v89);
    }
    else
    {
      uint64x2_t v90 = 0;
    }
    uint64_t v91 = &v90[8 * v86];
    uint64_t v92 = &v90[8 * v89];
    *(void *)uint64_t v91 = v72;
    uint64_t v84 = v91 + 8;
    if (v83 == v85)
    {
      a1[1] = v91;
      a1[2] = v84;
      a1[3] = v92;
    }
    else
    {
      unint64_t v93 = v83 - v85 - 8;
      if (v93 < 0x78
        || &v83[-(v93 & 0xFFFFFFFFFFFFFFF8) - 8] < v91 && &v90[v83 - v85 - (v93 & 0xFFFFFFFFFFFFFFF8) - 8] < v83)
      {
        goto LABEL_866;
      }
      uint64_t v94 = (v93 >> 3) + 1;
      uint64_t v95 = 8 * (v94 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v96 = &v83[-v95];
      v91 -= v95;
      unint64_t v97 = &v90[8 * v86 - 16];
      uint64_t v98 = v83 - 16;
      uint64_t v99 = v94 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v101 = *((_OWORD *)v98 - 1);
        long long v100 = *(_OWORD *)v98;
        *((_OWORD *)v98 - 1) = 0uLL;
        *(_OWORD *)uint64_t v98 = 0uLL;
        *((_OWORD *)v97 - 1) = v101;
        *(_OWORD *)unint64_t v97 = v100;
        v97 -= 32;
        v98 -= 32;
        v99 -= 4;
      }
      while (v99);
      char v83 = v96;
      if (v94 != (v94 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_866:
        do
        {
          uint64_t v102 = *((void *)v83 - 1);
          v83 -= 8;
          *(void *)char v83 = 0;
          *((void *)v91 - 1) = v102;
          v91 -= 8;
        }
        while (v83 != v85);
      }
      char v83 = (char *)a1[1];
      uint64_t v103 = (char *)a1[2];
      a1[1] = v91;
      a1[2] = v84;
      a1[3] = v92;
      while (v103 != v83)
      {
        uint64_t v105 = *((void *)v103 - 1);
        v103 -= 8;
        uint64_t v104 = v105;
        *(void *)uint64_t v103 = 0;
        if (v105) {
          (*(void (**)(uint64_t))(*(void *)v104 + 8))(v104);
        }
      }
    }
    if (v83) {
      operator delete(v83);
    }
  }
  else
  {
    *(void *)char v83 = v72;
    uint64_t v84 = v83 + 8;
  }
  a1[2] = v84;
  uint64_t v106 = operator new(0x60uLL);
  uint64_t v107 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v753, 1);
  mlir::Pattern::Pattern((uint64_t)(v106 + 1), (uint64_t)"mps.reduction_min", 17, (__int16)v753, v107, 0, 0);
  *uint64_t v106 = &unk_1EC9C8DA0;
  if (!v106[9])
  {
    uint64_t v753 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReduction<mlir"
           "::mps::ReductionMinOp>]";
    unint64_t v754 = 132;
    unint64_t v108 = llvm::StringRef::find((uint64_t *)&v753, "DesiredTypeName = ", 0x12uLL, 0);
    if (v754 >= v108) {
      unint64_t v109 = v108;
    }
    else {
      unint64_t v109 = v754;
    }
    unint64_t v110 = &v753[v109];
    unint64_t v111 = v754 - v109;
    if (v754 - v109 >= 0x12) {
      uint64_t v112 = 18;
    }
    else {
      uint64_t v112 = v754 - v109;
    }
    unint64_t v113 = &v110[v112];
    unint64_t v114 = v111 - v112;
    if (v114 >= v114 - 1) {
      --v114;
    }
    v106[8] = v113;
    v106[9] = v114;
  }
  unint64_t v115 = *((unsigned int *)v106 + 22);
  if (v115 > *((_DWORD *)v106 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v106 + 10), v106 + 12, v115, 16);
    LODWORD(v115) = *((_DWORD *)v106 + 22);
  }
  *((_DWORD *)v106 + 22) = v115;
  unint64_t v117 = (char *)a1[2];
  unint64_t v116 = a1[3];
  if ((unint64_t)v117 >= v116)
  {
    int64_t v119 = (char *)a1[1];
    uint64_t v120 = (v117 - v119) >> 3;
    unint64_t v121 = v120 + 1;
    if ((unint64_t)(v120 + 1) >> 61) {
      goto LABEL_860;
    }
    uint64_t v122 = v116 - (void)v119;
    if (v122 >> 2 > v121) {
      unint64_t v121 = v122 >> 2;
    }
    if ((unint64_t)v122 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v123 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v123 = v121;
    }
    if (v123)
    {
      if (v123 >> 61) {
        goto LABEL_861;
      }
      uint64_t v124 = (char *)operator new(8 * v123);
    }
    else
    {
      uint64_t v124 = 0;
    }
    unint64_t v125 = &v124[8 * v120];
    unint64_t v126 = &v124[8 * v123];
    *(void *)unint64_t v125 = v106;
    unint64_t v118 = v125 + 8;
    if (v117 == v119)
    {
      a1[1] = v125;
      a1[2] = v118;
      a1[3] = v126;
    }
    else
    {
      unint64_t v127 = v117 - v119 - 8;
      if (v127 < 0x78
        || &v117[-(v127 & 0xFFFFFFFFFFFFFFF8) - 8] < v125
        && &v124[v117 - v119 - (v127 & 0xFFFFFFFFFFFFFFF8) - 8] < v117)
      {
        goto LABEL_867;
      }
      uint64_t v128 = (v127 >> 3) + 1;
      uint64_t v129 = 8 * (v128 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v130 = &v117[-v129];
      v125 -= v129;
      uint64_t v131 = &v124[8 * v120 - 16];
      unint64_t v132 = v117 - 16;
      uint64_t v133 = v128 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v135 = *((_OWORD *)v132 - 1);
        long long v134 = *(_OWORD *)v132;
        *((_OWORD *)v132 - 1) = 0uLL;
        *(_OWORD *)unint64_t v132 = 0uLL;
        *((_OWORD *)v131 - 1) = v135;
        *(_OWORD *)uint64_t v131 = v134;
        v131 -= 32;
        v132 -= 32;
        v133 -= 4;
      }
      while (v133);
      unint64_t v117 = v130;
      if (v128 != (v128 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_867:
        do
        {
          uint64_t v136 = *((void *)v117 - 1);
          v117 -= 8;
          *(void *)unint64_t v117 = 0;
          *((void *)v125 - 1) = v136;
          v125 -= 8;
        }
        while (v117 != v119);
      }
      unint64_t v117 = (char *)a1[1];
      uint64_t v137 = (char *)a1[2];
      a1[1] = v125;
      a1[2] = v118;
      a1[3] = v126;
      while (v137 != v117)
      {
        uint64_t v139 = *((void *)v137 - 1);
        v137 -= 8;
        uint64_t v138 = v139;
        *(void *)uint64_t v137 = 0;
        if (v139) {
          (*(void (**)(uint64_t))(*(void *)v138 + 8))(v138);
        }
      }
    }
    if (v117) {
      operator delete(v117);
    }
  }
  else
  {
    *(void *)unint64_t v117 = v106;
    unint64_t v118 = v117 + 8;
  }
  a1[2] = v118;
  uint64_t v140 = operator new(0x60uLL);
  uint64_t v141 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v753, 1);
  mlir::Pattern::Pattern((uint64_t)(v140 + 1), (uint64_t)"mps.reduction_prod", 18, (__int16)v753, v141, 0, 0);
  *uint64_t v140 = &unk_1EC9C8E50;
  if (!v140[9])
  {
    uint64_t v753 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReduction<mlir"
           "::mps::ReductionProdOp>]";
    unint64_t v754 = 133;
    unint64_t v142 = llvm::StringRef::find((uint64_t *)&v753, "DesiredTypeName = ", 0x12uLL, 0);
    if (v754 >= v142) {
      unint64_t v143 = v142;
    }
    else {
      unint64_t v143 = v754;
    }
    unint64_t v144 = &v753[v143];
    unint64_t v145 = v754 - v143;
    if (v754 - v143 >= 0x12) {
      uint64_t v146 = 18;
    }
    else {
      uint64_t v146 = v754 - v143;
    }
    unint64_t v147 = &v144[v146];
    unint64_t v148 = v145 - v146;
    if (v148 >= v148 - 1) {
      --v148;
    }
    v140[8] = v147;
    v140[9] = v148;
  }
  unint64_t v149 = *((unsigned int *)v140 + 22);
  if (v149 > *((_DWORD *)v140 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v140 + 10), v140 + 12, v149, 16);
    LODWORD(v149) = *((_DWORD *)v140 + 22);
  }
  *((_DWORD *)v140 + 22) = v149;
  uint64_t v151 = (char *)a1[2];
  unint64_t v150 = a1[3];
  if ((unint64_t)v151 >= v150)
  {
    int64_t v153 = (char *)a1[1];
    uint64_t v154 = (v151 - v153) >> 3;
    unint64_t v155 = v154 + 1;
    if ((unint64_t)(v154 + 1) >> 61) {
      goto LABEL_860;
    }
    uint64_t v156 = v150 - (void)v153;
    if (v156 >> 2 > v155) {
      unint64_t v155 = v156 >> 2;
    }
    if ((unint64_t)v156 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v157 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v157 = v155;
    }
    if (v157)
    {
      if (v157 >> 61) {
        goto LABEL_861;
      }
      uint64_t v158 = (char *)operator new(8 * v157);
    }
    else
    {
      uint64_t v158 = 0;
    }
    unint64_t v159 = &v158[8 * v154];
    unint64_t v160 = &v158[8 * v157];
    *(void *)unint64_t v159 = v140;
    uint64_t v152 = v159 + 8;
    if (v151 == v153)
    {
      a1[1] = v159;
      a1[2] = v152;
      a1[3] = v160;
    }
    else
    {
      unint64_t v161 = v151 - v153 - 8;
      if (v161 < 0x78
        || &v151[-(v161 & 0xFFFFFFFFFFFFFFF8) - 8] < v159
        && &v158[v151 - v153 - (v161 & 0xFFFFFFFFFFFFFFF8) - 8] < v151)
      {
        goto LABEL_868;
      }
      uint64_t v162 = (v161 >> 3) + 1;
      uint64_t v163 = 8 * (v162 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v164 = &v151[-v163];
      v159 -= v163;
      unint64_t v165 = &v158[8 * v154 - 16];
      long long v166 = v151 - 16;
      uint64_t v167 = v162 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v169 = *((_OWORD *)v166 - 1);
        long long v168 = *(_OWORD *)v166;
        *((_OWORD *)v166 - 1) = 0uLL;
        *(_OWORD *)long long v166 = 0uLL;
        *((_OWORD *)v165 - 1) = v169;
        *(_OWORD *)unint64_t v165 = v168;
        v165 -= 32;
        v166 -= 32;
        v167 -= 4;
      }
      while (v167);
      uint64_t v151 = v164;
      if (v162 != (v162 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_868:
        do
        {
          uint64_t v170 = *((void *)v151 - 1);
          v151 -= 8;
          *(void *)uint64_t v151 = 0;
          *((void *)v159 - 1) = v170;
          v159 -= 8;
        }
        while (v151 != v153);
      }
      uint64_t v151 = (char *)a1[1];
      unint64_t v171 = (char *)a1[2];
      a1[1] = v159;
      a1[2] = v152;
      a1[3] = v160;
      while (v171 != v151)
      {
        uint64_t v173 = *((void *)v171 - 1);
        v171 -= 8;
        uint64_t v172 = v173;
        *(void *)unint64_t v171 = 0;
        if (v173) {
          (*(void (**)(uint64_t))(*(void *)v172 + 8))(v172);
        }
      }
    }
    if (v151) {
      operator delete(v151);
    }
  }
  else
  {
    *(void *)uint64_t v151 = v140;
    uint64_t v152 = v151 + 8;
  }
  a1[2] = v152;
  uint64_t v174 = operator new(0x60uLL);
  uint64_t v175 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v753, 1);
  mlir::Pattern::Pattern((uint64_t)(v174 + 1), (uint64_t)"mps.reduction_sum", 17, (__int16)v753, v175, 0, 0);
  *uint64_t v174 = &unk_1EC9C8DF8;
  if (!v174[9])
  {
    uint64_t v753 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReduction<mlir"
           "::mps::ReductionSumOp>]";
    unint64_t v754 = 132;
    unint64_t v176 = llvm::StringRef::find((uint64_t *)&v753, "DesiredTypeName = ", 0x12uLL, 0);
    if (v754 >= v176) {
      unint64_t v177 = v176;
    }
    else {
      unint64_t v177 = v754;
    }
    unint64_t v178 = &v753[v177];
    unint64_t v179 = v754 - v177;
    if (v754 - v177 >= 0x12) {
      uint64_t v180 = 18;
    }
    else {
      uint64_t v180 = v754 - v177;
    }
    unint64_t v181 = &v178[v180];
    unint64_t v182 = v179 - v180;
    if (v182 >= v182 - 1) {
      --v182;
    }
    v174[8] = v181;
    v174[9] = v182;
  }
  unint64_t v183 = *((unsigned int *)v174 + 22);
  if (v183 > *((_DWORD *)v174 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v174 + 10), v174 + 12, v183, 16);
    LODWORD(v183) = *((_DWORD *)v174 + 22);
  }
  *((_DWORD *)v174 + 22) = v183;
  uint64_t v185 = (char *)a1[2];
  unint64_t v184 = a1[3];
  if ((unint64_t)v185 >= v184)
  {
    int64_t v187 = (char *)a1[1];
    uint64_t v188 = (v185 - v187) >> 3;
    unint64_t v189 = v188 + 1;
    if ((unint64_t)(v188 + 1) >> 61) {
      goto LABEL_860;
    }
    uint64_t v190 = v184 - (void)v187;
    if (v190 >> 2 > v189) {
      unint64_t v189 = v190 >> 2;
    }
    if ((unint64_t)v190 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v191 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v191 = v189;
    }
    if (v191)
    {
      if (v191 >> 61) {
        goto LABEL_861;
      }
      uint64_t v192 = (char *)operator new(8 * v191);
    }
    else
    {
      uint64_t v192 = 0;
    }
    uint64_t v193 = &v192[8 * v188];
    uint64_t v194 = &v192[8 * v191];
    *(void *)uint64_t v193 = v174;
    unint64_t v186 = v193 + 8;
    if (v185 == v187)
    {
      a1[1] = v193;
      a1[2] = v186;
      a1[3] = v194;
    }
    else
    {
      unint64_t v195 = v185 - v187 - 8;
      if (v195 < 0x78
        || &v185[-(v195 & 0xFFFFFFFFFFFFFFF8) - 8] < v193
        && &v192[v185 - v187 - (v195 & 0xFFFFFFFFFFFFFFF8) - 8] < v185)
      {
        goto LABEL_869;
      }
      uint64_t v196 = (v195 >> 3) + 1;
      uint64_t v197 = 8 * (v196 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v198 = &v185[-v197];
      v193 -= v197;
      uint64_t v199 = &v192[8 * v188 - 16];
      long long v200 = v185 - 16;
      uint64_t v201 = v196 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v203 = *((_OWORD *)v200 - 1);
        long long v202 = *(_OWORD *)v200;
        *((_OWORD *)v200 - 1) = 0uLL;
        *(_OWORD *)long long v200 = 0uLL;
        *((_OWORD *)v199 - 1) = v203;
        *(_OWORD *)uint64_t v199 = v202;
        v199 -= 32;
        v200 -= 32;
        v201 -= 4;
      }
      while (v201);
      uint64_t v185 = v198;
      if (v196 != (v196 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_869:
        do
        {
          uint64_t v204 = *((void *)v185 - 1);
          v185 -= 8;
          *(void *)uint64_t v185 = 0;
          *((void *)v193 - 1) = v204;
          v193 -= 8;
        }
        while (v185 != v187);
      }
      uint64_t v185 = (char *)a1[1];
      uint64_t v205 = (char *)a1[2];
      a1[1] = v193;
      a1[2] = v186;
      a1[3] = v194;
      while (v205 != v185)
      {
        uint64_t v207 = *((void *)v205 - 1);
        v205 -= 8;
        uint64_t v206 = v207;
        *(void *)uint64_t v205 = 0;
        if (v207) {
          (*(void (**)(uint64_t))(*(void *)v206 + 8))(v206);
        }
      }
    }
    if (v185) {
      operator delete(v185);
    }
  }
  else
  {
    *(void *)uint64_t v185 = v174;
    unint64_t v186 = v185 + 8;
  }
  a1[2] = v186;
  uint64_t v208 = operator new(0x60uLL);
  uint64_t v209 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v753, 1);
  mlir::Pattern::Pattern((uint64_t)(v208 + 1), (uint64_t)"mps.reduction_argmax", 20, (__int16)v753, v209, 0, 0);
  void *v208 = &unk_1EC9C9AC8;
  if (!v208[9])
  {
    uint64_t v753 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReductionAxes<"
           "mlir::mps::ReductionArgMaxOp>]";
    unint64_t v754 = 139;
    unint64_t v210 = llvm::StringRef::find((uint64_t *)&v753, "DesiredTypeName = ", 0x12uLL, 0);
    if (v754 >= v210) {
      unint64_t v211 = v210;
    }
    else {
      unint64_t v211 = v754;
    }
    unint64_t v212 = &v753[v211];
    unint64_t v213 = v754 - v211;
    if (v754 - v211 >= 0x12) {
      uint64_t v214 = 18;
    }
    else {
      uint64_t v214 = v754 - v211;
    }
    unint64_t v215 = &v212[v214];
    unint64_t v216 = v213 - v214;
    if (v216 >= v216 - 1) {
      --v216;
    }
    v208[8] = v215;
    v208[9] = v216;
  }
  unint64_t v217 = *((unsigned int *)v208 + 22);
  if (v217 > *((_DWORD *)v208 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v208 + 10), v208 + 12, v217, 16);
    LODWORD(v217) = *((_DWORD *)v208 + 22);
  }
  *((_DWORD *)v208 + 22) = v217;
  uint64_t v219 = (char *)a1[2];
  unint64_t v218 = a1[3];
  if ((unint64_t)v219 >= v218)
  {
    int64_t v221 = (char *)a1[1];
    uint64_t v222 = (v219 - v221) >> 3;
    unint64_t v223 = v222 + 1;
    if ((unint64_t)(v222 + 1) >> 61) {
      goto LABEL_860;
    }
    uint64_t v224 = v218 - (void)v221;
    if (v224 >> 2 > v223) {
      unint64_t v223 = v224 >> 2;
    }
    if ((unint64_t)v224 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v225 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v225 = v223;
    }
    if (v225)
    {
      if (v225 >> 61) {
        goto LABEL_861;
      }
      uint64_t v226 = (char *)operator new(8 * v225);
    }
    else
    {
      uint64_t v226 = 0;
    }
    unint64_t v227 = &v226[8 * v222];
    uint64_t v228 = &v226[8 * v225];
    *(void *)unint64_t v227 = v208;
    uint64_t v220 = v227 + 8;
    if (v219 == v221)
    {
      a1[1] = v227;
      a1[2] = v220;
      a1[3] = v228;
    }
    else
    {
      unint64_t v229 = v219 - v221 - 8;
      if (v229 < 0x78
        || &v219[-(v229 & 0xFFFFFFFFFFFFFFF8) - 8] < v227
        && &v226[v219 - v221 - (v229 & 0xFFFFFFFFFFFFFFF8) - 8] < v219)
      {
        goto LABEL_870;
      }
      uint64_t v230 = (v229 >> 3) + 1;
      uint64_t v231 = 8 * (v230 & 0x3FFFFFFFFFFFFFFCLL);
      v232 = &v219[-v231];
      v227 -= v231;
      uint64_t v233 = &v226[8 * v222 - 16];
      long long v234 = v219 - 16;
      uint64_t v235 = v230 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v237 = *((_OWORD *)v234 - 1);
        long long v236 = *(_OWORD *)v234;
        *((_OWORD *)v234 - 1) = 0uLL;
        *(_OWORD *)long long v234 = 0uLL;
        *((_OWORD *)v233 - 1) = v237;
        *(_OWORD *)uint64_t v233 = v236;
        v233 -= 32;
        v234 -= 32;
        v235 -= 4;
      }
      while (v235);
      uint64_t v219 = v232;
      if (v230 != (v230 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_870:
        do
        {
          uint64_t v238 = *((void *)v219 - 1);
          v219 -= 8;
          *(void *)uint64_t v219 = 0;
          *((void *)v227 - 1) = v238;
          v227 -= 8;
        }
        while (v219 != v221);
      }
      uint64_t v219 = (char *)a1[1];
      uint64_t v239 = (char *)a1[2];
      a1[1] = v227;
      a1[2] = v220;
      a1[3] = v228;
      while (v239 != v219)
      {
        uint64_t v241 = *((void *)v239 - 1);
        v239 -= 8;
        uint64_t v240 = v241;
        *(void *)uint64_t v239 = 0;
        if (v241) {
          (*(void (**)(uint64_t))(*(void *)v240 + 8))(v240);
        }
      }
    }
    if (v219) {
      operator delete(v219);
    }
  }
  else
  {
    *(void *)uint64_t v219 = v208;
    uint64_t v220 = v219 + 8;
  }
  a1[2] = v220;
  uint64_t v242 = operator new(0x60uLL);
  uint64_t v243 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v753, 1);
  mlir::Pattern::Pattern((uint64_t)(v242 + 1), (uint64_t)"mps.reduction_argmin", 20, (__int16)v753, v243, 0, 0);
  *uint64_t v242 = &unk_1EC9C9B20;
  if (!v242[9])
  {
    uint64_t v753 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReductionAxes<"
           "mlir::mps::ReductionArgMinOp>]";
    unint64_t v754 = 139;
    unint64_t v244 = llvm::StringRef::find((uint64_t *)&v753, "DesiredTypeName = ", 0x12uLL, 0);
    if (v754 >= v244) {
      unint64_t v245 = v244;
    }
    else {
      unint64_t v245 = v754;
    }
    unint64_t v246 = &v753[v245];
    unint64_t v247 = v754 - v245;
    if (v754 - v245 >= 0x12) {
      uint64_t v248 = 18;
    }
    else {
      uint64_t v248 = v754 - v245;
    }
    unint64_t v249 = &v246[v248];
    unint64_t v250 = v247 - v248;
    if (v250 >= v250 - 1) {
      --v250;
    }
    v242[8] = v249;
    v242[9] = v250;
  }
  unint64_t v251 = *((unsigned int *)v242 + 22);
  if (v251 > *((_DWORD *)v242 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v242 + 10), v242 + 12, v251, 16);
    LODWORD(v251) = *((_DWORD *)v242 + 22);
  }
  *((_DWORD *)v242 + 22) = v251;
  int64_t v253 = (char *)a1[2];
  unint64_t v252 = a1[3];
  if ((unint64_t)v253 >= v252)
  {
    int64_t v255 = (char *)a1[1];
    uint64_t v256 = (v253 - v255) >> 3;
    unint64_t v257 = v256 + 1;
    if ((unint64_t)(v256 + 1) >> 61) {
      goto LABEL_860;
    }
    uint64_t v258 = v252 - (void)v255;
    if (v258 >> 2 > v257) {
      unint64_t v257 = v258 >> 2;
    }
    if ((unint64_t)v258 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v259 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v259 = v257;
    }
    if (v259)
    {
      if (v259 >> 61) {
        goto LABEL_861;
      }
      unint64_t v260 = (char *)operator new(8 * v259);
    }
    else
    {
      unint64_t v260 = 0;
    }
    unint64_t v261 = &v260[8 * v256];
    uint64_t v262 = &v260[8 * v259];
    *(void *)unint64_t v261 = v242;
    uint64_t v254 = v261 + 8;
    if (v253 == v255)
    {
      a1[1] = v261;
      a1[2] = v254;
      a1[3] = v262;
    }
    else
    {
      unint64_t v263 = v253 - v255 - 8;
      if (v263 < 0x78
        || &v253[-(v263 & 0xFFFFFFFFFFFFFFF8) - 8] < v261
        && &v260[v253 - v255 - (v263 & 0xFFFFFFFFFFFFFFF8) - 8] < v253)
      {
        goto LABEL_871;
      }
      uint64_t v264 = (v263 >> 3) + 1;
      uint64_t v265 = 8 * (v264 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v266 = &v253[-v265];
      v261 -= v265;
      uint64_t v267 = &v260[8 * v256 - 16];
      long long v268 = v253 - 16;
      uint64_t v269 = v264 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v271 = *((_OWORD *)v268 - 1);
        long long v270 = *(_OWORD *)v268;
        *((_OWORD *)v268 - 1) = 0uLL;
        *(_OWORD *)long long v268 = 0uLL;
        *((_OWORD *)v267 - 1) = v271;
        *(_OWORD *)uint64_t v267 = v270;
        v267 -= 32;
        v268 -= 32;
        v269 -= 4;
      }
      while (v269);
      int64_t v253 = v266;
      if (v264 != (v264 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_871:
        do
        {
          uint64_t v272 = *((void *)v253 - 1);
          v253 -= 8;
          *(void *)int64_t v253 = 0;
          *((void *)v261 - 1) = v272;
          v261 -= 8;
        }
        while (v253 != v255);
      }
      int64_t v253 = (char *)a1[1];
      uint64_t v273 = (char *)a1[2];
      a1[1] = v261;
      a1[2] = v254;
      a1[3] = v262;
      while (v273 != v253)
      {
        uint64_t v275 = *((void *)v273 - 1);
        v273 -= 8;
        uint64_t v274 = v275;
        *(void *)uint64_t v273 = 0;
        if (v275) {
          (*(void (**)(uint64_t))(*(void *)v274 + 8))(v274);
        }
      }
    }
    if (v253) {
      operator delete(v253);
    }
  }
  else
  {
    *(void *)int64_t v253 = v242;
    uint64_t v254 = v253 + 8;
  }
  a1[2] = v254;
  uint64_t v276 = operator new(0x60uLL);
  uint64_t v277 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v753, 1);
  mlir::Pattern::Pattern((uint64_t)(v276 + 1), (uint64_t)"mps.reduction_max", 17, (__int16)v753, v277, 0, 0);
  *uint64_t v276 = &unk_1EC9C9968;
  if (!v276[9])
  {
    uint64_t v753 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReductionAxes<"
           "mlir::mps::ReductionMaxOp>]";
    unint64_t v754 = 136;
    unint64_t v278 = llvm::StringRef::find((uint64_t *)&v753, "DesiredTypeName = ", 0x12uLL, 0);
    if (v754 >= v278) {
      unint64_t v279 = v278;
    }
    else {
      unint64_t v279 = v754;
    }
    unint64_t v280 = &v753[v279];
    unint64_t v281 = v754 - v279;
    if (v754 - v279 >= 0x12) {
      uint64_t v282 = 18;
    }
    else {
      uint64_t v282 = v754 - v279;
    }
    unint64_t v283 = &v280[v282];
    unint64_t v284 = v281 - v282;
    if (v284 >= v284 - 1) {
      --v284;
    }
    v276[8] = v283;
    v276[9] = v284;
  }
  unint64_t v285 = *((unsigned int *)v276 + 22);
  if (v285 > *((_DWORD *)v276 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v276 + 10), v276 + 12, v285, 16);
    LODWORD(v285) = *((_DWORD *)v276 + 22);
  }
  *((_DWORD *)v276 + 22) = v285;
  unint64_t v287 = (char *)a1[2];
  unint64_t v286 = a1[3];
  if ((unint64_t)v287 >= v286)
  {
    int64_t v289 = (char *)a1[1];
    uint64_t v290 = (v287 - v289) >> 3;
    unint64_t v291 = v290 + 1;
    if ((unint64_t)(v290 + 1) >> 61) {
      goto LABEL_860;
    }
    uint64_t v292 = v286 - (void)v289;
    if (v292 >> 2 > v291) {
      unint64_t v291 = v292 >> 2;
    }
    if ((unint64_t)v292 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v293 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v293 = v291;
    }
    if (v293)
    {
      if (v293 >> 61) {
        goto LABEL_861;
      }
      uint64_t v294 = (char *)operator new(8 * v293);
    }
    else
    {
      uint64_t v294 = 0;
    }
    unint64_t v295 = &v294[8 * v290];
    uint64_t v296 = &v294[8 * v293];
    *(void *)unint64_t v295 = v276;
    uint64_t v288 = v295 + 8;
    if (v287 == v289)
    {
      a1[1] = v295;
      a1[2] = v288;
      a1[3] = v296;
    }
    else
    {
      unint64_t v297 = v287 - v289 - 8;
      if (v297 < 0x78
        || &v287[-(v297 & 0xFFFFFFFFFFFFFFF8) - 8] < v295
        && &v294[v287 - v289 - (v297 & 0xFFFFFFFFFFFFFFF8) - 8] < v287)
      {
        goto LABEL_872;
      }
      uint64_t v298 = (v297 >> 3) + 1;
      uint64_t v299 = 8 * (v298 & 0x3FFFFFFFFFFFFFFCLL);
      long long v300 = &v287[-v299];
      v295 -= v299;
      uint64_t v301 = &v294[8 * v290 - 16];
      long long v302 = v287 - 16;
      uint64_t v303 = v298 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v305 = *((_OWORD *)v302 - 1);
        long long v304 = *(_OWORD *)v302;
        *((_OWORD *)v302 - 1) = 0uLL;
        *(_OWORD *)long long v302 = 0uLL;
        *((_OWORD *)v301 - 1) = v305;
        *(_OWORD *)uint64_t v301 = v304;
        v301 -= 32;
        v302 -= 32;
        v303 -= 4;
      }
      while (v303);
      unint64_t v287 = v300;
      if (v298 != (v298 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_872:
        do
        {
          uint64_t v306 = *((void *)v287 - 1);
          v287 -= 8;
          *(void *)unint64_t v287 = 0;
          *((void *)v295 - 1) = v306;
          v295 -= 8;
        }
        while (v287 != v289);
      }
      unint64_t v287 = (char *)a1[1];
      uint64_t v307 = (char *)a1[2];
      a1[1] = v295;
      a1[2] = v288;
      a1[3] = v296;
      while (v307 != v287)
      {
        uint64_t v309 = *((void *)v307 - 1);
        v307 -= 8;
        uint64_t v308 = v309;
        *(void *)uint64_t v307 = 0;
        if (v309) {
          (*(void (**)(uint64_t))(*(void *)v308 + 8))(v308);
        }
      }
    }
    if (v287) {
      operator delete(v287);
    }
  }
  else
  {
    *(void *)unint64_t v287 = v276;
    uint64_t v288 = v287 + 8;
  }
  a1[2] = v288;
  uint64_t v310 = operator new(0x60uLL);
  uint64_t v311 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v753, 1);
  mlir::Pattern::Pattern((uint64_t)(v310 + 1), (uint64_t)"mps.reduction_min", 17, (__int16)v753, v311, 0, 0);
  void *v310 = &unk_1EC9C99C0;
  if (!v310[9])
  {
    uint64_t v753 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReductionAxes<"
           "mlir::mps::ReductionMinOp>]";
    unint64_t v754 = 136;
    unint64_t v312 = llvm::StringRef::find((uint64_t *)&v753, "DesiredTypeName = ", 0x12uLL, 0);
    if (v754 >= v312) {
      unint64_t v313 = v312;
    }
    else {
      unint64_t v313 = v754;
    }
    unint64_t v314 = &v753[v313];
    unint64_t v315 = v754 - v313;
    if (v754 - v313 >= 0x12) {
      uint64_t v316 = 18;
    }
    else {
      uint64_t v316 = v754 - v313;
    }
    unint64_t v317 = &v314[v316];
    unint64_t v318 = v315 - v316;
    if (v318 >= v318 - 1) {
      --v318;
    }
    v310[8] = v317;
    v310[9] = v318;
  }
  unint64_t v319 = *((unsigned int *)v310 + 22);
  if (v319 > *((_DWORD *)v310 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v310 + 10), v310 + 12, v319, 16);
    LODWORD(v319) = *((_DWORD *)v310 + 22);
  }
  *((_DWORD *)v310 + 22) = v319;
  int64_t v321 = (char *)a1[2];
  unint64_t v320 = a1[3];
  if ((unint64_t)v321 >= v320)
  {
    int64_t v323 = (char *)a1[1];
    uint64_t v324 = (v321 - v323) >> 3;
    unint64_t v325 = v324 + 1;
    if ((unint64_t)(v324 + 1) >> 61) {
      goto LABEL_860;
    }
    uint64_t v326 = v320 - (void)v323;
    if (v326 >> 2 > v325) {
      unint64_t v325 = v326 >> 2;
    }
    if ((unint64_t)v326 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v327 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v327 = v325;
    }
    if (v327)
    {
      if (v327 >> 61) {
        goto LABEL_861;
      }
      uint64_t v328 = (char *)operator new(8 * v327);
    }
    else
    {
      uint64_t v328 = 0;
    }
    unint64_t v329 = &v328[8 * v324];
    uint64_t v330 = &v328[8 * v327];
    *(void *)unint64_t v329 = v310;
    uint64_t v322 = v329 + 8;
    if (v321 == v323)
    {
      a1[1] = v329;
      a1[2] = v322;
      a1[3] = v330;
    }
    else
    {
      unint64_t v331 = v321 - v323 - 8;
      if (v331 < 0x78
        || &v321[-(v331 & 0xFFFFFFFFFFFFFFF8) - 8] < v329
        && &v328[v321 - v323 - (v331 & 0xFFFFFFFFFFFFFFF8) - 8] < v321)
      {
        goto LABEL_873;
      }
      uint64_t v332 = (v331 >> 3) + 1;
      uint64_t v333 = 8 * (v332 & 0x3FFFFFFFFFFFFFFCLL);
      long long v334 = &v321[-v333];
      v329 -= v333;
      uint64_t v335 = &v328[8 * v324 - 16];
      long long v336 = v321 - 16;
      uint64_t v337 = v332 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v339 = *((_OWORD *)v336 - 1);
        long long v338 = *(_OWORD *)v336;
        *((_OWORD *)v336 - 1) = 0uLL;
        *(_OWORD *)long long v336 = 0uLL;
        *((_OWORD *)v335 - 1) = v339;
        *(_OWORD *)uint64_t v335 = v338;
        v335 -= 32;
        v336 -= 32;
        v337 -= 4;
      }
      while (v337);
      int64_t v321 = v334;
      if (v332 != (v332 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_873:
        do
        {
          uint64_t v340 = *((void *)v321 - 1);
          v321 -= 8;
          *(void *)int64_t v321 = 0;
          *((void *)v329 - 1) = v340;
          v329 -= 8;
        }
        while (v321 != v323);
      }
      int64_t v321 = (char *)a1[1];
      uint64_t v341 = (char *)a1[2];
      a1[1] = v329;
      a1[2] = v322;
      a1[3] = v330;
      while (v341 != v321)
      {
        uint64_t v343 = *((void *)v341 - 1);
        v341 -= 8;
        uint64_t v342 = v343;
        *(void *)uint64_t v341 = 0;
        if (v343) {
          (*(void (**)(uint64_t))(*(void *)v342 + 8))(v342);
        }
      }
    }
    if (v321) {
      operator delete(v321);
    }
  }
  else
  {
    *(void *)int64_t v321 = v310;
    uint64_t v322 = v321 + 8;
  }
  a1[2] = v322;
  uint64_t v344 = operator new(0x60uLL);
  uint64_t v345 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v753, 1);
  mlir::Pattern::Pattern((uint64_t)(v344 + 1), (uint64_t)"mps.reduction_prod", 18, (__int16)v753, v345, 0, 0);
  *uint64_t v344 = &unk_1EC9C9A70;
  if (!v344[9])
  {
    uint64_t v753 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReductionAxes<"
           "mlir::mps::ReductionProdOp>]";
    unint64_t v754 = 137;
    unint64_t v346 = llvm::StringRef::find((uint64_t *)&v753, "DesiredTypeName = ", 0x12uLL, 0);
    if (v754 >= v346) {
      unint64_t v347 = v346;
    }
    else {
      unint64_t v347 = v754;
    }
    unint64_t v348 = &v753[v347];
    unint64_t v349 = v754 - v347;
    if (v754 - v347 >= 0x12) {
      uint64_t v350 = 18;
    }
    else {
      uint64_t v350 = v754 - v347;
    }
    unint64_t v351 = &v348[v350];
    unint64_t v352 = v349 - v350;
    if (v352 >= v352 - 1) {
      --v352;
    }
    v344[8] = v351;
    v344[9] = v352;
  }
  unint64_t v353 = *((unsigned int *)v344 + 22);
  if (v353 > *((_DWORD *)v344 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v344 + 10), v344 + 12, v353, 16);
    LODWORD(v353) = *((_DWORD *)v344 + 22);
  }
  *((_DWORD *)v344 + 22) = v353;
  unint64_t v355 = (char *)a1[2];
  unint64_t v354 = a1[3];
  if ((unint64_t)v355 >= v354)
  {
    int64_t v357 = (char *)a1[1];
    uint64_t v358 = (v355 - v357) >> 3;
    unint64_t v359 = v358 + 1;
    if ((unint64_t)(v358 + 1) >> 61) {
      goto LABEL_860;
    }
    uint64_t v360 = v354 - (void)v357;
    if (v360 >> 2 > v359) {
      unint64_t v359 = v360 >> 2;
    }
    if ((unint64_t)v360 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v361 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v361 = v359;
    }
    if (v361)
    {
      if (v361 >> 61) {
        goto LABEL_861;
      }
      char v362 = (char *)operator new(8 * v361);
    }
    else
    {
      char v362 = 0;
    }
    unint64_t v363 = &v362[8 * v358];
    uint64_t v364 = &v362[8 * v361];
    *(void *)unint64_t v363 = v344;
    uint64_t v356 = v363 + 8;
    if (v355 == v357)
    {
      a1[1] = v363;
      a1[2] = v356;
      a1[3] = v364;
    }
    else
    {
      unint64_t v365 = v355 - v357 - 8;
      if (v365 < 0x78
        || &v355[-(v365 & 0xFFFFFFFFFFFFFFF8) - 8] < v363
        && &v362[v355 - v357 - (v365 & 0xFFFFFFFFFFFFFFF8) - 8] < v355)
      {
        goto LABEL_874;
      }
      uint64_t v366 = (v365 >> 3) + 1;
      uint64_t v367 = 8 * (v366 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v368 = &v355[-v367];
      v363 -= v367;
      uint64_t v369 = &v362[8 * v358 - 16];
      long long v370 = v355 - 16;
      uint64_t v371 = v366 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v373 = *((_OWORD *)v370 - 1);
        long long v372 = *(_OWORD *)v370;
        *((_OWORD *)v370 - 1) = 0uLL;
        *(_OWORD *)long long v370 = 0uLL;
        *((_OWORD *)v369 - 1) = v373;
        *(_OWORD *)uint64_t v369 = v372;
        v369 -= 32;
        v370 -= 32;
        v371 -= 4;
      }
      while (v371);
      unint64_t v355 = v368;
      if (v366 != (v366 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_874:
        do
        {
          uint64_t v374 = *((void *)v355 - 1);
          v355 -= 8;
          *(void *)unint64_t v355 = 0;
          *((void *)v363 - 1) = v374;
          v363 -= 8;
        }
        while (v355 != v357);
      }
      unint64_t v355 = (char *)a1[1];
      uint64_t v375 = (char *)a1[2];
      a1[1] = v363;
      a1[2] = v356;
      a1[3] = v364;
      while (v375 != v355)
      {
        uint64_t v377 = *((void *)v375 - 1);
        v375 -= 8;
        uint64_t v376 = v377;
        *(void *)uint64_t v375 = 0;
        if (v377) {
          (*(void (**)(uint64_t))(*(void *)v376 + 8))(v376);
        }
      }
    }
    if (v355) {
      operator delete(v355);
    }
  }
  else
  {
    *(void *)unint64_t v355 = v344;
    uint64_t v356 = v355 + 8;
  }
  a1[2] = v356;
  unint64_t v378 = operator new(0x60uLL);
  uint64_t v379 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v753, 1);
  mlir::Pattern::Pattern((uint64_t)(v378 + 1), (uint64_t)"mps.reduction_sum", 17, (__int16)v753, v379, 0, 0);
  void *v378 = &unk_1EC9C9A18;
  if (!v378[9])
  {
    uint64_t v753 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReductionAxes<"
           "mlir::mps::ReductionSumOp>]";
    unint64_t v754 = 136;
    unint64_t v380 = llvm::StringRef::find((uint64_t *)&v753, "DesiredTypeName = ", 0x12uLL, 0);
    if (v754 >= v380) {
      unint64_t v381 = v380;
    }
    else {
      unint64_t v381 = v754;
    }
    unint64_t v382 = &v753[v381];
    unint64_t v383 = v754 - v381;
    if (v754 - v381 >= 0x12) {
      uint64_t v384 = 18;
    }
    else {
      uint64_t v384 = v754 - v381;
    }
    unint64_t v385 = &v382[v384];
    unint64_t v386 = v383 - v384;
    if (v386 >= v386 - 1) {
      --v386;
    }
    v378[8] = v385;
    v378[9] = v386;
  }
  unint64_t v387 = *((unsigned int *)v378 + 22);
  if (v387 > *((_DWORD *)v378 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v378 + 10), v378 + 12, v387, 16);
    LODWORD(v387) = *((_DWORD *)v378 + 22);
  }
  *((_DWORD *)v378 + 22) = v387;
  v389 = (char *)a1[2];
  unint64_t v388 = a1[3];
  if ((unint64_t)v389 >= v388)
  {
    uint64_t v391 = (char *)a1[1];
    uint64_t v392 = (v389 - v391) >> 3;
    unint64_t v393 = v392 + 1;
    if ((unint64_t)(v392 + 1) >> 61) {
      goto LABEL_860;
    }
    uint64_t v394 = v388 - (void)v391;
    if (v394 >> 2 > v393) {
      unint64_t v393 = v394 >> 2;
    }
    if ((unint64_t)v394 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v395 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v395 = v393;
    }
    if (v395)
    {
      if (v395 >> 61) {
        goto LABEL_861;
      }
      unint64_t v396 = (char *)operator new(8 * v395);
    }
    else
    {
      unint64_t v396 = 0;
    }
    uint64_t v397 = &v396[8 * v392];
    unint64_t v398 = &v396[8 * v395];
    *(void *)uint64_t v397 = v378;
    uint64_t v390 = v397 + 8;
    if (v389 == v391)
    {
      a1[1] = v397;
      a1[2] = v390;
      a1[3] = v398;
    }
    else
    {
      unint64_t v399 = v389 - v391 - 8;
      if (v399 < 0x78
        || &v389[-(v399 & 0xFFFFFFFFFFFFFFF8) - 8] < v397
        && &v396[v389 - v391 - (v399 & 0xFFFFFFFFFFFFFFF8) - 8] < v389)
      {
        goto LABEL_875;
      }
      uint64_t v400 = (v399 >> 3) + 1;
      uint64_t v401 = 8 * (v400 & 0x3FFFFFFFFFFFFFFCLL);
      v402 = &v389[-v401];
      v397 -= v401;
      int64_t v403 = &v396[8 * v392 - 16];
      int64_t v404 = v389 - 16;
      uint64_t v405 = v400 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v407 = *((_OWORD *)v404 - 1);
        long long v406 = *(_OWORD *)v404;
        *((_OWORD *)v404 - 1) = 0uLL;
        *(_OWORD *)int64_t v404 = 0uLL;
        *((_OWORD *)v403 - 1) = v407;
        *(_OWORD *)int64_t v403 = v406;
        v403 -= 32;
        v404 -= 32;
        v405 -= 4;
      }
      while (v405);
      v389 = v402;
      if (v400 != (v400 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_875:
        do
        {
          uint64_t v408 = *((void *)v389 - 1);
          v389 -= 8;
          *(void *)v389 = 0;
          *((void *)v397 - 1) = v408;
          v397 -= 8;
        }
        while (v389 != v391);
      }
      v389 = (char *)a1[1];
      uint64_t v409 = (char *)a1[2];
      a1[1] = v397;
      a1[2] = v390;
      a1[3] = v398;
      while (v409 != v389)
      {
        uint64_t v411 = *((void *)v409 - 1);
        v409 -= 8;
        uint64_t v410 = v411;
        *(void *)uint64_t v409 = 0;
        if (v411) {
          (*(void (**)(uint64_t))(*(void *)v410 + 8))(v410);
        }
      }
    }
    if (v389) {
      operator delete(v389);
    }
  }
  else
  {
    *(void *)v389 = v378;
    uint64_t v390 = v389 + 8;
  }
  a1[2] = v390;
  unint64_t v412 = operator new(0x60uLL);
  uint64_t v413 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v753, 1);
  mlir::Pattern::Pattern((uint64_t)(v412 + 1), (uint64_t)"mps.matmul", 10, (__int16)v753, v413, 0, 0);
  void *v412 = &unk_1EC9C9C80;
  if (!v412[9])
  {
    uint64_t v753 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeMatMulTranspose]";
    unint64_t v754 = 111;
    unint64_t v414 = llvm::StringRef::find((uint64_t *)&v753, "DesiredTypeName = ", 0x12uLL, 0);
    if (v754 >= v414) {
      unint64_t v415 = v414;
    }
    else {
      unint64_t v415 = v754;
    }
    uint64_t v416 = &v753[v415];
    unint64_t v417 = v754 - v415;
    if (v754 - v415 >= 0x12) {
      uint64_t v418 = 18;
    }
    else {
      uint64_t v418 = v754 - v415;
    }
    uint64_t v419 = &v416[v418];
    unint64_t v420 = v417 - v418;
    if (v420 >= v420 - 1) {
      --v420;
    }
    v412[8] = v419;
    v412[9] = v420;
  }
  unint64_t v421 = *((unsigned int *)v412 + 22);
  if (v421 > *((_DWORD *)v412 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v412 + 10), v412 + 12, v421, 16);
    LODWORD(v421) = *((_DWORD *)v412 + 22);
  }
  *((_DWORD *)v412 + 22) = v421;
  uint64_t v423 = (char *)a1[2];
  unint64_t v422 = a1[3];
  if ((unint64_t)v423 >= v422)
  {
    long long v425 = (char *)a1[1];
    uint64_t v426 = (v423 - v425) >> 3;
    unint64_t v427 = v426 + 1;
    if ((unint64_t)(v426 + 1) >> 61) {
      goto LABEL_860;
    }
    uint64_t v428 = v422 - (void)v425;
    if (v428 >> 2 > v427) {
      unint64_t v427 = v428 >> 2;
    }
    if ((unint64_t)v428 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v429 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v429 = v427;
    }
    if (v429)
    {
      if (v429 >> 61) {
        goto LABEL_861;
      }
      uint64_t v430 = (char *)operator new(8 * v429);
    }
    else
    {
      uint64_t v430 = 0;
    }
    unint64_t v431 = &v430[8 * v426];
    uint64_t v432 = &v430[8 * v429];
    *(void *)unint64_t v431 = v412;
    uint64_t v424 = v431 + 8;
    if (v423 == v425)
    {
      a1[1] = v431;
      a1[2] = v424;
      a1[3] = v432;
    }
    else
    {
      unint64_t v433 = v423 - v425 - 8;
      if (v433 < 0x78
        || &v423[-(v433 & 0xFFFFFFFFFFFFFFF8) - 8] < v431
        && &v430[v423 - v425 - (v433 & 0xFFFFFFFFFFFFFFF8) - 8] < v423)
      {
        goto LABEL_876;
      }
      uint64_t v434 = (v433 >> 3) + 1;
      uint64_t v435 = 8 * (v434 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v436 = &v423[-v435];
      v431 -= v435;
      uint64_t v437 = &v430[8 * v426 - 16];
      unint64_t v438 = v423 - 16;
      uint64_t v439 = v434 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v441 = *((_OWORD *)v438 - 1);
        long long v440 = *(_OWORD *)v438;
        *((_OWORD *)v438 - 1) = 0uLL;
        *(_OWORD *)unint64_t v438 = 0uLL;
        *((_OWORD *)v437 - 1) = v441;
        *(_OWORD *)uint64_t v437 = v440;
        v437 -= 32;
        v438 -= 32;
        v439 -= 4;
      }
      while (v439);
      uint64_t v423 = v436;
      if (v434 != (v434 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_876:
        do
        {
          uint64_t v442 = *((void *)v423 - 1);
          v423 -= 8;
          *(void *)uint64_t v423 = 0;
          *((void *)v431 - 1) = v442;
          v431 -= 8;
        }
        while (v423 != v425);
      }
      uint64_t v423 = (char *)a1[1];
      uint64_t v443 = (char *)a1[2];
      a1[1] = v431;
      a1[2] = v424;
      a1[3] = v432;
      while (v443 != v423)
      {
        uint64_t v445 = *((void *)v443 - 1);
        v443 -= 8;
        uint64_t v444 = v445;
        *(void *)uint64_t v443 = 0;
        if (v445) {
          (*(void (**)(uint64_t))(*(void *)v444 + 8))(v444);
        }
      }
    }
    if (v423) {
      operator delete(v423);
    }
  }
  else
  {
    *(void *)uint64_t v423 = v412;
    uint64_t v424 = v423 + 8;
  }
  a1[2] = v424;
  unint64_t v446 = operator new(0x60uLL);
  uint64_t v447 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v753, 1);
  mlir::Pattern::Pattern((uint64_t)(v446 + 1), (uint64_t)"mps.matmul", 10, (__int16)v753, v447, 0, 0);
  void *v446 = &unk_1EC9C8AB0;
  if (!v446[9])
  {
    uint64_t v753 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeMatMul1D]";
    unint64_t v754 = 104;
    unint64_t v448 = llvm::StringRef::find((uint64_t *)&v753, "DesiredTypeName = ", 0x12uLL, 0);
    if (v754 >= v448) {
      unint64_t v449 = v448;
    }
    else {
      unint64_t v449 = v754;
    }
    uint64_t v450 = &v753[v449];
    unint64_t v451 = v754 - v449;
    if (v754 - v449 >= 0x12) {
      uint64_t v452 = 18;
    }
    else {
      uint64_t v452 = v754 - v449;
    }
    uint64_t v453 = &v450[v452];
    unint64_t v454 = v451 - v452;
    if (v454 >= v454 - 1) {
      --v454;
    }
    v446[8] = v453;
    v446[9] = v454;
  }
  unint64_t v455 = *((unsigned int *)v446 + 22);
  if (v455 > *((_DWORD *)v446 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v446 + 10), v446 + 12, v455, 16);
    LODWORD(v455) = *((_DWORD *)v446 + 22);
  }
  *((_DWORD *)v446 + 22) = v455;
  v457 = (char *)a1[2];
  unint64_t v456 = a1[3];
  if ((unint64_t)v457 >= v456)
  {
    long long v459 = (char *)a1[1];
    uint64_t v460 = (v457 - v459) >> 3;
    unint64_t v461 = v460 + 1;
    if ((unint64_t)(v460 + 1) >> 61) {
      goto LABEL_860;
    }
    uint64_t v462 = v456 - (void)v459;
    if (v462 >> 2 > v461) {
      unint64_t v461 = v462 >> 2;
    }
    if ((unint64_t)v462 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v463 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v463 = v461;
    }
    if (v463)
    {
      if (v463 >> 61) {
        goto LABEL_861;
      }
      uint64_t v464 = (char *)operator new(8 * v463);
    }
    else
    {
      uint64_t v464 = 0;
    }
    unint64_t v465 = &v464[8 * v460];
    uint64_t v466 = &v464[8 * v463];
    *(void *)unint64_t v465 = v446;
    uint64_t v458 = v465 + 8;
    if (v457 == v459)
    {
      a1[1] = v465;
      a1[2] = v458;
      a1[3] = v466;
    }
    else
    {
      unint64_t v467 = v457 - v459 - 8;
      if (v467 < 0x78
        || &v457[-(v467 & 0xFFFFFFFFFFFFFFF8) - 8] < v465
        && &v464[v457 - v459 - (v467 & 0xFFFFFFFFFFFFFFF8) - 8] < v457)
      {
        goto LABEL_877;
      }
      uint64_t v468 = (v467 >> 3) + 1;
      uint64_t v469 = 8 * (v468 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v470 = &v457[-v469];
      v465 -= v469;
      uint64_t v471 = &v464[8 * v460 - 16];
      unint64_t v472 = v457 - 16;
      uint64_t v473 = v468 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v475 = *((_OWORD *)v472 - 1);
        long long v474 = *(_OWORD *)v472;
        *((_OWORD *)v472 - 1) = 0uLL;
        *(_OWORD *)unint64_t v472 = 0uLL;
        *((_OWORD *)v471 - 1) = v475;
        *(_OWORD *)uint64_t v471 = v474;
        v471 -= 32;
        v472 -= 32;
        v473 -= 4;
      }
      while (v473);
      v457 = v470;
      if (v468 != (v468 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_877:
        do
        {
          uint64_t v476 = *((void *)v457 - 1);
          v457 -= 8;
          *(void *)v457 = 0;
          *((void *)v465 - 1) = v476;
          v465 -= 8;
        }
        while (v457 != v459);
      }
      v457 = (char *)a1[1];
      uint64_t v477 = (char *)a1[2];
      a1[1] = v465;
      a1[2] = v458;
      a1[3] = v466;
      while (v477 != v457)
      {
        uint64_t v479 = *((void *)v477 - 1);
        v477 -= 8;
        uint64_t v478 = v479;
        *(void *)uint64_t v477 = 0;
        if (v479) {
          (*(void (**)(uint64_t))(*(void *)v478 + 8))(v478);
        }
      }
    }
    if (v457) {
      operator delete(v457);
    }
  }
  else
  {
    *(void *)v457 = v446;
    uint64_t v458 = v457 + 8;
  }
  a1[2] = v458;
  unint64_t v480 = operator new(0x60uLL);
  uint64_t v481 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v753, 1);
  mlir::Pattern::Pattern((uint64_t)(v480 + 1), (uint64_t)"mps.conv_2d", 11, (__int16)v753, v481, 0, 0);
  *unint64_t v480 = &unk_1EC9C9C28;
  if (!v480[9])
  {
    uint64_t v753 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeConvToDepthwis"
           "e<mlir::mps::Conv2DOp>]";
    unint64_t v754 = 132;
    unint64_t v482 = llvm::StringRef::find((uint64_t *)&v753, "DesiredTypeName = ", 0x12uLL, 0);
    if (v754 >= v482) {
      unint64_t v483 = v482;
    }
    else {
      unint64_t v483 = v754;
    }
    uint64_t v484 = &v753[v483];
    unint64_t v485 = v754 - v483;
    if (v754 - v483 >= 0x12) {
      uint64_t v486 = 18;
    }
    else {
      uint64_t v486 = v754 - v483;
    }
    uint64_t v487 = &v484[v486];
    unint64_t v488 = v485 - v486;
    if (v488 >= v488 - 1) {
      --v488;
    }
    v480[8] = v487;
    v480[9] = v488;
  }
  unint64_t v489 = *((unsigned int *)v480 + 22);
  if (v489 > *((_DWORD *)v480 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v480 + 10), v480 + 12, v489, 16);
    LODWORD(v489) = *((_DWORD *)v480 + 22);
  }
  *((_DWORD *)v480 + 22) = v489;
  unint64_t v491 = (char *)a1[2];
  unint64_t v490 = a1[3];
  if ((unint64_t)v491 >= v490)
  {
    long long v493 = (char *)a1[1];
    uint64_t v494 = (v491 - v493) >> 3;
    unint64_t v495 = v494 + 1;
    if ((unint64_t)(v494 + 1) >> 61) {
      goto LABEL_860;
    }
    uint64_t v496 = v490 - (void)v493;
    if (v496 >> 2 > v495) {
      unint64_t v495 = v496 >> 2;
    }
    if ((unint64_t)v496 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v497 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v497 = v495;
    }
    if (v497)
    {
      if (v497 >> 61) {
        goto LABEL_861;
      }
      uint64_t v498 = (char *)operator new(8 * v497);
    }
    else
    {
      uint64_t v498 = 0;
    }
    uint64_t v499 = &v498[8 * v494];
    unint64_t v500 = &v498[8 * v497];
    *(void *)uint64_t v499 = v480;
    uint64_t v492 = v499 + 8;
    if (v491 == v493)
    {
      a1[1] = v499;
      a1[2] = v492;
      a1[3] = v500;
    }
    else
    {
      unint64_t v501 = v491 - v493 - 8;
      if (v501 < 0x78
        || &v491[-(v501 & 0xFFFFFFFFFFFFFFF8) - 8] < v499
        && &v498[v491 - v493 - (v501 & 0xFFFFFFFFFFFFFFF8) - 8] < v491)
      {
        goto LABEL_878;
      }
      uint64_t v502 = (v501 >> 3) + 1;
      uint64_t v503 = 8 * (v502 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v504 = &v491[-v503];
      v499 -= v503;
      unint64_t v505 = &v498[8 * v494 - 16];
      unint64_t v506 = v491 - 16;
      uint64_t v507 = v502 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v509 = *((_OWORD *)v506 - 1);
        long long v508 = *(_OWORD *)v506;
        *((_OWORD *)v506 - 1) = 0uLL;
        *(_OWORD *)unint64_t v506 = 0uLL;
        *((_OWORD *)v505 - 1) = v509;
        *(_OWORD *)unint64_t v505 = v508;
        v505 -= 32;
        v506 -= 32;
        v507 -= 4;
      }
      while (v507);
      unint64_t v491 = v504;
      if (v502 != (v502 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_878:
        do
        {
          uint64_t v510 = *((void *)v491 - 1);
          v491 -= 8;
          *(void *)unint64_t v491 = 0;
          *((void *)v499 - 1) = v510;
          v499 -= 8;
        }
        while (v491 != v493);
      }
      unint64_t v491 = (char *)a1[1];
      int64_t v511 = (char *)a1[2];
      a1[1] = v499;
      a1[2] = v492;
      a1[3] = v500;
      while (v511 != v491)
      {
        uint64_t v513 = *((void *)v511 - 1);
        v511 -= 8;
        uint64_t v512 = v513;
        *(void *)int64_t v511 = 0;
        if (v513) {
          (*(void (**)(uint64_t))(*(void *)v512 + 8))(v512);
        }
      }
    }
    if (v491) {
      operator delete(v491);
    }
  }
  else
  {
    *(void *)unint64_t v491 = v480;
    uint64_t v492 = v491 + 8;
  }
  a1[2] = v492;
  unint64_t v514 = operator new(0x60uLL);
  uint64_t v515 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v753, 1);
  mlir::Pattern::Pattern((uint64_t)(v514 + 1), (uint64_t)"mps.conv_2d_data_gradient", 25, (__int16)v753, v515, 0, 0);
  *unint64_t v514 = &unk_1EC9C9BD0;
  if (!v514[9])
  {
    uint64_t v753 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeConvToDepthwis"
           "e<mlir::mps::Conv2DDataGradientOp>]";
    unint64_t v754 = 144;
    unint64_t v516 = llvm::StringRef::find((uint64_t *)&v753, "DesiredTypeName = ", 0x12uLL, 0);
    if (v754 >= v516) {
      unint64_t v517 = v516;
    }
    else {
      unint64_t v517 = v754;
    }
    unint64_t v518 = &v753[v517];
    unint64_t v519 = v754 - v517;
    if (v754 - v517 >= 0x12) {
      uint64_t v520 = 18;
    }
    else {
      uint64_t v520 = v754 - v517;
    }
    unint64_t v521 = &v518[v520];
    unint64_t v522 = v519 - v520;
    if (v522 >= v522 - 1) {
      --v522;
    }
    v514[8] = v521;
    v514[9] = v522;
  }
  unint64_t v523 = *((unsigned int *)v514 + 22);
  if (v523 > *((_DWORD *)v514 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v514 + 10), v514 + 12, v523, 16);
    LODWORD(v523) = *((_DWORD *)v514 + 22);
  }
  *((_DWORD *)v514 + 22) = v523;
  long long v525 = (char *)a1[2];
  unint64_t v524 = a1[3];
  if ((unint64_t)v525 >= v524)
  {
    uint64_t v527 = (char *)a1[1];
    uint64_t v528 = (v525 - v527) >> 3;
    unint64_t v529 = v528 + 1;
    if ((unint64_t)(v528 + 1) >> 61) {
      goto LABEL_860;
    }
    uint64_t v530 = v524 - (void)v527;
    if (v530 >> 2 > v529) {
      unint64_t v529 = v530 >> 2;
    }
    if ((unint64_t)v530 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v531 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v531 = v529;
    }
    if (v531)
    {
      if (v531 >> 61) {
        goto LABEL_861;
      }
      uint64_t v532 = (char *)operator new(8 * v531);
    }
    else
    {
      uint64_t v532 = 0;
    }
    uint64_t v533 = &v532[8 * v528];
    uint64_t v534 = &v532[8 * v531];
    *(void *)uint64_t v533 = v514;
    long long v526 = v533 + 8;
    if (v525 == v527)
    {
      a1[1] = v533;
      a1[2] = v526;
      a1[3] = v534;
    }
    else
    {
      unint64_t v535 = v525 - v527 - 8;
      if (v535 < 0x78
        || &v525[-(v535 & 0xFFFFFFFFFFFFFFF8) - 8] < v533
        && &v532[v525 - v527 - (v535 & 0xFFFFFFFFFFFFFFF8) - 8] < v525)
      {
        goto LABEL_879;
      }
      uint64_t v536 = (v535 >> 3) + 1;
      uint64_t v537 = 8 * (v536 & 0x3FFFFFFFFFFFFFFCLL);
      long long v538 = &v525[-v537];
      v533 -= v537;
      long long v539 = &v532[8 * v528 - 16];
      uint64_t v540 = v525 - 16;
      uint64_t v541 = v536 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v543 = *((_OWORD *)v540 - 1);
        long long v542 = *(_OWORD *)v540;
        *((_OWORD *)v540 - 1) = 0uLL;
        *(_OWORD *)uint64_t v540 = 0uLL;
        *((_OWORD *)v539 - 1) = v543;
        *(_OWORD *)long long v539 = v542;
        v539 -= 32;
        v540 -= 32;
        v541 -= 4;
      }
      while (v541);
      long long v525 = v538;
      if (v536 != (v536 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_879:
        do
        {
          uint64_t v544 = *((void *)v525 - 1);
          v525 -= 8;
          *(void *)long long v525 = 0;
          *((void *)v533 - 1) = v544;
          v533 -= 8;
        }
        while (v525 != v527);
      }
      long long v525 = (char *)a1[1];
      uint64_t v545 = (char *)a1[2];
      a1[1] = v533;
      a1[2] = v526;
      a1[3] = v534;
      while (v545 != v525)
      {
        uint64_t v547 = *((void *)v545 - 1);
        v545 -= 8;
        uint64_t v546 = v547;
        *(void *)uint64_t v545 = 0;
        if (v547) {
          (*(void (**)(uint64_t))(*(void *)v546 + 8))(v546);
        }
      }
    }
    if (v525) {
      operator delete(v525);
    }
  }
  else
  {
    *(void *)long long v525 = v514;
    long long v526 = v525 + 8;
  }
  a1[2] = v526;
  unint64_t v548 = operator new(0x60uLL);
  uint64_t v549 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v753, 1);
  mlir::Pattern::Pattern((uint64_t)(v548 + 1), (uint64_t)"mpsx.sparse_dense_matmul", 24, (__int16)v753, v549, 0, 0);
  void *v548 = &unk_1EC9CA030;
  if (!v548[9])
  {
    uint64_t v753 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeSparseMatMulTranspose]";
    unint64_t v754 = 117;
    unint64_t v550 = llvm::StringRef::find((uint64_t *)&v753, "DesiredTypeName = ", 0x12uLL, 0);
    if (v754 >= v550) {
      unint64_t v551 = v550;
    }
    else {
      unint64_t v551 = v754;
    }
    unint64_t v552 = &v753[v551];
    unint64_t v553 = v754 - v551;
    if (v754 - v551 >= 0x12) {
      uint64_t v554 = 18;
    }
    else {
      uint64_t v554 = v754 - v551;
    }
    unint64_t v555 = &v552[v554];
    unint64_t v556 = v553 - v554;
    if (v556 >= v556 - 1) {
      --v556;
    }
    v548[8] = v555;
    v548[9] = v556;
  }
  unint64_t v557 = *((unsigned int *)v548 + 22);
  if (v557 > *((_DWORD *)v548 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v548 + 10), v548 + 12, v557, 16);
    LODWORD(v557) = *((_DWORD *)v548 + 22);
  }
  *((_DWORD *)v548 + 22) = v557;
  unint64_t v559 = (char *)a1[2];
  unint64_t v558 = a1[3];
  if ((unint64_t)v559 >= v558)
  {
    unint64_t v561 = (char *)a1[1];
    uint64_t v562 = (v559 - v561) >> 3;
    unint64_t v563 = v562 + 1;
    if ((unint64_t)(v562 + 1) >> 61) {
      goto LABEL_860;
    }
    uint64_t v564 = v558 - (void)v561;
    if (v564 >> 2 > v563) {
      unint64_t v563 = v564 >> 2;
    }
    if ((unint64_t)v564 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v565 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v565 = v563;
    }
    if (v565)
    {
      if (v565 >> 61) {
        goto LABEL_861;
      }
      uint64_t v566 = (char *)operator new(8 * v565);
    }
    else
    {
      uint64_t v566 = 0;
    }
    uint64_t v567 = &v566[8 * v562];
    uint64_t v568 = &v566[8 * v565];
    *(void *)uint64_t v567 = v548;
    int64_t v560 = v567 + 8;
    if (v559 == v561)
    {
      a1[1] = v567;
      a1[2] = v560;
      a1[3] = v568;
    }
    else
    {
      unint64_t v569 = v559 - v561 - 8;
      if (v569 < 0x78
        || &v559[-(v569 & 0xFFFFFFFFFFFFFFF8) - 8] < v567
        && &v566[v559 - v561 - (v569 & 0xFFFFFFFFFFFFFFF8) - 8] < v559)
      {
        goto LABEL_880;
      }
      uint64_t v570 = (v569 >> 3) + 1;
      uint64_t v571 = 8 * (v570 & 0x3FFFFFFFFFFFFFFCLL);
      long long v572 = &v559[-v571];
      v567 -= v571;
      long long v573 = &v566[8 * v562 - 16];
      uint64_t v574 = v559 - 16;
      uint64_t v575 = v570 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v577 = *((_OWORD *)v574 - 1);
        long long v576 = *(_OWORD *)v574;
        *((_OWORD *)v574 - 1) = 0uLL;
        *(_OWORD *)uint64_t v574 = 0uLL;
        *((_OWORD *)v573 - 1) = v577;
        *(_OWORD *)long long v573 = v576;
        v573 -= 32;
        v574 -= 32;
        v575 -= 4;
      }
      while (v575);
      unint64_t v559 = v572;
      if (v570 != (v570 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_880:
        do
        {
          uint64_t v578 = *((void *)v559 - 1);
          v559 -= 8;
          *(void *)unint64_t v559 = 0;
          *((void *)v567 - 1) = v578;
          v567 -= 8;
        }
        while (v559 != v561);
      }
      unint64_t v559 = (char *)a1[1];
      uint64_t v579 = (char *)a1[2];
      a1[1] = v567;
      a1[2] = v560;
      a1[3] = v568;
      while (v579 != v559)
      {
        uint64_t v581 = *((void *)v579 - 1);
        v579 -= 8;
        uint64_t v580 = v581;
        *(void *)uint64_t v579 = 0;
        if (v581) {
          (*(void (**)(uint64_t))(*(void *)v580 + 8))(v580);
        }
      }
    }
    if (v559) {
      operator delete(v559);
    }
  }
  else
  {
    *(void *)unint64_t v559 = v548;
    int64_t v560 = v559 + 8;
  }
  a1[2] = v560;
  unint64_t v582 = operator new(0x60uLL);
  uint64_t v583 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v753, 1);
  mlir::Pattern::Pattern((uint64_t)(v582 + 1), (uint64_t)"mpsx.quantized_matmul", 21, (__int16)v753, v583, 0, 0);
  void *v582 = &unk_1EC9CA138;
  if (!v582[9])
  {
    uint64_t v753 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeQuantizedMatmulTranpose]";
    unint64_t v754 = 119;
    unint64_t v584 = llvm::StringRef::find((uint64_t *)&v753, "DesiredTypeName = ", 0x12uLL, 0);
    if (v754 >= v584) {
      unint64_t v585 = v584;
    }
    else {
      unint64_t v585 = v754;
    }
    unint64_t v586 = &v753[v585];
    unint64_t v587 = v754 - v585;
    if (v754 - v585 >= 0x12) {
      uint64_t v588 = 18;
    }
    else {
      uint64_t v588 = v754 - v585;
    }
    unint64_t v589 = &v586[v588];
    unint64_t v590 = v587 - v588;
    if (v590 >= v590 - 1) {
      --v590;
    }
    v582[8] = v589;
    v582[9] = v590;
  }
  unint64_t v591 = *((unsigned int *)v582 + 22);
  if (v591 > *((_DWORD *)v582 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v582 + 10), v582 + 12, v591, 16);
    LODWORD(v591) = *((_DWORD *)v582 + 22);
  }
  *((_DWORD *)v582 + 22) = v591;
  unint64_t v593 = (char *)a1[2];
  unint64_t v592 = a1[3];
  if ((unint64_t)v593 >= v592)
  {
    unint64_t v595 = (char *)a1[1];
    uint64_t v596 = (v593 - v595) >> 3;
    unint64_t v597 = v596 + 1;
    if ((unint64_t)(v596 + 1) >> 61) {
      goto LABEL_860;
    }
    uint64_t v598 = v592 - (void)v595;
    if (v598 >> 2 > v597) {
      unint64_t v597 = v598 >> 2;
    }
    if ((unint64_t)v598 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v599 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v599 = v597;
    }
    if (v599)
    {
      if (v599 >> 61) {
        goto LABEL_861;
      }
      uint64_t v600 = (char *)operator new(8 * v599);
    }
    else
    {
      uint64_t v600 = 0;
    }
    uint64_t v601 = &v600[8 * v596];
    uint64_t v602 = &v600[8 * v599];
    *(void *)uint64_t v601 = v582;
    int64_t v594 = v601 + 8;
    if (v593 == v595)
    {
      a1[1] = v601;
      a1[2] = v594;
      a1[3] = v602;
    }
    else
    {
      unint64_t v603 = v593 - v595 - 8;
      if (v603 < 0x78
        || &v593[-(v603 & 0xFFFFFFFFFFFFFFF8) - 8] < v601
        && &v600[v593 - v595 - (v603 & 0xFFFFFFFFFFFFFFF8) - 8] < v593)
      {
        goto LABEL_881;
      }
      uint64_t v604 = (v603 >> 3) + 1;
      uint64_t v605 = 8 * (v604 & 0x3FFFFFFFFFFFFFFCLL);
      long long v606 = &v593[-v605];
      v601 -= v605;
      long long v607 = &v600[8 * v596 - 16];
      uint64_t v608 = v593 - 16;
      uint64_t v609 = v604 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v611 = *((_OWORD *)v608 - 1);
        long long v610 = *(_OWORD *)v608;
        *((_OWORD *)v608 - 1) = 0uLL;
        *(_OWORD *)uint64_t v608 = 0uLL;
        *((_OWORD *)v607 - 1) = v611;
        *(_OWORD *)long long v607 = v610;
        v607 -= 32;
        v608 -= 32;
        v609 -= 4;
      }
      while (v609);
      unint64_t v593 = v606;
      if (v604 != (v604 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_881:
        do
        {
          uint64_t v612 = *((void *)v593 - 1);
          v593 -= 8;
          *(void *)unint64_t v593 = 0;
          *((void *)v601 - 1) = v612;
          v601 -= 8;
        }
        while (v593 != v595);
      }
      unint64_t v593 = (char *)a1[1];
      uint64_t v613 = (char *)a1[2];
      a1[1] = v601;
      a1[2] = v594;
      a1[3] = v602;
      while (v613 != v593)
      {
        uint64_t v615 = *((void *)v613 - 1);
        v613 -= 8;
        uint64_t v614 = v615;
        *(void *)uint64_t v613 = 0;
        if (v615) {
          (*(void (**)(uint64_t))(*(void *)v614 + 8))(v614);
        }
      }
    }
    if (v593) {
      operator delete(v593);
    }
  }
  else
  {
    *(void *)unint64_t v593 = v582;
    int64_t v594 = v593 + 8;
  }
  a1[2] = v594;
  unint64_t v616 = operator new(0x60uLL);
  uint64_t v617 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v753, 1);
  mlir::Pattern::Pattern((uint64_t)(v616 + 1), (uint64_t)"mps.multiply", 12, (__int16)v753, v617, 0, 0);
  *unint64_t v616 = &unk_1EC9CA490;
  if (!v616[9])
  {
    uint64_t v753 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::FuseRMS<mlir::mps::MultiplyOp>]";
    unint64_t v754 = 114;
    unint64_t v618 = llvm::StringRef::find((uint64_t *)&v753, "DesiredTypeName = ", 0x12uLL, 0);
    if (v754 >= v618) {
      unint64_t v619 = v618;
    }
    else {
      unint64_t v619 = v754;
    }
    unint64_t v620 = &v753[v619];
    unint64_t v621 = v754 - v619;
    if (v754 - v619 >= 0x12) {
      uint64_t v622 = 18;
    }
    else {
      uint64_t v622 = v754 - v619;
    }
    unint64_t v623 = &v620[v622];
    unint64_t v624 = v621 - v622;
    if (v624 >= v624 - 1) {
      --v624;
    }
    v616[8] = v623;
    v616[9] = v624;
  }
  unint64_t v625 = *((unsigned int *)v616 + 22);
  if (v625 > *((_DWORD *)v616 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v616 + 10), v616 + 12, v625, 16);
    LODWORD(v625) = *((_DWORD *)v616 + 22);
  }
  *((_DWORD *)v616 + 22) = v625;
  int64_t v627 = (char *)a1[2];
  unint64_t v626 = a1[3];
  if ((unint64_t)v627 >= v626)
  {
    int64_t v629 = (char *)a1[1];
    uint64_t v630 = (v627 - v629) >> 3;
    unint64_t v631 = v630 + 1;
    if ((unint64_t)(v630 + 1) >> 61) {
      goto LABEL_860;
    }
    uint64_t v632 = v626 - (void)v629;
    if (v632 >> 2 > v631) {
      unint64_t v631 = v632 >> 2;
    }
    if ((unint64_t)v632 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v633 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v633 = v631;
    }
    if (v633)
    {
      if (v633 >> 61) {
        goto LABEL_861;
      }
      unint64_t v634 = (char *)operator new(8 * v633);
    }
    else
    {
      unint64_t v634 = 0;
    }
    uint64_t v635 = &v634[8 * v630];
    uint64_t v636 = &v634[8 * v633];
    *(void *)uint64_t v635 = v616;
    unint64_t v628 = v635 + 8;
    if (v627 == v629)
    {
      a1[1] = v635;
      a1[2] = v628;
      a1[3] = v636;
    }
    else
    {
      unint64_t v637 = v627 - v629 - 8;
      if (v637 < 0x78
        || &v627[-(v637 & 0xFFFFFFFFFFFFFFF8) - 8] < v635
        && &v634[v627 - v629 - (v637 & 0xFFFFFFFFFFFFFFF8) - 8] < v627)
      {
        goto LABEL_882;
      }
      uint64_t v638 = (v637 >> 3) + 1;
      uint64_t v639 = 8 * (v638 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v640 = &v627[-v639];
      v635 -= v639;
      long long v641 = &v634[8 * v630 - 16];
      long long v642 = v627 - 16;
      uint64_t v643 = v638 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v645 = *((_OWORD *)v642 - 1);
        long long v644 = *(_OWORD *)v642;
        *((_OWORD *)v642 - 1) = 0uLL;
        *(_OWORD *)long long v642 = 0uLL;
        *((_OWORD *)v641 - 1) = v645;
        *(_OWORD *)long long v641 = v644;
        v641 -= 32;
        v642 -= 32;
        v643 -= 4;
      }
      while (v643);
      int64_t v627 = v640;
      if (v638 != (v638 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_882:
        do
        {
          uint64_t v646 = *((void *)v627 - 1);
          v627 -= 8;
          *(void *)int64_t v627 = 0;
          *((void *)v635 - 1) = v646;
          v635 -= 8;
        }
        while (v627 != v629);
      }
      int64_t v627 = (char *)a1[1];
      uint64_t v647 = (char *)a1[2];
      a1[1] = v635;
      a1[2] = v628;
      a1[3] = v636;
      while (v647 != v627)
      {
        uint64_t v649 = *((void *)v647 - 1);
        v647 -= 8;
        uint64_t v648 = v649;
        *(void *)uint64_t v647 = 0;
        if (v649) {
          (*(void (**)(uint64_t))(*(void *)v648 + 8))(v648);
        }
      }
    }
    if (v627) {
      operator delete(v627);
    }
  }
  else
  {
    *(void *)int64_t v627 = v616;
    unint64_t v628 = v627 + 8;
  }
  a1[2] = v628;
  unint64_t v650 = operator new(0x60uLL);
  uint64_t v651 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v753, 1);
  mlir::Pattern::Pattern((uint64_t)(v650 + 1), (uint64_t)"mps.divide", 10, (__int16)v753, v651, 0, 0);
  void *v650 = &unk_1EC9CA4E8;
  if (!v650[9])
  {
    uint64_t v753 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::FuseRMS<mlir::mps::DivideOp>]";
    unint64_t v754 = 112;
    unint64_t v652 = llvm::StringRef::find((uint64_t *)&v753, "DesiredTypeName = ", 0x12uLL, 0);
    if (v754 >= v652) {
      unint64_t v653 = v652;
    }
    else {
      unint64_t v653 = v754;
    }
    uint64_t v654 = &v753[v653];
    unint64_t v655 = v754 - v653;
    if (v754 - v653 >= 0x12) {
      uint64_t v656 = 18;
    }
    else {
      uint64_t v656 = v754 - v653;
    }
    unint64_t v657 = &v654[v656];
    unint64_t v658 = v655 - v656;
    if (v658 >= v658 - 1) {
      --v658;
    }
    v650[8] = v657;
    v650[9] = v658;
  }
  unint64_t v659 = *((unsigned int *)v650 + 22);
  if (v659 > *((_DWORD *)v650 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v650 + 10), v650 + 12, v659, 16);
    LODWORD(v659) = *((_DWORD *)v650 + 22);
  }
  *((_DWORD *)v650 + 22) = v659;
  int64_t v661 = (char *)a1[2];
  unint64_t v660 = a1[3];
  if ((unint64_t)v661 >= v660)
  {
    unint64_t v663 = (char *)a1[1];
    uint64_t v664 = (v661 - v663) >> 3;
    unint64_t v665 = v664 + 1;
    if ((unint64_t)(v664 + 1) >> 61) {
      goto LABEL_860;
    }
    uint64_t v666 = v660 - (void)v663;
    if (v666 >> 2 > v665) {
      unint64_t v665 = v666 >> 2;
    }
    if ((unint64_t)v666 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v667 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v667 = v665;
    }
    if (v667)
    {
      if (v667 >> 61) {
        goto LABEL_861;
      }
      v668 = (char *)operator new(8 * v667);
    }
    else
    {
      v668 = 0;
    }
    unint64_t v669 = &v668[8 * v664];
    uint64_t v670 = &v668[8 * v667];
    *(void *)unint64_t v669 = v650;
    int64_t v662 = v669 + 8;
    if (v661 == v663)
    {
      a1[1] = v669;
      a1[2] = v662;
      a1[3] = v670;
    }
    else
    {
      unint64_t v671 = v661 - v663 - 8;
      if (v671 < 0x78
        || &v661[-(v671 & 0xFFFFFFFFFFFFFFF8) - 8] < v669
        && &v668[v661 - v663 - (v671 & 0xFFFFFFFFFFFFFFF8) - 8] < v661)
      {
        goto LABEL_883;
      }
      uint64_t v672 = (v671 >> 3) + 1;
      uint64_t v673 = 8 * (v672 & 0x3FFFFFFFFFFFFFFCLL);
      v674 = &v661[-v673];
      v669 -= v673;
      uint64_t v675 = &v668[8 * v664 - 16];
      long long v676 = v661 - 16;
      uint64_t v677 = v672 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v679 = *((_OWORD *)v676 - 1);
        long long v678 = *(_OWORD *)v676;
        *((_OWORD *)v676 - 1) = 0uLL;
        *(_OWORD *)long long v676 = 0uLL;
        *((_OWORD *)v675 - 1) = v679;
        *(_OWORD *)uint64_t v675 = v678;
        v675 -= 32;
        v676 -= 32;
        v677 -= 4;
      }
      while (v677);
      int64_t v661 = v674;
      if (v672 != (v672 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_883:
        do
        {
          uint64_t v680 = *((void *)v661 - 1);
          v661 -= 8;
          *(void *)int64_t v661 = 0;
          *((void *)v669 - 1) = v680;
          v669 -= 8;
        }
        while (v661 != v663);
      }
      int64_t v661 = (char *)a1[1];
      uint64_t v681 = (char *)a1[2];
      a1[1] = v669;
      a1[2] = v662;
      a1[3] = v670;
      while (v681 != v661)
      {
        uint64_t v683 = *((void *)v681 - 1);
        v681 -= 8;
        uint64_t v682 = v683;
        *(void *)uint64_t v681 = 0;
        if (v683) {
          (*(void (**)(uint64_t))(*(void *)v682 + 8))(v682);
        }
      }
    }
    if (v661) {
      operator delete(v661);
    }
  }
  else
  {
    *(void *)int64_t v661 = v650;
    int64_t v662 = v661 + 8;
  }
  a1[2] = v662;
  char v684 = operator new(0x60uLL);
  uint64_t v685 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v753, 1);
  mlir::Pattern::Pattern((uint64_t)(v684 + 1), (uint64_t)"mps.add", 7, (__int16)v753, v685, 0, 0);
  void *v684 = &unk_1EC9889D0;
  if (!v684[9])
  {
    uint64_t v753 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeRoPE]";
    unint64_t v754 = 100;
    unint64_t v686 = llvm::StringRef::find((uint64_t *)&v753, "DesiredTypeName = ", 0x12uLL, 0);
    if (v754 >= v686) {
      unint64_t v687 = v686;
    }
    else {
      unint64_t v687 = v754;
    }
    unint64_t v688 = &v753[v687];
    unint64_t v689 = v754 - v687;
    if (v754 - v687 >= 0x12) {
      uint64_t v690 = 18;
    }
    else {
      uint64_t v690 = v754 - v687;
    }
    unint64_t v691 = &v688[v690];
    unint64_t v692 = v689 - v690;
    if (v692 >= v692 - 1) {
      --v692;
    }
    v684[8] = v691;
    v684[9] = v692;
  }
  unint64_t v693 = *((unsigned int *)v684 + 22);
  if (v693 > *((_DWORD *)v684 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v684 + 10), v684 + 12, v693, 16);
    LODWORD(v693) = *((_DWORD *)v684 + 22);
  }
  *((_DWORD *)v684 + 22) = v693;
  v695 = (char *)a1[2];
  unint64_t v694 = a1[3];
  if ((unint64_t)v695 >= v694)
  {
    int64_t v697 = (char *)a1[1];
    uint64_t v698 = (v695 - v697) >> 3;
    unint64_t v699 = v698 + 1;
    if ((unint64_t)(v698 + 1) >> 61) {
      goto LABEL_860;
    }
    uint64_t v700 = v694 - (void)v697;
    if (v700 >> 2 > v699) {
      unint64_t v699 = v700 >> 2;
    }
    if ((unint64_t)v700 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v701 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v701 = v699;
    }
    if (v701)
    {
      if (v701 >> 61) {
        goto LABEL_861;
      }
      char v702 = (char *)operator new(8 * v701);
    }
    else
    {
      char v702 = 0;
    }
    unint64_t v703 = &v702[8 * v698];
    unint64_t v704 = &v702[8 * v701];
    *(void *)unint64_t v703 = v684;
    int64_t v696 = v703 + 8;
    if (v695 == v697)
    {
      a1[1] = v703;
      a1[2] = v696;
      a1[3] = v704;
    }
    else
    {
      unint64_t v705 = v695 - v697 - 8;
      if (v705 < 0x78
        || &v695[-(v705 & 0xFFFFFFFFFFFFFFF8) - 8] < v703
        && &v702[v695 - v697 - (v705 & 0xFFFFFFFFFFFFFFF8) - 8] < v695)
      {
        goto LABEL_884;
      }
      uint64_t v706 = (v705 >> 3) + 1;
      uint64_t v707 = 8 * (v706 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v708 = &v695[-v707];
      v703 -= v707;
      uint64_t v709 = &v702[8 * v698 - 16];
      uint64_t v710 = v695 - 16;
      uint64_t v711 = v706 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v713 = *((_OWORD *)v710 - 1);
        long long v712 = *(_OWORD *)v710;
        *((_OWORD *)v710 - 1) = 0uLL;
        *(_OWORD *)uint64_t v710 = 0uLL;
        *((_OWORD *)v709 - 1) = v713;
        *(_OWORD *)uint64_t v709 = v712;
        v709 -= 32;
        v710 -= 32;
        v711 -= 4;
      }
      while (v711);
      v695 = v708;
      if (v706 != (v706 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_884:
        do
        {
          uint64_t v714 = *((void *)v695 - 1);
          v695 -= 8;
          *(void *)v695 = 0;
          *((void *)v703 - 1) = v714;
          v703 -= 8;
        }
        while (v695 != v697);
      }
      v695 = (char *)a1[1];
      uint64_t v715 = (char *)a1[2];
      a1[1] = v703;
      a1[2] = v696;
      a1[3] = v704;
      while (v715 != v695)
      {
        uint64_t v717 = *((void *)v715 - 1);
        v715 -= 8;
        uint64_t v716 = v717;
        *(void *)uint64_t v715 = 0;
        if (v717) {
          (*(void (**)(uint64_t))(*(void *)v716 + 8))(v716);
        }
      }
    }
    if (v695) {
      operator delete(v695);
    }
  }
  else
  {
    *(void *)v695 = v684;
    int64_t v696 = v695 + 8;
  }
  a1[2] = v696;
  uint64_t v718 = operator new(0x60uLL);
  uint64_t v719 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v753, 1);
  mlir::Pattern::Pattern((uint64_t)(v718 + 1), (uint64_t)"mps.read_variable", 17, (__int16)v753, v719, 0, 0);
  *uint64_t v718 = &unk_1EC97F000;
  if (!v718[9])
  {
    uint64_t v753 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReadVariable]";
    unint64_t v754 = 108;
    unint64_t v720 = llvm::StringRef::find((uint64_t *)&v753, "DesiredTypeName = ", 0x12uLL, 0);
    if (v754 >= v720) {
      unint64_t v721 = v720;
    }
    else {
      unint64_t v721 = v754;
    }
    unint64_t v722 = &v753[v721];
    unint64_t v723 = v754 - v721;
    if (v754 - v721 >= 0x12) {
      uint64_t v724 = 18;
    }
    else {
      uint64_t v724 = v754 - v721;
    }
    unint64_t v725 = &v722[v724];
    unint64_t v726 = v723 - v724;
    if (v726 >= v726 - 1) {
      --v726;
    }
    v718[8] = v725;
    v718[9] = v726;
  }
  unint64_t v727 = *((unsigned int *)v718 + 22);
  if (v727 > *((_DWORD *)v718 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v718 + 10), v718 + 12, v727, 16);
    LODWORD(v727) = *((_DWORD *)v718 + 22);
  }
  *((_DWORD *)v718 + 22) = v727;
  v729 = (char *)a1[2];
  unint64_t v728 = a1[3];
  if ((unint64_t)v729 < v728)
  {
    *(void *)v729 = v718;
    uint64_t v730 = v729 + 8;
    goto LABEL_859;
  }
  int64_t v731 = (char *)a1[1];
  uint64_t v732 = (v729 - v731) >> 3;
  unint64_t v733 = v732 + 1;
  if ((unint64_t)(v732 + 1) >> 61) {
LABEL_860:
  }
    abort();
  uint64_t v734 = v728 - (void)v731;
  if (v734 >> 2 > v733) {
    unint64_t v733 = v734 >> 2;
  }
  if ((unint64_t)v734 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v735 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v735 = v733;
  }
  if (!v735)
  {
    v736 = 0;
    goto LABEL_844;
  }
  if (v735 >> 61) {
LABEL_861:
  }
    std::__throw_bad_array_new_length[abi:nn180100]();
  v736 = (char *)operator new(8 * v735);
LABEL_844:
  unint64_t v737 = &v736[8 * v732];
  uint64_t v738 = &v736[8 * v735];
  *(void *)unint64_t v737 = v718;
  uint64_t v730 = v737 + 8;
  if (v729 == v731)
  {
    a1[1] = v737;
    a1[2] = v730;
    a1[3] = v738;
  }
  else
  {
    unint64_t v739 = v729 - v731 - 8;
    if (v739 < 0x78
      || &v729[-(v739 & 0xFFFFFFFFFFFFFFF8) - 8] < v737
      && &v736[v729 - v731 - (v739 & 0xFFFFFFFFFFFFFFF8) - 8] < v729)
    {
      goto LABEL_885;
    }
    uint64_t v740 = (v739 >> 3) + 1;
    uint64_t v741 = 8 * (v740 & 0x3FFFFFFFFFFFFFFCLL);
    v742 = &v729[-v741];
    v737 -= v741;
    uint64_t v743 = &v736[8 * v732 - 16];
    long long v744 = v729 - 16;
    uint64_t v745 = v740 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v747 = *((_OWORD *)v744 - 1);
      long long v746 = *(_OWORD *)v744;
      *((_OWORD *)v744 - 1) = 0uLL;
      *(_OWORD *)long long v744 = 0uLL;
      *((_OWORD *)v743 - 1) = v747;
      *(_OWORD *)uint64_t v743 = v746;
      v743 -= 32;
      v744 -= 32;
      v745 -= 4;
    }
    while (v745);
    v729 = v742;
    if (v740 != (v740 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_885:
      do
      {
        uint64_t v748 = *((void *)v729 - 1);
        v729 -= 8;
        *(void *)v729 = 0;
        *((void *)v737 - 1) = v748;
        v737 -= 8;
      }
      while (v729 != v731);
    }
    v729 = (char *)a1[1];
    uint64_t v749 = (char *)a1[2];
    a1[1] = v737;
    a1[2] = v730;
    a1[3] = v738;
    while (v749 != v729)
    {
      uint64_t v751 = *((void *)v749 - 1);
      v749 -= 8;
      uint64_t v750 = v751;
      *(void *)uint64_t v749 = 0;
      if (v751) {
        (*(void (**)(uint64_t))(*(void *)v750 + 8))(v750);
      }
    }
  }
  if (v729) {
    operator delete(v729);
  }
LABEL_859:
  a1[2] = v730;
  return a1;
}

void mlir::mps::anonymous namespace'::MPS_ComplexGEMM_CC::~MPS_ComplexGEMM_CC(mlir::mps::_anonymous_namespace_::MPS_ComplexGEMM_CC *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::mps::anonymous namespace'::MPS_ComplexGEMM_CC::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_ComplexGEMM_CC *this, mlir::Operation *a2, mlir::BoolAttr **a3)
{
  void v25[4] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = 0;
  unint64_t v21 = 0;
  uint64_t v23 = v25;
  v25[0] = a2;
  uint64_t v24 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = 0;
  }
  unint64_t v19 = v5;
  uint64_t ODSOperands = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v19, 0);
  uint64_t v7 = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v19, 1u);
  if (*((unsigned char *)a2 + 47)
    && (uint64_t InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"transpose_lhs", 13), v9))
  {
    BoolAttr = (void *)InherentAttr;
    if (!InherentAttr) {
      goto LABEL_10;
    }
  }
  else
  {
    BoolAttr = (void *)mlir::DictionaryAttr::get((uint64_t)a2 + 56, "transpose_lhs", 0xDuLL);
    if (!BoolAttr)
    {
LABEL_10:
      BoolAttr = (void *)mlir::Builder::getBoolAttr(a3 + 1, 0);
      goto LABEL_11;
    }
  }
  if (!mlir::BoolAttr::classof(BoolAttr)) {
    goto LABEL_10;
  }
LABEL_11:
  uint64_t v20 = BoolAttr;
  if (*((unsigned char *)a2 + 47))
  {
    uint64_t v11 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"transpose_rhs", 13);
    if (v12)
    {
      unint64_t v13 = (void *)v11;
      if (!v11) {
        goto LABEL_17;
      }
LABEL_16:
      if (mlir::BoolAttr::classof(v13)) {
        goto LABEL_18;
      }
      goto LABEL_17;
    }
  }
  unint64_t v13 = (void *)mlir::DictionaryAttr::get((uint64_t)a2 + 56, "transpose_rhs", 0xDuLL);
  if (v13) {
    goto LABEL_16;
  }
LABEL_17:
  unint64_t v13 = (void *)mlir::Builder::getBoolAttr(a3 + 1, 0);
LABEL_18:
  unint64_t v21 = v13;
  if (*(_UNKNOWN **)(*(void *)mlir::getElementTypeOrSelf((void *)(*(void *)(*(void *)(ODSOperands + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
                    + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
  {
    if (*(_UNKNOWN **)(*(void *)mlir::getElementTypeOrSelf((void *)(*(void *)(*(void *)(v7 + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
                      + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      unint64_t v22 = *(void **)(*v23 + 24);
      mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v22, (mlir::MLIRContext *)1, 0);
    }
    uint64_t v14 = (uint64_t)a3[2];
    if (v14 && mlir::RewriterBase::Listener::classof(v14))
    {
      uint64_t v15 = *((void *)a2 + 3);
      goto LABEL_26;
    }
  }
  else
  {
    uint64_t v14 = (uint64_t)a3[2];
    if (v14 && mlir::RewriterBase::Listener::classof(v14))
    {
      uint64_t v15 = *((void *)a2 + 3);
LABEL_26:
      uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v14 + 64))(v14, v15, v16, &v22);
      goto LABEL_28;
    }
  }
  uint64_t v17 = 0;
LABEL_28:
  if (v23 != v25) {
    free(v23);
  }
  return v17;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::RealPartOp,mlir::Value &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.real_part", (const unsigned __int8 *)0xD, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    void v15[2] = (uint64_t)"mps.real_part";
    v15[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::RealPartOp::build(a1, (uint64_t)v17, *a3);
  char v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::RealPartOp,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value &,mlir::Value &,mlir::BoolAttr &,mlir::BoolAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.matmul", (const unsigned __int8 *)0xA, Context);
  if (!v14)
  {
    __int16 v22 = 1283;
    unint64_t v21[2] = (uint64_t)"mps.matmul";
    v21[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::mps::MatMulOp::build(a1, (uint64_t)v23, *a3, *a4, *a5, *a6);
  uint64_t v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id) {
    __int16 v16 = v15;
  }
  else {
    __int16 v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ImaginaryPartOp,mlir::Value &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.imaginary_part", (const unsigned __int8 *)0x12, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    void v15[2] = (uint64_t)"mps.imaginary_part";
    v15[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ImaginaryPartOp::build(a1, (uint64_t)v17, *a3);
  char v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ImaginaryPartOp,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::CreateComplexOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.create_complex", (const unsigned __int8 *)0x12, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"mps.create_complex";
    void v19[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(void *)a4, *(unsigned int *)(a4 + 8));
  mlir::arith::CmpIOp::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  uint64_t v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::CreateComplexOp,void>::id) {
    __int16 v14 = v13;
  }
  else {
    __int16 v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::anonymous namespace'::MPS_ComplexGEMM_CC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'lhs_c' failed to satisfy constraint: 'is complex type'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::anonymous namespace'::MPS_ComplexGEMM_CC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'rhs_c' failed to satisfy constraint: 'is complex type'");
}

void mlir::mps::anonymous namespace'::MPS_ComplexGEMM_CR::~MPS_ComplexGEMM_CR(mlir::mps::_anonymous_namespace_::MPS_ComplexGEMM_CR *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::mps::anonymous namespace'::MPS_ComplexGEMM_CR::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_ComplexGEMM_CR *this, mlir::Operation *a2, mlir::BoolAttr **a3)
{
  void v25[4] = *MEMORY[0x1E4F143B8];
  __int16 v20 = 0;
  unint64_t v21 = 0;
  uint64_t v23 = v25;
  v25[0] = a2;
  uint64_t v24 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = 0;
  }
  unint64_t v19 = v5;
  uint64_t ODSOperands = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v19, 0);
  uint64_t v7 = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v19, 1u);
  if (*((unsigned char *)a2 + 47)
    && (uint64_t InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"transpose_lhs", 13), v9))
  {
    BoolAttr = (void *)InherentAttr;
    if (!InherentAttr) {
      goto LABEL_10;
    }
  }
  else
  {
    BoolAttr = (void *)mlir::DictionaryAttr::get((uint64_t)a2 + 56, "transpose_lhs", 0xDuLL);
    if (!BoolAttr)
    {
LABEL_10:
      BoolAttr = (void *)mlir::Builder::getBoolAttr(a3 + 1, 0);
      goto LABEL_11;
    }
  }
  if (!mlir::BoolAttr::classof(BoolAttr)) {
    goto LABEL_10;
  }
LABEL_11:
  __int16 v20 = BoolAttr;
  if (*((unsigned char *)a2 + 47))
  {
    uint64_t v11 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"transpose_rhs", 13);
    if (v12)
    {
      uint64_t v13 = (void *)v11;
      if (!v11) {
        goto LABEL_17;
      }
LABEL_16:
      if (mlir::BoolAttr::classof(v13)) {
        goto LABEL_18;
      }
      goto LABEL_17;
    }
  }
  uint64_t v13 = (void *)mlir::DictionaryAttr::get((uint64_t)a2 + 56, "transpose_rhs", 0xDuLL);
  if (v13) {
    goto LABEL_16;
  }
LABEL_17:
  uint64_t v13 = (void *)mlir::Builder::getBoolAttr(a3 + 1, 0);
LABEL_18:
  unint64_t v21 = v13;
  if (*(_UNKNOWN **)(*(void *)mlir::getElementTypeOrSelf((void *)(*(void *)(*(void *)(ODSOperands + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
                    + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
  {
    if (*(_UNKNOWN **)(*(void *)mlir::getElementTypeOrSelf((void *)(*(void *)(*(void *)(v7 + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
                      + 136) != &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      __int16 v22 = *(void **)(*v23 + 24);
      mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v22, (mlir::MLIRContext *)1, 0);
    }
    uint64_t v14 = (uint64_t)a3[2];
    if (v14 && mlir::RewriterBase::Listener::classof(v14))
    {
      uint64_t v15 = *((void *)a2 + 3);
      goto LABEL_22;
    }
  }
  else
  {
    uint64_t v14 = (uint64_t)a3[2];
    if (v14 && mlir::RewriterBase::Listener::classof(v14))
    {
      uint64_t v15 = *((void *)a2 + 3);
LABEL_22:
      uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v14 + 64))(v14, v15, v16, &v22);
      goto LABEL_29;
    }
  }
  uint64_t v17 = 0;
LABEL_29:
  if (v23 != v25) {
    free(v23);
  }
  return v17;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::anonymous namespace'::MPS_ComplexGEMM_CR::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'lhs_c' failed to satisfy constraint: 'is complex type'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::anonymous namespace'::MPS_ComplexGEMM_CR::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'rhs_r' failed to satisfy constraint: 'is not complex type'");
}

void mlir::mps::anonymous namespace'::MPS_ComplexGEMM_RC::~MPS_ComplexGEMM_RC(mlir::mps::_anonymous_namespace_::MPS_ComplexGEMM_RC *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::mps::anonymous namespace'::MPS_ComplexGEMM_RC::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_ComplexGEMM_RC *this, mlir::Operation *a2, mlir::BoolAttr **a3)
{
  void v25[4] = *MEMORY[0x1E4F143B8];
  __int16 v20 = 0;
  unint64_t v21 = 0;
  uint64_t v23 = v25;
  v25[0] = a2;
  uint64_t v24 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = 0;
  }
  unint64_t v19 = v5;
  uint64_t ODSOperands = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v19, 0);
  uint64_t v7 = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v19, 1u);
  if (*((unsigned char *)a2 + 47)
    && (uint64_t InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"transpose_lhs", 13), v9))
  {
    BoolAttr = (void *)InherentAttr;
    if (!InherentAttr) {
      goto LABEL_10;
    }
  }
  else
  {
    BoolAttr = (void *)mlir::DictionaryAttr::get((uint64_t)a2 + 56, "transpose_lhs", 0xDuLL);
    if (!BoolAttr)
    {
LABEL_10:
      BoolAttr = (void *)mlir::Builder::getBoolAttr(a3 + 1, 0);
      goto LABEL_11;
    }
  }
  if (!mlir::BoolAttr::classof(BoolAttr)) {
    goto LABEL_10;
  }
LABEL_11:
  unint64_t v21 = BoolAttr;
  if (*((unsigned char *)a2 + 47))
  {
    uint64_t v11 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"transpose_rhs", 13);
    if (v12)
    {
      uint64_t v13 = (void *)v11;
      if (!v11) {
        goto LABEL_17;
      }
LABEL_16:
      if (mlir::BoolAttr::classof(v13)) {
        goto LABEL_18;
      }
      goto LABEL_17;
    }
  }
  uint64_t v13 = (void *)mlir::DictionaryAttr::get((uint64_t)a2 + 56, "transpose_rhs", 0xDuLL);
  if (v13) {
    goto LABEL_16;
  }
LABEL_17:
  uint64_t v13 = (void *)mlir::Builder::getBoolAttr(a3 + 1, 0);
LABEL_18:
  __int16 v20 = v13;
  if (*(_UNKNOWN **)(*(void *)mlir::getElementTypeOrSelf((void *)(*(void *)(*(void *)(ODSOperands + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
                    + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
  {
    uint64_t v14 = (uint64_t)a3[2];
    if (v14 && mlir::RewriterBase::Listener::classof(v14))
    {
      uint64_t v15 = *((void *)a2 + 3);
      goto LABEL_26;
    }
  }
  else
  {
    if (*(_UNKNOWN **)(*(void *)mlir::getElementTypeOrSelf((void *)(*(void *)(*(void *)(v7 + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
                      + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      __int16 v22 = *(void **)(*v23 + 24);
      mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v22, (mlir::MLIRContext *)1, 0);
    }
    uint64_t v14 = (uint64_t)a3[2];
    if (v14 && mlir::RewriterBase::Listener::classof(v14))
    {
      uint64_t v15 = *((void *)a2 + 3);
LABEL_26:
      uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v14 + 64))(v14, v15, v16, &v22);
      goto LABEL_29;
    }
  }
  uint64_t v17 = 0;
LABEL_29:
  if (v23 != v25) {
    free(v23);
  }
  return v17;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::anonymous namespace'::MPS_ComplexGEMM_RC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'lhs_r' failed to satisfy constraint: 'is not complex type'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::anonymous namespace'::MPS_ComplexGEMM_RC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'rhs_c' failed to satisfy constraint: 'is complex type'");
}

void mlir::mps::anonymous namespace'::MPS_DivideOfPower::~MPS_DivideOfPower(mlir::mps::_anonymous_namespace_::MPS_DivideOfPower *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::mps::anonymous namespace'::MPS_DivideOfPower::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_DivideOfPower *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  uint64_t v21[4] = *MEMORY[0x1E4F143B8];
  unint64_t v19 = v21;
  v21[0] = a2;
  uint64_t v20 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DivideOp,void>::id) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  uint64_t v16 = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v16, 0);
  v17[0] = *(void **)(mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v16, 1u) + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v17);
  if (!DefiningOp)
  {
    uint64_t v10 = *((void *)a3 + 2);
    if (!v10) {
      goto LABEL_20;
    }
    char v12 = v16;
    if (mlir::RewriterBase::Listener::classof(v10))
    {
      goto LABEL_15;
    }
    goto LABEL_16;
  }
  uint64_t v6 = DefiningOp;
  uint64_t v7 = *(void **)(*(void *)(DefiningOp + 48) + 16);
  BOOL v8 = v7 == &mlir::detail::TypeIDResolver<mlir::mps::PowerOp,void>::id;
  if (v7 == &mlir::detail::TypeIDResolver<mlir::mps::PowerOp,void>::id) {
    char v9 = (void *)DefiningOp;
  }
  else {
    char v9 = 0;
  }
  v17[0] = v9;
  if (v8)
  {
    mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v17, 0);
    mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v17, 1u);
    int v13 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 8);
      int v13 = v20;
    }
    v19[v13] = v6;
    LODWORD(v20) = v20 + 1;
    uint64_t v14 = *(void **)(v19[1] + 24);
    v17[0] = *(void **)(*v19 + 24);
    v17[1] = v14;
    mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)v17, (mlir::MLIRContext *)2, 0);
  }
  uint64_t v10 = *((void *)a3 + 2);
  if (v10)
  {
    if (mlir::RewriterBase::Listener::classof(v10))
    {
LABEL_15:
      uint64_t v10 = v11;
      goto LABEL_20;
    }
LABEL_16:
    uint64_t v10 = 0;
  }
LABEL_20:
  if (v19 != v21) {
    free(v19);
  }
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::NegativeOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v20[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.negative", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"mps.negative";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::NegativeOp,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::anonymous namespace'::MPS_DivideOfPower::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 1 of castedOp0");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::anonymous namespace'::MPS_DivideOfPower::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp1 is not ::mlir::mps::PowerOp type");
}

void mlir::mps::anonymous namespace'::MPS_DivideSqrtToMultiplyRsqrt::~MPS_DivideSqrtToMultiplyRsqrt(mlir::mps::_anonymous_namespace_::MPS_DivideSqrtToMultiplyRsqrt *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::mps::anonymous namespace'::MPS_DivideSqrtToMultiplyRsqrt::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_DivideSqrtToMultiplyRsqrt *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  uint64_t v21[4] = *MEMORY[0x1E4F143B8];
  unint64_t v19 = v21;
  v21[0] = a2;
  uint64_t v20 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DivideOp,void>::id) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  __int16 v16 = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v16, 0);
  v17[0] = *(void **)(mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v16, 1u) + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v17);
  if (!DefiningOp)
  {
    uint64_t v10 = *((void *)a3 + 2);
    if (!v10) {
      goto LABEL_20;
    }
    char v12 = v16;
    if (mlir::RewriterBase::Listener::classof(v10))
    {
      goto LABEL_15;
    }
    goto LABEL_16;
  }
  uint64_t v6 = DefiningOp;
  uint64_t v7 = *(void **)(*(void *)(DefiningOp + 48) + 16);
  BOOL v8 = v7 == &mlir::detail::TypeIDResolver<mlir::mps::SquareRootOp,void>::id;
  if (v7 == &mlir::detail::TypeIDResolver<mlir::mps::SquareRootOp,void>::id) {
    uint64_t v9 = (void *)DefiningOp;
  }
  else {
    uint64_t v9 = 0;
  }
  v17[0] = v9;
  if (v8)
  {
    mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v17, 0);
    int v13 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 8);
      int v13 = v20;
    }
    v19[v13] = v6;
    LODWORD(v20) = v20 + 1;
    uint64_t v14 = *(void **)(v19[1] + 24);
    v17[0] = *(void **)(*v19 + 24);
    v17[1] = v14;
    mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)v17, (mlir::MLIRContext *)2, 0);
  }
  uint64_t v10 = *((void *)a3 + 2);
  if (v10)
  {
    if (mlir::RewriterBase::Listener::classof(v10))
    {
LABEL_15:
      uint64_t v10 = v11;
      goto LABEL_20;
    }
LABEL_16:
    uint64_t v10 = 0;
  }
LABEL_20:
  if (v19 != v21) {
    free(v19);
  }
  return v10;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::anonymous namespace'::MPS_DivideSqrtToMultiplyRsqrt::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 1 of castedOp0");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::anonymous namespace'::MPS_DivideSqrtToMultiplyRsqrt::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp1 is not ::mlir::mps::SquareRootOp type");
}

void mlir::mps::anonymous namespace'::MPS_NCHW_ConvBias_NHWC::~MPS_NCHW_ConvBias_NHWC(mlir::mps::_anonymous_namespace_::MPS_NCHW_ConvBias_NHWC *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::mps::anonymous namespace'::MPS_NCHW_ConvBias_NHWC::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_NCHW_ConvBias_NHWC *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v55[4] = *MEMORY[0x1E4F143B8];
  int v5 = *((_DWORD *)a2 + 11);
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  uint64_t v46 = 0;
  if ((v5 & 0x800000) != 0)
  {
    uint64_t v6 = *((void *)a2 + 9);
    uint64_t v7 = *((unsigned int *)a2 + 17);
    v45[0] = v6;
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v6 = 0;
    v45[0] = 0;
  }
  v45[1] = v7;
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  v42[0] = v6;
  v42[1] = v7;
  v40[1] = v7;
  uint64_t v41 = 0;
  uint64_t v39 = 0;
  v40[0] = v6;
  unint64_t v53 = v55;
  v55[0] = a2;
  uint64_t v54 = 0x400000001;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::PermuteOp,void>::id) {
    BOOL v8 = a2;
  }
  else {
    BOOL v8 = 0;
  }
  uint64_t v38 = v8;
  v49[0] = *(void **)(mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v38, 0) + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v49);
  if (DefiningOp)
  {
    uint64_t v10 = DefiningOp;
    uint64_t v11 = *(void **)(*(void *)(DefiningOp + 48) + 16);
    BOOL v12 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::BiasAddOp,void>::id;
    if (v11 == &mlir::detail::TypeIDResolver<mlir::mps::BiasAddOp,void>::id) {
      int v13 = (void *)DefiningOp;
    }
    else {
      int v13 = 0;
    }
    v49[0] = v13;
    if (!v12)
    {
      uint64_t v14 = *((void *)a3 + 2);
      if (!v14) {
        goto LABEL_50;
      }
      if (mlir::RewriterBase::Listener::classof(*((void *)a3 + 2)))
      {
        uint64_t v15 = *(void *)(v10 + 24);
LABEL_14:
        uint64_t v17 = v16;
        uint64_t v18 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v14 + 64);
        unint64_t v19 = (void **)&v52;
LABEL_18:
        uint64_t v21 = v18(v14, v15, v17, v19);
LABEL_19:
        uint64_t v14 = v21;
        goto LABEL_50;
      }
      goto LABEL_49;
    }
    uint64_t v52 = *(void *)(mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v49, 0) + 24);
    uint64_t v22 = mlir::Value::getDefiningOp((mlir::Value *)&v52);
    if (v22)
    {
      uint64_t v23 = v22;
      {
        int v24 = v54;
        if (v54 >= HIDWORD(v54))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v53, v55, v54 + 1, 8);
          int v24 = v54;
        }
        v53[v24] = v23;
        LODWORD(v54) = v54 + 1;
        mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v49, 1u);
        if (!*(unsigned char *)(v10 + 47)
          || (uint64_t InherentAttr = mlir::Operation::getInherentAttr(v10, (uint64_t)"data_format", 11), !v26))
        {
          uint64_t InherentAttr = mlir::DictionaryAttr::get(v10 + 56, "data_format", 0xBuLL);
        }
        if (!InherentAttr
          || *(_UNKNOWN **)(*(void *)InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
        {
          mlir::mps::TensorDataLayoutAttr::get(*((mlir::MLIRContext **)a3 + 1), 1u);
        }
        int v27 = v54;
        if (v54 >= HIDWORD(v54))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v53, v55, v54 + 1, 8);
          int v27 = v54;
        }
        v53[v27] = v10;
        LODWORD(v54) = v54 + 1;
        uint64_t ODSOperands = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v38, 1u);
        if (mlir::AffineExpr::getKind((mlir::AffineExpr *)&v47))
        {
          uint64_t v29 = *((void *)a3 + 2);
          if (v29 && mlir::RewriterBase::Listener::classof(v29))
          {
            uint64_t v30 = *((void *)a2 + 3);
LABEL_48:
            uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v29 + 64))(v29, v30, v31, v49);
            goto LABEL_19;
          }
        }
        else
        {
          uint64_t v33 = *(void *)(v40[0] + 24);
          *(_OWORD *)uint64_t v49 = xmmword_18110B740;
          {
            uint64_t v34 = *(void *)(ODSOperands + 24);
            *(_OWORD *)uint64_t v49 = xmmword_18110B750;
            {
              unsigned int v35 = *(void **)(v53[1] + 24);
              v49[0] = *(void **)(*v53 + 24);
              v49[1] = v35;
              uint64_t v36 = *(void *)(v53[3] + 24);
              uint64_t v50 = *(void *)(v53[2] + 24);
              uint64_t v51 = v36;
              mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)v49, (mlir::MLIRContext *)4, 0);
            }
            uint64_t v29 = *((void *)a3 + 2);
            if (v29 && mlir::RewriterBase::Listener::classof(v29))
            {
              uint64_t v30 = *((void *)a2 + 3);
              goto LABEL_48;
            }
          }
          else
          {
            uint64_t v29 = *((void *)a3 + 2);
            if (v29 && mlir::RewriterBase::Listener::classof(v29))
            {
              uint64_t v30 = *((void *)a2 + 3);
              goto LABEL_48;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v14 = *((void *)a3 + 2);
      if (!v14) {
        goto LABEL_50;
      }
      long long v32 = v49[0];
      if (mlir::RewriterBase::Listener::classof(v14))
      {
        uint64_t v15 = v32[3];
        goto LABEL_14;
      }
    }
  }
  else
  {
    uint64_t v14 = *((void *)a3 + 2);
    if (!v14) {
      goto LABEL_50;
    }
    uint64_t v20 = v38;
    if (mlir::RewriterBase::Listener::classof(v14))
    {
      uint64_t v15 = *((void *)v20 + 3);
      uint64_t v18 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v14 + 64);
      unint64_t v19 = v49;
      goto LABEL_18;
    }
  }
LABEL_49:
  uint64_t v14 = 0;
LABEL_50:
  if (v53 != v55) {
    free(v53);
  }
  return v14;
}

uint64_t mlir::mps::anonymous namespace'::static_dag_matcher_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, void *a9, void *a10, uint64_t *a11, void *a12, uint64_t *a13)
{
  if (*(_UNKNOWN **)(*(void *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id) {
    uint64_t v15 = a2;
  }
  else {
    uint64_t v15 = 0;
  }
  uint64_t v54 = v15;
  if (!v15)
  {
    uint64_t v29 = *(void *)(a1 + 16);
    if (!v29) {
      return 0;
    }
    uint64_t result = mlir::RewriterBase::Listener::classof(v29);
    if (!result) {
      return result;
    }
    uint64_t v30 = *(void *)(a2 + 24);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(void *)v29 + 64))(v29, v30, v31, &v53);
  }
  uint64_t v53 = *(void *)(mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v54, 0) + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v53);
  if (DefiningOp)
  {
    uint64_t v23 = DefiningOp;
    int v24 = *(void **)(*(void *)(DefiningOp + 48) + 16);
    BOOL v25 = v24 == &mlir::detail::TypeIDResolver<mlir::mps::PermuteOp,void>::id;
    if (v24 == &mlir::detail::TypeIDResolver<mlir::mps::PermuteOp,void>::id) {
      uint64_t v26 = DefiningOp;
    }
    else {
      uint64_t v26 = 0;
    }
    uint64_t v53 = v26;
    if (!v25)
    {
      uint64_t v27 = *(void *)(a1 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16));
        if (result) {
        return result;
        }
      }
      return 0;
    }
    *a12 = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v53, 0);
    a12[1] = v34;
    *a10 = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v53, 1u);
    a10[1] = v35;
    uint64_t v36 = *(unsigned int *)(a3 + 8);
    if (v36 >= *(_DWORD *)(a3 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v36 + 1, 8);
      LODWORD(v36) = *(_DWORD *)(a3 + 8);
    }
    *(void *)(*(void *)a3 + 8 * v36) = v23;
    ++*(_DWORD *)(a3 + 8);
    *a9 = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v54, 1u);
    a9[1] = v37;
    if (!*(unsigned char *)(a2 + 47) || (uint64_t InherentAttr = mlir::Operation::getInherentAttr(a2, (uint64_t)"groups", 6), !v39)) {
      uint64_t InherentAttr = mlir::DictionaryAttr::get(a2 + 56, "groups", 6uLL);
    }
    if (!InherentAttr
      || *(_UNKNOWN **)(*(void *)InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      uint64_t v29 = *(void *)(a1 + 16);
      if (!v29) {
        return 0;
      }
      uint64_t result = mlir::RewriterBase::Listener::classof(v29);
      if (!result) {
        return result;
      }
      uint64_t v30 = *(void *)(a2 + 24);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(void *)v29 + 64))(v29, v30, v31, &v53);
    }
    *a8 = InherentAttr;
    if (!*(unsigned char *)(a2 + 47) || (uint64_t v40 = mlir::Operation::getInherentAttr(a2, (uint64_t)"strides", 7), !v41)) {
      uint64_t v40 = mlir::DictionaryAttr::get(a2 + 56, "strides", 7uLL);
    }
    uint64_t v42 = v40;
    if (!v40 || (mlir::DenseIntElementsAttr::classof(v40) & 1) == 0)
    {
      uint64_t v29 = *(void *)(a1 + 16);
      if (!v29) {
        return 0;
      }
      uint64_t result = mlir::RewriterBase::Listener::classof(v29);
      if (!result) {
        return result;
      }
      uint64_t v30 = *(void *)(a2 + 24);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(void *)v29 + 64))(v29, v30, v31, &v53);
    }
    *a6 = v42;
    if (!*(unsigned char *)(a2 + 47) || (uint64_t v43 = mlir::Operation::getInherentAttr(a2, (uint64_t)"dilation_rates", 14), !v44)) {
      uint64_t v43 = mlir::DictionaryAttr::get(a2 + 56, "dilation_rates", 0xEuLL);
    }
    uint64_t v45 = v43;
    if (!v43 || (mlir::DenseIntElementsAttr::classof(v43) & 1) == 0)
    {
      uint64_t v29 = *(void *)(a1 + 16);
      if (!v29) {
        return 0;
      }
      uint64_t result = mlir::RewriterBase::Listener::classof(v29);
      if (!result) {
        return result;
      }
      uint64_t v30 = *(void *)(a2 + 24);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(void *)v29 + 64))(v29, v30, v31, &v53);
    }
    *a4 = v45;
    if (!*(unsigned char *)(a2 + 47) || (uint64_t v46 = mlir::Operation::getInherentAttr(a2, (uint64_t)"explicit_padding", 16), !v47)) {
      uint64_t v46 = mlir::DictionaryAttr::get(a2 + 56, "explicit_padding", 0x10uLL);
    }
    uint64_t v48 = v46;
    if (v46 && (mlir::DenseIntElementsAttr::classof(v46) & 1) != 0)
    {
      *a11 = v48;
      uint64_t v49 = mlir::Operation::getAttrOfType<mlir::mps::PaddingStyleAttr>(a2, "padding_style", 0xDuLL);
      if (v49)
      {
        *a7 = v49;
        uint64_t v50 = mlir::Operation::getAttrOfType<mlir::mps::TensorDataLayoutAttr>(a2, "data_layout", 0xBuLL);
        if (v50)
        {
          *a5 = v50;
          uint64_t v51 = mlir::Operation::getAttrOfType<mlir::mps::TensorDataLayoutAttr>(a2, "weights_layout", 0xEuLL);
          if (v51)
          {
            *a13 = v51;
            return 1;
          }
          else
          {
          }
        }
        else
        {
        }
      }
      else
      {
      }
    }
    else
    {
    }
  }
  else
  {
    uint64_t v32 = *(void *)(a1 + 16);
    if (!v32) {
      return 0;
    }
    uint64_t v33 = v54;
    uint64_t result = mlir::RewriterBase::Listener::classof(v32);
    if (result) {
  }
    }
  return result;
}

uint64_t mlir::Operation::getAttrOfType<mlir::mps::TensorDataLayoutAttr>(uint64_t a1, const void *a2, size_t a3)
{
  if (!*(unsigned char *)(a1 + 47) || (uint64_t result = mlir::Operation::getInherentAttr(a1, (uint64_t)a2, a3), !v7)) {
    uint64_t result = mlir::DictionaryAttr::get(a1 + 56, a2, a3);
  }
  if (result)
  {
    if (*(_UNKNOWN **)(*(void *)result + 136) != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
      return 0;
    }
  }
  return result;
}

BOOL mlir::mps::anonymous namespace'::matchConstantValues<int>(uint64_t a1, const void *a2, uint64_t a3)
{
  v25[10] = *MEMORY[0x1E4F143B8];
  uint64_t v23 = a1;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v23);
  if (!DefiningOp) {
    return 0;
  }
  uint64_t v6 = DefiningOp;
  uint64_t v7 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(void, uint64_t))(**(void **)(v6 + 48) + 32))(*(void *)(v6 + 48), v7)) {
    return 0;
  }
  v24[0] = v25;
  v24[1] = (void *)0x100000000;
  mlir::Operation::fold(v6, 0, 0, (uint64_t)v24);
  BOOL v8 = (uint64_t *)(*(void *)v24[0] & 0xFFFFFFFFFFFFFFF8);
  if (v24[0] != v25) {
    free(v24[0]);
  }
  if (!v8) {
    return 0;
  }
  uint64_t v9 = *v8;
  unint64_t v10 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v11 = *(unsigned int *)(v9 + 16);
  if (!v11) {
    goto LABEL_14;
  }
  BOOL v12 = *(void **)(v9 + 8);
  int v13 = &v12[2 * v11];
  do
  {
    unint64_t v14 = v11 >> 1;
    uint64_t v15 = &v12[2 * (v11 >> 1)];
    unint64_t v17 = *v15;
    __int16 v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10) {
      BOOL v12 = v16;
    }
    else {
      unint64_t v11 = v14;
    }
  }
  while (v11);
  if (v12 != v13 && *v12 == v10) {
    uint64_t v18 = v12[1];
  }
  else {
LABEL_14:
  }
    uint64_t v18 = 0;
  mlir::mps::CPUNDArray::CPUNDArray(v24, v8, v18);
  unint64_t v19 = (const void *)v25[3];
  uint64_t NumElements = mlir::mps::CPUNDArray::getNumElements((mlir::mps::CPUNDArray *)v24);
  BOOL v21 = NumElements == a3 && memcmp(v19, a2, 4 * NumElements) == 0;
  mlir::mps::CPUNDArray::~CPUNDArray((mlir::mps::CPUNDArray *)v24);
  return v21;
}

uint64_t mlir::mps::anonymous namespace'::transpose4VecIntAttrToNHWC(uint64_t a1, uint64_t a2)
{
  v62[4] = *MEMORY[0x1E4F143B8];
  v57[0] = a1;
  v57[1] = a2;
  int64_t NumElements = mlir::ElementsAttr::getNumElements(a1, a2);
  v61[0] = v62;
  v61[1] = (void *)0x400000000;
  mlir::getIntValues<unsigned long long>(a1, a2, (uint64_t)v61, 1);
  int v5 = (char *)v61[0];
  int v58 = v60;
  uint64_t v59 = 0x600000000;
  if (!NumElements) {
    goto LABEL_33;
  }
  if ((unint64_t)NumElements < 7)
  {
    uint64_t v6 = 0;
    int64_t v7 = NumElements;
    goto LABEL_6;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, v60, NumElements, 8);
  uint64_t v6 = v59;
  int64_t v7 = NumElements - v59;
  if (NumElements != v59) {
LABEL_6:
  }
    bzero((char *)v58 + 8 * v6, 8 * v7);
  LODWORD(v59) = NumElements;
  if (NumElements >= 0) {
    uint64_t v8 = NumElements;
  }
  else {
    uint64_t v8 = NumElements + 3;
  }
  if ((unint64_t)(NumElements + 3) < 7) {
    goto LABEL_33;
  }
  unint64_t v9 = 0;
  unint64_t v10 = v8 >> 2;
  unint64_t v11 = (char *)v58;
  if (v10 < 4) {
    goto LABEL_16;
  }
  if ((unint64_t)((unsigned char *)v58 - v5) < 0x20) {
    goto LABEL_16;
  }
  unint64_t v9 = v10 & 0xFFFFFFFFFFFFFFFCLL;
  BOOL v12 = &v5[8 * (v10 & 0xFFFFFFFFFFFFFFFCLL)];
  int v13 = (char *)v58 + 16;
  unint64_t v14 = (long long *)(v5 + 16);
  unint64_t v15 = v10 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    long long v16 = *v14;
    *(v13 - 1) = *(v14 - 1);
    *int v13 = v16;
    v13 += 2;
    v14 += 2;
    v15 -= 4;
  }
  while (v15);
  v5 += 8 * (v10 & 0xFFFFFFFFFFFFFFFCLL);
  if (v10 != v9)
  {
LABEL_16:
    unint64_t v17 = v10 - v9;
    uint64_t v18 = &v11[8 * v9];
    BOOL v12 = v5;
    do
    {
      uint64_t v19 = *(void *)v12;
      v12 += 8;
      *(void *)uint64_t v18 = v19;
      v18 += 8;
      --v17;
    }
    while (v17);
  }
  uint64_t v20 = (char *)v58;
  if (v10 < 6 || (BOOL v21 = (char *)v58 + 24 * v10, (unint64_t)(v21 - v12) < 0x20))
  {
    unint64_t v22 = 0;
    uint64_t v23 = v12;
LABEL_21:
    unint64_t v24 = v10 - v22;
    BOOL v25 = &v20[24 * v10 + 8 * v22];
    do
    {
      uint64_t v26 = *(void *)v23;
      v23 += 8;
      *(void *)BOOL v25 = v26;
      v25 += 8;
      --v24;
    }
    while (v24);
    goto LABEL_23;
  }
  unint64_t v22 = v10 & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v23 = &v12[8 * (v10 & 0xFFFFFFFFFFFFFFFCLL)];
  uint64_t v45 = v21 + 16;
  uint64_t v46 = (long long *)(v12 + 16);
  unint64_t v47 = v10 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    long long v48 = *v46;
    *(v45 - 1) = *(v46 - 1);
    _OWORD *v45 = v48;
    v45 += 2;
    v46 += 2;
    v47 -= 4;
  }
  while (v47);
  if (v10 != v22) {
    goto LABEL_21;
  }
LABEL_23:
  uint64_t v27 = (char *)v58;
  if (v10 >= 6 && (long long v28 = (char *)v58 + 8 * v10, (unint64_t)(v28 - v23) >= 0x20))
  {
    unint64_t v29 = v10 & 0xFFFFFFFFFFFFFFFCLL;
    uint64_t v30 = &v23[8 * (v10 & 0xFFFFFFFFFFFFFFFCLL)];
    uint64_t v49 = v28 + 16;
    uint64_t v50 = (long long *)(v23 + 16);
    unint64_t v51 = v10 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      long long v52 = *v50;
      *(v49 - 1) = *(v50 - 1);
      _OWORD *v49 = v52;
      v49 += 2;
      v50 += 2;
      v51 -= 4;
    }
    while (v51);
    if (v10 == v29) {
      goto LABEL_28;
    }
  }
  else
  {
    unint64_t v29 = 0;
    uint64_t v30 = v23;
  }
  unint64_t v31 = v10 - v29;
  uint64_t v32 = &v27[8 * v29 + 8 * v10];
  do
  {
    uint64_t v33 = *(void *)v30;
    v30 += 8;
    *(void *)uint64_t v32 = v33;
    v32 += 8;
    --v31;
  }
  while (v31);
LABEL_28:
  uint64_t v34 = (char *)v58;
  uint64_t v35 = 16 * v10;
  if (v10 < 6 || (unint64_t)((unsigned char *)v58 + v35 - v30) < 0x20)
  {
    unint64_t v36 = 0;
    uint64_t v37 = (uint64_t *)v30;
LABEL_31:
    unint64_t v38 = v10 - v36;
    char v39 = &v34[8 * v36 + v35];
    do
    {
      uint64_t v40 = *v37++;
      *(void *)char v39 = v40;
      v39 += 8;
      --v38;
    }
    while (v38);
    goto LABEL_33;
  }
  unint64_t v36 = v10 & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v37 = (uint64_t *)&v30[8 * (v10 & 0xFFFFFFFFFFFFFFFCLL)];
  uint64_t v53 = (char *)v58 + v35 + 16;
  uint64_t v54 = (long long *)(v30 + 16);
  unint64_t v55 = v10 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    long long v56 = *v54;
    *(v53 - 1) = *(v54 - 1);
    *uint64_t v53 = v56;
    v53 += 2;
    v54 += 2;
    v55 -= 4;
  }
  while (v55);
  if (v10 != v36) {
    goto LABEL_31;
  }
LABEL_33:
  uint64_t ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v57);
  uint64_t v43 = mlir::DenseElementsAttr::getFromRawBuffer(ArgOperands, v42, v58, 8 * v59, 8, 1, 0);
  if (v58 != v60) {
    free(v58);
  }
  if (v61[0] != v62) {
    free(v61[0]);
  }
  return v43;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::Conv2DOp,mlir::Value &,mlir::Value &,mlir::IntegerAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyleAttr &,mlir::mps::TensorDataLayoutAttr &,mlir::mps::TensorDataLayoutAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10, uint64_t *a11)
{
  v30[38] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v25);
  uint64_t v20 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_2d", (const unsigned __int8 *)0xB, Context);
  if (!v21)
  {
    __int16 v29 = 1283;
    void v28[2] = (uint64_t)"mps.conv_2d";
    void v28[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v27 = 259;
    llvm::operator+(v28, (uint64_t *)&v26, (uint64_t)v30);
    llvm::report_fatal_error((llvm::Twine *)v30, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v20);
  mlir::mps::Conv2DOp::build(a1, (uint64_t)v30, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, *a11);
  unint64_t v22 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v30);
  if (*(_UNKNOWN **)(*((void *)v22 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id) {
    uint64_t v23 = v22;
  }
  else {
    uint64_t v23 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v23;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::BiasAddOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.bias_add", (const unsigned __int8 *)0xC, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"mps.bias_add";
    void v19[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(void *)a4, *(unsigned int *)(a4 + 8));
  mlir::arith::CmpIOp::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  int v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::BiasAddOp,void>::id) {
    unint64_t v14 = v13;
  }
  else {
    unint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::anonymous namespace'::MPS_NCHW_ConvBias_NHWC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 0 of castedOp0");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::anonymous namespace'::MPS_NCHW_ConvBias_NHWC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp1 is not ::mlir::mps::BiasAddOp type");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::anonymous namespace'::MPS_NCHW_ConvBias_NHWC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 0 of castedOp1");
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mps::anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DenseIntElementsAttr &,mlir::mps::TensorDataLayoutAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyleAttr &,mlir::IntegerAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::mps::TensorDataLayoutAttr &)::$_6>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3 || !mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16))) {
    return 0;
  }
  uint64_t v6 = *(void *)(a2 + 24);
  int64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t))(*(void *)v3 + 64);
}

uint64_t mlir::Operation::getAttrOfType<mlir::mps::PaddingStyleAttr>(uint64_t a1, const void *a2, size_t a3)
{
  if (!*(unsigned char *)(a1 + 47) || (uint64_t result = mlir::Operation::getInherentAttr(a1, (uint64_t)a2, a3), !v7)) {
    uint64_t result = mlir::DictionaryAttr::get(a1 + 56, a2, a3);
  }
  if (result)
  {
    if (*(_UNKNOWN **)(*(void *)result + 136) != &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
      return 0;
    }
  }
  return result;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mps::anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DenseIntElementsAttr &,mlir::mps::TensorDataLayoutAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyleAttr &,mlir::IntegerAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::mps::TensorDataLayoutAttr &)::$_7>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3 || !mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16))) {
    return 0;
  }
  uint64_t v6 = *(void *)(a2 + 24);
  char v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t))(*(void *)v3 + 64);
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mps::anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DenseIntElementsAttr &,mlir::mps::TensorDataLayoutAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyleAttr &,mlir::IntegerAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::mps::TensorDataLayoutAttr &)::$_8>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3 || !mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16))) {
    return 0;
  }
  uint64_t v6 = *(void *)(a2 + 24);
  char v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t))(*(void *)v3 + 64);
}