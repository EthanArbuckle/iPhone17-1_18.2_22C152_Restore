uint64_t mlir::mps::DequantizeLUTOp::getAxis(mlir::mps::DequantizeLUTOp *this)
{
  unsigned int v2;
  void *__p;
  unsigned int v4;
  uint64_t v5;

  v5 = *(void *)(*(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64);
  if (!v5) {
    return 0;
  }
  mlir::IntegerAttr::getValue(&v5, (llvm::APInt *)&__p);
  if (v4 <= 0x40) {
    return ((uint64_t)((void)__p << -(uint64_t)v4) >> -(uint64_t)v4) | 0x100000000;
  }
  v2 = *(_DWORD *)__p;
  operator delete[](__p);
  return v2 | 0x100000000;
}

uint64_t mlir::mps::UnrealizedFoldOp::verify(uint64_t **this)
{
  v26[2] = *MEMORY[0x1E4F143B8];
  v15[0] = *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v26, (uint64_t)v15, 1uLL);
  v13[0] = (const void **)(*(*this - 1) & 0xFFFFFFFFFFFFFFF8);
  mlir::ValueRange::ValueRange(v25, (uint64_t)v13, 1uLL);
  v23[0] = &unk_1EC97F2A0;
  v24 = v23;
  if (v24 == v23)
  {
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v2) {
      return 1;
    }
  }
  else
  {
    if (v24) {
      (*(void (**)(void *))(*v24 + 40))(v24);
    }
    if (v2) {
      return 1;
    }
  }
  v13[0] = (const void **)"failed: the input type must be more specialized than the result type";
  __int16 v14 = 259;
  mlir::OpState::emitOpError(this, v13, (uint64_t)v15);
  uint64_t v3 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v15);
  if (v15[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v15);
  }
  if (v22)
  {
    v4 = (void **)__p;
    if (__p)
    {
      v5 = v21;
      v6 = __p;
      if (v21 != __p)
      {
        do
          v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
        while (v5 != v4);
        v6 = __p;
      }
      v21 = v4;
      operator delete(v6);
    }
    v7 = v18;
    if (v18)
    {
      v8 = v19;
      v9 = v18;
      if (v19 != v18)
      {
        do
        {
          v11 = (void *)*--v8;
          v10 = v11;
          void *v8 = 0;
          if (v11) {
            operator delete[](v10);
          }
        }
        while (v8 != v7);
        v9 = v18;
      }
      v19 = v7;
      operator delete(v9);
    }
    if (v16 != &v17) {
      free(v16);
    }
  }
  return v3;
}

uint64_t mlir::mps::anonymous namespace'::areMoreSpecializedTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (a2 != a4) {
    return 0;
  }
  v17[0] = &unk_1EC9CF3A0;
  v17[1] = a5;
  v18 = v17;
  if (a2)
  {
    uint64_t v7 = 0;
    uint64_t v8 = a2 - 1;
    do
    {
      unint64_t v9 = mlir::TypeRange::dereference_iterator(a1, v7);
      unint64_t v15 = mlir::TypeRange::dereference_iterator(a3, v7);
      unint64_t v16 = v9;
      if (!v18)
      {
        __int16 v14 = (mlir::mps::TypeConstraintOp *)std::__throw_bad_function_call[abi:nn180100]();
        return mlir::mps::TypeConstraintOp::verify(v14);
      }
      uint64_t v10 = (*(uint64_t (**)(void *, unint64_t *, unint64_t *))(*v18 + 48))(v18, &v16, &v15);
      if (v10) {
        BOOL v11 = v8 == v7;
      }
      else {
        BOOL v11 = 1;
      }
      ++v7;
    }
    while (!v11);
    uint64_t v12 = v10;
    if (v18 == v17) {
      goto LABEL_16;
    }
    if (v18) {
      (*(void (**)(void))(*v18 + 40))();
    }
  }
  else
  {
    uint64_t v12 = 1;
LABEL_16:
    (*(void (**)(void *))(v17[0] + 32))(v17);
  }
  return v12;
}

uint64_t mlir::mps::TypeConstraintOp::verify(uint64_t **this)
{
  v26[2] = *MEMORY[0x1E4F143B8];
  v13[0] = (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  mlir::ValueRange::ValueRange(v26, (uint64_t)v13, 1uLL);
  v15[0] = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  v15[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v15);
  mlir::ValueRange::ValueRange(v25, (uint64_t)v15, 1uLL);
  v23[0] = &unk_1EC97F2F8;
  v24 = v23;
  if (v24 == v23)
  {
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v2) {
      return 1;
    }
  }
  else
  {
    if (v24) {
      (*(void (**)(void *))(*v24 + 40))(v24);
    }
    if (v2) {
      return 1;
    }
  }
  v13[0] = (const void **)"the type constraint cannot be satisfied";
  __int16 v14 = 259;
  mlir::OpState::emitOpError(this, v13, (uint64_t)v15);
  uint64_t v3 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v15);
  if (v15[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v15);
  }
  if (v22)
  {
    v4 = (void **)__p;
    if (__p)
    {
      v5 = v21;
      v6 = __p;
      if (v21 != __p)
      {
        do
          v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
        while (v5 != v4);
        v6 = __p;
      }
      v21 = v4;
      operator delete(v6);
    }
    uint64_t v7 = v18;
    if (v18)
    {
      uint64_t v8 = v19;
      unint64_t v9 = v18;
      if (v19 != v18)
      {
        do
        {
          BOOL v11 = (void *)*--v8;
          uint64_t v10 = v11;
          void *v8 = 0;
          if (v11) {
            operator delete[](v10);
          }
        }
        while (v8 != v7);
        unint64_t v9 = v18;
      }
      uint64_t v19 = v7;
      operator delete(v9);
    }
    if (v16 != &v17) {
      free(v16);
    }
  }
  return v3;
}

uint64_t mlir::mps::anonymous namespace'::areCompatibleTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = (void *)a5[3];
  if (v10)
  {
    if (v10 == a5)
    {
      v18 = v17;
      (*(void (**)(void *, void *))(*a5 + 24))(a5, v17);
    }
    else
    {
      v18 = (void *)(*(uint64_t (**)(void *))(*v10 + 16))(v10);
    }
  }
  else
  {
    v18 = 0;
  }
  {
    uint64_t v11 = 1;
    uint64_t v12 = v18;
    if (v18 == v17) {
      goto LABEL_21;
    }
  }
  else
  {
    v13 = (void *)a5[3];
    if (v13)
    {
      if (v13 == a5)
      {
        unint64_t v16 = v15;
        (*(void (**)(void *, void *))(*a5 + 24))(a5, v15);
      }
      else
      {
        unint64_t v16 = (void *)(*(uint64_t (**)(void *))(*v13 + 16))(v13);
      }
    }
    else
    {
      unint64_t v16 = 0;
    }
    if (v16 == v15)
    {
      (*(void (**)(void *))(v15[0] + 32))(v15);
      uint64_t v12 = v18;
      if (v18 == v17)
      {
LABEL_21:
        (*(void (**)(void *))(v17[0] + 32))(v17);
        return v11;
      }
    }
    else
    {
      if (v16) {
        (*(void (**)(void))(*v16 + 40))();
      }
      uint64_t v12 = v18;
      if (v18 == v17) {
        goto LABEL_21;
      }
    }
  }
  if (v12) {
    (*(void (**)(void *))(*v12 + 40))(v12);
  }
  return v11;
}

uint64_t mlir::mps::TypeConstraintOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v38[2] = *MEMORY[0x1E4F143B8];
  if (a7) {
    uint64_t v14 = *a7;
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v30 = a6;
  v31[0] = 0;
  char v32 = 0;
  uint64_t v33 = v14;
  uint64_t v34 = a9;
  uint64_t v35 = a10;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v30);
    if (v32) {
      char v32 = 0;
    }
    mlir::OperationName::OperationName(v31, "mps.type_constraint", 19, Context);
    char v32 = 1;
  }
  uint64_t v36 = a4;
  uint64_t v37 = a5;
  uint64_t v16 = mlir::UnknownLoc::get(this, a2);
  if (mlir::mps::TypeConstraintOpAdaptor::verify((uint64_t)&v30, v16))
  {
    v38[0] = v36;
    v38[1] = 0;
    unint64_t v25 = *(void *)(mlir::ValueRange::dereference_iterator(v38, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    v38[0] = v33;
    v38[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v38);
    mlir::ValueRange::ValueRange(v29, (uint64_t)&v25, 1uLL);
    mlir::ValueRange::ValueRange(v28, (uint64_t)v38, 1uLL);
    v26[0] = &unk_1EC97F2A0;
    v27 = v26;
    else {
      v18 = v38;
    }
    unint64_t v19 = *v18;
    uint64_t v20 = *(unsigned int *)(a11 + 8);
    if (v20 >= *(_DWORD *)(a11 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v20 + 1, 8);
      LODWORD(v20) = *(_DWORD *)(a11 + 8);
    }
    *(void *)(*(void *)a11 + 8 * v20) = v19;
    ++*(_DWORD *)(a11 + 8);
    if (v27 == v26)
    {
      (*(void (**)(void *))(v26[0] + 32))(v26);
    }
    else if (v27)
    {
      (*(void (**)(void *))(*v27 + 40))(v27);
    }
  }
  else
  {
    uint64_t v21 = mlir::Float32Type::get(this, v17);
    uint64_t v22 = mlir::UnrankedTensorType::get(v21);
    uint64_t v23 = *(unsigned int *)(a11 + 8);
    if (v23 >= *(_DWORD *)(a11 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v23 + 1, 8);
      LODWORD(v23) = *(_DWORD *)(a11 + 8);
    }
    *(void *)(*(void *)a11 + 8 * v23) = v22;
    ++*(_DWORD *)(a11 + 8);
  }
  return 1;
}

uint64_t mlir::mps::TypeConstraintOpAdaptor::verify(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 24))
  {
    v14[0] = *(void *)(a1 + 24);
    mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v14);
    return 1;
  }
  else
  {
    uint64_t v12 = "'mps.type_constraint' op requires attribute 'type_constraint'";
    __int16 v13 = 259;
    mlir::emitError(a2, (uint64_t)&v12, (uint64_t)v14);
    uint64_t v2 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v14[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v14);
    }
    if (v21)
    {
      v4 = (void **)__p;
      if (__p)
      {
        v5 = v20;
        v6 = __p;
        if (v20 != __p)
        {
          do
            v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
          while (v5 != v4);
          v6 = __p;
        }
        uint64_t v20 = v4;
        operator delete(v6);
      }
      uint64_t v7 = v17;
      if (v17)
      {
        uint64_t v8 = v18;
        unint64_t v9 = v17;
        if (v18 != v17)
        {
          do
          {
            uint64_t v11 = (void *)*--v8;
            uint64_t v10 = v11;
            void *v8 = 0;
            if (v11) {
              operator delete[](v10);
            }
          }
          while (v8 != v7);
          unint64_t v9 = v17;
        }
        v18 = v7;
        operator delete(v9);
      }
      if (v15 != &v16) {
        free(v15);
      }
    }
  }
  return v2;
}

uint64_t mlir::mps::CreateComplexOp::inferReturnTypes(mlir::Float32Type *a1, uint64_t a2, uint64_t a3, mlir::MLIRContext *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v26[1] = *MEMORY[0x1E4F143B8];
  v24 = v26;
  uint64_t v25 = 0x100000000;
  {
    __int16 v13 = *(void **)v24;
    if (*(void *)v24) {
      uint64_t v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v13 + 8);
    }
    else {
      uint64_t v14 = 0;
    }
    v21[0] = (uint64_t)v13;
    v21[1] = v14;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v21);
    uint64_t v20 = mlir::ComplexType::get(OperandRange);
    LOBYTE(v22) = 0;
    char v23 = 0;
    uint64_t v16 = mlir::ShapedType::cloneWith(v21, &v22, v20);
    uint64_t v17 = *(unsigned int *)(a11 + 8);
    if (v17 < *(_DWORD *)(a11 + 12)) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v15 = mlir::Float32Type::get(a1, v12);
    uint64_t v16 = mlir::UnrankedTensorType::get(v15);
    uint64_t v17 = *(unsigned int *)(a11 + 8);
    if (v17 < *(_DWORD *)(a11 + 12)) {
      goto LABEL_7;
    }
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v17 + 1, 8);
  LODWORD(v17) = *(_DWORD *)(a11 + 8);
LABEL_7:
  *(void *)(*(void *)a11 + 8 * v17) = v16;
  ++*(_DWORD *)(a11 + 8);
  if (v24 != v26) {
    free(v24);
  }
  return 1;
}

uint64_t mlir::mps::RealPartOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  unint64_t v28[2] = *MEMORY[0x1E4F143B8];
  uint64_t v21 = a6;
  v22[0] = 0;
  char v23 = 0;
  uint64_t v24 = a9;
  uint64_t v25 = a10;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v21);
    if (v23) {
      char v23 = 0;
    }
    mlir::OperationName::OperationName(v22, "mps.real_part", 13, Context);
    char v23 = 1;
  }
  uint64_t v26 = a4;
  uint64_t v27 = a5;
  if (!a5 {
    || (mlir::UnknownLoc::get(this, a2),
  }
        v28[0] = v26,
        v28[1] = 0,
        uint64_t v15 = mlir::ValueRange::dereference_iterator(v28, 0),
  {
    uint64_t v17 = mlir::Float32Type::get(this, a2);
    uint64_t ComplexPartType = mlir::UnrankedTensorType::get(v17);
  }
  uint64_t v18 = ComplexPartType;
  unsigned int v19 = *(_DWORD *)(a11 + 8);
  if (v19 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v19 + 1, 8);
    unsigned int v19 = *(_DWORD *)(a11 + 8);
  }
  *(void *)(*(void *)a11 + 8 * v19) = v18;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::anonymous namespace'::inferGetComplexPartType(void *a1)
{
  if (!mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*a1 + 8))
  {
    unint64_t v9 = 0;
    uint64_t v10 = 0;
    return 0;
  }
  uint64_t v2 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*a1 + 8);
  unint64_t v9 = a1;
  uint64_t v10 = v2;
  if (!a1) {
    return 0;
  }
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(a1);
  if (*(_UNKNOWN **)(*(void *)ElementTypeOrSelf + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id) {
    uint64_t v4 = ElementTypeOrSelf;
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t v8 = v4;
  if (v4) {
    uint64_t ElementTypeOrSelf = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v8);
  }
  LOBYTE(v6) = 0;
  char v7 = 0;
  return mlir::ShapedType::cloneWith((uint64_t *)&v9, &v6, ElementTypeOrSelf);
}

uint64_t mlir::mps::ImaginaryPartOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  unint64_t v28[2] = *MEMORY[0x1E4F143B8];
  uint64_t v21 = a6;
  v22[0] = 0;
  char v23 = 0;
  uint64_t v24 = a9;
  uint64_t v25 = a10;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v21);
    if (v23) {
      char v23 = 0;
    }
    mlir::OperationName::OperationName(v22, "mps.imaginary_part", 18, Context);
    char v23 = 1;
  }
  uint64_t v26 = a4;
  uint64_t v27 = a5;
  if (!a5 {
    || (mlir::UnknownLoc::get(this, a2),
  }
        v28[0] = v26,
        v28[1] = 0,
        uint64_t v15 = mlir::ValueRange::dereference_iterator(v28, 0),
  {
    uint64_t v17 = mlir::Float32Type::get(this, a2);
    uint64_t ComplexPartType = mlir::UnrankedTensorType::get(v17);
  }
  uint64_t v18 = ComplexPartType;
  unsigned int v19 = *(_DWORD *)(a11 + 8);
  if (v19 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v19 + 1, 8);
    unsigned int v19 = *(_DWORD *)(a11 + 8);
  }
  *(void *)(*(void *)a11 + 8 * v19) = v18;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::anonymous namespace'::verifyFFTAxes(uint64_t *a1, void *a2, const char **a3)
{
  v104[6] = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    v86 = 0;
    uint64_t v87 = 0;
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v86)) {
      goto LABEL_5;
    }
    return 1;
  }
  uint64_t v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*a2 + 8);
  v86 = a2;
  uint64_t v87 = v6;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v86)) {
    return 1;
  }
LABEL_5:
  v102 = a3;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v102);
  if (!DefiningOp) {
    return 1;
  }
  uint64_t v8 = DefiningOp;
  if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((void *)(DefiningOp + 48))) {
    return 1;
  }
  v91[0] = &v92;
  v91[1] = (void *)0x100000000;
  mlir::Operation::fold(v8, 0, 0, (uint64_t)v91);
  unint64_t v9 = *(void *)v91[0] & 0xFFFFFFFFFFFFFFF8;
  BOOL v10 = v9 != 0;
  int v11 = mlir::DenseIntElementsAttr::classof(v9);
  char v12 = v11 & v10;
  if ((v11 & v10) != 0) {
    __int16 v13 = (void *)v9;
  }
  else {
    __int16 v13 = 0;
  }
  if (v91[0] != &v92) {
    free(v91[0]);
  }
  if ((v12 & 1) == 0) {
    return 1;
  }
  v102 = (const char **)v104;
  uint64_t v103 = 0x600000000;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v86);
  uint64_t v15 = v14;
  if (v13) {
    uint64_t v16 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v13 + 8);
  }
  else {
    uint64_t v16 = 0;
  }
  {
    if (v103)
    {
      unsigned int v19 = v102;
      uint64_t v20 = 8 * v103;
      while (1)
      {
        uint64_t v21 = *v19;
        if (v15 - (uint64_t)*v19 >= 5) {
          break;
        }
        ++v19;
        v20 -= 8;
        if (!v20) {
          goto LABEL_23;
        }
      }
      v84 = (const void **)"invalid axis: ";
      __int16 v85 = 259;
      mlir::Operation::emitOpError(a1, &v84, (uint64_t)v91);
      if (v91[0])
      {
        int v88 = 2;
        v89 = v21;
        long long v22 = &v88;
        char v23 = (char *)v93;
        if (v94 >= v95)
        {
          unint64_t v64 = v94 + 1;
          if (v93 <= &v88 && (char *)v93 + 24 * v94 > (char *)&v88)
          {
            int64_t v77 = (char *)&v88 - (unsigned char *)v93;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v64, 24);
            char v23 = (char *)v93;
            long long v22 = (int *)((char *)v93 + v77);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v64, 24);
            long long v22 = &v88;
            char v23 = (char *)v93;
          }
        }
        uint64_t v24 = &v23[24 * v94];
        long long v25 = *(_OWORD *)v22;
        *((void *)v24 + 2) = *((void *)v22 + 2);
        *(_OWORD *)uint64_t v24 = v25;
        uint64_t v26 = ++v94;
        if (v91[0])
        {
          int v88 = 3;
          v89 = " for rank: ";
          uint64_t v90 = 11;
          uint64_t v27 = &v88;
          v28 = (char *)v93;
          if (v26 >= v95)
          {
            unint64_t v65 = v26 + 1;
            BOOL v66 = (char *)v93 + 24 * v26 > (char *)&v88;
            if (v93 <= &v88 && v66)
            {
              int64_t v78 = (char *)&v88 - (unsigned char *)v93;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v65, 24);
              v28 = (char *)v93;
              uint64_t v27 = (int *)((char *)v93 + v78);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v65, 24);
              uint64_t v27 = &v88;
              v28 = (char *)v93;
            }
          }
          v29 = &v28[24 * v94];
          long long v30 = *(_OWORD *)v27;
          *((void *)v29 + 2) = *((void *)v27 + 2);
          *(_OWORD *)v29 = v30;
          uint64_t v31 = ++v94;
          if (v91[0])
          {
            int v88 = 2;
            v89 = (const char *)v15;
            char v32 = &v88;
            uint64_t v33 = (char *)v93;
            if (v31 >= v95)
            {
              unint64_t v67 = v31 + 1;
              BOOL v68 = (char *)v93 + 24 * v31 > (char *)&v88;
              if (v93 <= &v88 && v68)
              {
                int64_t v79 = (char *)&v88 - (unsigned char *)v93;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v67, 24);
                uint64_t v33 = (char *)v93;
                char v32 = (int *)((char *)v93 + v79);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v67, 24);
                char v32 = &v88;
                uint64_t v33 = (char *)v93;
              }
            }
            uint64_t v34 = &v33[24 * v94];
            long long v35 = *(_OWORD *)v32;
            *((void *)v34 + 2) = *((void *)v32 + 2);
            *(_OWORD *)uint64_t v34 = v35;
            uint64_t v36 = ++v94;
            if (v91[0])
            {
              int v88 = 3;
              v89 = ". Transform supported only on the last four dimensions";
              uint64_t v90 = 54;
              uint64_t v37 = &v88;
              v38 = (char *)v93;
              if (v36 >= v95)
              {
                unint64_t v69 = v36 + 1;
                BOOL v70 = (char *)v93 + 24 * v36 > (char *)&v88;
                if (v93 <= &v88 && v70)
                {
                  int64_t v80 = (char *)&v88 - (unsigned char *)v93;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v69, 24);
                  v38 = (char *)v93;
                  uint64_t v37 = (int *)((char *)v93 + v80);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v69, 24);
                  uint64_t v37 = &v88;
                  v38 = (char *)v93;
                }
              }
              v39 = &v38[24 * v94];
              long long v40 = *(_OWORD *)v37;
              *((void *)v39 + 2) = *((void *)v37 + 2);
              *(_OWORD *)v39 = v40;
              uint64_t v41 = ++v94;
              if (v91[0])
              {
                int v88 = 3;
                v89 = ", ie. axis must be larger than ";
                uint64_t v90 = 31;
                v42 = &v88;
                v43 = (char *)v93;
                if (v41 >= v95)
                {
                  unint64_t v71 = v41 + 1;
                  BOOL v72 = (char *)v93 + 24 * v41 > (char *)&v88;
                  if (v93 <= &v88 && v72)
                  {
                    int64_t v81 = (char *)&v88 - (unsigned char *)v93;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v71, 24);
                    v43 = (char *)v93;
                    v42 = (int *)((char *)v93 + v81);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v71, 24);
                    v42 = &v88;
                    v43 = (char *)v93;
                  }
                }
                v44 = &v43[24 * v94];
                long long v45 = *(_OWORD *)v42;
                *((void *)v44 + 2) = *((void *)v42 + 2);
                *(_OWORD *)v44 = v45;
                uint64_t v46 = ++v94;
                if (v91[0])
                {
                  int v88 = 2;
                  v89 = (const char *)(v15 - 5);
                  v47 = &v88;
                  v48 = (char *)v93;
                  if (v46 >= v95)
                  {
                    unint64_t v73 = v46 + 1;
                    BOOL v74 = (char *)v93 + 24 * v46 > (char *)&v88;
                    if (v93 <= &v88 && v74)
                    {
                      int64_t v82 = (char *)&v88 - (unsigned char *)v93;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v73, 24);
                      v48 = (char *)v93;
                      v47 = (int *)((char *)v93 + v82);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v73, 24);
                      v47 = &v88;
                      v48 = (char *)v93;
                    }
                  }
                  v49 = &v48[24 * v94];
                  long long v50 = *(_OWORD *)v47;
                  *((void *)v49 + 2) = *((void *)v47 + 2);
                  *(_OWORD *)v49 = v50;
                  uint64_t v51 = ++v94;
                  if (v91[0])
                  {
                    int v88 = 3;
                    v89 = ".";
                    uint64_t v90 = 1;
                    v52 = &v88;
                    v53 = (char *)v93;
                    if (v51 >= v95)
                    {
                      unint64_t v75 = v51 + 1;
                      BOOL v76 = (char *)v93 + 24 * v51 > (char *)&v88;
                      if (v93 <= &v88 && v76)
                      {
                        int64_t v83 = (char *)&v88 - (unsigned char *)v93;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v75, 24);
                        v53 = (char *)v93;
                        v52 = (int *)((char *)v93 + v83);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v75, 24);
                        v52 = &v88;
                        v53 = (char *)v93;
                      }
                    }
                    v54 = &v53[24 * v94];
                    long long v55 = *(_OWORD *)v52;
                    *((void *)v54 + 2) = *((void *)v52 + 2);
                    *(_OWORD *)v54 = v55;
                    ++v94;
                  }
                }
              }
            }
          }
        }
      }
      uint64_t v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v91);
      if (v91[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v91);
      }
      if (v101)
      {
        v56 = (void **)__p;
        if (__p)
        {
          v57 = v100;
          v58 = __p;
          if (v100 != __p)
          {
            do
              v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
            while (v57 != v56);
            v58 = __p;
          }
          v100 = v56;
          operator delete(v58);
        }
        v59 = v97;
        if (v97)
        {
          v60 = v98;
          v61 = v97;
          if (v98 != v97)
          {
            do
            {
              v63 = (void *)*--v60;
              v62 = v63;
              void *v60 = 0;
              if (v63) {
                operator delete[](v62);
              }
            }
            while (v60 != v59);
            v61 = v97;
          }
          v98 = v59;
          operator delete(v61);
        }
        if (v93 != v96) {
          free(v93);
        }
      }
    }
    else
    {
LABEL_23:
      uint64_t v17 = 1;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  if (v102 != v104) {
    free(v102);
  }
  return v17;
}

uint64_t mlir::mps::FastFourierTransformOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, unint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  v37[0] = a4;
  v37[1] = a5;
  if (a7) {
    long long v14 = *a7;
  }
  else {
    long long v14 = 0uLL;
  }
  uint64_t v29 = a6;
  v30[0] = 0;
  char v31 = 0;
  long long v32 = v14;
  uint64_t v33 = a9;
  uint64_t v34 = a10;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v29);
    if (v31) {
      char v31 = 0;
    }
    mlir::OperationName::OperationName(v30, "mps.fast_fourier_transform", 26, Context);
    char v31 = 1;
  }
  unint64_t v35 = a4;
  uint64_t v36 = a5;
  if (a5)
  {
    uint64_t v16 = mlir::UnknownLoc::get(this, a2);
    if (mlir::mps::FastFourierTransformOpAdaptor::verify((uint64_t)&v29, v16))
    {
      long long v38 = v35;
      uint64_t v17 = (void *)(*(void *)(mlir::ValueRange::dereference_iterator(&v38, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v17 + 8))
      {
        uint64_t v18 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v17 + 8);
        uint64_t v27 = v17;
        uint64_t v28 = v18;
        if (v17)
        {
          uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v17);
          uint64_t v20 = ElementTypeOrSelf;
          if (!ElementTypeOrSelf
            || *(_UNKNOWN **)(*(void *)ElementTypeOrSelf + 136) != &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
          {
            uint64_t v20 = mlir::ComplexType::get(ElementTypeOrSelf);
          }
          LOBYTE(v38) = 0;
          char v39 = 0;
          unint64_t v21 = mlir::ShapedType::cloneWith((uint64_t *)&v27, &v38, v20);
          unsigned int v22 = *(_DWORD *)(a11 + 8);
          if (v22 < *(_DWORD *)(a11 + 12)) {
            goto LABEL_16;
          }
          goto LABEL_23;
        }
      }
      else
      {
        uint64_t v27 = 0;
        uint64_t v28 = 0;
      }
      unint64_t v21 = *(void *)(mlir::ValueRange::dereference_iterator(v37, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
      unsigned int v22 = *(_DWORD *)(a11 + 8);
      if (v22 < *(_DWORD *)(a11 + 12))
      {
LABEL_16:
        *(void *)(*(void *)a11 + 8 * v22) = v21;
        goto LABEL_20;
      }
LABEL_23:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v22 + 1, 8);
      unsigned int v22 = *(_DWORD *)(a11 + 8);
      goto LABEL_16;
    }
  }
  uint64_t v23 = mlir::Float32Type::get(this, a2);
  uint64_t v24 = mlir::UnrankedTensorType::get(v23);
  uint64_t v25 = *(unsigned int *)(a11 + 8);
  if (v25 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v25 + 1, 8);
    LODWORD(v25) = *(_DWORD *)(a11 + 8);
  }
  *(void *)(*(void *)a11 + 8 * v25) = v24;
LABEL_20:
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::FastFourierTransformOpAdaptor::verify(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 32)) {
    return 1;
  }
  char v12 = "'mps.fast_fourier_transform' op requires attribute 'scaling_mode'";
  __int16 v13 = 259;
  mlir::emitError(a2, (uint64_t)&v12, (uint64_t)v14);
  uint64_t v2 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
  if (v14[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v14);
  }
  if (v21)
  {
    uint64_t v4 = (void **)__p;
    if (__p)
    {
      v5 = v20;
      uint64_t v6 = __p;
      if (v20 != __p)
      {
        do
          v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
        while (v5 != v4);
        uint64_t v6 = __p;
      }
      uint64_t v20 = v4;
      operator delete(v6);
    }
    char v7 = v17;
    if (v17)
    {
      uint64_t v8 = v18;
      unint64_t v9 = v17;
      if (v18 != v17)
      {
        do
        {
          int v11 = (void *)*--v8;
          BOOL v10 = v11;
          void *v8 = 0;
          if (v11) {
            operator delete[](v10);
          }
        }
        while (v8 != v7);
        unint64_t v9 = v17;
      }
      uint64_t v18 = v7;
      operator delete(v9);
    }
    if (v15 != &v16) {
      free(v15);
    }
  }
  return v2;
}

uint64_t mlir::mps::RealToHermiteanFFTOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, unint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (a7) {
    long long v14 = *a7;
  }
  else {
    long long v14 = 0uLL;
  }
  uint64_t v24 = a6;
  v25[0] = 0;
  char v26 = 0;
  long long v27 = v14;
  uint64_t v28 = a9;
  uint64_t v29 = a10;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v24);
    if (v26) {
      char v26 = 0;
    }
    mlir::OperationName::OperationName(v25, "mps.real_to_hermitean_fft", 25, Context);
    char v26 = 1;
  }
  unint64_t v30 = a4;
  uint64_t v31 = a5;
  if (!a5) {
    goto LABEL_11;
  }
  uint64_t v16 = mlir::UnknownLoc::get(this, a2);
  if (!mlir::mps::RealToHermiteanFFTOpAdaptor::verify((uint64_t)&v24, v16)) {
    goto LABEL_11;
  }
  unint64_t v32 = v30;
  uint64_t v33 = 0;
  uint64_t v17 = (void *)(*(void *)(mlir::ValueRange::dereference_iterator(&v32, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  unint64_t v32 = v30;
  uint64_t v33 = 1;
  unint64_t v32 = mlir::ValueRange::offset_base(&v32, 1);
  uint64_t v33 = 0;
  uint64_t v18 = mlir::ValueRange::dereference_iterator(&v32, 0);
  if (!v19)
  {
LABEL_11:
    uint64_t v20 = mlir::Float32Type::get(this, a2);
    uint64_t v19 = mlir::UnrankedTensorType::get(v20);
  }
  uint64_t v21 = v19;
  unsigned int v22 = *(_DWORD *)(a11 + 8);
  if (v22 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v22 + 1, 8);
    unsigned int v22 = *(_DWORD *)(a11 + 8);
  }
  *(void *)(*(void *)a11 + 8 * v22) = v21;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::RealToHermiteanFFTOpAdaptor::verify(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 32)) {
    return 1;
  }
  char v12 = "'mps.real_to_hermitean_fft' op requires attribute 'scaling_mode'";
  __int16 v13 = 259;
  mlir::emitError(a2, (uint64_t)&v12, (uint64_t)v14);
  uint64_t v2 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
  if (v14[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v14);
  }
  if (v21)
  {
    uint64_t v4 = (void **)__p;
    if (__p)
    {
      v5 = v20;
      uint64_t v6 = __p;
      if (v20 != __p)
      {
        do
          v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
        while (v5 != v4);
        uint64_t v6 = __p;
      }
      uint64_t v20 = v4;
      operator delete(v6);
    }
    char v7 = v17;
    if (v17)
    {
      uint64_t v8 = v18;
      unint64_t v9 = v17;
      if (v18 != v17)
      {
        do
        {
          int v11 = (void *)*--v8;
          BOOL v10 = v11;
          void *v8 = 0;
          if (v11) {
            operator delete[](v10);
          }
        }
        while (v8 != v7);
        unint64_t v9 = v17;
      }
      uint64_t v18 = v7;
      operator delete(v9);
    }
    if (v15 != &v16) {
      free(v15);
    }
  }
  return v2;
}

uint64_t mlir::mps::anonymous namespace'::inferHermiteanFFTType(void *a1, uint64_t a2, int a3, unsigned int a4)
{
  v53[4] = *MEMORY[0x1E4F143B8];
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(a1);
  if (*(_UNKNOWN **)(*(void *)ElementTypeOrSelf + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id) {
    uint64_t v9 = ElementTypeOrSelf;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v47 = v9;
  if (!a3)
  {
    if (!v9)
    {
      uint64_t Value = mlir::ComplexType::get(ElementTypeOrSelf);
      uint64_t v11 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*a1 + 8);
      if (v11) {
        goto LABEL_7;
      }
LABEL_12:
      long long v45 = 0;
      uint64_t v46 = v11;
      return mlir::UnrankedTensorType::get(Value);
    }
    return 0;
  }
  if (!v9) {
    return 0;
  }
  uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v47);
  uint64_t v11 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*a1 + 8);
  if (!v11) {
    goto LABEL_12;
  }
LABEL_7:
  uint64_t v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*a1 + 8);
  long long v45 = a1;
  uint64_t v46 = v12;
  if (!a1 || (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v45) & 1) == 0) {
    return mlir::UnrankedTensorType::get(Value);
  }
  __b = v50;
  uint64_t v49 = 0x400000000;
  ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v45);
  unint64_t v16 = v15;
  uint64_t v51 = v53;
  uint64_t v52 = 0x400000000;
  char matched = mlir::matchConstantWithIntVector<long long>(a2, (uint64_t)&v51);
  if (!matched || !v52)
  {
    int8x8_t v19 = (int8x8_t)-1;
    goto LABEL_26;
  }
  unint64_t v18 = (v52 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (v18 >= 3)
  {
    unint64_t v21 = v18 + 1;
    uint64_t v22 = (v18 + 1) & 0x3FFFFFFFFFFFFFFCLL;
    uint64_t v20 = (uint64_t *)((char *)v51 + 8 * v22);
    int8x16_t v23 = (int8x16_t)vdupq_n_s64(v16);
    uint64_t v24 = (int64x2_t *)((char *)v51 + 16);
    v25.i64[0] = -1;
    v25.i64[1] = -1;
    uint64_t v26 = v22;
    v27.i64[0] = -1;
    v27.i64[1] = -1;
    do
    {
      int64x2_t v28 = vaddq_s64((int64x2_t)vandq_s8((int8x16_t)vcltzq_s64(v24[-1]), v23), v24[-1]);
      int64x2_t v29 = vaddq_s64((int64x2_t)vandq_s8((int8x16_t)vcltzq_s64(*v24), v23), *v24);
      int64x2_t v25 = (int64x2_t)vbslq_s8((int8x16_t)vcgtq_s64(v28, v25), (int8x16_t)v28, (int8x16_t)v25);
      int64x2_t v27 = (int64x2_t)vbslq_s8((int8x16_t)vcgtq_s64(v29, v27), (int8x16_t)v29, (int8x16_t)v27);
      v24 += 2;
      v26 -= 4;
    }
    while (v26);
    int8x16_t v30 = vbslq_s8((int8x16_t)vcgtq_s64(v25, v27), (int8x16_t)v25, (int8x16_t)v27);
    uint64_t v31 = vextq_s8(v30, v30, 8uLL).u64[0];
    int8x8_t v19 = vbsl_s8((int8x8_t)vcgtd_s64(v30.i64[0], v31), *(int8x8_t *)v30.i8, (int8x8_t)v31);
    if (v21 == v22) {
      goto LABEL_26;
    }
  }
  else
  {
    int8x8_t v19 = (int8x8_t)-1;
    uint64_t v20 = (uint64_t *)v51;
  }
  do
  {
    uint64_t v32 = *v20++;
    int8x8_t v33 = (int8x8_t)((v16 & (v32 >> 63)) + v32);
    if (*(void *)&v33 > *(void *)&v19) {
      int8x8_t v19 = v33;
    }
  }
  while (v20 != (uint64_t *)((char *)v51 + 8 * v52));
LABEL_26:
  uint64_t v34 = v49;
  if (v16 != v49)
  {
    if (v16 >= v49)
    {
      if (v16 > HIDWORD(v49))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__b, v50, v16, 8);
        uint64_t v34 = v49;
      }
      if (v16 != v34) {
        bzero((char *)__b + 8 * v34, 8 * (v16 - v34));
      }
    }
    LODWORD(v49) = v16;
    LODWORD(v34) = v16;
  }
  if (!v16) {
    goto LABEL_54;
  }
  unint64_t v35 = (uint64_t *)__b;
  if (a3)
  {
    if (matched)
    {
      do
      {
        unint64_t v37 = *ArgAttrsAttr++;
        unint64_t v36 = v37;
        unint64_t v38 = (a4 | (2 * v37)) - 2;
        if (v37 == 0x8000000000000000) {
          unint64_t v38 = 0x8000000000000000;
        }
        if (!*(void *)&v19) {
          unint64_t v36 = v38;
        }
        *v35++ = v36;
        --*(void *)&v19;
        --v16;
      }
      while (v16);
      goto LABEL_54;
    }
  }
  else if (matched)
  {
    do
    {
      uint64_t v40 = *ArgAttrsAttr++;
      uint64_t v39 = v40;
      if (v40 >= 0) {
        uint64_t v41 = v39;
      }
      else {
        uint64_t v41 = v39 + 1;
      }
      uint64_t v42 = v41 >> 1;
      if (v39 == 0x8000000000000000) {
        unint64_t v43 = 0x8000000000000000;
      }
      else {
        unint64_t v43 = v42 + 1;
      }
      if (!*(void *)&v19) {
        uint64_t v39 = v43;
      }
      *v35++ = v39;
      --*(void *)&v19;
      --v16;
    }
    while (v16);
    goto LABEL_54;
  }
  memset_pattern16(__b, &unk_1811000C0, 8 * v16);
LABEL_54:
  if (v51 != v53)
  {
    free(v51);
    LODWORD(v34) = v49;
  }
  uint64_t v13 = mlir::RankedTensorType::get((uint64_t)__b, v34, Value, 0);
  if (__b != v50) {
    free(__b);
  }
  return v13;
}

uint64_t mlir::mps::HermiteanToRealFFTOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, unint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (a7)
  {
    long long v14 = *a7;
    uint64_t v15 = *((void *)a7 + 2);
  }
  else
  {
    uint64_t v15 = 0;
    long long v14 = 0uLL;
  }
  uint64_t v26 = a6;
  v27[0] = 0;
  char v28 = 0;
  long long v29 = v14;
  uint64_t v30 = v15;
  uint64_t v31 = a9;
  uint64_t v32 = a10;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v26);
    if (v28) {
      char v28 = 0;
    }
    mlir::OperationName::OperationName(v27, "mps.hermitean_to_real_fft", 25, Context);
    char v28 = 1;
  }
  unint64_t v33 = a4;
  uint64_t v34 = a5;
  if (!a5) {
    goto LABEL_11;
  }
  uint64_t v17 = mlir::UnknownLoc::get(this, a2);
  if (!mlir::mps::HermiteanToRealFFTOpAdaptor::verify((uint64_t)&v26, v17)) {
    goto LABEL_11;
  }
  unsigned int v18 = *((void *)&v29 + 1) != 0;
  unint64_t v35 = v33;
  uint64_t v36 = 0;
  int8x8_t v19 = (void *)(*(void *)(mlir::ValueRange::dereference_iterator(&v35, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  unint64_t v35 = v33;
  uint64_t v36 = 1;
  unint64_t v35 = mlir::ValueRange::offset_base(&v35, 1);
  uint64_t v36 = 0;
  uint64_t v20 = mlir::ValueRange::dereference_iterator(&v35, 0);
  if (!v21)
  {
LABEL_11:
    uint64_t v22 = mlir::Float32Type::get(this, a2);
    uint64_t v21 = mlir::UnrankedTensorType::get(v22);
  }
  uint64_t v23 = v21;
  unsigned int v24 = *(_DWORD *)(a11 + 8);
  if (v24 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v24 + 1, 8);
    unsigned int v24 = *(_DWORD *)(a11 + 8);
  }
  *(void *)(*(void *)a11 + 8 * v24) = v23;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::HermiteanToRealFFTOpAdaptor::verify(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 40)) {
    return 1;
  }
  uint64_t v12 = "'mps.hermitean_to_real_fft' op requires attribute 'scaling_mode'";
  __int16 v13 = 259;
  mlir::emitError(a2, (uint64_t)&v12, (uint64_t)v14);
  uint64_t v2 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
  if (v14[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v14);
  }
  if (v21)
  {
    uint64_t v4 = (void **)__p;
    if (__p)
    {
      v5 = v20;
      uint64_t v6 = __p;
      if (v20 != __p)
      {
        do
          v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
        while (v5 != v4);
        uint64_t v6 = __p;
      }
      uint64_t v20 = v4;
      operator delete(v6);
    }
    char v7 = v17;
    if (v17)
    {
      uint64_t v8 = v18;
      uint64_t v9 = v17;
      if (v18 != v17)
      {
        do
        {
          uint64_t v11 = (void *)*--v8;
          BOOL v10 = v11;
          void *v8 = 0;
          if (v11) {
            operator delete[](v10);
          }
        }
        while (v8 != v7);
        uint64_t v9 = v17;
      }
      unsigned int v18 = v7;
      operator delete(v9);
    }
    if (v15 != &v16) {
      free(v15);
    }
  }
  return v2;
}

uint64_t mlir::mps::NonZeroOp::inferReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v36 = v38;
  memset_pattern16(v38, &unk_1811000C0, 0x10uLL);
  uint64_t v37 = 0x200000002;
  uint64_t v29 = a6;
  v30[0] = 0;
  char v31 = 0;
  uint64_t v32 = a9;
  uint64_t v33 = a10;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v29);
    if (v31) {
      char v31 = 0;
    }
    mlir::OperationName::OperationName(v30, "mps.non_zero", 12, Context);
    char v31 = 1;
  }
  uint64_t v34 = a4;
  uint64_t v35 = a5;
  if (a5)
  {
    mlir::UnknownLoc::get(a1, v15);
    uint64_t v39 = v34;
    uint64_t v40 = 0;
    uint64_t v17 = (void *)(*(void *)(mlir::ValueRange::dereference_iterator(&v39, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v17 + 8))
    {
      uint64_t v18 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v17 + 8);
      uint64_t v39 = v17;
      uint64_t v40 = v18;
      if (v17 && (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v39) & 1) != 0)
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v39);
        if (v23 <= 1) {
          uint64_t v24 = 1;
        }
        else {
          uint64_t v24 = v23;
        }
        *((void *)v36 + 1) = v24;
      }
    }
    else
    {
      uint64_t v39 = 0;
      uint64_t v40 = 0;
    }
    uint64_t v25 = mlir::IntegerType::get((uint64_t)a1, 0x20u, 1u);
    uint64_t v26 = mlir::RankedTensorType::get((uint64_t)v36, v37, v25, 0);
    unsigned int v27 = *(_DWORD *)(a11 + 8);
    if (v27 >= *(_DWORD *)(a11 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v27 + 1, 8);
      unsigned int v27 = *(_DWORD *)(a11 + 8);
    }
    *(void *)(*(void *)a11 + 8 * v27) = v26;
    ++*(_DWORD *)(a11 + 8);
    uint64_t v22 = v36;
    if (v36 != v38) {
LABEL_22:
    }
      free(v22);
  }
  else
  {
    uint64_t v19 = mlir::IntegerType::get((uint64_t)a1, 0x20u, 1u);
    uint64_t v20 = mlir::RankedTensorType::get((uint64_t)v36, v37, v19, 0);
    uint64_t v21 = *(unsigned int *)(a11 + 8);
    if (v21 >= *(_DWORD *)(a11 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v21 + 1, 8);
      LODWORD(v21) = *(_DWORD *)(a11 + 8);
    }
    *(void *)(*(void *)a11 + 8 * v21) = v20;
    ++*(_DWORD *)(a11 + 8);
    uint64_t v22 = v36;
    if (v36 != v38) {
      goto LABEL_22;
    }
  }
  return 1;
}

uint64_t mlir::mps::ImToColOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v103 = *MEMORY[0x1E4F143B8];
  uint64_t v101 = a4;
  uint64_t v102 = a5;
  if (a7)
  {
    long long v14 = *a7;
    long long v15 = a7[1];
    uint64_t v16 = (void *)*((void *)a7 + 4);
  }
  else
  {
    uint64_t v16 = 0;
    long long v14 = 0uLL;
    long long v15 = 0uLL;
  }
  uint64_t v91 = a6;
  v92[0] = 0;
  char v93 = 0;
  long long v94 = v14;
  long long v95 = v15;
  v96 = v16;
  uint64_t v97 = a9;
  uint64_t v17 = a5;
  uint64_t v98 = a10;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v91);
    if (v93) {
      char v93 = 0;
    }
    mlir::OperationName::OperationName(v92, "mps.im_to_col", 13, Context);
    char v93 = 1;
    uint64_t v17 = v102;
  }
  uint64_t v99 = a4;
  uint64_t v100 = a5;
  if (v17 != 1
    || (uint64_t v19 = mlir::UnknownLoc::get(this, a2), !mlir::mps::ImToColOpAdaptor::verify(&v91, v19)))
  {
    uint64_t v24 = mlir::Float32Type::get(this, a2);
    uint64_t v25 = mlir::UnrankedTensorType::get(v24);
    uint64_t v26 = *(unsigned int *)(a11 + 8);
    if (v26 >= *(_DWORD *)(a11 + 12))
    {
LABEL_28:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v26 + 1, 8);
      LODWORD(v26) = *(_DWORD *)(a11 + 8);
    }
LABEL_14:
    *(void *)(*(void *)a11 + 8 * v26) = v25;
    ++*(_DWORD *)(a11 + 8);
    return 1;
  }
  uint64_t v20 = mlir::ValueRange::dereference_iterator(&v101, 0);
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
  uint64_t v22 = (void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v22 + 8))
  {
    v63 = 0;
    uint64_t v64 = 0;
    goto LABEL_27;
  }
  uint64_t v23 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v22 + 8);
  v63 = v22;
  uint64_t v64 = v23;
  if (!v22
    || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v63)
    || (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v63), v28 != 4))
  {
LABEL_27:
    uint64_t v25 = mlir::UnrankedTensorType::get(ElementTypeOrSelf);
    uint64_t v26 = *(unsigned int *)(a11 + 8);
    if (v26 >= *(_DWORD *)(a11 + 12)) {
      goto LABEL_28;
    }
    goto LABEL_14;
  }
  ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v63);
  uint64_t v30 = *((void *)&v95 + 1);
  uint64_t v31 = *ArgAttrsAttr;
  uint64_t v32 = 3;
  uint64_t v33 = 1;
  if (*(_DWORD *)(v94 + 8)) {
    uint64_t v34 = 3;
  }
  else {
    uint64_t v34 = 1;
  }
  if (*(_DWORD *)(v94 + 8)) {
    uint64_t v32 = 2;
  }
  else {
    uint64_t v33 = 2;
  }
  uint64_t v35 = ArgAttrsAttr[v34];
  uint64_t v36 = ArgAttrsAttr[v33];
  uint64_t v37 = ArgAttrsAttr[v32];
  int v88 = v90;
  v90[0] = v31;
  v90[1] = v35;
  v90[2] = v36;
  v90[3] = v37;
  uint64_t v89 = 0x400000004;
  v86[0] = v87;
  v86[1] = (void *)0x200000000;
  if (*((void *)&v95 + 1)) {
    uint64_t v38 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(**((void **)&v95 + 1) + 8);
  }
  else {
    uint64_t v38 = 0;
  }
  mlir::getIntValues<long long>(v30, v38, (uint64_t)v86, 1);
  int64_t v83 = &v85;
  long long v85 = *(_OWORD *)v86[0];
  uint64_t v84 = 0x200000002;
  v81[0] = v82;
  v81[1] = (void *)0x200000000;
  uint64_t v39 = (uint64_t)v96;
  if (v96) {
    uint64_t v40 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v96 + 8);
  }
  else {
    uint64_t v40 = 0;
  }
  mlir::getIntValues<long long>(v39, v40, (uint64_t)v81, 1);
  int64_t v78 = &v80;
  long long v80 = *(_OWORD *)v81[0];
  uint64_t v79 = 0x200000002;
  v76[0] = v77;
  v76[1] = (void *)0x200000000;
  uint64_t v41 = *((void *)&v94 + 1);
  if (*((void *)&v94 + 1)) {
    uint64_t v42 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(**((void **)&v94 + 1) + 8);
  }
  else {
    uint64_t v42 = 0;
  }
  mlir::getIntValues<long long>(v41, v42, (uint64_t)v76, 1);
  unint64_t v73 = &v75;
  long long v75 = *(_OWORD *)v76[0];
  uint64_t v74 = 0x200000002;
  v71[0] = v72;
  v71[1] = (void *)0x800000000;
  uint64_t v43 = v95;
  if ((void)v95) {
    uint64_t v44 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(void *)v95 + 8);
  }
  else {
    uint64_t v44 = 0;
  }
  mlir::getIntValues<long long>(v43, v44, (uint64_t)v71, 1);
  uint64_t v45 = 16;
  uint64_t v46 = 32;
  if (!*(_DWORD *)(v94 + 8)) {
    uint64_t v45 = 32;
  }
  uint64_t v47 = 24;
  uint64_t v48 = 40;
  if (!*(_DWORD *)(v94 + 8))
  {
    uint64_t v47 = 40;
    uint64_t v46 = 48;
    uint64_t v48 = 56;
  }
  uint64_t v49 = *(void *)((char *)v71[0] + v45);
  uint64_t v50 = *(void *)((char *)v71[0] + v47);
  uint64_t v51 = *(void *)((char *)v71[0] + v46);
  uint64_t v52 = *(void *)((char *)v71[0] + v48);
  BOOL v68 = v70;
  v70[0] = v49;
  v70[1] = v50;
  v70[2] = v51;
  v70[3] = v52;
  uint64_t v69 = 0x400000004;
  unint64_t v65 = v67;
  uint64_t v66 = 0x300000003;
  v67[0] = *(void *)v88;
  uint64_t v53 = *(void *)v83;
  uint64_t v54 = *((void *)v83 + 1);
  v67[1] = *(void *)v83 * *((void *)v88 + 1) * v54;
  uint64_t v55 = *((void *)v88 + 2);
  uint64_t v56 = *((void *)v88 + 3);
  uint64_t v57 = 0x8000000000000000;
  uint64_t v58 = 0x8000000000000000;
  if (v55 != 0x8000000000000000 && v53 != 0x8000000000000000) {
    uint64_t v58 = (v55 + v49 + ~(*(void *)v73 * (v53 - 1)) + v50 + *(void *)v78) / *(void *)v78;
  }
  if (v56 != 0x8000000000000000 && v54 != 0x8000000000000000) {
    uint64_t v57 = (v51 + v56 + ~(*((void *)v73 + 1) * (v54 - 1)) + v52 + *((void *)v78 + 1)) / *((void *)v78 + 1);
  }
  unint64_t v59 = 0x8000000000000000;
  if (v57 != 0x8000000000000000 && v58 != 0x8000000000000000) {
    unint64_t v59 = v57 * v58;
  }
  v67[2] = v59;
  uint64_t v61 = mlir::RankedTensorType::get((uint64_t)v67, 3, ElementTypeOrSelf, 0);
  uint64_t v62 = *(unsigned int *)(a11 + 8);
  if (v62 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v62 + 1, 8);
    LODWORD(v62) = *(_DWORD *)(a11 + 8);
  }
  *(void *)(*(void *)a11 + 8 * v62) = v61;
  ++*(_DWORD *)(a11 + 8);
  if (v65 != v67) {
    free(v65);
  }
  if (v68 != v70) {
    free(v68);
  }
  if (v71[0] != v72) {
    free(v71[0]);
  }
  if (v73 != &v75) {
    free(v73);
  }
  if (v76[0] != v77) {
    free(v76[0]);
  }
  if (v78 != &v80) {
    free(v78);
  }
  if (v81[0] != v82) {
    free(v81[0]);
  }
  if (v83 != &v85) {
    free(v83);
  }
  if (v86[0] != v87) {
    free(v86[0]);
  }
  if (v88 != v90) {
    free(v88);
  }
  return 1;
}

uint64_t mlir::mps::ImToColOpAdaptor::verify(void *a1, uint64_t a2)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1[3];
  if (v3)
  {
    uint64_t v4 = (const char *)a1[4];
    if (v4)
    {
      v5 = (const char *)a1[5];
      if (v5)
      {
        uint64_t v6 = (const char *)a1[6];
        if (v6)
        {
          char v7 = (const char *)a1[7];
          if (v7)
          {
            uint64_t v8 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(void *)v6 + 8);
            unint64_t v71 = v6;
            uint64_t v72 = v8;
            Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v71);
            BOOL v10 = Type;
            if (Type) {
              Type = (void *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
            }
            BOOL v76 = v10;
            int64_t v77 = Type;
            ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v76);
            v74[0] = 2;
            if (v12 == 1
              && *ArgAttrsAttr == v74[0]
              && (uint64_t OperandRange = v6,
                  llvm::all_of<mlir::DenseIntElementsAttr,mlir::mps::Conv3DDataGradientOpAdaptor::verify(mlir::Location)::$_0>((uint64_t *)&OperandRange))
              && (BOOL v68 = v6,
                  *(void *)&long long v75 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v68),
                  *((void *)&v75 + 1) = v13,
                  uint64_t v69 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v75),
                  mlir::Type::isUnsignedInteger((mlir::Type *)&v69, 64)))
            {
              uint64_t v14 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(void *)v7 + 8);
              unint64_t v71 = v7;
              uint64_t v72 = v14;
              long long v15 = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v71);
              uint64_t v16 = v15;
              if (v15) {
                long long v15 = (void *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v15 + 8);
              }
              BOOL v76 = v16;
              int64_t v77 = v15;
              uint64_t v17 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v76);
              v74[0] = 2;
              if (v18 == 1
                && *v17 == v74[0]
                && (uint64_t OperandRange = v7,
                    llvm::all_of<mlir::DenseIntElementsAttr,mlir::mps::Conv3DDataGradientOpAdaptor::verify(mlir::Location)::$_0>((uint64_t *)&OperandRange))
                && (BOOL v68 = v7,
                    *(void *)&long long v75 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v68),
                    *((void *)&v75 + 1) = v19,
                    uint64_t v69 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v75),
                    mlir::Type::isUnsignedInteger((mlir::Type *)&v69, 64)))
              {
                uint64_t v20 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(void *)v4 + 8);
                unint64_t v71 = v4;
                uint64_t v72 = v20;
                uint64_t v21 = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v71);
                uint64_t v22 = v21;
                if (v21) {
                  uint64_t v21 = (void *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v21 + 8);
                }
                BOOL v76 = v22;
                int64_t v77 = v21;
                uint64_t v23 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v76);
                v74[0] = 2;
                if (v24 == 1
                  && *v23 == v74[0]
                  && (uint64_t OperandRange = v4,
                      llvm::all_of<mlir::DenseIntElementsAttr,mlir::mps::Conv3DDataGradientOpAdaptor::verify(mlir::Location)::$_0>((uint64_t *)&OperandRange))
                  && (BOOL v68 = v4,
                      *(void *)&long long v75 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v68),
                      *((void *)&v75 + 1) = v25,
                      uint64_t v69 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v75),
                      mlir::Type::isUnsignedInteger((mlir::Type *)&v69, 64)))
                {
                  uint64_t v26 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(void *)v5 + 8);
                  unint64_t v71 = v5;
                  uint64_t v72 = v26;
                  unsigned int v27 = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v71);
                  uint64_t v28 = v27;
                  if (v27) {
                    unsigned int v27 = (void *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v27 + 8);
                  }
                  BOOL v76 = v28;
                  int64_t v77 = v27;
                  uint64_t v29 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v76);
                  long long v75 = xmmword_18110B5E0;
                  if (v30 == 2
                    && (*v29 == (void)v75 ? (BOOL v31 = v29[1] == *((void *)&v75 + 1)) : (BOOL v31 = 0),
                        v31
                     && (uint64_t v69 = (uint64_t)v5,
                         v74[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v69),
                         v74[1] = v32,
                         uint64_t OperandRange = (const char *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v74),
                         mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))))
                  {
                    if (*(_DWORD *)(v3 + 8) < 2u) {
                      return 1;
                    }
                    v60 = "'mps.im_to_col' op attribute 'data_layout' failed to satisfy constraint: valid TensorDataLayou"
                          "t is one of NCHW or NHWC";
                  }
                  else
                  {
                    v60 = "'mps.im_to_col' op attribute 'explicit_padding' failed to satisfy constraint: ui64 elements at"
                          "tribute of shape {4, 2}";
                  }
                }
                else
                {
                  v60 = "'mps.im_to_col' op attribute 'dilation_rates' failed to satisfy constraint: positive ui64 elemen"
                        "ts attribute of shape {2}";
                }
              }
              else
              {
                v60 = "'mps.im_to_col' op attribute 'strides' failed to satisfy constraint: positive ui64 elements attrib"
                      "ute of shape {2}";
              }
            }
            else
            {
              v60 = "'mps.im_to_col' op attribute 'kernel_sizes' failed to satisfy constraint: positive ui64 elements att"
                    "ribute of shape {2}";
            }
            unint64_t v71 = v60;
            __int16 v73 = 259;
            mlir::emitError(a2, (uint64_t)&v71, (uint64_t)&v76);
            uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v76);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v76);
            return v33;
          }
          unint64_t v71 = "'mps.im_to_col' op requires attribute 'strides'";
          __int16 v73 = 259;
          mlir::emitError(a2, (uint64_t)&v71, (uint64_t)&v76);
          uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v76);
          if (v76) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v76);
          }
          if (v84)
          {
            uint64_t v61 = (void **)__p;
            if (__p)
            {
              uint64_t v62 = v83;
              v63 = __p;
              if (v83 != __p)
              {
                do
                  uint64_t v62 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v62 - 1);
                while (v62 != v61);
                v63 = __p;
              }
              int64_t v83 = v61;
              operator delete(v63);
            }
            uint64_t v37 = v80;
            if (!v80) {
              goto LABEL_109;
            }
            uint64_t v64 = v81;
            uint64_t v39 = v80;
            if (v81 == v80)
            {
LABEL_108:
              int64_t v81 = v37;
              operator delete(v39);
LABEL_109:
              if (v78 != &v79) {
                free(v78);
              }
              return v33;
            }
            do
            {
              uint64_t v66 = (void *)*--v64;
              unint64_t v65 = v66;
              *uint64_t v64 = 0;
              if (v66) {
                operator delete[](v65);
              }
            }
            while (v64 != v37);
LABEL_107:
            uint64_t v39 = v80;
            goto LABEL_108;
          }
        }
        else
        {
          unint64_t v71 = "'mps.im_to_col' op requires attribute 'kernel_sizes'";
          __int16 v73 = 259;
          mlir::emitError(a2, (uint64_t)&v71, (uint64_t)&v76);
          uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v76);
          if (v76) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v76);
          }
          if (v84)
          {
            uint64_t v54 = (void **)__p;
            if (__p)
            {
              uint64_t v55 = v83;
              uint64_t v56 = __p;
              if (v83 != __p)
              {
                do
                  uint64_t v55 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v55 - 1);
                while (v55 != v54);
                uint64_t v56 = __p;
              }
              int64_t v83 = v54;
              operator delete(v56);
            }
            uint64_t v37 = v80;
            if (!v80) {
              goto LABEL_109;
            }
            uint64_t v57 = v81;
            uint64_t v39 = v80;
            if (v81 == v80) {
              goto LABEL_108;
            }
            do
            {
              unint64_t v59 = (void *)*--v57;
              uint64_t v58 = v59;
              *uint64_t v57 = 0;
              if (v59) {
                operator delete[](v58);
              }
            }
            while (v57 != v37);
            goto LABEL_107;
          }
        }
      }
      else
      {
        unint64_t v71 = "'mps.im_to_col' op requires attribute 'explicit_padding'";
        __int16 v73 = 259;
        mlir::emitError(a2, (uint64_t)&v71, (uint64_t)&v76);
        uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v76);
        if (v76) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v76);
        }
        if (v84)
        {
          uint64_t v48 = (void **)__p;
          if (__p)
          {
            uint64_t v49 = v83;
            uint64_t v50 = __p;
            if (v83 != __p)
            {
              do
                uint64_t v49 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v49 - 1);
              while (v49 != v48);
              uint64_t v50 = __p;
            }
            int64_t v83 = v48;
            operator delete(v50);
          }
          uint64_t v37 = v80;
          if (!v80) {
            goto LABEL_109;
          }
          uint64_t v51 = v81;
          uint64_t v39 = v80;
          if (v81 == v80) {
            goto LABEL_108;
          }
          do
          {
            uint64_t v53 = (void *)*--v51;
            uint64_t v52 = v53;
            *uint64_t v51 = 0;
            if (v53) {
              operator delete[](v52);
            }
          }
          while (v51 != v37);
          goto LABEL_107;
        }
      }
    }
    else
    {
      unint64_t v71 = "'mps.im_to_col' op requires attribute 'dilation_rates'";
      __int16 v73 = 259;
      mlir::emitError(a2, (uint64_t)&v71, (uint64_t)&v76);
      uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v76);
      if (v76) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v76);
      }
      if (v84)
      {
        uint64_t v42 = (void **)__p;
        if (__p)
        {
          uint64_t v43 = v83;
          uint64_t v44 = __p;
          if (v83 != __p)
          {
            do
              uint64_t v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v43 - 1);
            while (v43 != v42);
            uint64_t v44 = __p;
          }
          int64_t v83 = v42;
          operator delete(v44);
        }
        uint64_t v37 = v80;
        if (!v80) {
          goto LABEL_109;
        }
        uint64_t v45 = v81;
        uint64_t v39 = v80;
        if (v81 == v80) {
          goto LABEL_108;
        }
        do
        {
          uint64_t v47 = (void *)*--v45;
          uint64_t v46 = v47;
          *uint64_t v45 = 0;
          if (v47) {
            operator delete[](v46);
          }
        }
        while (v45 != v37);
        goto LABEL_107;
      }
    }
  }
  else
  {
    unint64_t v71 = "'mps.im_to_col' op requires attribute 'data_layout'";
    __int16 v73 = 259;
    mlir::emitError(a2, (uint64_t)&v71, (uint64_t)&v76);
    uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v76);
    if (v76) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v76);
    }
    if (v84)
    {
      uint64_t v34 = (void **)__p;
      if (__p)
      {
        uint64_t v35 = v83;
        uint64_t v36 = __p;
        if (v83 != __p)
        {
          do
            uint64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
          while (v35 != v34);
          uint64_t v36 = __p;
        }
        int64_t v83 = v34;
        operator delete(v36);
      }
      uint64_t v37 = v80;
      if (!v80) {
        goto LABEL_109;
      }
      uint64_t v38 = v81;
      uint64_t v39 = v80;
      if (v81 == v80) {
        goto LABEL_108;
      }
      do
      {
        uint64_t v41 = (void *)*--v38;
        uint64_t v40 = v41;
        void *v38 = 0;
        if (v41) {
          operator delete[](v40);
        }
      }
      while (v38 != v37);
      goto LABEL_107;
    }
  }
  return v33;
}

uint64_t mlir::mps::ImToColOp::verify(uint64_t **this)
{
  v28[6] = *MEMORY[0x1E4F143B8];
  v27[0] = v28;
  v27[1] = 0x600000000;
  unint64_t v2 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11))) {
    unint64_t v2 = 0;
  }
  uint64_t v3 = *(void **)(v2 + 16);
  if (v3) {
    uint64_t v4 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v3 + 8);
  }
  else {
    uint64_t v4 = 0;
  }
  mlir::getIntValues<long long>((uint64_t)v3, v4, (uint64_t)v27, 1);
  v5 = (void *)v27[0];
  uint64_t v6 = *(void *)v27[0];
  if (*(_DWORD *)((*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8] + 8))
  {
    if (!v6 && !*(void *)(v27[0] + 8) && !*(void *)(v27[0] + 48) && !*(void *)(v27[0] + 56)) {
      goto LABEL_37;
    }
  }
  else if (!v6 && !*(void *)(v27[0] + 8) && !*(void *)(v27[0] + 16) && !*(void *)(v27[0] + 24))
  {
LABEL_37:
    uint64_t v7 = 1;
    if ((void *)v27[0] == v28) {
      return v7;
    }
    goto LABEL_35;
  }
  uint64_t v17 = (const void **)"failed: padding should be nonzero on spatial dimension only";
  __int16 v18 = 259;
  mlir::OpState::emitOpError(this, &v17, (uint64_t)v19);
  uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v19);
  if (v19[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v19);
  }
  if (v26)
  {
    uint64_t v8 = (void **)__p;
    if (__p)
    {
      uint64_t v9 = v25;
      BOOL v10 = __p;
      if (v25 != __p)
      {
        do
          uint64_t v9 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v9 - 1);
        while (v9 != v8);
        BOOL v10 = __p;
      }
      uint64_t v25 = v8;
      operator delete(v10);
    }
    uint64_t v11 = v22;
    if (v22)
    {
      uint64_t v12 = v23;
      uint64_t v13 = v22;
      if (v23 != v22)
      {
        do
        {
          long long v15 = (void *)*--v12;
          uint64_t v14 = v15;
          *uint64_t v12 = 0;
          if (v15) {
            operator delete[](v14);
          }
        }
        while (v12 != v11);
        uint64_t v13 = v22;
      }
      uint64_t v23 = v11;
      operator delete(v13);
    }
    if (v20 != &v21) {
      free(v20);
    }
  }
  v5 = (void *)v27[0];
  if ((void *)v27[0] != v28) {
LABEL_35:
  }
    free(v5);
  return v7;
}

uint64_t mlir::mps::get2DElementsForImToCol(mlir::Builder *a1, long long *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = &v11;
  long long v11 = *a2;
  uint64_t v10 = 0x200000002;
  uint64_t v8 = 2;
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  uint64_t v3 = (void *)mlir::RankedTensorType::get((uint64_t)&v8, 1, IntegerType, 0);
  uint64_t v4 = v3;
  if (v3) {
    uint64_t v5 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v3 + 8);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = mlir::DenseElementsAttr::getFromRawBuffer(v4, v5, v9, 8 * v10, 8, 1, 0);
  if (v9 != &v11) {
    free(v9);
  }
  return v6;
}

uint64_t mlir::mps::getFormattedPaddingImToCol(mlir::Builder *a1, uint64_t *a2, uint64_t a3, int a4)
{
  v21[4] = *MEMORY[0x1E4F143B8];
  uint64_t v19 = v21;
  uint64_t v7 = *a2;
  uint64_t v6 = a2[1];
  uint64_t v9 = a2[2];
  uint64_t v8 = a2[3];
  uint64_t v20 = 0x400000000;
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, 8uLL, 8);
  int v10 = v20;
  long long v11 = (char *)v19 + 8 * v20;
  if (a4)
  {
    void *v11 = 0;
    v11[1] = 0;
    v11[2] = v7;
    v11[3] = v6;
    v11[4] = v9;
    v11[5] = v8;
    v11[6] = 0;
    v11[7] = 0;
  }
  else
  {
    *(_OWORD *)long long v11 = 0u;
    *((_OWORD *)v11 + 1) = 0u;
    v11[4] = v7;
    v11[5] = v6;
    v11[6] = v9;
    v11[7] = v8;
  }
  LODWORD(v20) = v10 + 8;
  long long v18 = xmmword_18110B5E0;
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  uint64_t v13 = (void *)mlir::RankedTensorType::get((uint64_t)&v18, 2, IntegerType, 0);
  uint64_t v14 = v13;
  if (v13) {
    uint64_t v15 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v13 + 8);
  }
  else {
    uint64_t v15 = 0;
  }
  uint64_t v16 = mlir::DenseElementsAttr::getFromRawBuffer(v14, v15, v19, 8 * v20, 8, 1, 0);
  if (v19 != v21) {
    free(v19);
  }
  return v16;
}

uint64_t mlir::mps::ColToImOp::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, long long *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  v33[0] = a4;
  v33[1] = a5;
  if (a7)
  {
    long long v13 = *a7;
    long long v14 = a7[1];
    uint64_t v15 = *((void *)a7 + 4);
  }
  else
  {
    uint64_t v15 = 0;
    long long v13 = 0uLL;
    long long v14 = 0uLL;
  }
  uint64_t v23 = a6;
  v24[0] = 0;
  char v25 = 0;
  long long v26 = v13;
  long long v27 = v14;
  uint64_t v28 = v15;
  uint64_t v29 = a9;
  uint64_t v30 = a10;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v23);
    if (v25) {
      char v25 = 0;
    }
    mlir::OperationName::OperationName(v24, "mps.col_to_im", 13, Context);
    char v25 = 1;
  }
  unint64_t v31 = a4;
  uint64_t v32 = a5;
  uint64_t v17 = mlir::ValueRange::dereference_iterator(v33, 0);
  unint64_t v34 = v31;
  uint64_t v35 = 1;
  unint64_t v34 = mlir::ValueRange::offset_base(&v34, 1);
  uint64_t v35 = 0;
  uint64_t v18 = mlir::ValueRange::dereference_iterator(&v34, 0);
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf((void *)(*(void *)(v17 + 8) & 0xFFFFFFFFFFFFFFF8));
  uint64_t TensorType = mlir::mps::getTensorType(v18, ElementTypeOrSelf);
  uint64_t v21 = *(unsigned int *)(a11 + 8);
  if (v21 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v21 + 1, 8);
    LODWORD(v21) = *(_DWORD *)(a11 + 8);
  }
  *(void *)(*(void *)a11 + 8 * v21) = TensorType;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::ColToImOp::verify(uint64_t **this)
{
  v113[6] = *MEMORY[0x1E4F143B8];
  v112[0] = v113;
  v112[1] = (void *)0x600000000;
  unint64_t v2 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11))) {
    unint64_t v2 = 0;
  }
  uint64_t v3 = *(void **)(v2 + 16);
  if (v3) {
    uint64_t v4 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v3 + 8);
  }
  else {
    uint64_t v4 = 0;
  }
  mlir::getIntValues<long long>((uint64_t)v3, v4, (uint64_t)v112, 1);
  unint64_t v5 = *((unsigned int *)*this + 11);
  uint64_t v6 = (uint64_t)&(*this)[2 * ((v5 >> 23) & 1)];
  uint64_t v8 = *(void *)(v6 + 64);
  uint64_t v7 = v6 + 64;
  uint64_t v9 = *(void *)v112[0];
  if (*(_DWORD *)(v8 + 8))
  {
    if (!v9 && !*((void *)v112[0] + 1) && !*((void *)v112[0] + 6) && !*((void *)v112[0] + 7))
    {
LABEL_37:
      v102[0] = v103;
      v102[1] = 0x200000000;
      if (BYTE3(v5)) {
        uint64_t v21 = v7;
      }
      else {
        uint64_t v21 = 0;
      }
      uint64_t v22 = *(void **)(v21 + 24);
      if (v22) {
        uint64_t v23 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v22 + 8);
      }
      else {
        uint64_t v23 = 0;
      }
      mlir::getIntValues<long long>((uint64_t)v22, v23, (uint64_t)v102, 1);
      unint64_t v24 = *((unsigned int *)*this + 11);
      uint64_t v25 = (uint64_t)&(*this)[2 * ((v24 >> 23) & 1) + 8];
      uint64_t v99 = &v101;
      long long v101 = *(_OWORD *)v102[0];
      uint64_t v100 = 0x200000002;
      v97[0] = v98;
      v97[1] = (void *)0x200000000;
      if (BYTE3(v24)) {
        uint64_t v26 = v25;
      }
      else {
        uint64_t v26 = 0;
      }
      long long v27 = *(void **)(v26 + 32);
      if (v27) {
        uint64_t v28 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v27 + 8);
      }
      else {
        uint64_t v28 = 0;
      }
      mlir::getIntValues<long long>((uint64_t)v27, v28, (uint64_t)v97, 1);
      unint64_t v29 = *((unsigned int *)*this + 11);
      uint64_t v30 = (uint64_t)&(*this)[2 * ((v29 >> 23) & 1) + 8];
      long long v94 = &v96;
      long long v96 = *(_OWORD *)v97[0];
      uint64_t v95 = 0x200000002;
      v92[0] = v93;
      v92[1] = (void *)0x200000000;
      if (BYTE3(v29)) {
        uint64_t v31 = v30;
      }
      else {
        uint64_t v31 = 0;
      }
      uint64_t v32 = *(void **)(v31 + 8);
      if (v32) {
        uint64_t v33 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v32 + 8);
      }
      else {
        uint64_t v33 = 0;
      }
      uint64_t v10 = 1;
      mlir::getIntValues<long long>((uint64_t)v32, v33, (uint64_t)v92, 1);
      unint64_t v34 = *this;
      uint64_t v89 = &v91;
      long long v91 = *(_OWORD *)v92[0];
      uint64_t v90 = 0x200000002;
      int v35 = *((_DWORD *)v34 + 9);
      uint64_t v36 = (uint64_t)(v34 - 2);
      if (v35) {
        uint64_t v37 = v36;
      }
      else {
        uint64_t v37 = 0;
      }
      uint64_t v38 = (void *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v37, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (v38)
      {
        uint64_t v39 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v38 + 8);
        v78[0] = v38;
        v78[1] = v39;
        if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v78))
        {
          ArgAttrsAttr = (unsigned char *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v78);
          uint64_t v41 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v78);
          uint64_t v43 = (unsigned char *)(v41 + 8 * v42);
          v86 = v88;
          uint64_t v87 = 0x400000000;
          uint64_t v44 = v43 - ArgAttrsAttr;
          if ((unint64_t)(v43 - ArgAttrsAttr) < 0x21)
          {
            unsigned int v45 = 0;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v86, v88, v44 >> 3, 8);
            unsigned int v45 = v87;
          }
          if (v43 != ArgAttrsAttr)
          {
            memcpy((char *)v86 + 8 * v45, ArgAttrsAttr, v43 - ArgAttrsAttr);
            unsigned int v45 = v87;
          }
          LODWORD(v87) = v45 + ((unint64_t)v44 >> 3);
          uint64_t v46 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v78);
          uint64_t v47 = *this;
          uint64_t v48 = *v46;
          uint64_t v49 = 3;
          uint64_t v50 = 1;
          if (*(_DWORD *)((*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8] + 8)) {
            uint64_t v51 = 3;
          }
          else {
            uint64_t v51 = 1;
          }
          if (!*(_DWORD *)((*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8] + 8)) {
            uint64_t v50 = 2;
          }
          uint64_t v52 = v46[v51];
          if (*(_DWORD *)((*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8] + 8)) {
            uint64_t v49 = 2;
          }
          uint64_t v53 = v46[v50];
          uint64_t v54 = v46[v49];
          unint64_t v82 = 0;
          int64_t v83 = v85;
          v85[0] = v48;
          v85[1] = v52;
          v85[2] = v53;
          v85[3] = v54;
          uint64_t v84 = 0x400000004;
          uint64_t v79 = v81;
          uint64_t v80 = 0x300000003;
          v81[0] = v48;
          uint64_t v56 = *(void *)v99;
          uint64_t v55 = *((void *)v99 + 1);
          v81[1] = *(void *)v99 * v52 * v55;
          uint64_t v57 = 0x8000000000000000;
          uint64_t v58 = 0x8000000000000000;
          if (v53 != 0x8000000000000000 && v56 != 0x8000000000000000) {
            uint64_t v58 = (*(void *)v112[0] + ~(*(void *)v89 * (v56 - 1)) + *((void *)v112[0] + 1) + *(void *)v94 + v53)
          }
                / *(void *)v94;
          if (v54 != 0x8000000000000000 && v55 != 0x8000000000000000) {
            uint64_t v57 = (*((void *)v112[0] + 2)
          }
                 + ~(*((void *)v89 + 1) * (v55 - 1))
                 + *((void *)v112[0] + 3)
                 + *((void *)v94 + 1)
                 + v54)
                / *((void *)v94 + 1);
          unint64_t v59 = 0x8000000000000000;
          if (v57 != 0x8000000000000000 && v58 != 0x8000000000000000) {
            unint64_t v59 = v57 * v58;
          }
          unint64_t v82 = v59;
          uint64_t v61 = (void *)(*(void *)(*(void *)(v47[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
          if (v61) {
            uint64_t v62 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v61 + 8);
          }
          else {
            uint64_t v62 = 0;
          }
          v77[0] = v61;
          v77[1] = v62;
          uint64_t v63 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v77);
          if (!v77[0]
            || (unint64_t v65 = (void *)v63,
                uint64_t v66 = v64,
                !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v77))
            || *v65 == *(void *)v79
            && v65[1] == *((void *)v79 + 1)
            && v65[2] == *((void *)v79 + 2)
            && v66 == 3
            && v80 == 3)
          {
            uint64_t v10 = 1;
          }
          else
          {
            long long v75 = (const void **)"failed: invalid output shape for input & attributes.";
            __int16 v76 = 259;
            mlir::OpState::emitOpError(this, &v75, (uint64_t)v104);
            uint64_t v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v104);
            if (v104[0]) {
              mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v104);
            }
            if (v111)
            {
              unint64_t v67 = (void **)__p;
              if (__p)
              {
                BOOL v68 = v110;
                uint64_t v69 = __p;
                if (v110 != __p)
                {
                  do
                    BOOL v68 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v68 - 1);
                  while (v68 != v67);
                  uint64_t v69 = __p;
                }
                v110 = v67;
                operator delete(v69);
              }
              BOOL v70 = v107;
              if (v107)
              {
                unint64_t v71 = v108;
                uint64_t v72 = v107;
                if (v108 != v107)
                {
                  do
                  {
                    uint64_t v74 = (void *)*--v71;
                    __int16 v73 = v74;
                    *unint64_t v71 = 0;
                    if (v74) {
                      operator delete[](v73);
                    }
                  }
                  while (v71 != v70);
                  uint64_t v72 = v107;
                }
                v108 = v70;
                operator delete(v72);
              }
              if (v105 != v106) {
                free(v105);
              }
            }
          }
          if (v79 != v81) {
            free(v79);
          }
          if (v83 != v85) {
            free(v83);
          }
          if (v86 != v88) {
            free(v86);
          }
        }
      }
      if (v89 != &v91) {
        free(v89);
      }
      if (v92[0] != v93) {
        free(v92[0]);
      }
      if (v94 != &v96) {
        free(v94);
      }
      if (v97[0] != v98) {
        free(v97[0]);
      }
      if (v99 != &v101) {
        free(v99);
      }
      uint64_t v19 = (void *)v102[0];
      if ((unsigned char *)v102[0] == v103) {
        goto LABEL_34;
      }
LABEL_33:
      free(v19);
      goto LABEL_34;
    }
  }
  else if (!v9 && !*((void *)v112[0] + 1) && !*((void *)v112[0] + 2) && !*((void *)v112[0] + 3))
  {
    goto LABEL_37;
  }
  v86 = "failed: padding should be nonzero on spatial dimension only";
  v88[8] = 259;
  mlir::OpState::emitOpError(this, (const void ***)&v86, (uint64_t)v104);
  uint64_t v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v104);
  if (v104[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v104);
  }
  if (v111)
  {
    long long v11 = (void **)__p;
    if (__p)
    {
      uint64_t v12 = v110;
      long long v13 = __p;
      if (v110 != __p)
      {
        do
          uint64_t v12 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v12 - 1);
        while (v12 != v11);
        long long v13 = __p;
      }
      v110 = v11;
      operator delete(v13);
    }
    long long v14 = v107;
    if (v107)
    {
      uint64_t v15 = v108;
      uint64_t v16 = v107;
      if (v108 != v107)
      {
        do
        {
          uint64_t v18 = (void *)*--v15;
          uint64_t v17 = v18;
          *uint64_t v15 = 0;
          if (v18) {
            operator delete[](v17);
          }
        }
        while (v15 != v14);
        uint64_t v16 = v107;
      }
      v108 = v14;
      operator delete(v16);
    }
    uint64_t v19 = v105;
    if (v105 != v106) {
      goto LABEL_33;
    }
  }
LABEL_34:
  if (v112[0] != v113) {
    free(v112[0]);
  }
  return v10;
}

uint64_t mlir::mps::ColToImOp::getKernelSizes(mlir::mps::ColToImOp *this)
{
  unint64_t v1 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v1 = 0;
  }
  return *(void *)(v1 + 24);
}

uint64_t mlir::mps::ColToImOp::getStrides(mlir::mps::ColToImOp *this)
{
  unint64_t v1 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v1 = 0;
  }
  return *(void *)(v1 + 32);
}

uint64_t mlir::mps::NonMaximumSuppressionOp::inferReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, uint64_t a3, void *a4, unint64_t a5, uint64_t a6, long long *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  v47[1] = a11;
  uint64_t v48 = a1;
  v47[0] = &v48;
  v58[0] = v59;
  memset_pattern16(v59, &unk_1811000C0, 0x18uLL);
  v58[1] = (void *)0x300000003;
  v59[2] = 2;
  if (a7)
  {
    long long v16 = *a7;
    uint64_t v17 = *((void *)a7 + 2);
  }
  else
  {
    uint64_t v17 = 0;
    long long v16 = 0uLL;
  }
  uint64_t v49 = a6;
  v50[0] = 0;
  char v51 = 0;
  long long v52 = v16;
  uint64_t v53 = v17;
  uint64_t v54 = a9;
  uint64_t v55 = a10;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v49);
    if (v51) {
      char v51 = 0;
    }
    mlir::OperationName::OperationName(v50, "mps.non_maximum_suppression", 27, Context);
    char v51 = 1;
  }
  uint64_t v56 = a4;
  unint64_t v57 = a5;
  if (a5)
  {
    uint64_t v19 = mlir::UnknownLoc::get(v48, v15);
    if (mlir::mps::NonMaximumSuppressionOpAdaptor::verify((uint64_t)&v49, v19))
    {
      unsigned int v45 = (void *)*((void *)&v52 + 1);
      if (*((void *)&v52 + 1))
      {
        mlir::IntegerAttr::getValue(&v45, (llvm::APInt *)&v60);
        if (v61 >= 0x41 && v60) {
          operator delete[](v60);
        }
        unsigned int v45 = (void *)*((void *)&v52 + 1);
        if (*((void *)&v52 + 1))
        {
          mlir::IntegerAttr::getValue(&v45, (llvm::APInt *)&v60);
          if (v61 >= 0x41) {
            uint64_t v20 = (void **)v60;
          }
          else {
            uint64_t v20 = &v60;
          }
          uint64_t v21 = *(unsigned int *)v20;
          if (v61 >= 0x41 && v60) {
            operator delete[](v60);
          }
        }
        else
        {
          uint64_t v21 = 0;
        }
        *((void *)v58[0] + 1) = v21;
      }
      v60 = v56;
      uint64_t v61 = 0;
      uint64_t v22 = (void *)(*(void *)(mlir::ValueRange::dereference_iterator(&v60, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v22 + 8))
      {
        uint64_t v23 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v22 + 8);
        unsigned int v45 = v22;
        uint64_t v46 = v23;
        if (v22)
        {
          if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v45))
          {
            mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v45);
            if (v24 == 3)
            {
              ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v45);
              uint64_t v26 = v58[0];
              *(void *)v58[0] = *ArgAttrsAttr;
              if (v26[1] == 0x8000000000000000)
              {
                uint64_t v27 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v45);
                *((void *)v58[0] + 1) = *(void *)(v27 + 8);
              }
            }
          }
        }
      }
      else
      {
        unsigned int v45 = 0;
        uint64_t v46 = 0;
      }
      uint64_t v28 = v58[0];
      if (*(void *)v58[0] == 0x8000000000000000 || *((void *)v58[0] + 1) == 0x8000000000000000)
      {
        if (a5 < 2) {
          goto LABEL_59;
        }
        v60 = v56;
        uint64_t v61 = 1;
        v60 = (void *)mlir::ValueRange::offset_base(&v60, 1);
        uint64_t v61 = 0;
        unint64_t v29 = (void *)(*(void *)(mlir::ValueRange::dereference_iterator(&v60, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
        if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v29 + 8))
        {
          uint64_t v30 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v29 + 8);
          v60 = v29;
          uint64_t v61 = v30;
          if (v29)
          {
            if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v60))
            {
              mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v60);
              if (v31 == 3)
              {
                uint64_t v32 = v58[0];
                if (*(void *)v58[0] == 0x8000000000000000)
                {
                  uint64_t v33 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v60);
                  uint64_t v32 = v58[0];
                  *(void *)v58[0] = *v33;
                }
                if (v32[1] == 0x8000000000000000)
                {
                  uint64_t v34 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v60);
                  *((void *)v58[0] + 1) = *(void *)(v34 + 8);
                }
              }
            }
          }
        }
        else
        {
          v60 = 0;
          uint64_t v61 = 0;
        }
        uint64_t v28 = v58[0];
        if (*(void *)v58[0] == 0x8000000000000000) {
          goto LABEL_64;
        }
      }
      if (v28[1] == 0x8000000000000000)
      {
LABEL_64:
        if (a5 >= 3)
        {
          int v35 = v57;
          v60 = v56;
          uint64_t v61 = 2;
          uint64_t v36 = (void *)mlir::ValueRange::offset_base(&v60, 2);
          if (v35 - 2 != v61)
          {
            v60 = v36;
            uint64_t v61 = 0;
            if (mlir::ValueRange::dereference_iterator(&v60, 0))
            {
              v60 = v56;
              uint64_t v61 = 2;
              v60 = (void *)mlir::ValueRange::offset_base(&v60, 2);
              uint64_t v61 = 0;
              uint64_t v37 = (void *)(*(void *)(mlir::ValueRange::dereference_iterator(&v60, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
              uint64_t v38 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v37 + 8);
              if (v38) {
                uint64_t v38 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v37 + 8);
              }
              else {
                uint64_t v37 = 0;
              }
              v60 = v37;
              uint64_t v61 = v38;
              if (v37)
              {
                if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v60))
                {
                  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v60);
                  if (v39 == 2)
                  {
                    uint64_t v40 = v58[0];
                    if (*(void *)v58[0] == 0x8000000000000000)
                    {
                      uint64_t v41 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v60);
                      uint64_t v40 = v58[0];
                      *(void *)v58[0] = *v41;
                    }
                    if (v40[1] == 0x8000000000000000)
                    {
                      uint64_t v42 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v60);
                      *((void *)v58[0] + 1) = *(void *)(v42 + 8);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_59:
  uint64_t v43 = mlir::mps::NonMaximumSuppressionOp::inferReturnTypes(mlir::MLIRContext *,std::optional<mlir::Location>,mlir::ValueRange,mlir::DictionaryAttr,mlir::OpaqueProperties,mlir::RegionRange,llvm::SmallVectorImpl<mlir::Type> &)::$_0::operator()((uint64_t)v47, (uint64_t)v58);
  if (v58[0] != v59) {
    free(v58[0]);
  }
  return v43;
}

uint64_t mlir::mps::NonMaximumSuppressionOpAdaptor::verify(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(a1 + 32)) {
    return 1;
  }
  v13[0] = *(void *)(a1 + 32);
  v15[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v13);
  if (mlir::Type::isUnsignedInteger((mlir::Type *)v15, 32)) {
    return 1;
  }
  v13[0] = "'mps.non_maximum_suppression' op attribute 'max_boxes' failed to satisfy constraint: 32-bit unsigned integer attribute";
  __int16 v14 = 259;
  mlir::emitError(a2, (uint64_t)v13, (uint64_t)v15);
  uint64_t v3 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v15);
  if (v15[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v15);
  }
  if (v22)
  {
    unint64_t v5 = (void **)__p;
    if (__p)
    {
      uint64_t v6 = v21;
      uint64_t v7 = __p;
      if (v21 != __p)
      {
        do
          uint64_t v6 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v6 - 1);
        while (v6 != v5);
        uint64_t v7 = __p;
      }
      uint64_t v21 = v5;
      operator delete(v7);
    }
    uint64_t v8 = v18;
    if (v18)
    {
      uint64_t v9 = v19;
      uint64_t v10 = v18;
      if (v19 != v18)
      {
        do
        {
          uint64_t v12 = (void *)*--v9;
          long long v11 = v12;
          void *v9 = 0;
          if (v12) {
            operator delete[](v11);
          }
        }
        while (v9 != v8);
        uint64_t v10 = v18;
      }
      uint64_t v19 = v8;
      operator delete(v10);
    }
    if (v16 != &v17) {
      free(v16);
    }
  }
  return v3;
}

uint64_t mlir::mps::NonMaximumSuppressionOp::inferReturnTypes(mlir::MLIRContext *,std::optional<mlir::Location>,mlir::ValueRange,mlir::DictionaryAttr,mlir::OpaqueProperties,mlir::RegionRange,llvm::SmallVectorImpl<mlir::Type> &)::$_0::operator()(uint64_t a1, uint64_t a2)
{
  v14[1] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = mlir::IntegerType::get(**(void **)a1, 0x20u, 1u);
  uint64_t v5 = mlir::IntegerType::get(**(void **)a1, 0x20u, 2u);
  uint64_t v6 = *(void **)a2;
  v14[0] = **(void **)a2;
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = mlir::RankedTensorType::get((uint64_t)v6, *(unsigned int *)(a2 + 8), v4, 0);
  uint64_t v9 = *(unsigned int *)(v7 + 8);
  if (v9 >= *(_DWORD *)(v7 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v7, (void *)(v7 + 16), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(v7 + 8);
  }
  *(void *)(*(void *)v7 + 8 * v9) = v8;
  ++*(_DWORD *)(v7 + 8);
  uint64_t v10 = *(void *)(a1 + 8);
  uint64_t v11 = mlir::RankedTensorType::get((uint64_t)v14, 1, v5, 0);
  uint64_t v12 = *(unsigned int *)(v10 + 8);
  if (v12 >= *(_DWORD *)(v10 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v10, (void *)(v10 + 16), v12 + 1, 8);
    LODWORD(v12) = *(_DWORD *)(v10 + 8);
  }
  *(void *)(*(void *)v10 + 8 * v12) = v11;
  ++*(_DWORD *)(v10 + 8);
  return 1;
}

uint64_t mlir::mps::NonMaximumSuppressionOp::verify(uint64_t **this)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (*this)[9];
  uint64_t v3 = (void *)(*(void *)(*(void *)(v2 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v3)
  {
    uint64_t v4 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v3 + 8);
    uint64_t v5 = (*this)[9];
    uint64_t v56 = v3;
    uint64_t v57 = v4;
    uint64_t v6 = (void *)(*(void *)(*(void *)(v5 + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (v6) {
      goto LABEL_3;
    }
LABEL_20:
    uint64_t v54 = v6;
    uint64_t v55 = 0;
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v56)) {
      goto LABEL_4;
    }
LABEL_21:
    uint64_t v15 = 0;
    BOOL v14 = 0;
    uint64_t v13 = 0;
    BOOL v12 = 0;
    if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v54)) {
      goto LABEL_14;
    }
LABEL_22:
    ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v54);
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v54);
    if (v23 != 3
      || v12 && *ArgAttrsAttr != 0x8000000000000000 && *ArgAttrsAttr != v13
      || (uint64_t v24 = ArgAttrsAttr[1], v14) && v24 != 0x8000000000000000 && v24 != v15)
    {
      v52[0] = (const void **)"scores tensor must have shape [N, B, K]";
      __int16 v53 = 259;
      mlir::OpState::emitOpError(this, v52, (uint64_t)v58);
      uint64_t v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v58);
      if (v58[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v58);
      }
      if (!v65) {
        return v25;
      }
      uint64_t v26 = (void **)__p;
      if (__p)
      {
        uint64_t v27 = v64;
        uint64_t v28 = __p;
        if (v64 != __p)
        {
          do
            uint64_t v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
          while (v27 != v26);
          uint64_t v28 = __p;
        }
        uint64_t v64 = v26;
        operator delete(v28);
      }
      unint64_t v29 = v61;
      if (v61)
      {
        uint64_t v30 = v62;
        uint64_t v31 = v61;
        if (v62 == v61) {
          goto LABEL_93;
        }
        do
        {
          uint64_t v33 = (void *)*--v30;
          uint64_t v32 = v33;
          *uint64_t v30 = 0;
          if (v33) {
            operator delete[](v32);
          }
        }
        while (v30 != v29);
LABEL_92:
        uint64_t v31 = v61;
LABEL_93:
        uint64_t v62 = v29;
        operator delete(v31);
      }
LABEL_94:
      if (v59 != &v60) {
        free(v59);
      }
      return v25;
    }
    if (*ArgAttrsAttr != 0x8000000000000000)
    {
      uint64_t v13 = *ArgAttrsAttr;
      BOOL v12 = 1;
    }
    if (v24 != 0x8000000000000000)
    {
      uint64_t v15 = ArgAttrsAttr[1];
      BOOL v14 = 1;
    }
    uint64_t v40 = ArgAttrsAttr[2];
    BOOL v17 = v40 != 0x8000000000000000;
    if (v40 == 0x8000000000000000) {
      uint64_t v16 = 0;
    }
    else {
      uint64_t v16 = ArgAttrsAttr[2];
    }
    uint64_t v18 = *this;
    if (*((_DWORD *)*this + 17) == 4) {
      return 1;
    }
    goto LABEL_15;
  }
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  uint64_t v6 = (void *)(*(void *)(*(void *)(v2 + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_20;
  }
LABEL_3:
  uint64_t v7 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v6 + 8);
  uint64_t v54 = v6;
  uint64_t v55 = v7;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v56)) {
    goto LABEL_21;
  }
LABEL_4:
  uint64_t v8 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v56);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v56);
  if (v9 != 3 || (uint64_t v10 = v8[2], v10 != 0x8000000000000000) && v10 != 4)
  {
    v52[0] = (const void **)"boxes tensor must have shape [N, B, 4]";
    __int16 v53 = 259;
    mlir::OpState::emitOpError(this, v52, (uint64_t)v58);
    uint64_t v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v58);
    if (v58[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v58);
    }
    if (!v65) {
      return v25;
    }
    uint64_t v34 = (void **)__p;
    if (__p)
    {
      int v35 = v64;
      uint64_t v36 = __p;
      if (v64 != __p)
      {
        do
          int v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        uint64_t v36 = __p;
      }
      uint64_t v64 = v34;
      operator delete(v36);
    }
    unint64_t v29 = v61;
    if (v61)
    {
      uint64_t v37 = v62;
      uint64_t v31 = v61;
      if (v62 == v61) {
        goto LABEL_93;
      }
      do
      {
        uint64_t v39 = (void *)*--v37;
        uint64_t v38 = v39;
        *uint64_t v37 = 0;
        if (v39) {
          operator delete[](v38);
        }
      }
      while (v37 != v29);
      goto LABEL_92;
    }
    goto LABEL_94;
  }
  uint64_t v11 = v8[1];
  BOOL v12 = *v8 != 0x8000000000000000;
  if (*v8 == 0x8000000000000000) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = *v8;
  }
  BOOL v14 = v11 != 0x8000000000000000;
  if (v11 == 0x8000000000000000) {
    uint64_t v15 = 0;
  }
  else {
    uint64_t v15 = v8[1];
  }
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v54)) {
    goto LABEL_22;
  }
LABEL_14:
  uint64_t v16 = 0;
  BOOL v17 = 0;
  uint64_t v18 = *this;
  if (*((_DWORD *)*this + 17) == 4) {
    return 1;
  }
LABEL_15:
  uint64_t v19 = *(void *)(v18[9] + 88);
  if (!v19) {
    return 1;
  }
  uint64_t v20 = (void *)(*(void *)(v19 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v20)
  {
    uint64_t v50 = 0;
    uint64_t v51 = 0;
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v50)) {
      goto LABEL_67;
    }
    return 1;
  }
  uint64_t v21 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v20 + 8);
  uint64_t v50 = v20;
  uint64_t v51 = v21;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v50)) {
    return 1;
  }
LABEL_67:
  uint64_t v41 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v50);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v50);
  if (v42 != 2
    || v12 && *v41 != 0x8000000000000000 && *v41 != v13
    || v14 && *v41 != 0x8000000000000000 && v41[1] != v15)
  {
    v52[0] = (const void **)"class_indices tensor must have shape [N, B]";
    __int16 v53 = 259;
    mlir::OpState::emitOpError(this, v52, (uint64_t)v58);
    uint64_t v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v58);
    if (v58[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v58);
    }
    if (!v65) {
      return v25;
    }
    uint64_t v43 = (void **)__p;
    if (__p)
    {
      uint64_t v44 = v64;
      unsigned int v45 = __p;
      if (v64 != __p)
      {
        do
          uint64_t v44 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v44 - 1);
        while (v44 != v43);
        unsigned int v45 = __p;
      }
      uint64_t v64 = v43;
      operator delete(v45);
    }
    unint64_t v29 = v61;
    if (v61)
    {
      uint64_t v46 = v62;
      uint64_t v31 = v61;
      if (v62 == v61) {
        goto LABEL_93;
      }
      do
      {
        uint64_t v48 = (void *)*--v46;
        uint64_t v47 = v48;
        *uint64_t v46 = 0;
        if (v48) {
          operator delete[](v47);
        }
      }
      while (v46 != v29);
      goto LABEL_92;
    }
    goto LABEL_94;
  }
  if (v16 == 1 || !v17) {
    return 1;
  }
  v52[0] = (const void **)"when class_indices tensor is provided, scores tensor must have shape [N, B, 1]";
  __int16 v53 = 259;
  mlir::OpState::emitOpError(this, v52, (uint64_t)v58);
  uint64_t v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v58);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v58);
  return v25;
}

uint64_t mlir::mps::NonMaximumSuppressionOp::getClassIndices(mlir::mps::NonMaximumSuppressionOp *this)
{
  if (*(_DWORD *)(*(void *)this + 68) == 4) {
    return 0;
  }
  else {
    return *(void *)(*(void *)(*(void *)this + 72) + 88);
  }
}

uint64_t mlir::mps::ACosOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ACoshOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ASinOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ASinhOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ATan2Op::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ATanOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ATanhOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::AbsoluteOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::AbsoluteSquareOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::AddOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::AndOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::AssignVariableOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::BandPartOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::BatchToSpaceOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::BiasAddGradOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::BiasAddOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::BitwiseAndOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::BitwiseLeftShiftOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::BitwiseNotOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::BitwiseOrOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::BitwisePopcountOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::BitwiseRightShiftOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::BitwiseXorOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::BroadcastGradientArgsOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::BroadcastToOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::CallOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::CastOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::CeilOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ClampOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ColToImOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ConcatOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ConjugateOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ConstantOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::Conv2DDataGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::Conv2DOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::Conv2DWeightsGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::Conv3DDataGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::Conv3DOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::Conv3DWeightsGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::CosOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::CoshOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::CostVolumeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::CreateComplexOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::CreateTextureTensorOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::CropOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::CropResizeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::CumulativeMaximumOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::CumulativeMinimumOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::CumulativeProductOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::CumulativeSumOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::DegammaOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::DepthToSpace2DOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::DepthwiseConv2DDataGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::DepthwiseConv2DOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::DepthwiseConv2DWeightsGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::DepthwiseConv3DDataGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::DepthwiseConv3DOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::DepthwiseConv3DWeightsGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::DequantizeLUTOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::DequantizeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::DimensionSizeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::DiracOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::DivideOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::DynamicShapeCastOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::EluOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::EqualToOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ErfOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ExpandDimsOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ExponentBase10Op::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ExponentBase2Op::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ExponentOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::FastFourierTransformOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::Flatten2DOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::FloorDivideOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::FloorOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::GRUGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::GRUOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::GatherAlongAxisOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::GatherNDOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::GatherOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::GeluOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::GetCoordOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::GreaterThanOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::GreaterThanOrEqualToOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::HammingDistanceOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::HermiteanToRealFFTOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::IdentityOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ImToColOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ImaginaryPartOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::InitRandomPhiloxStateOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::InstanceNormOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::IsFiniteOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::IsInfiniteOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::IsNaNOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::LPNormOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::LSTMGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::LSTMOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::LeakyReluOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::LessThanOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::LessThanOrEqualToOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::LocalConvolutionDataGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::LocalConvolutionOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::LocalConvolutionWeightGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::LogarithmBase10Op::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::LogarithmBase2Op::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::LogarithmOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::MatMulOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::MaterializeSparseTensorOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::MatrixDecompositionLUOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::MatrixInverseOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::MatrixSolverLUOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::MaximumOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::MinimumOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ModuloOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::MultiplyOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::NReluOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::NandOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::NegativeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::NonMaximumSuppressionOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::NonZeroOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::NorOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::NormalizationOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::NotEqualToOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::NotOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::OneHotOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::OrOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::PReluOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::PadGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::PadOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::PermuteOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::PlaceholderOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::PoolAvgGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::PoolAvgOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::PoolL2NormGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::PoolL2NormOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::PoolMaxGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::PoolMaxOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::PowerOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::PruningGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::PruningOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::QuantizeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::RandomNormalOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::RandomTruncatedNormalOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::RandomUniformOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::RankOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ReadDataFromFileOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ReadVariableOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::RealPartOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::RealToHermiteanFFTOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ReciprocalOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ReciprocalSquareRootOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ReductionAndOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ReductionArgMaxOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ReductionArgMinOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ReductionLogSumExpOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ReductionMaxOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ReductionMeanOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ReductionMinOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ReductionOrOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ReductionProdOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ReductionSumOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ReductionVarianceOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ReinterpretCastOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::Relu6Op::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ReluGradOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ReluOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ReshapeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ResizeGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ResizeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ReverseOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::RintOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::RoundOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SampleGridDataGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SampleGridOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ScatterAlongAxisOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ScatterNDOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ScatterOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SelectOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::ShapeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SigmoidGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SigmoidGradientWithSigmoidOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SigmoidHardOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SigmoidOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SignOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SignbitOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SinOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SingleGateRNNGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SingleGateRNNOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SinhOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SizeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SliceOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SoftmaxOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SoftplusOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SoftplusParametricOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SoftsignOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SortOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SpaceToBatchOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SpaceToDepth2DOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SplitOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SquareOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SquareRootOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SqueezeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::StencilOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::StridedSliceGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::StridedSliceOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::StridedSliceUpdateOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SubtractOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::SwishOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::TanOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::TanhOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::TileGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::TileOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::TopKGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::TopKOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::TransposeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::TruncateOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::TypeConstraintOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::UnrealizedFoldOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::UpdateRandomStateOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::VariableFromTensorOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::XnorOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::XorOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalCanonicalizeInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalCanonicalizeInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result) {
    return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v5, a2);
  }
  return result;
}

uint64_t mlir::mps::symbolizeMetalPixelFormat(uint64_t *a1, uint64_t a2)
{
  switch(a2)
  {
    case 7:
      if (*(_DWORD *)a1 != 1851078738 || *(_DWORD *)((char *)a1 + 3) != 1836216174) {
        goto LABEL_40;
      }
      uint64_t result = 0x100000000;
      break;
    case 8:
      switch(*a1)
      {
        case 0x6D726F6E55384752:
          uint64_t result = 0x100000001;
          break;
        case 0x74616F6C46363152:
          uint64_t result = 0x100000004;
          break;
        case 0x74616F6C46323352:
          uint64_t result = 0x100000007;
          break;
        default:
          goto LABEL_40;
      }
      break;
    case 9:
      if (*a1 == 0x616F6C4636314752 && *((unsigned char *)a1 + 8) == 116)
      {
        uint64_t result = 0x100000005;
      }
      else
      {
        if (*a1 != 0x616F6C4632334752 || *((unsigned char *)a1 + 8) != 116) {
          goto LABEL_40;
        }
        uint64_t result = 0x100000008;
      }
      break;
    case 10:
      uint64_t result = 0x100000002;
      if (*a1 != 0x6F6E553841424752 || *((_WORD *)a1 + 4) != 28018)
      {
        uint64_t v8 = *a1;
        int v9 = *((unsigned __int16 *)a1 + 4);
        if (v8 != 0x6F6E553841524742 || v9 != 28018) {
          goto LABEL_40;
        }
        uint64_t result = 0x100000003;
      }
      break;
    case 11:
      if (*a1 == 0x6C46363141424752 && *(uint64_t *)((char *)a1 + 3) == 0x74616F6C46363141)
      {
        uint64_t result = 0x100000006;
      }
      else
      {
        if (*a1 != 0x6C46323341424752 || *(uint64_t *)((char *)a1 + 3) != 0x74616F6C46323341) {
          goto LABEL_40;
        }
        uint64_t result = 0x100000009;
      }
      break;
    default:
LABEL_40:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t mlir::mps::symbolizeNearestRoundingMode(uint64_t a1, uint64_t a2)
{
  switch(a2)
  {
    case 4:
      if (*(_DWORD *)a1 != 1818846563) {
        goto LABEL_38;
      }
      uint64_t result = 0x100000002;
      break;
    case 5:
      if (*(_DWORD *)a1 != 1869573222 || *(unsigned char *)(a1 + 4) != 114) {
        goto LABEL_38;
      }
      uint64_t result = 0x100000003;
      break;
    case 12:
      if (*(void *)a1 != 0x6F745F646E756F72 || *(_DWORD *)(a1 + 8) != 1684303711) {
        goto LABEL_38;
      }
      uint64_t result = 0x100000005;
      break;
    case 13:
      if (*(void *)a1 != 0x6F745F646E756F72 || *(void *)(a1 + 5) != 0x6E6576655F6F745FLL) {
        goto LABEL_38;
      }
      uint64_t result = 0x100000004;
      break;
    case 17:
      if (*(void *)a1 != 0x72705F646E756F72
        || *(void *)(a1 + 8) != 0x6965635F72656665
        || *(unsigned char *)(a1 + 16) != 108)
      {
        goto LABEL_38;
      }
      uint64_t result = 0x100000000;
      break;
    case 18:
      if (*(void *)a1 != 0x72705F646E756F72
        || *(void *)(a1 + 8) != 0x6F6C665F72656665
        || *(_WORD *)(a1 + 16) != 29295)
      {
        goto LABEL_38;
      }
      uint64_t result = 0x100000001;
      break;
    default:
LABEL_38:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t mlir::mps::symbolizePaddingStyle(uint64_t a1, uint64_t a2)
{
  if (a2 == 7)
  {
    if (*(_DWORD *)a1 == 1398752852 && *(_DWORD *)(a1 + 3) == 1162690899) {
      return 0x100000002;
    }
    return 0;
  }
  if (a2 == 15)
  {
    if (*(void *)a1 == 0x544943494C505845 && *(void *)(a1 + 7) == 0x54455346464F5F54) {
      return 0x100000003;
    }
    if (*(void *)a1 == 0x4D41535F584E4E4FLL && *(void *)(a1 + 7) == 0x5245574F4C5F454DLL) {
      return 0x100000004;
    }
    return 0;
  }
  if (a2 != 8) {
    return 0;
  }
  if (*(void *)a1 != 0x544943494C505845)
  {
    if (*(void *)a1 == 0x44494C41565F4654) {
      return 0x100000001;
    }
    return 0;
  }
  return 0x100000000;
}

uint64_t mlir::mps::symbolizePoolIndicesMode(void *a1, uint64_t a2)
{
  if (a2 == 15)
  {
    if (*a1 == 0x6C465F6C61636F4CLL && *(void *)((char *)a1 + 7) == 0x44316E657474616CLL) {
      return 0x100000004;
    }
    if (*a1 == 0x6C465F6C61636F4CLL && *(void *)((char *)a1 + 7) == 0x44326E657474616CLL) {
      return 0x100000005;
    }
    if (*a1 == 0x6C465F6C61636F4CLL && *(void *)((char *)a1 + 7) == 0x44336E657474616CLL) {
      return 0x100000006;
    }
    uint64_t v4 = 0x100000007;
    if (*a1 ^ 0x6C465F6C61636F4CLL | *(void *)((char *)a1 + 7) ^ 0x44346E657474616CLL) {
      return 0;
    }
    return v4;
  }
  if (a2 != 16) {
    return 0;
  }
  if (*a1 == 0x465F6C61626F6C47 && a1[1] == 0x44316E657474616CLL) {
    return 0x100000000;
  }
  if (*a1 == 0x465F6C61626F6C47 && a1[1] == 0x44326E657474616CLL) {
    return 0x100000001;
  }
  uint64_t v4 = 0x100000002;
  if (*a1 == 0x465F6C61626F6C47 && a1[1] == 0x44336E657474616CLL) {
    return v4;
  }
  if (*a1 != 0x465F6C61626F6C47 || a1[1] != 0x44346E657474616CLL) {
    return 0;
  }
  return 0x100000003;
}

uint64_t mlir::mps::symbolizeRNNActivation(int *a1, uint64_t a2)
{
  uint64_t result = 0;
  switch(a2)
  {
    case 4:
      switch(*a1)
      {
        case 1701736302:
          uint64_t result = 0x100000000;
          break;
        case 1970038130:
          uint64_t result = 0x100000001;
          break;
        case 1752064372:
          uint64_t result = 0x100000002;
          break;
        default:
          goto LABEL_19;
      }
      break;
    case 7:
      int v4 = *a1;
      int v5 = *(int *)((char *)a1 + 3);
      if (v4 != 1835493747 || v5 != 1684631405) {
        goto LABEL_19;
      }
      uint64_t result = 0x100000003;
      break;
    case 11:
      if (*(void *)a1 ^ 0x745F64656C616373 | *(void *)((char *)a1 + 3) ^ 0x686E61745F64656CLL) {
        uint64_t result = 0;
      }
      else {
        uint64_t result = 0x100000005;
      }
      break;
    case 12:
      uint64_t v7 = *(void *)a1;
      int v8 = a1[2];
      if (v7 == 0x6769735F64726168 && v8 == 1684631405) {
        uint64_t result = 0x100000004;
      }
      else {
LABEL_19:
      }
        uint64_t result = 0;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t mlir::mps::symbolizeReductionMode(uint64_t a1, uint64_t a2)
{
  if (a2 == 7)
  {
    if (*(_DWORD *)a1 == 1685025392 && *(_DWORD *)(a1 + 3) == 1952675172) {
      return 0x100000003;
    }
    if (*(_DWORD *)a1 == 1298625121 && *(_DWORD *)(a1 + 3) == 544106829) {
      return 0x100000004;
    }
    return 0;
  }
  if (a2 == 6)
  {
    if (*(_DWORD *)a1 ^ 0x4D677261 | *(unsigned __int16 *)(a1 + 4) ^ 0x7861) {
      return 0;
    }
    else {
      return 0x100000005;
    }
  }
  if (a2 != 3) {
    return 0;
  }
  if (*(_WORD *)a1 == 26989 && *(unsigned char *)(a1 + 2) == 110) {
    return 0x100000000;
  }
  if (*(_WORD *)a1 != 24941 || *(unsigned char *)(a1 + 2) != 120)
  {
    if (*(_WORD *)a1 == 30067 && *(unsigned char *)(a1 + 2) == 109) {
      return 0x100000002;
    }
    return 0;
  }
  return 0x100000001;
}

uint64_t mlir::mps::symbolizeScatterMode(uint64_t a1, uint64_t a2)
{
  if (a2 == 8)
  {
    if (*(void *)a1 != 0x7463617274627573)
    {
      if (*(void *)a1 == 0x796C7069746C756DLL) {
        return 0x100000002;
      }
      return 0;
    }
    return 0x100000001;
  }
  if (a2 == 6)
  {
    if (*(_DWORD *)a1 == 1769367908 && *(_WORD *)(a1 + 4) == 25956) {
      return 0x100000003;
    }
    return 0;
  }
  if (a2 != 3) {
    return 0;
  }
  if (*(_WORD *)a1 == 25697 && *(unsigned char *)(a1 + 2) == 100) {
    return 0x100000000;
  }
  if (*(_WORD *)a1 == 26989 && *(unsigned char *)(a1 + 2) == 110) {
    return 0x100000004;
  }
  if (*(_WORD *)a1 != 24941 || *(unsigned char *)(a1 + 2) != 120)
  {
    if (*(_WORD *)a1 == 25971 && *(unsigned char *)(a1 + 2) == 116) {
      return 0x100000006;
    }
    return 0;
  }
  return 0x100000005;
}

uint64_t mlir::mps::symbolizeStencilPaddingMode(int *a1, uint64_t a2)
{
  uint64_t result = 0;
  switch(a2)
  {
    case 4:
      uint64_t v4 = 0x100000004;
      BOOL v5 = *a1 == 1869768058;
      goto LABEL_18;
    case 6:
      int v6 = *a1;
      int v7 = *((unsigned __int16 *)a1 + 2);
      if (v6 != 1920100717 || v7 != 29295) {
        return 0;
      }
      return 0x100000001;
    case 8:
      if (*(void *)a1 == 0x746E6174736E6F63)
      {
        uint64_t result = 0x100000000;
      }
      else if (*(void *)a1 == 0x6369646F69726570)
      {
        uint64_t result = 0x100000005;
      }
      else
      {
LABEL_25:
        uint64_t result = 0;
      }
      break;
    case 11:
      uint64_t v9 = *(void *)a1;
      uint64_t v10 = *(void *)((char *)a1 + 3);
      if (v9 == 0x456F54706D616C63 && v10 == 0x656764456F54706DLL) {
        return 0x100000003;
      }
      else {
        return 0;
      }
    case 12:
      uint64_t v4 = 0x100000006;
      BOOL v5 = (*(void *)a1 ^ 0x6972655069746E61 | a1[2] ^ 0x6369646FLL) == 0;
LABEL_18:
      if (v5) {
        return v4;
      }
      else {
        return 0;
      }
    case 14:
      uint64_t v12 = *(void *)a1;
      uint64_t v13 = *(void *)((char *)a1 + 6);
      if (v12 != 0x6957726F7272696DLL || v13 != 0x6567644568746957) {
        goto LABEL_25;
      }
      uint64_t result = 0x100000002;
      break;
    default:
      return result;
  }
  return result;
}

const char *mlir::mps::stringifyTensorDataLayout(unsigned int a1)
{
  if (a1 > 0xA) {
    return "";
  }
  else {
    return off_1E4FC01E0[a1];
  }
}

uint64_t mlir::mps::symbolizeTensorDataLayout(uint64_t a1, uint64_t a2)
{
  switch(a2)
  {
    case 2:
      if (*(_WORD *)a1 != 22344) {
        goto LABEL_18;
      }
      uint64_t result = 0x100000006;
      break;
    case 3:
      if (*(_WORD *)a1 == 18499 && *(unsigned char *)(a1 + 2) == 87)
      {
        uint64_t result = 0x100000004;
      }
      else
      {
        if (*(_WORD *)a1 != 22344 || *(unsigned char *)(a1 + 2) != 67) {
          goto LABEL_18;
        }
        uint64_t result = 0x100000005;
      }
      break;
    case 4:
      if (*(_DWORD *)a1 == 1464353614)
      {
        uint64_t result = 0x100000000;
      }
      else if (*(_DWORD *)a1 == 1129793614)
      {
        uint64_t result = 0x100000001;
      }
      else
      {
        uint64_t v5 = 0x100000002;
        if (*(_DWORD *)a1 == 1464355151) {
          goto LABEL_33;
        }
        if (*(_DWORD *)a1 != 1330206536) {
          goto LABEL_18;
        }
        uint64_t result = 0x100000003;
      }
      break;
    case 5:
      if (*(_DWORD *)a1 == 1212433230 && *(unsigned char *)(a1 + 4) == 87)
      {
        uint64_t result = 0x100000007;
      }
      else if (*(_DWORD *)a1 == 1464353870 && *(unsigned char *)(a1 + 4) == 67)
      {
        uint64_t result = 0x100000008;
      }
      else if (*(_DWORD *)a1 == 1212434767 && *(unsigned char *)(a1 + 4) == 87)
      {
        uint64_t result = 0x100000009;
      }
      else
      {
        uint64_t v5 = 0x10000000ALL;
        if (*(_DWORD *)a1 ^ 0x49574844 | *(unsigned __int8 *)(a1 + 4) ^ 0x4F) {
          uint64_t v5 = 0;
        }
LABEL_33:
        uint64_t result = v5;
      }
      break;
    default:
LABEL_18:
      uint64_t result = 0;
      break;
  }
  return result;
}

mlir::mps::MPSDialect *mlir::mps::MPSDialect::MPSDialect(mlir::mps::MPSDialect *this, mlir::MLIRContext *a2)
{
  uint64_t v3 = (mlir::mps::MPSDialect *)mlir::Dialect::Dialect((uint64_t)this, (uint64_t)"mps", 3, (uint64_t)a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::MPSDialect,void>::id);
  *(void *)uint64_t v3 = &unk_1EC9C6FC8;
  mlir::mps::MPSDialect::initialize(v3);
  return this;
}

void mlir::mps::MPSDialect::~MPSDialect(llvm **this)
{
}

void sub_1809F60C0(void *__p)
{
  operator delete(__p);
}

uint64_t mlir::mps::TensorDataLayoutAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v5);
}

uint64_t mlir::mps::TensorDataLayoutAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v240 = *MEMORY[0x1E4F143B8];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1)) {
    return 0;
  }
  uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  uint64_t v217 = 0;
  uint64_t v218 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v217))
  {
LABEL_73:
    uint64_t v135 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    LOWORD(v232) = 259;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v222, a1, v135, v230);
    if (v222[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v222);
    }
    if (v229)
    {
      v136 = (void **)__p;
      if (__p)
      {
        v137 = v228;
        v138 = __p;
        if (v228 != __p)
        {
          do
            v137 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v137 - 1);
          while (v137 != v136);
          v138 = __p;
        }
        v228 = v136;
        operator delete(v138);
      }
      v139 = v225;
      if (v225)
      {
        v140 = v226;
        v141 = v225;
        if (v226 != v225)
        {
          do
          {
            v143 = (void *)*--v140;
            v142 = v143;
            void *v140 = 0;
            if (v143) {
              operator delete[](v142);
            }
          }
          while (v140 != v139);
          v141 = v225;
        }
        v226 = v139;
        operator delete(v141);
      }
      if (v223 != &v224) {
        free(v223);
      }
    }
    return 0;
  }
  uint64_t v3 = mlir::mps::symbolizeTensorDataLayout(v217, v218);
  if ((v3 & 0xFF00000000) == 0)
  {
    __int16 v216 = 257;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v230, a1, v2, v215);
    if (v230[0])
    {
      int v219 = 3;
      v220 = "expected ";
      uint64_t v221 = 9;
      int v8 = &v219;
      uint64_t v9 = v231;
      if (v232 >= v233)
      {
        unint64_t v144 = v232 + 1;
        if (v231 <= &v219 && &v231[6 * v232] > &v219)
        {
          int64_t v177 = (char *)&v219 - (char *)v231;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v144, 24);
          uint64_t v9 = v231;
          int v8 = (int *)((char *)v231 + v177);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v144, 24);
          int v8 = &v219;
          uint64_t v9 = v231;
        }
      }
      uint64_t v10 = &v9[6 * v232];
      long long v11 = *(_OWORD *)v8;
      *((void *)v10 + 2) = *((void *)v8 + 2);
      *(_OWORD *)uint64_t v10 = v11;
      uint64_t v12 = ++v232;
      if (v230[0])
      {
        int v219 = 3;
        v220 = "::mlir::mps::TensorDataLayout";
        uint64_t v221 = 29;
        uint64_t v13 = &v219;
        BOOL v14 = v231;
        if (v12 >= v233)
        {
          unint64_t v145 = v12 + 1;
          BOOL v146 = &v231[6 * v12] > &v219;
          if (v231 <= &v219 && v146)
          {
            int64_t v180 = (char *)&v219 - (char *)v231;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v145, 24);
            BOOL v14 = v231;
            uint64_t v13 = (int *)((char *)v231 + v180);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v145, 24);
            uint64_t v13 = &v219;
            BOOL v14 = v231;
          }
        }
        uint64_t v15 = &v14[6 * v232];
        long long v16 = *(_OWORD *)v13;
        *((void *)v15 + 2) = *((void *)v13 + 2);
        *(_OWORD *)uint64_t v15 = v16;
        uint64_t v17 = ++v232;
        if (v230[0])
        {
          int v219 = 3;
          v220 = " to be one of: ";
          uint64_t v221 = 15;
          uint64_t v18 = &v219;
          uint64_t v19 = v231;
          if (v17 >= v233)
          {
            unint64_t v147 = v17 + 1;
            BOOL v148 = &v231[6 * v17] > &v219;
            if (v231 <= &v219 && v148)
            {
              int64_t v183 = (char *)&v219 - (char *)v231;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v147, 24);
              uint64_t v19 = v231;
              uint64_t v18 = (int *)((char *)v231 + v183);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v147, 24);
              uint64_t v18 = &v219;
              uint64_t v19 = v231;
            }
          }
          uint64_t v20 = &v19[6 * v232];
          long long v21 = *(_OWORD *)v18;
          *((void *)v20 + 2) = *((void *)v18 + 2);
          *(_OWORD *)uint64_t v20 = v21;
          uint64_t v22 = ++v232;
          if (v230[0])
          {
            int v219 = 3;
            v220 = "NCHW";
            uint64_t v221 = 4;
            uint64_t v23 = &v219;
            uint64_t v24 = v231;
            if (v22 >= v233)
            {
              unint64_t v149 = v22 + 1;
              BOOL v150 = &v231[6 * v22] > &v219;
              if (v231 <= &v219 && v150)
              {
                int64_t v186 = (char *)&v219 - (char *)v231;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v149, 24);
                uint64_t v24 = v231;
                uint64_t v23 = (int *)((char *)v231 + v186);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v149, 24);
                uint64_t v23 = &v219;
                uint64_t v24 = v231;
              }
            }
            uint64_t v25 = &v24[6 * v232];
            long long v26 = *(_OWORD *)v23;
            *((void *)v25 + 2) = *((void *)v23 + 2);
            *(_OWORD *)uint64_t v25 = v26;
            uint64_t v27 = ++v232;
            if (v230[0])
            {
              int v219 = 3;
              v220 = ", ";
              uint64_t v221 = 2;
              uint64_t v28 = &v219;
              unint64_t v29 = v231;
              if (v27 >= v233)
              {
                unint64_t v151 = v27 + 1;
                BOOL v152 = &v231[6 * v27] > &v219;
                if (v231 <= &v219 && v152)
                {
                  int64_t v189 = (char *)&v219 - (char *)v231;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v151, 24);
                  unint64_t v29 = v231;
                  uint64_t v28 = (int *)((char *)v231 + v189);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v151, 24);
                  uint64_t v28 = &v219;
                  unint64_t v29 = v231;
                }
              }
              uint64_t v30 = &v29[6 * v232];
              long long v31 = *(_OWORD *)v28;
              *((void *)v30 + 2) = *((void *)v28 + 2);
              *(_OWORD *)uint64_t v30 = v31;
              uint64_t v32 = ++v232;
              if (v230[0])
              {
                int v219 = 3;
                v220 = "NHWC";
                uint64_t v221 = 4;
                uint64_t v33 = &v219;
                uint64_t v34 = v231;
                if (v32 >= v233)
                {
                  unint64_t v153 = v32 + 1;
                  BOOL v154 = &v231[6 * v32] > &v219;
                  if (v231 <= &v219 && v154)
                  {
                    int64_t v192 = (char *)&v219 - (char *)v231;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v153, 24);
                    uint64_t v34 = v231;
                    uint64_t v33 = (int *)((char *)v231 + v192);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v153, 24);
                    uint64_t v33 = &v219;
                    uint64_t v34 = v231;
                  }
                }
                int v35 = &v34[6 * v232];
                long long v36 = *(_OWORD *)v33;
                *((void *)v35 + 2) = *((void *)v33 + 2);
                *(_OWORD *)int v35 = v36;
                uint64_t v37 = ++v232;
                if (v230[0])
                {
                  int v219 = 3;
                  v220 = ", ";
                  uint64_t v221 = 2;
                  uint64_t v38 = &v219;
                  uint64_t v39 = v231;
                  if (v37 >= v233)
                  {
                    unint64_t v155 = v37 + 1;
                    BOOL v156 = &v231[6 * v37] > &v219;
                    if (v231 <= &v219 && v156)
                    {
                      int64_t v195 = (char *)&v219 - (char *)v231;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v155, 24);
                      uint64_t v39 = v231;
                      uint64_t v38 = (int *)((char *)v231 + v195);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v155, 24);
                      uint64_t v38 = &v219;
                      uint64_t v39 = v231;
                    }
                  }
                  uint64_t v40 = &v39[6 * v232];
                  long long v41 = *(_OWORD *)v38;
                  *((void *)v40 + 2) = *((void *)v38 + 2);
                  *(_OWORD *)uint64_t v40 = v41;
                  uint64_t v42 = ++v232;
                  if (v230[0])
                  {
                    int v219 = 3;
                    v220 = "OIHW";
                    uint64_t v221 = 4;
                    uint64_t v43 = &v219;
                    uint64_t v44 = v231;
                    if (v42 >= v233)
                    {
                      unint64_t v157 = v42 + 1;
                      BOOL v158 = &v231[6 * v42] > &v219;
                      if (v231 <= &v219 && v158)
                      {
                        int64_t v198 = (char *)&v219 - (char *)v231;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v157, 24);
                        uint64_t v44 = v231;
                        uint64_t v43 = (int *)((char *)v231 + v198);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v157, 24);
                        uint64_t v43 = &v219;
                        uint64_t v44 = v231;
                      }
                    }
                    unsigned int v45 = &v44[6 * v232];
                    long long v46 = *(_OWORD *)v43;
                    *((void *)v45 + 2) = *((void *)v43 + 2);
                    *(_OWORD *)unsigned int v45 = v46;
                    uint64_t v47 = ++v232;
                    if (v230[0])
                    {
                      int v219 = 3;
                      v220 = ", ";
                      uint64_t v221 = 2;
                      uint64_t v48 = &v219;
                      uint64_t v49 = v231;
                      if (v47 >= v233)
                      {
                        unint64_t v159 = v47 + 1;
                        BOOL v160 = &v231[6 * v47] > &v219;
                        if (v231 <= &v219 && v160)
                        {
                          int64_t v199 = (char *)&v219 - (char *)v231;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v159, 24);
                          uint64_t v49 = v231;
                          uint64_t v48 = (int *)((char *)v231 + v199);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v159, 24);
                          uint64_t v48 = &v219;
                          uint64_t v49 = v231;
                        }
                      }
                      uint64_t v50 = &v49[6 * v232];
                      long long v51 = *(_OWORD *)v48;
                      *((void *)v50 + 2) = *((void *)v48 + 2);
                      *(_OWORD *)uint64_t v50 = v51;
                      uint64_t v52 = ++v232;
                      if (v230[0])
                      {
                        int v219 = 3;
                        v220 = "HWIO";
                        uint64_t v221 = 4;
                        __int16 v53 = &v219;
                        uint64_t v54 = v231;
                        if (v52 >= v233)
                        {
                          unint64_t v161 = v52 + 1;
                          BOOL v162 = &v231[6 * v52] > &v219;
                          if (v231 <= &v219 && v162)
                          {
                            int64_t v200 = (char *)&v219 - (char *)v231;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v161, 24);
                            uint64_t v54 = v231;
                            __int16 v53 = (int *)((char *)v231 + v200);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v161, 24);
                            __int16 v53 = &v219;
                            uint64_t v54 = v231;
                          }
                        }
                        uint64_t v55 = &v54[6 * v232];
                        long long v56 = *(_OWORD *)v53;
                        *((void *)v55 + 2) = *((void *)v53 + 2);
                        *(_OWORD *)uint64_t v55 = v56;
                        uint64_t v57 = ++v232;
                        if (v230[0])
                        {
                          int v219 = 3;
                          v220 = ", ";
                          uint64_t v221 = 2;
                          uint64_t v58 = &v219;
                          unint64_t v59 = v231;
                          if (v57 >= v233)
                          {
                            unint64_t v163 = v57 + 1;
                            BOOL v164 = &v231[6 * v57] > &v219;
                            if (v231 <= &v219 && v164)
                            {
                              int64_t v201 = (char *)&v219 - (char *)v231;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v163, 24);
                              unint64_t v59 = v231;
                              uint64_t v58 = (int *)((char *)v231 + v201);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v163, 24);
                              uint64_t v58 = &v219;
                              unint64_t v59 = v231;
                            }
                          }
                          uint64_t v60 = &v59[6 * v232];
                          long long v61 = *(_OWORD *)v58;
                          *((void *)v60 + 2) = *((void *)v58 + 2);
                          *(_OWORD *)uint64_t v60 = v61;
                          uint64_t v62 = ++v232;
                          if (v230[0])
                          {
                            int v219 = 3;
                            v220 = "CHW";
                            uint64_t v221 = 3;
                            uint64_t v63 = &v219;
                            uint64_t v64 = v231;
                            if (v62 >= v233)
                            {
                              unint64_t v165 = v62 + 1;
                              BOOL v166 = &v231[6 * v62] > &v219;
                              if (v231 <= &v219 && v166)
                              {
                                int64_t v202 = (char *)&v219 - (char *)v231;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v165, 24);
                                uint64_t v64 = v231;
                                uint64_t v63 = (int *)((char *)v231 + v202);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v165, 24);
                                uint64_t v63 = &v219;
                                uint64_t v64 = v231;
                              }
                            }
                            char v65 = &v64[6 * v232];
                            long long v66 = *(_OWORD *)v63;
                            *((void *)v65 + 2) = *((void *)v63 + 2);
                            *(_OWORD *)char v65 = v66;
                            uint64_t v67 = ++v232;
                            if (v230[0])
                            {
                              int v219 = 3;
                              v220 = ", ";
                              uint64_t v221 = 2;
                              BOOL v68 = &v219;
                              uint64_t v69 = v231;
                              if (v67 >= v233)
                              {
                                unint64_t v167 = v67 + 1;
                                BOOL v168 = &v231[6 * v67] > &v219;
                                if (v231 <= &v219 && v168)
                                {
                                  int64_t v203 = (char *)&v219 - (char *)v231;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v167, 24);
                                  uint64_t v69 = v231;
                                  BOOL v68 = (int *)((char *)v231 + v203);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v167, 24);
                                  BOOL v68 = &v219;
                                  uint64_t v69 = v231;
                                }
                              }
                              BOOL v70 = &v69[6 * v232];
                              long long v71 = *(_OWORD *)v68;
                              *((void *)v70 + 2) = *((void *)v68 + 2);
                              *(_OWORD *)BOOL v70 = v71;
                              uint64_t v72 = ++v232;
                              if (v230[0])
                              {
                                int v219 = 3;
                                v220 = "HWC";
                                uint64_t v221 = 3;
                                __int16 v73 = &v219;
                                uint64_t v74 = v231;
                                if (v72 >= v233)
                                {
                                  unint64_t v169 = v72 + 1;
                                  BOOL v170 = &v231[6 * v72] > &v219;
                                  if (v231 <= &v219 && v170)
                                  {
                                    int64_t v204 = (char *)&v219 - (char *)v231;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v169, 24);
                                    uint64_t v74 = v231;
                                    __int16 v73 = (int *)((char *)v231 + v204);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v169, 24);
                                    __int16 v73 = &v219;
                                    uint64_t v74 = v231;
                                  }
                                }
                                long long v75 = &v74[6 * v232];
                                long long v76 = *(_OWORD *)v73;
                                *((void *)v75 + 2) = *((void *)v73 + 2);
                                *(_OWORD *)long long v75 = v76;
                                uint64_t v77 = ++v232;
                                if (v230[0])
                                {
                                  int v219 = 3;
                                  v220 = ", ";
                                  uint64_t v221 = 2;
                                  int64_t v78 = &v219;
                                  uint64_t v79 = v231;
                                  if (v77 >= v233)
                                  {
                                    unint64_t v171 = v77 + 1;
                                    BOOL v172 = &v231[6 * v77] > &v219;
                                    if (v231 <= &v219 && v172)
                                    {
                                      int64_t v205 = (char *)&v219 - (char *)v231;
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v171, 24);
                                      uint64_t v79 = v231;
                                      int64_t v78 = (int *)((char *)v231 + v205);
                                    }
                                    else
                                    {
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v171, 24);
                                      int64_t v78 = &v219;
                                      uint64_t v79 = v231;
                                    }
                                  }
                                  uint64_t v80 = &v79[6 * v232];
                                  long long v81 = *(_OWORD *)v78;
                                  *((void *)v80 + 2) = *((void *)v78 + 2);
                                  *(_OWORD *)uint64_t v80 = v81;
                                  uint64_t v82 = ++v232;
                                  if (v230[0])
                                  {
                                    int v219 = 3;
                                    v220 = "HW";
                                    uint64_t v221 = 2;
                                    int64_t v83 = &v219;
                                    uint64_t v84 = v231;
                                    if (v82 >= v233)
                                    {
                                      unint64_t v173 = v82 + 1;
                                      BOOL v174 = &v231[6 * v82] > &v219;
                                      if (v231 <= &v219 && v174)
                                      {
                                        int64_t v206 = (char *)&v219 - (char *)v231;
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v173, 24);
                                        uint64_t v84 = v231;
                                        int64_t v83 = (int *)((char *)v231 + v206);
                                      }
                                      else
                                      {
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v173, 24);
                                        int64_t v83 = &v219;
                                        uint64_t v84 = v231;
                                      }
                                    }
                                    uint64_t v85 = &v84[6 * v232];
                                    long long v86 = *(_OWORD *)v83;
                                    *((void *)v85 + 2) = *((void *)v83 + 2);
                                    *(_OWORD *)uint64_t v85 = v86;
                                    uint64_t v87 = ++v232;
                                    if (v230[0])
                                    {
                                      int v219 = 3;
                                      v220 = ", ";
                                      uint64_t v221 = 2;
                                      int v88 = &v219;
                                      uint64_t v89 = v231;
                                      if (v87 >= v233)
                                      {
                                        unint64_t v175 = v87 + 1;
                                        BOOL v176 = &v231[6 * v87] > &v219;
                                        if (v231 <= &v219 && v176)
                                        {
                                          int64_t v207 = (char *)&v219 - (char *)v231;
                                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v175, 24);
                                          uint64_t v89 = v231;
                                          int v88 = (int *)((char *)v231 + v207);
                                        }
                                        else
                                        {
                                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v175, 24);
                                          int v88 = &v219;
                                          uint64_t v89 = v231;
                                        }
                                      }
                                      uint64_t v90 = &v89[6 * v232];
                                      long long v91 = *(_OWORD *)v88;
                                      *((void *)v90 + 2) = *((void *)v88 + 2);
                                      *(_OWORD *)uint64_t v90 = v91;
                                      uint64_t v92 = ++v232;
                                      if (v230[0])
                                      {
                                        int v219 = 3;
                                        v220 = "NCDHW";
                                        uint64_t v221 = 5;
                                        char v93 = &v219;
                                        long long v94 = v231;
                                        if (v92 >= v233)
                                        {
                                          unint64_t v178 = v92 + 1;
                                          BOOL v179 = &v231[6 * v92] > &v219;
                                          if (v231 <= &v219 && v179)
                                          {
                                            int64_t v208 = (char *)&v219 - (char *)v231;
                                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v178, 24);
                                            long long v94 = v231;
                                            char v93 = (int *)((char *)v231 + v208);
                                          }
                                          else
                                          {
                                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v178, 24);
                                            char v93 = &v219;
                                            long long v94 = v231;
                                          }
                                        }
                                        uint64_t v95 = &v94[6 * v232];
                                        long long v96 = *(_OWORD *)v93;
                                        *((void *)v95 + 2) = *((void *)v93 + 2);
                                        *(_OWORD *)uint64_t v95 = v96;
                                        uint64_t v97 = ++v232;
                                        if (v230[0])
                                        {
                                          int v219 = 3;
                                          v220 = ", ";
                                          uint64_t v221 = 2;
                                          uint64_t v98 = &v219;
                                          uint64_t v99 = v231;
                                          if (v97 >= v233)
                                          {
                                            unint64_t v181 = v97 + 1;
                                            BOOL v182 = &v231[6 * v97] > &v219;
                                            if (v231 <= &v219 && v182)
                                            {
                                              int64_t v209 = (char *)&v219 - (char *)v231;
                                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v181, 24);
                                              uint64_t v99 = v231;
                                              uint64_t v98 = (int *)((char *)v231 + v209);
                                            }
                                            else
                                            {
                                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v181, 24);
                                              uint64_t v98 = &v219;
                                              uint64_t v99 = v231;
                                            }
                                          }
                                          uint64_t v100 = &v99[6 * v232];
                                          long long v101 = *(_OWORD *)v98;
                                          *((void *)v100 + 2) = *((void *)v98 + 2);
                                          *(_OWORD *)uint64_t v100 = v101;
                                          uint64_t v102 = ++v232;
                                          if (v230[0])
                                          {
                                            int v219 = 3;
                                            v220 = "NDHWC";
                                            uint64_t v221 = 5;
                                            uint64_t v103 = &v219;
                                            v104 = v231;
                                            if (v102 >= v233)
                                            {
                                              unint64_t v184 = v102 + 1;
                                              BOOL v185 = &v231[6 * v102] > &v219;
                                              if (v231 <= &v219 && v185)
                                              {
                                                int64_t v210 = (char *)&v219 - (char *)v231;
                                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v184, 24);
                                                v104 = v231;
                                                uint64_t v103 = (int *)((char *)v231 + v210);
                                              }
                                              else
                                              {
                                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v184, 24);
                                                uint64_t v103 = &v219;
                                                v104 = v231;
                                              }
                                            }
                                            v105 = &v104[6 * v232];
                                            long long v106 = *(_OWORD *)v103;
                                            *((void *)v105 + 2) = *((void *)v103 + 2);
                                            *(_OWORD *)v105 = v106;
                                            uint64_t v107 = ++v232;
                                            if (v230[0])
                                            {
                                              int v219 = 3;
                                              v220 = ", ";
                                              uint64_t v221 = 2;
                                              v108 = &v219;
                                              v109 = v231;
                                              if (v107 >= v233)
                                              {
                                                unint64_t v187 = v107 + 1;
                                                BOOL v188 = &v231[6 * v107] > &v219;
                                                if (v231 <= &v219 && v188)
                                                {
                                                  int64_t v211 = (char *)&v219 - (char *)v231;
                                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v187, 24);
                                                  v109 = v231;
                                                  v108 = (int *)((char *)v231 + v211);
                                                }
                                                else
                                                {
                                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v187, 24);
                                                  v108 = &v219;
                                                  v109 = v231;
                                                }
                                              }
                                              v110 = &v109[6 * v232];
                                              long long v111 = *(_OWORD *)v108;
                                              *((void *)v110 + 2) = *((void *)v108 + 2);
                                              *(_OWORD *)v110 = v111;
                                              uint64_t v112 = ++v232;
                                              if (v230[0])
                                              {
                                                int v219 = 3;
                                                v220 = "OIDHW";
                                                uint64_t v221 = 5;
                                                v113 = &v219;
                                                v114 = v231;
                                                if (v112 >= v233)
                                                {
                                                  unint64_t v190 = v112 + 1;
                                                  BOOL v191 = &v231[6 * v112] > &v219;
                                                  if (v231 <= &v219 && v191)
                                                  {
                                                    int64_t v212 = (char *)&v219 - (char *)v231;
                                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v190, 24);
                                                    v114 = v231;
                                                    v113 = (int *)((char *)v231 + v212);
                                                  }
                                                  else
                                                  {
                                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v190, 24);
                                                    v113 = &v219;
                                                    v114 = v231;
                                                  }
                                                }
                                                v115 = &v114[6 * v232];
                                                long long v116 = *(_OWORD *)v113;
                                                *((void *)v115 + 2) = *((void *)v113 + 2);
                                                *(_OWORD *)v115 = v116;
                                                uint64_t v117 = ++v232;
                                                if (v230[0])
                                                {
                                                  int v219 = 3;
                                                  v220 = ", ";
                                                  uint64_t v221 = 2;
                                                  v118 = &v219;
                                                  v119 = v231;
                                                  if (v117 >= v233)
                                                  {
                                                    unint64_t v193 = v117 + 1;
                                                    BOOL v194 = &v231[6 * v117] > &v219;
                                                    if (v231 <= &v219 && v194)
                                                    {
                                                      int64_t v213 = (char *)&v219 - (char *)v231;
                                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v193, 24);
                                                      v119 = v231;
                                                      v118 = (int *)((char *)v231 + v213);
                                                    }
                                                    else
                                                    {
                                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v193, 24);
                                                      v118 = &v219;
                                                      v119 = v231;
                                                    }
                                                  }
                                                  v120 = &v119[6 * v232];
                                                  long long v121 = *(_OWORD *)v118;
                                                  *((void *)v120 + 2) = *((void *)v118 + 2);
                                                  *(_OWORD *)v120 = v121;
                                                  uint64_t v122 = ++v232;
                                                  if (v230[0])
                                                  {
                                                    int v219 = 3;
                                                    v220 = "DHWIO";
                                                    uint64_t v221 = 5;
                                                    v123 = &v219;
                                                    v124 = v231;
                                                    if (v122 >= v233)
                                                    {
                                                      unint64_t v196 = v122 + 1;
                                                      BOOL v197 = &v231[6 * v122] > &v219;
                                                      if (v231 <= &v219 && v197)
                                                      {
                                                        int64_t v214 = (char *)&v219 - (char *)v231;
                                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v196, 24);
                                                        v124 = v231;
                                                        v123 = (int *)((char *)v231 + v214);
                                                      }
                                                      else
                                                      {
                                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v196, 24);
                                                        v123 = &v219;
                                                        v124 = v231;
                                                      }
                                                    }
                                                    v125 = &v124[6 * v232];
                                                    long long v126 = *(_OWORD *)v123;
                                                    *((void *)v125 + 2) = *((void *)v123 + 2);
                                                    *(_OWORD *)v125 = v126;
                                                    ++v232;
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v230);
    if (v230[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v230);
    }
    if (v239)
    {
      v127 = v237;
      if (v237)
      {
        v128 = v238;
        v129 = v237;
        if (v238 != v237)
        {
          do
            v128 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v128 - 1);
          while (v128 != v127);
          v129 = v237;
        }
        v238 = v127;
        operator delete(v129);
      }
      v130 = v235;
      if (v235)
      {
        v131 = v236;
        v132 = v235;
        if (v236 != v235)
        {
          do
          {
            v134 = (void *)*--v131;
            v133 = v134;
            void *v131 = 0;
            if (v134) {
              operator delete[](v133);
            }
          }
          while (v131 != v130);
          v132 = v235;
        }
        v236 = v130;
        operator delete(v132);
      }
      if (v231 != (int *)v234) {
        free(v231);
      }
    }
    goto LABEL_73;
  }
  unsigned int v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v215[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v230[0] = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
    v230[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v230, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, v215);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::TensorDataLayoutAttr::print(mlir::mps::TensorDataLayoutAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6 > 0xA)
    {
LABEL_6:
      size_t v9 = 0;
      int v8 = "";
      char v7 = 1;
      goto LABEL_17;
    }
  }
  else
  {
    unsigned char *v5 = 60;
    ++*((void *)v4 + 4);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
  }
  char v7 = 0;
  int v8 = "NCHW";
  size_t v9 = 4;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      char v7 = 0;
      int v8 = "NHWC";
      size_t v9 = 4;
      break;
    case 2u:
      char v7 = 0;
      int v8 = "OIHW";
      size_t v9 = 4;
      break;
    case 3u:
      char v7 = 0;
      int v8 = "HWIO";
      size_t v9 = 4;
      break;
    case 4u:
      char v7 = 0;
      int v8 = "CHW";
      size_t v9 = 3;
      break;
    case 5u:
      char v7 = 0;
      int v8 = "HWC";
      size_t v9 = 3;
      break;
    case 6u:
      char v7 = 0;
      int v8 = "HW";
      size_t v9 = 2;
      break;
    case 7u:
      char v7 = 0;
      int v8 = "NCDHW";
      goto LABEL_16;
    case 8u:
      char v7 = 0;
      int v8 = "NDHWC";
      goto LABEL_16;
    case 9u:
      char v7 = 0;
      int v8 = "OIDHW";
      goto LABEL_16;
    case 0xAu:
      char v7 = 0;
      int v8 = "DHWIO";
LABEL_16:
      size_t v9 = 5;
      break;
    default:
      goto LABEL_6;
  }
LABEL_17:
  uint64_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v11 = (void *)*((void *)v10 + 4);
  if (v9 <= *((void *)v10 + 3) - (void)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((void *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    unsigned char *v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::ReductionModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::ReductionModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::ReductionModeAttrStorage,mlir::mps::ReductionMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24ReductionModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17ReductionModeAttrEJNS2_13ReductionModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReductionModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::ReductionModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v160 = *MEMORY[0x1E4F143B8];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1)) {
    return 0;
  }
  uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  uint64_t v137 = 0;
  uint64_t v138 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v137))
  {
LABEL_53:
    uint64_t v85 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    LOWORD(v152) = 259;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v142, a1, v85, v150);
    if (v142[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v142);
    }
    if (v149)
    {
      long long v86 = (void **)__p;
      if (__p)
      {
        uint64_t v87 = v148;
        int v88 = __p;
        if (v148 != __p)
        {
          do
            uint64_t v87 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v87 - 1);
          while (v87 != v86);
          int v88 = __p;
        }
        BOOL v148 = v86;
        operator delete(v88);
      }
      uint64_t v89 = v145;
      if (v145)
      {
        uint64_t v90 = v146;
        long long v91 = v145;
        if (v146 != v145)
        {
          do
          {
            char v93 = (void *)*--v90;
            uint64_t v92 = v93;
            *uint64_t v90 = 0;
            if (v93) {
              operator delete[](v92);
            }
          }
          while (v90 != v89);
          long long v91 = v145;
        }
        BOOL v146 = v89;
        operator delete(v91);
      }
      if (v143 != &v144) {
        free(v143);
      }
    }
    return 0;
  }
  uint64_t v3 = mlir::mps::symbolizeReductionMode(v137, v138);
  if ((v3 & 0xFF00000000) == 0)
  {
    __int16 v136 = 257;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v150, a1, v2, v135);
    if (v150[0])
    {
      int v139 = 3;
      v140 = "expected ";
      uint64_t v141 = 9;
      int v8 = &v139;
      size_t v9 = v151;
      if (v152 >= v153)
      {
        unint64_t v94 = v152 + 1;
        if (v151 <= &v139 && &v151[6 * v152] > &v139)
        {
          int64_t v121 = (char *)&v139 - (char *)v151;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v94, 24);
          size_t v9 = v151;
          int v8 = (int *)((char *)v151 + v121);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v94, 24);
          int v8 = &v139;
          size_t v9 = v151;
        }
      }
      uint64_t v10 = &v9[6 * v152];
      long long v11 = *(_OWORD *)v8;
      *((void *)v10 + 2) = *((void *)v8 + 2);
      *(_OWORD *)uint64_t v10 = v11;
      uint64_t v12 = ++v152;
      if (v150[0])
      {
        int v139 = 3;
        v140 = "::mlir::mps::ReductionMode";
        uint64_t v141 = 26;
        uint64_t v13 = &v139;
        BOOL v14 = v151;
        if (v12 >= v153)
        {
          unint64_t v95 = v12 + 1;
          BOOL v96 = &v151[6 * v12] > &v139;
          if (v151 <= &v139 && v96)
          {
            int64_t v122 = (char *)&v139 - (char *)v151;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v95, 24);
            BOOL v14 = v151;
            uint64_t v13 = (int *)((char *)v151 + v122);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v95, 24);
            uint64_t v13 = &v139;
            BOOL v14 = v151;
          }
        }
        uint64_t v15 = &v14[6 * v152];
        long long v16 = *(_OWORD *)v13;
        *((void *)v15 + 2) = *((void *)v13 + 2);
        *(_OWORD *)uint64_t v15 = v16;
        uint64_t v17 = ++v152;
        if (v150[0])
        {
          int v139 = 3;
          v140 = " to be one of: ";
          uint64_t v141 = 15;
          uint64_t v18 = &v139;
          uint64_t v19 = v151;
          if (v17 >= v153)
          {
            unint64_t v97 = v17 + 1;
            BOOL v98 = &v151[6 * v17] > &v139;
            if (v151 <= &v139 && v98)
            {
              int64_t v123 = (char *)&v139 - (char *)v151;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v97, 24);
              uint64_t v19 = v151;
              uint64_t v18 = (int *)((char *)v151 + v123);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v97, 24);
              uint64_t v18 = &v139;
              uint64_t v19 = v151;
            }
          }
          uint64_t v20 = &v19[6 * v152];
          long long v21 = *(_OWORD *)v18;
          *((void *)v20 + 2) = *((void *)v18 + 2);
          *(_OWORD *)uint64_t v20 = v21;
          uint64_t v22 = ++v152;
          if (v150[0])
          {
            int v139 = 3;
            v140 = "min";
            uint64_t v141 = 3;
            uint64_t v23 = &v139;
            uint64_t v24 = v151;
            if (v22 >= v153)
            {
              unint64_t v99 = v22 + 1;
              BOOL v100 = &v151[6 * v22] > &v139;
              if (v151 <= &v139 && v100)
              {
                int64_t v124 = (char *)&v139 - (char *)v151;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v99, 24);
                uint64_t v24 = v151;
                uint64_t v23 = (int *)((char *)v151 + v124);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v99, 24);
                uint64_t v23 = &v139;
                uint64_t v24 = v151;
              }
            }
            uint64_t v25 = &v24[6 * v152];
            long long v26 = *(_OWORD *)v23;
            *((void *)v25 + 2) = *((void *)v23 + 2);
            *(_OWORD *)uint64_t v25 = v26;
            uint64_t v27 = ++v152;
            if (v150[0])
            {
              int v139 = 3;
              v140 = ", ";
              uint64_t v141 = 2;
              uint64_t v28 = &v139;
              unint64_t v29 = v151;
              if (v27 >= v153)
              {
                unint64_t v101 = v27 + 1;
                BOOL v102 = &v151[6 * v27] > &v139;
                if (v151 <= &v139 && v102)
                {
                  int64_t v125 = (char *)&v139 - (char *)v151;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v101, 24);
                  unint64_t v29 = v151;
                  uint64_t v28 = (int *)((char *)v151 + v125);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v101, 24);
                  uint64_t v28 = &v139;
                  unint64_t v29 = v151;
                }
              }
              uint64_t v30 = &v29[6 * v152];
              long long v31 = *(_OWORD *)v28;
              *((void *)v30 + 2) = *((void *)v28 + 2);
              *(_OWORD *)uint64_t v30 = v31;
              uint64_t v32 = ++v152;
              if (v150[0])
              {
                int v139 = 3;
                v140 = "max";
                uint64_t v141 = 3;
                uint64_t v33 = &v139;
                uint64_t v34 = v151;
                if (v32 >= v153)
                {
                  unint64_t v103 = v32 + 1;
                  BOOL v104 = &v151[6 * v32] > &v139;
                  if (v151 <= &v139 && v104)
                  {
                    int64_t v126 = (char *)&v139 - (char *)v151;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v103, 24);
                    uint64_t v34 = v151;
                    uint64_t v33 = (int *)((char *)v151 + v126);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v103, 24);
                    uint64_t v33 = &v139;
                    uint64_t v34 = v151;
                  }
                }
                int v35 = &v34[6 * v152];
                long long v36 = *(_OWORD *)v33;
                *((void *)v35 + 2) = *((void *)v33 + 2);
                *(_OWORD *)int v35 = v36;
                uint64_t v37 = ++v152;
                if (v150[0])
                {
                  int v139 = 3;
                  v140 = ", ";
                  uint64_t v141 = 2;
                  uint64_t v38 = &v139;
                  uint64_t v39 = v151;
                  if (v37 >= v153)
                  {
                    unint64_t v105 = v37 + 1;
                    BOOL v106 = &v151[6 * v37] > &v139;
                    if (v151 <= &v139 && v106)
                    {
                      int64_t v127 = (char *)&v139 - (char *)v151;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v105, 24);
                      uint64_t v39 = v151;
                      uint64_t v38 = (int *)((char *)v151 + v127);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v105, 24);
                      uint64_t v38 = &v139;
                      uint64_t v39 = v151;
                    }
                  }
                  uint64_t v40 = &v39[6 * v152];
                  long long v41 = *(_OWORD *)v38;
                  *((void *)v40 + 2) = *((void *)v38 + 2);
                  *(_OWORD *)uint64_t v40 = v41;
                  uint64_t v42 = ++v152;
                  if (v150[0])
                  {
                    int v139 = 3;
                    v140 = "sum";
                    uint64_t v141 = 3;
                    uint64_t v43 = &v139;
                    uint64_t v44 = v151;
                    if (v42 >= v153)
                    {
                      unint64_t v107 = v42 + 1;
                      BOOL v108 = &v151[6 * v42] > &v139;
                      if (v151 <= &v139 && v108)
                      {
                        int64_t v128 = (char *)&v139 - (char *)v151;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v107, 24);
                        uint64_t v44 = v151;
                        uint64_t v43 = (int *)((char *)v151 + v128);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v107, 24);
                        uint64_t v43 = &v139;
                        uint64_t v44 = v151;
                      }
                    }
                    unsigned int v45 = &v44[6 * v152];
                    long long v46 = *(_OWORD *)v43;
                    *((void *)v45 + 2) = *((void *)v43 + 2);
                    *(_OWORD *)unsigned int v45 = v46;
                    uint64_t v47 = ++v152;
                    if (v150[0])
                    {
                      int v139 = 3;
                      v140 = ", ";
                      uint64_t v141 = 2;
                      uint64_t v48 = &v139;
                      uint64_t v49 = v151;
                      if (v47 >= v153)
                      {
                        unint64_t v109 = v47 + 1;
                        BOOL v110 = &v151[6 * v47] > &v139;
                        if (v151 <= &v139 && v110)
                        {
                          int64_t v129 = (char *)&v139 - (char *)v151;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v109, 24);
                          uint64_t v49 = v151;
                          uint64_t v48 = (int *)((char *)v151 + v129);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v109, 24);
                          uint64_t v48 = &v139;
                          uint64_t v49 = v151;
                        }
                      }
                      uint64_t v50 = &v49[6 * v152];
                      long long v51 = *(_OWORD *)v48;
                      *((void *)v50 + 2) = *((void *)v48 + 2);
                      *(_OWORD *)uint64_t v50 = v51;
                      uint64_t v52 = ++v152;
                      if (v150[0])
                      {
                        int v139 = 3;
                        v140 = "product";
                        uint64_t v141 = 7;
                        __int16 v53 = &v139;
                        uint64_t v54 = v151;
                        if (v52 >= v153)
                        {
                          unint64_t v111 = v52 + 1;
                          BOOL v112 = &v151[6 * v52] > &v139;
                          if (v151 <= &v139 && v112)
                          {
                            int64_t v130 = (char *)&v139 - (char *)v151;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v111, 24);
                            uint64_t v54 = v151;
                            __int16 v53 = (int *)((char *)v151 + v130);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v111, 24);
                            __int16 v53 = &v139;
                            uint64_t v54 = v151;
                          }
                        }
                        uint64_t v55 = &v54[6 * v152];
                        long long v56 = *(_OWORD *)v53;
                        *((void *)v55 + 2) = *((void *)v53 + 2);
                        *(_OWORD *)uint64_t v55 = v56;
                        uint64_t v57 = ++v152;
                        if (v150[0])
                        {
                          int v139 = 3;
                          v140 = ", ";
                          uint64_t v141 = 2;
                          uint64_t v58 = &v139;
                          unint64_t v59 = v151;
                          if (v57 >= v153)
                          {
                            unint64_t v113 = v57 + 1;
                            BOOL v114 = &v151[6 * v57] > &v139;
                            if (v151 <= &v139 && v114)
                            {
                              int64_t v131 = (char *)&v139 - (char *)v151;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v113, 24);
                              unint64_t v59 = v151;
                              uint64_t v58 = (int *)((char *)v151 + v131);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v113, 24);
                              uint64_t v58 = &v139;
                              unint64_t v59 = v151;
                            }
                          }
                          uint64_t v60 = &v59[6 * v152];
                          long long v61 = *(_OWORD *)v58;
                          *((void *)v60 + 2) = *((void *)v58 + 2);
                          *(_OWORD *)uint64_t v60 = v61;
                          uint64_t v62 = ++v152;
                          if (v150[0])
                          {
                            int v139 = 3;
                            v140 = "argMin ";
                            uint64_t v141 = 7;
                            uint64_t v63 = &v139;
                            uint64_t v64 = v151;
                            if (v62 >= v153)
                            {
                              unint64_t v115 = v62 + 1;
                              BOOL v116 = &v151[6 * v62] > &v139;
                              if (v151 <= &v139 && v116)
                              {
                                int64_t v132 = (char *)&v139 - (char *)v151;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v115, 24);
                                uint64_t v64 = v151;
                                uint64_t v63 = (int *)((char *)v151 + v132);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v115, 24);
                                uint64_t v63 = &v139;
                                uint64_t v64 = v151;
                              }
                            }
                            char v65 = &v64[6 * v152];
                            long long v66 = *(_OWORD *)v63;
                            *((void *)v65 + 2) = *((void *)v63 + 2);
                            *(_OWORD *)char v65 = v66;
                            uint64_t v67 = ++v152;
                            if (v150[0])
                            {
                              int v139 = 3;
                              v140 = ", ";
                              uint64_t v141 = 2;
                              BOOL v68 = &v139;
                              uint64_t v69 = v151;
                              if (v67 >= v153)
                              {
                                unint64_t v117 = v67 + 1;
                                BOOL v118 = &v151[6 * v67] > &v139;
                                if (v151 <= &v139 && v118)
                                {
                                  int64_t v133 = (char *)&v139 - (char *)v151;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v117, 24);
                                  uint64_t v69 = v151;
                                  BOOL v68 = (int *)((char *)v151 + v133);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v117, 24);
                                  BOOL v68 = &v139;
                                  uint64_t v69 = v151;
                                }
                              }
                              BOOL v70 = &v69[6 * v152];
                              long long v71 = *(_OWORD *)v68;
                              *((void *)v70 + 2) = *((void *)v68 + 2);
                              *(_OWORD *)BOOL v70 = v71;
                              uint64_t v72 = ++v152;
                              if (v150[0])
                              {
                                int v139 = 3;
                                v140 = "argMax";
                                uint64_t v141 = 6;
                                __int16 v73 = &v139;
                                uint64_t v74 = v151;
                                if (v72 >= v153)
                                {
                                  unint64_t v119 = v72 + 1;
                                  BOOL v120 = &v151[6 * v72] > &v139;
                                  if (v151 <= &v139 && v120)
                                  {
                                    int64_t v134 = (char *)&v139 - (char *)v151;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v119, 24);
                                    uint64_t v74 = v151;
                                    __int16 v73 = (int *)((char *)v151 + v134);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v119, 24);
                                    __int16 v73 = &v139;
                                    uint64_t v74 = v151;
                                  }
                                }
                                long long v75 = &v74[6 * v152];
                                long long v76 = *(_OWORD *)v73;
                                *((void *)v75 + 2) = *((void *)v73 + 2);
                                *(_OWORD *)long long v75 = v76;
                                ++v152;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v150);
    if (v150[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v150);
    }
    if (v159)
    {
      uint64_t v77 = v157;
      if (v157)
      {
        int64_t v78 = v158;
        uint64_t v79 = v157;
        if (v158 != v157)
        {
          do
            int64_t v78 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v78 - 1);
          while (v78 != v77);
          uint64_t v79 = v157;
        }
        BOOL v158 = v77;
        operator delete(v79);
      }
      uint64_t v80 = v155;
      if (v155)
      {
        long long v81 = v156;
        uint64_t v82 = v155;
        if (v156 != v155)
        {
          do
          {
            uint64_t v84 = (void *)*--v81;
            int64_t v83 = v84;
            *long long v81 = 0;
            if (v84) {
              operator delete[](v83);
            }
          }
          while (v81 != v80);
          uint64_t v82 = v155;
        }
        BOOL v156 = v80;
        operator delete(v82);
      }
      if (v151 != (int *)v154) {
        free(v151);
      }
    }
    goto LABEL_53;
  }
  unsigned int v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v135[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v150[0] = &mlir::detail::TypeIDResolver<mlir::mps::ReductionModeAttr,void>::id;
    v150[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::ReductionModeAttrStorage,mlir::mps::ReductionMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24ReductionModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17ReductionModeAttrEJNS2_13ReductionModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v150, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReductionModeAttr,void>::id, v135);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::ReductionModeAttr::print(mlir::mps::ReductionModeAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6 > 5)
    {
LABEL_6:
      size_t v9 = 0;
      int v8 = "";
      char v7 = 1;
      goto LABEL_11;
    }
  }
  else
  {
    unsigned char *v5 = 60;
    ++*((void *)v4 + 4);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
  }
  char v7 = 0;
  int v8 = "min";
  size_t v9 = 3;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      char v7 = 0;
      int v8 = "max";
      size_t v9 = 3;
      break;
    case 2u:
      char v7 = 0;
      int v8 = "sum";
      size_t v9 = 3;
      break;
    case 3u:
      char v7 = 0;
      int v8 = "product";
      size_t v9 = 7;
      break;
    case 4u:
      char v7 = 0;
      int v8 = "argMin ";
      size_t v9 = 7;
      break;
    case 5u:
      char v7 = 0;
      int v8 = "argMax";
      size_t v9 = 6;
      break;
    default:
      goto LABEL_6;
  }
LABEL_11:
  uint64_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v11 = (void *)*((void *)v10 + 4);
  if (v9 <= *((void *)v10 + 3) - (void)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((void *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    unsigned char *v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::DeviceHintAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::DeviceHintAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::DeviceHintAttrStorage,mlir::mps::DeviceHint>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail21DeviceHintAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_14DeviceHintAttrEJNS2_10DeviceHintEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::DeviceHintAttr,void>::id, &v5);
}

uint64_t mlir::mps::DeviceHintAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v112 = *MEMORY[0x1E4F143B8];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1))
  {
    uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    uint64_t v89 = 0;
    uint64_t v90 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v89))
    {
LABEL_52:
      uint64_t v54 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
      LOWORD(v104) = 259;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v94, a1, v54, v102);
      if (v94[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v94);
      }
      if (v101)
      {
        uint64_t v55 = (void **)__p;
        if (__p)
        {
          long long v56 = v100;
          uint64_t v57 = __p;
          if (v100 != __p)
          {
            do
              long long v56 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v56 - 1);
            while (v56 != v55);
            uint64_t v57 = __p;
          }
          BOOL v100 = v55;
          operator delete(v57);
        }
        uint64_t v58 = v97;
        if (v97)
        {
          unint64_t v59 = v98;
          uint64_t v60 = v97;
          if (v98 != v97)
          {
            do
            {
              uint64_t v62 = (void *)*--v59;
              long long v61 = v62;
              void *v59 = 0;
              if (v62) {
                operator delete[](v61);
              }
            }
            while (v59 != v58);
            uint64_t v60 = v97;
          }
          BOOL v98 = v58;
          operator delete(v60);
        }
        if (v95 != &v96) {
          free(v95);
        }
      }
      return 0;
    }
    if (v90 != 3)
    {
LABEL_16:
      __int16 v88 = 257;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v102, a1, v2, v87);
      if (v102[0])
      {
        int v91 = 3;
        uint64_t v92 = "expected ";
        uint64_t v93 = 9;
        unsigned int v6 = &v91;
        char v7 = v103;
        if (v104 >= v105)
        {
          unint64_t v66 = v104 + 1;
          if (v103 <= &v91 && &v103[6 * v104] > &v91)
          {
            int64_t v79 = (char *)&v91 - (char *)v103;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
            char v7 = v103;
            unsigned int v6 = (int *)((char *)v103 + v79);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
            unsigned int v6 = &v91;
            char v7 = v103;
          }
        }
        int v8 = &v7[6 * v104];
        long long v9 = *(_OWORD *)v6;
        *((void *)v8 + 2) = *((void *)v6 + 2);
        *(_OWORD *)int v8 = v9;
        uint64_t v10 = ++v104;
        if (v102[0])
        {
          int v91 = 3;
          uint64_t v92 = "::mlir::mps::DeviceHint";
          uint64_t v93 = 23;
          long long v11 = &v91;
          uint64_t v12 = v103;
          if (v10 >= v105)
          {
            unint64_t v67 = v10 + 1;
            BOOL v68 = &v103[6 * v10] > &v91;
            if (v103 <= &v91 && v68)
            {
              int64_t v80 = (char *)&v91 - (char *)v103;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
              uint64_t v12 = v103;
              long long v11 = (int *)((char *)v103 + v80);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
              long long v11 = &v91;
              uint64_t v12 = v103;
            }
          }
          uint64_t v13 = &v12[6 * v104];
          long long v14 = *(_OWORD *)v11;
          *((void *)v13 + 2) = *((void *)v11 + 2);
          *(_OWORD *)uint64_t v13 = v14;
          uint64_t v15 = ++v104;
          if (v102[0])
          {
            int v91 = 3;
            uint64_t v92 = " to be one of: ";
            uint64_t v93 = 15;
            long long v16 = &v91;
            uint64_t v17 = v103;
            if (v15 >= v105)
            {
              unint64_t v69 = v15 + 1;
              BOOL v70 = &v103[6 * v15] > &v91;
              if (v103 <= &v91 && v70)
              {
                int64_t v81 = (char *)&v91 - (char *)v103;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                uint64_t v17 = v103;
                long long v16 = (int *)((char *)v103 + v81);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                long long v16 = &v91;
                uint64_t v17 = v103;
              }
            }
            uint64_t v18 = &v17[6 * v104];
            long long v19 = *(_OWORD *)v16;
            *((void *)v18 + 2) = *((void *)v16 + 2);
            *(_OWORD *)uint64_t v18 = v19;
            uint64_t v20 = ++v104;
            if (v102[0])
            {
              int v91 = 3;
              uint64_t v92 = "ANE";
              uint64_t v93 = 3;
              long long v21 = &v91;
              uint64_t v22 = v103;
              if (v20 >= v105)
              {
                unint64_t v71 = v20 + 1;
                BOOL v72 = &v103[6 * v20] > &v91;
                if (v103 <= &v91 && v72)
                {
                  int64_t v82 = (char *)&v91 - (char *)v103;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                  uint64_t v22 = v103;
                  long long v21 = (int *)((char *)v103 + v82);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                  long long v21 = &v91;
                  uint64_t v22 = v103;
                }
              }
              uint64_t v23 = &v22[6 * v104];
              long long v24 = *(_OWORD *)v21;
              *((void *)v23 + 2) = *((void *)v21 + 2);
              *(_OWORD *)uint64_t v23 = v24;
              uint64_t v25 = ++v104;
              if (v102[0])
              {
                int v91 = 3;
                uint64_t v92 = ", ";
                uint64_t v93 = 2;
                long long v26 = &v91;
                uint64_t v27 = v103;
                if (v25 >= v105)
                {
                  unint64_t v73 = v25 + 1;
                  if (v103 <= &v91 && &v103[6 * v25] > &v91)
                  {
                    int64_t v83 = (char *)&v91 - (char *)v103;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                    uint64_t v27 = v103;
                    long long v26 = (int *)((char *)v103 + v83);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                    long long v26 = &v91;
                    uint64_t v27 = v103;
                  }
                }
                uint64_t v28 = &v27[6 * v104];
                long long v29 = *(_OWORD *)v26;
                *((void *)v28 + 2) = *((void *)v26 + 2);
                *(_OWORD *)uint64_t v28 = v29;
                uint64_t v30 = ++v104;
                if (v102[0])
                {
                  int v91 = 3;
                  uint64_t v92 = "GPU";
                  uint64_t v93 = 3;
                  long long v31 = &v91;
                  uint64_t v32 = v103;
                  if (v30 >= v105)
                  {
                    unint64_t v74 = v30 + 1;
                    if (v103 <= &v91 && &v103[6 * v30] > &v91)
                    {
                      int64_t v84 = (char *)&v91 - (char *)v103;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                      uint64_t v32 = v103;
                      long long v31 = (int *)((char *)v103 + v84);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                      long long v31 = &v91;
                      uint64_t v32 = v103;
                    }
                  }
                  uint64_t v33 = &v32[6 * v104];
                  long long v34 = *(_OWORD *)v31;
                  *((void *)v33 + 2) = *((void *)v31 + 2);
                  *(_OWORD *)uint64_t v33 = v34;
                  uint64_t v35 = ++v104;
                  if (v102[0])
                  {
                    int v91 = 3;
                    uint64_t v92 = ", ";
                    uint64_t v93 = 2;
                    long long v36 = &v91;
                    uint64_t v37 = v103;
                    if (v35 >= v105)
                    {
                      unint64_t v75 = v35 + 1;
                      BOOL v76 = &v103[6 * v35] > &v91;
                      if (v103 <= &v91 && v76)
                      {
                        int64_t v85 = (char *)&v91 - (char *)v103;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                        uint64_t v37 = v103;
                        long long v36 = (int *)((char *)v103 + v85);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                        long long v36 = &v91;
                        uint64_t v37 = v103;
                      }
                    }
                    uint64_t v38 = &v37[6 * v104];
                    long long v39 = *(_OWORD *)v36;
                    *((void *)v38 + 2) = *((void *)v36 + 2);
                    *(_OWORD *)uint64_t v38 = v39;
                    uint64_t v40 = ++v104;
                    if (v102[0])
                    {
                      int v91 = 3;
                      uint64_t v92 = "CPU";
                      uint64_t v93 = 3;
                      long long v41 = &v91;
                      uint64_t v42 = v103;
                      if (v40 >= v105)
                      {
                        unint64_t v77 = v40 + 1;
                        BOOL v78 = &v103[6 * v40] > &v91;
                        if (v103 <= &v91 && v78)
                        {
                          int64_t v86 = (char *)&v91 - (char *)v103;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                          uint64_t v42 = v103;
                          long long v41 = (int *)((char *)v103 + v86);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                          long long v41 = &v91;
                          uint64_t v42 = v103;
                        }
                      }
                      uint64_t v43 = &v42[6 * v104];
                      long long v44 = *(_OWORD *)v41;
                      *((void *)v43 + 2) = *((void *)v41 + 2);
                      *(_OWORD *)uint64_t v43 = v44;
                      ++v104;
                    }
                  }
                }
              }
            }
          }
        }
      }
      mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v102);
      if (v102[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v102);
      }
      if (v111)
      {
        unsigned int v45 = v109;
        if (v109)
        {
          long long v46 = v110;
          uint64_t v47 = v109;
          if (v110 != v109)
          {
            do
              long long v46 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v46 - 1);
            while (v46 != v45);
            uint64_t v47 = v109;
          }
          BOOL v110 = v45;
          operator delete(v47);
        }
        uint64_t v48 = v107;
        if (v107)
        {
          uint64_t v49 = v108;
          uint64_t v50 = v107;
          if (v108 != v107)
          {
            do
            {
              uint64_t v52 = (void *)*--v49;
              long long v51 = v52;
              void *v49 = 0;
              if (v52) {
                operator delete[](v51);
              }
            }
            while (v49 != v48);
            uint64_t v50 = v107;
          }
          BOOL v108 = v48;
          operator delete(v50);
        }
        if (v103 != (int *)v106) {
          free(v103);
        }
      }
      goto LABEL_52;
    }
    if (*(_WORD *)v89 == 20033 && *(unsigned char *)(v89 + 2) == 69)
    {
      unsigned int v53 = 0;
    }
    else if (*(_WORD *)v89 == 20551 && *(unsigned char *)(v89 + 2) == 85)
    {
      unsigned int v53 = 1;
    }
    else
    {
      if (*(_WORD *)v89 != 20547 || *(unsigned char *)(v89 + 2) != 85) {
        goto LABEL_16;
      }
      unsigned int v53 = 2;
    }
    if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
    {
      uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v87[0] = v53;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v102[0] = &mlir::detail::TypeIDResolver<mlir::mps::DeviceHintAttr,void>::id;
      v102[1] = Context;
      return mlir::StorageUniquer::get<mlir::mps::detail::DeviceHintAttrStorage,mlir::mps::DeviceHint>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail21DeviceHintAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_14DeviceHintAttrEJNS2_10DeviceHintEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v102, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::DeviceHintAttr,void>::id, v87);
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::DeviceHintAttr::print(mlir::mps::DeviceHintAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) != v5)
  {
    unsigned char *v5 = 60;
    ++*((void *)v4 + 4);
    int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6) {
      goto LABEL_3;
    }
LABEL_11:
    BOOL v7 = 0;
    long long v9 = "ANE";
LABEL_13:
    size_t v8 = 3;
    goto LABEL_14;
  }
  llvm::raw_ostream::write(v4, "<", 1uLL);
  int v6 = *(_DWORD *)(*(void *)this + 8);
  if (!v6) {
    goto LABEL_11;
  }
LABEL_3:
  if (v6 == 2)
  {
    BOOL v7 = 0;
    long long v9 = "CPU";
    goto LABEL_13;
  }
  BOOL v7 = v6 != 1;
  if (v6 == 1) {
    size_t v8 = 3;
  }
  else {
    size_t v8 = 0;
  }
  if (v6 == 1) {
    long long v9 = "GPU";
  }
  else {
    long long v9 = "";
  }
LABEL_14:
  uint64_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v11 = (void *)*((void *)v10 + 4);
  if (v8 <= *((void *)v10 + 3) - (void)v11)
  {
    if (!v7)
    {
      memcpy(v11, v9, v8);
      *((void *)v10 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v9, v8);
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    unsigned char *v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::ScatterModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::ScatterModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::ScatterModeAttrStorage,mlir::mps::ScatterMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail22ScatterModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_15ScatterModeAttrEJNS2_11ScatterModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ScatterModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::ScatterModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v176 = *MEMORY[0x1E4F143B8];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1)) {
    return 0;
  }
  uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  uint64_t v153 = 0;
  uint64_t v154 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v153))
  {
LABEL_57:
    uint64_t v95 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    LOWORD(v168) = 259;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v158, a1, v95, v166);
    if (v158[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v158);
    }
    if (v165)
    {
      uint64_t v96 = (void **)__p;
      if (__p)
      {
        unint64_t v97 = v164;
        BOOL v98 = __p;
        if (v164 != __p)
        {
          do
            unint64_t v97 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v97 - 1);
          while (v97 != v96);
          BOOL v98 = __p;
        }
        BOOL v164 = v96;
        operator delete(v98);
      }
      unint64_t v99 = v161;
      if (v161)
      {
        BOOL v100 = v162;
        char v101 = v161;
        if (v162 != v161)
        {
          do
          {
            unint64_t v103 = (void *)*--v100;
            BOOL v102 = v103;
            *BOOL v100 = 0;
            if (v103) {
              operator delete[](v102);
            }
          }
          while (v100 != v99);
          char v101 = v161;
        }
        BOOL v162 = v99;
        operator delete(v101);
      }
      if (v159 != &v160) {
        free(v159);
      }
    }
    return 0;
  }
  uint64_t v3 = mlir::mps::symbolizeScatterMode(v153, v154);
  if ((v3 & 0xFF00000000) == 0)
  {
    __int16 v152 = 257;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v166, a1, v2, v151);
    if (v166[0])
    {
      int v155 = 3;
      BOOL v156 = "expected ";
      uint64_t v157 = 9;
      size_t v8 = &v155;
      long long v9 = v167;
      if (v168 >= v169)
      {
        unint64_t v104 = v168 + 1;
        if (v167 <= &v155 && &v167[6 * v168] > &v155)
        {
          int64_t v135 = (char *)&v155 - (char *)v167;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v104, 24);
          long long v9 = v167;
          size_t v8 = (int *)((char *)v167 + v135);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v104, 24);
          size_t v8 = &v155;
          long long v9 = v167;
        }
      }
      uint64_t v10 = &v9[6 * v168];
      long long v11 = *(_OWORD *)v8;
      *((void *)v10 + 2) = *((void *)v8 + 2);
      *(_OWORD *)uint64_t v10 = v11;
      uint64_t v12 = ++v168;
      if (v166[0])
      {
        int v155 = 3;
        BOOL v156 = "::mlir::mps::ScatterMode";
        uint64_t v157 = 24;
        uint64_t v13 = &v155;
        long long v14 = v167;
        if (v12 >= v169)
        {
          unint64_t v105 = v12 + 1;
          BOOL v106 = &v167[6 * v12] > &v155;
          if (v167 <= &v155 && v106)
          {
            int64_t v136 = (char *)&v155 - (char *)v167;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v105, 24);
            long long v14 = v167;
            uint64_t v13 = (int *)((char *)v167 + v136);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v105, 24);
            uint64_t v13 = &v155;
            long long v14 = v167;
          }
        }
        uint64_t v15 = &v14[6 * v168];
        long long v16 = *(_OWORD *)v13;
        *((void *)v15 + 2) = *((void *)v13 + 2);
        *(_OWORD *)uint64_t v15 = v16;
        uint64_t v17 = ++v168;
        if (v166[0])
        {
          int v155 = 3;
          BOOL v156 = " to be one of: ";
          uint64_t v157 = 15;
          uint64_t v18 = &v155;
          long long v19 = v167;
          if (v17 >= v169)
          {
            unint64_t v107 = v17 + 1;
            BOOL v108 = &v167[6 * v17] > &v155;
            if (v167 <= &v155 && v108)
            {
              int64_t v137 = (char *)&v155 - (char *)v167;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v107, 24);
              long long v19 = v167;
              uint64_t v18 = (int *)((char *)v167 + v137);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v107, 24);
              uint64_t v18 = &v155;
              long long v19 = v167;
            }
          }
          uint64_t v20 = &v19[6 * v168];
          long long v21 = *(_OWORD *)v18;
          *((void *)v20 + 2) = *((void *)v18 + 2);
          *(_OWORD *)uint64_t v20 = v21;
          uint64_t v22 = ++v168;
          if (v166[0])
          {
            int v155 = 3;
            BOOL v156 = "add";
            uint64_t v157 = 3;
            uint64_t v23 = &v155;
            long long v24 = v167;
            if (v22 >= v169)
            {
              unint64_t v109 = v22 + 1;
              BOOL v110 = &v167[6 * v22] > &v155;
              if (v167 <= &v155 && v110)
              {
                int64_t v138 = (char *)&v155 - (char *)v167;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v109, 24);
                long long v24 = v167;
                uint64_t v23 = (int *)((char *)v167 + v138);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v109, 24);
                uint64_t v23 = &v155;
                long long v24 = v167;
              }
            }
            uint64_t v25 = &v24[6 * v168];
            long long v26 = *(_OWORD *)v23;
            *((void *)v25 + 2) = *((void *)v23 + 2);
            *(_OWORD *)uint64_t v25 = v26;
            uint64_t v27 = ++v168;
            if (v166[0])
            {
              int v155 = 3;
              BOOL v156 = ", ";
              uint64_t v157 = 2;
              uint64_t v28 = &v155;
              long long v29 = v167;
              if (v27 >= v169)
              {
                unint64_t v111 = v27 + 1;
                BOOL v112 = &v167[6 * v27] > &v155;
                if (v167 <= &v155 && v112)
                {
                  int64_t v139 = (char *)&v155 - (char *)v167;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v111, 24);
                  long long v29 = v167;
                  uint64_t v28 = (int *)((char *)v167 + v139);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v111, 24);
                  uint64_t v28 = &v155;
                  long long v29 = v167;
                }
              }
              uint64_t v30 = &v29[6 * v168];
              long long v31 = *(_OWORD *)v28;
              *((void *)v30 + 2) = *((void *)v28 + 2);
              *(_OWORD *)uint64_t v30 = v31;
              uint64_t v32 = ++v168;
              if (v166[0])
              {
                int v155 = 3;
                BOOL v156 = "subtract";
                uint64_t v157 = 8;
                uint64_t v33 = &v155;
                long long v34 = v167;
                if (v32 >= v169)
                {
                  unint64_t v113 = v32 + 1;
                  BOOL v114 = &v167[6 * v32] > &v155;
                  if (v167 <= &v155 && v114)
                  {
                    int64_t v140 = (char *)&v155 - (char *)v167;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v113, 24);
                    long long v34 = v167;
                    uint64_t v33 = (int *)((char *)v167 + v140);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v113, 24);
                    uint64_t v33 = &v155;
                    long long v34 = v167;
                  }
                }
                uint64_t v35 = &v34[6 * v168];
                long long v36 = *(_OWORD *)v33;
                *((void *)v35 + 2) = *((void *)v33 + 2);
                *(_OWORD *)uint64_t v35 = v36;
                uint64_t v37 = ++v168;
                if (v166[0])
                {
                  int v155 = 3;
                  BOOL v156 = ", ";
                  uint64_t v157 = 2;
                  uint64_t v38 = &v155;
                  long long v39 = v167;
                  if (v37 >= v169)
                  {
                    unint64_t v115 = v37 + 1;
                    BOOL v116 = &v167[6 * v37] > &v155;
                    if (v167 <= &v155 && v116)
                    {
                      int64_t v141 = (char *)&v155 - (char *)v167;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v115, 24);
                      long long v39 = v167;
                      uint64_t v38 = (int *)((char *)v167 + v141);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v115, 24);
                      uint64_t v38 = &v155;
                      long long v39 = v167;
                    }
                  }
                  uint64_t v40 = &v39[6 * v168];
                  long long v41 = *(_OWORD *)v38;
                  *((void *)v40 + 2) = *((void *)v38 + 2);
                  *(_OWORD *)uint64_t v40 = v41;
                  uint64_t v42 = ++v168;
                  if (v166[0])
                  {
                    int v155 = 3;
                    BOOL v156 = "multiply";
                    uint64_t v157 = 8;
                    uint64_t v43 = &v155;
                    long long v44 = v167;
                    if (v42 >= v169)
                    {
                      unint64_t v117 = v42 + 1;
                      BOOL v118 = &v167[6 * v42] > &v155;
                      if (v167 <= &v155 && v118)
                      {
                        int64_t v142 = (char *)&v155 - (char *)v167;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v117, 24);
                        long long v44 = v167;
                        uint64_t v43 = (int *)((char *)v167 + v142);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v117, 24);
                        uint64_t v43 = &v155;
                        long long v44 = v167;
                      }
                    }
                    unsigned int v45 = &v44[6 * v168];
                    long long v46 = *(_OWORD *)v43;
                    *((void *)v45 + 2) = *((void *)v43 + 2);
                    *(_OWORD *)unsigned int v45 = v46;
                    uint64_t v47 = ++v168;
                    if (v166[0])
                    {
                      int v155 = 3;
                      BOOL v156 = ", ";
                      uint64_t v157 = 2;
                      uint64_t v48 = &v155;
                      uint64_t v49 = v167;
                      if (v47 >= v169)
                      {
                        unint64_t v119 = v47 + 1;
                        BOOL v120 = &v167[6 * v47] > &v155;
                        if (v167 <= &v155 && v120)
                        {
                          int64_t v143 = (char *)&v155 - (char *)v167;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v119, 24);
                          uint64_t v49 = v167;
                          uint64_t v48 = (int *)((char *)v167 + v143);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v119, 24);
                          uint64_t v48 = &v155;
                          uint64_t v49 = v167;
                        }
                      }
                      uint64_t v50 = &v49[6 * v168];
                      long long v51 = *(_OWORD *)v48;
                      *((void *)v50 + 2) = *((void *)v48 + 2);
                      *(_OWORD *)uint64_t v50 = v51;
                      uint64_t v52 = ++v168;
                      if (v166[0])
                      {
                        int v155 = 3;
                        BOOL v156 = "divide";
                        uint64_t v157 = 6;
                        unsigned int v53 = &v155;
                        uint64_t v54 = v167;
                        if (v52 >= v169)
                        {
                          unint64_t v121 = v52 + 1;
                          BOOL v122 = &v167[6 * v52] > &v155;
                          if (v167 <= &v155 && v122)
                          {
                            int64_t v144 = (char *)&v155 - (char *)v167;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v121, 24);
                            uint64_t v54 = v167;
                            unsigned int v53 = (int *)((char *)v167 + v144);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v121, 24);
                            unsigned int v53 = &v155;
                            uint64_t v54 = v167;
                          }
                        }
                        uint64_t v55 = &v54[6 * v168];
                        long long v56 = *(_OWORD *)v53;
                        *((void *)v55 + 2) = *((void *)v53 + 2);
                        *(_OWORD *)uint64_t v55 = v56;
                        uint64_t v57 = ++v168;
                        if (v166[0])
                        {
                          int v155 = 3;
                          BOOL v156 = ", ";
                          uint64_t v157 = 2;
                          uint64_t v58 = &v155;
                          unint64_t v59 = v167;
                          if (v57 >= v169)
                          {
                            unint64_t v123 = v57 + 1;
                            BOOL v124 = &v167[6 * v57] > &v155;
                            if (v167 <= &v155 && v124)
                            {
                              int64_t v145 = (char *)&v155 - (char *)v167;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v123, 24);
                              unint64_t v59 = v167;
                              uint64_t v58 = (int *)((char *)v167 + v145);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v123, 24);
                              uint64_t v58 = &v155;
                              unint64_t v59 = v167;
                            }
                          }
                          uint64_t v60 = &v59[6 * v168];
                          long long v61 = *(_OWORD *)v58;
                          *((void *)v60 + 2) = *((void *)v58 + 2);
                          *(_OWORD *)uint64_t v60 = v61;
                          uint64_t v62 = ++v168;
                          if (v166[0])
                          {
                            int v155 = 3;
                            BOOL v156 = "min";
                            uint64_t v157 = 3;
                            uint64_t v63 = &v155;
                            uint64_t v64 = v167;
                            if (v62 >= v169)
                            {
                              unint64_t v125 = v62 + 1;
                              BOOL v126 = &v167[6 * v62] > &v155;
                              if (v167 <= &v155 && v126)
                              {
                                int64_t v146 = (char *)&v155 - (char *)v167;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v125, 24);
                                uint64_t v64 = v167;
                                uint64_t v63 = (int *)((char *)v167 + v146);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v125, 24);
                                uint64_t v63 = &v155;
                                uint64_t v64 = v167;
                              }
                            }
                            char v65 = &v64[6 * v168];
                            long long v66 = *(_OWORD *)v63;
                            *((void *)v65 + 2) = *((void *)v63 + 2);
                            *(_OWORD *)char v65 = v66;
                            uint64_t v67 = ++v168;
                            if (v166[0])
                            {
                              int v155 = 3;
                              BOOL v156 = ", ";
                              uint64_t v157 = 2;
                              BOOL v68 = &v155;
                              unint64_t v69 = v167;
                              if (v67 >= v169)
                              {
                                unint64_t v127 = v67 + 1;
                                BOOL v128 = &v167[6 * v67] > &v155;
                                if (v167 <= &v155 && v128)
                                {
                                  int64_t v147 = (char *)&v155 - (char *)v167;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v127, 24);
                                  unint64_t v69 = v167;
                                  BOOL v68 = (int *)((char *)v167 + v147);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v127, 24);
                                  BOOL v68 = &v155;
                                  unint64_t v69 = v167;
                                }
                              }
                              BOOL v70 = &v69[6 * v168];
                              long long v71 = *(_OWORD *)v68;
                              *((void *)v70 + 2) = *((void *)v68 + 2);
                              *(_OWORD *)BOOL v70 = v71;
                              uint64_t v72 = ++v168;
                              if (v166[0])
                              {
                                int v155 = 3;
                                BOOL v156 = "max";
                                uint64_t v157 = 3;
                                unint64_t v73 = &v155;
                                unint64_t v74 = v167;
                                if (v72 >= v169)
                                {
                                  unint64_t v129 = v72 + 1;
                                  BOOL v130 = &v167[6 * v72] > &v155;
                                  if (v167 <= &v155 && v130)
                                  {
                                    int64_t v148 = (char *)&v155 - (char *)v167;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v129, 24);
                                    unint64_t v74 = v167;
                                    unint64_t v73 = (int *)((char *)v167 + v148);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v129, 24);
                                    unint64_t v73 = &v155;
                                    unint64_t v74 = v167;
                                  }
                                }
                                unint64_t v75 = &v74[6 * v168];
                                long long v76 = *(_OWORD *)v73;
                                *((void *)v75 + 2) = *((void *)v73 + 2);
                                *(_OWORD *)unint64_t v75 = v76;
                                uint64_t v77 = ++v168;
                                if (v166[0])
                                {
                                  int v155 = 3;
                                  BOOL v156 = ", ";
                                  uint64_t v157 = 2;
                                  BOOL v78 = &v155;
                                  int64_t v79 = v167;
                                  if (v77 >= v169)
                                  {
                                    unint64_t v131 = v77 + 1;
                                    BOOL v132 = &v167[6 * v77] > &v155;
                                    if (v167 <= &v155 && v132)
                                    {
                                      int64_t v149 = (char *)&v155 - (char *)v167;
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v131, 24);
                                      int64_t v79 = v167;
                                      BOOL v78 = (int *)((char *)v167 + v149);
                                    }
                                    else
                                    {
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v131, 24);
                                      BOOL v78 = &v155;
                                      int64_t v79 = v167;
                                    }
                                  }
                                  int64_t v80 = &v79[6 * v168];
                                  long long v81 = *(_OWORD *)v78;
                                  *((void *)v80 + 2) = *((void *)v78 + 2);
                                  *(_OWORD *)int64_t v80 = v81;
                                  uint64_t v82 = ++v168;
                                  if (v166[0])
                                  {
                                    int v155 = 3;
                                    BOOL v156 = "set";
                                    uint64_t v157 = 3;
                                    int64_t v83 = &v155;
                                    int64_t v84 = v167;
                                    if (v82 >= v169)
                                    {
                                      unint64_t v133 = v82 + 1;
                                      BOOL v134 = &v167[6 * v82] > &v155;
                                      if (v167 <= &v155 && v134)
                                      {
                                        int64_t v150 = (char *)&v155 - (char *)v167;
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v133, 24);
                                        int64_t v84 = v167;
                                        int64_t v83 = (int *)((char *)v167 + v150);
                                      }
                                      else
                                      {
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v133, 24);
                                        int64_t v83 = &v155;
                                        int64_t v84 = v167;
                                      }
                                    }
                                    int64_t v85 = &v84[6 * v168];
                                    long long v86 = *(_OWORD *)v83;
                                    *((void *)v85 + 2) = *((void *)v83 + 2);
                                    *(_OWORD *)int64_t v85 = v86;
                                    ++v168;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v166);
    if (v166[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v166);
    }
    if (v175)
    {
      uint64_t v87 = v173;
      if (v173)
      {
        __int16 v88 = v174;
        uint64_t v89 = v173;
        if (v174 != v173)
        {
          do
            __int16 v88 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v88 - 1);
          while (v88 != v87);
          uint64_t v89 = v173;
        }
        BOOL v174 = v87;
        operator delete(v89);
      }
      uint64_t v90 = v171;
      if (v171)
      {
        int v91 = v172;
        uint64_t v92 = v171;
        if (v172 != v171)
        {
          do
          {
            unint64_t v94 = (void *)*--v91;
            uint64_t v93 = v94;
            *int v91 = 0;
            if (v94) {
              operator delete[](v93);
            }
          }
          while (v91 != v90);
          uint64_t v92 = v171;
        }
        BOOL v172 = v90;
        operator delete(v92);
      }
      if (v167 != (int *)v170) {
        free(v167);
      }
    }
    goto LABEL_57;
  }
  unsigned int v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v151[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v166[0] = &mlir::detail::TypeIDResolver<mlir::mps::ScatterModeAttr,void>::id;
    v166[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::ScatterModeAttrStorage,mlir::mps::ScatterMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail22ScatterModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_15ScatterModeAttrEJNS2_11ScatterModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v166, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ScatterModeAttr,void>::id, v151);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::ScatterModeAttr::print(mlir::mps::ScatterModeAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6 > 6)
    {
LABEL_6:
      size_t v9 = 0;
      size_t v8 = "";
      char v7 = 1;
      goto LABEL_13;
    }
  }
  else
  {
    unsigned char *v5 = 60;
    ++*((void *)v4 + 4);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
  }
  char v7 = 0;
  size_t v8 = "add";
  size_t v9 = 3;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      char v7 = 0;
      size_t v8 = "subtract";
      size_t v9 = 8;
      break;
    case 2u:
      char v7 = 0;
      size_t v8 = "multiply";
      size_t v9 = 8;
      break;
    case 3u:
      char v7 = 0;
      size_t v8 = "divide";
      size_t v9 = 6;
      break;
    case 4u:
      char v7 = 0;
      size_t v8 = "min";
      goto LABEL_12;
    case 5u:
      char v7 = 0;
      size_t v8 = "max";
      goto LABEL_12;
    case 6u:
      char v7 = 0;
      size_t v8 = "set";
LABEL_12:
      size_t v9 = 3;
      break;
    default:
      goto LABEL_6;
  }
LABEL_13:
  uint64_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v11 = (void *)*((void *)v10 + 4);
  if (v9 <= *((void *)v10 + 3) - (void)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((void *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    unsigned char *v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::PaddingModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::PaddingModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::PaddingModeAttrStorage,mlir::mps::PaddingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail22PaddingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_15PaddingModeAttrEJNS2_11PaddingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::PaddingModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v126 = *MEMORY[0x1E4F143B8];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1)) {
    return 0;
  }
  uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  uint64_t v103 = 0;
  uint64_t v104 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v103))
  {
LABEL_61:
    uint64_t v64 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    LOWORD(v118) = 259;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v108, a1, v64, v116);
    if (v108[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v108);
    }
    if (v115)
    {
      char v65 = (void **)__p;
      if (__p)
      {
        long long v66 = v114;
        uint64_t v67 = __p;
        if (v114 != __p)
        {
          do
            long long v66 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v66 - 1);
          while (v66 != v65);
          uint64_t v67 = __p;
        }
        BOOL v114 = v65;
        operator delete(v67);
      }
      BOOL v68 = v111;
      if (v111)
      {
        unint64_t v69 = v112;
        BOOL v70 = v111;
        if (v112 != v111)
        {
          do
          {
            uint64_t v72 = (void *)*--v69;
            long long v71 = v72;
            *unint64_t v69 = 0;
            if (v72) {
              operator delete[](v71);
            }
          }
          while (v69 != v68);
          BOOL v70 = v111;
        }
        BOOL v112 = v68;
        operator delete(v70);
      }
      if (v109 != &v110) {
        free(v109);
      }
    }
    return 0;
  }
  switch(v104)
  {
    case 7:
      if (*(_DWORD *)v103 != 1818649970 || *(_DWORD *)(v103 + 3) != 1952671084) {
        goto LABEL_22;
      }
      unsigned int v4 = 1;
      goto LABEL_82;
    case 8:
      if (*(void *)v103 != 0x746E6174736E6F63) {
        goto LABEL_22;
      }
      unsigned int v4 = 0;
      goto LABEL_82;
    case 9:
      if (*(void *)v103 != 0x697274656D6D7973 || *(unsigned char *)(v103 + 8) != 99) {
        goto LABEL_22;
      }
      unsigned int v4 = 2;
      goto LABEL_82;
    case 11:
      if (*(void *)v103 != 0x456F54706D616C63 || *(void *)(v103 + 3) != 0x656764456F54706DLL) {
        goto LABEL_22;
      }
      unsigned int v4 = 3;
LABEL_82:
      if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1)) {
        return 0;
      }
      uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v101[0] = v4;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v116[0] = &mlir::detail::TypeIDResolver<mlir::mps::PaddingModeAttr,void>::id;
      v116[1] = Context;
      uint64_t result = mlir::StorageUniquer::get<mlir::mps::detail::PaddingModeAttrStorage,mlir::mps::PaddingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail22PaddingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_15PaddingModeAttrEJNS2_11PaddingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v116, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingModeAttr,void>::id, v101);
      break;
    default:
LABEL_22:
      __int16 v102 = 257;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v116, a1, v2, v101);
      if (v116[0])
      {
        int v105 = 3;
        BOOL v106 = "expected ";
        uint64_t v107 = 9;
        char v7 = &v105;
        size_t v8 = v117;
        if (v118 >= v119)
        {
          unint64_t v76 = v118 + 1;
          if (v117 <= &v105 && &v117[6 * v118] > &v105)
          {
            int64_t v91 = (char *)&v105 - (char *)v117;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v76, 24);
            size_t v8 = v117;
            char v7 = (int *)((char *)v117 + v91);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v76, 24);
            char v7 = &v105;
            size_t v8 = v117;
          }
        }
        size_t v9 = &v8[6 * v118];
        long long v10 = *(_OWORD *)v7;
        *((void *)v9 + 2) = *((void *)v7 + 2);
        *(_OWORD *)size_t v9 = v10;
        uint64_t v11 = ++v118;
        if (v116[0])
        {
          int v105 = 3;
          BOOL v106 = "::mlir::mps::PaddingMode";
          uint64_t v107 = 24;
          uint64_t v12 = &v105;
          uint64_t v13 = v117;
          if (v11 >= v119)
          {
            unint64_t v77 = v11 + 1;
            BOOL v78 = &v117[6 * v11] > &v105;
            if (v117 <= &v105 && v78)
            {
              int64_t v92 = (char *)&v105 - (char *)v117;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v77, 24);
              uint64_t v13 = v117;
              uint64_t v12 = (int *)((char *)v117 + v92);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v77, 24);
              uint64_t v12 = &v105;
              uint64_t v13 = v117;
            }
          }
          long long v14 = &v13[6 * v118];
          long long v15 = *(_OWORD *)v12;
          *((void *)v14 + 2) = *((void *)v12 + 2);
          *(_OWORD *)long long v14 = v15;
          uint64_t v16 = ++v118;
          if (v116[0])
          {
            int v105 = 3;
            BOOL v106 = " to be one of: ";
            uint64_t v107 = 15;
            uint64_t v17 = &v105;
            uint64_t v18 = v117;
            if (v16 >= v119)
            {
              unint64_t v79 = v16 + 1;
              BOOL v80 = &v117[6 * v16] > &v105;
              if (v117 <= &v105 && v80)
              {
                int64_t v93 = (char *)&v105 - (char *)v117;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v79, 24);
                uint64_t v18 = v117;
                uint64_t v17 = (int *)((char *)v117 + v93);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v79, 24);
                uint64_t v17 = &v105;
                uint64_t v18 = v117;
              }
            }
            long long v19 = &v18[6 * v118];
            long long v20 = *(_OWORD *)v17;
            *((void *)v19 + 2) = *((void *)v17 + 2);
            *(_OWORD *)long long v19 = v20;
            uint64_t v21 = ++v118;
            if (v116[0])
            {
              int v105 = 3;
              BOOL v106 = "constant";
              uint64_t v107 = 8;
              uint64_t v22 = &v105;
              uint64_t v23 = v117;
              if (v21 >= v119)
              {
                unint64_t v81 = v21 + 1;
                BOOL v82 = &v117[6 * v21] > &v105;
                if (v117 <= &v105 && v82)
                {
                  int64_t v94 = (char *)&v105 - (char *)v117;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v81, 24);
                  uint64_t v23 = v117;
                  uint64_t v22 = (int *)((char *)v117 + v94);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v81, 24);
                  uint64_t v22 = &v105;
                  uint64_t v23 = v117;
                }
              }
              long long v24 = &v23[6 * v118];
              long long v25 = *(_OWORD *)v22;
              *((void *)v24 + 2) = *((void *)v22 + 2);
              *(_OWORD *)long long v24 = v25;
              uint64_t v26 = ++v118;
              if (v116[0])
              {
                int v105 = 3;
                BOOL v106 = ", ";
                uint64_t v107 = 2;
                uint64_t v27 = &v105;
                uint64_t v28 = v117;
                if (v26 >= v119)
                {
                  unint64_t v83 = v26 + 1;
                  if (v117 <= &v105 && &v117[6 * v26] > &v105)
                  {
                    int64_t v95 = (char *)&v105 - (char *)v117;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v83, 24);
                    uint64_t v28 = v117;
                    uint64_t v27 = (int *)((char *)v117 + v95);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v83, 24);
                    uint64_t v27 = &v105;
                    uint64_t v28 = v117;
                  }
                }
                long long v29 = &v28[6 * v118];
                long long v30 = *(_OWORD *)v27;
                *((void *)v29 + 2) = *((void *)v27 + 2);
                *(_OWORD *)long long v29 = v30;
                uint64_t v31 = ++v118;
                if (v116[0])
                {
                  int v105 = 3;
                  BOOL v106 = "reflect";
                  uint64_t v107 = 7;
                  uint64_t v32 = &v105;
                  uint64_t v33 = v117;
                  if (v31 >= v119)
                  {
                    unint64_t v84 = v31 + 1;
                    if (v117 <= &v105 && &v117[6 * v31] > &v105)
                    {
                      int64_t v96 = (char *)&v105 - (char *)v117;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v84, 24);
                      uint64_t v33 = v117;
                      uint64_t v32 = (int *)((char *)v117 + v96);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v84, 24);
                      uint64_t v32 = &v105;
                      uint64_t v33 = v117;
                    }
                  }
                  long long v34 = &v33[6 * v118];
                  long long v35 = *(_OWORD *)v32;
                  *((void *)v34 + 2) = *((void *)v32 + 2);
                  *(_OWORD *)long long v34 = v35;
                  uint64_t v36 = ++v118;
                  if (v116[0])
                  {
                    int v105 = 3;
                    BOOL v106 = ", ";
                    uint64_t v107 = 2;
                    uint64_t v37 = &v105;
                    uint64_t v38 = v117;
                    if (v36 >= v119)
                    {
                      unint64_t v85 = v36 + 1;
                      if (v117 <= &v105 && &v117[6 * v36] > &v105)
                      {
                        int64_t v97 = (char *)&v105 - (char *)v117;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v85, 24);
                        uint64_t v38 = v117;
                        uint64_t v37 = (int *)((char *)v117 + v97);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v85, 24);
                        uint64_t v37 = &v105;
                        uint64_t v38 = v117;
                      }
                    }
                    long long v39 = &v38[6 * v118];
                    long long v40 = *(_OWORD *)v37;
                    *((void *)v39 + 2) = *((void *)v37 + 2);
                    *(_OWORD *)long long v39 = v40;
                    uint64_t v41 = ++v118;
                    if (v116[0])
                    {
                      int v105 = 3;
                      BOOL v106 = "symmetric";
                      uint64_t v107 = 9;
                      uint64_t v42 = &v105;
                      uint64_t v43 = v117;
                      if (v41 >= v119)
                      {
                        unint64_t v86 = v41 + 1;
                        if (v117 <= &v105 && &v117[6 * v41] > &v105)
                        {
                          int64_t v98 = (char *)&v105 - (char *)v117;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v86, 24);
                          uint64_t v43 = v117;
                          uint64_t v42 = (int *)((char *)v117 + v98);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v86, 24);
                          uint64_t v42 = &v105;
                          uint64_t v43 = v117;
                        }
                      }
                      long long v44 = &v43[6 * v118];
                      long long v45 = *(_OWORD *)v42;
                      *((void *)v44 + 2) = *((void *)v42 + 2);
                      *(_OWORD *)long long v44 = v45;
                      uint64_t v46 = ++v118;
                      if (v116[0])
                      {
                        int v105 = 3;
                        BOOL v106 = ", ";
                        uint64_t v107 = 2;
                        uint64_t v47 = &v105;
                        uint64_t v48 = v117;
                        if (v46 >= v119)
                        {
                          unint64_t v87 = v46 + 1;
                          BOOL v88 = &v117[6 * v46] > &v105;
                          if (v117 <= &v105 && v88)
                          {
                            int64_t v99 = (char *)&v105 - (char *)v117;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v87, 24);
                            uint64_t v48 = v117;
                            uint64_t v47 = (int *)((char *)v117 + v99);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v87, 24);
                            uint64_t v47 = &v105;
                            uint64_t v48 = v117;
                          }
                        }
                        uint64_t v49 = &v48[6 * v118];
                        long long v50 = *(_OWORD *)v47;
                        *((void *)v49 + 2) = *((void *)v47 + 2);
                        *(_OWORD *)uint64_t v49 = v50;
                        uint64_t v51 = ++v118;
                        if (v116[0])
                        {
                          int v105 = 3;
                          BOOL v106 = "clampToEdge";
                          uint64_t v107 = 11;
                          uint64_t v52 = &v105;
                          unsigned int v53 = v117;
                          if (v51 >= v119)
                          {
                            unint64_t v89 = v51 + 1;
                            BOOL v90 = &v117[6 * v51] > &v105;
                            if (v117 <= &v105 && v90)
                            {
                              int64_t v100 = (char *)&v105 - (char *)v117;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v89, 24);
                              unsigned int v53 = v117;
                              uint64_t v52 = (int *)((char *)v117 + v100);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v89, 24);
                              uint64_t v52 = &v105;
                              unsigned int v53 = v117;
                            }
                          }
                          uint64_t v54 = &v53[6 * v118];
                          long long v55 = *(_OWORD *)v52;
                          *((void *)v54 + 2) = *((void *)v52 + 2);
                          *(_OWORD *)uint64_t v54 = v55;
                          ++v118;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v116);
      if (v116[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v116);
      }
      if (v125)
      {
        long long v56 = v123;
        if (v123)
        {
          uint64_t v57 = v124;
          uint64_t v58 = v123;
          if (v124 != v123)
          {
            do
              uint64_t v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
            while (v57 != v56);
            uint64_t v58 = v123;
          }
          BOOL v124 = v56;
          operator delete(v58);
        }
        unint64_t v59 = v121;
        if (v121)
        {
          uint64_t v60 = v122;
          long long v61 = v121;
          if (v122 != v121)
          {
            do
            {
              uint64_t v63 = (void *)*--v60;
              uint64_t v62 = v63;
              void *v60 = 0;
              if (v63) {
                operator delete[](v62);
              }
            }
            while (v60 != v59);
            long long v61 = v121;
          }
          BOOL v122 = v59;
          operator delete(v61);
        }
        if (v117 != (int *)v120) {
          free(v117);
        }
      }
      goto LABEL_61;
  }
  return result;
}

llvm::raw_ostream *mlir::mps::PaddingModeAttr::print(mlir::mps::PaddingModeAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6 > 3)
    {
LABEL_6:
      size_t v9 = 0;
      size_t v8 = "";
      char v7 = 1;
      goto LABEL_9;
    }
  }
  else
  {
    unsigned char *v5 = 60;
    ++*((void *)v4 + 4);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
  }
  char v7 = 0;
  size_t v8 = "constant";
  size_t v9 = 8;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      char v7 = 0;
      size_t v8 = "reflect";
      size_t v9 = 7;
      break;
    case 2u:
      char v7 = 0;
      size_t v8 = "symmetric";
      size_t v9 = 9;
      break;
    case 3u:
      char v7 = 0;
      size_t v8 = "clampToEdge";
      size_t v9 = 11;
      break;
    default:
      goto LABEL_6;
  }
LABEL_9:
  long long v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v11 = (void *)*((void *)v10 + 4);
  if (v9 <= *((void *)v10 + 3) - (void)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((void *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    unsigned char *v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::SamplingModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::SamplingModeAttrStorage,mlir::mps::SamplingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23SamplingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16SamplingModeAttrEJNS2_12SamplingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::SamplingModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v96 = *MEMORY[0x1E4F143B8];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1))
  {
    uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    uint64_t v73 = 0;
    uint64_t v74 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v73))
    {
LABEL_43:
      uint64_t v42 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
      LOWORD(v88) = 259;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v78, a1, v42, v86);
      if (v78[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v78);
      }
      if (v85)
      {
        uint64_t v43 = (void **)__p;
        if (__p)
        {
          long long v44 = v84;
          long long v45 = __p;
          if (v84 != __p)
          {
            do
              long long v44 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v44 - 1);
            while (v44 != v43);
            long long v45 = __p;
          }
          unint64_t v84 = v43;
          operator delete(v45);
        }
        uint64_t v46 = v81;
        if (v81)
        {
          uint64_t v47 = v82;
          uint64_t v48 = v81;
          if (v82 != v81)
          {
            do
            {
              long long v50 = (void *)*--v47;
              uint64_t v49 = v50;
              void *v47 = 0;
              if (v50) {
                operator delete[](v49);
              }
            }
            while (v47 != v46);
            uint64_t v48 = v81;
          }
          BOOL v82 = v46;
          operator delete(v48);
        }
        if (v79 != &v80) {
          free(v79);
        }
      }
      return 0;
    }
    if (v74 == 8)
    {
      if (*(void *)v73 != 0x7261656E696C6962)
      {
LABEL_12:
        __int16 v72 = 257;
        (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v86, a1, v2, v71);
        if (v86[0])
        {
          int v75 = 3;
          unint64_t v76 = "expected ";
          uint64_t v77 = 9;
          unsigned int v5 = &v75;
          unsigned int v6 = v87;
          if (v88 >= v89)
          {
            unint64_t v54 = v88 + 1;
            if (v87 <= &v75 && &v87[6 * v88] > &v75)
            {
              int64_t v65 = (char *)&v75 - (char *)v87;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v54, 24);
              unsigned int v6 = v87;
              unsigned int v5 = (int *)((char *)v87 + v65);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v54, 24);
              unsigned int v5 = &v75;
              unsigned int v6 = v87;
            }
          }
          char v7 = &v6[6 * v88];
          long long v8 = *(_OWORD *)v5;
          *((void *)v7 + 2) = *((void *)v5 + 2);
          *(_OWORD *)char v7 = v8;
          uint64_t v9 = ++v88;
          if (v86[0])
          {
            int v75 = 3;
            unint64_t v76 = "::mlir::mps::SamplingMode";
            uint64_t v77 = 25;
            long long v10 = &v75;
            uint64_t v11 = v87;
            if (v9 >= v89)
            {
              unint64_t v55 = v9 + 1;
              BOOL v56 = &v87[6 * v9] > &v75;
              if (v87 <= &v75 && v56)
              {
                int64_t v66 = (char *)&v75 - (char *)v87;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v55, 24);
                uint64_t v11 = v87;
                long long v10 = (int *)((char *)v87 + v66);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v55, 24);
                long long v10 = &v75;
                uint64_t v11 = v87;
              }
            }
            uint64_t v12 = &v11[6 * v88];
            long long v13 = *(_OWORD *)v10;
            *((void *)v12 + 2) = *((void *)v10 + 2);
            *(_OWORD *)uint64_t v12 = v13;
            uint64_t v14 = ++v88;
            if (v86[0])
            {
              int v75 = 3;
              unint64_t v76 = " to be one of: ";
              uint64_t v77 = 15;
              long long v15 = &v75;
              uint64_t v16 = v87;
              if (v14 >= v89)
              {
                unint64_t v57 = v14 + 1;
                BOOL v58 = &v87[6 * v14] > &v75;
                if (v87 <= &v75 && v58)
                {
                  int64_t v67 = (char *)&v75 - (char *)v87;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v57, 24);
                  uint64_t v16 = v87;
                  long long v15 = (int *)((char *)v87 + v67);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v57, 24);
                  long long v15 = &v75;
                  uint64_t v16 = v87;
                }
              }
              uint64_t v17 = &v16[6 * v88];
              long long v18 = *(_OWORD *)v15;
              *((void *)v17 + 2) = *((void *)v15 + 2);
              *(_OWORD *)uint64_t v17 = v18;
              uint64_t v19 = ++v88;
              if (v86[0])
              {
                int v75 = 3;
                unint64_t v76 = "nearest";
                uint64_t v77 = 7;
                long long v20 = &v75;
                uint64_t v21 = v87;
                if (v19 >= v89)
                {
                  unint64_t v59 = v19 + 1;
                  BOOL v60 = &v87[6 * v19] > &v75;
                  if (v87 <= &v75 && v60)
                  {
                    int64_t v68 = (char *)&v75 - (char *)v87;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v59, 24);
                    uint64_t v21 = v87;
                    long long v20 = (int *)((char *)v87 + v68);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v59, 24);
                    long long v20 = &v75;
                    uint64_t v21 = v87;
                  }
                }
                uint64_t v22 = &v21[6 * v88];
                long long v23 = *(_OWORD *)v20;
                *((void *)v22 + 2) = *((void *)v20 + 2);
                *(_OWORD *)uint64_t v22 = v23;
                uint64_t v24 = ++v88;
                if (v86[0])
                {
                  int v75 = 3;
                  unint64_t v76 = ", ";
                  uint64_t v77 = 2;
                  long long v25 = &v75;
                  uint64_t v26 = v87;
                  if (v24 >= v89)
                  {
                    unint64_t v61 = v24 + 1;
                    BOOL v62 = &v87[6 * v24] > &v75;
                    if (v87 <= &v75 && v62)
                    {
                      int64_t v69 = (char *)&v75 - (char *)v87;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v61, 24);
                      uint64_t v26 = v87;
                      long long v25 = (int *)((char *)v87 + v69);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v61, 24);
                      long long v25 = &v75;
                      uint64_t v26 = v87;
                    }
                  }
                  uint64_t v27 = &v26[6 * v88];
                  long long v28 = *(_OWORD *)v25;
                  *((void *)v27 + 2) = *((void *)v25 + 2);
                  *(_OWORD *)uint64_t v27 = v28;
                  uint64_t v29 = ++v88;
                  if (v86[0])
                  {
                    int v75 = 3;
                    unint64_t v76 = "bilinear";
                    uint64_t v77 = 8;
                    long long v30 = &v75;
                    uint64_t v31 = v87;
                    if (v29 >= v89)
                    {
                      unint64_t v63 = v29 + 1;
                      BOOL v64 = &v87[6 * v29] > &v75;
                      if (v87 <= &v75 && v64)
                      {
                        int64_t v70 = (char *)&v75 - (char *)v87;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v63, 24);
                        uint64_t v31 = v87;
                        long long v30 = (int *)((char *)v87 + v70);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v63, 24);
                        long long v30 = &v75;
                        uint64_t v31 = v87;
                      }
                    }
                    uint64_t v32 = &v31[6 * v88];
                    long long v33 = *(_OWORD *)v30;
                    *((void *)v32 + 2) = *((void *)v30 + 2);
                    *(_OWORD *)uint64_t v32 = v33;
                    ++v88;
                  }
                }
              }
            }
          }
        }
        mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v86);
        if (v86[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v86);
        }
        if (v95)
        {
          long long v34 = v93;
          if (v93)
          {
            long long v35 = v94;
            uint64_t v36 = v93;
            if (v94 != v93)
            {
              do
                long long v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
              while (v35 != v34);
              uint64_t v36 = v93;
            }
            int64_t v94 = v34;
            operator delete(v36);
          }
          uint64_t v37 = v91;
          if (v91)
          {
            uint64_t v38 = v92;
            long long v39 = v91;
            if (v92 != v91)
            {
              do
              {
                uint64_t v41 = (void *)*--v38;
                long long v40 = v41;
                void *v38 = 0;
                if (v41) {
                  operator delete[](v40);
                }
              }
              while (v38 != v37);
              long long v39 = v91;
            }
            int64_t v92 = v37;
            operator delete(v39);
          }
          if (v87 != (int *)v90) {
            free(v87);
          }
        }
        goto LABEL_43;
      }
      unsigned int v4 = 1;
    }
    else
    {
      if (v74 != 7) {
        goto LABEL_12;
      }
      if (*(_DWORD *)v73 != 1918985582 || *(_DWORD *)(v73 + 3) != 1953719666) {
        goto LABEL_12;
      }
      unsigned int v4 = 0;
    }
    if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
    {
      uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v71[0] = v4;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v86[0] = &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id;
      v86[1] = Context;
      return mlir::StorageUniquer::get<mlir::mps::detail::SamplingModeAttrStorage,mlir::mps::SamplingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23SamplingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16SamplingModeAttrEJNS2_12SamplingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v86, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id, v71);
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::SamplingModeAttr::print(mlir::mps::SamplingModeAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }
  else
  {
    unsigned char *v5 = 60;
    ++*((void *)v4 + 4);
  }
  int v6 = *(_DWORD *)(*(void *)this + 8);
  char v7 = "";
  uint64_t v8 = 8;
  if (v6 == 1) {
    char v7 = "bilinear";
  }
  else {
    uint64_t v8 = 0;
  }
  if (v6) {
    BOOL v9 = v6 != 1;
  }
  else {
    BOOL v9 = 0;
  }
  if (v6) {
    size_t v10 = v8;
  }
  else {
    size_t v10 = 7;
  }
  if (v6) {
    uint64_t v11 = v7;
  }
  else {
    uint64_t v11 = "nearest";
  }
  uint64_t v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (void *)*((void *)v12 + 4);
  if (v10 <= *((void *)v12 + 3) - (void)v13)
  {
    if (!v9)
    {
      memcpy(v13, v11, v10);
      *((void *)v12 + 4) += v10;
    }
  }
  else
  {
    llvm::raw_ostream::write(v12, v11, v10);
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v15 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v15)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    *long long v15 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::NearestRoundingModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::NearestRoundingModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::NearestRoundingModeAttrStorage,mlir::mps::NearestRoundingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail30NearestRoundingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_23NearestRoundingModeAttrEJNS2_19NearestRoundingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::NearestRoundingModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::NearestRoundingModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v160 = *MEMORY[0x1E4F143B8];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1)) {
    return 0;
  }
  uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  uint64_t v137 = 0;
  uint64_t v138 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v137))
  {
LABEL_53:
    uint64_t v85 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    LOWORD(v152) = 259;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v142, a1, v85, v150);
    if (v142[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v142);
    }
    if (v149)
    {
      unint64_t v86 = (void **)__p;
      if (__p)
      {
        unint64_t v87 = v148;
        unsigned int v88 = __p;
        if (v148 != __p)
        {
          do
            unint64_t v87 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v87 - 1);
          while (v87 != v86);
          unsigned int v88 = __p;
        }
        int64_t v148 = v86;
        operator delete(v88);
      }
      unsigned int v89 = v145;
      if (v145)
      {
        BOOL v90 = v146;
        int64_t v91 = v145;
        if (v146 != v145)
        {
          do
          {
            int64_t v93 = (void *)*--v90;
            int64_t v92 = v93;
            *BOOL v90 = 0;
            if (v93) {
              operator delete[](v92);
            }
          }
          while (v90 != v89);
          int64_t v91 = v145;
        }
        int64_t v146 = v89;
        operator delete(v91);
      }
      if (v143 != &v144) {
        free(v143);
      }
    }
    return 0;
  }
  uint64_t v3 = mlir::mps::symbolizeNearestRoundingMode(v137, v138);
  if ((v3 & 0xFF00000000) == 0)
  {
    __int16 v136 = 257;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v150, a1, v2, v135);
    if (v150[0])
    {
      int v139 = 3;
      int64_t v140 = "expected ";
      uint64_t v141 = 9;
      uint64_t v8 = &v139;
      BOOL v9 = v151;
      if (v152 >= v153)
      {
        unint64_t v94 = v152 + 1;
        if (v151 <= &v139 && &v151[6 * v152] > &v139)
        {
          int64_t v121 = (char *)&v139 - (char *)v151;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v94, 24);
          BOOL v9 = v151;
          uint64_t v8 = (int *)((char *)v151 + v121);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v94, 24);
          uint64_t v8 = &v139;
          BOOL v9 = v151;
        }
      }
      size_t v10 = &v9[6 * v152];
      long long v11 = *(_OWORD *)v8;
      *((void *)v10 + 2) = *((void *)v8 + 2);
      *(_OWORD *)size_t v10 = v11;
      uint64_t v12 = ++v152;
      if (v150[0])
      {
        int v139 = 3;
        int64_t v140 = "mlir::mps::NearestRoundingMode";
        uint64_t v141 = 30;
        long long v13 = &v139;
        uint64_t v14 = v151;
        if (v12 >= v153)
        {
          unint64_t v95 = v12 + 1;
          BOOL v96 = &v151[6 * v12] > &v139;
          if (v151 <= &v139 && v96)
          {
            int64_t v122 = (char *)&v139 - (char *)v151;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v95, 24);
            uint64_t v14 = v151;
            long long v13 = (int *)((char *)v151 + v122);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v95, 24);
            long long v13 = &v139;
            uint64_t v14 = v151;
          }
        }
        long long v15 = &v14[6 * v152];
        long long v16 = *(_OWORD *)v13;
        *((void *)v15 + 2) = *((void *)v13 + 2);
        *(_OWORD *)long long v15 = v16;
        uint64_t v17 = ++v152;
        if (v150[0])
        {
          int v139 = 3;
          int64_t v140 = " to be one of: ";
          uint64_t v141 = 15;
          long long v18 = &v139;
          uint64_t v19 = v151;
          if (v17 >= v153)
          {
            unint64_t v97 = v17 + 1;
            BOOL v98 = &v151[6 * v17] > &v139;
            if (v151 <= &v139 && v98)
            {
              int64_t v123 = (char *)&v139 - (char *)v151;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v97, 24);
              uint64_t v19 = v151;
              long long v18 = (int *)((char *)v151 + v123);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v97, 24);
              long long v18 = &v139;
              uint64_t v19 = v151;
            }
          }
          long long v20 = &v19[6 * v152];
          long long v21 = *(_OWORD *)v18;
          *((void *)v20 + 2) = *((void *)v18 + 2);
          *(_OWORD *)long long v20 = v21;
          uint64_t v22 = ++v152;
          if (v150[0])
          {
            int v139 = 3;
            int64_t v140 = "round_prefer_ceil";
            uint64_t v141 = 17;
            long long v23 = &v139;
            uint64_t v24 = v151;
            if (v22 >= v153)
            {
              unint64_t v99 = v22 + 1;
              BOOL v100 = &v151[6 * v22] > &v139;
              if (v151 <= &v139 && v100)
              {
                int64_t v124 = (char *)&v139 - (char *)v151;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v99, 24);
                uint64_t v24 = v151;
                long long v23 = (int *)((char *)v151 + v124);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v99, 24);
                long long v23 = &v139;
                uint64_t v24 = v151;
              }
            }
            long long v25 = &v24[6 * v152];
            long long v26 = *(_OWORD *)v23;
            *((void *)v25 + 2) = *((void *)v23 + 2);
            *(_OWORD *)long long v25 = v26;
            uint64_t v27 = ++v152;
            if (v150[0])
            {
              int v139 = 3;
              int64_t v140 = ", ";
              uint64_t v141 = 2;
              long long v28 = &v139;
              uint64_t v29 = v151;
              if (v27 >= v153)
              {
                unint64_t v101 = v27 + 1;
                BOOL v102 = &v151[6 * v27] > &v139;
                if (v151 <= &v139 && v102)
                {
                  int64_t v125 = (char *)&v139 - (char *)v151;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v101, 24);
                  uint64_t v29 = v151;
                  long long v28 = (int *)((char *)v151 + v125);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v101, 24);
                  long long v28 = &v139;
                  uint64_t v29 = v151;
                }
              }
              long long v30 = &v29[6 * v152];
              long long v31 = *(_OWORD *)v28;
              *((void *)v30 + 2) = *((void *)v28 + 2);
              *(_OWORD *)long long v30 = v31;
              uint64_t v32 = ++v152;
              if (v150[0])
              {
                int v139 = 3;
                int64_t v140 = "round_prefer_floor";
                uint64_t v141 = 18;
                long long v33 = &v139;
                long long v34 = v151;
                if (v32 >= v153)
                {
                  unint64_t v103 = v32 + 1;
                  BOOL v104 = &v151[6 * v32] > &v139;
                  if (v151 <= &v139 && v104)
                  {
                    int64_t v126 = (char *)&v139 - (char *)v151;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v103, 24);
                    long long v34 = v151;
                    long long v33 = (int *)((char *)v151 + v126);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v103, 24);
                    long long v33 = &v139;
                    long long v34 = v151;
                  }
                }
                long long v35 = &v34[6 * v152];
                long long v36 = *(_OWORD *)v33;
                *((void *)v35 + 2) = *((void *)v33 + 2);
                *(_OWORD *)long long v35 = v36;
                uint64_t v37 = ++v152;
                if (v150[0])
                {
                  int v139 = 3;
                  int64_t v140 = ", ";
                  uint64_t v141 = 2;
                  uint64_t v38 = &v139;
                  long long v39 = v151;
                  if (v37 >= v153)
                  {
                    unint64_t v105 = v37 + 1;
                    BOOL v106 = &v151[6 * v37] > &v139;
                    if (v151 <= &v139 && v106)
                    {
                      int64_t v127 = (char *)&v139 - (char *)v151;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v105, 24);
                      long long v39 = v151;
                      uint64_t v38 = (int *)((char *)v151 + v127);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v105, 24);
                      uint64_t v38 = &v139;
                      long long v39 = v151;
                    }
                  }
                  long long v40 = &v39[6 * v152];
                  long long v41 = *(_OWORD *)v38;
                  *((void *)v40 + 2) = *((void *)v38 + 2);
                  *(_OWORD *)long long v40 = v41;
                  uint64_t v42 = ++v152;
                  if (v150[0])
                  {
                    int v139 = 3;
                    int64_t v140 = "ceil";
                    uint64_t v141 = 4;
                    uint64_t v43 = &v139;
                    long long v44 = v151;
                    if (v42 >= v153)
                    {
                      unint64_t v107 = v42 + 1;
                      BOOL v108 = &v151[6 * v42] > &v139;
                      if (v151 <= &v139 && v108)
                      {
                        int64_t v128 = (char *)&v139 - (char *)v151;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v107, 24);
                        long long v44 = v151;
                        uint64_t v43 = (int *)((char *)v151 + v128);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v107, 24);
                        uint64_t v43 = &v139;
                        long long v44 = v151;
                      }
                    }
                    long long v45 = &v44[6 * v152];
                    long long v46 = *(_OWORD *)v43;
                    *((void *)v45 + 2) = *((void *)v43 + 2);
                    *(_OWORD *)long long v45 = v46;
                    uint64_t v47 = ++v152;
                    if (v150[0])
                    {
                      int v139 = 3;
                      int64_t v140 = ", ";
                      uint64_t v141 = 2;
                      uint64_t v48 = &v139;
                      uint64_t v49 = v151;
                      if (v47 >= v153)
                      {
                        unint64_t v109 = v47 + 1;
                        BOOL v110 = &v151[6 * v47] > &v139;
                        if (v151 <= &v139 && v110)
                        {
                          int64_t v129 = (char *)&v139 - (char *)v151;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v109, 24);
                          uint64_t v49 = v151;
                          uint64_t v48 = (int *)((char *)v151 + v129);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v109, 24);
                          uint64_t v48 = &v139;
                          uint64_t v49 = v151;
                        }
                      }
                      long long v50 = &v49[6 * v152];
                      long long v51 = *(_OWORD *)v48;
                      *((void *)v50 + 2) = *((void *)v48 + 2);
                      *(_OWORD *)long long v50 = v51;
                      uint64_t v52 = ++v152;
                      if (v150[0])
                      {
                        int v139 = 3;
                        int64_t v140 = "floor";
                        uint64_t v141 = 5;
                        unsigned int v53 = &v139;
                        unint64_t v54 = v151;
                        if (v52 >= v153)
                        {
                          unint64_t v111 = v52 + 1;
                          BOOL v112 = &v151[6 * v52] > &v139;
                          if (v151 <= &v139 && v112)
                          {
                            int64_t v130 = (char *)&v139 - (char *)v151;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v111, 24);
                            unint64_t v54 = v151;
                            unsigned int v53 = (int *)((char *)v151 + v130);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v111, 24);
                            unsigned int v53 = &v139;
                            unint64_t v54 = v151;
                          }
                        }
                        unint64_t v55 = &v54[6 * v152];
                        long long v56 = *(_OWORD *)v53;
                        *((void *)v55 + 2) = *((void *)v53 + 2);
                        *(_OWORD *)unint64_t v55 = v56;
                        uint64_t v57 = ++v152;
                        if (v150[0])
                        {
                          int v139 = 3;
                          int64_t v140 = ", ";
                          uint64_t v141 = 2;
                          BOOL v58 = &v139;
                          unint64_t v59 = v151;
                          if (v57 >= v153)
                          {
                            unint64_t v113 = v57 + 1;
                            BOOL v114 = &v151[6 * v57] > &v139;
                            if (v151 <= &v139 && v114)
                            {
                              int64_t v131 = (char *)&v139 - (char *)v151;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v113, 24);
                              unint64_t v59 = v151;
                              BOOL v58 = (int *)((char *)v151 + v131);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v113, 24);
                              BOOL v58 = &v139;
                              unint64_t v59 = v151;
                            }
                          }
                          BOOL v60 = &v59[6 * v152];
                          long long v61 = *(_OWORD *)v58;
                          *((void *)v60 + 2) = *((void *)v58 + 2);
                          *(_OWORD *)BOOL v60 = v61;
                          uint64_t v62 = ++v152;
                          if (v150[0])
                          {
                            int v139 = 3;
                            int64_t v140 = "round_to_even";
                            uint64_t v141 = 13;
                            unint64_t v63 = &v139;
                            BOOL v64 = v151;
                            if (v62 >= v153)
                            {
                              unint64_t v115 = v62 + 1;
                              BOOL v116 = &v151[6 * v62] > &v139;
                              if (v151 <= &v139 && v116)
                              {
                                int64_t v132 = (char *)&v139 - (char *)v151;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v115, 24);
                                BOOL v64 = v151;
                                unint64_t v63 = (int *)((char *)v151 + v132);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v115, 24);
                                unint64_t v63 = &v139;
                                BOOL v64 = v151;
                              }
                            }
                            int64_t v65 = &v64[6 * v152];
                            long long v66 = *(_OWORD *)v63;
                            *((void *)v65 + 2) = *((void *)v63 + 2);
                            *(_OWORD *)int64_t v65 = v66;
                            uint64_t v67 = ++v152;
                            if (v150[0])
                            {
                              int v139 = 3;
                              int64_t v140 = ", ";
                              uint64_t v141 = 2;
                              int64_t v68 = &v139;
                              int64_t v69 = v151;
                              if (v67 >= v153)
                              {
                                unint64_t v117 = v67 + 1;
                                BOOL v118 = &v151[6 * v67] > &v139;
                                if (v151 <= &v139 && v118)
                                {
                                  int64_t v133 = (char *)&v139 - (char *)v151;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v117, 24);
                                  int64_t v69 = v151;
                                  int64_t v68 = (int *)((char *)v151 + v133);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v117, 24);
                                  int64_t v68 = &v139;
                                  int64_t v69 = v151;
                                }
                              }
                              int64_t v70 = &v69[6 * v152];
                              long long v71 = *(_OWORD *)v68;
                              *((void *)v70 + 2) = *((void *)v68 + 2);
                              *(_OWORD *)int64_t v70 = v71;
                              uint64_t v72 = ++v152;
                              if (v150[0])
                              {
                                int v139 = 3;
                                int64_t v140 = "round_to_odd";
                                uint64_t v141 = 12;
                                uint64_t v73 = &v139;
                                uint64_t v74 = v151;
                                if (v72 >= v153)
                                {
                                  unint64_t v119 = v72 + 1;
                                  BOOL v120 = &v151[6 * v72] > &v139;
                                  if (v151 <= &v139 && v120)
                                  {
                                    int64_t v134 = (char *)&v139 - (char *)v151;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v119, 24);
                                    uint64_t v74 = v151;
                                    uint64_t v73 = (int *)((char *)v151 + v134);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v119, 24);
                                    uint64_t v73 = &v139;
                                    uint64_t v74 = v151;
                                  }
                                }
                                int v75 = &v74[6 * v152];
                                long long v76 = *(_OWORD *)v73;
                                *((void *)v75 + 2) = *((void *)v73 + 2);
                                *(_OWORD *)int v75 = v76;
                                ++v152;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v150);
    if (v150[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v150);
    }
    if (v159)
    {
      uint64_t v77 = v157;
      if (v157)
      {
        BOOL v78 = v158;
        unint64_t v79 = v157;
        if (v158 != v157)
        {
          do
            BOOL v78 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v78 - 1);
          while (v78 != v77);
          unint64_t v79 = v157;
        }
        BOOL v158 = v77;
        operator delete(v79);
      }
      uint64_t v80 = v155;
      if (v155)
      {
        unint64_t v81 = v156;
        BOOL v82 = v155;
        if (v156 != v155)
        {
          do
          {
            unint64_t v84 = (void *)*--v81;
            unint64_t v83 = v84;
            *unint64_t v81 = 0;
            if (v84) {
              operator delete[](v83);
            }
          }
          while (v81 != v80);
          BOOL v82 = v155;
        }
        BOOL v156 = v80;
        operator delete(v82);
      }
      if (v151 != (int *)v154) {
        free(v151);
      }
    }
    goto LABEL_53;
  }
  unsigned int v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v135[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v150[0] = &mlir::detail::TypeIDResolver<mlir::mps::NearestRoundingModeAttr,void>::id;
    v150[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::NearestRoundingModeAttrStorage,mlir::mps::NearestRoundingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail30NearestRoundingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_23NearestRoundingModeAttrEJNS2_19NearestRoundingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v150, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::NearestRoundingModeAttr,void>::id, v135);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::NearestRoundingModeAttr::print(mlir::mps::NearestRoundingModeAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6 > 5)
    {
LABEL_6:
      size_t v9 = 0;
      uint64_t v8 = "";
      char v7 = 1;
      goto LABEL_11;
    }
  }
  else
  {
    unsigned char *v5 = 60;
    ++*((void *)v4 + 4);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
  }
  char v7 = 0;
  uint64_t v8 = "round_prefer_ceil";
  size_t v9 = 17;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      char v7 = 0;
      uint64_t v8 = "round_prefer_floor";
      size_t v9 = 18;
      break;
    case 2u:
      char v7 = 0;
      uint64_t v8 = "ceil";
      size_t v9 = 4;
      break;
    case 3u:
      char v7 = 0;
      uint64_t v8 = "floor";
      size_t v9 = 5;
      break;
    case 4u:
      char v7 = 0;
      uint64_t v8 = "round_to_even";
      size_t v9 = 13;
      break;
    case 5u:
      char v7 = 0;
      uint64_t v8 = "round_to_odd";
      size_t v9 = 12;
      break;
    default:
      goto LABEL_6;
  }
LABEL_11:
  size_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v11 = (void *)*((void *)v10 + 4);
  if (v9 <= *((void *)v10 + 3) - (void)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((void *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    unsigned char *v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::SparseTensorStorageAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::SparseTensorStorageAttrStorage,mlir::mps::SparseTensorStorage>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail30SparseTensorStorageAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_23SparseTensorStorageAttrEJNS2_19SparseTensorStorageEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id, &v5);
}

uint64_t mlir::mps::SparseTensorStorageAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v112 = *MEMORY[0x1E4F143B8];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1))
  {
    uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    uint64_t v89 = 0;
    uint64_t v90 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v89))
    {
LABEL_52:
      uint64_t v54 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
      LOWORD(v104) = 259;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v94, a1, v54, v102);
      if (v94[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v94);
      }
      if (v101)
      {
        unint64_t v55 = (void **)__p;
        if (__p)
        {
          long long v56 = v100;
          uint64_t v57 = __p;
          if (v100 != __p)
          {
            do
              long long v56 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v56 - 1);
            while (v56 != v55);
            uint64_t v57 = __p;
          }
          BOOL v100 = v55;
          operator delete(v57);
        }
        BOOL v58 = v97;
        if (v97)
        {
          unint64_t v59 = v98;
          BOOL v60 = v97;
          if (v98 != v97)
          {
            do
            {
              uint64_t v62 = (void *)*--v59;
              long long v61 = v62;
              void *v59 = 0;
              if (v62) {
                operator delete[](v61);
              }
            }
            while (v59 != v58);
            BOOL v60 = v97;
          }
          BOOL v98 = v58;
          operator delete(v60);
        }
        if (v95 != &v96) {
          free(v95);
        }
      }
      return 0;
    }
    if (v90 != 3)
    {
LABEL_16:
      __int16 v88 = 257;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v102, a1, v2, v87);
      if (v102[0])
      {
        int v91 = 3;
        int64_t v92 = "expected ";
        uint64_t v93 = 9;
        unsigned int v6 = &v91;
        char v7 = v103;
        if (v104 >= v105)
        {
          unint64_t v66 = v104 + 1;
          if (v103 <= &v91 && &v103[6 * v104] > &v91)
          {
            int64_t v79 = (char *)&v91 - (char *)v103;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
            char v7 = v103;
            unsigned int v6 = (int *)((char *)v103 + v79);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
            unsigned int v6 = &v91;
            char v7 = v103;
          }
        }
        uint64_t v8 = &v7[6 * v104];
        long long v9 = *(_OWORD *)v6;
        *((void *)v8 + 2) = *((void *)v6 + 2);
        *(_OWORD *)uint64_t v8 = v9;
        uint64_t v10 = ++v104;
        if (v102[0])
        {
          int v91 = 3;
          int64_t v92 = "::mlir::mps::SparseTensorStorage";
          uint64_t v93 = 32;
          long long v11 = &v91;
          uint64_t v12 = v103;
          if (v10 >= v105)
          {
            unint64_t v67 = v10 + 1;
            BOOL v68 = &v103[6 * v10] > &v91;
            if (v103 <= &v91 && v68)
            {
              int64_t v80 = (char *)&v91 - (char *)v103;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
              uint64_t v12 = v103;
              long long v11 = (int *)((char *)v103 + v80);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
              long long v11 = &v91;
              uint64_t v12 = v103;
            }
          }
          long long v13 = &v12[6 * v104];
          long long v14 = *(_OWORD *)v11;
          *((void *)v13 + 2) = *((void *)v11 + 2);
          *(_OWORD *)long long v13 = v14;
          uint64_t v15 = ++v104;
          if (v102[0])
          {
            int v91 = 3;
            int64_t v92 = " to be one of: ";
            uint64_t v93 = 15;
            long long v16 = &v91;
            uint64_t v17 = v103;
            if (v15 >= v105)
            {
              unint64_t v69 = v15 + 1;
              BOOL v70 = &v103[6 * v15] > &v91;
              if (v103 <= &v91 && v70)
              {
                int64_t v81 = (char *)&v91 - (char *)v103;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                uint64_t v17 = v103;
                long long v16 = (int *)((char *)v103 + v81);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                long long v16 = &v91;
                uint64_t v17 = v103;
              }
            }
            long long v18 = &v17[6 * v104];
            long long v19 = *(_OWORD *)v16;
            *((void *)v18 + 2) = *((void *)v16 + 2);
            *(_OWORD *)long long v18 = v19;
            uint64_t v20 = ++v104;
            if (v102[0])
            {
              int v91 = 3;
              int64_t v92 = "COO";
              uint64_t v93 = 3;
              long long v21 = &v91;
              uint64_t v22 = v103;
              if (v20 >= v105)
              {
                unint64_t v71 = v20 + 1;
                BOOL v72 = &v103[6 * v20] > &v91;
                if (v103 <= &v91 && v72)
                {
                  int64_t v82 = (char *)&v91 - (char *)v103;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                  uint64_t v22 = v103;
                  long long v21 = (int *)((char *)v103 + v82);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                  long long v21 = &v91;
                  uint64_t v22 = v103;
                }
              }
              long long v23 = &v22[6 * v104];
              long long v24 = *(_OWORD *)v21;
              *((void *)v23 + 2) = *((void *)v21 + 2);
              *(_OWORD *)long long v23 = v24;
              uint64_t v25 = ++v104;
              if (v102[0])
              {
                int v91 = 3;
                int64_t v92 = ", ";
                uint64_t v93 = 2;
                long long v26 = &v91;
                uint64_t v27 = v103;
                if (v25 >= v105)
                {
                  unint64_t v73 = v25 + 1;
                  if (v103 <= &v91 && &v103[6 * v25] > &v91)
                  {
                    int64_t v83 = (char *)&v91 - (char *)v103;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                    uint64_t v27 = v103;
                    long long v26 = (int *)((char *)v103 + v83);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                    long long v26 = &v91;
                    uint64_t v27 = v103;
                  }
                }
                long long v28 = &v27[6 * v104];
                long long v29 = *(_OWORD *)v26;
                *((void *)v28 + 2) = *((void *)v26 + 2);
                *(_OWORD *)long long v28 = v29;
                uint64_t v30 = ++v104;
                if (v102[0])
                {
                  int v91 = 3;
                  int64_t v92 = "CSC";
                  uint64_t v93 = 3;
                  long long v31 = &v91;
                  uint64_t v32 = v103;
                  if (v30 >= v105)
                  {
                    unint64_t v74 = v30 + 1;
                    if (v103 <= &v91 && &v103[6 * v30] > &v91)
                    {
                      int64_t v84 = (char *)&v91 - (char *)v103;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                      uint64_t v32 = v103;
                      long long v31 = (int *)((char *)v103 + v84);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                      long long v31 = &v91;
                      uint64_t v32 = v103;
                    }
                  }
                  long long v33 = &v32[6 * v104];
                  long long v34 = *(_OWORD *)v31;
                  *((void *)v33 + 2) = *((void *)v31 + 2);
                  *(_OWORD *)long long v33 = v34;
                  uint64_t v35 = ++v104;
                  if (v102[0])
                  {
                    int v91 = 3;
                    int64_t v92 = ", ";
                    uint64_t v93 = 2;
                    long long v36 = &v91;
                    uint64_t v37 = v103;
                    if (v35 >= v105)
                    {
                      unint64_t v75 = v35 + 1;
                      BOOL v76 = &v103[6 * v35] > &v91;
                      if (v103 <= &v91 && v76)
                      {
                        int64_t v85 = (char *)&v91 - (char *)v103;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                        uint64_t v37 = v103;
                        long long v36 = (int *)((char *)v103 + v85);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                        long long v36 = &v91;
                        uint64_t v37 = v103;
                      }
                    }
                    uint64_t v38 = &v37[6 * v104];
                    long long v39 = *(_OWORD *)v36;
                    *((void *)v38 + 2) = *((void *)v36 + 2);
                    *(_OWORD *)uint64_t v38 = v39;
                    uint64_t v40 = ++v104;
                    if (v102[0])
                    {
                      int v91 = 3;
                      int64_t v92 = "CSR";
                      uint64_t v93 = 3;
                      long long v41 = &v91;
                      uint64_t v42 = v103;
                      if (v40 >= v105)
                      {
                        unint64_t v77 = v40 + 1;
                        BOOL v78 = &v103[6 * v40] > &v91;
                        if (v103 <= &v91 && v78)
                        {
                          int64_t v86 = (char *)&v91 - (char *)v103;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                          uint64_t v42 = v103;
                          long long v41 = (int *)((char *)v103 + v86);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                          long long v41 = &v91;
                          uint64_t v42 = v103;
                        }
                      }
                      uint64_t v43 = &v42[6 * v104];
                      long long v44 = *(_OWORD *)v41;
                      *((void *)v43 + 2) = *((void *)v41 + 2);
                      *(_OWORD *)uint64_t v43 = v44;
                      ++v104;
                    }
                  }
                }
              }
            }
          }
        }
      }
      mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v102);
      if (v102[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v102);
      }
      if (v111)
      {
        long long v45 = v109;
        if (v109)
        {
          long long v46 = v110;
          uint64_t v47 = v109;
          if (v110 != v109)
          {
            do
              long long v46 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v46 - 1);
            while (v46 != v45);
            uint64_t v47 = v109;
          }
          BOOL v110 = v45;
          operator delete(v47);
        }
        uint64_t v48 = v107;
        if (v107)
        {
          uint64_t v49 = v108;
          long long v50 = v107;
          if (v108 != v107)
          {
            do
            {
              uint64_t v52 = (void *)*--v49;
              long long v51 = v52;
              void *v49 = 0;
              if (v52) {
                operator delete[](v51);
              }
            }
            while (v49 != v48);
            long long v50 = v107;
          }
          BOOL v108 = v48;
          operator delete(v50);
        }
        if (v103 != (int *)v106) {
          free(v103);
        }
      }
      goto LABEL_52;
    }
    if (*(_WORD *)v89 == 20291 && *(unsigned char *)(v89 + 2) == 79)
    {
      unsigned int v53 = 0;
    }
    else if (*(_WORD *)v89 == 21315 && *(unsigned char *)(v89 + 2) == 67)
    {
      unsigned int v53 = 1;
    }
    else
    {
      if (*(_WORD *)v89 != 21315 || *(unsigned char *)(v89 + 2) != 82) {
        goto LABEL_16;
      }
      unsigned int v53 = 2;
    }
    if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
    {
      uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v87[0] = v53;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v102[0] = &mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id;
      v102[1] = Context;
      return mlir::StorageUniquer::get<mlir::mps::detail::SparseTensorStorageAttrStorage,mlir::mps::SparseTensorStorage>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail30SparseTensorStorageAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_23SparseTensorStorageAttrEJNS2_19SparseTensorStorageEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v102, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id, v87);
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::SparseTensorStorageAttr::print(mlir::mps::SparseTensorStorageAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) != v5)
  {
    unsigned char *v5 = 60;
    ++*((void *)v4 + 4);
    int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6) {
      goto LABEL_3;
    }
LABEL_11:
    BOOL v7 = 0;
    long long v9 = "COO";
LABEL_13:
    size_t v8 = 3;
    goto LABEL_14;
  }
  llvm::raw_ostream::write(v4, "<", 1uLL);
  int v6 = *(_DWORD *)(*(void *)this + 8);
  if (!v6) {
    goto LABEL_11;
  }
LABEL_3:
  if (v6 == 2)
  {
    BOOL v7 = 0;
    long long v9 = "CSR";
    goto LABEL_13;
  }
  BOOL v7 = v6 != 1;
  if (v6 == 1) {
    size_t v8 = 3;
  }
  else {
    size_t v8 = 0;
  }
  if (v6 == 1) {
    long long v9 = "CSC";
  }
  else {
    long long v9 = "";
  }
LABEL_14:
  uint64_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v11 = (void *)*((void *)v10 + 4);
  if (v8 <= *((void *)v10 + 3) - (void)v11)
  {
    if (!v7)
    {
      memcpy(v11, v9, v8);
      *((void *)v10 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v9, v8);
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    unsigned char *v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::MetalPixelFormatAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::MetalPixelFormatAttrStorage,mlir::mps::MetalPixelFormat>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27MetalPixelFormatAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20MetalPixelFormatAttrEJNS2_16MetalPixelFormatEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id, &v5);
}

uint64_t mlir::mps::MetalPixelFormatAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v224 = *MEMORY[0x1E4F143B8];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1)) {
    return 0;
  }
  uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  int64_t v201 = 0;
  uint64_t v202 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v201))
  {
LABEL_69:
    uint64_t v125 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    LOWORD(v216) = 259;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v206, a1, v125, v214);
    if (v206[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v206);
    }
    if (v213)
    {
      int64_t v126 = (void **)__p;
      if (__p)
      {
        int64_t v127 = v212;
        int64_t v128 = __p;
        if (v212 != __p)
        {
          do
            int64_t v127 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v127 - 1);
          while (v127 != v126);
          int64_t v128 = __p;
        }
        int64_t v212 = v126;
        operator delete(v128);
      }
      int64_t v129 = v209;
      if (v209)
      {
        int64_t v130 = v210;
        int64_t v131 = v209;
        if (v210 != v209)
        {
          do
          {
            int64_t v133 = (void *)*--v130;
            int64_t v132 = v133;
            void *v130 = 0;
            if (v133) {
              operator delete[](v132);
            }
          }
          while (v130 != v129);
          int64_t v131 = v209;
        }
        int64_t v210 = v129;
        operator delete(v131);
      }
      if (v207 != &v208) {
        free(v207);
      }
    }
    return 0;
  }
  uint64_t v3 = mlir::mps::symbolizeMetalPixelFormat(v201, v202);
  if ((v3 & 0xFF00000000) == 0)
  {
    __int16 v200 = 257;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v214, a1, v2, v199);
    if (v214[0])
    {
      int v203 = 3;
      int64_t v204 = "expected ";
      uint64_t v205 = 9;
      size_t v8 = &v203;
      long long v9 = v215;
      if (v216 >= v217)
      {
        unint64_t v134 = v216 + 1;
        if (v215 <= &v203 && &v215[6 * v216] > &v203)
        {
          int64_t v167 = (char *)&v203 - (char *)v215;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v134, 24);
          long long v9 = v215;
          size_t v8 = (int *)((char *)v215 + v167);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v134, 24);
          size_t v8 = &v203;
          long long v9 = v215;
        }
      }
      uint64_t v10 = &v9[6 * v216];
      long long v11 = *(_OWORD *)v8;
      *((void *)v10 + 2) = *((void *)v8 + 2);
      *(_OWORD *)uint64_t v10 = v11;
      uint64_t v12 = ++v216;
      if (v214[0])
      {
        int v203 = 3;
        int64_t v204 = "::mlir::mps::MetalPixelFormat";
        uint64_t v205 = 29;
        long long v13 = &v203;
        long long v14 = v215;
        if (v12 >= v217)
        {
          unint64_t v135 = v12 + 1;
          BOOL v136 = &v215[6 * v12] > &v203;
          if (v215 <= &v203 && v136)
          {
            int64_t v170 = (char *)&v203 - (char *)v215;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v135, 24);
            long long v14 = v215;
            long long v13 = (int *)((char *)v215 + v170);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v135, 24);
            long long v13 = &v203;
            long long v14 = v215;
          }
        }
        uint64_t v15 = &v14[6 * v216];
        long long v16 = *(_OWORD *)v13;
        *((void *)v15 + 2) = *((void *)v13 + 2);
        *(_OWORD *)uint64_t v15 = v16;
        uint64_t v17 = ++v216;
        if (v214[0])
        {
          int v203 = 3;
          int64_t v204 = " to be one of: ";
          uint64_t v205 = 15;
          long long v18 = &v203;
          long long v19 = v215;
          if (v17 >= v217)
          {
            unint64_t v137 = v17 + 1;
            BOOL v138 = &v215[6 * v17] > &v203;
            if (v215 <= &v203 && v138)
            {
              int64_t v173 = (char *)&v203 - (char *)v215;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v137, 24);
              long long v19 = v215;
              long long v18 = (int *)((char *)v215 + v173);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v137, 24);
              long long v18 = &v203;
              long long v19 = v215;
            }
          }
          uint64_t v20 = &v19[6 * v216];
          long long v21 = *(_OWORD *)v18;
          *((void *)v20 + 2) = *((void *)v18 + 2);
          *(_OWORD *)uint64_t v20 = v21;
          uint64_t v22 = ++v216;
          if (v214[0])
          {
            int v203 = 3;
            int64_t v204 = "R8Unorm";
            uint64_t v205 = 7;
            long long v23 = &v203;
            long long v24 = v215;
            if (v22 >= v217)
            {
              unint64_t v139 = v22 + 1;
              BOOL v140 = &v215[6 * v22] > &v203;
              if (v215 <= &v203 && v140)
              {
                int64_t v176 = (char *)&v203 - (char *)v215;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v139, 24);
                long long v24 = v215;
                long long v23 = (int *)((char *)v215 + v176);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v139, 24);
                long long v23 = &v203;
                long long v24 = v215;
              }
            }
            uint64_t v25 = &v24[6 * v216];
            long long v26 = *(_OWORD *)v23;
            *((void *)v25 + 2) = *((void *)v23 + 2);
            *(_OWORD *)uint64_t v25 = v26;
            uint64_t v27 = ++v216;
            if (v214[0])
            {
              int v203 = 3;
              int64_t v204 = ", ";
              uint64_t v205 = 2;
              long long v28 = &v203;
              long long v29 = v215;
              if (v27 >= v217)
              {
                unint64_t v141 = v27 + 1;
                BOOL v142 = &v215[6 * v27] > &v203;
                if (v215 <= &v203 && v142)
                {
                  int64_t v179 = (char *)&v203 - (char *)v215;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v141, 24);
                  long long v29 = v215;
                  long long v28 = (int *)((char *)v215 + v179);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v141, 24);
                  long long v28 = &v203;
                  long long v29 = v215;
                }
              }
              uint64_t v30 = &v29[6 * v216];
              long long v31 = *(_OWORD *)v28;
              *((void *)v30 + 2) = *((void *)v28 + 2);
              *(_OWORD *)uint64_t v30 = v31;
              uint64_t v32 = ++v216;
              if (v214[0])
              {
                int v203 = 3;
                int64_t v204 = "RG8Unorm";
                uint64_t v205 = 8;
                long long v33 = &v203;
                long long v34 = v215;
                if (v32 >= v217)
                {
                  unint64_t v143 = v32 + 1;
                  BOOL v144 = &v215[6 * v32] > &v203;
                  if (v215 <= &v203 && v144)
                  {
                    int64_t v182 = (char *)&v203 - (char *)v215;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v143, 24);
                    long long v34 = v215;
                    long long v33 = (int *)((char *)v215 + v182);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v143, 24);
                    long long v33 = &v203;
                    long long v34 = v215;
                  }
                }
                uint64_t v35 = &v34[6 * v216];
                long long v36 = *(_OWORD *)v33;
                *((void *)v35 + 2) = *((void *)v33 + 2);
                *(_OWORD *)uint64_t v35 = v36;
                uint64_t v37 = ++v216;
                if (v214[0])
                {
                  int v203 = 3;
                  int64_t v204 = ", ";
                  uint64_t v205 = 2;
                  uint64_t v38 = &v203;
                  long long v39 = v215;
                  if (v37 >= v217)
                  {
                    unint64_t v145 = v37 + 1;
                    BOOL v146 = &v215[6 * v37] > &v203;
                    if (v215 <= &v203 && v146)
                    {
                      int64_t v183 = (char *)&v203 - (char *)v215;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v145, 24);
                      long long v39 = v215;
                      uint64_t v38 = (int *)((char *)v215 + v183);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v145, 24);
                      uint64_t v38 = &v203;
                      long long v39 = v215;
                    }
                  }
                  uint64_t v40 = &v39[6 * v216];
                  long long v41 = *(_OWORD *)v38;
                  *((void *)v40 + 2) = *((void *)v38 + 2);
                  *(_OWORD *)uint64_t v40 = v41;
                  uint64_t v42 = ++v216;
                  if (v214[0])
                  {
                    int v203 = 3;
                    int64_t v204 = "RGBA8Unorm";
                    uint64_t v205 = 10;
                    uint64_t v43 = &v203;
                    long long v44 = v215;
                    if (v42 >= v217)
                    {
                      unint64_t v147 = v42 + 1;
                      BOOL v148 = &v215[6 * v42] > &v203;
                      if (v215 <= &v203 && v148)
                      {
                        int64_t v184 = (char *)&v203 - (char *)v215;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v147, 24);
                        long long v44 = v215;
                        uint64_t v43 = (int *)((char *)v215 + v184);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v147, 24);
                        uint64_t v43 = &v203;
                        long long v44 = v215;
                      }
                    }
                    long long v45 = &v44[6 * v216];
                    long long v46 = *(_OWORD *)v43;
                    *((void *)v45 + 2) = *((void *)v43 + 2);
                    *(_OWORD *)long long v45 = v46;
                    uint64_t v47 = ++v216;
                    if (v214[0])
                    {
                      int v203 = 3;
                      int64_t v204 = ", ";
                      uint64_t v205 = 2;
                      uint64_t v48 = &v203;
                      uint64_t v49 = v215;
                      if (v47 >= v217)
                      {
                        unint64_t v149 = v47 + 1;
                        BOOL v150 = &v215[6 * v47] > &v203;
                        if (v215 <= &v203 && v150)
                        {
                          int64_t v185 = (char *)&v203 - (char *)v215;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v149, 24);
                          uint64_t v49 = v215;
                          uint64_t v48 = (int *)((char *)v215 + v185);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v149, 24);
                          uint64_t v48 = &v203;
                          uint64_t v49 = v215;
                        }
                      }
                      long long v50 = &v49[6 * v216];
                      long long v51 = *(_OWORD *)v48;
                      *((void *)v50 + 2) = *((void *)v48 + 2);
                      *(_OWORD *)long long v50 = v51;
                      uint64_t v52 = ++v216;
                      if (v214[0])
                      {
                        int v203 = 3;
                        int64_t v204 = "BGRA8Unorm";
                        uint64_t v205 = 10;
                        unsigned int v53 = &v203;
                        uint64_t v54 = v215;
                        if (v52 >= v217)
                        {
                          unint64_t v151 = v52 + 1;
                          BOOL v152 = &v215[6 * v52] > &v203;
                          if (v215 <= &v203 && v152)
                          {
                            int64_t v186 = (char *)&v203 - (char *)v215;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v151, 24);
                            uint64_t v54 = v215;
                            unsigned int v53 = (int *)((char *)v215 + v186);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v151, 24);
                            unsigned int v53 = &v203;
                            uint64_t v54 = v215;
                          }
                        }
                        unint64_t v55 = &v54[6 * v216];
                        long long v56 = *(_OWORD *)v53;
                        *((void *)v55 + 2) = *((void *)v53 + 2);
                        *(_OWORD *)unint64_t v55 = v56;
                        uint64_t v57 = ++v216;
                        if (v214[0])
                        {
                          int v203 = 3;
                          int64_t v204 = ", ";
                          uint64_t v205 = 2;
                          BOOL v58 = &v203;
                          unint64_t v59 = v215;
                          if (v57 >= v217)
                          {
                            unint64_t v153 = v57 + 1;
                            BOOL v154 = &v215[6 * v57] > &v203;
                            if (v215 <= &v203 && v154)
                            {
                              int64_t v187 = (char *)&v203 - (char *)v215;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v153, 24);
                              unint64_t v59 = v215;
                              BOOL v58 = (int *)((char *)v215 + v187);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v153, 24);
                              BOOL v58 = &v203;
                              unint64_t v59 = v215;
                            }
                          }
                          BOOL v60 = &v59[6 * v216];
                          long long v61 = *(_OWORD *)v58;
                          *((void *)v60 + 2) = *((void *)v58 + 2);
                          *(_OWORD *)BOOL v60 = v61;
                          uint64_t v62 = ++v216;
                          if (v214[0])
                          {
                            int v203 = 3;
                            int64_t v204 = "R16Float";
                            uint64_t v205 = 8;
                            unint64_t v63 = &v203;
                            BOOL v64 = v215;
                            if (v62 >= v217)
                            {
                              unint64_t v155 = v62 + 1;
                              BOOL v156 = &v215[6 * v62] > &v203;
                              if (v215 <= &v203 && v156)
                              {
                                int64_t v188 = (char *)&v203 - (char *)v215;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v155, 24);
                                BOOL v64 = v215;
                                unint64_t v63 = (int *)((char *)v215 + v188);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v155, 24);
                                unint64_t v63 = &v203;
                                BOOL v64 = v215;
                              }
                            }
                            int64_t v65 = &v64[6 * v216];
                            long long v66 = *(_OWORD *)v63;
                            *((void *)v65 + 2) = *((void *)v63 + 2);
                            *(_OWORD *)int64_t v65 = v66;
                            uint64_t v67 = ++v216;
                            if (v214[0])
                            {
                              int v203 = 3;
                              int64_t v204 = ", ";
                              uint64_t v205 = 2;
                              BOOL v68 = &v203;
                              unint64_t v69 = v215;
                              if (v67 >= v217)
                              {
                                unint64_t v157 = v67 + 1;
                                BOOL v158 = &v215[6 * v67] > &v203;
                                if (v215 <= &v203 && v158)
                                {
                                  int64_t v189 = (char *)&v203 - (char *)v215;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v157, 24);
                                  unint64_t v69 = v215;
                                  BOOL v68 = (int *)((char *)v215 + v189);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v157, 24);
                                  BOOL v68 = &v203;
                                  unint64_t v69 = v215;
                                }
                              }
                              BOOL v70 = &v69[6 * v216];
                              long long v71 = *(_OWORD *)v68;
                              *((void *)v70 + 2) = *((void *)v68 + 2);
                              *(_OWORD *)BOOL v70 = v71;
                              uint64_t v72 = ++v216;
                              if (v214[0])
                              {
                                int v203 = 3;
                                int64_t v204 = "RG16Float";
                                uint64_t v205 = 9;
                                unint64_t v73 = &v203;
                                unint64_t v74 = v215;
                                if (v72 >= v217)
                                {
                                  unint64_t v159 = v72 + 1;
                                  BOOL v160 = &v215[6 * v72] > &v203;
                                  if (v215 <= &v203 && v160)
                                  {
                                    int64_t v190 = (char *)&v203 - (char *)v215;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v159, 24);
                                    unint64_t v74 = v215;
                                    unint64_t v73 = (int *)((char *)v215 + v190);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v159, 24);
                                    unint64_t v73 = &v203;
                                    unint64_t v74 = v215;
                                  }
                                }
                                unint64_t v75 = &v74[6 * v216];
                                long long v76 = *(_OWORD *)v73;
                                *((void *)v75 + 2) = *((void *)v73 + 2);
                                *(_OWORD *)unint64_t v75 = v76;
                                uint64_t v77 = ++v216;
                                if (v214[0])
                                {
                                  int v203 = 3;
                                  int64_t v204 = ", ";
                                  uint64_t v205 = 2;
                                  BOOL v78 = &v203;
                                  int64_t v79 = v215;
                                  if (v77 >= v217)
                                  {
                                    unint64_t v161 = v77 + 1;
                                    BOOL v162 = &v215[6 * v77] > &v203;
                                    if (v215 <= &v203 && v162)
                                    {
                                      int64_t v191 = (char *)&v203 - (char *)v215;
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v161, 24);
                                      int64_t v79 = v215;
                                      BOOL v78 = (int *)((char *)v215 + v191);
                                    }
                                    else
                                    {
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v161, 24);
                                      BOOL v78 = &v203;
                                      int64_t v79 = v215;
                                    }
                                  }
                                  int64_t v80 = &v79[6 * v216];
                                  long long v81 = *(_OWORD *)v78;
                                  *((void *)v80 + 2) = *((void *)v78 + 2);
                                  *(_OWORD *)int64_t v80 = v81;
                                  uint64_t v82 = ++v216;
                                  if (v214[0])
                                  {
                                    int v203 = 3;
                                    int64_t v204 = "RGBA16Float";
                                    uint64_t v205 = 11;
                                    int64_t v83 = &v203;
                                    int64_t v84 = v215;
                                    if (v82 >= v217)
                                    {
                                      unint64_t v163 = v82 + 1;
                                      BOOL v164 = &v215[6 * v82] > &v203;
                                      if (v215 <= &v203 && v164)
                                      {
                                        int64_t v192 = (char *)&v203 - (char *)v215;
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v163, 24);
                                        int64_t v84 = v215;
                                        int64_t v83 = (int *)((char *)v215 + v192);
                                      }
                                      else
                                      {
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v163, 24);
                                        int64_t v83 = &v203;
                                        int64_t v84 = v215;
                                      }
                                    }
                                    int64_t v85 = &v84[6 * v216];
                                    long long v86 = *(_OWORD *)v83;
                                    *((void *)v85 + 2) = *((void *)v83 + 2);
                                    *(_OWORD *)int64_t v85 = v86;
                                    uint64_t v87 = ++v216;
                                    if (v214[0])
                                    {
                                      int v203 = 3;
                                      int64_t v204 = ", ";
                                      uint64_t v205 = 2;
                                      __int16 v88 = &v203;
                                      uint64_t v89 = v215;
                                      if (v87 >= v217)
                                      {
                                        unint64_t v165 = v87 + 1;
                                        BOOL v166 = &v215[6 * v87] > &v203;
                                        if (v215 <= &v203 && v166)
                                        {
                                          int64_t v193 = (char *)&v203 - (char *)v215;
                                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v165, 24);
                                          uint64_t v89 = v215;
                                          __int16 v88 = (int *)((char *)v215 + v193);
                                        }
                                        else
                                        {
                                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v165, 24);
                                          __int16 v88 = &v203;
                                          uint64_t v89 = v215;
                                        }
                                      }
                                      uint64_t v90 = &v89[6 * v216];
                                      long long v91 = *(_OWORD *)v88;
                                      *((void *)v90 + 2) = *((void *)v88 + 2);
                                      *(_OWORD *)uint64_t v90 = v91;
                                      uint64_t v92 = ++v216;
                                      if (v214[0])
                                      {
                                        int v203 = 3;
                                        int64_t v204 = "R32Float";
                                        uint64_t v205 = 8;
                                        uint64_t v93 = &v203;
                                        unint64_t v94 = v215;
                                        if (v92 >= v217)
                                        {
                                          unint64_t v168 = v92 + 1;
                                          BOOL v169 = &v215[6 * v92] > &v203;
                                          if (v215 <= &v203 && v169)
                                          {
                                            int64_t v194 = (char *)&v203 - (char *)v215;
                                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v168, 24);
                                            unint64_t v94 = v215;
                                            uint64_t v93 = (int *)((char *)v215 + v194);
                                          }
                                          else
                                          {
                                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v168, 24);
                                            uint64_t v93 = &v203;
                                            unint64_t v94 = v215;
                                          }
                                        }
                                        unint64_t v95 = &v94[6 * v216];
                                        long long v96 = *(_OWORD *)v93;
                                        *((void *)v95 + 2) = *((void *)v93 + 2);
                                        *(_OWORD *)unint64_t v95 = v96;
                                        uint64_t v97 = ++v216;
                                        if (v214[0])
                                        {
                                          int v203 = 3;
                                          int64_t v204 = ", ";
                                          uint64_t v205 = 2;
                                          BOOL v98 = &v203;
                                          unint64_t v99 = v215;
                                          if (v97 >= v217)
                                          {
                                            unint64_t v171 = v97 + 1;
                                            BOOL v172 = &v215[6 * v97] > &v203;
                                            if (v215 <= &v203 && v172)
                                            {
                                              int64_t v195 = (char *)&v203 - (char *)v215;
                                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v171, 24);
                                              unint64_t v99 = v215;
                                              BOOL v98 = (int *)((char *)v215 + v195);
                                            }
                                            else
                                            {
                                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v171, 24);
                                              BOOL v98 = &v203;
                                              unint64_t v99 = v215;
                                            }
                                          }
                                          BOOL v100 = &v99[6 * v216];
                                          long long v101 = *(_OWORD *)v98;
                                          *((void *)v100 + 2) = *((void *)v98 + 2);
                                          *(_OWORD *)BOOL v100 = v101;
                                          uint64_t v102 = ++v216;
                                          if (v214[0])
                                          {
                                            int v203 = 3;
                                            int64_t v204 = "RG32Float";
                                            uint64_t v205 = 9;
                                            unint64_t v103 = &v203;
                                            unsigned int v104 = v215;
                                            if (v102 >= v217)
                                            {
                                              unint64_t v174 = v102 + 1;
                                              BOOL v175 = &v215[6 * v102] > &v203;
                                              if (v215 <= &v203 && v175)
                                              {
                                                int64_t v196 = (char *)&v203 - (char *)v215;
                                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v174, 24);
                                                unsigned int v104 = v215;
                                                unint64_t v103 = (int *)((char *)v215 + v196);
                                              }
                                              else
                                              {
                                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v174, 24);
                                                unint64_t v103 = &v203;
                                                unsigned int v104 = v215;
                                              }
                                            }
                                            unsigned int v105 = &v104[6 * v216];
                                            long long v106 = *(_OWORD *)v103;
                                            *((void *)v105 + 2) = *((void *)v103 + 2);
                                            *(_OWORD *)unsigned int v105 = v106;
                                            uint64_t v107 = ++v216;
                                            if (v214[0])
                                            {
                                              int v203 = 3;
                                              int64_t v204 = ", ";
                                              uint64_t v205 = 2;
                                              BOOL v108 = &v203;
                                              unint64_t v109 = v215;
                                              if (v107 >= v217)
                                              {
                                                unint64_t v177 = v107 + 1;
                                                BOOL v178 = &v215[6 * v107] > &v203;
                                                if (v215 <= &v203 && v178)
                                                {
                                                  int64_t v197 = (char *)&v203 - (char *)v215;
                                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v177, 24);
                                                  unint64_t v109 = v215;
                                                  BOOL v108 = (int *)((char *)v215 + v197);
                                                }
                                                else
                                                {
                                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v177, 24);
                                                  BOOL v108 = &v203;
                                                  unint64_t v109 = v215;
                                                }
                                              }
                                              BOOL v110 = &v109[6 * v216];
                                              long long v111 = *(_OWORD *)v108;
                                              *((void *)v110 + 2) = *((void *)v108 + 2);
                                              *(_OWORD *)BOOL v110 = v111;
                                              uint64_t v112 = ++v216;
                                              if (v214[0])
                                              {
                                                int v203 = 3;
                                                int64_t v204 = "RGBA32Float";
                                                uint64_t v205 = 11;
                                                unint64_t v113 = &v203;
                                                BOOL v114 = v215;
                                                if (v112 >= v217)
                                                {
                                                  unint64_t v180 = v112 + 1;
                                                  BOOL v181 = &v215[6 * v112] > &v203;
                                                  if (v215 <= &v203 && v181)
                                                  {
                                                    int64_t v198 = (char *)&v203 - (char *)v215;
                                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v180, 24);
                                                    BOOL v114 = v215;
                                                    unint64_t v113 = (int *)((char *)v215 + v198);
                                                  }
                                                  else
                                                  {
                                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v180, 24);
                                                    unint64_t v113 = &v203;
                                                    BOOL v114 = v215;
                                                  }
                                                }
                                                unint64_t v115 = &v114[6 * v216];
                                                long long v116 = *(_OWORD *)v113;
                                                *((void *)v115 + 2) = *((void *)v113 + 2);
                                                *(_OWORD *)unint64_t v115 = v116;
                                                ++v216;
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v214);
    if (v214[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v214);
    }
    if (v223)
    {
      unint64_t v117 = v221;
      if (v221)
      {
        BOOL v118 = v222;
        unint64_t v119 = v221;
        if (v222 != v221)
        {
          do
            BOOL v118 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v118 - 1);
          while (v118 != v117);
          unint64_t v119 = v221;
        }
        v222 = v117;
        operator delete(v119);
      }
      BOOL v120 = v219;
      if (v219)
      {
        int64_t v121 = v220;
        int64_t v122 = v219;
        if (v220 != v219)
        {
          do
          {
            int64_t v124 = (void *)*--v121;
            int64_t v123 = v124;
            *int64_t v121 = 0;
            if (v124) {
              operator delete[](v123);
            }
          }
          while (v121 != v120);
          int64_t v122 = v219;
        }
        v220 = v120;
        operator delete(v122);
      }
      if (v215 != (int *)v218) {
        free(v215);
      }
    }
    goto LABEL_69;
  }
  unsigned int v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v199[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v214[0] = &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id;
    v214[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::MetalPixelFormatAttrStorage,mlir::mps::MetalPixelFormat>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27MetalPixelFormatAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20MetalPixelFormatAttrEJNS2_16MetalPixelFormatEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v214, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id, v199);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::MetalPixelFormatAttr::print(mlir::mps::MetalPixelFormatAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6 > 9)
    {
LABEL_6:
      size_t v9 = 0;
      size_t v8 = "";
      char v7 = 1;
      goto LABEL_16;
    }
  }
  else
  {
    unsigned char *v5 = 60;
    ++*((void *)v4 + 4);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
  }
  char v7 = 0;
  size_t v8 = "R8Unorm";
  size_t v9 = 7;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      char v7 = 0;
      size_t v8 = "RG8Unorm";
      size_t v9 = 8;
      break;
    case 2u:
      char v7 = 0;
      size_t v8 = "RGBA8Unorm";
      size_t v9 = 10;
      break;
    case 3u:
      char v7 = 0;
      size_t v8 = "BGRA8Unorm";
      size_t v9 = 10;
      break;
    case 4u:
      char v7 = 0;
      size_t v8 = "R16Float";
      size_t v9 = 8;
      break;
    case 5u:
      char v7 = 0;
      size_t v8 = "RG16Float";
      goto LABEL_15;
    case 6u:
      char v7 = 0;
      size_t v8 = "RGBA16Float";
      size_t v9 = 11;
      break;
    case 7u:
      char v7 = 0;
      size_t v8 = "R32Float";
      size_t v9 = 8;
      break;
    case 8u:
      char v7 = 0;
      size_t v8 = "RG32Float";
LABEL_15:
      size_t v9 = 9;
      break;
    case 9u:
      char v7 = 0;
      size_t v8 = "RGBA32Float";
      size_t v9 = 11;
      break;
    default:
      goto LABEL_6;
  }
LABEL_16:
  uint64_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v11 = (void *)*((void *)v10 + 4);
  if (v9 <= *((void *)v10 + 3) - (void)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((void *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    unsigned char *v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::NormalSamplingMethodAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::NormalSamplingMethodAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::NormalSamplingMethodAttrStorage,mlir::mps::NormalSamplingMethod>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail31NormalSamplingMethodAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_24NormalSamplingMethodAttrEJNS2_20NormalSamplingMethodEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::NormalSamplingMethodAttr,void>::id, &v5);
}

uint64_t mlir::mps::NormalSamplingMethodAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v97 = *MEMORY[0x1E4F143B8];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1))
  {
    uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    uint64_t v74 = 0;
    uint64_t v75 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v74))
    {
LABEL_46:
      uint64_t v43 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
      LOWORD(v89) = 259;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v79, a1, v43, v87);
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
      if (v86)
      {
        long long v44 = (void **)__p;
        if (__p)
        {
          long long v45 = v85;
          long long v46 = __p;
          if (v85 != __p)
          {
            do
              long long v45 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v45 - 1);
            while (v45 != v44);
            long long v46 = __p;
          }
          int64_t v85 = v44;
          operator delete(v46);
        }
        uint64_t v47 = v82;
        if (v82)
        {
          uint64_t v48 = v83;
          uint64_t v49 = v82;
          if (v83 != v82)
          {
            do
            {
              long long v51 = (void *)*--v48;
              long long v50 = v51;
              void *v48 = 0;
              if (v51) {
                operator delete[](v50);
              }
            }
            while (v48 != v47);
            uint64_t v49 = v82;
          }
          int64_t v83 = v47;
          operator delete(v49);
        }
        if (v80 != &v81) {
          free(v80);
        }
      }
      return 0;
    }
    if (v75 == 10)
    {
      if (*(void *)v74 != 0x6C6C756D5F786F62 || *(_WORD *)(v74 + 8) != 29285) {
        goto LABEL_15;
      }
      unsigned int v4 = 1;
    }
    else
    {
      if (v75 != 7 || (*(_DWORD *)v74 == 1601597033 ? (BOOL v3 = *(_DWORD *)(v74 + 3) == 1717855071) : (BOOL v3 = 0), !v3))
      {
LABEL_15:
        __int16 v73 = 257;
        (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v87, a1, v2, v72);
        if (v87[0])
        {
          int v76 = 3;
          uint64_t v77 = "expected ";
          uint64_t v78 = 9;
          unsigned int v6 = &v76;
          char v7 = v88;
          if (v89 >= v90)
          {
            unint64_t v55 = v89 + 1;
            if (v88 <= &v76 && &v88[6 * v89] > &v76)
            {
              int64_t v66 = (char *)&v76 - (char *)v88;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v55, 24);
              char v7 = v88;
              unsigned int v6 = (int *)((char *)v88 + v66);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v55, 24);
              unsigned int v6 = &v76;
              char v7 = v88;
            }
          }
          size_t v8 = &v7[6 * v89];
          long long v9 = *(_OWORD *)v6;
          *((void *)v8 + 2) = *((void *)v6 + 2);
          *(_OWORD *)size_t v8 = v9;
          uint64_t v10 = ++v89;
          if (v87[0])
          {
            int v76 = 3;
            uint64_t v77 = "::mlir::mps::NormalSamplingMethod";
            uint64_t v78 = 33;
            long long v11 = &v76;
            uint64_t v12 = v88;
            if (v10 >= v90)
            {
              unint64_t v56 = v10 + 1;
              BOOL v57 = &v88[6 * v10] > &v76;
              if (v88 <= &v76 && v57)
              {
                int64_t v67 = (char *)&v76 - (char *)v88;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v56, 24);
                uint64_t v12 = v88;
                long long v11 = (int *)((char *)v88 + v67);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v56, 24);
                long long v11 = &v76;
                uint64_t v12 = v88;
              }
            }
            long long v13 = &v12[6 * v89];
            long long v14 = *(_OWORD *)v11;
            *((void *)v13 + 2) = *((void *)v11 + 2);
            *(_OWORD *)long long v13 = v14;
            uint64_t v15 = ++v89;
            if (v87[0])
            {
              int v76 = 3;
              uint64_t v77 = " to be one of: ";
              uint64_t v78 = 15;
              long long v16 = &v76;
              uint64_t v17 = v88;
              if (v15 >= v90)
              {
                unint64_t v58 = v15 + 1;
                BOOL v59 = &v88[6 * v15] > &v76;
                if (v88 <= &v76 && v59)
                {
                  int64_t v68 = (char *)&v76 - (char *)v88;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v58, 24);
                  uint64_t v17 = v88;
                  long long v16 = (int *)((char *)v88 + v68);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v58, 24);
                  long long v16 = &v76;
                  uint64_t v17 = v88;
                }
              }
              long long v18 = &v17[6 * v89];
              long long v19 = *(_OWORD *)v16;
              *((void *)v18 + 2) = *((void *)v16 + 2);
              *(_OWORD *)long long v18 = v19;
              uint64_t v20 = ++v89;
              if (v87[0])
              {
                int v76 = 3;
                uint64_t v77 = "inv_cdf";
                uint64_t v78 = 7;
                long long v21 = &v76;
                uint64_t v22 = v88;
                if (v20 >= v90)
                {
                  unint64_t v60 = v20 + 1;
                  BOOL v61 = &v88[6 * v20] > &v76;
                  if (v88 <= &v76 && v61)
                  {
                    int64_t v69 = (char *)&v76 - (char *)v88;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v60, 24);
                    uint64_t v22 = v88;
                    long long v21 = (int *)((char *)v88 + v69);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v60, 24);
                    long long v21 = &v76;
                    uint64_t v22 = v88;
                  }
                }
                long long v23 = &v22[6 * v89];
                long long v24 = *(_OWORD *)v21;
                *((void *)v23 + 2) = *((void *)v21 + 2);
                *(_OWORD *)long long v23 = v24;
                uint64_t v25 = ++v89;
                if (v87[0])
                {
                  int v76 = 3;
                  uint64_t v77 = ", ";
                  uint64_t v78 = 2;
                  long long v26 = &v76;
                  uint64_t v27 = v88;
                  if (v25 >= v90)
                  {
                    unint64_t v62 = v25 + 1;
                    BOOL v63 = &v88[6 * v25] > &v76;
                    if (v88 <= &v76 && v63)
                    {
                      int64_t v70 = (char *)&v76 - (char *)v88;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v62, 24);
                      uint64_t v27 = v88;
                      long long v26 = (int *)((char *)v88 + v70);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v62, 24);
                      long long v26 = &v76;
                      uint64_t v27 = v88;
                    }
                  }
                  long long v28 = &v27[6 * v89];
                  long long v29 = *(_OWORD *)v26;
                  *((void *)v28 + 2) = *((void *)v26 + 2);
                  *(_OWORD *)long long v28 = v29;
                  uint64_t v30 = ++v89;
                  if (v87[0])
                  {
                    int v76 = 3;
                    uint64_t v77 = "box_muller";
                    uint64_t v78 = 10;
                    long long v31 = &v76;
                    uint64_t v32 = v88;
                    if (v30 >= v90)
                    {
                      unint64_t v64 = v30 + 1;
                      BOOL v65 = &v88[6 * v30] > &v76;
                      if (v88 <= &v76 && v65)
                      {
                        int64_t v71 = (char *)&v76 - (char *)v88;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v64, 24);
                        uint64_t v32 = v88;
                        long long v31 = (int *)((char *)v88 + v71);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v64, 24);
                        long long v31 = &v76;
                        uint64_t v32 = v88;
                      }
                    }
                    long long v33 = &v32[6 * v89];
                    long long v34 = *(_OWORD *)v31;
                    *((void *)v33 + 2) = *((void *)v31 + 2);
                    *(_OWORD *)long long v33 = v34;
                    ++v89;
                  }
                }
              }
            }
          }
        }
        mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v87);
        if (v87[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v87);
        }
        if (v96)
        {
          uint64_t v35 = v94;
          if (v94)
          {
            long long v36 = v95;
            uint64_t v37 = v94;
            if (v95 != v94)
            {
              do
                long long v36 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v36 - 1);
              while (v36 != v35);
              uint64_t v37 = v94;
            }
            unint64_t v95 = v35;
            operator delete(v37);
          }
          uint64_t v38 = v92;
          if (v92)
          {
            long long v39 = v93;
            uint64_t v40 = v92;
            if (v93 != v92)
            {
              do
              {
                uint64_t v42 = (void *)*--v39;
                long long v41 = v42;
                void *v39 = 0;
                if (v42) {
                  operator delete[](v41);
                }
              }
              while (v39 != v38);
              uint64_t v40 = v92;
            }
            uint64_t v93 = v38;
            operator delete(v40);
          }
          if (v88 != (int *)v91) {
            free(v88);
          }
        }
        goto LABEL_46;
      }
      unsigned int v4 = 0;
    }
    if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
    {
      uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v72[0] = v4;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v87[0] = &mlir::detail::TypeIDResolver<mlir::mps::NormalSamplingMethodAttr,void>::id;
      v87[1] = Context;
      return mlir::StorageUniquer::get<mlir::mps::detail::NormalSamplingMethodAttrStorage,mlir::mps::NormalSamplingMethod>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail31NormalSamplingMethodAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_24NormalSamplingMethodAttrEJNS2_20NormalSamplingMethodEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v87, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::NormalSamplingMethodAttr,void>::id, v72);
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::NormalSamplingMethodAttr::print(mlir::mps::NormalSamplingMethodAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }
  else
  {
    unsigned char *v5 = 60;
    ++*((void *)v4 + 4);
  }
  int v6 = *(_DWORD *)(*(void *)this + 8);
  char v7 = "";
  uint64_t v8 = 10;
  if (v6 == 1) {
    char v7 = "box_muller";
  }
  else {
    uint64_t v8 = 0;
  }
  if (v6) {
    BOOL v9 = v6 != 1;
  }
  else {
    BOOL v9 = 0;
  }
  if (v6) {
    size_t v10 = v8;
  }
  else {
    size_t v10 = 7;
  }
  if (v6) {
    long long v11 = v7;
  }
  else {
    long long v11 = "inv_cdf";
  }
  uint64_t v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (void *)*((void *)v12 + 4);
  if (v10 <= *((void *)v12 + 3) - (void)v13)
  {
    if (!v9)
    {
      memcpy(v13, v11, v10);
      *((void *)v12 + 4) += v10;
    }
  }
  else
  {
    llvm::raw_ostream::write(v12, v11, v10);
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v15 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v15)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    *uint64_t v15 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::PaddingStyleAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v5);
}

uint64_t mlir::mps::PaddingStyleAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v144 = *MEMORY[0x1E4F143B8];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1)) {
    return 0;
  }
  uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  uint64_t v121 = 0;
  uint64_t v122 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v121))
  {
LABEL_49:
    uint64_t v75 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    LOWORD(v136) = 259;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v126, a1, v75, v134);
    if (v126[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v126);
    }
    if (v133)
    {
      int v76 = (void **)__p;
      if (__p)
      {
        uint64_t v77 = v132;
        uint64_t v78 = __p;
        if (v132 != __p)
        {
          do
            uint64_t v77 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v77 - 1);
          while (v77 != v76);
          uint64_t v78 = __p;
        }
        int64_t v132 = v76;
        operator delete(v78);
      }
      int64_t v79 = v129;
      if (v129)
      {
        int64_t v80 = v130;
        uint64_t v81 = v129;
        if (v130 != v129)
        {
          do
          {
            int64_t v83 = (void *)*--v80;
            uint64_t v82 = v83;
            *int64_t v80 = 0;
            if (v83) {
              operator delete[](v82);
            }
          }
          while (v80 != v79);
          uint64_t v81 = v129;
        }
        int64_t v130 = v79;
        operator delete(v81);
      }
      if (v127 != &v128) {
        free(v127);
      }
    }
    return 0;
  }
  uint64_t v3 = mlir::mps::symbolizePaddingStyle(v121, v122);
  if ((v3 & 0xFF00000000) == 0)
  {
    __int16 v120 = 257;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v134, a1, v2, v119);
    if (v134[0])
    {
      int v123 = 3;
      int64_t v124 = "expected ";
      uint64_t v125 = 9;
      uint64_t v8 = &v123;
      BOOL v9 = v135;
      if (v136 >= v137)
      {
        unint64_t v84 = v136 + 1;
        if (v135 <= &v123 && &v135[6 * v136] > &v123)
        {
          int64_t v107 = (char *)&v123 - (char *)v135;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v84, 24);
          BOOL v9 = v135;
          uint64_t v8 = (int *)((char *)v135 + v107);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v84, 24);
          uint64_t v8 = &v123;
          BOOL v9 = v135;
        }
      }
      size_t v10 = &v9[6 * v136];
      long long v11 = *(_OWORD *)v8;
      *((void *)v10 + 2) = *((void *)v8 + 2);
      *(_OWORD *)size_t v10 = v11;
      uint64_t v12 = ++v136;
      if (v134[0])
      {
        int v123 = 3;
        int64_t v124 = "::mlir::mps::PaddingStyle";
        uint64_t v125 = 25;
        long long v13 = &v123;
        long long v14 = v135;
        if (v12 >= v137)
        {
          unint64_t v85 = v12 + 1;
          BOOL v86 = &v135[6 * v12] > &v123;
          if (v135 <= &v123 && v86)
          {
            int64_t v108 = (char *)&v123 - (char *)v135;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v85, 24);
            long long v14 = v135;
            long long v13 = (int *)((char *)v135 + v108);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v85, 24);
            long long v13 = &v123;
            long long v14 = v135;
          }
        }
        uint64_t v15 = &v14[6 * v136];
        long long v16 = *(_OWORD *)v13;
        *((void *)v15 + 2) = *((void *)v13 + 2);
        *(_OWORD *)uint64_t v15 = v16;
        uint64_t v17 = ++v136;
        if (v134[0])
        {
          int v123 = 3;
          int64_t v124 = " to be one of: ";
          uint64_t v125 = 15;
          long long v18 = &v123;
          long long v19 = v135;
          if (v17 >= v137)
          {
            unint64_t v87 = v17 + 1;
            BOOL v88 = &v135[6 * v17] > &v123;
            if (v135 <= &v123 && v88)
            {
              int64_t v109 = (char *)&v123 - (char *)v135;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v87, 24);
              long long v19 = v135;
              long long v18 = (int *)((char *)v135 + v109);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v87, 24);
              long long v18 = &v123;
              long long v19 = v135;
            }
          }
          uint64_t v20 = &v19[6 * v136];
          long long v21 = *(_OWORD *)v18;
          *((void *)v20 + 2) = *((void *)v18 + 2);
          *(_OWORD *)uint64_t v20 = v21;
          uint64_t v22 = ++v136;
          if (v134[0])
          {
            int v123 = 3;
            int64_t v124 = "EXPLICIT";
            uint64_t v125 = 8;
            long long v23 = &v123;
            long long v24 = v135;
            if (v22 >= v137)
            {
              unint64_t v89 = v22 + 1;
              BOOL v90 = &v135[6 * v22] > &v123;
              if (v135 <= &v123 && v90)
              {
                int64_t v110 = (char *)&v123 - (char *)v135;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v89, 24);
                long long v24 = v135;
                long long v23 = (int *)((char *)v135 + v110);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v89, 24);
                long long v23 = &v123;
                long long v24 = v135;
              }
            }
            uint64_t v25 = &v24[6 * v136];
            long long v26 = *(_OWORD *)v23;
            *((void *)v25 + 2) = *((void *)v23 + 2);
            *(_OWORD *)uint64_t v25 = v26;
            uint64_t v27 = ++v136;
            if (v134[0])
            {
              int v123 = 3;
              int64_t v124 = ", ";
              uint64_t v125 = 2;
              long long v28 = &v123;
              long long v29 = v135;
              if (v27 >= v137)
              {
                unint64_t v91 = v27 + 1;
                BOOL v92 = &v135[6 * v27] > &v123;
                if (v135 <= &v123 && v92)
                {
                  int64_t v111 = (char *)&v123 - (char *)v135;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v91, 24);
                  long long v29 = v135;
                  long long v28 = (int *)((char *)v135 + v111);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v91, 24);
                  long long v28 = &v123;
                  long long v29 = v135;
                }
              }
              uint64_t v30 = &v29[6 * v136];
              long long v31 = *(_OWORD *)v28;
              *((void *)v30 + 2) = *((void *)v28 + 2);
              *(_OWORD *)uint64_t v30 = v31;
              uint64_t v32 = ++v136;
              if (v134[0])
              {
                int v123 = 3;
                int64_t v124 = "TF_VALID";
                uint64_t v125 = 8;
                long long v33 = &v123;
                long long v34 = v135;
                if (v32 >= v137)
                {
                  unint64_t v93 = v32 + 1;
                  BOOL v94 = &v135[6 * v32] > &v123;
                  if (v135 <= &v123 && v94)
                  {
                    int64_t v112 = (char *)&v123 - (char *)v135;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v93, 24);
                    long long v34 = v135;
                    long long v33 = (int *)((char *)v135 + v112);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v93, 24);
                    long long v33 = &v123;
                    long long v34 = v135;
                  }
                }
                uint64_t v35 = &v34[6 * v136];
                long long v36 = *(_OWORD *)v33;
                *((void *)v35 + 2) = *((void *)v33 + 2);
                *(_OWORD *)uint64_t v35 = v36;
                uint64_t v37 = ++v136;
                if (v134[0])
                {
                  int v123 = 3;
                  int64_t v124 = ", ";
                  uint64_t v125 = 2;
                  uint64_t v38 = &v123;
                  long long v39 = v135;
                  if (v37 >= v137)
                  {
                    unint64_t v95 = v37 + 1;
                    BOOL v96 = &v135[6 * v37] > &v123;
                    if (v135 <= &v123 && v96)
                    {
                      int64_t v113 = (char *)&v123 - (char *)v135;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v95, 24);
                      long long v39 = v135;
                      uint64_t v38 = (int *)((char *)v135 + v113);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v95, 24);
                      uint64_t v38 = &v123;
                      long long v39 = v135;
                    }
                  }
                  uint64_t v40 = &v39[6 * v136];
                  long long v41 = *(_OWORD *)v38;
                  *((void *)v40 + 2) = *((void *)v38 + 2);
                  *(_OWORD *)uint64_t v40 = v41;
                  uint64_t v42 = ++v136;
                  if (v134[0])
                  {
                    int v123 = 3;
                    int64_t v124 = "TF_SAME";
                    uint64_t v125 = 7;
                    uint64_t v43 = &v123;
                    long long v44 = v135;
                    if (v42 >= v137)
                    {
                      unint64_t v97 = v42 + 1;
                      BOOL v98 = &v135[6 * v42] > &v123;
                      if (v135 <= &v123 && v98)
                      {
                        int64_t v114 = (char *)&v123 - (char *)v135;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v97, 24);
                        long long v44 = v135;
                        uint64_t v43 = (int *)((char *)v135 + v114);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v97, 24);
                        uint64_t v43 = &v123;
                        long long v44 = v135;
                      }
                    }
                    long long v45 = &v44[6 * v136];
                    long long v46 = *(_OWORD *)v43;
                    *((void *)v45 + 2) = *((void *)v43 + 2);
                    *(_OWORD *)long long v45 = v46;
                    uint64_t v47 = ++v136;
                    if (v134[0])
                    {
                      int v123 = 3;
                      int64_t v124 = ", ";
                      uint64_t v125 = 2;
                      uint64_t v48 = &v123;
                      uint64_t v49 = v135;
                      if (v47 >= v137)
                      {
                        unint64_t v99 = v47 + 1;
                        BOOL v100 = &v135[6 * v47] > &v123;
                        if (v135 <= &v123 && v100)
                        {
                          int64_t v115 = (char *)&v123 - (char *)v135;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v99, 24);
                          uint64_t v49 = v135;
                          uint64_t v48 = (int *)((char *)v135 + v115);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v99, 24);
                          uint64_t v48 = &v123;
                          uint64_t v49 = v135;
                        }
                      }
                      long long v50 = &v49[6 * v136];
                      long long v51 = *(_OWORD *)v48;
                      *((void *)v50 + 2) = *((void *)v48 + 2);
                      *(_OWORD *)long long v50 = v51;
                      uint64_t v52 = ++v136;
                      if (v134[0])
                      {
                        int v123 = 3;
                        int64_t v124 = "EXPLICIT_OFFSET";
                        uint64_t v125 = 15;
                        unsigned int v53 = &v123;
                        uint64_t v54 = v135;
                        if (v52 >= v137)
                        {
                          unint64_t v101 = v52 + 1;
                          BOOL v102 = &v135[6 * v52] > &v123;
                          if (v135 <= &v123 && v102)
                          {
                            int64_t v116 = (char *)&v123 - (char *)v135;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v101, 24);
                            uint64_t v54 = v135;
                            unsigned int v53 = (int *)((char *)v135 + v116);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v101, 24);
                            unsigned int v53 = &v123;
                            uint64_t v54 = v135;
                          }
                        }
                        unint64_t v55 = &v54[6 * v136];
                        long long v56 = *(_OWORD *)v53;
                        *((void *)v55 + 2) = *((void *)v53 + 2);
                        *(_OWORD *)unint64_t v55 = v56;
                        uint64_t v57 = ++v136;
                        if (v134[0])
                        {
                          int v123 = 3;
                          int64_t v124 = ", ";
                          uint64_t v125 = 2;
                          unint64_t v58 = &v123;
                          BOOL v59 = v135;
                          if (v57 >= v137)
                          {
                            unint64_t v103 = v57 + 1;
                            BOOL v104 = &v135[6 * v57] > &v123;
                            if (v135 <= &v123 && v104)
                            {
                              int64_t v117 = (char *)&v123 - (char *)v135;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v103, 24);
                              BOOL v59 = v135;
                              unint64_t v58 = (int *)((char *)v135 + v117);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v103, 24);
                              unint64_t v58 = &v123;
                              BOOL v59 = v135;
                            }
                          }
                          unint64_t v60 = &v59[6 * v136];
                          long long v61 = *(_OWORD *)v58;
                          *((void *)v60 + 2) = *((void *)v58 + 2);
                          *(_OWORD *)unint64_t v60 = v61;
                          uint64_t v62 = ++v136;
                          if (v134[0])
                          {
                            int v123 = 3;
                            int64_t v124 = "ONNX_SAME_LOWER";
                            uint64_t v125 = 15;
                            BOOL v63 = &v123;
                            unint64_t v64 = v135;
                            if (v62 >= v137)
                            {
                              unint64_t v105 = v62 + 1;
                              BOOL v106 = &v135[6 * v62] > &v123;
                              if (v135 <= &v123 && v106)
                              {
                                int64_t v118 = (char *)&v123 - (char *)v135;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v105, 24);
                                unint64_t v64 = v135;
                                BOOL v63 = (int *)((char *)v135 + v118);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v105, 24);
                                BOOL v63 = &v123;
                                unint64_t v64 = v135;
                              }
                            }
                            BOOL v65 = &v64[6 * v136];
                            long long v66 = *(_OWORD *)v63;
                            *((void *)v65 + 2) = *((void *)v63 + 2);
                            *(_OWORD *)BOOL v65 = v66;
                            ++v136;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v134);
    if (v134[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v134);
    }
    if (v143)
    {
      int64_t v67 = v141;
      if (v141)
      {
        int64_t v68 = v142;
        int64_t v69 = v141;
        if (v142 != v141)
        {
          do
            int64_t v68 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v68 - 1);
          while (v68 != v67);
          int64_t v69 = v141;
        }
        BOOL v142 = v67;
        operator delete(v69);
      }
      int64_t v70 = v139;
      if (v139)
      {
        int64_t v71 = v140;
        uint64_t v72 = v139;
        if (v140 != v139)
        {
          do
          {
            uint64_t v74 = (void *)*--v71;
            __int16 v73 = v74;
            *int64_t v71 = 0;
            if (v74) {
              operator delete[](v73);
            }
          }
          while (v71 != v70);
          uint64_t v72 = v139;
        }
        BOOL v140 = v70;
        operator delete(v72);
      }
      if (v135 != (int *)v138) {
        free(v135);
      }
    }
    goto LABEL_49;
  }
  unsigned int v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v119[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v134[0] = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
    v134[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v134, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, v119);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::PaddingStyleAttr::print(mlir::mps::PaddingStyleAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6 > 4)
    {
LABEL_6:
      size_t v9 = 0;
      uint64_t v8 = "";
      char v7 = 1;
      goto LABEL_11;
    }
  }
  else
  {
    unsigned char *v5 = 60;
    ++*((void *)v4 + 4);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
  }
  char v7 = 0;
  uint64_t v8 = "EXPLICIT";
  size_t v9 = 8;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      char v7 = 0;
      uint64_t v8 = "TF_VALID";
      size_t v9 = 8;
      break;
    case 2u:
      char v7 = 0;
      uint64_t v8 = "TF_SAME";
      size_t v9 = 7;
      break;
    case 3u:
      char v7 = 0;
      uint64_t v8 = "EXPLICIT_OFFSET";
      goto LABEL_10;
    case 4u:
      char v7 = 0;
      uint64_t v8 = "ONNX_SAME_LOWER";
LABEL_10:
      size_t v9 = 15;
      break;
    default:
      goto LABEL_6;
  }
LABEL_11:
  size_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v11 = (void *)*((void *)v10 + 4);
  if (v9 <= *((void *)v10 + 3) - (void)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((void *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    unsigned char *v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::PoolIndicesModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::PoolIndicesModeAttrStorage,mlir::mps::PoolIndicesMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail26PoolIndicesModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_19PoolIndicesModeAttrEJNS2_15PoolIndicesModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::PoolIndicesModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v192 = *MEMORY[0x1E4F143B8];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1)) {
    return 0;
  }
  uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  BOOL v169 = 0;
  uint64_t v170 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v169))
  {
LABEL_61:
    uint64_t v105 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    LOWORD(v184) = 259;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v174, a1, v105, v182);
    if (v174[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v174);
    }
    if (v181)
    {
      BOOL v106 = (void **)__p;
      if (__p)
      {
        int64_t v107 = v180;
        int64_t v108 = __p;
        if (v180 != __p)
        {
          do
            int64_t v107 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v107 - 1);
          while (v107 != v106);
          int64_t v108 = __p;
        }
        unint64_t v180 = v106;
        operator delete(v108);
      }
      int64_t v109 = v177;
      if (v177)
      {
        int64_t v110 = v178;
        int64_t v111 = v177;
        if (v178 != v177)
        {
          do
          {
            int64_t v113 = (void *)*--v110;
            int64_t v112 = v113;
            void *v110 = 0;
            if (v113) {
              operator delete[](v112);
            }
          }
          while (v110 != v109);
          int64_t v111 = v177;
        }
        BOOL v178 = v109;
        operator delete(v111);
      }
      if (v175 != &v176) {
        free(v175);
      }
    }
    return 0;
  }
  uint64_t v3 = mlir::mps::symbolizePoolIndicesMode(v169, v170);
  if ((v3 & 0xFF00000000) == 0)
  {
    __int16 v168 = 257;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v182, a1, v2, v167);
    if (v182[0])
    {
      int v171 = 3;
      BOOL v172 = "expected ";
      uint64_t v173 = 9;
      uint64_t v8 = &v171;
      size_t v9 = v183;
      if (v184 >= v185)
      {
        unint64_t v114 = v184 + 1;
        if (v183 <= &v171 && &v183[6 * v184] > &v171)
        {
          int64_t v147 = (char *)&v171 - (char *)v183;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v114, 24);
          size_t v9 = v183;
          uint64_t v8 = (int *)((char *)v183 + v147);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v114, 24);
          uint64_t v8 = &v171;
          size_t v9 = v183;
        }
      }
      size_t v10 = &v9[6 * v184];
      long long v11 = *(_OWORD *)v8;
      *((void *)v10 + 2) = *((void *)v8 + 2);
      *(_OWORD *)size_t v10 = v11;
      uint64_t v12 = ++v184;
      if (v182[0])
      {
        int v171 = 3;
        BOOL v172 = "::mlir::mps::PoolIndicesMode";
        uint64_t v173 = 28;
        long long v13 = &v171;
        long long v14 = v183;
        if (v12 >= v185)
        {
          unint64_t v115 = v12 + 1;
          BOOL v116 = &v183[6 * v12] > &v171;
          if (v183 <= &v171 && v116)
          {
            int64_t v150 = (char *)&v171 - (char *)v183;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v115, 24);
            long long v14 = v183;
            long long v13 = (int *)((char *)v183 + v150);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v115, 24);
            long long v13 = &v171;
            long long v14 = v183;
          }
        }
        uint64_t v15 = &v14[6 * v184];
        long long v16 = *(_OWORD *)v13;
        *((void *)v15 + 2) = *((void *)v13 + 2);
        *(_OWORD *)uint64_t v15 = v16;
        uint64_t v17 = ++v184;
        if (v182[0])
        {
          int v171 = 3;
          BOOL v172 = " to be one of: ";
          uint64_t v173 = 15;
          long long v18 = &v171;
          long long v19 = v183;
          if (v17 >= v185)
          {
            unint64_t v117 = v17 + 1;
            BOOL v118 = &v183[6 * v17] > &v171;
            if (v183 <= &v171 && v118)
            {
              int64_t v151 = (char *)&v171 - (char *)v183;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v117, 24);
              long long v19 = v183;
              long long v18 = (int *)((char *)v183 + v151);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v117, 24);
              long long v18 = &v171;
              long long v19 = v183;
            }
          }
          uint64_t v20 = &v19[6 * v184];
          long long v21 = *(_OWORD *)v18;
          *((void *)v20 + 2) = *((void *)v18 + 2);
          *(_OWORD *)uint64_t v20 = v21;
          uint64_t v22 = ++v184;
          if (v182[0])
          {
            int v171 = 3;
            BOOL v172 = "Global_Flatten1D";
            uint64_t v173 = 16;
            long long v23 = &v171;
            long long v24 = v183;
            if (v22 >= v185)
            {
              unint64_t v119 = v22 + 1;
              BOOL v120 = &v183[6 * v22] > &v171;
              if (v183 <= &v171 && v120)
              {
                int64_t v152 = (char *)&v171 - (char *)v183;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v119, 24);
                long long v24 = v183;
                long long v23 = (int *)((char *)v183 + v152);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v119, 24);
                long long v23 = &v171;
                long long v24 = v183;
              }
            }
            uint64_t v25 = &v24[6 * v184];
            long long v26 = *(_OWORD *)v23;
            *((void *)v25 + 2) = *((void *)v23 + 2);
            *(_OWORD *)uint64_t v25 = v26;
            uint64_t v27 = ++v184;
            if (v182[0])
            {
              int v171 = 3;
              BOOL v172 = ", ";
              uint64_t v173 = 2;
              long long v28 = &v171;
              long long v29 = v183;
              if (v27 >= v185)
              {
                unint64_t v121 = v27 + 1;
                BOOL v122 = &v183[6 * v27] > &v171;
                if (v183 <= &v171 && v122)
                {
                  int64_t v153 = (char *)&v171 - (char *)v183;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v121, 24);
                  long long v29 = v183;
                  long long v28 = (int *)((char *)v183 + v153);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v121, 24);
                  long long v28 = &v171;
                  long long v29 = v183;
                }
              }
              uint64_t v30 = &v29[6 * v184];
              long long v31 = *(_OWORD *)v28;
              *((void *)v30 + 2) = *((void *)v28 + 2);
              *(_OWORD *)uint64_t v30 = v31;
              uint64_t v32 = ++v184;
              if (v182[0])
              {
                int v171 = 3;
                BOOL v172 = "Global_Flatten2D";
                uint64_t v173 = 16;
                long long v33 = &v171;
                long long v34 = v183;
                if (v32 >= v185)
                {
                  unint64_t v123 = v32 + 1;
                  BOOL v124 = &v183[6 * v32] > &v171;
                  if (v183 <= &v171 && v124)
                  {
                    int64_t v154 = (char *)&v171 - (char *)v183;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v123, 24);
                    long long v34 = v183;
                    long long v33 = (int *)((char *)v183 + v154);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v123, 24);
                    long long v33 = &v171;
                    long long v34 = v183;
                  }
                }
                uint64_t v35 = &v34[6 * v184];
                long long v36 = *(_OWORD *)v33;
                *((void *)v35 + 2) = *((void *)v33 + 2);
                *(_OWORD *)uint64_t v35 = v36;
                uint64_t v37 = ++v184;
                if (v182[0])
                {
                  int v171 = 3;
                  BOOL v172 = ", ";
                  uint64_t v173 = 2;
                  uint64_t v38 = &v171;
                  long long v39 = v183;
                  if (v37 >= v185)
                  {
                    unint64_t v125 = v37 + 1;
                    BOOL v126 = &v183[6 * v37] > &v171;
                    if (v183 <= &v171 && v126)
                    {
                      int64_t v155 = (char *)&v171 - (char *)v183;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v125, 24);
                      long long v39 = v183;
                      uint64_t v38 = (int *)((char *)v183 + v155);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v125, 24);
                      uint64_t v38 = &v171;
                      long long v39 = v183;
                    }
                  }
                  uint64_t v40 = &v39[6 * v184];
                  long long v41 = *(_OWORD *)v38;
                  *((void *)v40 + 2) = *((void *)v38 + 2);
                  *(_OWORD *)uint64_t v40 = v41;
                  uint64_t v42 = ++v184;
                  if (v182[0])
                  {
                    int v171 = 3;
                    BOOL v172 = "Global_Flatten3D";
                    uint64_t v173 = 16;
                    uint64_t v43 = &v171;
                    long long v44 = v183;
                    if (v42 >= v185)
                    {
                      unint64_t v127 = v42 + 1;
                      BOOL v128 = &v183[6 * v42] > &v171;
                      if (v183 <= &v171 && v128)
                      {
                        int64_t v156 = (char *)&v171 - (char *)v183;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v127, 24);
                        long long v44 = v183;
                        uint64_t v43 = (int *)((char *)v183 + v156);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v127, 24);
                        uint64_t v43 = &v171;
                        long long v44 = v183;
                      }
                    }
                    long long v45 = &v44[6 * v184];
                    long long v46 = *(_OWORD *)v43;
                    *((void *)v45 + 2) = *((void *)v43 + 2);
                    *(_OWORD *)long long v45 = v46;
                    uint64_t v47 = ++v184;
                    if (v182[0])
                    {
                      int v171 = 3;
                      BOOL v172 = ", ";
                      uint64_t v173 = 2;
                      uint64_t v48 = &v171;
                      uint64_t v49 = v183;
                      if (v47 >= v185)
                      {
                        unint64_t v129 = v47 + 1;
                        BOOL v130 = &v183[6 * v47] > &v171;
                        if (v183 <= &v171 && v130)
                        {
                          int64_t v157 = (char *)&v171 - (char *)v183;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v129, 24);
                          uint64_t v49 = v183;
                          uint64_t v48 = (int *)((char *)v183 + v157);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v129, 24);
                          uint64_t v48 = &v171;
                          uint64_t v49 = v183;
                        }
                      }
                      long long v50 = &v49[6 * v184];
                      long long v51 = *(_OWORD *)v48;
                      *((void *)v50 + 2) = *((void *)v48 + 2);
                      *(_OWORD *)long long v50 = v51;
                      uint64_t v52 = ++v184;
                      if (v182[0])
                      {
                        int v171 = 3;
                        BOOL v172 = "Global_Flatten4D";
                        uint64_t v173 = 16;
                        unsigned int v53 = &v171;
                        uint64_t v54 = v183;
                        if (v52 >= v185)
                        {
                          unint64_t v131 = v52 + 1;
                          BOOL v132 = &v183[6 * v52] > &v171;
                          if (v183 <= &v171 && v132)
                          {
                            int64_t v158 = (char *)&v171 - (char *)v183;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v131, 24);
                            uint64_t v54 = v183;
                            unsigned int v53 = (int *)((char *)v183 + v158);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v131, 24);
                            unsigned int v53 = &v171;
                            uint64_t v54 = v183;
                          }
                        }
                        unint64_t v55 = &v54[6 * v184];
                        long long v56 = *(_OWORD *)v53;
                        *((void *)v55 + 2) = *((void *)v53 + 2);
                        *(_OWORD *)unint64_t v55 = v56;
                        uint64_t v57 = ++v184;
                        if (v182[0])
                        {
                          int v171 = 3;
                          BOOL v172 = ", ";
                          uint64_t v173 = 2;
                          unint64_t v58 = &v171;
                          BOOL v59 = v183;
                          if (v57 >= v185)
                          {
                            unint64_t v133 = v57 + 1;
                            BOOL v134 = &v183[6 * v57] > &v171;
                            if (v183 <= &v171 && v134)
                            {
                              int64_t v159 = (char *)&v171 - (char *)v183;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v133, 24);
                              BOOL v59 = v183;
                              unint64_t v58 = (int *)((char *)v183 + v159);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v133, 24);
                              unint64_t v58 = &v171;
                              BOOL v59 = v183;
                            }
                          }
                          unint64_t v60 = &v59[6 * v184];
                          long long v61 = *(_OWORD *)v58;
                          *((void *)v60 + 2) = *((void *)v58 + 2);
                          *(_OWORD *)unint64_t v60 = v61;
                          uint64_t v62 = ++v184;
                          if (v182[0])
                          {
                            int v171 = 3;
                            BOOL v172 = "Local_Flatten1D";
                            uint64_t v173 = 15;
                            BOOL v63 = &v171;
                            unint64_t v64 = v183;
                            if (v62 >= v185)
                            {
                              unint64_t v135 = v62 + 1;
                              BOOL v136 = &v183[6 * v62] > &v171;
                              if (v183 <= &v171 && v136)
                              {
                                int64_t v160 = (char *)&v171 - (char *)v183;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v135, 24);
                                unint64_t v64 = v183;
                                BOOL v63 = (int *)((char *)v183 + v160);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v135, 24);
                                BOOL v63 = &v171;
                                unint64_t v64 = v183;
                              }
                            }
                            BOOL v65 = &v64[6 * v184];
                            long long v66 = *(_OWORD *)v63;
                            *((void *)v65 + 2) = *((void *)v63 + 2);
                            *(_OWORD *)BOOL v65 = v66;
                            uint64_t v67 = ++v184;
                            if (v182[0])
                            {
                              int v171 = 3;
                              BOOL v172 = ", ";
                              uint64_t v173 = 2;
                              int64_t v68 = &v171;
                              int64_t v69 = v183;
                              if (v67 >= v185)
                              {
                                unint64_t v137 = v67 + 1;
                                BOOL v138 = &v183[6 * v67] > &v171;
                                if (v183 <= &v171 && v138)
                                {
                                  int64_t v161 = (char *)&v171 - (char *)v183;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v137, 24);
                                  int64_t v69 = v183;
                                  int64_t v68 = (int *)((char *)v183 + v161);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v137, 24);
                                  int64_t v68 = &v171;
                                  int64_t v69 = v183;
                                }
                              }
                              int64_t v70 = &v69[6 * v184];
                              long long v71 = *(_OWORD *)v68;
                              *((void *)v70 + 2) = *((void *)v68 + 2);
                              *(_OWORD *)int64_t v70 = v71;
                              uint64_t v72 = ++v184;
                              if (v182[0])
                              {
                                int v171 = 3;
                                BOOL v172 = "Local_Flatten2D";
                                uint64_t v173 = 15;
                                __int16 v73 = &v171;
                                uint64_t v74 = v183;
                                if (v72 >= v185)
                                {
                                  unint64_t v139 = v72 + 1;
                                  BOOL v140 = &v183[6 * v72] > &v171;
                                  if (v183 <= &v171 && v140)
                                  {
                                    int64_t v162 = (char *)&v171 - (char *)v183;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v139, 24);
                                    uint64_t v74 = v183;
                                    __int16 v73 = (int *)((char *)v183 + v162);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v139, 24);
                                    __int16 v73 = &v171;
                                    uint64_t v74 = v183;
                                  }
                                }
                                uint64_t v75 = &v74[6 * v184];
                                long long v76 = *(_OWORD *)v73;
                                *((void *)v75 + 2) = *((void *)v73 + 2);
                                *(_OWORD *)uint64_t v75 = v76;
                                uint64_t v77 = ++v184;
                                if (v182[0])
                                {
                                  int v171 = 3;
                                  BOOL v172 = ", ";
                                  uint64_t v173 = 2;
                                  uint64_t v78 = &v171;
                                  int64_t v79 = v183;
                                  if (v77 >= v185)
                                  {
                                    unint64_t v141 = v77 + 1;
                                    BOOL v142 = &v183[6 * v77] > &v171;
                                    if (v183 <= &v171 && v142)
                                    {
                                      int64_t v163 = (char *)&v171 - (char *)v183;
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v141, 24);
                                      int64_t v79 = v183;
                                      uint64_t v78 = (int *)((char *)v183 + v163);
                                    }
                                    else
                                    {
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v141, 24);
                                      uint64_t v78 = &v171;
                                      int64_t v79 = v183;
                                    }
                                  }
                                  int64_t v80 = &v79[6 * v184];
                                  long long v81 = *(_OWORD *)v78;
                                  *((void *)v80 + 2) = *((void *)v78 + 2);
                                  *(_OWORD *)int64_t v80 = v81;
                                  uint64_t v82 = ++v184;
                                  if (v182[0])
                                  {
                                    int v171 = 3;
                                    BOOL v172 = "Local_Flatten3D";
                                    uint64_t v173 = 15;
                                    int64_t v83 = &v171;
                                    unint64_t v84 = v183;
                                    if (v82 >= v185)
                                    {
                                      unint64_t v143 = v82 + 1;
                                      BOOL v144 = &v183[6 * v82] > &v171;
                                      if (v183 <= &v171 && v144)
                                      {
                                        int64_t v164 = (char *)&v171 - (char *)v183;
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v143, 24);
                                        unint64_t v84 = v183;
                                        int64_t v83 = (int *)((char *)v183 + v164);
                                      }
                                      else
                                      {
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v143, 24);
                                        int64_t v83 = &v171;
                                        unint64_t v84 = v183;
                                      }
                                    }
                                    unint64_t v85 = &v84[6 * v184];
                                    long long v86 = *(_OWORD *)v83;
                                    *((void *)v85 + 2) = *((void *)v83 + 2);
                                    *(_OWORD *)unint64_t v85 = v86;
                                    uint64_t v87 = ++v184;
                                    if (v182[0])
                                    {
                                      int v171 = 3;
                                      BOOL v172 = ", ";
                                      uint64_t v173 = 2;
                                      BOOL v88 = &v171;
                                      unint64_t v89 = v183;
                                      if (v87 >= v185)
                                      {
                                        unint64_t v145 = v87 + 1;
                                        BOOL v146 = &v183[6 * v87] > &v171;
                                        if (v183 <= &v171 && v146)
                                        {
                                          int64_t v165 = (char *)&v171 - (char *)v183;
                                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v145, 24);
                                          unint64_t v89 = v183;
                                          BOOL v88 = (int *)((char *)v183 + v165);
                                        }
                                        else
                                        {
                                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v145, 24);
                                          BOOL v88 = &v171;
                                          unint64_t v89 = v183;
                                        }
                                      }
                                      BOOL v90 = &v89[6 * v184];
                                      long long v91 = *(_OWORD *)v88;
                                      *((void *)v90 + 2) = *((void *)v88 + 2);
                                      *(_OWORD *)BOOL v90 = v91;
                                      uint64_t v92 = ++v184;
                                      if (v182[0])
                                      {
                                        int v171 = 3;
                                        BOOL v172 = "Local_Flatten4D";
                                        uint64_t v173 = 15;
                                        unint64_t v93 = &v171;
                                        BOOL v94 = v183;
                                        if (v92 >= v185)
                                        {
                                          unint64_t v148 = v92 + 1;
                                          BOOL v149 = &v183[6 * v92] > &v171;
                                          if (v183 <= &v171 && v149)
                                          {
                                            int64_t v166 = (char *)&v171 - (char *)v183;
                                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v148, 24);
                                            BOOL v94 = v183;
                                            unint64_t v93 = (int *)((char *)v183 + v166);
                                          }
                                          else
                                          {
                                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v148, 24);
                                            unint64_t v93 = &v171;
                                            BOOL v94 = v183;
                                          }
                                        }
                                        unint64_t v95 = &v94[6 * v184];
                                        long long v96 = *(_OWORD *)v93;
                                        *((void *)v95 + 2) = *((void *)v93 + 2);
                                        *(_OWORD *)unint64_t v95 = v96;
                                        ++v184;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v182);
    if (v182[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v182);
    }
    if (v191)
    {
      unint64_t v97 = v189;
      if (v189)
      {
        BOOL v98 = v190;
        unint64_t v99 = v189;
        if (v190 != v189)
        {
          do
            BOOL v98 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v98 - 1);
          while (v98 != v97);
          unint64_t v99 = v189;
        }
        int64_t v190 = v97;
        operator delete(v99);
      }
      BOOL v100 = v187;
      if (v187)
      {
        unint64_t v101 = v188;
        BOOL v102 = v187;
        if (v188 != v187)
        {
          do
          {
            BOOL v104 = (void *)*--v101;
            unint64_t v103 = v104;
            *unint64_t v101 = 0;
            if (v104) {
              operator delete[](v103);
            }
          }
          while (v101 != v100);
          BOOL v102 = v187;
        }
        int64_t v188 = v100;
        operator delete(v102);
      }
      if (v183 != (int *)v186) {
        free(v183);
      }
    }
    goto LABEL_61;
  }
  unsigned int v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v167[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v182[0] = &mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id;
    v182[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::PoolIndicesModeAttrStorage,mlir::mps::PoolIndicesMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail26PoolIndicesModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_19PoolIndicesModeAttrEJNS2_15PoolIndicesModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v182, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id, v167);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::PoolIndicesModeAttr::print(mlir::mps::PoolIndicesModeAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6 > 7)
    {
LABEL_6:
      size_t v9 = 0;
      uint64_t v8 = "";
      char v7 = 1;
      goto LABEL_14;
    }
  }
  else
  {
    unsigned char *v5 = 60;
    ++*((void *)v4 + 4);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
  }
  char v7 = 0;
  uint64_t v8 = "Global_Flatten1D";
  size_t v9 = 16;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      char v7 = 0;
      uint64_t v8 = "Global_Flatten2D";
      size_t v9 = 16;
      break;
    case 2u:
      char v7 = 0;
      uint64_t v8 = "Global_Flatten3D";
      size_t v9 = 16;
      break;
    case 3u:
      char v7 = 0;
      uint64_t v8 = "Global_Flatten4D";
      size_t v9 = 16;
      break;
    case 4u:
      char v7 = 0;
      uint64_t v8 = "Local_Flatten1D";
      goto LABEL_13;
    case 5u:
      char v7 = 0;
      uint64_t v8 = "Local_Flatten2D";
      goto LABEL_13;
    case 6u:
      char v7 = 0;
      uint64_t v8 = "Local_Flatten3D";
      goto LABEL_13;
    case 7u:
      char v7 = 0;
      uint64_t v8 = "Local_Flatten4D";
LABEL_13:
      size_t v9 = 15;
      break;
    default:
      goto LABEL_6;
  }
LABEL_14:
  size_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v11 = (void *)*((void *)v10 + 4);
  if (v9 <= *((void *)v10 + 3) - (void)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((void *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    unsigned char *v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::RNNActivationAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v5);
}

uint64_t mlir::mps::RNNActivationAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v160 = *MEMORY[0x1E4F143B8];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1)) {
    return 0;
  }
  uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  unint64_t v137 = 0;
  uint64_t v138 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v137))
  {
LABEL_53:
    uint64_t v85 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    LOWORD(v152) = 259;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v142, a1, v85, v150);
    if (v142[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v142);
    }
    if (v149)
    {
      long long v86 = (void **)__p;
      if (__p)
      {
        uint64_t v87 = v148;
        BOOL v88 = __p;
        if (v148 != __p)
        {
          do
            uint64_t v87 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v87 - 1);
          while (v87 != v86);
          BOOL v88 = __p;
        }
        unint64_t v148 = v86;
        operator delete(v88);
      }
      unint64_t v89 = v145;
      if (v145)
      {
        BOOL v90 = v146;
        long long v91 = v145;
        if (v146 != v145)
        {
          do
          {
            unint64_t v93 = (void *)*--v90;
            uint64_t v92 = v93;
            *BOOL v90 = 0;
            if (v93) {
              operator delete[](v92);
            }
          }
          while (v90 != v89);
          long long v91 = v145;
        }
        BOOL v146 = v89;
        operator delete(v91);
      }
      if (v143 != &v144) {
        free(v143);
      }
    }
    return 0;
  }
  uint64_t v3 = mlir::mps::symbolizeRNNActivation(v137, v138);
  if ((v3 & 0xFF00000000) == 0)
  {
    __int16 v136 = 257;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v150, a1, v2, v135);
    if (v150[0])
    {
      int v139 = 3;
      BOOL v140 = "expected ";
      uint64_t v141 = 9;
      uint64_t v8 = &v139;
      size_t v9 = v151;
      if (v152 >= v153)
      {
        unint64_t v94 = v152 + 1;
        if (v151 <= &v139 && &v151[6 * v152] > &v139)
        {
          int64_t v121 = (char *)&v139 - (char *)v151;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v94, 24);
          size_t v9 = v151;
          uint64_t v8 = (int *)((char *)v151 + v121);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v94, 24);
          uint64_t v8 = &v139;
          size_t v9 = v151;
        }
      }
      size_t v10 = &v9[6 * v152];
      long long v11 = *(_OWORD *)v8;
      *((void *)v10 + 2) = *((void *)v8 + 2);
      *(_OWORD *)size_t v10 = v11;
      uint64_t v12 = ++v152;
      if (v150[0])
      {
        int v139 = 3;
        BOOL v140 = "::mlir::mps::RNNActivation";
        uint64_t v141 = 26;
        long long v13 = &v139;
        long long v14 = v151;
        if (v12 >= v153)
        {
          unint64_t v95 = v12 + 1;
          BOOL v96 = &v151[6 * v12] > &v139;
          if (v151 <= &v139 && v96)
          {
            int64_t v122 = (char *)&v139 - (char *)v151;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v95, 24);
            long long v14 = v151;
            long long v13 = (int *)((char *)v151 + v122);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v95, 24);
            long long v13 = &v139;
            long long v14 = v151;
          }
        }
        uint64_t v15 = &v14[6 * v152];
        long long v16 = *(_OWORD *)v13;
        *((void *)v15 + 2) = *((void *)v13 + 2);
        *(_OWORD *)uint64_t v15 = v16;
        uint64_t v17 = ++v152;
        if (v150[0])
        {
          int v139 = 3;
          BOOL v140 = " to be one of: ";
          uint64_t v141 = 15;
          long long v18 = &v139;
          long long v19 = v151;
          if (v17 >= v153)
          {
            unint64_t v97 = v17 + 1;
            BOOL v98 = &v151[6 * v17] > &v139;
            if (v151 <= &v139 && v98)
            {
              int64_t v123 = (char *)&v139 - (char *)v151;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v97, 24);
              long long v19 = v151;
              long long v18 = (int *)((char *)v151 + v123);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v97, 24);
              long long v18 = &v139;
              long long v19 = v151;
            }
          }
          uint64_t v20 = &v19[6 * v152];
          long long v21 = *(_OWORD *)v18;
          *((void *)v20 + 2) = *((void *)v18 + 2);
          *(_OWORD *)uint64_t v20 = v21;
          uint64_t v22 = ++v152;
          if (v150[0])
          {
            int v139 = 3;
            BOOL v140 = "none";
            uint64_t v141 = 4;
            long long v23 = &v139;
            long long v24 = v151;
            if (v22 >= v153)
            {
              unint64_t v99 = v22 + 1;
              BOOL v100 = &v151[6 * v22] > &v139;
              if (v151 <= &v139 && v100)
              {
                int64_t v124 = (char *)&v139 - (char *)v151;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v99, 24);
                long long v24 = v151;
                long long v23 = (int *)((char *)v151 + v124);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v99, 24);
                long long v23 = &v139;
                long long v24 = v151;
              }
            }
            uint64_t v25 = &v24[6 * v152];
            long long v26 = *(_OWORD *)v23;
            *((void *)v25 + 2) = *((void *)v23 + 2);
            *(_OWORD *)uint64_t v25 = v26;
            uint64_t v27 = ++v152;
            if (v150[0])
            {
              int v139 = 3;
              BOOL v140 = ", ";
              uint64_t v141 = 2;
              long long v28 = &v139;
              long long v29 = v151;
              if (v27 >= v153)
              {
                unint64_t v101 = v27 + 1;
                BOOL v102 = &v151[6 * v27] > &v139;
                if (v151 <= &v139 && v102)
                {
                  int64_t v125 = (char *)&v139 - (char *)v151;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v101, 24);
                  long long v29 = v151;
                  long long v28 = (int *)((char *)v151 + v125);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v101, 24);
                  long long v28 = &v139;
                  long long v29 = v151;
                }
              }
              uint64_t v30 = &v29[6 * v152];
              long long v31 = *(_OWORD *)v28;
              *((void *)v30 + 2) = *((void *)v28 + 2);
              *(_OWORD *)uint64_t v30 = v31;
              uint64_t v32 = ++v152;
              if (v150[0])
              {
                int v139 = 3;
                BOOL v140 = "relu";
                uint64_t v141 = 4;
                long long v33 = &v139;
                long long v34 = v151;
                if (v32 >= v153)
                {
                  unint64_t v103 = v32 + 1;
                  BOOL v104 = &v151[6 * v32] > &v139;
                  if (v151 <= &v139 && v104)
                  {
                    int64_t v126 = (char *)&v139 - (char *)v151;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v103, 24);
                    long long v34 = v151;
                    long long v33 = (int *)((char *)v151 + v126);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v103, 24);
                    long long v33 = &v139;
                    long long v34 = v151;
                  }
                }
                uint64_t v35 = &v34[6 * v152];
                long long v36 = *(_OWORD *)v33;
                *((void *)v35 + 2) = *((void *)v33 + 2);
                *(_OWORD *)uint64_t v35 = v36;
                uint64_t v37 = ++v152;
                if (v150[0])
                {
                  int v139 = 3;
                  BOOL v140 = ", ";
                  uint64_t v141 = 2;
                  uint64_t v38 = &v139;
                  long long v39 = v151;
                  if (v37 >= v153)
                  {
                    unint64_t v105 = v37 + 1;
                    BOOL v106 = &v151[6 * v37] > &v139;
                    if (v151 <= &v139 && v106)
                    {
                      int64_t v127 = (char *)&v139 - (char *)v151;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v105, 24);
                      long long v39 = v151;
                      uint64_t v38 = (int *)((char *)v151 + v127);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v105, 24);
                      uint64_t v38 = &v139;
                      long long v39 = v151;
                    }
                  }
                  uint64_t v40 = &v39[6 * v152];
                  long long v41 = *(_OWORD *)v38;
                  *((void *)v40 + 2) = *((void *)v38 + 2);
                  *(_OWORD *)uint64_t v40 = v41;
                  uint64_t v42 = ++v152;
                  if (v150[0])
                  {
                    int v139 = 3;
                    BOOL v140 = "tanh";
                    uint64_t v141 = 4;
                    uint64_t v43 = &v139;
                    long long v44 = v151;
                    if (v42 >= v153)
                    {
                      unint64_t v107 = v42 + 1;
                      BOOL v108 = &v151[6 * v42] > &v139;
                      if (v151 <= &v139 && v108)
                      {
                        int64_t v128 = (char *)&v139 - (char *)v151;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v107, 24);
                        long long v44 = v151;
                        uint64_t v43 = (int *)((char *)v151 + v128);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v107, 24);
                        uint64_t v43 = &v139;
                        long long v44 = v151;
                      }
                    }
                    long long v45 = &v44[6 * v152];
                    long long v46 = *(_OWORD *)v43;
                    *((void *)v45 + 2) = *((void *)v43 + 2);
                    *(_OWORD *)long long v45 = v46;
                    uint64_t v47 = ++v152;
                    if (v150[0])
                    {
                      int v139 = 3;
                      BOOL v140 = ", ";
                      uint64_t v141 = 2;
                      uint64_t v48 = &v139;
                      uint64_t v49 = v151;
                      if (v47 >= v153)
                      {
                        unint64_t v109 = v47 + 1;
                        BOOL v110 = &v151[6 * v47] > &v139;
                        if (v151 <= &v139 && v110)
                        {
                          int64_t v129 = (char *)&v139 - (char *)v151;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v109, 24);
                          uint64_t v49 = v151;
                          uint64_t v48 = (int *)((char *)v151 + v129);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v109, 24);
                          uint64_t v48 = &v139;
                          uint64_t v49 = v151;
                        }
                      }
                      long long v50 = &v49[6 * v152];
                      long long v51 = *(_OWORD *)v48;
                      *((void *)v50 + 2) = *((void *)v48 + 2);
                      *(_OWORD *)long long v50 = v51;
                      uint64_t v52 = ++v152;
                      if (v150[0])
                      {
                        int v139 = 3;
                        BOOL v140 = "sigmoid";
                        uint64_t v141 = 7;
                        unsigned int v53 = &v139;
                        uint64_t v54 = v151;
                        if (v52 >= v153)
                        {
                          unint64_t v111 = v52 + 1;
                          BOOL v112 = &v151[6 * v52] > &v139;
                          if (v151 <= &v139 && v112)
                          {
                            int64_t v130 = (char *)&v139 - (char *)v151;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v111, 24);
                            uint64_t v54 = v151;
                            unsigned int v53 = (int *)((char *)v151 + v130);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v111, 24);
                            unsigned int v53 = &v139;
                            uint64_t v54 = v151;
                          }
                        }
                        unint64_t v55 = &v54[6 * v152];
                        long long v56 = *(_OWORD *)v53;
                        *((void *)v55 + 2) = *((void *)v53 + 2);
                        *(_OWORD *)unint64_t v55 = v56;
                        uint64_t v57 = ++v152;
                        if (v150[0])
                        {
                          int v139 = 3;
                          BOOL v140 = ", ";
                          uint64_t v141 = 2;
                          unint64_t v58 = &v139;
                          BOOL v59 = v151;
                          if (v57 >= v153)
                          {
                            unint64_t v113 = v57 + 1;
                            BOOL v114 = &v151[6 * v57] > &v139;
                            if (v151 <= &v139 && v114)
                            {
                              int64_t v131 = (char *)&v139 - (char *)v151;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v113, 24);
                              BOOL v59 = v151;
                              unint64_t v58 = (int *)((char *)v151 + v131);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v113, 24);
                              unint64_t v58 = &v139;
                              BOOL v59 = v151;
                            }
                          }
                          unint64_t v60 = &v59[6 * v152];
                          long long v61 = *(_OWORD *)v58;
                          *((void *)v60 + 2) = *((void *)v58 + 2);
                          *(_OWORD *)unint64_t v60 = v61;
                          uint64_t v62 = ++v152;
                          if (v150[0])
                          {
                            int v139 = 3;
                            BOOL v140 = "hard_sigmoid";
                            uint64_t v141 = 12;
                            BOOL v63 = &v139;
                            unint64_t v64 = v151;
                            if (v62 >= v153)
                            {
                              unint64_t v115 = v62 + 1;
                              BOOL v116 = &v151[6 * v62] > &v139;
                              if (v151 <= &v139 && v116)
                              {
                                int64_t v132 = (char *)&v139 - (char *)v151;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v115, 24);
                                unint64_t v64 = v151;
                                BOOL v63 = (int *)((char *)v151 + v132);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v115, 24);
                                BOOL v63 = &v139;
                                unint64_t v64 = v151;
                              }
                            }
                            BOOL v65 = &v64[6 * v152];
                            long long v66 = *(_OWORD *)v63;
                            *((void *)v65 + 2) = *((void *)v63 + 2);
                            *(_OWORD *)BOOL v65 = v66;
                            uint64_t v67 = ++v152;
                            if (v150[0])
                            {
                              int v139 = 3;
                              BOOL v140 = ", ";
                              uint64_t v141 = 2;
                              int64_t v68 = &v139;
                              int64_t v69 = v151;
                              if (v67 >= v153)
                              {
                                unint64_t v117 = v67 + 1;
                                BOOL v118 = &v151[6 * v67] > &v139;
                                if (v151 <= &v139 && v118)
                                {
                                  int64_t v133 = (char *)&v139 - (char *)v151;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v117, 24);
                                  int64_t v69 = v151;
                                  int64_t v68 = (int *)((char *)v151 + v133);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v117, 24);
                                  int64_t v68 = &v139;
                                  int64_t v69 = v151;
                                }
                              }
                              int64_t v70 = &v69[6 * v152];
                              long long v71 = *(_OWORD *)v68;
                              *((void *)v70 + 2) = *((void *)v68 + 2);
                              *(_OWORD *)int64_t v70 = v71;
                              uint64_t v72 = ++v152;
                              if (v150[0])
                              {
                                int v139 = 3;
                                BOOL v140 = "scaled_tanh";
                                uint64_t v141 = 11;
                                __int16 v73 = &v139;
                                uint64_t v74 = v151;
                                if (v72 >= v153)
                                {
                                  unint64_t v119 = v72 + 1;
                                  BOOL v120 = &v151[6 * v72] > &v139;
                                  if (v151 <= &v139 && v120)
                                  {
                                    int64_t v134 = (char *)&v139 - (char *)v151;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v119, 24);
                                    uint64_t v74 = v151;
                                    __int16 v73 = (int *)((char *)v151 + v134);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v119, 24);
                                    __int16 v73 = &v139;
                                    uint64_t v74 = v151;
                                  }
                                }
                                uint64_t v75 = &v74[6 * v152];
                                long long v76 = *(_OWORD *)v73;
                                *((void *)v75 + 2) = *((void *)v73 + 2);
                                *(_OWORD *)uint64_t v75 = v76;
                                ++v152;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v150);
    if (v150[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v150);
    }
    if (v159)
    {
      uint64_t v77 = v157;
      if (v157)
      {
        uint64_t v78 = v158;
        int64_t v79 = v157;
        if (v158 != v157)
        {
          do
            uint64_t v78 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v78 - 1);
          while (v78 != v77);
          int64_t v79 = v157;
        }
        int64_t v158 = v77;
        operator delete(v79);
      }
      int64_t v80 = v155;
      if (v155)
      {
        long long v81 = v156;
        uint64_t v82 = v155;
        if (v156 != v155)
        {
          do
          {
            unint64_t v84 = (void *)*--v81;
            int64_t v83 = v84;
            *long long v81 = 0;
            if (v84) {
              operator delete[](v83);
            }
          }
          while (v81 != v80);
          uint64_t v82 = v155;
        }
        int64_t v156 = v80;
        operator delete(v82);
      }
      if (v151 != (int *)v154) {
        free(v151);
      }
    }
    goto LABEL_53;
  }
  unsigned int v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v135[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v150[0] = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
    v150[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v150, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, v135);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::RNNActivationAttr::print(mlir::mps::RNNActivationAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6 > 5)
    {
LABEL_6:
      size_t v9 = 0;
      uint64_t v8 = "";
      char v7 = 1;
      goto LABEL_11;
    }
  }
  else
  {
    unsigned char *v5 = 60;
    ++*((void *)v4 + 4);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
  }
  char v7 = 0;
  uint64_t v8 = "none";
  size_t v9 = 4;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      char v7 = 0;
      uint64_t v8 = "relu";
      size_t v9 = 4;
      break;
    case 2u:
      char v7 = 0;
      uint64_t v8 = "tanh";
      size_t v9 = 4;
      break;
    case 3u:
      char v7 = 0;
      uint64_t v8 = "sigmoid";
      size_t v9 = 7;
      break;
    case 4u:
      char v7 = 0;
      uint64_t v8 = "hard_sigmoid";
      size_t v9 = 12;
      break;
    case 5u:
      char v7 = 0;
      uint64_t v8 = "scaled_tanh";
      size_t v9 = 11;
      break;
    default:
      goto LABEL_6;
  }
LABEL_11:
  size_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v11 = (void *)*((void *)v10 + 4);
  if (v9 <= *((void *)v10 + 3) - (void)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((void *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    unsigned char *v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::LSTMGateLayoutAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::LSTMGateLayoutAttrStorage,mlir::mps::LSTMGateLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25LSTMGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18LSTMGateLayoutAttrEJNS2_14LSTMGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id, &v5);
}

uint64_t mlir::mps::LSTMGateLayoutAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v123 = *MEMORY[0x1E4F143B8];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1))
  {
    uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    BOOL v100 = 0;
    uint64_t v101 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v100))
    {
LABEL_48:
      uint64_t v61 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
      LOWORD(v115) = 259;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v105, a1, v61, v113);
      if (v105[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v105);
      }
      if (v112)
      {
        uint64_t v62 = (void **)__p;
        if (__p)
        {
          BOOL v63 = v111;
          unint64_t v64 = __p;
          if (v111 != __p)
          {
            do
              BOOL v63 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v63 - 1);
            while (v63 != v62);
            unint64_t v64 = __p;
          }
          unint64_t v111 = v62;
          operator delete(v64);
        }
        BOOL v65 = v108;
        if (v108)
        {
          long long v66 = v109;
          uint64_t v67 = v108;
          if (v109 != v108)
          {
            do
            {
              int64_t v69 = (void *)*--v66;
              int64_t v68 = v69;
              *long long v66 = 0;
              if (v69) {
                operator delete[](v68);
              }
            }
            while (v66 != v65);
            uint64_t v67 = v108;
          }
          unint64_t v109 = v65;
          operator delete(v67);
        }
        if (v106 != &v107) {
          free(v106);
        }
      }
      return 0;
    }
    if (v101 != 4)
    {
LABEL_8:
      __int16 v99 = 257;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v113, a1, v2, v98);
      if (v113[0])
      {
        int v102 = 3;
        unint64_t v103 = "expected ";
        uint64_t v104 = 9;
        uint64_t v3 = &v102;
        unsigned int v4 = v114;
        if (v115 >= v116)
        {
          unint64_t v73 = v115 + 1;
          if (v114 <= &v102 && &v114[6 * v115] > &v102)
          {
            int64_t v88 = (char *)&v102 - (char *)v114;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v73, 24);
            unsigned int v4 = v114;
            uint64_t v3 = (int *)((char *)v114 + v88);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v73, 24);
            uint64_t v3 = &v102;
            unsigned int v4 = v114;
          }
        }
        unsigned int v5 = &v4[6 * v115];
        long long v6 = *(_OWORD *)v3;
        *((void *)v5 + 2) = *((void *)v3 + 2);
        *(_OWORD *)unsigned int v5 = v6;
        uint64_t v7 = ++v115;
        if (v113[0])
        {
          int v102 = 3;
          unint64_t v103 = "::mlir::mps::LSTMGateLayout";
          uint64_t v104 = 27;
          uint64_t v8 = &v102;
          size_t v9 = v114;
          if (v7 >= v116)
          {
            unint64_t v74 = v7 + 1;
            BOOL v75 = &v114[6 * v7] > &v102;
            if (v114 <= &v102 && v75)
            {
              int64_t v89 = (char *)&v102 - (char *)v114;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v74, 24);
              size_t v9 = v114;
              uint64_t v8 = (int *)((char *)v114 + v89);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v74, 24);
              uint64_t v8 = &v102;
              size_t v9 = v114;
            }
          }
          size_t v10 = &v9[6 * v115];
          long long v11 = *(_OWORD *)v8;
          *((void *)v10 + 2) = *((void *)v8 + 2);
          *(_OWORD *)size_t v10 = v11;
          uint64_t v12 = ++v115;
          if (v113[0])
          {
            int v102 = 3;
            unint64_t v103 = " to be one of: ";
            uint64_t v104 = 15;
            long long v13 = &v102;
            long long v14 = v114;
            if (v12 >= v116)
            {
              unint64_t v76 = v12 + 1;
              BOOL v77 = &v114[6 * v12] > &v102;
              if (v114 <= &v102 && v77)
              {
                int64_t v90 = (char *)&v102 - (char *)v114;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v76, 24);
                long long v14 = v114;
                long long v13 = (int *)((char *)v114 + v90);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v76, 24);
                long long v13 = &v102;
                long long v14 = v114;
              }
            }
            uint64_t v15 = &v14[6 * v115];
            long long v16 = *(_OWORD *)v13;
            *((void *)v15 + 2) = *((void *)v13 + 2);
            *(_OWORD *)uint64_t v15 = v16;
            uint64_t v17 = ++v115;
            if (v113[0])
            {
              int v102 = 3;
              unint64_t v103 = "IFZO";
              uint64_t v104 = 4;
              long long v18 = &v102;
              long long v19 = v114;
              if (v17 >= v116)
              {
                unint64_t v78 = v17 + 1;
                BOOL v79 = &v114[6 * v17] > &v102;
                if (v114 <= &v102 && v79)
                {
                  int64_t v91 = (char *)&v102 - (char *)v114;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v78, 24);
                  long long v19 = v114;
                  long long v18 = (int *)((char *)v114 + v91);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v78, 24);
                  long long v18 = &v102;
                  long long v19 = v114;
                }
              }
              uint64_t v20 = &v19[6 * v115];
              long long v21 = *(_OWORD *)v18;
              *((void *)v20 + 2) = *((void *)v18 + 2);
              *(_OWORD *)uint64_t v20 = v21;
              uint64_t v22 = ++v115;
              if (v113[0])
              {
                int v102 = 3;
                unint64_t v103 = ", ";
                uint64_t v104 = 2;
                long long v23 = &v102;
                long long v24 = v114;
                if (v22 >= v116)
                {
                  unint64_t v80 = v22 + 1;
                  if (v114 <= &v102 && &v114[6 * v22] > &v102)
                  {
                    int64_t v92 = (char *)&v102 - (char *)v114;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v80, 24);
                    long long v24 = v114;
                    long long v23 = (int *)((char *)v114 + v92);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v80, 24);
                    long long v23 = &v102;
                    long long v24 = v114;
                  }
                }
                uint64_t v25 = &v24[6 * v115];
                long long v26 = *(_OWORD *)v23;
                *((void *)v25 + 2) = *((void *)v23 + 2);
                *(_OWORD *)uint64_t v25 = v26;
                uint64_t v27 = ++v115;
                if (v113[0])
                {
                  int v102 = 3;
                  unint64_t v103 = "IZFO";
                  uint64_t v104 = 4;
                  long long v28 = &v102;
                  long long v29 = v114;
                  if (v27 >= v116)
                  {
                    unint64_t v81 = v27 + 1;
                    if (v114 <= &v102 && &v114[6 * v27] > &v102)
                    {
                      int64_t v93 = (char *)&v102 - (char *)v114;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v81, 24);
                      long long v29 = v114;
                      long long v28 = (int *)((char *)v114 + v93);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v81, 24);
                      long long v28 = &v102;
                      long long v29 = v114;
                    }
                  }
                  uint64_t v30 = &v29[6 * v115];
                  long long v31 = *(_OWORD *)v28;
                  *((void *)v30 + 2) = *((void *)v28 + 2);
                  *(_OWORD *)uint64_t v30 = v31;
                  uint64_t v32 = ++v115;
                  if (v113[0])
                  {
                    int v102 = 3;
                    unint64_t v103 = ", ";
                    uint64_t v104 = 2;
                    long long v33 = &v102;
                    long long v34 = v114;
                    if (v32 >= v116)
                    {
                      unint64_t v82 = v32 + 1;
                      if (v114 <= &v102 && &v114[6 * v32] > &v102)
                      {
                        int64_t v94 = (char *)&v102 - (char *)v114;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v82, 24);
                        long long v34 = v114;
                        long long v33 = (int *)((char *)v114 + v94);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v82, 24);
                        long long v33 = &v102;
                        long long v34 = v114;
                      }
                    }
                    uint64_t v35 = &v34[6 * v115];
                    long long v36 = *(_OWORD *)v33;
                    *((void *)v35 + 2) = *((void *)v33 + 2);
                    *(_OWORD *)uint64_t v35 = v36;
                    uint64_t v37 = ++v115;
                    if (v113[0])
                    {
                      int v102 = 3;
                      unint64_t v103 = "IFOZ";
                      uint64_t v104 = 4;
                      uint64_t v38 = &v102;
                      long long v39 = v114;
                      if (v37 >= v116)
                      {
                        unint64_t v83 = v37 + 1;
                        if (v114 <= &v102 && &v114[6 * v37] > &v102)
                        {
                          int64_t v95 = (char *)&v102 - (char *)v114;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v83, 24);
                          long long v39 = v114;
                          uint64_t v38 = (int *)((char *)v114 + v95);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v83, 24);
                          uint64_t v38 = &v102;
                          long long v39 = v114;
                        }
                      }
                      uint64_t v40 = &v39[6 * v115];
                      long long v41 = *(_OWORD *)v38;
                      *((void *)v40 + 2) = *((void *)v38 + 2);
                      *(_OWORD *)uint64_t v40 = v41;
                      uint64_t v42 = ++v115;
                      if (v113[0])
                      {
                        int v102 = 3;
                        unint64_t v103 = ", ";
                        uint64_t v104 = 2;
                        uint64_t v43 = &v102;
                        long long v44 = v114;
                        if (v42 >= v116)
                        {
                          unint64_t v84 = v42 + 1;
                          BOOL v85 = &v114[6 * v42] > &v102;
                          if (v114 <= &v102 && v85)
                          {
                            int64_t v96 = (char *)&v102 - (char *)v114;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v84, 24);
                            long long v44 = v114;
                            uint64_t v43 = (int *)((char *)v114 + v96);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v84, 24);
                            uint64_t v43 = &v102;
                            long long v44 = v114;
                          }
                        }
                        long long v45 = &v44[6 * v115];
                        long long v46 = *(_OWORD *)v43;
                        *((void *)v45 + 2) = *((void *)v43 + 2);
                        *(_OWORD *)long long v45 = v46;
                        uint64_t v47 = ++v115;
                        if (v113[0])
                        {
                          int v102 = 3;
                          unint64_t v103 = "IOFZ";
                          uint64_t v104 = 4;
                          uint64_t v48 = &v102;
                          uint64_t v49 = v114;
                          if (v47 >= v116)
                          {
                            unint64_t v86 = v47 + 1;
                            BOOL v87 = &v114[6 * v47] > &v102;
                            if (v114 <= &v102 && v87)
                            {
                              int64_t v97 = (char *)&v102 - (char *)v114;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v86, 24);
                              uint64_t v49 = v114;
                              uint64_t v48 = (int *)((char *)v114 + v97);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v86, 24);
                              uint64_t v48 = &v102;
                              uint64_t v49 = v114;
                            }
                          }
                          long long v50 = &v49[6 * v115];
                          long long v51 = *(_OWORD *)v48;
                          *((void *)v50 + 2) = *((void *)v48 + 2);
                          *(_OWORD *)long long v50 = v51;
                          ++v115;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v113);
      if (v113[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
      }
      if (v122)
      {
        uint64_t v52 = v120;
        if (v120)
        {
          unsigned int v53 = v121;
          uint64_t v54 = v120;
          if (v121 != v120)
          {
            do
              unsigned int v53 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v53 - 1);
            while (v53 != v52);
            uint64_t v54 = v120;
          }
          int64_t v121 = v52;
          operator delete(v54);
        }
        unint64_t v55 = v118;
        if (v118)
        {
          long long v56 = v119;
          uint64_t v57 = v118;
          if (v119 != v118)
          {
            do
            {
              BOOL v59 = (void *)*--v56;
              unint64_t v58 = v59;
              *long long v56 = 0;
              if (v59) {
                operator delete[](v58);
              }
            }
            while (v56 != v55);
            uint64_t v57 = v118;
          }
          unint64_t v119 = v55;
          operator delete(v57);
        }
        if (v114 != (int *)v117) {
          free(v114);
        }
      }
      goto LABEL_48;
    }
    switch(*v100)
    {
      case 0x4F5A4649:
        unsigned int v60 = 0;
        break;
      case 0x4F465A49:
        unsigned int v60 = 1;
        break;
      case 0x5A4F4649:
        unsigned int v60 = 2;
        break;
      case 0x5A464F49:
        unsigned int v60 = 3;
        break;
      default:
        goto LABEL_8;
    }
    if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
    {
      uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v98[0] = v60;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v113[0] = &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id;
      v113[1] = Context;
      return mlir::StorageUniquer::get<mlir::mps::detail::LSTMGateLayoutAttrStorage,mlir::mps::LSTMGateLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25LSTMGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18LSTMGateLayoutAttrEJNS2_14LSTMGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v113, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id, v98);
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::LSTMGateLayoutAttr::print(mlir::mps::LSTMGateLayoutAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6 > 3)
    {
LABEL_6:
      size_t v9 = 0;
      uint64_t v8 = "";
      char v7 = 1;
      goto LABEL_10;
    }
  }
  else
  {
    unsigned char *v5 = 60;
    ++*((void *)v4 + 4);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
  }
  char v7 = 0;
  uint64_t v8 = "IFZO";
  size_t v9 = 4;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      char v7 = 0;
      uint64_t v8 = "IZFO";
      goto LABEL_9;
    case 2u:
      char v7 = 0;
      uint64_t v8 = "IFOZ";
      goto LABEL_9;
    case 3u:
      char v7 = 0;
      uint64_t v8 = "IOFZ";
LABEL_9:
      size_t v9 = 4;
      break;
    default:
      goto LABEL_6;
  }
LABEL_10:
  size_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v11 = (void *)*((void *)v10 + 4);
  if (v9 <= *((void *)v10 + 3) - (void)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((void *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    unsigned char *v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::GRUGateLayoutAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::GRUGateLayoutAttrStorage,mlir::mps::GRUGateLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24GRUGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17GRUGateLayoutAttrEJNS2_13GRUGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id, &v5);
}

uint64_t mlir::mps::GRUGateLayoutAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v112 = *MEMORY[0x1E4F143B8];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1))
  {
    uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    uint64_t v89 = 0;
    uint64_t v90 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v89))
    {
LABEL_52:
      uint64_t v54 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
      LOWORD(v104) = 259;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v94, a1, v54, v102);
      if (v94[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v94);
      }
      if (v101)
      {
        unint64_t v55 = (void **)__p;
        if (__p)
        {
          long long v56 = v100;
          uint64_t v57 = __p;
          if (v100 != __p)
          {
            do
              long long v56 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v56 - 1);
            while (v56 != v55);
            uint64_t v57 = __p;
          }
          BOOL v100 = v55;
          operator delete(v57);
        }
        unint64_t v58 = v97;
        if (v97)
        {
          BOOL v59 = v98;
          unsigned int v60 = v97;
          if (v98 != v97)
          {
            do
            {
              uint64_t v62 = (void *)*--v59;
              uint64_t v61 = v62;
              void *v59 = 0;
              if (v62) {
                operator delete[](v61);
              }
            }
            while (v59 != v58);
            unsigned int v60 = v97;
          }
          BOOL v98 = v58;
          operator delete(v60);
        }
        if (v95 != &v96) {
          free(v95);
        }
      }
      return 0;
    }
    if (v90 != 3)
    {
LABEL_16:
      __int16 v88 = 257;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v102, a1, v2, v87);
      if (v102[0])
      {
        int v91 = 3;
        int64_t v92 = "expected ";
        uint64_t v93 = 9;
        unsigned int v6 = &v91;
        char v7 = v103;
        if (v104 >= v105)
        {
          unint64_t v66 = v104 + 1;
          if (v103 <= &v91 && &v103[6 * v104] > &v91)
          {
            int64_t v79 = (char *)&v91 - (char *)v103;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
            char v7 = v103;
            unsigned int v6 = (int *)((char *)v103 + v79);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
            unsigned int v6 = &v91;
            char v7 = v103;
          }
        }
        uint64_t v8 = &v7[6 * v104];
        long long v9 = *(_OWORD *)v6;
        *((void *)v8 + 2) = *((void *)v6 + 2);
        *(_OWORD *)uint64_t v8 = v9;
        uint64_t v10 = ++v104;
        if (v102[0])
        {
          int v91 = 3;
          int64_t v92 = "::mlir::mps::GRUGateLayout";
          uint64_t v93 = 26;
          long long v11 = &v91;
          uint64_t v12 = v103;
          if (v10 >= v105)
          {
            unint64_t v67 = v10 + 1;
            BOOL v68 = &v103[6 * v10] > &v91;
            if (v103 <= &v91 && v68)
            {
              int64_t v80 = (char *)&v91 - (char *)v103;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
              uint64_t v12 = v103;
              long long v11 = (int *)((char *)v103 + v80);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
              long long v11 = &v91;
              uint64_t v12 = v103;
            }
          }
          long long v13 = &v12[6 * v104];
          long long v14 = *(_OWORD *)v11;
          *((void *)v13 + 2) = *((void *)v11 + 2);
          *(_OWORD *)long long v13 = v14;
          uint64_t v15 = ++v104;
          if (v102[0])
          {
            int v91 = 3;
            int64_t v92 = " to be one of: ";
            uint64_t v93 = 15;
            long long v16 = &v91;
            uint64_t v17 = v103;
            if (v15 >= v105)
            {
              unint64_t v69 = v15 + 1;
              BOOL v70 = &v103[6 * v15] > &v91;
              if (v103 <= &v91 && v70)
              {
                int64_t v81 = (char *)&v91 - (char *)v103;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                uint64_t v17 = v103;
                long long v16 = (int *)((char *)v103 + v81);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                long long v16 = &v91;
                uint64_t v17 = v103;
              }
            }
            long long v18 = &v17[6 * v104];
            long long v19 = *(_OWORD *)v16;
            *((void *)v18 + 2) = *((void *)v16 + 2);
            *(_OWORD *)long long v18 = v19;
            uint64_t v20 = ++v104;
            if (v102[0])
            {
              int v91 = 3;
              int64_t v92 = "ZRO";
              uint64_t v93 = 3;
              long long v21 = &v91;
              uint64_t v22 = v103;
              if (v20 >= v105)
              {
                unint64_t v71 = v20 + 1;
                BOOL v72 = &v103[6 * v20] > &v91;
                if (v103 <= &v91 && v72)
                {
                  int64_t v82 = (char *)&v91 - (char *)v103;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                  uint64_t v22 = v103;
                  long long v21 = (int *)((char *)v103 + v82);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                  long long v21 = &v91;
                  uint64_t v22 = v103;
                }
              }
              long long v23 = &v22[6 * v104];
              long long v24 = *(_OWORD *)v21;
              *((void *)v23 + 2) = *((void *)v21 + 2);
              *(_OWORD *)long long v23 = v24;
              uint64_t v25 = ++v104;
              if (v102[0])
              {
                int v91 = 3;
                int64_t v92 = ", ";
                uint64_t v93 = 2;
                long long v26 = &v91;
                uint64_t v27 = v103;
                if (v25 >= v105)
                {
                  unint64_t v73 = v25 + 1;
                  if (v103 <= &v91 && &v103[6 * v25] > &v91)
                  {
                    int64_t v83 = (char *)&v91 - (char *)v103;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                    uint64_t v27 = v103;
                    long long v26 = (int *)((char *)v103 + v83);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                    long long v26 = &v91;
                    uint64_t v27 = v103;
                  }
                }
                long long v28 = &v27[6 * v104];
                long long v29 = *(_OWORD *)v26;
                *((void *)v28 + 2) = *((void *)v26 + 2);
                *(_OWORD *)long long v28 = v29;
                uint64_t v30 = ++v104;
                if (v102[0])
                {
                  int v91 = 3;
                  int64_t v92 = "RZO";
                  uint64_t v93 = 3;
                  long long v31 = &v91;
                  uint64_t v32 = v103;
                  if (v30 >= v105)
                  {
                    unint64_t v74 = v30 + 1;
                    if (v103 <= &v91 && &v103[6 * v30] > &v91)
                    {
                      int64_t v84 = (char *)&v91 - (char *)v103;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                      uint64_t v32 = v103;
                      long long v31 = (int *)((char *)v103 + v84);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                      long long v31 = &v91;
                      uint64_t v32 = v103;
                    }
                  }
                  long long v33 = &v32[6 * v104];
                  long long v34 = *(_OWORD *)v31;
                  *((void *)v33 + 2) = *((void *)v31 + 2);
                  *(_OWORD *)long long v33 = v34;
                  uint64_t v35 = ++v104;
                  if (v102[0])
                  {
                    int v91 = 3;
                    int64_t v92 = ", ";
                    uint64_t v93 = 2;
                    long long v36 = &v91;
                    uint64_t v37 = v103;
                    if (v35 >= v105)
                    {
                      unint64_t v75 = v35 + 1;
                      BOOL v76 = &v103[6 * v35] > &v91;
                      if (v103 <= &v91 && v76)
                      {
                        int64_t v85 = (char *)&v91 - (char *)v103;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                        uint64_t v37 = v103;
                        long long v36 = (int *)((char *)v103 + v85);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                        long long v36 = &v91;
                        uint64_t v37 = v103;
                      }
                    }
                    uint64_t v38 = &v37[6 * v104];
                    long long v39 = *(_OWORD *)v36;
                    *((void *)v38 + 2) = *((void *)v36 + 2);
                    *(_OWORD *)uint64_t v38 = v39;
                    uint64_t v40 = ++v104;
                    if (v102[0])
                    {
                      int v91 = 3;
                      int64_t v92 = "ROZ";
                      uint64_t v93 = 3;
                      long long v41 = &v91;
                      uint64_t v42 = v103;
                      if (v40 >= v105)
                      {
                        unint64_t v77 = v40 + 1;
                        BOOL v78 = &v103[6 * v40] > &v91;
                        if (v103 <= &v91 && v78)
                        {
                          int64_t v86 = (char *)&v91 - (char *)v103;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                          uint64_t v42 = v103;
                          long long v41 = (int *)((char *)v103 + v86);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                          long long v41 = &v91;
                          uint64_t v42 = v103;
                        }
                      }
                      uint64_t v43 = &v42[6 * v104];
                      long long v44 = *(_OWORD *)v41;
                      *((void *)v43 + 2) = *((void *)v41 + 2);
                      *(_OWORD *)uint64_t v43 = v44;
                      ++v104;
                    }
                  }
                }
              }
            }
          }
        }
      }
      mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v102);
      if (v102[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v102);
      }
      if (v111)
      {
        long long v45 = v109;
        if (v109)
        {
          long long v46 = v110;
          uint64_t v47 = v109;
          if (v110 != v109)
          {
            do
              long long v46 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v46 - 1);
            while (v46 != v45);
            uint64_t v47 = v109;
          }
          BOOL v110 = v45;
          operator delete(v47);
        }
        uint64_t v48 = v107;
        if (v107)
        {
          uint64_t v49 = v108;
          long long v50 = v107;
          if (v108 != v107)
          {
            do
            {
              uint64_t v52 = (void *)*--v49;
              long long v51 = v52;
              void *v49 = 0;
              if (v52) {
                operator delete[](v51);
              }
            }
            while (v49 != v48);
            long long v50 = v107;
          }
          BOOL v108 = v48;
          operator delete(v50);
        }
        if (v103 != (int *)v106) {
          free(v103);
        }
      }
      goto LABEL_52;
    }
    if (*(_WORD *)v89 == 21082 && *(unsigned char *)(v89 + 2) == 79)
    {
      unsigned int v53 = 0;
    }
    else if (*(_WORD *)v89 == 23122 && *(unsigned char *)(v89 + 2) == 79)
    {
      unsigned int v53 = 1;
    }
    else
    {
      if (*(_WORD *)v89 != 20306 || *(unsigned char *)(v89 + 2) != 90) {
        goto LABEL_16;
      }
      unsigned int v53 = 2;
    }
    if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
    {
      uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v87[0] = v53;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v102[0] = &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id;
      v102[1] = Context;
      return mlir::StorageUniquer::get<mlir::mps::detail::GRUGateLayoutAttrStorage,mlir::mps::GRUGateLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24GRUGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17GRUGateLayoutAttrEJNS2_13GRUGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v102, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id, v87);
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::GRUGateLayoutAttr::print(mlir::mps::GRUGateLayoutAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) != v5)
  {
    unsigned char *v5 = 60;
    ++*((void *)v4 + 4);
    int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6) {
      goto LABEL_3;
    }
LABEL_11:
    BOOL v7 = 0;
    long long v9 = "ZRO";
LABEL_13:
    size_t v8 = 3;
    goto LABEL_14;
  }
  llvm::raw_ostream::write(v4, "<", 1uLL);
  int v6 = *(_DWORD *)(*(void *)this + 8);
  if (!v6) {
    goto LABEL_11;
  }
LABEL_3:
  if (v6 == 2)
  {
    BOOL v7 = 0;
    long long v9 = "ROZ";
    goto LABEL_13;
  }
  BOOL v7 = v6 != 1;
  if (v6 == 1) {
    size_t v8 = 3;
  }
  else {
    size_t v8 = 0;
  }
  if (v6 == 1) {
    long long v9 = "RZO";
  }
  else {
    long long v9 = "";
  }
LABEL_14:
  uint64_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v11 = (void *)*((void *)v10 + 4);
  if (v8 <= *((void *)v10 + 3) - (void)v11)
  {
    if (!v7)
    {
      memcpy(v11, v9, v8);
      *((void *)v10 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v9, v8);
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    unsigned char *v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::StencilPaddingModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::StencilPaddingModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::StencilPaddingModeAttrStorage,mlir::mps::StencilPaddingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail29StencilPaddingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_22StencilPaddingModeAttrEJNS2_18StencilPaddingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::StencilPaddingModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::StencilPaddingModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v176 = *MEMORY[0x1E4F143B8];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1)) {
    return 0;
  }
  uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  unsigned int v153 = 0;
  uint64_t v154 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v153))
  {
LABEL_57:
    uint64_t v95 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    LOWORD(v168) = 259;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v158, a1, v95, v166);
    if (v158[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v158);
    }
    if (v165)
    {
      uint64_t v96 = (void **)__p;
      if (__p)
      {
        int64_t v97 = v164;
        BOOL v98 = __p;
        if (v164 != __p)
        {
          do
            int64_t v97 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v97 - 1);
          while (v97 != v96);
          BOOL v98 = __p;
        }
        int64_t v164 = v96;
        operator delete(v98);
      }
      __int16 v99 = v161;
      if (v161)
      {
        BOOL v100 = v162;
        char v101 = v161;
        if (v162 != v161)
        {
          do
          {
            unint64_t v103 = (void *)*--v100;
            int v102 = v103;
            *BOOL v100 = 0;
            if (v103) {
              operator delete[](v102);
            }
          }
          while (v100 != v99);
          char v101 = v161;
        }
        int64_t v162 = v99;
        operator delete(v101);
      }
      if (v159 != &v160) {
        free(v159);
      }
    }
    return 0;
  }
  uint64_t v3 = mlir::mps::symbolizeStencilPaddingMode(v153, v154);
  if ((v3 & 0xFF00000000) == 0)
  {
    __int16 v152 = 257;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v166, a1, v2, v151);
    if (v166[0])
    {
      int v155 = 3;
      int64_t v156 = "expected ";
      uint64_t v157 = 9;
      size_t v8 = &v155;
      long long v9 = v167;
      if (v168 >= v169)
      {
        unint64_t v104 = v168 + 1;
        if (v167 <= &v155 && &v167[6 * v168] > &v155)
        {
          int64_t v135 = (char *)&v155 - (char *)v167;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v104, 24);
          long long v9 = v167;
          size_t v8 = (int *)((char *)v167 + v135);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v104, 24);
          size_t v8 = &v155;
          long long v9 = v167;
        }
      }
      uint64_t v10 = &v9[6 * v168];
      long long v11 = *(_OWORD *)v8;
      *((void *)v10 + 2) = *((void *)v8 + 2);
      *(_OWORD *)uint64_t v10 = v11;
      uint64_t v12 = ++v168;
      if (v166[0])
      {
        int v155 = 3;
        int64_t v156 = "::mlir::mps::StencilPaddingMode";
        uint64_t v157 = 31;
        long long v13 = &v155;
        long long v14 = v167;
        if (v12 >= v169)
        {
          unint64_t v105 = v12 + 1;
          BOOL v106 = &v167[6 * v12] > &v155;
          if (v167 <= &v155 && v106)
          {
            int64_t v136 = (char *)&v155 - (char *)v167;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v105, 24);
            long long v14 = v167;
            long long v13 = (int *)((char *)v167 + v136);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v105, 24);
            long long v13 = &v155;
            long long v14 = v167;
          }
        }
        uint64_t v15 = &v14[6 * v168];
        long long v16 = *(_OWORD *)v13;
        *((void *)v15 + 2) = *((void *)v13 + 2);
        *(_OWORD *)uint64_t v15 = v16;
        uint64_t v17 = ++v168;
        if (v166[0])
        {
          int v155 = 3;
          int64_t v156 = " to be one of: ";
          uint64_t v157 = 15;
          long long v18 = &v155;
          long long v19 = v167;
          if (v17 >= v169)
          {
            unint64_t v107 = v17 + 1;
            BOOL v108 = &v167[6 * v17] > &v155;
            if (v167 <= &v155 && v108)
            {
              int64_t v137 = (char *)&v155 - (char *)v167;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v107, 24);
              long long v19 = v167;
              long long v18 = (int *)((char *)v167 + v137);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v107, 24);
              long long v18 = &v155;
              long long v19 = v167;
            }
          }
          uint64_t v20 = &v19[6 * v168];
          long long v21 = *(_OWORD *)v18;
          *((void *)v20 + 2) = *((void *)v18 + 2);
          *(_OWORD *)uint64_t v20 = v21;
          uint64_t v22 = ++v168;
          if (v166[0])
          {
            int v155 = 3;
            int64_t v156 = "zero";
            uint64_t v157 = 4;
            long long v23 = &v155;
            long long v24 = v167;
            if (v22 >= v169)
            {
              unint64_t v109 = v22 + 1;
              BOOL v110 = &v167[6 * v22] > &v155;
              if (v167 <= &v155 && v110)
              {
                int64_t v138 = (char *)&v155 - (char *)v167;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v109, 24);
                long long v24 = v167;
                long long v23 = (int *)((char *)v167 + v138);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v109, 24);
                long long v23 = &v155;
                long long v24 = v167;
              }
            }
            uint64_t v25 = &v24[6 * v168];
            long long v26 = *(_OWORD *)v23;
            *((void *)v25 + 2) = *((void *)v23 + 2);
            *(_OWORD *)uint64_t v25 = v26;
            uint64_t v27 = ++v168;
            if (v166[0])
            {
              int v155 = 3;
              int64_t v156 = ", ";
              uint64_t v157 = 2;
              long long v28 = &v155;
              long long v29 = v167;
              if (v27 >= v169)
              {
                unint64_t v111 = v27 + 1;
                BOOL v112 = &v167[6 * v27] > &v155;
                if (v167 <= &v155 && v112)
                {
                  int64_t v139 = (char *)&v155 - (char *)v167;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v111, 24);
                  long long v29 = v167;
                  long long v28 = (int *)((char *)v167 + v139);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v111, 24);
                  long long v28 = &v155;
                  long long v29 = v167;
                }
              }
              uint64_t v30 = &v29[6 * v168];
              long long v31 = *(_OWORD *)v28;
              *((void *)v30 + 2) = *((void *)v28 + 2);
              *(_OWORD *)uint64_t v30 = v31;
              uint64_t v32 = ++v168;
              if (v166[0])
              {
                int v155 = 3;
                int64_t v156 = "constant";
                uint64_t v157 = 8;
                long long v33 = &v155;
                long long v34 = v167;
                if (v32 >= v169)
                {
                  unint64_t v113 = v32 + 1;
                  BOOL v114 = &v167[6 * v32] > &v155;
                  if (v167 <= &v155 && v114)
                  {
                    int64_t v140 = (char *)&v155 - (char *)v167;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v113, 24);
                    long long v34 = v167;
                    long long v33 = (int *)((char *)v167 + v140);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v113, 24);
                    long long v33 = &v155;
                    long long v34 = v167;
                  }
                }
                uint64_t v35 = &v34[6 * v168];
                long long v36 = *(_OWORD *)v33;
                *((void *)v35 + 2) = *((void *)v33 + 2);
                *(_OWORD *)uint64_t v35 = v36;
                uint64_t v37 = ++v168;
                if (v166[0])
                {
                  int v155 = 3;
                  int64_t v156 = ", ";
                  uint64_t v157 = 2;
                  uint64_t v38 = &v155;
                  long long v39 = v167;
                  if (v37 >= v169)
                  {
                    unint64_t v115 = v37 + 1;
                    BOOL v116 = &v167[6 * v37] > &v155;
                    if (v167 <= &v155 && v116)
                    {
                      int64_t v141 = (char *)&v155 - (char *)v167;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v115, 24);
                      long long v39 = v167;
                      uint64_t v38 = (int *)((char *)v167 + v141);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v115, 24);
                      uint64_t v38 = &v155;
                      long long v39 = v167;
                    }
                  }
                  uint64_t v40 = &v39[6 * v168];
                  long long v41 = *(_OWORD *)v38;
                  *((void *)v40 + 2) = *((void *)v38 + 2);
                  *(_OWORD *)uint64_t v40 = v41;
                  uint64_t v42 = ++v168;
                  if (v166[0])
                  {
                    int v155 = 3;
                    int64_t v156 = "clampToEdge";
                    uint64_t v157 = 11;
                    uint64_t v43 = &v155;
                    long long v44 = v167;
                    if (v42 >= v169)
                    {
                      unint64_t v117 = v42 + 1;
                      BOOL v118 = &v167[6 * v42] > &v155;
                      if (v167 <= &v155 && v118)
                      {
                        int64_t v142 = (char *)&v155 - (char *)v167;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v117, 24);
                        long long v44 = v167;
                        uint64_t v43 = (int *)((char *)v167 + v142);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v117, 24);
                        uint64_t v43 = &v155;
                        long long v44 = v167;
                      }
                    }
                    long long v45 = &v44[6 * v168];
                    long long v46 = *(_OWORD *)v43;
                    *((void *)v45 + 2) = *((void *)v43 + 2);
                    *(_OWORD *)long long v45 = v46;
                    uint64_t v47 = ++v168;
                    if (v166[0])
                    {
                      int v155 = 3;
                      int64_t v156 = ", ";
                      uint64_t v157 = 2;
                      uint64_t v48 = &v155;
                      uint64_t v49 = v167;
                      if (v47 >= v169)
                      {
                        unint64_t v119 = v47 + 1;
                        BOOL v120 = &v167[6 * v47] > &v155;
                        if (v167 <= &v155 && v120)
                        {
                          int64_t v143 = (char *)&v155 - (char *)v167;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v119, 24);
                          uint64_t v49 = v167;
                          uint64_t v48 = (int *)((char *)v167 + v143);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v119, 24);
                          uint64_t v48 = &v155;
                          uint64_t v49 = v167;
                        }
                      }
                      long long v50 = &v49[6 * v168];
                      long long v51 = *(_OWORD *)v48;
                      *((void *)v50 + 2) = *((void *)v48 + 2);
                      *(_OWORD *)long long v50 = v51;
                      uint64_t v52 = ++v168;
                      if (v166[0])
                      {
                        int v155 = 3;
                        int64_t v156 = "mirror";
                        uint64_t v157 = 6;
                        unsigned int v53 = &v155;
                        uint64_t v54 = v167;
                        if (v52 >= v169)
                        {
                          unint64_t v121 = v52 + 1;
                          BOOL v122 = &v167[6 * v52] > &v155;
                          if (v167 <= &v155 && v122)
                          {
                            int64_t v144 = (char *)&v155 - (char *)v167;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v121, 24);
                            uint64_t v54 = v167;
                            unsigned int v53 = (int *)((char *)v167 + v144);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v121, 24);
                            unsigned int v53 = &v155;
                            uint64_t v54 = v167;
                          }
                        }
                        unint64_t v55 = &v54[6 * v168];
                        long long v56 = *(_OWORD *)v53;
                        *((void *)v55 + 2) = *((void *)v53 + 2);
                        *(_OWORD *)unint64_t v55 = v56;
                        uint64_t v57 = ++v168;
                        if (v166[0])
                        {
                          int v155 = 3;
                          int64_t v156 = ", ";
                          uint64_t v157 = 2;
                          unint64_t v58 = &v155;
                          BOOL v59 = v167;
                          if (v57 >= v169)
                          {
                            unint64_t v123 = v57 + 1;
                            BOOL v124 = &v167[6 * v57] > &v155;
                            if (v167 <= &v155 && v124)
                            {
                              int64_t v145 = (char *)&v155 - (char *)v167;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v123, 24);
                              BOOL v59 = v167;
                              unint64_t v58 = (int *)((char *)v167 + v145);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v123, 24);
                              unint64_t v58 = &v155;
                              BOOL v59 = v167;
                            }
                          }
                          unsigned int v60 = &v59[6 * v168];
                          long long v61 = *(_OWORD *)v58;
                          *((void *)v60 + 2) = *((void *)v58 + 2);
                          *(_OWORD *)unsigned int v60 = v61;
                          uint64_t v62 = ++v168;
                          if (v166[0])
                          {
                            int v155 = 3;
                            int64_t v156 = "mirrorWithEdge";
                            uint64_t v157 = 14;
                            BOOL v63 = &v155;
                            unint64_t v64 = v167;
                            if (v62 >= v169)
                            {
                              unint64_t v125 = v62 + 1;
                              BOOL v126 = &v167[6 * v62] > &v155;
                              if (v167 <= &v155 && v126)
                              {
                                int64_t v146 = (char *)&v155 - (char *)v167;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v125, 24);
                                unint64_t v64 = v167;
                                BOOL v63 = (int *)((char *)v167 + v146);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v125, 24);
                                BOOL v63 = &v155;
                                unint64_t v64 = v167;
                              }
                            }
                            BOOL v65 = &v64[6 * v168];
                            long long v66 = *(_OWORD *)v63;
                            *((void *)v65 + 2) = *((void *)v63 + 2);
                            *(_OWORD *)BOOL v65 = v66;
                            uint64_t v67 = ++v168;
                            if (v166[0])
                            {
                              int v155 = 3;
                              int64_t v156 = ", ";
                              uint64_t v157 = 2;
                              BOOL v68 = &v155;
                              unint64_t v69 = v167;
                              if (v67 >= v169)
                              {
                                unint64_t v127 = v67 + 1;
                                BOOL v128 = &v167[6 * v67] > &v155;
                                if (v167 <= &v155 && v128)
                                {
                                  int64_t v147 = (char *)&v155 - (char *)v167;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v127, 24);
                                  unint64_t v69 = v167;
                                  BOOL v68 = (int *)((char *)v167 + v147);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v127, 24);
                                  BOOL v68 = &v155;
                                  unint64_t v69 = v167;
                                }
                              }
                              BOOL v70 = &v69[6 * v168];
                              long long v71 = *(_OWORD *)v68;
                              *((void *)v70 + 2) = *((void *)v68 + 2);
                              *(_OWORD *)BOOL v70 = v71;
                              uint64_t v72 = ++v168;
                              if (v166[0])
                              {
                                int v155 = 3;
                                int64_t v156 = "periodic";
                                uint64_t v157 = 8;
                                unint64_t v73 = &v155;
                                unint64_t v74 = v167;
                                if (v72 >= v169)
                                {
                                  unint64_t v129 = v72 + 1;
                                  BOOL v130 = &v167[6 * v72] > &v155;
                                  if (v167 <= &v155 && v130)
                                  {
                                    int64_t v148 = (char *)&v155 - (char *)v167;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v129, 24);
                                    unint64_t v74 = v167;
                                    unint64_t v73 = (int *)((char *)v167 + v148);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v129, 24);
                                    unint64_t v73 = &v155;
                                    unint64_t v74 = v167;
                                  }
                                }
                                unint64_t v75 = &v74[6 * v168];
                                long long v76 = *(_OWORD *)v73;
                                *((void *)v75 + 2) = *((void *)v73 + 2);
                                *(_OWORD *)unint64_t v75 = v76;
                                uint64_t v77 = ++v168;
                                if (v166[0])
                                {
                                  int v155 = 3;
                                  int64_t v156 = ", ";
                                  uint64_t v157 = 2;
                                  BOOL v78 = &v155;
                                  int64_t v79 = v167;
                                  if (v77 >= v169)
                                  {
                                    unint64_t v131 = v77 + 1;
                                    BOOL v132 = &v167[6 * v77] > &v155;
                                    if (v167 <= &v155 && v132)
                                    {
                                      int64_t v149 = (char *)&v155 - (char *)v167;
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v131, 24);
                                      int64_t v79 = v167;
                                      BOOL v78 = (int *)((char *)v167 + v149);
                                    }
                                    else
                                    {
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v131, 24);
                                      BOOL v78 = &v155;
                                      int64_t v79 = v167;
                                    }
                                  }
                                  int64_t v80 = &v79[6 * v168];
                                  long long v81 = *(_OWORD *)v78;
                                  *((void *)v80 + 2) = *((void *)v78 + 2);
                                  *(_OWORD *)int64_t v80 = v81;
                                  uint64_t v82 = ++v168;
                                  if (v166[0])
                                  {
                                    int v155 = 3;
                                    int64_t v156 = "antiPeriodic";
                                    uint64_t v157 = 12;
                                    int64_t v83 = &v155;
                                    int64_t v84 = v167;
                                    if (v82 >= v169)
                                    {
                                      unint64_t v133 = v82 + 1;
                                      BOOL v134 = &v167[6 * v82] > &v155;
                                      if (v167 <= &v155 && v134)
                                      {
                                        int64_t v150 = (char *)&v155 - (char *)v167;
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v133, 24);
                                        int64_t v84 = v167;
                                        int64_t v83 = (int *)((char *)v167 + v150);
                                      }
                                      else
                                      {
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v133, 24);
                                        int64_t v83 = &v155;
                                        int64_t v84 = v167;
                                      }
                                    }
                                    int64_t v85 = &v84[6 * v168];
                                    long long v86 = *(_OWORD *)v83;
                                    *((void *)v85 + 2) = *((void *)v83 + 2);
                                    *(_OWORD *)int64_t v85 = v86;
                                    ++v168;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v166);
    if (v166[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v166);
    }
    if (v175)
    {
      BOOL v87 = v173;
      if (v173)
      {
        __int16 v88 = v174;
        uint64_t v89 = v173;
        if (v174 != v173)
        {
          do
            __int16 v88 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v88 - 1);
          while (v88 != v87);
          uint64_t v89 = v173;
        }
        unint64_t v174 = v87;
        operator delete(v89);
      }
      uint64_t v90 = v171;
      if (v171)
      {
        int v91 = v172;
        int64_t v92 = v171;
        if (v172 != v171)
        {
          do
          {
            int64_t v94 = (void *)*--v91;
            uint64_t v93 = v94;
            *int v91 = 0;
            if (v94) {
              operator delete[](v93);
            }
          }
          while (v91 != v90);
          int64_t v92 = v171;
        }
        BOOL v172 = v90;
        operator delete(v92);
      }
      if (v167 != (int *)v170) {
        free(v167);
      }
    }
    goto LABEL_57;
  }
  unsigned int v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v151[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v166[0] = &mlir::detail::TypeIDResolver<mlir::mps::StencilPaddingModeAttr,void>::id;
    v166[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::StencilPaddingModeAttrStorage,mlir::mps::StencilPaddingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail29StencilPaddingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_22StencilPaddingModeAttrEJNS2_18StencilPaddingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v166, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::StencilPaddingModeAttr,void>::id, v151);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::StencilPaddingModeAttr::print(mlir::mps::StencilPaddingModeAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    size_t v6 = *(unsigned int *)(*(void *)this + 8);
    if (v6 > 6)
    {
LABEL_6:
      size_t v6 = 0;
      size_t v8 = "";
      char v7 = 1;
      goto LABEL_12;
    }
  }
  else
  {
    unsigned char *v5 = 60;
    ++*((void *)v4 + 4);
    size_t v6 = *(unsigned int *)(*(void *)this + 8);
  }
  char v7 = 0;
  size_t v8 = "zero";
  switch((int)v6)
  {
    case 0:
      char v7 = 0;
      size_t v8 = "constant";
      size_t v6 = 8;
      break;
    case 1:
      char v7 = 0;
      size_t v8 = "mirror";
      size_t v6 = 6;
      break;
    case 2:
      char v7 = 0;
      size_t v8 = "mirrorWithEdge";
      size_t v6 = 14;
      break;
    case 3:
      char v7 = 0;
      size_t v8 = "clampToEdge";
      size_t v6 = 11;
      break;
    case 4:
      break;
    case 5:
      char v7 = 0;
      size_t v8 = "periodic";
      size_t v6 = 8;
      break;
    case 6:
      char v7 = 0;
      size_t v8 = "antiPeriodic";
      size_t v6 = 12;
      break;
    default:
      goto LABEL_6;
  }
LABEL_12:
  long long v9 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v10 = (void *)*((void *)v9 + 4);
  if (v6 <= *((void *)v9 + 3) - (void)v10)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v10, v8, v6);
      *((void *)v9 + 4) += v6;
    }
  }
  else
  {
    llvm::raw_ostream::write(v9, v8, v6);
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v12 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v12)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    *uint64_t v12 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::CropResizeAlignmentModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::CropResizeAlignmentModeAttrStorage,mlir::mps::CropResizeAlignmentMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail34CropResizeAlignmentModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_27CropResizeAlignmentModeAttrEJNS2_23CropResizeAlignmentModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::CropResizeAlignmentModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v112 = *MEMORY[0x1E4F143B8];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1))
  {
    uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    uint64_t v89 = 0;
    uint64_t v90 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v89))
    {
LABEL_57:
      uint64_t v54 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
      LOWORD(v104) = 259;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v94, a1, v54, v102);
      if (v94[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v94);
      }
      if (v101)
      {
        unint64_t v55 = (void **)__p;
        if (__p)
        {
          long long v56 = v100;
          uint64_t v57 = __p;
          if (v100 != __p)
          {
            do
              long long v56 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v56 - 1);
            while (v56 != v55);
            uint64_t v57 = __p;
          }
          BOOL v100 = v55;
          operator delete(v57);
        }
        unint64_t v58 = v97;
        if (v97)
        {
          BOOL v59 = v98;
          unsigned int v60 = v97;
          if (v98 != v97)
          {
            do
            {
              uint64_t v62 = (void *)*--v59;
              long long v61 = v62;
              void *v59 = 0;
              if (v62) {
                operator delete[](v61);
              }
            }
            while (v59 != v58);
            unsigned int v60 = v97;
          }
          BOOL v98 = v58;
          operator delete(v60);
        }
        if (v95 != &v96) {
          free(v95);
        }
      }
      return 0;
    }
    if (v90 == 12)
    {
      if (*(void *)v89 != 0x726F436E67696C61 || *(_DWORD *)(v89 + 8) != 1936876910) {
        goto LABEL_22;
      }
      unsigned int v4 = 1;
    }
    else if (v90 == 13)
    {
      if (*(void *)v89 != 0x6F4374657366666FLL || *(void *)(v89 + 5) != 0x7372656E726F4374) {
        goto LABEL_22;
      }
      unsigned int v4 = 2;
    }
    else
    {
      if (v90 != 16
        || (*(void *)v89 == 0x41746C7561666564 ? (BOOL v3 = *(void *)(v89 + 8) == 0x746E656D6E67696CLL) : (BOOL v3 = 0), !v3))
      {
LABEL_22:
        __int16 v88 = 257;
        (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v102, a1, v2, v87);
        if (v102[0])
        {
          int v91 = 3;
          int64_t v92 = "expected ";
          uint64_t v93 = 9;
          char v7 = &v91;
          size_t v8 = v103;
          if (v104 >= v105)
          {
            unint64_t v66 = v104 + 1;
            if (v103 <= &v91 && &v103[6 * v104] > &v91)
            {
              int64_t v79 = (char *)&v91 - (char *)v103;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
              size_t v8 = v103;
              char v7 = (int *)((char *)v103 + v79);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
              char v7 = &v91;
              size_t v8 = v103;
            }
          }
          long long v9 = &v8[6 * v104];
          long long v10 = *(_OWORD *)v7;
          *((void *)v9 + 2) = *((void *)v7 + 2);
          *(_OWORD *)long long v9 = v10;
          uint64_t v11 = ++v104;
          if (v102[0])
          {
            int v91 = 3;
            int64_t v92 = "::mlir::mps::CropResizeAlignmentMode";
            uint64_t v93 = 36;
            uint64_t v12 = &v91;
            long long v13 = v103;
            if (v11 >= v105)
            {
              unint64_t v67 = v11 + 1;
              BOOL v68 = &v103[6 * v11] > &v91;
              if (v103 <= &v91 && v68)
              {
                int64_t v80 = (char *)&v91 - (char *)v103;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
                long long v13 = v103;
                uint64_t v12 = (int *)((char *)v103 + v80);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
                uint64_t v12 = &v91;
                long long v13 = v103;
              }
            }
            long long v14 = &v13[6 * v104];
            long long v15 = *(_OWORD *)v12;
            *((void *)v14 + 2) = *((void *)v12 + 2);
            *(_OWORD *)long long v14 = v15;
            uint64_t v16 = ++v104;
            if (v102[0])
            {
              int v91 = 3;
              int64_t v92 = " to be one of: ";
              uint64_t v93 = 15;
              uint64_t v17 = &v91;
              long long v18 = v103;
              if (v16 >= v105)
              {
                unint64_t v69 = v16 + 1;
                BOOL v70 = &v103[6 * v16] > &v91;
                if (v103 <= &v91 && v70)
                {
                  int64_t v81 = (char *)&v91 - (char *)v103;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                  long long v18 = v103;
                  uint64_t v17 = (int *)((char *)v103 + v81);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                  uint64_t v17 = &v91;
                  long long v18 = v103;
                }
              }
              long long v19 = &v18[6 * v104];
              long long v20 = *(_OWORD *)v17;
              *((void *)v19 + 2) = *((void *)v17 + 2);
              *(_OWORD *)long long v19 = v20;
              uint64_t v21 = ++v104;
              if (v102[0])
              {
                int v91 = 3;
                int64_t v92 = "defaultAlignment";
                uint64_t v93 = 16;
                uint64_t v22 = &v91;
                long long v23 = v103;
                if (v21 >= v105)
                {
                  unint64_t v71 = v21 + 1;
                  BOOL v72 = &v103[6 * v21] > &v91;
                  if (v103 <= &v91 && v72)
                  {
                    int64_t v82 = (char *)&v91 - (char *)v103;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                    long long v23 = v103;
                    uint64_t v22 = (int *)((char *)v103 + v82);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                    uint64_t v22 = &v91;
                    long long v23 = v103;
                  }
                }
                long long v24 = &v23[6 * v104];
                long long v25 = *(_OWORD *)v22;
                *((void *)v24 + 2) = *((void *)v22 + 2);
                *(_OWORD *)long long v24 = v25;
                uint64_t v26 = ++v104;
                if (v102[0])
                {
                  int v91 = 3;
                  int64_t v92 = ", ";
                  uint64_t v93 = 2;
                  uint64_t v27 = &v91;
                  long long v28 = v103;
                  if (v26 >= v105)
                  {
                    unint64_t v73 = v26 + 1;
                    if (v103 <= &v91 && &v103[6 * v26] > &v91)
                    {
                      int64_t v83 = (char *)&v91 - (char *)v103;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                      long long v28 = v103;
                      uint64_t v27 = (int *)((char *)v103 + v83);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                      uint64_t v27 = &v91;
                      long long v28 = v103;
                    }
                  }
                  long long v29 = &v28[6 * v104];
                  long long v30 = *(_OWORD *)v27;
                  *((void *)v29 + 2) = *((void *)v27 + 2);
                  *(_OWORD *)long long v29 = v30;
                  uint64_t v31 = ++v104;
                  if (v102[0])
                  {
                    int v91 = 3;
                    int64_t v92 = "alignCorners";
                    uint64_t v93 = 12;
                    uint64_t v32 = &v91;
                    long long v33 = v103;
                    if (v31 >= v105)
                    {
                      unint64_t v74 = v31 + 1;
                      if (v103 <= &v91 && &v103[6 * v31] > &v91)
                      {
                        int64_t v84 = (char *)&v91 - (char *)v103;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                        long long v33 = v103;
                        uint64_t v32 = (int *)((char *)v103 + v84);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                        uint64_t v32 = &v91;
                        long long v33 = v103;
                      }
                    }
                    long long v34 = &v33[6 * v104];
                    long long v35 = *(_OWORD *)v32;
                    *((void *)v34 + 2) = *((void *)v32 + 2);
                    *(_OWORD *)long long v34 = v35;
                    uint64_t v36 = ++v104;
                    if (v102[0])
                    {
                      int v91 = 3;
                      int64_t v92 = ", ";
                      uint64_t v93 = 2;
                      uint64_t v37 = &v91;
                      uint64_t v38 = v103;
                      if (v36 >= v105)
                      {
                        unint64_t v75 = v36 + 1;
                        BOOL v76 = &v103[6 * v36] > &v91;
                        if (v103 <= &v91 && v76)
                        {
                          int64_t v85 = (char *)&v91 - (char *)v103;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                          uint64_t v38 = v103;
                          uint64_t v37 = (int *)((char *)v103 + v85);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                          uint64_t v37 = &v91;
                          uint64_t v38 = v103;
                        }
                      }
                      long long v39 = &v38[6 * v104];
                      long long v40 = *(_OWORD *)v37;
                      *((void *)v39 + 2) = *((void *)v37 + 2);
                      *(_OWORD *)long long v39 = v40;
                      uint64_t v41 = ++v104;
                      if (v102[0])
                      {
                        int v91 = 3;
                        int64_t v92 = "offsetCorners";
                        uint64_t v93 = 13;
                        uint64_t v42 = &v91;
                        uint64_t v43 = v103;
                        if (v41 >= v105)
                        {
                          unint64_t v77 = v41 + 1;
                          BOOL v78 = &v103[6 * v41] > &v91;
                          if (v103 <= &v91 && v78)
                          {
                            int64_t v86 = (char *)&v91 - (char *)v103;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                            uint64_t v43 = v103;
                            uint64_t v42 = (int *)((char *)v103 + v86);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                            uint64_t v42 = &v91;
                            uint64_t v43 = v103;
                          }
                        }
                        long long v44 = &v43[6 * v104];
                        long long v45 = *(_OWORD *)v42;
                        *((void *)v44 + 2) = *((void *)v42 + 2);
                        *(_OWORD *)long long v44 = v45;
                        ++v104;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v102);
        if (v102[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v102);
        }
        if (v111)
        {
          long long v46 = v109;
          if (v109)
          {
            uint64_t v47 = v110;
            uint64_t v48 = v109;
            if (v110 != v109)
            {
              do
                uint64_t v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
              while (v47 != v46);
              uint64_t v48 = v109;
            }
            BOOL v110 = v46;
            operator delete(v48);
          }
          uint64_t v49 = v107;
          if (v107)
          {
            long long v50 = v108;
            long long v51 = v107;
            if (v108 != v107)
            {
              do
              {
                unsigned int v53 = (void *)*--v50;
                uint64_t v52 = v53;
                *long long v50 = 0;
                if (v53) {
                  operator delete[](v52);
                }
              }
              while (v50 != v49);
              long long v51 = v107;
            }
            BOOL v108 = v49;
            operator delete(v51);
          }
          if (v103 != (int *)v106) {
            free(v103);
          }
        }
        goto LABEL_57;
      }
      unsigned int v4 = 0;
    }
    if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
    {
      uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v87[0] = v4;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v102[0] = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id;
      v102[1] = Context;
      return mlir::StorageUniquer::get<mlir::mps::detail::CropResizeAlignmentModeAttrStorage,mlir::mps::CropResizeAlignmentMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail34CropResizeAlignmentModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_27CropResizeAlignmentModeAttrEJNS2_23CropResizeAlignmentModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v102, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id, v87);
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::CropResizeAlignmentModeAttr::print(mlir::mps::CropResizeAlignmentModeAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) != v5)
  {
    unsigned char *v5 = 60;
    ++*((void *)v4 + 4);
    int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6) {
      goto LABEL_3;
    }
LABEL_11:
    BOOL v7 = 0;
    long long v9 = "defaultAlignment";
    size_t v8 = 16;
    goto LABEL_13;
  }
  llvm::raw_ostream::write(v4, "<", 1uLL);
  int v6 = *(_DWORD *)(*(void *)this + 8);
  if (!v6) {
    goto LABEL_11;
  }
LABEL_3:
  if (v6 == 2)
  {
    BOOL v7 = 0;
    long long v9 = "offsetCorners";
    size_t v8 = 13;
  }
  else
  {
    BOOL v7 = v6 != 1;
    if (v6 == 1) {
      size_t v8 = 12;
    }
    else {
      size_t v8 = 0;
    }
    if (v6 == 1) {
      long long v9 = "alignCorners";
    }
    else {
      long long v9 = "";
    }
  }
LABEL_13:
  long long v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v11 = (void *)*((void *)v10 + 4);
  if (v8 <= *((void *)v10 + 3) - (void)v11)
  {
    if (!v7)
    {
      memcpy(v11, v9, v8);
      *((void *)v10 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v9, v8);
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    unsigned char *v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::CropResizeCoordinateModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::CropResizeCoordinateModeAttrStorage,mlir::mps::CropResizeCoordinateMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail35CropResizeCoordinateModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_28CropResizeCoordinateModeAttrEJNS2_24CropResizeCoordinateModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::CropResizeCoordinateModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v131 = *MEMORY[0x1E4F143B8];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1))
  {
    uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    uint64_t v108 = 0;
    uint64_t v109 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v108))
    {
LABEL_74:
      uint64_t v69 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
      LOWORD(v123) = 259;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v113, a1, v69, v121);
      if (v113[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
      }
      if (v120)
      {
        BOOL v70 = (void **)__p;
        if (__p)
        {
          unint64_t v71 = v119;
          BOOL v72 = __p;
          if (v119 != __p)
          {
            do
              unint64_t v71 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v71 - 1);
            while (v71 != v70);
            BOOL v72 = __p;
          }
          unint64_t v119 = v70;
          operator delete(v72);
        }
        unint64_t v73 = v116;
        if (v116)
        {
          unint64_t v74 = v117;
          unint64_t v75 = v116;
          if (v117 != v116)
          {
            do
            {
              unint64_t v77 = (void *)*--v74;
              BOOL v76 = v77;
              *unint64_t v74 = 0;
              if (v77) {
                operator delete[](v76);
              }
            }
            while (v74 != v73);
            unint64_t v75 = v116;
          }
          unint64_t v117 = v73;
          operator delete(v75);
        }
        if (v114 != &v115) {
          free(v114);
        }
      }
      return 0;
    }
    if (v109 == 17)
    {
      if (*(void *)v108 == 0x577372656E726F63
        && *(void *)(v108 + 8) == 0x7372694668746469
        && *(unsigned char *)(v108 + 16) == 116)
      {
        unsigned int v7 = 1;
      }
      else
      {
        if (*(void *)v108 != 0x57737265746E6563
          || *(void *)(v108 + 8) != 0x7372694668746469
          || *(unsigned char *)(v108 + 16) != 116)
        {
          goto LABEL_35;
        }
        unsigned int v7 = 3;
      }
    }
    else
    {
      if (v109 != 18)
      {
LABEL_35:
        __int16 v107 = 257;
        (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v121, a1, v2, v106);
        if (v121[0])
        {
          int v110 = 3;
          char v111 = "expected ";
          uint64_t v112 = 9;
          uint64_t v12 = &v110;
          long long v13 = v122;
          if (v123 >= v124)
          {
            unint64_t v81 = v123 + 1;
            if (v122 <= &v110 && &v122[6 * v123] > &v110)
            {
              int64_t v96 = (char *)&v110 - (char *)v122;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v81, 24);
              long long v13 = v122;
              uint64_t v12 = (int *)((char *)v122 + v96);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v81, 24);
              uint64_t v12 = &v110;
              long long v13 = v122;
            }
          }
          long long v14 = &v13[6 * v123];
          long long v15 = *(_OWORD *)v12;
          *((void *)v14 + 2) = *((void *)v12 + 2);
          *(_OWORD *)long long v14 = v15;
          uint64_t v16 = ++v123;
          if (v121[0])
          {
            int v110 = 3;
            char v111 = "::mlir::mps::CropResizeCoordinateMode";
            uint64_t v112 = 37;
            uint64_t v17 = &v110;
            long long v18 = v122;
            if (v16 >= v124)
            {
              unint64_t v82 = v16 + 1;
              BOOL v83 = &v122[6 * v16] > &v110;
              if (v122 <= &v110 && v83)
              {
                int64_t v97 = (char *)&v110 - (char *)v122;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v82, 24);
                long long v18 = v122;
                uint64_t v17 = (int *)((char *)v122 + v97);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v82, 24);
                uint64_t v17 = &v110;
                long long v18 = v122;
              }
            }
            long long v19 = &v18[6 * v123];
            long long v20 = *(_OWORD *)v17;
            *((void *)v19 + 2) = *((void *)v17 + 2);
            *(_OWORD *)long long v19 = v20;
            uint64_t v21 = ++v123;
            if (v121[0])
            {
              int v110 = 3;
              char v111 = " to be one of: ";
              uint64_t v112 = 15;
              uint64_t v22 = &v110;
              long long v23 = v122;
              if (v21 >= v124)
              {
                unint64_t v84 = v21 + 1;
                BOOL v85 = &v122[6 * v21] > &v110;
                if (v122 <= &v110 && v85)
                {
                  int64_t v98 = (char *)&v110 - (char *)v122;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v84, 24);
                  long long v23 = v122;
                  uint64_t v22 = (int *)((char *)v122 + v98);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v84, 24);
                  uint64_t v22 = &v110;
                  long long v23 = v122;
                }
              }
              long long v24 = &v23[6 * v123];
              long long v25 = *(_OWORD *)v22;
              *((void *)v24 + 2) = *((void *)v22 + 2);
              *(_OWORD *)long long v24 = v25;
              uint64_t v26 = ++v123;
              if (v121[0])
              {
                int v110 = 3;
                char v111 = "cornersHeightFirst";
                uint64_t v112 = 18;
                uint64_t v27 = &v110;
                long long v28 = v122;
                if (v26 >= v124)
                {
                  unint64_t v86 = v26 + 1;
                  BOOL v87 = &v122[6 * v26] > &v110;
                  if (v122 <= &v110 && v87)
                  {
                    int64_t v99 = (char *)&v110 - (char *)v122;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v86, 24);
                    long long v28 = v122;
                    uint64_t v27 = (int *)((char *)v122 + v99);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v86, 24);
                    uint64_t v27 = &v110;
                    long long v28 = v122;
                  }
                }
                long long v29 = &v28[6 * v123];
                long long v30 = *(_OWORD *)v27;
                *((void *)v29 + 2) = *((void *)v27 + 2);
                *(_OWORD *)long long v29 = v30;
                uint64_t v31 = ++v123;
                if (v121[0])
                {
                  int v110 = 3;
                  char v111 = ", ";
                  uint64_t v112 = 2;
                  uint64_t v32 = &v110;
                  long long v33 = v122;
                  if (v31 >= v124)
                  {
                    unint64_t v88 = v31 + 1;
                    if (v122 <= &v110 && &v122[6 * v31] > &v110)
                    {
                      int64_t v100 = (char *)&v110 - (char *)v122;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v88, 24);
                      long long v33 = v122;
                      uint64_t v32 = (int *)((char *)v122 + v100);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v88, 24);
                      uint64_t v32 = &v110;
                      long long v33 = v122;
                    }
                  }
                  long long v34 = &v33[6 * v123];
                  long long v35 = *(_OWORD *)v32;
                  *((void *)v34 + 2) = *((void *)v32 + 2);
                  *(_OWORD *)long long v34 = v35;
                  uint64_t v36 = ++v123;
                  if (v121[0])
                  {
                    int v110 = 3;
                    char v111 = "cornersWidthFirst";
                    uint64_t v112 = 17;
                    uint64_t v37 = &v110;
                    uint64_t v38 = v122;
                    if (v36 >= v124)
                    {
                      unint64_t v89 = v36 + 1;
                      if (v122 <= &v110 && &v122[6 * v36] > &v110)
                      {
                        int64_t v101 = (char *)&v110 - (char *)v122;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v89, 24);
                        uint64_t v38 = v122;
                        uint64_t v37 = (int *)((char *)v122 + v101);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v89, 24);
                        uint64_t v37 = &v110;
                        uint64_t v38 = v122;
                      }
                    }
                    long long v39 = &v38[6 * v123];
                    long long v40 = *(_OWORD *)v37;
                    *((void *)v39 + 2) = *((void *)v37 + 2);
                    *(_OWORD *)long long v39 = v40;
                    uint64_t v41 = ++v123;
                    if (v121[0])
                    {
                      int v110 = 3;
                      char v111 = ", ";
                      uint64_t v112 = 2;
                      uint64_t v42 = &v110;
                      uint64_t v43 = v122;
                      if (v41 >= v124)
                      {
                        unint64_t v90 = v41 + 1;
                        if (v122 <= &v110 && &v122[6 * v41] > &v110)
                        {
                          int64_t v102 = (char *)&v110 - (char *)v122;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v90, 24);
                          uint64_t v43 = v122;
                          uint64_t v42 = (int *)((char *)v122 + v102);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v90, 24);
                          uint64_t v42 = &v110;
                          uint64_t v43 = v122;
                        }
                      }
                      long long v44 = &v43[6 * v123];
                      long long v45 = *(_OWORD *)v42;
                      *((void *)v44 + 2) = *((void *)v42 + 2);
                      *(_OWORD *)long long v44 = v45;
                      uint64_t v46 = ++v123;
                      if (v121[0])
                      {
                        int v110 = 3;
                        char v111 = "centersHeightFirst";
                        uint64_t v112 = 18;
                        uint64_t v47 = &v110;
                        uint64_t v48 = v122;
                        if (v46 >= v124)
                        {
                          unint64_t v91 = v46 + 1;
                          if (v122 <= &v110 && &v122[6 * v46] > &v110)
                          {
                            int64_t v103 = (char *)&v110 - (char *)v122;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v91, 24);
                            uint64_t v48 = v122;
                            uint64_t v47 = (int *)((char *)v122 + v103);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v91, 24);
                            uint64_t v47 = &v110;
                            uint64_t v48 = v122;
                          }
                        }
                        uint64_t v49 = &v48[6 * v123];
                        long long v50 = *(_OWORD *)v47;
                        *((void *)v49 + 2) = *((void *)v47 + 2);
                        *(_OWORD *)uint64_t v49 = v50;
                        uint64_t v51 = ++v123;
                        if (v121[0])
                        {
                          int v110 = 3;
                          char v111 = ", ";
                          uint64_t v112 = 2;
                          uint64_t v52 = &v110;
                          unsigned int v53 = v122;
                          if (v51 >= v124)
                          {
                            unint64_t v92 = v51 + 1;
                            BOOL v93 = &v122[6 * v51] > &v110;
                            if (v122 <= &v110 && v93)
                            {
                              int64_t v104 = (char *)&v110 - (char *)v122;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v92, 24);
                              unsigned int v53 = v122;
                              uint64_t v52 = (int *)((char *)v122 + v104);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v92, 24);
                              uint64_t v52 = &v110;
                              unsigned int v53 = v122;
                            }
                          }
                          uint64_t v54 = &v53[6 * v123];
                          long long v55 = *(_OWORD *)v52;
                          *((void *)v54 + 2) = *((void *)v52 + 2);
                          *(_OWORD *)uint64_t v54 = v55;
                          uint64_t v56 = ++v123;
                          if (v121[0])
                          {
                            int v110 = 3;
                            char v111 = "centersWidthFirst";
                            uint64_t v112 = 17;
                            uint64_t v57 = &v110;
                            unint64_t v58 = v122;
                            if (v56 >= v124)
                            {
                              unint64_t v94 = v56 + 1;
                              BOOL v95 = &v122[6 * v56] > &v110;
                              if (v122 <= &v110 && v95)
                              {
                                int64_t v105 = (char *)&v110 - (char *)v122;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v94, 24);
                                unint64_t v58 = v122;
                                uint64_t v57 = (int *)((char *)v122 + v105);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v94, 24);
                                uint64_t v57 = &v110;
                                unint64_t v58 = v122;
                              }
                            }
                            BOOL v59 = &v58[6 * v123];
                            long long v60 = *(_OWORD *)v57;
                            *((void *)v59 + 2) = *((void *)v57 + 2);
                            *(_OWORD *)BOOL v59 = v60;
                            ++v123;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v121);
        if (v121[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v121);
        }
        if (v130)
        {
          long long v61 = v128;
          if (v128)
          {
            uint64_t v62 = v129;
            BOOL v63 = v128;
            if (v129 != v128)
            {
              do
                uint64_t v62 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v62 - 1);
              while (v62 != v61);
              BOOL v63 = v128;
            }
            unint64_t v129 = v61;
            operator delete(v63);
          }
          unint64_t v64 = v126;
          if (v126)
          {
            BOOL v65 = v127;
            unint64_t v66 = v126;
            if (v127 != v126)
            {
              do
              {
                BOOL v68 = (void *)*--v65;
                unint64_t v67 = v68;
                *BOOL v65 = 0;
                if (v68) {
                  operator delete[](v67);
                }
              }
              while (v65 != v64);
              unint64_t v66 = v126;
            }
            unint64_t v127 = v64;
            operator delete(v66);
          }
          if (v122 != (int *)v125) {
            free(v122);
          }
        }
        goto LABEL_74;
      }
      if (*(void *)v108 == 0x487372656E726F63
        && *(void *)(v108 + 8) == 0x7269467468676965
        && *(_WORD *)(v108 + 16) == 29811)
      {
        unsigned int v7 = 0;
      }
      else
      {
        if (*(void *)v108 != 0x48737265746E6563
          || *(void *)(v108 + 8) != 0x7269467468676965
          || *(_WORD *)(v108 + 16) != 29811)
        {
          goto LABEL_35;
        }
        unsigned int v7 = 2;
      }
    }
    if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
    {
      uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v106[0] = v7;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v121[0] = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id;
      v121[1] = Context;
      return mlir::StorageUniquer::get<mlir::mps::detail::CropResizeCoordinateModeAttrStorage,mlir::mps::CropResizeCoordinateMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail35CropResizeCoordinateModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_28CropResizeCoordinateModeAttrEJNS2_24CropResizeCoordinateModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v121, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id, v106);
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::CropResizeCoordinateModeAttr::print(mlir::mps::CropResizeCoordinateModeAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6 > 3)
    {
LABEL_6:
      size_t v9 = 0;
      size_t v8 = "";
      char v7 = 1;
      goto LABEL_10;
    }
  }
  else
  {
    unsigned char *v5 = 60;
    ++*((void *)v4 + 4);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
  }
  char v7 = 0;
  size_t v8 = "cornersHeightFirst";
  size_t v9 = 18;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      char v7 = 0;
      size_t v8 = "cornersWidthFirst";
      goto LABEL_9;
    case 2u:
      char v7 = 0;
      size_t v8 = "centersHeightFirst";
      size_t v9 = 18;
      break;
    case 3u:
      char v7 = 0;
      size_t v8 = "centersWidthFirst";
LABEL_9:
      size_t v9 = 17;
      break;
    default:
      goto LABEL_6;
  }
LABEL_10:
  long long v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v11 = (void *)*((void *)v10 + 4);
  if (v9 <= *((void *)v10 + 3) - (void)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((void *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    unsigned char *v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::PruningMetricAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::PruningMetricAttrStorage,mlir::mps::PruningMetric>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24PruningMetricAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17PruningMetricAttrEJNS2_13PruningMetricEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id, &v5);
}

uint64_t mlir::mps::PruningMetricAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1))
  {
    uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    uint64_t v57 = 0;
    uint64_t v58 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v57))
    {
LABEL_38:
      uint64_t v32 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
      LOWORD(v72) = 259;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v62, a1, v32, v70);
      if (v62[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v62);
      }
      if (v69)
      {
        long long v33 = (void **)__p;
        if (__p)
        {
          long long v34 = v68;
          long long v35 = __p;
          if (v68 != __p)
          {
            do
              long long v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
            while (v34 != v33);
            long long v35 = __p;
          }
          BOOL v68 = v33;
          operator delete(v35);
        }
        uint64_t v36 = v65;
        if (v65)
        {
          uint64_t v37 = v66;
          uint64_t v38 = v65;
          if (v66 != v65)
          {
            do
            {
              long long v40 = (void *)*--v37;
              long long v39 = v40;
              *uint64_t v37 = 0;
              if (v40) {
                operator delete[](v39);
              }
            }
            while (v37 != v36);
            uint64_t v38 = v65;
          }
          unint64_t v66 = v36;
          operator delete(v38);
        }
        if (v63 != &v64) {
          free(v63);
        }
      }
      return 0;
    }
    if (v58 != 17
      || (*(void *)v57 == 0x647574696E67616DLL ? (BOOL v3 = *(void *)(v57 + 8) == 0x6E696E7572705F65) : (BOOL v3 = 0),
          v3 ? (BOOL v4 = *(unsigned char *)(v57 + 16) == 103) : (BOOL v4 = 0),
          !v4))
    {
      __int16 v56 = 257;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v70, a1, v2, v55);
      if (v70[0])
      {
        int v59 = 3;
        long long v60 = "expected ";
        uint64_t v61 = 9;
        unsigned int v5 = &v59;
        unsigned int v6 = v71;
        if (v72 >= v73)
        {
          unint64_t v44 = v72 + 1;
          if (v71 <= &v59 && &v71[6 * v72] > &v59)
          {
            int64_t v51 = (char *)&v59 - (char *)v71;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v44, 24);
            unsigned int v6 = v71;
            unsigned int v5 = (int *)((char *)v71 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v44, 24);
            unsigned int v5 = &v59;
            unsigned int v6 = v71;
          }
        }
        char v7 = &v6[6 * v72];
        long long v8 = *(_OWORD *)v5;
        *((void *)v7 + 2) = *((void *)v5 + 2);
        *(_OWORD *)char v7 = v8;
        uint64_t v9 = ++v72;
        if (v70[0])
        {
          int v59 = 3;
          long long v60 = "::mlir::mps::PruningMetric";
          uint64_t v61 = 26;
          long long v10 = &v59;
          uint64_t v11 = v71;
          if (v9 >= v73)
          {
            unint64_t v45 = v9 + 1;
            BOOL v46 = &v71[6 * v9] > &v59;
            if (v71 <= &v59 && v46)
            {
              int64_t v52 = (char *)&v59 - (char *)v71;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v45, 24);
              uint64_t v11 = v71;
              long long v10 = (int *)((char *)v71 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v45, 24);
              long long v10 = &v59;
              uint64_t v11 = v71;
            }
          }
          uint64_t v12 = &v11[6 * v72];
          long long v13 = *(_OWORD *)v10;
          *((void *)v12 + 2) = *((void *)v10 + 2);
          *(_OWORD *)uint64_t v12 = v13;
          uint64_t v14 = ++v72;
          if (v70[0])
          {
            int v59 = 3;
            long long v60 = " to be one of: ";
            uint64_t v61 = 15;
            long long v15 = &v59;
            uint64_t v16 = v71;
            if (v14 >= v73)
            {
              unint64_t v47 = v14 + 1;
              BOOL v48 = &v71[6 * v14] > &v59;
              if (v71 <= &v59 && v48)
              {
                int64_t v53 = (char *)&v59 - (char *)v71;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v47, 24);
                uint64_t v16 = v71;
                long long v15 = (int *)((char *)v71 + v53);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v47, 24);
                long long v15 = &v59;
                uint64_t v16 = v71;
              }
            }
            uint64_t v17 = &v16[6 * v72];
            long long v18 = *(_OWORD *)v15;
            *((void *)v17 + 2) = *((void *)v15 + 2);
            *(_OWORD *)uint64_t v17 = v18;
            uint64_t v19 = ++v72;
            if (v70[0])
            {
              int v59 = 3;
              long long v60 = "magnitude_pruning";
              uint64_t v61 = 17;
              long long v20 = &v59;
              uint64_t v21 = v71;
              if (v19 >= v73)
              {
                unint64_t v49 = v19 + 1;
                BOOL v50 = &v71[6 * v19] > &v59;
                if (v71 <= &v59 && v50)
                {
                  int64_t v54 = (char *)&v59 - (char *)v71;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v49, 24);
                  uint64_t v21 = v71;
                  long long v20 = (int *)((char *)v71 + v54);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v49, 24);
                  long long v20 = &v59;
                  uint64_t v21 = v71;
                }
              }
              uint64_t v22 = &v21[6 * v72];
              long long v23 = *(_OWORD *)v20;
              *((void *)v22 + 2) = *((void *)v20 + 2);
              *(_OWORD *)uint64_t v22 = v23;
              ++v72;
            }
          }
        }
      }
      mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v70);
      if (v70[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v70);
      }
      if (v79)
      {
        long long v24 = v77;
        if (v77)
        {
          long long v25 = v78;
          uint64_t v26 = v77;
          if (v78 != v77)
          {
            do
              long long v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
            while (v25 != v24);
            uint64_t v26 = v77;
          }
          BOOL v78 = v24;
          operator delete(v26);
        }
        uint64_t v27 = v75;
        if (v75)
        {
          long long v28 = v76;
          long long v29 = v75;
          if (v76 != v75)
          {
            do
            {
              uint64_t v31 = (void *)*--v28;
              long long v30 = v31;
              void *v28 = 0;
              if (v31) {
                operator delete[](v30);
              }
            }
            while (v28 != v27);
            long long v29 = v75;
          }
          BOOL v76 = v27;
          operator delete(v29);
        }
        if (v71 != (int *)v74) {
          free(v71);
        }
      }
      goto LABEL_38;
    }
    if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
    {
      uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v55[0] = 0;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v70[0] = &mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id;
      v70[1] = Context;
      return mlir::StorageUniquer::get<mlir::mps::detail::PruningMetricAttrStorage,mlir::mps::PruningMetric>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24PruningMetricAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17PruningMetricAttrEJNS2_13PruningMetricEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v70, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id, v55);
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::PruningMetricAttr::print(mlir::mps::PruningMetricAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  BOOL v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }
  else
  {
    unsigned char *v5 = 60;
    ++*((void *)v4 + 4);
  }
  int v6 = *(_DWORD *)(*(void *)this + 8);
  if (v6) {
    size_t v7 = 0;
  }
  else {
    size_t v7 = 17;
  }
  long long v8 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v9 = *((void *)v8 + 4);
  if (v7 <= *((void *)v8 + 3) - v9)
  {
    if (!v6)
    {
      *(unsigned char *)(v9 + 16) = 103;
      *(_OWORD *)uint64_t v9 = *(_OWORD *)"magnitude_pruning";
      *((void *)v8 + 4) += 17;
    }
  }
  else
  {
    if (v6) {
      long long v10 = "";
    }
    else {
      long long v10 = "magnitude_pruning";
    }
    llvm::raw_ostream::write(v8, v10, v7);
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v12 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v12)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    *uint64_t v12 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::PruningStructureAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::PruningStructureAttrStorage,mlir::mps::PruningStructure>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27PruningStructureAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20PruningStructureAttrEJNS2_16PruningStructureEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id, &v5);
}

uint64_t mlir::mps::PruningStructureAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v98 = *MEMORY[0x1E4F143B8];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1))
  {
    uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    uint64_t v75 = 0;
    uint64_t v76 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v75))
    {
LABEL_49:
      uint64_t v44 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
      LOWORD(v90) = 259;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v80, a1, v44, v88);
      if (v80[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v80);
      }
      if (v87)
      {
        unint64_t v45 = (void **)__p;
        if (__p)
        {
          BOOL v46 = v86;
          unint64_t v47 = __p;
          if (v86 != __p)
          {
            do
              BOOL v46 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v46 - 1);
            while (v46 != v45);
            unint64_t v47 = __p;
          }
          unint64_t v86 = v45;
          operator delete(v47);
        }
        BOOL v48 = v83;
        if (v83)
        {
          unint64_t v49 = v84;
          BOOL v50 = v83;
          if (v84 != v83)
          {
            do
            {
              int64_t v52 = (void *)*--v49;
              int64_t v51 = v52;
              void *v49 = 0;
              if (v52) {
                operator delete[](v51);
              }
            }
            while (v49 != v48);
            BOOL v50 = v83;
          }
          unint64_t v84 = v48;
          operator delete(v50);
        }
        if (v81 != &v82) {
          free(v81);
        }
      }
      return 0;
    }
    if (v76 == 20)
    {
      if (*(void *)v75 != 0x64315F6B636F6C62
        || *(void *)(v75 + 8) != 0x7572705F345F325FLL
        || *(_DWORD *)(v75 + 16) != 1735289198)
      {
        goto LABEL_18;
      }
      unsigned int v4 = 1;
    }
    else
    {
      if (v76 != 14
        || (*(void *)v75 == 0x705F6D6F646E6172 ? (BOOL v3 = *(void *)(v75 + 6) == 0x676E696E7572705FLL) : (BOOL v3 = 0), !v3))
      {
LABEL_18:
        __int16 v74 = 257;
        (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v88, a1, v2, v73);
        if (v88[0])
        {
          int v77 = 3;
          BOOL v78 = "expected ";
          uint64_t v79 = 9;
          size_t v7 = &v77;
          long long v8 = v89;
          if (v90 >= v91)
          {
            unint64_t v56 = v90 + 1;
            if (v89 <= &v77 && &v89[6 * v90] > &v77)
            {
              int64_t v67 = (char *)&v77 - (char *)v89;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v56, 24);
              long long v8 = v89;
              size_t v7 = (int *)((char *)v89 + v67);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v56, 24);
              size_t v7 = &v77;
              long long v8 = v89;
            }
          }
          uint64_t v9 = &v8[6 * v90];
          long long v10 = *(_OWORD *)v7;
          *((void *)v9 + 2) = *((void *)v7 + 2);
          *(_OWORD *)uint64_t v9 = v10;
          uint64_t v11 = ++v90;
          if (v88[0])
          {
            int v77 = 3;
            BOOL v78 = "::mlir::mps::PruningStructure";
            uint64_t v79 = 29;
            uint64_t v12 = &v77;
            long long v13 = v89;
            if (v11 >= v91)
            {
              unint64_t v57 = v11 + 1;
              BOOL v58 = &v89[6 * v11] > &v77;
              if (v89 <= &v77 && v58)
              {
                int64_t v68 = (char *)&v77 - (char *)v89;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v57, 24);
                long long v13 = v89;
                uint64_t v12 = (int *)((char *)v89 + v68);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v57, 24);
                uint64_t v12 = &v77;
                long long v13 = v89;
              }
            }
            uint64_t v14 = &v13[6 * v90];
            long long v15 = *(_OWORD *)v12;
            *((void *)v14 + 2) = *((void *)v12 + 2);
            *(_OWORD *)uint64_t v14 = v15;
            uint64_t v16 = ++v90;
            if (v88[0])
            {
              int v77 = 3;
              BOOL v78 = " to be one of: ";
              uint64_t v79 = 15;
              uint64_t v17 = &v77;
              long long v18 = v89;
              if (v16 >= v91)
              {
                unint64_t v59 = v16 + 1;
                BOOL v60 = &v89[6 * v16] > &v77;
                if (v89 <= &v77 && v60)
                {
                  int64_t v69 = (char *)&v77 - (char *)v89;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v59, 24);
                  long long v18 = v89;
                  uint64_t v17 = (int *)((char *)v89 + v69);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v59, 24);
                  uint64_t v17 = &v77;
                  long long v18 = v89;
                }
              }
              uint64_t v19 = &v18[6 * v90];
              long long v20 = *(_OWORD *)v17;
              *((void *)v19 + 2) = *((void *)v17 + 2);
              *(_OWORD *)uint64_t v19 = v20;
              uint64_t v21 = ++v90;
              if (v88[0])
              {
                int v77 = 3;
                BOOL v78 = "random_pruning";
                uint64_t v79 = 14;
                uint64_t v22 = &v77;
                long long v23 = v89;
                if (v21 >= v91)
                {
                  unint64_t v61 = v21 + 1;
                  BOOL v62 = &v89[6 * v21] > &v77;
                  if (v89 <= &v77 && v62)
                  {
                    int64_t v70 = (char *)&v77 - (char *)v89;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v61, 24);
                    long long v23 = v89;
                    uint64_t v22 = (int *)((char *)v89 + v70);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v61, 24);
                    uint64_t v22 = &v77;
                    long long v23 = v89;
                  }
                }
                long long v24 = &v23[6 * v90];
                long long v25 = *(_OWORD *)v22;
                *((void *)v24 + 2) = *((void *)v22 + 2);
                *(_OWORD *)long long v24 = v25;
                uint64_t v26 = ++v90;
                if (v88[0])
                {
                  int v77 = 3;
                  BOOL v78 = ", ";
                  uint64_t v79 = 2;
                  uint64_t v27 = &v77;
                  long long v28 = v89;
                  if (v26 >= v91)
                  {
                    unint64_t v63 = v26 + 1;
                    BOOL v64 = &v89[6 * v26] > &v77;
                    if (v89 <= &v77 && v64)
                    {
                      int64_t v71 = (char *)&v77 - (char *)v89;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v63, 24);
                      long long v28 = v89;
                      uint64_t v27 = (int *)((char *)v89 + v71);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v63, 24);
                      uint64_t v27 = &v77;
                      long long v28 = v89;
                    }
                  }
                  long long v29 = &v28[6 * v90];
                  long long v30 = *(_OWORD *)v27;
                  *((void *)v29 + 2) = *((void *)v27 + 2);
                  *(_OWORD *)long long v29 = v30;
                  uint64_t v31 = ++v90;
                  if (v88[0])
                  {
                    int v77 = 3;
                    BOOL v78 = "block_1d_2_4_pruning";
                    uint64_t v79 = 20;
                    uint64_t v32 = &v77;
                    long long v33 = v89;
                    if (v31 >= v91)
                    {
                      unint64_t v65 = v31 + 1;
                      BOOL v66 = &v89[6 * v31] > &v77;
                      if (v89 <= &v77 && v66)
                      {
                        int64_t v72 = (char *)&v77 - (char *)v89;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v65, 24);
                        long long v33 = v89;
                        uint64_t v32 = (int *)((char *)v89 + v72);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v65, 24);
                        uint64_t v32 = &v77;
                        long long v33 = v89;
                      }
                    }
                    long long v34 = &v33[6 * v90];
                    long long v35 = *(_OWORD *)v32;
                    *((void *)v34 + 2) = *((void *)v32 + 2);
                    *(_OWORD *)long long v34 = v35;
                    ++v90;
                  }
                }
              }
            }
          }
        }
        mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v88);
        if (v88[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v88);
        }
        if (v97)
        {
          uint64_t v36 = v95;
          if (v95)
          {
            uint64_t v37 = v96;
            uint64_t v38 = v95;
            if (v96 != v95)
            {
              do
                uint64_t v37 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v37 - 1);
              while (v37 != v36);
              uint64_t v38 = v95;
            }
            int64_t v96 = v36;
            operator delete(v38);
          }
          long long v39 = v93;
          if (v93)
          {
            long long v40 = v94;
            uint64_t v41 = v93;
            if (v94 != v93)
            {
              do
              {
                uint64_t v43 = (void *)*--v40;
                uint64_t v42 = v43;
                *long long v40 = 0;
                if (v43) {
                  operator delete[](v42);
                }
              }
              while (v40 != v39);
              uint64_t v41 = v93;
            }
            unint64_t v94 = v39;
            operator delete(v41);
          }
          if (v89 != (int *)v92) {
            free(v89);
          }
        }
        goto LABEL_49;
      }
      unsigned int v4 = 0;
    }
    if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
    {
      uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v73[0] = v4;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v88[0] = &mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id;
      v88[1] = Context;
      return mlir::StorageUniquer::get<mlir::mps::detail::PruningStructureAttrStorage,mlir::mps::PruningStructure>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27PruningStructureAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20PruningStructureAttrEJNS2_16PruningStructureEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v88, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id, v73);
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::PruningStructureAttr::print(mlir::mps::PruningStructureAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }
  else
  {
    unsigned char *v5 = 60;
    ++*((void *)v4 + 4);
  }
  int v6 = *(_DWORD *)(*(void *)this + 8);
  size_t v7 = "";
  uint64_t v8 = 20;
  if (v6 == 1) {
    size_t v7 = "block_1d_2_4_pruning";
  }
  else {
    uint64_t v8 = 0;
  }
  if (v6) {
    BOOL v9 = v6 != 1;
  }
  else {
    BOOL v9 = 0;
  }
  if (v6) {
    size_t v10 = v8;
  }
  else {
    size_t v10 = 14;
  }
  if (v6) {
    uint64_t v11 = v7;
  }
  else {
    uint64_t v11 = "random_pruning";
  }
  uint64_t v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (void *)*((void *)v12 + 4);
  if (v10 <= *((void *)v12 + 3) - (void)v13)
  {
    if (!v9)
    {
      memcpy(v13, v11, v10);
      *((void *)v12 + 4) += v10;
    }
  }
  else
  {
    llvm::raw_ostream::write(v12, v11, v10);
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v15 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v15)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    *long long v15 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::SimilarityTypeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::SimilarityTypeAttrStorage,mlir::mps::SimilarityType>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25SimilarityTypeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18SimilarityTypeAttrEJNS2_14SimilarityTypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id, &v5);
}

uint64_t mlir::mps::SimilarityTypeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v96 = *MEMORY[0x1E4F143B8];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1))
  {
    uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    unsigned int v73 = 0;
    uint64_t v74 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v73))
    {
LABEL_43:
      uint64_t v42 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
      LOWORD(v88) = 259;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v78, a1, v42, v86);
      if (v78[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v78);
      }
      if (v85)
      {
        uint64_t v43 = (void **)__p;
        if (__p)
        {
          uint64_t v44 = v84;
          unint64_t v45 = __p;
          if (v84 != __p)
          {
            do
              uint64_t v44 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v44 - 1);
            while (v44 != v43);
            unint64_t v45 = __p;
          }
          unint64_t v84 = v43;
          operator delete(v45);
        }
        BOOL v46 = v81;
        if (v81)
        {
          unint64_t v47 = v82;
          BOOL v48 = v81;
          if (v82 != v81)
          {
            do
            {
              BOOL v50 = (void *)*--v47;
              unint64_t v49 = v50;
              void *v47 = 0;
              if (v50) {
                operator delete[](v49);
              }
            }
            while (v47 != v46);
            BOOL v48 = v81;
          }
          uint64_t v82 = v46;
          operator delete(v48);
        }
        if (v79 != &v80) {
          free(v79);
        }
      }
      return 0;
    }
    if (v74 == 8)
    {
      if (*v73 != 0x666669645F736261)
      {
LABEL_12:
        __int16 v72 = 257;
        (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v86, a1, v2, v71);
        if (v86[0])
        {
          int v75 = 3;
          uint64_t v76 = "expected ";
          uint64_t v77 = 9;
          unsigned int v5 = &v75;
          int v6 = v87;
          if (v88 >= v89)
          {
            unint64_t v54 = v88 + 1;
            if (v87 <= &v75 && &v87[6 * v88] > &v75)
            {
              int64_t v65 = (char *)&v75 - (char *)v87;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v54, 24);
              int v6 = v87;
              unsigned int v5 = (int *)((char *)v87 + v65);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v54, 24);
              unsigned int v5 = &v75;
              int v6 = v87;
            }
          }
          size_t v7 = &v6[6 * v88];
          long long v8 = *(_OWORD *)v5;
          *((void *)v7 + 2) = *((void *)v5 + 2);
          *(_OWORD *)size_t v7 = v8;
          uint64_t v9 = ++v88;
          if (v86[0])
          {
            int v75 = 3;
            uint64_t v76 = "::mlir::mps::SimilarityType";
            uint64_t v77 = 27;
            size_t v10 = &v75;
            uint64_t v11 = v87;
            if (v9 >= v89)
            {
              unint64_t v55 = v9 + 1;
              BOOL v56 = &v87[6 * v9] > &v75;
              if (v87 <= &v75 && v56)
              {
                int64_t v66 = (char *)&v75 - (char *)v87;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v55, 24);
                uint64_t v11 = v87;
                size_t v10 = (int *)((char *)v87 + v66);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v55, 24);
                size_t v10 = &v75;
                uint64_t v11 = v87;
              }
            }
            uint64_t v12 = &v11[6 * v88];
            long long v13 = *(_OWORD *)v10;
            *((void *)v12 + 2) = *((void *)v10 + 2);
            *(_OWORD *)uint64_t v12 = v13;
            uint64_t v14 = ++v88;
            if (v86[0])
            {
              int v75 = 3;
              uint64_t v76 = " to be one of: ";
              uint64_t v77 = 15;
              long long v15 = &v75;
              uint64_t v16 = v87;
              if (v14 >= v89)
              {
                unint64_t v57 = v14 + 1;
                BOOL v58 = &v87[6 * v14] > &v75;
                if (v87 <= &v75 && v58)
                {
                  int64_t v67 = (char *)&v75 - (char *)v87;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v57, 24);
                  uint64_t v16 = v87;
                  long long v15 = (int *)((char *)v87 + v67);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v57, 24);
                  long long v15 = &v75;
                  uint64_t v16 = v87;
                }
              }
              uint64_t v17 = &v16[6 * v88];
              long long v18 = *(_OWORD *)v15;
              *((void *)v17 + 2) = *((void *)v15 + 2);
              *(_OWORD *)uint64_t v17 = v18;
              uint64_t v19 = ++v88;
              if (v86[0])
              {
                int v75 = 3;
                uint64_t v76 = "dot_product";
                uint64_t v77 = 11;
                long long v20 = &v75;
                uint64_t v21 = v87;
                if (v19 >= v89)
                {
                  unint64_t v59 = v19 + 1;
                  BOOL v60 = &v87[6 * v19] > &v75;
                  if (v87 <= &v75 && v60)
                  {
                    int64_t v68 = (char *)&v75 - (char *)v87;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v59, 24);
                    uint64_t v21 = v87;
                    long long v20 = (int *)((char *)v87 + v68);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v59, 24);
                    long long v20 = &v75;
                    uint64_t v21 = v87;
                  }
                }
                uint64_t v22 = &v21[6 * v88];
                long long v23 = *(_OWORD *)v20;
                *((void *)v22 + 2) = *((void *)v20 + 2);
                *(_OWORD *)uint64_t v22 = v23;
                uint64_t v24 = ++v88;
                if (v86[0])
                {
                  int v75 = 3;
                  uint64_t v76 = ", ";
                  uint64_t v77 = 2;
                  long long v25 = &v75;
                  uint64_t v26 = v87;
                  if (v24 >= v89)
                  {
                    unint64_t v61 = v24 + 1;
                    BOOL v62 = &v87[6 * v24] > &v75;
                    if (v87 <= &v75 && v62)
                    {
                      int64_t v69 = (char *)&v75 - (char *)v87;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v61, 24);
                      uint64_t v26 = v87;
                      long long v25 = (int *)((char *)v87 + v69);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v61, 24);
                      long long v25 = &v75;
                      uint64_t v26 = v87;
                    }
                  }
                  uint64_t v27 = &v26[6 * v88];
                  long long v28 = *(_OWORD *)v25;
                  *((void *)v27 + 2) = *((void *)v25 + 2);
                  *(_OWORD *)uint64_t v27 = v28;
                  uint64_t v29 = ++v88;
                  if (v86[0])
                  {
                    int v75 = 3;
                    uint64_t v76 = "abs_diff";
                    uint64_t v77 = 8;
                    long long v30 = &v75;
                    uint64_t v31 = v87;
                    if (v29 >= v89)
                    {
                      unint64_t v63 = v29 + 1;
                      BOOL v64 = &v87[6 * v29] > &v75;
                      if (v87 <= &v75 && v64)
                      {
                        int64_t v70 = (char *)&v75 - (char *)v87;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v63, 24);
                        uint64_t v31 = v87;
                        long long v30 = (int *)((char *)v87 + v70);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v63, 24);
                        long long v30 = &v75;
                        uint64_t v31 = v87;
                      }
                    }
                    uint64_t v32 = &v31[6 * v88];
                    long long v33 = *(_OWORD *)v30;
                    *((void *)v32 + 2) = *((void *)v30 + 2);
                    *(_OWORD *)uint64_t v32 = v33;
                    ++v88;
                  }
                }
              }
            }
          }
        }
        mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v86);
        if (v86[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v86);
        }
        if (v95)
        {
          long long v34 = v93;
          if (v93)
          {
            long long v35 = v94;
            uint64_t v36 = v93;
            if (v94 != v93)
            {
              do
                long long v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
              while (v35 != v34);
              uint64_t v36 = v93;
            }
            unint64_t v94 = v34;
            operator delete(v36);
          }
          uint64_t v37 = v91;
          if (v91)
          {
            uint64_t v38 = v92;
            long long v39 = v91;
            if (v92 != v91)
            {
              do
              {
                uint64_t v41 = (void *)*--v38;
                long long v40 = v41;
                void *v38 = 0;
                if (v41) {
                  operator delete[](v40);
                }
              }
              while (v38 != v37);
              long long v39 = v91;
            }
            unint64_t v92 = v37;
            operator delete(v39);
          }
          if (v87 != (int *)v90) {
            free(v87);
          }
        }
        goto LABEL_43;
      }
      unsigned int v4 = 1;
    }
    else
    {
      if (v74 != 11) {
        goto LABEL_12;
      }
      if (*v73 != 0x646F72705F746F64 || *(void *)((char *)v73 + 3) != 0x746375646F72705FLL) {
        goto LABEL_12;
      }
      unsigned int v4 = 0;
    }
    if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
    {
      uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v71[0] = v4;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v86[0] = &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id;
      v86[1] = Context;
      return mlir::StorageUniquer::get<mlir::mps::detail::SimilarityTypeAttrStorage,mlir::mps::SimilarityType>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25SimilarityTypeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18SimilarityTypeAttrEJNS2_14SimilarityTypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v86, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id, v71);
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::SimilarityTypeAttr::print(mlir::mps::SimilarityTypeAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }
  else
  {
    unsigned char *v5 = 60;
    ++*((void *)v4 + 4);
  }
  int v6 = *(_DWORD *)(*(void *)this + 8);
  size_t v7 = "";
  uint64_t v8 = 8;
  if (v6 == 1) {
    size_t v7 = "abs_diff";
  }
  else {
    uint64_t v8 = 0;
  }
  if (v6) {
    BOOL v9 = v6 != 1;
  }
  else {
    BOOL v9 = 0;
  }
  if (v6) {
    size_t v10 = v8;
  }
  else {
    size_t v10 = 11;
  }
  if (v6) {
    uint64_t v11 = v7;
  }
  else {
    uint64_t v11 = "dot_product";
  }
  uint64_t v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (void *)*((void *)v12 + 4);
  if (v10 <= *((void *)v12 + 3) - (void)v13)
  {
    if (!v9)
    {
      memcpy(v13, v11, v10);
      *((void *)v12 + 4) += v10;
    }
  }
  else
  {
    llvm::raw_ostream::write(v12, v11, v10);
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v15 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v15)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    *long long v15 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::FFTScalingModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::FFTScalingModeAttrStorage,mlir::mps::FFTScalingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25FFTScalingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18FFTScalingModeAttrEJNS2_14FFTScalingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::FFTScalingModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v110 = *MEMORY[0x1E4F143B8];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1)) {
    return 0;
  }
  uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  char v87 = 0;
  uint64_t v88 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v87))
  {
LABEL_47:
    uint64_t v52 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    LOWORD(v102) = 259;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v92, a1, v52, v100);
    if (v92[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v92);
    }
    if (v99)
    {
      int64_t v53 = (void **)__p;
      if (__p)
      {
        unint64_t v54 = v98;
        unint64_t v55 = __p;
        if (v98 != __p)
        {
          do
            unint64_t v54 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v54 - 1);
          while (v54 != v53);
          unint64_t v55 = __p;
        }
        uint64_t v98 = v53;
        operator delete(v55);
      }
      BOOL v56 = v95;
      if (v95)
      {
        unint64_t v57 = v96;
        BOOL v58 = v95;
        if (v96 != v95)
        {
          do
          {
            BOOL v60 = (void *)*--v57;
            unint64_t v59 = v60;
            *unint64_t v57 = 0;
            if (v60) {
              operator delete[](v59);
            }
          }
          while (v57 != v56);
          BOOL v58 = v95;
        }
        uint64_t v96 = v56;
        operator delete(v58);
      }
      if (v93 != &v94) {
        free(v93);
      }
    }
    return 0;
  }
  if (v88 == 7)
  {
    if (*v87 == 1953066613 && *(_DWORD *)((char *)v87 + 3) == 2037539188)
    {
      unsigned int v3 = 2;
      goto LABEL_69;
    }
LABEL_12:
    __int16 v86 = 257;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v100, a1, v2, v85);
    if (v100[0])
    {
      int v89 = 3;
      unsigned int v90 = "expected ";
      uint64_t v91 = 9;
      unsigned int v5 = &v89;
      int v6 = v101;
      if (v102 >= v103)
      {
        unint64_t v64 = v102 + 1;
        if (v101 <= &v89 && &v101[6 * v102] > &v89)
        {
          int64_t v77 = (char *)&v89 - (char *)v101;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v64, 24);
          int v6 = v101;
          unsigned int v5 = (int *)((char *)v101 + v77);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v64, 24);
          unsigned int v5 = &v89;
          int v6 = v101;
        }
      }
      size_t v7 = &v6[6 * v102];
      long long v8 = *(_OWORD *)v5;
      *((void *)v7 + 2) = *((void *)v5 + 2);
      *(_OWORD *)size_t v7 = v8;
      uint64_t v9 = ++v102;
      if (v100[0])
      {
        int v89 = 3;
        unsigned int v90 = "::mlir::mps::FFTScalingMode";
        uint64_t v91 = 27;
        size_t v10 = &v89;
        uint64_t v11 = v101;
        if (v9 >= v103)
        {
          unint64_t v65 = v9 + 1;
          BOOL v66 = &v101[6 * v9] > &v89;
          if (v101 <= &v89 && v66)
          {
            int64_t v78 = (char *)&v89 - (char *)v101;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v65, 24);
            uint64_t v11 = v101;
            size_t v10 = (int *)((char *)v101 + v78);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v65, 24);
            size_t v10 = &v89;
            uint64_t v11 = v101;
          }
        }
        uint64_t v12 = &v11[6 * v102];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = *((void *)v10 + 2);
        *(_OWORD *)uint64_t v12 = v13;
        uint64_t v14 = ++v102;
        if (v100[0])
        {
          int v89 = 3;
          unsigned int v90 = " to be one of: ";
          uint64_t v91 = 15;
          long long v15 = &v89;
          uint64_t v16 = v101;
          if (v14 >= v103)
          {
            unint64_t v67 = v14 + 1;
            BOOL v68 = &v101[6 * v14] > &v89;
            if (v101 <= &v89 && v68)
            {
              int64_t v79 = (char *)&v89 - (char *)v101;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v67, 24);
              uint64_t v16 = v101;
              long long v15 = (int *)((char *)v101 + v79);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v67, 24);
              long long v15 = &v89;
              uint64_t v16 = v101;
            }
          }
          uint64_t v17 = &v16[6 * v102];
          long long v18 = *(_OWORD *)v15;
          *((void *)v17 + 2) = *((void *)v15 + 2);
          *(_OWORD *)uint64_t v17 = v18;
          uint64_t v19 = ++v102;
          if (v100[0])
          {
            int v89 = 3;
            unsigned int v90 = "none";
            uint64_t v91 = 4;
            long long v20 = &v89;
            uint64_t v21 = v101;
            if (v19 >= v103)
            {
              unint64_t v69 = v19 + 1;
              BOOL v70 = &v101[6 * v19] > &v89;
              if (v101 <= &v89 && v70)
              {
                int64_t v80 = (char *)&v89 - (char *)v101;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v69, 24);
                uint64_t v21 = v101;
                long long v20 = (int *)((char *)v101 + v80);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v69, 24);
                long long v20 = &v89;
                uint64_t v21 = v101;
              }
            }
            uint64_t v22 = &v21[6 * v102];
            long long v23 = *(_OWORD *)v20;
            *((void *)v22 + 2) = *((void *)v20 + 2);
            *(_OWORD *)uint64_t v22 = v23;
            uint64_t v24 = ++v102;
            if (v100[0])
            {
              int v89 = 3;
              unsigned int v90 = ", ";
              uint64_t v91 = 2;
              long long v25 = &v89;
              uint64_t v26 = v101;
              if (v24 >= v103)
              {
                unint64_t v71 = v24 + 1;
                if (v101 <= &v89 && &v101[6 * v24] > &v89)
                {
                  int64_t v81 = (char *)&v89 - (char *)v101;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v71, 24);
                  uint64_t v26 = v101;
                  long long v25 = (int *)((char *)v101 + v81);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v71, 24);
                  long long v25 = &v89;
                  uint64_t v26 = v101;
                }
              }
              uint64_t v27 = &v26[6 * v102];
              long long v28 = *(_OWORD *)v25;
              *((void *)v27 + 2) = *((void *)v25 + 2);
              *(_OWORD *)uint64_t v27 = v28;
              uint64_t v29 = ++v102;
              if (v100[0])
              {
                int v89 = 3;
                unsigned int v90 = "size";
                uint64_t v91 = 4;
                long long v30 = &v89;
                uint64_t v31 = v101;
                if (v29 >= v103)
                {
                  unint64_t v72 = v29 + 1;
                  if (v101 <= &v89 && &v101[6 * v29] > &v89)
                  {
                    int64_t v82 = (char *)&v89 - (char *)v101;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v72, 24);
                    uint64_t v31 = v101;
                    long long v30 = (int *)((char *)v101 + v82);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v72, 24);
                    long long v30 = &v89;
                    uint64_t v31 = v101;
                  }
                }
                uint64_t v32 = &v31[6 * v102];
                long long v33 = *(_OWORD *)v30;
                *((void *)v32 + 2) = *((void *)v30 + 2);
                *(_OWORD *)uint64_t v32 = v33;
                uint64_t v34 = ++v102;
                if (v100[0])
                {
                  int v89 = 3;
                  unsigned int v90 = ", ";
                  uint64_t v91 = 2;
                  long long v35 = &v89;
                  uint64_t v36 = v101;
                  if (v34 >= v103)
                  {
                    unint64_t v73 = v34 + 1;
                    BOOL v74 = &v101[6 * v34] > &v89;
                    if (v101 <= &v89 && v74)
                    {
                      int64_t v83 = (char *)&v89 - (char *)v101;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v73, 24);
                      uint64_t v36 = v101;
                      long long v35 = (int *)((char *)v101 + v83);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v73, 24);
                      long long v35 = &v89;
                      uint64_t v36 = v101;
                    }
                  }
                  uint64_t v37 = &v36[6 * v102];
                  long long v38 = *(_OWORD *)v35;
                  *((void *)v37 + 2) = *((void *)v35 + 2);
                  *(_OWORD *)uint64_t v37 = v38;
                  uint64_t v39 = ++v102;
                  if (v100[0])
                  {
                    int v89 = 3;
                    unsigned int v90 = "unitary";
                    uint64_t v91 = 7;
                    long long v40 = &v89;
                    uint64_t v41 = v101;
                    if (v39 >= v103)
                    {
                      unint64_t v75 = v39 + 1;
                      BOOL v76 = &v101[6 * v39] > &v89;
                      if (v101 <= &v89 && v76)
                      {
                        int64_t v84 = (char *)&v89 - (char *)v101;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v75, 24);
                        uint64_t v41 = v101;
                        long long v40 = (int *)((char *)v101 + v84);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v75, 24);
                        long long v40 = &v89;
                        uint64_t v41 = v101;
                      }
                    }
                    uint64_t v42 = &v41[6 * v102];
                    long long v43 = *(_OWORD *)v40;
                    *((void *)v42 + 2) = *((void *)v40 + 2);
                    *(_OWORD *)uint64_t v42 = v43;
                    ++v102;
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v100);
    if (v100[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v100);
    }
    if (v109)
    {
      uint64_t v44 = v107;
      if (v107)
      {
        unint64_t v45 = v108;
        BOOL v46 = v107;
        if (v108 != v107)
        {
          do
            unint64_t v45 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v45 - 1);
          while (v45 != v44);
          BOOL v46 = v107;
        }
        uint64_t v108 = v44;
        operator delete(v46);
      }
      unint64_t v47 = v105;
      if (v105)
      {
        BOOL v48 = v106;
        unint64_t v49 = v105;
        if (v106 != v105)
        {
          do
          {
            int64_t v51 = (void *)*--v48;
            BOOL v50 = v51;
            void *v48 = 0;
            if (v51) {
              operator delete[](v50);
            }
          }
          while (v48 != v47);
          unint64_t v49 = v105;
        }
        BOOL v106 = v47;
        operator delete(v49);
      }
      if (v101 != (int *)v104) {
        free(v101);
      }
    }
    goto LABEL_47;
  }
  if (v88 != 4) {
    goto LABEL_12;
  }
  if (*v87 != 1701736302)
  {
    if (*v87 == 1702521203)
    {
      unsigned int v3 = 1;
      goto LABEL_69;
    }
    goto LABEL_12;
  }
  unsigned int v3 = 0;
LABEL_69:
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v85[0] = v3;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v100[0] = &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id;
    v100[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::FFTScalingModeAttrStorage,mlir::mps::FFTScalingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25FFTScalingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18FFTScalingModeAttrEJNS2_14FFTScalingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v100, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id, v85);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::FFTScalingModeAttr::print(mlir::mps::FFTScalingModeAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) != v5)
  {
    unsigned char *v5 = 60;
    ++*((void *)v4 + 4);
    int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6) {
      goto LABEL_3;
    }
LABEL_11:
    BOOL v7 = 0;
    uint64_t v9 = "none";
    size_t v8 = 4;
    goto LABEL_13;
  }
  llvm::raw_ostream::write(v4, "<", 1uLL);
  int v6 = *(_DWORD *)(*(void *)this + 8);
  if (!v6) {
    goto LABEL_11;
  }
LABEL_3:
  if (v6 == 2)
  {
    BOOL v7 = 0;
    uint64_t v9 = "unitary";
    size_t v8 = 7;
  }
  else
  {
    BOOL v7 = v6 != 1;
    if (v6 == 1) {
      size_t v8 = 4;
    }
    else {
      size_t v8 = 0;
    }
    if (v6 == 1) {
      uint64_t v9 = "size";
    }
    else {
      uint64_t v9 = "";
    }
  }
LABEL_13:
  size_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v11 = (void *)*((void *)v10 + 4);
  if (v8 <= *((void *)v10 + 3) - (void)v11)
  {
    if (!v7)
    {
      memcpy(v11, v9, v8);
      *((void *)v10 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v9, v8);
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    unsigned char *v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::MPSBufferTensorAttr::parse(mlir::AsmParser *a1, void *a2)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  mlir::AsmParser::getContext(a1);
  uint64_t v4 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if (!a2)
  {
    *(void *)uint64_t v39 = "expected a trailing type";
    __int16 v41 = 259;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned char *))(*(void *)a1 + 24))(v52, a1, v4, v39);
    if (v52[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v52);
    }
    if (!v59) {
      return 0;
    }
    long long v13 = (void **)v57;
    if (v57)
    {
      uint64_t v14 = v58;
      long long v15 = v57;
      if (v58 != v57)
      {
        do
          uint64_t v14 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v14 - 1);
        while (v14 != v13);
        long long v15 = v57;
      }
      BOOL v58 = v13;
      operator delete(v15);
    }
    uint64_t v16 = v55;
    if (v55)
    {
      uint64_t v17 = v56;
      long long v18 = v55;
      if (v56 != v55)
      {
        do
        {
          long long v20 = (void *)*--v17;
          uint64_t v19 = v20;
          *uint64_t v17 = 0;
          if (v20) {
            operator delete[](v19);
          }
        }
        while (v17 != v16);
        long long v18 = v55;
      }
      BOOL v56 = v16;
      operator delete(v18);
    }
    uint64_t v24 = v53;
    if (v53 == &v54) {
      return 0;
    }
    goto LABEL_45;
  }
  if (*(_UNKNOWN **)(*a2 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    *(void *)uint64_t v39 = "invalid kind of type specified";
    __int16 v41 = 259;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned char *))(*(void *)a1 + 24))(v60, a1, v4, v39);
    if (v60[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v60);
    }
    if (!v67) {
      return 0;
    }
    unsigned int v5 = (void **)__p;
    if (__p)
    {
      int v6 = v66;
      BOOL v7 = __p;
      if (v66 != __p)
      {
        do
          int v6 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v6 - 1);
        while (v6 != v5);
        BOOL v7 = __p;
      }
      BOOL v66 = v5;
      operator delete(v7);
    }
    size_t v8 = v63;
    if (v63)
    {
      uint64_t v9 = v64;
      size_t v10 = v63;
      if (v64 != v63)
      {
        do
        {
          uint64_t v12 = (void *)*--v9;
          uint64_t v11 = v12;
          void *v9 = 0;
          if (v12) {
            operator delete[](v11);
          }
        }
        while (v9 != v8);
        size_t v10 = v63;
      }
      unint64_t v64 = v8;
      operator delete(v10);
    }
    uint64_t v24 = v61;
    if (v61 == &v62) {
      return 0;
    }
    goto LABEL_45;
  }
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1))
  {
    mlir::AsmParser::parseResourceHandle<mlir::mps::MPSDialectResourceBlobHandle>(a1, (uint64_t)v39);
    char v21 = v39[0];
    *(_OWORD *)int64_t v51 = *(_OWORD *)&v39[1];
    *(void *)&v51[15] = *(void *)&v39[16];
    uint64_t v22 = *(void *)a1;
    if (v40)
    {
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(v22 + 128))(a1))
      {
        __int16 v41 = 257;
        if (!(*(unsigned __int8 (**)(mlir::AsmParser *, const char *, uint64_t, unsigned char *))(*(void *)a1 + 368))(a1, "handle_offset", 13, v39)|| !(*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 136))(a1))
        {
          return 0;
        }
        *(void *)uint64_t v39 = 0;
        if (!mlir::AsmParser::parseInteger<unsigned long long>((uint64_t)a1, (uint64_t *)v39))
        {
          uint64_t v35 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
          __int16 v41 = 259;
          (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned char *))(*(void *)a1 + 24))(v42, a1, v35, v39);
          mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v42);
          return 0;
        }
        uint64_t v23 = *(void *)v39;
      }
      else
      {
        uint64_t v23 = 0;
      }
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
      {
        uint64_t v37 = a2;
        uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
        v39[0] = v21;
        *(_OWORD *)&v39[1] = *(_OWORD *)v51;
        *(void *)&v39[16] = *(void *)&v51[15];
        uint64_t v36 = v23;
        return mlir::AsmParser::getChecked<mlir::mps::MPSBufferTensorAttr,mlir::MLIRContext *,mlir::RankedTensorType,mlir::mps::MPSDialectResourceBlobHandle,unsigned long long>((uint64_t)a1, v4, &Context, &v37, (uint64_t)v39, &v36);
      }
      return 0;
    }
    uint64_t v26 = (*(uint64_t (**)(mlir::AsmParser *))(v22 + 40))(a1);
    __int16 v41 = 259;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned char *))(*(void *)a1 + 24))(v43, a1, v26, v39);
    if (v43[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v43);
    }
    if (!v50) {
      return 0;
    }
    uint64_t v27 = (void **)v48;
    if (v48)
    {
      long long v28 = v49;
      uint64_t v29 = v48;
      if (v49 != v48)
      {
        do
          long long v28 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v28 - 1);
        while (v28 != v27);
        uint64_t v29 = v48;
      }
      unint64_t v49 = v27;
      operator delete(v29);
    }
    long long v30 = v46;
    if (v46)
    {
      uint64_t v31 = v47;
      uint64_t v32 = v46;
      if (v47 != v46)
      {
        do
        {
          uint64_t v34 = (void *)*--v31;
          long long v33 = v34;
          *uint64_t v31 = 0;
          if (v34) {
            operator delete[](v33);
          }
        }
        while (v31 != v30);
        uint64_t v32 = v46;
      }
      unint64_t v47 = v30;
      operator delete(v32);
    }
    uint64_t v24 = v44;
    if (v44 == &v45) {
      return 0;
    }
LABEL_45:
    free(v24);
  }
  return 0;
}

void mlir::AsmParser::parseResourceHandle<mlir::mps::MPSDialectResourceBlobHandle>(mlir::AsmParser *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  uint64_t Context = (char *)mlir::AsmParser::getContext(a1);
  Dialect = mlir::MLIRContext::getOrLoadDialect(Context, (uint64_t)"mps", 3, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::MPSDialect,void>::id, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::mps::MPSDialect * mlir::MLIRContext::getOrLoadDialect<mlir::mps::MPSDialect>(void)::{lambda(void)#1}>, (uint64_t)&Context);
  if (Dialect)
  {
    (*(void (**)(long long *__return_ptr, mlir::AsmParser *, mlir::Dialect *))(*(void *)a1 + 584))(&v50, a1, Dialect);
    if (!v52)
    {
      *(unsigned char *)a2 = 0;
      *(unsigned char *)(a2 + 24) = 0;
      return;
    }
    uint64_t v6 = *((void *)&v50 + 1);
    unint64_t v7 = 0x1E8EB8000uLL;
    {
      unint64_t v7 = 0x1E8EB8000;
      if (v39)
      {
        uint64_t Context = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::MPSDialectResourceBlobHandle]";
        unint64_t v62 = 89;
        unint64_t v40 = llvm::StringRef::find((uint64_t *)&Context, "DesiredTypeName = ", 0x12uLL, 0);
        if (v62 >= v40) {
          unint64_t v41 = v40;
        }
        else {
          unint64_t v41 = v62;
        }
        uint64_t v42 = &Context[v41];
        unint64_t v43 = v62 - v41;
        if (v62 - v41 >= 0x12) {
          uint64_t v44 = 18;
        }
        else {
          uint64_t v44 = v62 - v41;
        }
        unint64_t v45 = v43 - v44;
        if (v45 >= v45 - 1) {
          uint64_t v46 = v45 - 1;
        }
        else {
          uint64_t v46 = v45;
        }
        mlir::detail::TypeIDResolver<mlir::mps::MPSDialectResourceBlobHandle,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v42[v44], v46);
        unint64_t v7 = 0x1E8EB8000;
      }
    }
    if (v6 == *(void *)(v7 + 2816))
    {
      *(_OWORD *)a2 = v50;
      *(void *)(a2 + 16) = v51;
      *(unsigned char *)(a2 + 24) = 1;
      return;
    }
    __int16 v57 = 257;
    (*(void (**)(char **__return_ptr, mlir::AsmParser *, uint64_t, const void ***))(*(void *)a1 + 24))(&Context, a1, v4, &v54);
    if (Context)
    {
      int v58 = 3;
      char v59 = "provided resource handle differs from the expected resource type";
      uint64_t v60 = 64;
      size_t v8 = &v58;
      uint64_t v9 = (char *)v63;
      if (v64 >= v65)
      {
        unint64_t v37 = v64 + 1;
        if (v63 <= &v58 && (char *)v63 + 24 * v64 > (char *)&v58)
        {
          int64_t v48 = (char *)&v58 - (unsigned char *)v63;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v37, 24);
          uint64_t v9 = (char *)v63;
          size_t v8 = (int *)((char *)v63 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v37, 24);
          size_t v8 = &v58;
          uint64_t v9 = (char *)v63;
        }
      }
      size_t v10 = &v9[24 * v64];
      long long v11 = *(_OWORD *)v8;
      *((void *)v10 + 2) = *((void *)v8 + 2);
      *(_OWORD *)size_t v10 = v11;
      ++v64;
      uint64_t v12 = Context;
      *(unsigned char *)a2 = 0;
      *(unsigned char *)(a2 + 24) = 0;
      if (v12) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Context);
      }
      if (!v71) {
        return;
      }
    }
    else
    {
      *(unsigned char *)a2 = 0;
      *(unsigned char *)(a2 + 24) = 0;
      if (!v71) {
        return;
      }
    }
    long long v30 = (void **)__p;
    if (__p)
    {
      uint64_t v31 = v70;
      uint64_t v32 = __p;
      if (v70 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        uint64_t v32 = __p;
      }
      BOOL v70 = v30;
      operator delete(v32);
    }
    long long v25 = v67;
    if (!v67)
    {
LABEL_47:
      if (v63 != v66) {
        free(v63);
      }
      return;
    }
    long long v33 = v68;
    uint64_t v27 = v67;
    if (v68 == v67)
    {
LABEL_46:
      uint64_t v68 = v25;
      operator delete(v27);
      goto LABEL_47;
    }
    do
    {
      uint64_t v35 = (void *)*--v33;
      uint64_t v34 = v35;
      *long long v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v25);
LABEL_45:
    uint64_t v27 = v67;
    goto LABEL_46;
  }
  __int16 v53 = 257;
  (*(void (**)(char **__return_ptr, mlir::AsmParser *, uint64_t, long long *))(*(void *)a1 + 24))(&Context, a1, v4, &v50);
  if (!Context) {
    goto LABEL_18;
  }
  LODWORD(v54) = 3;
  unint64_t v55 = "dialect '";
  uint64_t v56 = 9;
  long long v13 = &v54;
  uint64_t v14 = (char *)v63;
  if (v64 >= v65)
  {
    unint64_t v36 = v64 + 1;
    if (v63 <= &v54 && (char *)v63 + 24 * v64 > (char *)&v54)
    {
      int64_t v47 = (char *)&v54 - (unsigned char *)v63;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v36, 24);
      uint64_t v14 = (char *)v63;
      long long v13 = (const void ***)((char *)v63 + v47);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v36, 24);
      long long v13 = &v54;
      uint64_t v14 = (char *)v63;
    }
  }
  long long v15 = &v14[24 * v64];
  long long v16 = *(_OWORD *)v13;
  *((void *)v15 + 2) = v13[2];
  *(_OWORD *)long long v15 = v16;
  ++v64;
  if (!Context) {
    goto LABEL_18;
  }
  __int16 v57 = 262;
  uint64_t v54 = (const void **)"mps";
  unint64_t v55 = (const char *)3;
  mlir::Diagnostic::operator<<((uint64_t)&v62, &v54);
  if (Context)
  {
    LODWORD(v54) = 3;
    unint64_t v55 = "' is unknown";
    uint64_t v56 = 12;
    uint64_t v17 = &v54;
    long long v18 = (char *)v63;
    if (v64 >= v65)
    {
      unint64_t v38 = v64 + 1;
      if (v63 <= &v54 && (char *)v63 + 24 * v64 > (char *)&v54)
      {
        int64_t v49 = (char *)&v54 - (unsigned char *)v63;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v38, 24);
        long long v18 = (char *)v63;
        uint64_t v17 = (const void ***)((char *)v63 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v38, 24);
        uint64_t v17 = &v54;
        long long v18 = (char *)v63;
      }
    }
    uint64_t v19 = &v18[24 * v64];
    long long v20 = *(_OWORD *)v17;
    *((void *)v19 + 2) = v17[2];
    *(_OWORD *)uint64_t v19 = v20;
    ++v64;
    char v21 = Context;
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 24) = 0;
    if (v21) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Context);
    }
  }
  else
  {
LABEL_18:
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 24) = 0;
  }
  if (v71)
  {
    uint64_t v22 = (void **)__p;
    if (__p)
    {
      uint64_t v23 = v70;
      uint64_t v24 = __p;
      if (v70 != __p)
      {
        do
          uint64_t v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
        while (v23 != v22);
        uint64_t v24 = __p;
      }
      BOOL v70 = v22;
      operator delete(v24);
    }
    long long v25 = v67;
    if (!v67) {
      goto LABEL_47;
    }
    uint64_t v26 = v68;
    uint64_t v27 = v67;
    if (v68 == v67) {
      goto LABEL_46;
    }
    do
    {
      uint64_t v29 = (void *)*--v26;
      long long v28 = v29;
      *uint64_t v26 = 0;
      if (v29) {
        operator delete[](v28);
      }
    }
    while (v26 != v25);
    goto LABEL_45;
  }
}

uint64_t mlir::AsmParser::getChecked<mlir::mps::MPSBufferTensorAttr,mlir::MLIRContext *,mlir::RankedTensorType,mlir::mps::MPSDialectResourceBlobHandle,unsigned long long>(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, void **a4, uint64_t a5, uint64_t *a6)
{
  v10[0] = a1;
  v10[1] = &v11;
  uint64_t v11 = a2;
  uint64_t v6 = *a3;
  unint64_t v7 = *a4;
  long long v12 = *(_OWORD *)a5;
  uint64_t v13 = *(void *)(a5 + 16);
  uint64_t v14 = *a6;
  long long v15 = v7;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v6);
  v16[0] = &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id;
  v16[1] = v6;
  return mlir::StorageUniquer::get<mlir::mps::detail::MPSBufferTensorAttrStorage,mlir::RankedTensorType &,mlir::mps::MPSDialectResourceBlobHandle &,unsigned long long &>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail26MPSBufferTensorAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_19MPSBufferTensorAttrEJRNS1_16RankedTensorTypeERNS2_28MPSDialectResourceBlobHandleERyEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESK_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSM_E_EEvlS5_, (uint64_t)v16, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id, (uint64_t *)&v15, &v12, &v14);
}

llvm::raw_ostream *mlir::mps::MPSBufferTensorAttr::print(mlir::mps::MPSBufferTensorAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  uint64_t v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }
  else
  {
    unsigned char *v5 = 60;
    ++*((void *)v4 + 4);
  }
  long long v6 = *(_OWORD *)(*(void *)this + 16);
  uint64_t v24 = *(void *)(*(void *)this + 32);
  long long v23 = v6;
  (*(void (**)(mlir::AsmPrinter *, long long *))(*(void *)a2 + 80))(a2, &v23);
  if (!*(void *)(*(void *)this + 40)) {
    goto LABEL_25;
  }
  unint64_t v7 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  size_t v8 = (unsigned char *)*((void *)v7 + 4);
  if (*((unsigned char **)v7 + 3) == v8)
  {
    llvm::raw_ostream::write(v7, ",", 1uLL);
  }
  else
  {
    unsigned char *v8 = 44;
    ++*((void *)v7 + 4);
  }
  uint64_t v9 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  size_t v10 = (unsigned char *)*((void *)v9 + 4);
  if ((unint64_t)v10 >= *((void *)v9 + 3))
  {
    llvm::raw_ostream::write(v9, 32);
  }
  else
  {
    *((void *)v9 + 4) = v10 + 1;
    unsigned char *v10 = 32;
  }
  uint64_t v11 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v12 = (void *)*((void *)v11 + 4);
  if (*((void *)v11 + 3) - (void)v12 > 0xCuLL)
  {
    qmemcpy(v12, "handle_offset", 13);
    *((void *)v11 + 4) += 13;
  }
  else
  {
    llvm::raw_ostream::write(v11, "handle_offset", 0xDuLL);
  }
  uint64_t v13 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v14 = (unsigned char *)*((void *)v13 + 4);
  if ((unint64_t)v14 >= *((void *)v13 + 3))
  {
    llvm::raw_ostream::write(v13, 32);
  }
  else
  {
    *((void *)v13 + 4) = v14 + 1;
    *uint64_t v14 = 32;
  }
  long long v15 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v16 = (unsigned char *)*((void *)v15 + 4);
  if (*((unsigned char **)v15 + 3) == v16)
  {
    llvm::raw_ostream::write(v15, "=", 1uLL);
    if (!*(void *)(*(void *)this + 40)) {
      goto LABEL_25;
    }
  }
  else
  {
    unsigned char *v16 = 61;
    ++*((void *)v15 + 4);
    if (!*(void *)(*(void *)this + 40)) {
      goto LABEL_25;
    }
  }
  uint64_t v17 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v18 = (unsigned char *)*((void *)v17 + 4);
  if ((unint64_t)v18 >= *((void *)v17 + 3))
  {
    llvm::raw_ostream::write(v17, 32);
  }
  else
  {
    *((void *)v17 + 4) = v18 + 1;
    unsigned char *v18 = 32;
  }
  unint64_t v19 = *(void *)(*(void *)this + 40);
  long long v20 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  llvm::raw_ostream::operator<<(v20, v19);
LABEL_25:
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v22 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v22) {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  *uint64_t v22 = 62;
  ++*((void *)result + 4);
  return result;
}

uint64_t mlir::mps::CallInlineModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::CallInlineModeAttrStorage,mlir::mps::CallInlineMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25CallInlineModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18CallInlineModeAttrEJNS2_14CallInlineModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::CallInlineModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v111 = *MEMORY[0x1E4F143B8];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1))
  {
    uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    uint64_t v88 = 0;
    uint64_t v89 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v88))
    {
LABEL_53:
      uint64_t v53 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
      LOWORD(v103) = 259;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v93, a1, v53, v101);
      if (v93[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v93);
      }
      if (v100)
      {
        uint64_t v54 = (void **)__p;
        if (__p)
        {
          unint64_t v55 = v99;
          uint64_t v56 = __p;
          if (v99 != __p)
          {
            do
              unint64_t v55 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v55 - 1);
            while (v55 != v54);
            uint64_t v56 = __p;
          }
          char v99 = v54;
          operator delete(v56);
        }
        __int16 v57 = v96;
        if (v96)
        {
          int v58 = v97;
          char v59 = v96;
          if (v97 != v96)
          {
            do
            {
              unint64_t v61 = (void *)*--v58;
              uint64_t v60 = v61;
              void *v58 = 0;
              if (v61) {
                operator delete[](v60);
              }
            }
            while (v58 != v57);
            char v59 = v96;
          }
          char v97 = v57;
          operator delete(v59);
        }
        if (v94 != &v95) {
          free(v94);
        }
      }
      return 0;
    }
    switch(v89)
    {
      case 2:
        if (*(_WORD *)v88 != 28271)
        {
LABEL_18:
          __int16 v87 = 257;
          (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v101, a1, v2, v86);
          if (v101[0])
          {
            int v90 = 3;
            uint64_t v91 = "expected ";
            uint64_t v92 = 9;
            long long v6 = &v90;
            unint64_t v7 = v102;
            if (v103 >= v104)
            {
              unint64_t v65 = v103 + 1;
              if (v102 <= &v90 && &v102[6 * v103] > &v90)
              {
                int64_t v78 = (char *)&v90 - (char *)v102;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v65, 24);
                unint64_t v7 = v102;
                long long v6 = (int *)((char *)v102 + v78);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v65, 24);
                long long v6 = &v90;
                unint64_t v7 = v102;
              }
            }
            size_t v8 = &v7[6 * v103];
            long long v9 = *(_OWORD *)v6;
            *((void *)v8 + 2) = *((void *)v6 + 2);
            *(_OWORD *)size_t v8 = v9;
            uint64_t v10 = ++v103;
            if (v101[0])
            {
              int v90 = 3;
              uint64_t v91 = "::mlir::mps::CallInlineMode";
              uint64_t v92 = 27;
              uint64_t v11 = &v90;
              long long v12 = v102;
              if (v10 >= v104)
              {
                unint64_t v66 = v10 + 1;
                BOOL v67 = &v102[6 * v10] > &v90;
                if (v102 <= &v90 && v67)
                {
                  int64_t v79 = (char *)&v90 - (char *)v102;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v66, 24);
                  long long v12 = v102;
                  uint64_t v11 = (int *)((char *)v102 + v79);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v66, 24);
                  uint64_t v11 = &v90;
                  long long v12 = v102;
                }
              }
              uint64_t v13 = &v12[6 * v103];
              long long v14 = *(_OWORD *)v11;
              *((void *)v13 + 2) = *((void *)v11 + 2);
              *(_OWORD *)uint64_t v13 = v14;
              uint64_t v15 = ++v103;
              if (v101[0])
              {
                int v90 = 3;
                uint64_t v91 = " to be one of: ";
                uint64_t v92 = 15;
                long long v16 = &v90;
                uint64_t v17 = v102;
                if (v15 >= v104)
                {
                  unint64_t v68 = v15 + 1;
                  BOOL v69 = &v102[6 * v15] > &v90;
                  if (v102 <= &v90 && v69)
                  {
                    int64_t v80 = (char *)&v90 - (char *)v102;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v68, 24);
                    uint64_t v17 = v102;
                    long long v16 = (int *)((char *)v102 + v80);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v68, 24);
                    long long v16 = &v90;
                    uint64_t v17 = v102;
                  }
                }
                long long v18 = &v17[6 * v103];
                long long v19 = *(_OWORD *)v16;
                *((void *)v18 + 2) = *((void *)v16 + 2);
                *(_OWORD *)long long v18 = v19;
                uint64_t v20 = ++v103;
                if (v101[0])
                {
                  int v90 = 3;
                  uint64_t v91 = "off";
                  uint64_t v92 = 3;
                  char v21 = &v90;
                  uint64_t v22 = v102;
                  if (v20 >= v104)
                  {
                    unint64_t v70 = v20 + 1;
                    BOOL v71 = &v102[6 * v20] > &v90;
                    if (v102 <= &v90 && v71)
                    {
                      int64_t v81 = (char *)&v90 - (char *)v102;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v70, 24);
                      uint64_t v22 = v102;
                      char v21 = (int *)((char *)v102 + v81);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v70, 24);
                      char v21 = &v90;
                      uint64_t v22 = v102;
                    }
                  }
                  long long v23 = &v22[6 * v103];
                  long long v24 = *(_OWORD *)v21;
                  *((void *)v23 + 2) = *((void *)v21 + 2);
                  *(_OWORD *)long long v23 = v24;
                  uint64_t v25 = ++v103;
                  if (v101[0])
                  {
                    int v90 = 3;
                    uint64_t v91 = ", ";
                    uint64_t v92 = 2;
                    uint64_t v26 = &v90;
                    uint64_t v27 = v102;
                    if (v25 >= v104)
                    {
                      unint64_t v72 = v25 + 1;
                      if (v102 <= &v90 && &v102[6 * v25] > &v90)
                      {
                        int64_t v82 = (char *)&v90 - (char *)v102;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v72, 24);
                        uint64_t v27 = v102;
                        uint64_t v26 = (int *)((char *)v102 + v82);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v72, 24);
                        uint64_t v26 = &v90;
                        uint64_t v27 = v102;
                      }
                    }
                    long long v28 = &v27[6 * v103];
                    long long v29 = *(_OWORD *)v26;
                    *((void *)v28 + 2) = *((void *)v26 + 2);
                    *(_OWORD *)long long v28 = v29;
                    uint64_t v30 = ++v103;
                    if (v101[0])
                    {
                      int v90 = 3;
                      uint64_t v91 = "on";
                      uint64_t v92 = 2;
                      uint64_t v31 = &v90;
                      uint64_t v32 = v102;
                      if (v30 >= v104)
                      {
                        unint64_t v73 = v30 + 1;
                        if (v102 <= &v90 && &v102[6 * v30] > &v90)
                        {
                          int64_t v83 = (char *)&v90 - (char *)v102;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v73, 24);
                          uint64_t v32 = v102;
                          uint64_t v31 = (int *)((char *)v102 + v83);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v73, 24);
                          uint64_t v31 = &v90;
                          uint64_t v32 = v102;
                        }
                      }
                      long long v33 = &v32[6 * v103];
                      long long v34 = *(_OWORD *)v31;
                      *((void *)v33 + 2) = *((void *)v31 + 2);
                      *(_OWORD *)long long v33 = v34;
                      uint64_t v35 = ++v103;
                      if (v101[0])
                      {
                        int v90 = 3;
                        uint64_t v91 = ", ";
                        uint64_t v92 = 2;
                        unint64_t v36 = &v90;
                        unint64_t v37 = v102;
                        if (v35 >= v104)
                        {
                          unint64_t v74 = v35 + 1;
                          BOOL v75 = &v102[6 * v35] > &v90;
                          if (v102 <= &v90 && v75)
                          {
                            int64_t v84 = (char *)&v90 - (char *)v102;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v74, 24);
                            unint64_t v37 = v102;
                            unint64_t v36 = (int *)((char *)v102 + v84);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v74, 24);
                            unint64_t v36 = &v90;
                            unint64_t v37 = v102;
                          }
                        }
                        unint64_t v38 = &v37[6 * v103];
                        long long v39 = *(_OWORD *)v36;
                        *((void *)v38 + 2) = *((void *)v36 + 2);
                        *(_OWORD *)unint64_t v38 = v39;
                        uint64_t v40 = ++v103;
                        if (v101[0])
                        {
                          int v90 = 3;
                          uint64_t v91 = "automatic";
                          uint64_t v92 = 9;
                          unint64_t v41 = &v90;
                          uint64_t v42 = v102;
                          if (v40 >= v104)
                          {
                            unint64_t v76 = v40 + 1;
                            BOOL v77 = &v102[6 * v40] > &v90;
                            if (v102 <= &v90 && v77)
                            {
                              int64_t v85 = (char *)&v90 - (char *)v102;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v76, 24);
                              uint64_t v42 = v102;
                              unint64_t v41 = (int *)((char *)v102 + v85);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v76, 24);
                              unint64_t v41 = &v90;
                              uint64_t v42 = v102;
                            }
                          }
                          unint64_t v43 = &v42[6 * v103];
                          long long v44 = *(_OWORD *)v41;
                          *((void *)v43 + 2) = *((void *)v41 + 2);
                          *(_OWORD *)unint64_t v43 = v44;
                          ++v103;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v101);
          if (v101[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v101);
          }
          if (v110)
          {
            unint64_t v45 = v108;
            if (v108)
            {
              uint64_t v46 = v109;
              int64_t v47 = v108;
              if (v109 != v108)
              {
                do
                  uint64_t v46 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v46 - 1);
                while (v46 != v45);
                int64_t v47 = v108;
              }
              char v109 = v45;
              operator delete(v47);
            }
            int64_t v48 = v106;
            if (v106)
            {
              int64_t v49 = v107;
              long long v50 = v106;
              if (v107 != v106)
              {
                do
                {
                  char v52 = (void *)*--v49;
                  uint64_t v51 = v52;
                  void *v49 = 0;
                  if (v52) {
                    operator delete[](v51);
                  }
                }
                while (v49 != v48);
                long long v50 = v106;
              }
              __int16 v107 = v48;
              operator delete(v50);
            }
            if (v102 != (int *)v105) {
              free(v102);
            }
          }
          goto LABEL_53;
        }
        unsigned int v4 = 1;
        break;
      case 9:
        if (*(void *)v88 != 0x6974616D6F747561 || *(unsigned char *)(v88 + 8) != 99) {
          goto LABEL_18;
        }
        unsigned int v4 = 2;
        break;
      case 3:
        if (*(_WORD *)v88 != 26223 || *(unsigned char *)(v88 + 2) != 102) {
          goto LABEL_18;
        }
        unsigned int v4 = 0;
        break;
      default:
        goto LABEL_18;
    }
    if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
    {
      uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v86[0] = v4;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v101[0] = &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id;
      v101[1] = Context;
      return mlir::StorageUniquer::get<mlir::mps::detail::CallInlineModeAttrStorage,mlir::mps::CallInlineMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25CallInlineModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18CallInlineModeAttrEJNS2_14CallInlineModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v101, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id, v86);
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::CallInlineModeAttr::print(mlir::mps::CallInlineModeAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) != v5)
  {
    unsigned char *v5 = 60;
    ++*((void *)v4 + 4);
    int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6) {
      goto LABEL_3;
    }
LABEL_11:
    BOOL v7 = 0;
    long long v9 = "off";
    size_t v8 = 3;
    goto LABEL_13;
  }
  llvm::raw_ostream::write(v4, "<", 1uLL);
  int v6 = *(_DWORD *)(*(void *)this + 8);
  if (!v6) {
    goto LABEL_11;
  }
LABEL_3:
  if (v6 == 2)
  {
    BOOL v7 = 0;
    long long v9 = "automatic";
    size_t v8 = 9;
  }
  else
  {
    BOOL v7 = v6 != 1;
    if (v6 == 1) {
      size_t v8 = 2;
    }
    else {
      size_t v8 = 0;
    }
    if (v6 == 1) {
      long long v9 = "on";
    }
    else {
      long long v9 = "";
    }
  }
LABEL_13:
  uint64_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v11 = (void *)*((void *)v10 + 4);
  if (v8 <= *((void *)v10 + 3) - (void)v11)
  {
    if (!v7)
    {
      memcpy(v11, v9, v8);
      *((void *)v10 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v9, v8);
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    unsigned char *v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::MPSDialect::parseAttribute(uint64_t a1, mlir::AsmParser *a2, void *a3)
{
  uint64_t v97 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a2 + 40))(a2);
  int64_t v85 = a2;
  uint64_t v7 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a2 + 40))(a2);
  BYTE2(v89) = 0;
  uint64_t v87 = 0;
  uint64_t v88 = 0;
  uint64_t v86 = v7;
  LOBYTE(v89) = 0;
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *, uint64_t *))(*(void *)a2 + 608))(a2, &v87))
  {
    LOWORD(v89) = 256;
    if (!BYTE2(v89)) {
      BYTE2(v89) = 1;
    }
    goto LABEL_238;
  }
  int64_t v81 = (const void **)"tensor_data_layout";
  uint64_t v82 = 18;
  if (BYTE2(v89))
  {
LABEL_238:
    uint64_t v47 = 0;
LABEL_239:
    size_t v8 = 0;
    int64_t v48 = 0;
    goto LABEL_240;
  }
  size_t v8 = v88;
  if (v88)
  {
    if (v88 == (void *)18)
    {
      BOOL v9 = *(void *)v87 == 0x645F726F736E6574 && *(void *)(v87 + 8) == 0x6F79616C5F617461;
      if (v9 && *(_WORD *)(v87 + 16) == 29813)
      {
        uint64_t v72 = mlir::mps::TensorDataLayoutAttr::parse(a2);
        goto LABEL_301;
      }
    }
    int64_t v81 = (const void **)"reduction_mode";
    uint64_t v82 = 14;
  }
  else
  {
    (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
    int64_t v81 = (const void **)"reduction_mode";
    uint64_t v82 = 14;
    if (BYTE2(v89)) {
      goto LABEL_238;
    }
    size_t v8 = v88;
    if (!v88)
    {
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (const void **)"device_hint";
      uint64_t v82 = 11;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_19;
      }
LABEL_197:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (const void **)"scatter_mode";
      uint64_t v82 = 12;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_25;
      }
LABEL_199:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (const void **)"padding_mode";
      uint64_t v82 = 12;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_31;
      }
LABEL_201:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (const void **)"sampling_mode";
      uint64_t v82 = 13;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_37;
      }
LABEL_203:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (const void **)"nearest_rounding_mode";
      uint64_t v82 = 21;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_43;
      }
LABEL_205:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (const void **)"sparse_tensor_storage";
      uint64_t v82 = 21;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_52;
      }
LABEL_207:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (const void **)"texture_tensor_pixel_format";
      uint64_t v82 = 27;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_61;
      }
LABEL_209:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (const void **)"random_normal_sampling_method";
      uint64_t v82 = 29;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_73;
      }
LABEL_211:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (const void **)"padding_style";
      uint64_t v82 = 13;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_85;
      }
LABEL_213:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (const void **)"pooling_indices_mode";
      uint64_t v82 = 20;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_91;
      }
LABEL_215:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (const void **)"rnn_activation";
      uint64_t v82 = 14;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_100;
      }
LABEL_217:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (const void **)"lstm_gate_layout";
      uint64_t v82 = 16;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_106;
      }
LABEL_219:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (const void **)"gru_gate_layout";
      uint64_t v82 = 15;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_112;
      }
LABEL_221:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (const void **)"stencil_padding_mode";
      uint64_t v82 = 20;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_118;
      }
LABEL_223:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (const void **)"crop_resize_alignment_mode";
      uint64_t v82 = 26;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_127;
      }
LABEL_225:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (const void **)"crop_resize_coordinate_mode";
      uint64_t v82 = 27;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_139;
      }
LABEL_227:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (const void **)"pruning_metric";
      uint64_t v82 = 14;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_151;
      }
      goto LABEL_229;
    }
  }
  if (v8 == (void *)14 && *(void *)v87 == 0x6F69746375646572 && *(void *)(v87 + 6) == 0x65646F6D5F6E6F69)
  {
    uint64_t v72 = mlir::mps::ReductionModeAttr::parse(a2);
    goto LABEL_301;
  }
  int64_t v81 = (const void **)"device_hint";
  uint64_t v82 = 11;
  if (!v8) {
    goto LABEL_197;
  }
LABEL_19:
  if (v8 == (void *)11 && *(void *)v87 == 0x685F656369766564 && *(void *)(v87 + 3) == 0x746E69685F656369)
  {
    uint64_t v72 = mlir::mps::DeviceHintAttr::parse(a2);
    goto LABEL_301;
  }
  int64_t v81 = (const void **)"scatter_mode";
  uint64_t v82 = 12;
  if (!v8) {
    goto LABEL_199;
  }
LABEL_25:
  if (v8 == (void *)12 && *(void *)v87 == 0x5F72657474616373 && *(_DWORD *)(v87 + 8) == 1701080941)
  {
    uint64_t v72 = mlir::mps::ScatterModeAttr::parse(a2);
    goto LABEL_301;
  }
  int64_t v81 = (const void **)"padding_mode";
  uint64_t v82 = 12;
  if (!v8) {
    goto LABEL_201;
  }
LABEL_31:
  if (v8 == (void *)12 && *(void *)v87 == 0x5F676E6964646170 && *(_DWORD *)(v87 + 8) == 1701080941)
  {
    uint64_t v72 = mlir::mps::PaddingModeAttr::parse(a2);
    goto LABEL_301;
  }
  int64_t v81 = (const void **)"sampling_mode";
  uint64_t v82 = 13;
  if (!v8) {
    goto LABEL_203;
  }
LABEL_37:
  if (v8 == (void *)13 && *(void *)v87 == 0x676E696C706D6173 && *(void *)(v87 + 5) == 0x65646F6D5F676E69)
  {
    uint64_t v72 = mlir::mps::SamplingModeAttr::parse(a2);
    goto LABEL_301;
  }
  int64_t v81 = (const void **)"nearest_rounding_mode";
  uint64_t v82 = 21;
  if (!v8) {
    goto LABEL_205;
  }
LABEL_43:
  if (v8 == (void *)21)
  {
    BOOL v16 = *(void *)v87 == 0x5F7473657261656ELL && *(void *)(v87 + 8) == 0x676E69646E756F72;
    if (v16 && *(void *)(v87 + 13) == 0x65646F6D5F676E69)
    {
      uint64_t v72 = mlir::mps::NearestRoundingModeAttr::parse(a2);
      goto LABEL_301;
    }
  }
  int64_t v81 = (const void **)"sparse_tensor_storage";
  uint64_t v82 = 21;
  if (!v8) {
    goto LABEL_207;
  }
LABEL_52:
  if (v8 == (void *)21)
  {
    BOOL v18 = *(void *)v87 == 0x745F657372617073 && *(void *)(v87 + 8) == 0x74735F726F736E65;
    if (v18 && *(void *)(v87 + 13) == 0x656761726F74735FLL)
    {
      uint64_t v72 = mlir::mps::SparseTensorStorageAttr::parse(a2);
      goto LABEL_301;
    }
  }
  int64_t v81 = (const void **)"texture_tensor_pixel_format";
  uint64_t v82 = 27;
  if (!v8) {
    goto LABEL_209;
  }
LABEL_61:
  if (v8 == (void *)27)
  {
    BOOL v20 = *(void *)v87 == 0x5F65727574786574 && *(void *)(v87 + 8) == 0x705F726F736E6574;
    BOOL v21 = v20 && *(void *)(v87 + 16) == 0x726F665F6C657869;
    if (v21 && *(void *)(v87 + 19) == 0x74616D726F665F6CLL)
    {
      uint64_t v72 = mlir::mps::MetalPixelFormatAttr::parse(a2);
      goto LABEL_301;
    }
  }
  int64_t v81 = (const void **)"random_normal_sampling_method";
  uint64_t v82 = 29;
  if (!v8) {
    goto LABEL_211;
  }
LABEL_73:
  if (v8 == (void *)29)
  {
    BOOL v23 = *(void *)v87 == 0x6E5F6D6F646E6172 && *(void *)(v87 + 8) == 0x61735F6C616D726FLL;
    BOOL v24 = v23 && *(void *)(v87 + 16) == 0x6D5F676E696C706DLL;
    if (v24 && *(void *)(v87 + 21) == 0x646F6874656D5F67)
    {
      uint64_t v72 = mlir::mps::NormalSamplingMethodAttr::parse(a2);
      goto LABEL_301;
    }
  }
  int64_t v81 = (const void **)"padding_style";
  uint64_t v82 = 13;
  if (!v8) {
    goto LABEL_213;
  }
LABEL_85:
  if (v8 == (void *)13 && *(void *)v87 == 0x5F676E6964646170 && *(void *)(v87 + 5) == 0x656C7974735F676ELL)
  {
    uint64_t v72 = mlir::mps::PaddingStyleAttr::parse(a2);
    goto LABEL_301;
  }
  int64_t v81 = (const void **)"pooling_indices_mode";
  uint64_t v82 = 20;
  if (!v8) {
    goto LABEL_215;
  }
LABEL_91:
  if (v8 == (void *)20)
  {
    BOOL v27 = *(void *)v87 == 0x5F676E696C6F6F70 && *(void *)(v87 + 8) == 0x5F73656369646E69;
    if (v27 && *(_DWORD *)(v87 + 16) == 1701080941)
    {
      uint64_t v72 = mlir::mps::PoolIndicesModeAttr::parse(a2);
      goto LABEL_301;
    }
  }
  int64_t v81 = (const void **)"rnn_activation";
  uint64_t v82 = 14;
  if (!v8) {
    goto LABEL_217;
  }
LABEL_100:
  if (v8 == (void *)14 && *(void *)v87 == 0x697463615F6E6E72 && *(void *)(v87 + 6) == 0x6E6F697461766974)
  {
    uint64_t v72 = mlir::mps::RNNActivationAttr::parse(a2);
    goto LABEL_301;
  }
  int64_t v81 = (const void **)"lstm_gate_layout";
  uint64_t v82 = 16;
  if (!v8) {
    goto LABEL_219;
  }
LABEL_106:
  if (v8 == (void *)16 && *(void *)v87 == 0x7461675F6D74736CLL && *(void *)(v87 + 8) == 0x74756F79616C5F65)
  {
    uint64_t v72 = mlir::mps::LSTMGateLayoutAttr::parse(a2);
    goto LABEL_301;
  }
  int64_t v81 = (const void **)"gru_gate_layout";
  uint64_t v82 = 15;
  if (!v8) {
    goto LABEL_221;
  }
LABEL_112:
  if (v8 == (void *)15 && *(void *)v87 == 0x657461675F757267 && *(void *)(v87 + 7) == 0x74756F79616C5F65)
  {
    uint64_t v72 = mlir::mps::GRUGateLayoutAttr::parse(a2);
    goto LABEL_301;
  }
  int64_t v81 = (const void **)"stencil_padding_mode";
  uint64_t v82 = 20;
  if (!v8) {
    goto LABEL_223;
  }
LABEL_118:
  if (v8 == (void *)20)
  {
    BOOL v32 = *(void *)v87 == 0x5F6C69636E657473 && *(void *)(v87 + 8) == 0x5F676E6964646170;
    if (v32 && *(_DWORD *)(v87 + 16) == 1701080941)
    {
      uint64_t v72 = mlir::mps::StencilPaddingModeAttr::parse(a2);
      goto LABEL_301;
    }
  }
  int64_t v81 = (const void **)"crop_resize_alignment_mode";
  uint64_t v82 = 26;
  if (!v8) {
    goto LABEL_225;
  }
LABEL_127:
  if (v8 == (void *)26)
  {
    BOOL v34 = *(void *)v87 == 0x7365725F706F7263 && *(void *)(v87 + 8) == 0x67696C615F657A69;
    BOOL v35 = v34 && *(void *)(v87 + 16) == 0x6F6D5F746E656D6ELL;
    if (v35 && *(_WORD *)(v87 + 24) == 25956)
    {
      uint64_t v72 = mlir::mps::CropResizeAlignmentModeAttr::parse(a2);
      goto LABEL_301;
    }
  }
  int64_t v81 = (const void **)"crop_resize_coordinate_mode";
  uint64_t v82 = 27;
  if (!v8) {
    goto LABEL_227;
  }
LABEL_139:
  if (v8 == (void *)27)
  {
    BOOL v37 = *(void *)v87 == 0x7365725F706F7263 && *(void *)(v87 + 8) == 0x726F6F635F657A69;
    BOOL v38 = v37 && *(void *)(v87 + 16) == 0x6D5F6574616E6964;
    if (v38 && *(void *)(v87 + 19) == 0x65646F6D5F657461)
    {
      uint64_t v72 = mlir::mps::CropResizeCoordinateModeAttr::parse(a2);
      goto LABEL_301;
    }
  }
  int64_t v81 = (const void **)"pruning_metric";
  uint64_t v82 = 14;
  if (v8)
  {
LABEL_151:
    if (v8 == (void *)14 && *(void *)v87 == 0x5F676E696E757270 && *(void *)(v87 + 6) == 0x63697274656D5F67)
    {
      uint64_t v72 = mlir::mps::PruningMetricAttr::parse(a2);
      goto LABEL_301;
    }
    int64_t v81 = (const void **)"pruning_structure";
    uint64_t v82 = 17;
    if (v8) {
      goto LABEL_157;
    }
    goto LABEL_231;
  }
LABEL_229:
  (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
  int64_t v81 = (const void **)"pruning_structure";
  uint64_t v82 = 17;
  if (BYTE2(v89)) {
    goto LABEL_238;
  }
  size_t v8 = v88;
  if (v88)
  {
LABEL_157:
    if (v8 != (void *)17
      || (*(void *)v87 == 0x5F676E696E757270 ? (BOOL v41 = *(void *)(v87 + 8) == 0x7275746375727473) : (BOOL v41 = 0),
          v41 ? (BOOL v42 = *(unsigned char *)(v87 + 16) == 101) : (BOOL v42 = 0),
          !v42))
    {
      int64_t v81 = (const void **)"similarity_type";
      uint64_t v82 = 15;
      if (v8) {
        goto LABEL_166;
      }
LABEL_233:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (const void **)"fft_scaling_mode";
      uint64_t v82 = 16;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_172;
      }
      goto LABEL_235;
    }
    uint64_t v72 = mlir::mps::PruningStructureAttr::parse(a2);
LABEL_301:
    uint64_t v47 = v72;
    LOBYTE(v89) = v72 != 0;
    *(_WORD *)((char *)&v89 + 1) = 257;
    goto LABEL_239;
  }
LABEL_231:
  (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
  int64_t v81 = (const void **)"similarity_type";
  uint64_t v82 = 15;
  if (BYTE2(v89)) {
    goto LABEL_238;
  }
  size_t v8 = v88;
  if (!v88) {
    goto LABEL_233;
  }
LABEL_166:
  if (v8 == (void *)15 && *(void *)v87 == 0x6972616C696D6973 && *(void *)(v87 + 7) == 0x657079745F797469)
  {
    uint64_t v72 = mlir::mps::SimilarityTypeAttr::parse(a2);
    goto LABEL_301;
  }
  int64_t v81 = (const void **)"fft_scaling_mode";
  uint64_t v82 = 16;
  if (!v8)
  {
LABEL_235:
    (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
    int64_t v81 = (const void **)"buffer_tensor";
    uint64_t v82 = 13;
    if (!BYTE2(v89))
    {
      size_t v8 = v88;
      if (v88) {
        goto LABEL_178;
      }
      goto LABEL_237;
    }
    goto LABEL_238;
  }
LABEL_172:
  if (v8 == (void *)16 && *(void *)v87 == 0x6C6163735F746666 && *(void *)(v87 + 8) == 0x65646F6D5F676E69)
  {
    uint64_t v72 = mlir::mps::FFTScalingModeAttr::parse(a2);
    goto LABEL_301;
  }
  int64_t v81 = (const void **)"buffer_tensor";
  uint64_t v82 = 13;
  if (!v8)
  {
LABEL_237:
    (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
    int64_t v81 = (const void **)"call_inline_mode";
    uint64_t v82 = 16;
    if (!BYTE2(v89))
    {
      size_t v8 = v88;
      if (v88) {
        goto LABEL_184;
      }
      goto LABEL_303;
    }
    goto LABEL_238;
  }
LABEL_178:
  if (v8 == (void *)13 && *(void *)v87 == 0x745F726566667562 && *(void *)(v87 + 5) == 0x726F736E65745F72)
  {
    uint64_t v72 = mlir::mps::MPSBufferTensorAttr::parse(a2, a3);
    goto LABEL_301;
  }
  int64_t v81 = (const void **)"call_inline_mode";
  uint64_t v82 = 16;
  if (v8)
  {
LABEL_184:
    if (v8 == (void *)16 && *(void *)v87 == 0x6C6E695F6C6C6163 && *(void *)(v87 + 8) == 0x65646F6D5F656E69)
    {
      uint64_t v47 = mlir::mps::CallInlineModeAttr::parse(a2);
      size_t v8 = 0;
      int64_t v48 = 0;
      LOBYTE(v89) = v47 != 0;
      *(_WORD *)((char *)&v89 + 1) = 257;
      goto LABEL_240;
    }
    goto LABEL_306;
  }
LABEL_303:
  (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
  if (BYTE2(v89))
  {
    size_t v8 = 0;
    int64_t v48 = 0;
    uint64_t v47 = 0;
    goto LABEL_240;
  }
  size_t v8 = v88;
LABEL_306:
  uint64_t v47 = 0;
  int64_t v48 = (const void **)v87;
  LOWORD(v89) = 0;
  BYTE2(v89) = 1;
LABEL_240:
  if ((unsigned __int16)mlir::AsmParser::KeywordSwitch<mlir::OptionalParseResult>::operator mlir::OptionalParseResult((uint64_t)&v85) <= 0xFFu)
  {
    __int16 v80 = 257;
    (*(void (**)(mlir::AsmParser **__return_ptr, mlir::AsmParser *, uint64_t, char *))(*(void *)a2 + 24))(&v85, a2, v6, v79);
    if (v85)
    {
      LODWORD(v81) = 3;
      uint64_t v83 = 19;
      int64_t v49 = &v81;
      long long v50 = (char *)v88;
      if (v89 >= v90)
      {
        unint64_t v73 = v89 + 1;
        if (v88 <= &v81 && (char *)v88 + 24 * v89 > (char *)&v81)
        {
          int64_t v76 = (char *)&v81 - (unsigned char *)v88;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v73, 24);
          long long v50 = (char *)v88;
          int64_t v49 = (const void ***)((char *)v88 + v76);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v73, 24);
          int64_t v49 = &v81;
          long long v50 = (char *)v88;
        }
      }
      uint64_t v51 = &v50[24 * v89];
      long long v52 = *(_OWORD *)v49;
      *((void *)v51 + 2) = v49[2];
      *(_OWORD *)uint64_t v51 = v52;
      ++v89;
      if (v85)
      {
        __int16 v84 = 261;
        int64_t v81 = v48;
        uint64_t v82 = (uint64_t)v8;
        mlir::Diagnostic::operator<<((uint64_t)&v86, &v81);
        if (v85)
        {
          LODWORD(v81) = 3;
          uint64_t v83 = 14;
          uint64_t v53 = &v81;
          uint64_t v54 = (char *)v88;
          if (v89 >= v90)
          {
            unint64_t v74 = v89 + 1;
            if (v88 <= &v81 && (char *)v88 + 24 * v89 > (char *)&v81)
            {
              int64_t v77 = (char *)&v81 - (unsigned char *)v88;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v74, 24);
              uint64_t v54 = (char *)v88;
              uint64_t v53 = (const void ***)((char *)v88 + v77);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v74, 24);
              uint64_t v53 = &v81;
              uint64_t v54 = (char *)v88;
            }
          }
          unint64_t v55 = &v54[24 * v89];
          long long v56 = *(_OWORD *)v53;
          *((void *)v55 + 2) = v53[2];
          *(_OWORD *)unint64_t v55 = v56;
          ++v89;
          if (v85)
          {
            __int16 v57 = *(const void ***)(a1 + 8);
            uint64_t v58 = *(void *)(a1 + 16);
            __int16 v84 = 261;
            int64_t v81 = v57;
            uint64_t v82 = v58;
            mlir::Diagnostic::operator<<((uint64_t)&v86, &v81);
            if (v85)
            {
              LODWORD(v81) = 3;
              uint64_t v83 = 1;
              char v59 = &v81;
              uint64_t v60 = (char *)v88;
              if (v89 >= v90)
              {
                unint64_t v75 = v89 + 1;
                if (v88 <= &v81 && (char *)v88 + 24 * v89 > (char *)&v81)
                {
                  int64_t v78 = (char *)&v81 - (unsigned char *)v88;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v75, 24);
                  uint64_t v60 = (char *)v88;
                  char v59 = (const void ***)((char *)v88 + v78);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v75, 24);
                  char v59 = &v81;
                  uint64_t v60 = (char *)v88;
                }
              }
              unint64_t v61 = &v60[24 * v89];
              long long v62 = *(_OWORD *)v59;
              *((void *)v61 + 2) = v59[2];
              *(_OWORD *)unint64_t v61 = v62;
              ++v89;
              if (v85) {
                mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v85);
              }
            }
          }
        }
      }
    }
    if (v96)
    {
      unint64_t v63 = (void **)__p;
      if (__p)
      {
        unsigned int v64 = v95;
        unint64_t v65 = __p;
        if (v95 != __p)
        {
          do
            unsigned int v64 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v64 - 1);
          while (v64 != v63);
          unint64_t v65 = __p;
        }
        uint64_t v95 = v63;
        operator delete(v65);
      }
      unint64_t v66 = v92;
      if (v92)
      {
        BOOL v67 = v93;
        unint64_t v68 = v92;
        if (v93 != v92)
        {
          do
          {
            unint64_t v70 = (void *)*--v67;
            BOOL v69 = v70;
            *BOOL v67 = 0;
            if (v70) {
              operator delete[](v69);
            }
          }
          while (v67 != v66);
          unint64_t v68 = v92;
        }
        BOOL v93 = v66;
        operator delete(v68);
      }
      if (v88 != v91) {
        free(v88);
      }
    }
    return 0;
  }
  return v47;
}

void mlir::mps::MPSDialect::printAttribute(uint64_t a1, uint64_t a2, mlir::AsmPrinter *a3)
{
  unsigned int v4 = *(void **)(*(void *)a2 + 136);
  if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    uint64_t v53 = a2;
    uint64_t v7 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v8 = *((void *)v7 + 4);
    if ((unint64_t)(*((void *)v7 + 3) - v8) > 0x11)
    {
      *(_WORD *)(v8 + 16) = 29813;
      *(_OWORD *)uint64_t v8 = *(_OWORD *)"tensor_data_layout";
      *((void *)v7 + 4) += 18;
    }
    else
    {
      llvm::raw_ostream::write(v7, "tensor_data_layout", 0x12uLL);
    }
    mlir::mps::TensorDataLayoutAttr::print((mlir::mps::TensorDataLayoutAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::ReductionModeAttr,void>::id)
  {
    uint64_t v53 = a2;
    BOOL v9 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v10 = (void *)*((void *)v9 + 4);
    if (*((void *)v9 + 3) - (void)v10 > 0xDuLL)
    {
      qmemcpy(v10, "reduction_mode", 14);
      *((void *)v9 + 4) += 14;
    }
    else
    {
      llvm::raw_ostream::write(v9, "reduction_mode", 0xEuLL);
    }
    mlir::mps::ReductionModeAttr::print((mlir::mps::ReductionModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::DeviceHintAttr,void>::id)
  {
    uint64_t v53 = a2;
    uint64_t v11 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v12 = *((void *)v11 + 4);
    if ((unint64_t)(*((void *)v11 + 3) - v12) > 0xA)
    {
      *(_DWORD *)(v12 + 7) = 1953393000;
      *(void *)uint64_t v12 = *(void *)"device_hint";
      *((void *)v11 + 4) += 11;
    }
    else
    {
      llvm::raw_ostream::write(v11, "device_hint", 0xBuLL);
    }
    mlir::mps::DeviceHintAttr::print((mlir::mps::DeviceHintAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::ScatterModeAttr,void>::id)
  {
    uint64_t v53 = a2;
    uint64_t v13 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v14 = *((void *)v13 + 4);
    if ((unint64_t)(*((void *)v13 + 3) - v14) > 0xB)
    {
      *(_DWORD *)(v14 + 8) = 1701080941;
      *(void *)uint64_t v14 = *(void *)"scatter_mode";
      *((void *)v13 + 4) += 12;
    }
    else
    {
      llvm::raw_ostream::write(v13, "scatter_mode", 0xCuLL);
    }
    mlir::mps::ScatterModeAttr::print((mlir::mps::ScatterModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::PaddingModeAttr,void>::id)
  {
    uint64_t v53 = a2;
    uint64_t v15 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v16 = *((void *)v15 + 4);
    if ((unint64_t)(*((void *)v15 + 3) - v16) > 0xB)
    {
      *(_DWORD *)(v16 + 8) = 1701080941;
      *(void *)uint64_t v16 = *(void *)"padding_mode";
      *((void *)v15 + 4) += 12;
    }
    else
    {
      llvm::raw_ostream::write(v15, "padding_mode", 0xCuLL);
    }
    mlir::mps::PaddingModeAttr::print((mlir::mps::PaddingModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id)
  {
    uint64_t v53 = a2;
    uint64_t v17 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    BOOL v18 = (void *)*((void *)v17 + 4);
    if (*((void *)v17 + 3) - (void)v18 > 0xCuLL)
    {
      qmemcpy(v18, "sampling_mode", 13);
      *((void *)v17 + 4) += 13;
    }
    else
    {
      llvm::raw_ostream::write(v17, "sampling_mode", 0xDuLL);
    }
    mlir::mps::SamplingModeAttr::print((mlir::mps::SamplingModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::NearestRoundingModeAttr,void>::id)
  {
    uint64_t v53 = a2;
    long long v19 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    BOOL v20 = (void *)*((void *)v19 + 4);
    if (*((void *)v19 + 3) - (void)v20 > 0x14uLL)
    {
      qmemcpy(v20, "nearest_rounding_mode", 21);
      *((void *)v19 + 4) += 21;
    }
    else
    {
      llvm::raw_ostream::write(v19, "nearest_rounding_mode", 0x15uLL);
    }
    mlir::mps::NearestRoundingModeAttr::print((mlir::mps::NearestRoundingModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id)
  {
    uint64_t v53 = a2;
    BOOL v21 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v22 = (void *)*((void *)v21 + 4);
    if (*((void *)v21 + 3) - (void)v22 > 0x14uLL)
    {
      qmemcpy(v22, "sparse_tensor_storage", 21);
      *((void *)v21 + 4) += 21;
    }
    else
    {
      llvm::raw_ostream::write(v21, "sparse_tensor_storage", 0x15uLL);
    }
    mlir::mps::SparseTensorStorageAttr::print((mlir::mps::SparseTensorStorageAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id)
  {
    uint64_t v53 = a2;
    BOOL v23 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    BOOL v24 = (void *)*((void *)v23 + 4);
    if (*((void *)v23 + 3) - (void)v24 > 0x1AuLL)
    {
      qmemcpy(v24, "texture_tensor_pixel_format", 27);
      *((void *)v23 + 4) += 27;
    }
    else
    {
      llvm::raw_ostream::write(v23, "texture_tensor_pixel_format", 0x1BuLL);
    }
    mlir::mps::MetalPixelFormatAttr::print((mlir::mps::MetalPixelFormatAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::NormalSamplingMethodAttr,void>::id)
  {
    uint64_t v53 = a2;
    uint64_t v25 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v26 = (void *)*((void *)v25 + 4);
    if (*((void *)v25 + 3) - (void)v26 > 0x1CuLL)
    {
      qmemcpy(v26, "random_normal_sampling_method", 29);
      *((void *)v25 + 4) += 29;
    }
    else
    {
      llvm::raw_ostream::write(v25, "random_normal_sampling_method", 0x1DuLL);
    }
    mlir::mps::NormalSamplingMethodAttr::print((mlir::mps::NormalSamplingMethodAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
  {
    uint64_t v53 = a2;
    BOOL v27 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    long long v28 = (void *)*((void *)v27 + 4);
    if (*((void *)v27 + 3) - (void)v28 > 0xCuLL)
    {
      qmemcpy(v28, "padding_style", 13);
      *((void *)v27 + 4) += 13;
    }
    else
    {
      llvm::raw_ostream::write(v27, "padding_style", 0xDuLL);
    }
    mlir::mps::PaddingStyleAttr::print((mlir::mps::PaddingStyleAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id)
  {
    uint64_t v53 = a2;
    long long v29 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v30 = *((void *)v29 + 4);
    if ((unint64_t)(*((void *)v29 + 3) - v30) > 0x13)
    {
      *(_DWORD *)(v30 + 16) = 1701080941;
      *(_OWORD *)uint64_t v30 = *(_OWORD *)"pooling_indices_mode";
      *((void *)v29 + 4) += 20;
    }
    else
    {
      llvm::raw_ostream::write(v29, "pooling_indices_mode", 0x14uLL);
    }
    mlir::mps::PoolIndicesModeAttr::print((mlir::mps::PoolIndicesModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
  {
    uint64_t v53 = a2;
    uint64_t v31 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    BOOL v32 = (void *)*((void *)v31 + 4);
    if (*((void *)v31 + 3) - (void)v32 > 0xDuLL)
    {
      qmemcpy(v32, "rnn_activation", 14);
      *((void *)v31 + 4) += 14;
    }
    else
    {
      llvm::raw_ostream::write(v31, "rnn_activation", 0xEuLL);
    }
    mlir::mps::RNNActivationAttr::print((mlir::mps::RNNActivationAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id)
  {
    uint64_t v53 = a2;
    long long v33 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    BOOL v34 = (_OWORD *)*((void *)v33 + 4);
    if (*((void *)v33 + 3) - (void)v34 > 0xFuLL)
    {
      *BOOL v34 = *(_OWORD *)"lstm_gate_layout";
      *((void *)v33 + 4) += 16;
    }
    else
    {
      llvm::raw_ostream::write(v33, "lstm_gate_layout", 0x10uLL);
    }
    mlir::mps::LSTMGateLayoutAttr::print((mlir::mps::LSTMGateLayoutAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id)
  {
    uint64_t v53 = a2;
    BOOL v35 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    unint64_t v36 = (void *)*((void *)v35 + 4);
    if (*((void *)v35 + 3) - (void)v36 > 0xEuLL)
    {
      qmemcpy(v36, "gru_gate_layout", 15);
      *((void *)v35 + 4) += 15;
    }
    else
    {
      llvm::raw_ostream::write(v35, "gru_gate_layout", 0xFuLL);
    }
    mlir::mps::GRUGateLayoutAttr::print((mlir::mps::GRUGateLayoutAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::StencilPaddingModeAttr,void>::id)
  {
    uint64_t v53 = a2;
    BOOL v37 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v38 = *((void *)v37 + 4);
    if ((unint64_t)(*((void *)v37 + 3) - v38) > 0x13)
    {
      *(_DWORD *)(v38 + 16) = 1701080941;
      *(_OWORD *)uint64_t v38 = *(_OWORD *)"stencil_padding_mode";
      *((void *)v37 + 4) += 20;
    }
    else
    {
      llvm::raw_ostream::write(v37, "stencil_padding_mode", 0x14uLL);
    }
    mlir::mps::StencilPaddingModeAttr::print((mlir::mps::StencilPaddingModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id)
  {
    uint64_t v53 = a2;
    long long v39 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v40 = (void *)*((void *)v39 + 4);
    if (*((void *)v39 + 3) - (void)v40 > 0x19uLL)
    {
      qmemcpy(v40, "crop_resize_alignment_mode", 26);
      *((void *)v39 + 4) += 26;
    }
    else
    {
      llvm::raw_ostream::write(v39, "crop_resize_alignment_mode", 0x1AuLL);
    }
    mlir::mps::CropResizeAlignmentModeAttr::print((mlir::mps::CropResizeAlignmentModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id)
  {
    uint64_t v53 = a2;
    BOOL v41 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    BOOL v42 = (void *)*((void *)v41 + 4);
    if (*((void *)v41 + 3) - (void)v42 > 0x1AuLL)
    {
      qmemcpy(v42, "crop_resize_coordinate_mode", 27);
      *((void *)v41 + 4) += 27;
    }
    else
    {
      llvm::raw_ostream::write(v41, "crop_resize_coordinate_mode", 0x1BuLL);
    }
    mlir::mps::CropResizeCoordinateModeAttr::print((mlir::mps::CropResizeCoordinateModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id)
  {
    uint64_t v53 = a2;
    unint64_t v43 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    long long v44 = (void *)*((void *)v43 + 4);
    if (*((void *)v43 + 3) - (void)v44 > 0xDuLL)
    {
      qmemcpy(v44, "pruning_metric", 14);
      *((void *)v43 + 4) += 14;
    }
    else
    {
      llvm::raw_ostream::write(v43, "pruning_metric", 0xEuLL);
    }
    mlir::mps::PruningMetricAttr::print((mlir::mps::PruningMetricAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id)
  {
    uint64_t v53 = a2;
    unint64_t v45 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v46 = *((void *)v45 + 4);
    if ((unint64_t)(*((void *)v45 + 3) - v46) > 0x10)
    {
      *(unsigned char *)(v46 + 16) = 101;
      *(_OWORD *)uint64_t v46 = *(_OWORD *)"pruning_structure";
      *((void *)v45 + 4) += 17;
    }
    else
    {
      llvm::raw_ostream::write(v45, "pruning_structure", 0x11uLL);
    }
    mlir::mps::PruningStructureAttr::print((mlir::mps::PruningStructureAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id)
  {
    uint64_t v53 = a2;
    uint64_t v47 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    int64_t v48 = (void *)*((void *)v47 + 4);
    if (*((void *)v47 + 3) - (void)v48 > 0xEuLL)
    {
      qmemcpy(v48, "similarity_type", 15);
      *((void *)v47 + 4) += 15;
    }
    else
    {
      llvm::raw_ostream::write(v47, "similarity_type", 0xFuLL);
    }
    mlir::mps::SimilarityTypeAttr::print((mlir::mps::SimilarityTypeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id)
  {
    uint64_t v53 = a2;
    int64_t v49 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    long long v50 = (_OWORD *)*((void *)v49 + 4);
    if (*((void *)v49 + 3) - (void)v50 > 0xFuLL)
    {
      *long long v50 = *(_OWORD *)"fft_scaling_mode";
      *((void *)v49 + 4) += 16;
    }
    else
    {
      llvm::raw_ostream::write(v49, "fft_scaling_mode", 0x10uLL);
    }
    mlir::mps::FFTScalingModeAttr::print((mlir::mps::FFTScalingModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
  {
    uint64_t v53 = a2;
    uint64_t v51 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    long long v52 = (void *)*((void *)v51 + 4);
    if (*((void *)v51 + 3) - (void)v52 > 0xCuLL)
    {
      qmemcpy(v52, "buffer_tensor", 13);
      *((void *)v51 + 4) += 13;
    }
    else
    {
      llvm::raw_ostream::write(v51, "buffer_tensor", 0xDuLL);
    }
    mlir::mps::MPSBufferTensorAttr::print((mlir::mps::MPSBufferTensorAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id)
  {
    uint64_t v53 = a2;
    unsigned int v5 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v6 = (_OWORD *)*((void *)v5 + 4);
    if (*((void *)v5 + 3) - (void)v6 > 0xFuLL)
    {
      _OWORD *v6 = *(_OWORD *)"call_inline_mode";
      *((void *)v5 + 4) += 16;
    }
    else
    {
      llvm::raw_ostream::write(v5, "call_inline_mode", 0x10uLL);
    }
    mlir::mps::CallInlineModeAttr::print((mlir::mps::CallInlineModeAttr *)&v53, a3);
  }
}

uint64_t mlir::mps::detail::ACosOpGenericAdaptorBase::ACosOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.acos", 8, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::ACosOp::build(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v11, 1);
  __src = v16;
  uint64_t v15 = 0x200000000;
  mlir::ValueRange::ValueRange((unint64_t *)&v13, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v12, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  long long v17 = v13;
  if (v15 != 1)
  {
    if (!v15)
    {
      if (HIDWORD(v15))
      {
        unsigned int v5 = 0;
LABEL_6:
        bzero((char *)__src + 8 * v5, 8 - 8 * v5);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v16, 1uLL, 8);
      unsigned int v5 = v15;
      if (v15 != 1) {
        goto LABEL_6;
      }
    }
LABEL_7:
    LODWORD(v15) = 1;
  }
  uint64_t v6 = mlir::ValueRange::dereference_iterator(&v17, 0);
  *(void *)__src = *(void *)(v6 + 8) & 0xFFFFFFFFFFFFFFF8;
  uint64_t v7 = __src;
  uint64_t v8 = v15;
  uint64_t v9 = *(unsigned int *)(a2 + 72);
  unint64_t v10 = v9 + v15;
  if (v10 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v10, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
  }
  if (v8)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v9), v7, 8 * v8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v9 + v8;
  if (__src != v16) {
    free(__src);
  }
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  unint64_t v10 = *a2;
  uint64_t v11 = (void *)*((void *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v63[0] = a2;
    v63[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v63);
    if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isF16((mlir::Type *)&OperandRange)
      || mlir::Type::isF32((mlir::Type *)&OperandRange)
      || mlir::Type::isBF16((mlir::Type *)&OperandRange)
      || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
    {
      return 1;
    }
    unint64_t v10 = *a2;
    uint64_t v11 = (void *)*((void *)*a2 + 17);
  }
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    uint64_t v54 = a2;
    uint64_t v55 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t v14 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v54);
    if (*(_UNKNOWN **)(*(void *)v14 + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      uint64_t v42 = v14;
      uint64_t v59 = v14;
      uint64_t OperandRange = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v59);
      if (mlir::Type::isF16((mlir::Type *)&OperandRange)) {
        return 1;
      }
      uint64_t v57 = v42;
      uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v57);
      if (mlir::Type::isF32((mlir::Type *)&Value)) {
        return 1;
      }
    }
  }
  __int16 v56 = 261;
  uint64_t v54 = a3;
  uint64_t v55 = a4;
  mlir::Operation::emitOpError(a1, &v54, (uint64_t)v63);
  if (v63[0])
  {
    LODWORD(OperandRange) = 3;
    unint64_t v61 = " #";
    uint64_t v62 = 2;
    p_uint64_t OperandRange = &OperandRange;
    uint64_t v16 = (char *)v64;
    if (v65 >= v66)
    {
      unint64_t v44 = v65 + 1;
      if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
      {
        int64_t v50 = (char *)&OperandRange - (unsigned char *)v64;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v44, 24);
        uint64_t v16 = (char *)v64;
        p_uint64_t OperandRange = (uint64_t *)((char *)v64 + v50);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v44, 24);
        p_uint64_t OperandRange = &OperandRange;
        uint64_t v16 = (char *)v64;
      }
    }
    long long v17 = &v16[24 * v65];
    long long v18 = *(_OWORD *)p_OperandRange;
    *((void *)v17 + 2) = p_OperandRange[2];
    *(_OWORD *)long long v17 = v18;
    uint64_t v19 = ++v65;
    if (v63[0])
    {
      LODWORD(OperandRange) = 5;
      unint64_t v61 = (const char *)a5;
      BOOL v20 = &OperandRange;
      BOOL v21 = (char *)v64;
      if (v19 >= v66)
      {
        unint64_t v45 = v19 + 1;
        BOOL v46 = (char *)v64 + 24 * v19 > (char *)&OperandRange;
        if (v64 <= &OperandRange && v46)
        {
          int64_t v51 = (char *)&OperandRange - (unsigned char *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
          BOOL v21 = (char *)v64;
          BOOL v20 = (uint64_t *)((char *)v64 + v51);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
          BOOL v20 = &OperandRange;
          BOOL v21 = (char *)v64;
        }
      }
      uint64_t v22 = &v21[24 * v65];
      long long v23 = *(_OWORD *)v20;
      *((void *)v22 + 2) = v20[2];
      *(_OWORD *)uint64_t v22 = v23;
      uint64_t v24 = ++v65;
      if (v63[0])
      {
        LODWORD(OperandRange) = 3;
        unint64_t v61 = " must be tensor of mps native type values or tensor of complex values, but got ";
        uint64_t v62 = 79;
        uint64_t v25 = &OperandRange;
        uint64_t v26 = (char *)v64;
        if (v24 >= v66)
        {
          unint64_t v47 = v24 + 1;
          BOOL v48 = (char *)v64 + 24 * v24 > (char *)&OperandRange;
          if (v64 <= &OperandRange && v48)
          {
            int64_t v52 = (char *)&OperandRange - (unsigned char *)v64;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
            uint64_t v26 = (char *)v64;
            uint64_t v25 = (uint64_t *)((char *)v64 + v52);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
            uint64_t v25 = &OperandRange;
            uint64_t v26 = (char *)v64;
          }
        }
        BOOL v27 = &v26[24 * v65];
        long long v28 = *(_OWORD *)v25;
        *((void *)v27 + 2) = v25[2];
        *(_OWORD *)BOOL v27 = v28;
        ++v65;
        if (v63[0])
        {
          long long v29 = &OperandRange;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&OperandRange, (uint64_t)a2);
          uint64_t v30 = (char *)v64;
          if (v65 >= v66)
          {
            unint64_t v49 = v65 + 1;
            if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
            {
              int64_t v53 = (char *)&OperandRange - (unsigned char *)v64;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
              uint64_t v30 = (char *)v64;
              long long v29 = (uint64_t *)((char *)v64 + v53);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
              long long v29 = &OperandRange;
              uint64_t v30 = (char *)v64;
            }
          }
          uint64_t v31 = &v30[24 * v65];
          long long v32 = *(_OWORD *)v29;
          *((void *)v31 + 2) = v29[2];
          *(_OWORD *)uint64_t v31 = v32;
          ++v65;
        }
      }
    }
  }
  uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v63);
  if (v63[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
  }
  if (v72)
  {
    BOOL v34 = (void **)__p;
    if (__p)
    {
      BOOL v35 = v71;
      unint64_t v36 = __p;
      if (v71 != __p)
      {
        do
          BOOL v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        unint64_t v36 = __p;
      }
      BOOL v71 = v34;
      operator delete(v36);
    }
    BOOL v37 = v68;
    if (v68)
    {
      uint64_t v38 = v69;
      long long v39 = v68;
      if (v69 != v68)
      {
        do
        {
          BOOL v41 = (void *)*--v38;
          uint64_t v40 = v41;
          void *v38 = 0;
          if (v41) {
            operator delete[](v40);
          }
        }
        while (v38 != v37);
        long long v39 = v68;
      }
      BOOL v69 = v37;
      operator delete(v39);
    }
    if (v64 != v67) {
      free(v64);
    }
  }
  return v33;
}

uint64_t mlir::mps::ACosOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  unsigned int v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.acos", 8, v2, v3, 0, 0);
  *unsigned int v4 = &unk_1EC9826A0;
  v4[12] = mlir::mps::ACosOp::canonicalize;
  uint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::ACoshOpGenericAdaptorBase::ACoshOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.acosh", 9, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::ACoshOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  unsigned int v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.acosh", 9, v2, v3, 0, 0);
  *unsigned int v4 = &unk_1EC982DD8;
  v4[12] = mlir::mps::ACoshOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::ASinOpGenericAdaptorBase::ASinOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.asin", 8, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::ASinOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  unsigned int v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.asin", 8, v2, v3, 0, 0);
  *unsigned int v4 = &unk_1EC9826F8;
  v4[12] = mlir::mps::ASinOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::ASinhOpGenericAdaptorBase::ASinhOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.asinh", 9, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::ASinhOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  unsigned int v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.asinh", 9, v2, v3, 0, 0);
  *unsigned int v4 = &unk_1EC982E30;
  v4[12] = mlir::mps::ASinhOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::ATan2OpGenericAdaptorBase::ATan2OpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.atan2", 9, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::ATan2Op::build(mlir::Float32Type **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v18[2] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a4;
  uint64_t v13 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v13, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v12, 1);
  __src = v18;
  uint64_t v17 = 0x200000000;
  unint64_t v6 = *a1;
  mlir::ValueRange::ValueRange((unint64_t *)v15, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v14, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  __int16 v8 = __src;
  uint64_t v9 = v17;
  uint64_t v10 = *(unsigned int *)(a2 + 72);
  unint64_t v11 = v10 + v17;
  if (v11 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v11, 8);
    LODWORD(v10) = *(_DWORD *)(a2 + 72);
  }
  if (v9)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v10), v8, 8 * v9);
    LODWORD(v10) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v10 + v9;
  if (__src != v18) {
    free(__src);
  }
}

BOOL mlir::mps::ATan2Op::verifyInvariantsImpl(uint64_t **this)
{
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v2 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::ATan2Op::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  unsigned int v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.atan2", 9, v2, v3, 0, 0);
  *unsigned int v4 = &unk_1EC982E88;
  v4[12] = mlir::mps::ATan2Op::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::ATanOpGenericAdaptorBase::ATanOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.atan", 8, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::ATanOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  unsigned int v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.atan", 8, v2, v3, 0, 0);
  *unsigned int v4 = &unk_1EC982750;
  v4[12] = mlir::mps::ATanOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::ATanhOpGenericAdaptorBase::ATanhOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.atanh", 9, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::ATanhOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  unsigned int v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.atanh", 9, v2, v3, 0, 0);
  *unsigned int v4 = &unk_1EC982EE0;
  v4[12] = mlir::mps::ATanhOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::AbsoluteOpGenericAdaptorBase::AbsoluteOpGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  unint64_t v5 = a2[11];
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.absolute", 12, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::AbsoluteOp::getODSOperands(mlir::mps::AbsoluteOp *this, unsigned int a2)
{
  if ((*(unsigned char *)(*(void *)this + 46) & 0x80) != 0) {
    return *(void *)(*(void *)this + 72) + 32 * a2;
  }
  else {
    return 32 * a2;
  }
}

uint64_t mlir::mps::AbsoluteOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  unsigned int v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.absolute", 12, v2, v3, 0, 0);
  *unsigned int v4 = &unk_1EC97F4C8;
  v4[12] = mlir::mps::AbsoluteOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::AbsoluteSquareOpGenericAdaptorBase::AbsoluteSquareOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.absolute_square", 19, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::AbsoluteSquareOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  unsigned int v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.absolute_square", 19, v2, v3, 0, 0);
  *unsigned int v4 = &unk_1EC980BD0;
  v4[12] = mlir::mps::AbsoluteSquareOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::AddOpGenericAdaptorBase::AddOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.add", 7, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::AddOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  unsigned int v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.add", 7, v2, v3, 0, 0);
  *unsigned int v4 = &unk_1EC982280;
  v4[12] = mlir::mps::AddOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::AndOpGenericAdaptorBase::AndOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.and", 7, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::AndOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  unsigned int v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.and", 7, v2, v3, 0, 0);
  *unsigned int v4 = &unk_1EC9822D8;
  v4[12] = mlir::mps::AndOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::AssignVariableOpGenericAdaptorBase::AssignVariableOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.assign_variable", 19, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::AssignVariableOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a4;
  uint64_t v6 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v6, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v5, 1);
}

uint64_t mlir::mps::AssignVariableOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  unsigned int v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.assign_variable", 19, v2, v3, 0, 0);
  *unsigned int v4 = &unk_1EC980C28;
  v4[12] = mlir::mps::AssignVariableOp::canonicalize;
  uint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

void mlir::mps::AssignVariableOp::getEffects(uint64_t a1, uint64_t a2)
{
  void v26[2] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = mlir::SideEffects::Effect::Base<mlir::MemoryEffects::Write,mlir::MemoryEffects::Effect>::get();
  {
    uint64_t v22 = v3;
    uint64_t v3 = v22;
    if (v13)
    {
      {
        long long v23 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::SideEffects::DefaultResource]";
        unint64_t v24 = 84;
        unint64_t v15 = llvm::StringRef::find((uint64_t *)&v23, "DesiredTypeName = ", 0x12uLL, 0);
        if (v24 >= v15) {
          unint64_t v16 = v15;
        }
        else {
          unint64_t v16 = v24;
        }
        uint64_t v17 = &v23[v16];
        unint64_t v18 = v24 - v16;
        if (v24 - v16 >= 0x12) {
          uint64_t v19 = 18;
        }
        else {
          uint64_t v19 = v24 - v16;
        }
        unint64_t v20 = v18 - v19;
        if (v20 >= v20 - 1) {
          uint64_t v21 = v20 - 1;
        }
        else {
          uint64_t v21 = v20;
        }
        mlir::detail::TypeIDResolver<mlir::SideEffects::DefaultResource,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v17[v19], v21);
      }
      mlir::SideEffects::Resource::Base<mlir::SideEffects::DefaultResource,mlir::SideEffects::Resource>::get(void)::instance = (uint64_t)&unk_1EC9A4AE8;
      *(void *)algn_1E8EB9D58 = mlir::detail::TypeIDResolver<mlir::SideEffects::DefaultResource,void>::resolveTypeID(void)::id;
      __cxa_atexit((void (*)(void *))mlir::SideEffects::DefaultResource::~DefaultResource, &mlir::SideEffects::Resource::Base<mlir::SideEffects::DefaultResource,mlir::SideEffects::Resource>::get(void)::instance, &dword_180159000);
      uint64_t v3 = v22;
    }
  }
  uint64_t v4 = *(unsigned int *)(a2 + 8);
  if (v4 >= *(_DWORD *)(a2 + 12))
  {
    long long v23 = (const char *)v3;
    unint64_t v24 = (unint64_t)&mlir::SideEffects::Resource::Base<mlir::SideEffects::DefaultResource,mlir::SideEffects::Resource>::get(void)::instance;
    unint64_t v6 = v4 + 1;
    uint64_t v25 = 0;
    v26[0] = 0;
    *(void *)((char *)v26 + 5) = 0;
    BOOL v7 = *(void *)a2 + 40 * (unint64_t)v4 > (unint64_t)&v23;
    if (*(void *)a2 <= (unint64_t)&v23 && v7)
    {
      unint64_t v14 = (char *)&v23 - *(void *)a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v6, 40);
      uint64_t v8 = *(void *)a2;
      uint64_t v9 = (const char **)&v14[*(void *)a2];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v6, 40);
      uint64_t v8 = *(void *)a2;
      uint64_t v9 = &v23;
    }
    uint64_t v10 = v8 + 40 * *(unsigned int *)(a2 + 8);
    long long v11 = *(_OWORD *)v9;
    long long v12 = *((_OWORD *)v9 + 1);
    *(void *)(v10 + 32) = v9[4];
    *(_OWORD *)uint64_t v10 = v11;
    *(_OWORD *)(v10 + 16) = v12;
  }
  else
  {
    uint64_t v5 = (uint64_t **)(*(void *)a2 + 40 * v4);
    llvm::raw_ostream *v5 = v3;
    v5[1] = &mlir::SideEffects::Resource::Base<mlir::SideEffects::DefaultResource,mlir::SideEffects::Resource>::get(void)::instance;
    void v5[2] = 0;
    v5[3] = 0;
    *(uint64_t **)((char *)v5 + 29) = 0;
  }
  ++*(_DWORD *)(a2 + 8);
}

uint64_t mlir::mps::detail::BandPartOpGenericAdaptorBase::BandPartOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.band_part", 13, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::BandPartOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v23[2] = *MEMORY[0x1E4F143B8];
  uint64_t v15 = a4;
  uint64_t v16 = a3;
  uint64_t v14 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v16, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v15, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v14, 1);
  __src = v22;
  uint64_t v21 = 0x200000000;
  uint64_t v6 = *(void *)a2;
  mlir::ValueRange::ValueRange(&v18, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v17, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v23[0] = v18;
  v23[1] = v19;
  if (v19)
  {
    unint64_t v8 = *(void *)(mlir::ValueRange::dereference_iterator(v23, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    unsigned int v9 = v21;
    if (v21 >= HIDWORD(v21))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v22, v21 + 1, 8);
      unsigned int v9 = v21;
    }
    *((void *)__src + v9) = v8;
    unsigned int v10 = v21 + 1;
    LODWORD(v21) = v10;
    uint64_t v11 = __src;
    uint64_t v12 = *(unsigned int *)(a2 + 72);
    unint64_t v13 = v12 + v10;
    if (v13 > *(unsigned int *)(a2 + 76))
    {
LABEL_5:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v13, 8);
      LODWORD(v12) = *(_DWORD *)(a2 + 72);
    }
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(v6, 1, "invalid number of operands")) {
      llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
    }
    unsigned int v10 = v21;
    uint64_t v11 = __src;
    uint64_t v12 = *(unsigned int *)(a2 + 72);
    unint64_t v13 = v12 + v21;
    if (v13 > *(unsigned int *)(a2 + 76)) {
      goto LABEL_5;
    }
  }
  if (v10)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v12), v11, 8 * v10);
    LODWORD(v12) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v12 + v10;
  if (__src != v22) {
    free(__src);
  }
}

BOOL mlir::mps::BandPartOp::verifyInvariantsImpl(uint64_t **this)
{
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 2u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v2 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v82 = *MEMORY[0x1E4F143B8];
  unsigned int v10 = *a2;
  if (*((_UNKNOWN **)*a2 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    goto LABEL_4;
  }
  v71[0] = a2;
  v71[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  int ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v71);
  unsigned int v10 = *a2;
  if (!ArgOperands) {
    goto LABEL_4;
  }
  unint64_t v61 = a2;
  uint64_t v62 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v61);
  unsigned int v10 = *a2;
  if (!v12)
  {
    uint64_t v47 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
    unint64_t v68 = a2;
    uint64_t v69 = v47;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v68);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
    {
      return 1;
    }
    unsigned int v10 = *a2;
    unint64_t v49 = (void *)*((void *)*a2 + 17);
    if (v49 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v49 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_13;
    }
  }
  else
  {
LABEL_4:
    unint64_t v13 = (void *)v10[17];
    if (v13 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v13 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_13;
    }
  }
  uint64_t v15 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  v66[0] = a2;
  v66[1] = v15;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v66);
  if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
  {
    uint64_t v16 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
    v65[0] = a2;
    v65[1] = v16;
    ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v65);
    uint64_t v81 = 1;
    if (v18 == 1 && *ArgAttrsAttr == v81) {
      return 1;
    }
  }
LABEL_13:
  if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    uint64_t v46 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
    v64[0] = a2;
    v64[1] = v46;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v64);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
    {
      return 1;
    }
  }
  __int16 v63 = 261;
  unint64_t v61 = a3;
  uint64_t v62 = a4;
  mlir::Operation::emitOpError(a1, &v61, (uint64_t)v71);
  if (v71[0])
  {
    LODWORD(v68) = 3;
    uint64_t v69 = (uint64_t)" #";
    uint64_t v70 = 2;
    uint64_t v19 = &v68;
    unint64_t v20 = (char *)v72;
    if (v73 >= v74)
    {
      unint64_t v51 = v73 + 1;
      if (v72 <= &v68 && (char *)v72 + 24 * v73 > (char *)&v68)
      {
        int64_t v57 = (char *)&v68 - (unsigned char *)v72;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v51, 24);
        unint64_t v20 = (char *)v72;
        uint64_t v19 = (const void ***)((char *)v72 + v57);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v51, 24);
        uint64_t v19 = &v68;
        unint64_t v20 = (char *)v72;
      }
    }
    uint64_t v21 = &v20[24 * v73];
    long long v22 = *(_OWORD *)v19;
    *((void *)v21 + 2) = v19[2];
    *(_OWORD *)uint64_t v21 = v22;
    uint64_t v23 = ++v73;
    if (v71[0])
    {
      LODWORD(v68) = 5;
      uint64_t v69 = a5;
      unint64_t v24 = &v68;
      uint64_t v25 = (char *)v72;
      if (v23 >= v74)
      {
        unint64_t v52 = v23 + 1;
        BOOL v53 = (char *)v72 + 24 * v23 > (char *)&v68;
        if (v72 <= &v68 && v53)
        {
          int64_t v58 = (char *)&v68 - (unsigned char *)v72;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v52, 24);
          uint64_t v25 = (char *)v72;
          unint64_t v24 = (const void ***)((char *)v72 + v58);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v52, 24);
          unint64_t v24 = &v68;
          uint64_t v25 = (char *)v72;
        }
      }
      uint64_t v26 = &v25[24 * v73];
      long long v27 = *(_OWORD *)v24;
      *((void *)v26 + 2) = v24[2];
      *(_OWORD *)uint64_t v26 = v27;
      uint64_t v28 = ++v73;
      if (v71[0])
      {
        LODWORD(v68) = 3;
        uint64_t v69 = (uint64_t)" must be 0D tensor of mps index type values or static-shape defined tensor with shape equal to [1"
                       "] or unranked tensor of mps index type values, but got ";
        uint64_t v70 = 152;
        long long v29 = &v68;
        uint64_t v30 = (char *)v72;
        if (v28 >= v74)
        {
          unint64_t v54 = v28 + 1;
          BOOL v55 = (char *)v72 + 24 * v28 > (char *)&v68;
          if (v72 <= &v68 && v55)
          {
            int64_t v59 = (char *)&v68 - (unsigned char *)v72;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v54, 24);
            uint64_t v30 = (char *)v72;
            long long v29 = (const void ***)((char *)v72 + v59);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v54, 24);
            long long v29 = &v68;
            uint64_t v30 = (char *)v72;
          }
        }
        uint64_t v31 = &v30[24 * v73];
        long long v32 = *(_OWORD *)v29;
        *((void *)v31 + 2) = v29[2];
        *(_OWORD *)uint64_t v31 = v32;
        ++v73;
        if (v71[0])
        {
          uint64_t v33 = &v68;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v68, (uint64_t)a2);
          BOOL v34 = (char *)v72;
          if (v73 >= v74)
          {
            unint64_t v56 = v73 + 1;
            if (v72 <= &v68 && (char *)v72 + 24 * v73 > (char *)&v68)
            {
              int64_t v60 = (char *)&v68 - (unsigned char *)v72;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v56, 24);
              BOOL v34 = (char *)v72;
              uint64_t v33 = (const void ***)((char *)v72 + v60);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v56, 24);
              uint64_t v33 = &v68;
              BOOL v34 = (char *)v72;
            }
          }
          BOOL v35 = &v34[24 * v73];
          long long v36 = *(_OWORD *)v33;
          *((void *)v35 + 2) = v33[2];
          *(_OWORD *)BOOL v35 = v36;
          ++v73;
        }
      }
    }
  }
  uint64_t v37 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v71);
  if (v71[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v71);
  }
  if (v80)
  {
    uint64_t v38 = (void **)__p;
    if (__p)
    {
      long long v39 = v79;
      uint64_t v40 = __p;
      if (v79 != __p)
      {
        do
          long long v39 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v39 - 1);
        while (v39 != v38);
        uint64_t v40 = __p;
      }
      int64_t v79 = v38;
      operator delete(v40);
    }
    BOOL v41 = v76;
    if (v76)
    {
      uint64_t v42 = v77;
      unint64_t v43 = v76;
      if (v77 != v76)
      {
        do
        {
          unint64_t v45 = (void *)*--v42;
          unint64_t v44 = v45;
          void *v42 = 0;
          if (v45) {
            operator delete[](v44);
          }
        }
        while (v42 != v41);
        unint64_t v43 = v76;
      }
      int64_t v77 = v41;
      operator delete(v43);
    }
    if (v72 != v75) {
      free(v72);
    }
  }
  return v37;
}

uint64_t mlir::mps::BandPartOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.band_part", 13, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC97F520;
  v4[12] = mlir::mps::BandPartOp::canonicalize;
  unsigned int v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unsigned int v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::BatchToSpaceOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  unint64_t v5 = (void *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.batch_to_space", 18, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::BatchToSpaceOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      int v44 = 3;
      unint64_t v45 = "expected DictionaryAttr to set properties";
      uint64_t v46 = 41;
      uint64_t v26 = &v44;
      long long v27 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v40 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          long long v27 = (char *)v48;
          uint64_t v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          uint64_t v26 = &v44;
          long long v27 = (char *)v48;
        }
      }
      uint64_t v28 = &v27[24 * v49];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)uint64_t v28 = v29;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
    if (!v56) {
      return 0;
    }
    uint64_t v30 = (void **)__p;
    if (__p)
    {
      uint64_t v31 = v55;
      long long v32 = __p;
      if (v55 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        long long v32 = __p;
      }
      BOOL v55 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v52;
    if (!v52) {
      goto LABEL_43;
    }
    uint64_t v33 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      BOOL v35 = (void *)*--v33;
      BOOL v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "pixel_shuffle", 0xDuLL);
  if (!v8) {
    return 1;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    int v44 = 3;
    uint64_t v46 = 58;
    unsigned int v10 = &v44;
    uint64_t v11 = (char *)v48;
    if (v49 >= v50)
    {
      unint64_t v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        int64_t v41 = (char *)&v44 - (unsigned char *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v11 = (char *)v48;
        unsigned int v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        unsigned int v10 = &v44;
        uint64_t v11 = (char *)v48;
      }
    }
    uint64_t v12 = &v11[24 * v49];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = *((void *)v10 + 2);
    *(_OWORD *)uint64_t v12 = v13;
    ++v49;
    if (v47[0])
    {
      uint64_t v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      uint64_t v15 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v42 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v15 = (char *)v48;
          uint64_t v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v14 = &v44;
          uint64_t v15 = (char *)v48;
        }
      }
      uint64_t v16 = &v15[24 * v49];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = *((void *)v14 + 2);
      *(_OWORD *)uint64_t v16 = v17;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
  }
  if (!v56) {
    return 0;
  }
  uint64_t v18 = (void **)__p;
  if (__p)
  {
    uint64_t v19 = v55;
    unint64_t v20 = __p;
    if (v55 != __p)
    {
      do
        uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      unint64_t v20 = __p;
    }
    BOOL v55 = v18;
    operator delete(v20);
  }
  uint64_t v21 = v52;
  if (v52)
  {
    long long v22 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v25 = (void *)*--v22;
      unint64_t v24 = v25;
      *long long v22 = 0;
      if (v25) {
        operator delete[](v24);
      }
    }
    while (v22 != v21);
LABEL_41:
    uint64_t v23 = v52;
LABEL_42:
    BOOL v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51) {
    free(v48);
  }
  return 0;
}

uint64_t mlir::mps::BatchToSpaceOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v15[6] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a1;
  long long v13 = v15;
  uint64_t v14 = 0x300000000;
  if (!*a2) {
    return 0;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"pixel_shuffle", 13, *a2);
  uint64_t v4 = v3;
  unsigned int v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    unsigned int v5 = v14;
  }
  uint64_t v6 = (uint64_t *)((char *)v13 + 16 * v5);
  uint64_t *v6 = NamedAttr;
  v6[1] = v4;
  uint64_t v7 = v13;
  BOOL v8 = __CFADD__(v14, 1);
  uint64_t v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v13 == v15) {
      return DictionaryAttr;
    }
    goto LABEL_10;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (uint64_t *)v13, v9);
  uint64_t v7 = v13;
  if (v13 != v15) {
LABEL_10:
  }
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    *uint64_t v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 113;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        BOOL v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[9];
    return a1[32];
  }
  return result;
}

void mlir::mps::BatchToSpaceOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  v32[2] = *MEMORY[0x1E4F143B8];
  uint64_t v26 = a4;
  uint64_t v27 = a3;
  uint64_t v24 = a6;
  uint64_t v25 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v27, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v26, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v25, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v24, 1);
  if (a7)
  {
    uint64_t UnitAttr = mlir::Builder::getUnitAttr(a1, v10);
    *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::Properties>((void *)a2) = UnitAttr;
  }
  __src = v32;
  uint64_t v31 = 0x200000000;
  uint64_t v12 = *(void *)a2;
  mlir::ValueRange::ValueRange(v29, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  unint64_t v14 = mlir::ValueRange::ValueRange(&v28, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::BatchToSpaceOp::inferReturnTypes((uint64_t)v14, v12, 1, v29[0], v29[1], v15, v16, v17, v22, v23, (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v18 = __src;
  }
  uint64_t v19 = v31;
  uint64_t v20 = *(unsigned int *)(a2 + 72);
  unint64_t v21 = v20 + v31;
  if (v21 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v21, 8);
    LODWORD(v20) = *(_DWORD *)(a2 + 72);
  }
  if (v19)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v20), v18, 8 * v19);
    LODWORD(v20) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v20 + v19;
  if (__src != v32) {
    free(__src);
  }
}

BOOL mlir::mps::BatchToSpaceOp::verifyInvariantsImpl(uint64_t **this)
{
  __int16 v2 = *this;
  uint64_t v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  unint64_t v7 = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v3, (const void **)"pixel_shuffle", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v7)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this,
                           (const void **)(*(void *)(*(void *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8),
                           (const void **)"operand",
                           7,
                           2u)
    || !mlir::mps::__mlir_ods_local_type_constraint_MPSOps4(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 120) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 3u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v4 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = (_UNKNOWN **)*a2;
  if (*((_UNKNOWN **)*a2 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    goto LABEL_4;
  }
  v69[0] = a2;
  v69[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  int ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v69);
  uint64_t v10 = (_UNKNOWN **)*a2;
  if (!ArgOperands) {
    goto LABEL_4;
  }
  int64_t v58 = a2;
  uint64_t v59 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
  uint64_t v10 = (_UNKNOWN **)*a2;
  if (!v12)
  {
    uint64_t v18 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
    unsigned int v66 = a2;
    uint64_t v67 = v18;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v66);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
    {
      return 1;
    }
    uint64_t v10 = (_UNKNOWN **)*a2;
    if (*((_UNKNOWN **)*a2 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
      goto LABEL_13;
    }
  }
  else
  {
LABEL_4:
    if (v10[17] != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
      goto LABEL_13;
    }
  }
  uint64_t v13 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  v64[0] = a2;
  v64[1] = v13;
  int v14 = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v64);
  uint64_t v10 = (_UNKNOWN **)*a2;
  if (v14)
  {
    uint64_t v15 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
    v63[0] = a2;
    v63[1] = v15;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v63);
    uint64_t v10 = (_UNKNOWN **)*a2;
    if (v16 == 1)
    {
      uint64_t v17 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
      v62[0] = a2;
      v62[1] = v17;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v62);
      if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
      {
        return 1;
      }
      uint64_t v10 = (_UNKNOWN **)*a2;
    }
  }
LABEL_13:
  if (v10[17] == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    uint64_t v46 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
    v61[0] = a2;
    v61[1] = v46;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
    {
      return 1;
    }
  }
  __int16 v60 = 261;
  int64_t v58 = a3;
  uint64_t v59 = a4;
  mlir::Operation::emitOpError(a1, &v58, (uint64_t)v69);
  if (v69[0])
  {
    LODWORD(v66) = 3;
    uint64_t v67 = (uint64_t)" #";
    uint64_t v68 = 2;
    uint64_t v19 = &v66;
    uint64_t v20 = (char *)v70;
    if (v71 >= v72)
    {
      unint64_t v48 = v71 + 1;
      if (v70 <= &v66 && (char *)v70 + 24 * v71 > (char *)&v66)
      {
        int64_t v54 = (char *)&v66 - (unsigned char *)v70;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v48, 24);
        uint64_t v20 = (char *)v70;
        uint64_t v19 = (const void ***)((char *)v70 + v54);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v48, 24);
        uint64_t v19 = &v66;
        uint64_t v20 = (char *)v70;
      }
    }
    unint64_t v21 = &v20[24 * v71];
    long long v22 = *(_OWORD *)v19;
    *((void *)v21 + 2) = v19[2];
    *(_OWORD *)unint64_t v21 = v22;
    uint64_t v23 = ++v71;
    if (v69[0])
    {
      LODWORD(v66) = 5;
      uint64_t v67 = a5;
      uint64_t v24 = &v66;
      uint64_t v25 = (char *)v70;
      if (v23 >= v72)
      {
        unint64_t v49 = v23 + 1;
        BOOL v50 = (char *)v70 + 24 * v23 > (char *)&v66;
        if (v70 <= &v66 && v50)
        {
          int64_t v55 = (char *)&v66 - (unsigned char *)v70;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v49, 24);
          uint64_t v25 = (char *)v70;
          uint64_t v24 = (const void ***)((char *)v70 + v55);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v49, 24);
          uint64_t v24 = &v66;
          uint64_t v25 = (char *)v70;
        }
      }
      uint64_t v26 = &v25[24 * v71];
      long long v27 = *(_OWORD *)v24;
      *((void *)v26 + 2) = v24[2];
      *(_OWORD *)uint64_t v26 = v27;
      uint64_t v28 = ++v71;
      if (v69[0])
      {
        LODWORD(v66) = 3;
        uint64_t v67 = (uint64_t)" must be 0D tensor of mps index type values or 1D tensor of mps index type values or unranked ten"
                       "sor of mps index type values, but got ";
        uint64_t v68 = 135;
        long long v29 = &v66;
        uint64_t v30 = (char *)v70;
        if (v28 >= v72)
        {
          unint64_t v51 = v28 + 1;
          BOOL v52 = (char *)v70 + 24 * v28 > (char *)&v66;
          if (v70 <= &v66 && v52)
          {
            int64_t v56 = (char *)&v66 - (unsigned char *)v70;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v51, 24);
            uint64_t v30 = (char *)v70;
            long long v29 = (const void ***)((char *)v70 + v56);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v51, 24);
            long long v29 = &v66;
            uint64_t v30 = (char *)v70;
          }
        }
        uint64_t v31 = &v30[24 * v71];
        long long v32 = *(_OWORD *)v29;
        *((void *)v31 + 2) = v29[2];
        *(_OWORD *)uint64_t v31 = v32;
        ++v71;
        if (v69[0])
        {
          uint64_t v33 = &v66;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v66, (uint64_t)a2);
          BOOL v34 = (char *)v70;
          if (v71 >= v72)
          {
            unint64_t v53 = v71 + 1;
            if (v70 <= &v66 && (char *)v70 + 24 * v71 > (char *)&v66)
            {
              int64_t v57 = (char *)&v66 - (unsigned char *)v70;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v53, 24);
              BOOL v34 = (char *)v70;
              uint64_t v33 = (const void ***)((char *)v70 + v57);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v53, 24);
              uint64_t v33 = &v66;
              BOOL v34 = (char *)v70;
            }
          }
          BOOL v35 = &v34[24 * v71];
          long long v36 = *(_OWORD *)v33;
          *((void *)v35 + 2) = v33[2];
          *(_OWORD *)BOOL v35 = v36;
          ++v71;
        }
      }
    }
  }
  uint64_t v37 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v69);
  if (v69[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v69);
  }
  if (v78)
  {
    unint64_t v38 = (void **)__p;
    if (__p)
    {
      unint64_t v39 = v77;
      int64_t v40 = __p;
      if (v77 != __p)
      {
        do
          unint64_t v39 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v39 - 1);
        while (v39 != v38);
        int64_t v40 = __p;
      }
      int64_t v77 = v38;
      operator delete(v40);
    }
    int64_t v41 = v74;
    if (v74)
    {
      int64_t v42 = v75;
      uint64_t v43 = v74;
      if (v75 != v74)
      {
        do
        {
          unint64_t v45 = (void *)*--v42;
          int v44 = v45;
          void *v42 = 0;
          if (v45) {
            operator delete[](v44);
          }
        }
        while (v42 != v41);
        uint64_t v43 = v74;
      }
      unint64_t v75 = v41;
      operator delete(v43);
    }
    if (v70 != v73) {
      free(v70);
    }
  }
  return v37;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps4(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *a2;
  unint64_t v11 = (void *)*((void *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v61[0] = a2;
    v61[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
    {
      return 1;
    }
    uint64_t v10 = *a2;
    if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
LABEL_3:
      unint64_t v53 = a2;
      uint64_t v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53)) {
        goto LABEL_24;
      }
      uint64_t v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      int64_t v58 = a2;
      uint64_t v59 = v12;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
      if (v13 != 1) {
        goto LABEL_24;
      }
      uint64_t v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v56[0] = a2;
      v56[1] = v14;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
      if (!mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
        && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
        && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
        && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
        && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
        && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
        && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
        && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
      {
        goto LABEL_24;
      }
      return 1;
    }
  }
  else if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    goto LABEL_3;
  }
LABEL_24:
  __int16 v55 = 261;
  unint64_t v53 = a3;
  uint64_t v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v61);
  if (v61[0])
  {
    LODWORD(v58) = 3;
    uint64_t v59 = (uint64_t)" #";
    uint64_t v60 = 2;
    uint64_t v16 = &v58;
    uint64_t v17 = (char *)v62;
    if (v63 >= v64)
    {
      unint64_t v43 = v63 + 1;
      if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
      {
        int64_t v49 = (char *)&v58 - (unsigned char *)v62;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        uint64_t v17 = (char *)v62;
        uint64_t v16 = (const void ***)((char *)v62 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        uint64_t v16 = &v58;
        uint64_t v17 = (char *)v62;
      }
    }
    uint64_t v18 = &v17[24 * v63];
    long long v19 = *(_OWORD *)v16;
    *((void *)v18 + 2) = v16[2];
    *(_OWORD *)uint64_t v18 = v19;
    uint64_t v20 = ++v63;
    if (v61[0])
    {
      LODWORD(v58) = 5;
      uint64_t v59 = a5;
      unint64_t v21 = &v58;
      long long v22 = (char *)v62;
      if (v20 >= v64)
      {
        unint64_t v44 = v20 + 1;
        BOOL v45 = (char *)v62 + 24 * v20 > (char *)&v58;
        if (v62 <= &v58 && v45)
        {
          int64_t v50 = (char *)&v58 - (unsigned char *)v62;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          long long v22 = (char *)v62;
          unint64_t v21 = (const void ***)((char *)v62 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          unint64_t v21 = &v58;
          long long v22 = (char *)v62;
        }
      }
      uint64_t v23 = &v22[24 * v63];
      long long v24 = *(_OWORD *)v21;
      *((void *)v23 + 2) = v21[2];
      *(_OWORD *)uint64_t v23 = v24;
      uint64_t v25 = ++v63;
      if (v61[0])
      {
        LODWORD(v58) = 3;
        uint64_t v59 = (uint64_t)" must be unranked tensor of int values or 1D tensor of int values, but got ";
        uint64_t v60 = 75;
        uint64_t v26 = &v58;
        long long v27 = (char *)v62;
        if (v25 >= v64)
        {
          unint64_t v46 = v25 + 1;
          BOOL v47 = (char *)v62 + 24 * v25 > (char *)&v58;
          if (v62 <= &v58 && v47)
          {
            int64_t v51 = (char *)&v58 - (unsigned char *)v62;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            long long v27 = (char *)v62;
            uint64_t v26 = (const void ***)((char *)v62 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            uint64_t v26 = &v58;
            long long v27 = (char *)v62;
          }
        }
        uint64_t v28 = &v27[24 * v63];
        long long v29 = *(_OWORD *)v26;
        *((void *)v28 + 2) = v26[2];
        *(_OWORD *)uint64_t v28 = v29;
        ++v63;
        if (v61[0])
        {
          uint64_t v30 = &v58;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v58, (uint64_t)a2);
          uint64_t v31 = (char *)v62;
          if (v63 >= v64)
          {
            unint64_t v48 = v63 + 1;
            if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
            {
              int64_t v52 = (char *)&v58 - (unsigned char *)v62;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              uint64_t v31 = (char *)v62;
              uint64_t v30 = (const void ***)((char *)v62 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              uint64_t v30 = &v58;
              uint64_t v31 = (char *)v62;
            }
          }
          long long v32 = &v31[24 * v63];
          long long v33 = *(_OWORD *)v30;
          *((void *)v32 + 2) = v30[2];
          *(_OWORD *)long long v32 = v33;
          ++v63;
        }
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v61);
  if (v61[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v61);
  }
  if (v70)
  {
    BOOL v34 = (void **)__p;
    if (__p)
    {
      BOOL v35 = v69;
      long long v36 = __p;
      if (v69 != __p)
      {
        do
          BOOL v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        long long v36 = __p;
      }
      uint64_t v69 = v34;
      operator delete(v36);
    }
    uint64_t v37 = v66;
    if (v66)
    {
      unint64_t v38 = v67;
      unint64_t v39 = v66;
      if (v67 != v66)
      {
        do
        {
          int64_t v41 = (void *)*--v38;
          int64_t v40 = v41;
          void *v38 = 0;
          if (v41) {
            operator delete[](v40);
          }
        }
        while (v38 != v37);
        unint64_t v39 = v66;
      }
      uint64_t v67 = v37;
      operator delete(v39);
    }
    if (v62 != v65) {
      free(v62);
    }
  }
  return v15;
}

uint64_t mlir::mps::BatchToSpaceOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.batch_to_space", 18, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC980390;
  v4[12] = mlir::mps::BatchToSpaceOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::BiasAddGradOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  int v5 = (void *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.bias_add_grad", 17, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::BiasAddGradOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      int v44 = 3;
      BOOL v45 = "expected DictionaryAttr to set properties";
      uint64_t v46 = 41;
      uint64_t v26 = &v44;
      long long v27 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v40 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          long long v27 = (char *)v48;
          uint64_t v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          uint64_t v26 = &v44;
          long long v27 = (char *)v48;
        }
      }
      uint64_t v28 = &v27[24 * v49];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)uint64_t v28 = v29;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
    if (!v56) {
      return 0;
    }
    uint64_t v30 = (void **)__p;
    if (__p)
    {
      uint64_t v31 = v55;
      long long v32 = __p;
      if (v55 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        long long v32 = __p;
      }
      __int16 v55 = v30;
      operator delete(v32);
    }
    unint64_t v21 = v52;
    if (!v52) {
      goto LABEL_43;
    }
    long long v33 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      BOOL v35 = (void *)*--v33;
      BOOL v34 = v35;
      *long long v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "data_format", 0xBuLL);
  if (!v8) {
    return 1;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    int v44 = 3;
    uint64_t v46 = 56;
    uint64_t v10 = &v44;
    uint64_t v11 = (char *)v48;
    if (v49 >= v50)
    {
      unint64_t v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        int64_t v41 = (char *)&v44 - (unsigned char *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v11 = (char *)v48;
        uint64_t v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v10 = &v44;
        uint64_t v11 = (char *)v48;
      }
    }
    uint64_t v12 = &v11[24 * v49];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = *((void *)v10 + 2);
    *(_OWORD *)uint64_t v12 = v13;
    ++v49;
    if (v47[0])
    {
      uint64_t v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      uint64_t v15 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v42 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v15 = (char *)v48;
          uint64_t v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v14 = &v44;
          uint64_t v15 = (char *)v48;
        }
      }
      uint64_t v16 = &v15[24 * v49];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = *((void *)v14 + 2);
      *(_OWORD *)uint64_t v16 = v17;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
  }
  if (!v56) {
    return 0;
  }
  uint64_t v18 = (void **)__p;
  if (__p)
  {
    long long v19 = v55;
    uint64_t v20 = __p;
    if (v55 != __p)
    {
      do
        long long v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      uint64_t v20 = __p;
    }
    __int16 v55 = v18;
    operator delete(v20);
  }
  unint64_t v21 = v52;
  if (v52)
  {
    long long v22 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v25 = (void *)*--v22;
      long long v24 = v25;
      *long long v22 = 0;
      if (v25) {
        operator delete[](v24);
      }
    }
    while (v22 != v21);
LABEL_41:
    uint64_t v23 = v52;
LABEL_42:
    unint64_t v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51) {
    free(v48);
  }
  return 0;
}

uint64_t mlir::mps::BiasAddGradOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v15[6] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a1;
  long long v13 = v15;
  uint64_t v14 = 0x300000000;
  if (!*a2) {
    return 0;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"data_format", 11, *a2);
  uint64_t v4 = v3;
  unsigned int v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    unsigned int v5 = v14;
  }
  uint64_t v6 = (uint64_t *)((char *)v13 + 16 * v5);
  uint64_t *v6 = NamedAttr;
  v6[1] = v4;
  uint64_t v7 = v13;
  BOOL v8 = __CFADD__(v14, 1);
  uint64_t v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v13 == v15) {
      return DictionaryAttr;
    }
    goto LABEL_10;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (uint64_t *)v13, v9);
  uint64_t v7 = v13;
  if (v13 != v15) {
LABEL_10:
  }
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(_DWORD *a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id
    && a1[2] < 2u)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    uint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    BOOL v8 = &v29;
    uint64_t v9 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v9 = (char *)v35;
        BOOL v8 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        BOOL v8 = &v29;
        uint64_t v9 = (char *)v35;
      }
    }
    uint64_t v10 = &v9[24 * v36];
    long long v11 = *(_OWORD *)v8;
    *((void *)v10 + 2) = v8[2];
    *(_OWORD *)uint64_t v10 = v11;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      long long v29 = a2;
      uint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        uint64_t v30 = "' failed to satisfy constraint: valid TensorDataLayout is NHWC or NCHW";
        uint64_t v31 = 70;
        uint64_t v12 = &v29;
        long long v13 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            long long v13 = (char *)v35;
            uint64_t v12 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = &v29;
            long long v13 = (char *)v35;
          }
        }
        uint64_t v14 = &v13[24 * v36];
        long long v15 = *(_OWORD *)v12;
        *((void *)v14 + 2) = v12[2];
        *(_OWORD *)uint64_t v14 = v15;
        ++v36;
      }
    }
  }
  uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    uint64_t v16 = (void **)__p;
    if (__p)
    {
      long long v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          long long v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      int64_t v42 = v16;
      operator delete(v18);
    }
    long long v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      unint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = (void *)*--v20;
          long long v22 = v23;
          *uint64_t v20 = 0;
          if (v23) {
            operator delete[](v22);
          }
        }
        while (v20 != v19);
        unint64_t v21 = v39;
      }
      int64_t v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v7;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    *uint64_t v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 112;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        BOOL v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[11];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::TensorDataLayoutAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  if (!v39) {
    return 1;
  }
  int v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
    return 1;
  }
  unsigned char v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    unint64_t v6 = &v40;
    unint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v7 = (char *)v46;
        unint64_t v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v6 = &v40;
        unint64_t v7 = (char *)v46;
      }
    }
    BOOL v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)BOOL v8 = v9;
    ++v47;
  }
  int64_t v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::TensorDataLayoutAttr]";
  unint64_t v41 = 81;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    int64_t v40 = (const void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      unint64_t v14 = &v40;
      long long v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          long long v15 = (char *)v46;
          unint64_t v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          unint64_t v14 = &v40;
          long long v15 = (char *)v46;
        }
      }
      uint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)uint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        long long v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            long long v19 = (char *)v46;
            uint64_t v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            long long v19 = (char *)v46;
          }
        }
        uint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = (void **)__p;
    if (__p)
    {
      long long v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          long long v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      unint64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = (void *)*--v27;
          long long v29 = v30;
          void *v27 = 0;
          if (v30) {
            operator delete[](v29);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      int64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

BOOL mlir::mps::BiasAddGradOp::verifyInvariantsImpl(uint64_t **this)
{
  __int16 v2 = *this;
  uint64_t v3 = (_DWORD *)(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  unint64_t v7 = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(v3, (const void **)"data_format", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v7)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps5(*this, *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v4 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps5(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *(void *)a2;
  unint64_t v11 = *(void **)(*(void *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isF16((mlir::Type *)v51)
      || mlir::Type::isF32((mlir::Type *)v51)
      || mlir::Type::isBF16((mlir::Type *)v51))
    {
      return 1;
    }
  }
  __int16 v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    int v53 = 3;
    char v54 = " #";
    uint64_t v55 = 2;
    unint64_t v14 = &v53;
    long long v15 = (char *)v57;
    if (v58 >= v59)
    {
      unint64_t v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        int64_t v47 = (char *)&v53 - (unsigned char *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        long long v15 = (char *)v57;
        unint64_t v14 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        unint64_t v14 = &v53;
        long long v15 = (char *)v57;
      }
    }
    uint64_t v16 = &v15[24 * v58];
    long long v17 = *(_OWORD *)v14;
    *((void *)v16 + 2) = *((void *)v14 + 2);
    *(_OWORD *)uint64_t v16 = v17;
    uint64_t v18 = ++v58;
    if (v56[0])
    {
      int v53 = 5;
      char v54 = (const char *)a5;
      long long v19 = &v53;
      uint64_t v20 = (char *)v57;
      if (v18 >= v59)
      {
        unint64_t v42 = v18 + 1;
        BOOL v43 = (char *)v57 + 24 * v18 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          int64_t v48 = (char *)&v53 - (unsigned char *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          uint64_t v20 = (char *)v57;
          long long v19 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          long long v19 = &v53;
          uint64_t v20 = (char *)v57;
        }
      }
      long long v21 = &v20[24 * v58];
      long long v22 = *(_OWORD *)v19;
      *((void *)v21 + 2) = *((void *)v19 + 2);
      *(_OWORD *)long long v21 = v22;
      uint64_t v23 = ++v58;
      if (v56[0])
      {
        int v53 = 3;
        char v54 = " must be tensor of floating point values, but got ";
        uint64_t v55 = 50;
        long long v24 = &v53;
        unint64_t v25 = (char *)v57;
        if (v23 >= v59)
        {
          unint64_t v44 = v23 + 1;
          BOOL v45 = (char *)v57 + 24 * v23 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            int64_t v49 = (char *)&v53 - (unsigned char *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            unint64_t v25 = (char *)v57;
            long long v24 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            long long v24 = &v53;
            unint64_t v25 = (char *)v57;
          }
        }
        unint64_t v26 = &v25[24 * v58];
        long long v27 = *(_OWORD *)v24;
        *((void *)v26 + 2) = *((void *)v24 + 2);
        *(_OWORD *)unint64_t v26 = v27;
        ++v58;
        if (v56[0])
        {
          int64_t v28 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          long long v29 = (char *)v57;
          if (v58 >= v59)
          {
            unint64_t v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              int64_t v50 = (char *)&v53 - (unsigned char *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              long long v29 = (char *)v57;
              int64_t v28 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              int64_t v28 = &v53;
              long long v29 = (char *)v57;
            }
          }
          uint64_t v30 = &v29[24 * v58];
          long long v31 = *(_OWORD *)v28;
          *((void *)v30 + 2) = *((void *)v28 + 2);
          *(_OWORD *)uint64_t v30 = v31;
          ++v58;
        }
      }
    }
  }
  uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  }
  if (v65)
  {
    unint64_t v32 = (void **)__p;
    if (__p)
    {
      unint64_t v33 = v64;
      unint64_t v34 = __p;
      if (v64 != __p)
      {
        do
          unint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        unint64_t v34 = __p;
      }
      unsigned int v64 = v32;
      operator delete(v34);
    }
    int64_t v35 = v61;
    if (v61)
    {
      int64_t v36 = v62;
      int64_t v37 = v61;
      if (v62 != v61)
      {
        do
        {
          uint64_t v39 = (void *)*--v36;
          unint64_t v38 = v39;
          *int64_t v36 = 0;
          if (v39) {
            operator delete[](v38);
          }
        }
        while (v36 != v35);
        int64_t v37 = v61;
      }
      uint64_t v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60) {
      free(v57);
    }
  }
  return v13;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *(void *)a2;
  unint64_t v11 = *(void **)(*(void *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isSignlessInteger((mlir::Type *)v51, 1)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 64)
      || mlir::Type::isF16((mlir::Type *)v51)
      || mlir::Type::isF32((mlir::Type *)v51)
      || mlir::Type::isBF16((mlir::Type *)v51)
      || *((_UNKNOWN **)*v51[0] + 17) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
    {
      return 1;
    }
  }
  __int16 v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    int v53 = 3;
    char v54 = " #";
    uint64_t v55 = 2;
    uint64_t v13 = &v53;
    unint64_t v14 = (char *)v57;
    if (v58 >= v59)
    {
      unint64_t v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        int64_t v47 = (char *)&v53 - (unsigned char *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        unint64_t v14 = (char *)v57;
        uint64_t v13 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        uint64_t v13 = &v53;
        unint64_t v14 = (char *)v57;
      }
    }
    long long v15 = &v14[24 * v58];
    long long v16 = *(_OWORD *)v13;
    *((void *)v15 + 2) = *((void *)v13 + 2);
    *(_OWORD *)long long v15 = v16;
    uint64_t v17 = ++v58;
    if (v56[0])
    {
      int v53 = 5;
      char v54 = (const char *)a5;
      uint64_t v18 = &v53;
      long long v19 = (char *)v57;
      if (v17 >= v59)
      {
        unint64_t v42 = v17 + 1;
        BOOL v43 = (char *)v57 + 24 * v17 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          int64_t v48 = (char *)&v53 - (unsigned char *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          long long v19 = (char *)v57;
          uint64_t v18 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          uint64_t v18 = &v53;
          long long v19 = (char *)v57;
        }
      }
      uint64_t v20 = &v19[24 * v58];
      long long v21 = *(_OWORD *)v18;
      *((void *)v20 + 2) = *((void *)v18 + 2);
      *(_OWORD *)uint64_t v20 = v21;
      uint64_t v22 = ++v58;
      if (v56[0])
      {
        int v53 = 3;
        char v54 = " must be tensor of mps native type values, but got ";
        uint64_t v55 = 51;
        uint64_t v23 = &v53;
        long long v24 = (char *)v57;
        if (v22 >= v59)
        {
          unint64_t v44 = v22 + 1;
          BOOL v45 = (char *)v57 + 24 * v22 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            int64_t v49 = (char *)&v53 - (unsigned char *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            long long v24 = (char *)v57;
            uint64_t v23 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            uint64_t v23 = &v53;
            long long v24 = (char *)v57;
          }
        }
        unint64_t v25 = &v24[24 * v58];
        long long v26 = *(_OWORD *)v23;
        *((void *)v25 + 2) = *((void *)v23 + 2);
        *(_OWORD *)unint64_t v25 = v26;
        ++v58;
        if (v56[0])
        {
          long long v27 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          int64_t v28 = (char *)v57;
          if (v58 >= v59)
          {
            unint64_t v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              int64_t v50 = (char *)&v53 - (unsigned char *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              int64_t v28 = (char *)v57;
              long long v27 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              long long v27 = &v53;
              int64_t v28 = (char *)v57;
            }
          }
          long long v29 = &v28[24 * v58];
          long long v30 = *(_OWORD *)v27;
          *((void *)v29 + 2) = *((void *)v27 + 2);
          *(_OWORD *)long long v29 = v30;
          ++v58;
        }
      }
    }
  }
  uint64_t v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  }
  if (v65)
  {
    unint64_t v32 = (void **)__p;
    if (__p)
    {
      unint64_t v33 = v64;
      unint64_t v34 = __p;
      if (v64 != __p)
      {
        do
          unint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        unint64_t v34 = __p;
      }
      unsigned int v64 = v32;
      operator delete(v34);
    }
    int64_t v35 = v61;
    if (v61)
    {
      int64_t v36 = v62;
      int64_t v37 = v61;
      if (v62 != v61)
      {
        do
        {
          uint64_t v39 = (void *)*--v36;
          unint64_t v38 = v39;
          *int64_t v36 = 0;
          if (v39) {
            operator delete[](v38);
          }
        }
        while (v36 != v35);
        int64_t v37 = v61;
      }
      uint64_t v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60) {
      free(v57);
    }
  }
  return v31;
}

uint64_t mlir::mps::BiasAddGradOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.bias_add_grad", 17, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC980078;
  v4[12] = mlir::mps::BiasAddGradOp::canonicalize;
  long long v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    long long v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::BiasAddOpGenericAdaptorBase::BiasAddOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  int v5 = (void *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.bias_add", 12, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::BiasAddOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    *uint64_t v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::BiasAddOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::BiasAddOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::BiasAddOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::BiasAddOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    unint64_t v4 = 0x1E8EB8000uLL;
    {
      unint64_t v4 = 0x1E8EB8000;
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::BiasAddOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 108;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        __int16 v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::BiasAddOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        unint64_t v4 = 0x1E8EB8000;
      }
    }
    a1[33] = *(void *)(v4 + 1984);
    return a1[32];
  }
  return result;
}

void mlir::mps::BiasAddOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  void v27[2] = *MEMORY[0x1E4F143B8];
  uint64_t v19 = a4;
  uint64_t v20 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v20, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v19, 1);
  __int16 v8 = *a1;
  LODWORD(v27[0]) = a5;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v8);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  uint64_t v25 = (uint64_t)v8;
  uint64_t v10 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, (unsigned int *)v27);
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::BiasAddOpGenericAdaptorBase::Properties>((void *)a2) = v10;
  __src = v26;
  uint64_t v25 = 0x200000000;
  uint64_t v11 = *(void *)a2;
  mlir::ValueRange::ValueRange(&v22, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v21, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v27[0] = v22;
  v27[1] = v23;
  if (v23)
  {
    unint64_t v13 = *(void *)(mlir::ValueRange::dereference_iterator(v27, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    unsigned int v14 = v25;
    if (v25 >= HIDWORD(v25))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v26, v25 + 1, 8);
      unsigned int v14 = v25;
    }
    *((void *)__src + v14) = v13;
    unsigned int v15 = v25 + 1;
    LODWORD(v25) = v15;
    long long v16 = __src;
    uint64_t v17 = *(unsigned int *)(a2 + 72);
    unint64_t v18 = v17 + v15;
    if (v18 > *(unsigned int *)(a2 + 76))
    {
LABEL_5:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v18, 8);
      LODWORD(v17) = *(_DWORD *)(a2 + 72);
    }
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(v11, 1, "invalid number of operands")) {
      llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
    }
    unsigned int v15 = v25;
    long long v16 = __src;
    uint64_t v17 = *(unsigned int *)(a2 + 72);
    unint64_t v18 = v17 + v25;
    if (v18 > *(unsigned int *)(a2 + 76)) {
      goto LABEL_5;
    }
  }
  if (v15)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v17), v16, 8 * v15);
    LODWORD(v17) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v17 + v15;
  if (__src != v26) {
    free(__src);
  }
}

BOOL mlir::mps::BiasAddOp::verifyInvariantsImpl(uint64_t **this)
{
  __int16 v2 = *this;
  uint64_t v3 = (_DWORD *)(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  unint64_t v7 = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(v3, (const void **)"data_format", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v7)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v4 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::BiasAddOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.bias_add", 12, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC983778;
  v4[12] = mlir::mps::BiasAddOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::BitwiseAndOpGenericAdaptorBase::BitwiseAndOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_and", 15, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::mps::BitwiseAndOp::verifyInvariantsImpl(uint64_t **this)
{
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps7(*this, *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps7(*this, *(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v2 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps7(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps7(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *(void *)a2;
  uint64_t v11 = *(void **)(*(void *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isSignedInteger((mlir::Type *)v51, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 64))
    {
      return 1;
    }
  }
  __int16 v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    int v53 = 3;
    char v54 = " #";
    uint64_t v55 = 2;
    unsigned int v14 = &v53;
    unsigned int v15 = (char *)v57;
    if (v58 >= v59)
    {
      unint64_t v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        int64_t v47 = (char *)&v53 - (unsigned char *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        unsigned int v15 = (char *)v57;
        unsigned int v14 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        unsigned int v14 = &v53;
        unsigned int v15 = (char *)v57;
      }
    }
    long long v16 = &v15[24 * v58];
    long long v17 = *(_OWORD *)v14;
    *((void *)v16 + 2) = *((void *)v14 + 2);
    *(_OWORD *)long long v16 = v17;
    uint64_t v18 = ++v58;
    if (v56[0])
    {
      int v53 = 5;
      char v54 = (const char *)a5;
      uint64_t v19 = &v53;
      uint64_t v20 = (char *)v57;
      if (v18 >= v59)
      {
        unint64_t v42 = v18 + 1;
        BOOL v43 = (char *)v57 + 24 * v18 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          int64_t v48 = (char *)&v53 - (unsigned char *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          uint64_t v20 = (char *)v57;
          uint64_t v19 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          uint64_t v19 = &v53;
          uint64_t v20 = (char *)v57;
        }
      }
      unint64_t v21 = &v20[24 * v58];
      long long v22 = *(_OWORD *)v19;
      *((void *)v21 + 2) = *((void *)v19 + 2);
      *(_OWORD *)unint64_t v21 = v22;
      uint64_t v23 = ++v58;
      if (v56[0])
      {
        int v53 = 3;
        char v54 = " must be tensor of int values, but got ";
        uint64_t v55 = 39;
        long long v24 = &v53;
        uint64_t v25 = (char *)v57;
        if (v23 >= v59)
        {
          unint64_t v44 = v23 + 1;
          BOOL v45 = (char *)v57 + 24 * v23 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            int64_t v49 = (char *)&v53 - (unsigned char *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            uint64_t v25 = (char *)v57;
            long long v24 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            long long v24 = &v53;
            uint64_t v25 = (char *)v57;
          }
        }
        long long v26 = &v25[24 * v58];
        long long v27 = *(_OWORD *)v24;
        *((void *)v26 + 2) = *((void *)v24 + 2);
        *(_OWORD *)long long v26 = v27;
        ++v58;
        if (v56[0])
        {
          int64_t v28 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          long long v29 = (char *)v57;
          if (v58 >= v59)
          {
            unint64_t v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              int64_t v50 = (char *)&v53 - (unsigned char *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              long long v29 = (char *)v57;
              int64_t v28 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              int64_t v28 = &v53;
              long long v29 = (char *)v57;
            }
          }
          long long v30 = &v29[24 * v58];
          long long v31 = *(_OWORD *)v28;
          *((void *)v30 + 2) = *((void *)v28 + 2);
          *(_OWORD *)long long v30 = v31;
          ++v58;
        }
      }
    }
  }
  uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  }
  if (v65)
  {
    unint64_t v32 = (void **)__p;
    if (__p)
    {
      unint64_t v33 = v64;
      unint64_t v34 = __p;
      if (v64 != __p)
      {
        do
          unint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        unint64_t v34 = __p;
      }
      unsigned int v64 = v32;
      operator delete(v34);
    }
    int64_t v35 = v61;
    if (v61)
    {
      int64_t v36 = v62;
      int64_t v37 = v61;
      if (v62 != v61)
      {
        do
        {
          uint64_t v39 = (void *)*--v36;
          unint64_t v38 = v39;
          *int64_t v36 = 0;
          if (v39) {
            operator delete[](v38);
          }
        }
        while (v36 != v35);
        int64_t v37 = v61;
      }
      uint64_t v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60) {
      free(v57);
    }
  }
  return v13;
}

uint64_t mlir::mps::BitwiseAndOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.bitwise_and", 15, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC97FCB0;
  v4[12] = mlir::mps::BitwiseAndOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::BitwiseLeftShiftOpGenericAdaptorBase::BitwiseLeftShiftOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_left_shift", 22, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::BitwiseLeftShiftOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.bitwise_left_shift", 22, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC9813B8;
  v4[12] = mlir::mps::BitwiseLeftShiftOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::BitwiseNotOpGenericAdaptorBase::BitwiseNotOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_not", 15, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::BitwiseNotOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.bitwise_not", 15, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC97FD08;
  v4[12] = mlir::mps::BitwiseNotOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::BitwiseOrOpGenericAdaptorBase::BitwiseOrOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_or", 14, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::BitwiseOrOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.bitwise_or", 14, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC97FAA0;
  v4[12] = mlir::mps::BitwiseOrOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::BitwisePopcountOpGenericAdaptorBase::BitwisePopcountOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_popcount", 20, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::BitwisePopcountOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.bitwise_popcount", 20, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC980F40;
  v4[12] = mlir::mps::BitwisePopcountOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::BitwiseRightShiftOpGenericAdaptorBase::BitwiseRightShiftOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_right_shift", 23, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::BitwiseRightShiftOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.bitwise_right_shift", 23, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC981518;
  v4[12] = mlir::mps::BitwiseRightShiftOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::BitwiseXorOpGenericAdaptorBase::BitwiseXorOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_xor", 15, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::BitwiseXorOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.bitwise_xor", 15, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC97FD60;
  v4[12] = mlir::mps::BitwiseXorOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::BroadcastGradientArgsOpGenericAdaptorBase::BroadcastGradientArgsOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.broadcast_gradient_args", 27, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::BroadcastGradientArgsOp::build(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v24[2] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a4;
  uint64_t v19 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v19, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v18, 1);
  __src = v24;
  uint64_t v23 = 0x200000000;
  uint64_t v6 = *a1;
  uint64_t v7 = *(void *)a2;
  mlir::ValueRange::ValueRange(v21, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v20, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::BroadcastGradientArgsOp::inferReturnTypes(v6, v7, 1, v21[0], v21[1], v9, v10, v11, v16, v17, (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v12 = __src;
  }
  uint64_t v13 = v23;
  uint64_t v14 = *(unsigned int *)(a2 + 72);
  unint64_t v15 = v14 + v23;
  if (v15 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v15, 8);
    LODWORD(v14) = *(_DWORD *)(a2 + 72);
  }
  if (v13)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v14), v12, 8 * v13);
    LODWORD(v14) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v14 + v13;
  if (__src != v24) {
    free(__src);
  }
}

BOOL mlir::mps::BroadcastGradientArgsOp::verifyInvariantsImpl(uint64_t **this)
{
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v2 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::BroadcastGradientArgsOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.broadcast_gradient_args", 27, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC981C50;
  v4[12] = mlir::mps::BroadcastGradientArgsOp::canonicalize;
  uint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::BroadcastToOpGenericAdaptorBase::BroadcastToOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.broadcast_to", 16, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::BroadcastToOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v23[2] = *MEMORY[0x1E4F143B8];
  uint64_t v17 = a4;
  uint64_t v18 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v18, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v17, 1);
  __src = v23;
  uint64_t v22 = 0x200000000;
  uint64_t v5 = *(void *)a2;
  mlir::ValueRange::ValueRange(v20, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v7 = mlir::ValueRange::ValueRange(&v19, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::BroadcastToOp::inferReturnTypes((uint64_t)v7, v5, 1, v20[0], v20[1], v8, v9, v10, v15, v16, (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v11 = __src;
  }
  uint64_t v12 = v22;
  uint64_t v13 = *(unsigned int *)(a2 + 72);
  unint64_t v14 = v13 + v22;
  if (v14 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v14, 8);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  if (v12)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v13), v11, 8 * v12);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v13 + v12;
  if (__src != v23) {
    free(__src);
  }
}

BOOL mlir::mps::BroadcastToOp::verifyInvariantsImpl(uint64_t **this)
{
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v2 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::BroadcastToOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.broadcast_to", 16, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC9800D0;
  v4[12] = mlir::mps::BroadcastToOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::CallOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v101 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v87 = v6;
  if (!v6)
  {
    a3(v91, a4);
    if (v91[0])
    {
      int v88 = 3;
      unsigned int v89 = "expected DictionaryAttr to set properties";
      uint64_t v90 = 41;
      long long v26 = &v88;
      long long v27 = (char *)v92;
      if (v93 >= v94)
      {
        unint64_t v73 = v93 + 1;
        if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
        {
          int64_t v80 = (char *)&v88 - (unsigned char *)v92;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v73, 24);
          long long v27 = (char *)v92;
          long long v26 = (int *)((char *)v92 + v80);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v73, 24);
          long long v26 = &v88;
          long long v27 = (char *)v92;
        }
      }
      int64_t v28 = &v27[24 * v93];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)int64_t v28 = v29;
      ++v93;
      if (v91[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v91);
      }
    }
    if (!v100) {
      return 0;
    }
    long long v30 = (void **)__p;
    if (__p)
    {
      long long v31 = v99;
      unint64_t v32 = __p;
      if (v99 != __p)
      {
        do
          long long v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unint64_t v32 = __p;
      }
      char v99 = v30;
      operator delete(v32);
    }
    unint64_t v21 = v96;
    if (!v96) {
      goto LABEL_95;
    }
    unint64_t v33 = v97;
    uint64_t v23 = v96;
    if (v97 == v96) {
      goto LABEL_94;
    }
    do
    {
      int64_t v35 = (void *)*--v33;
      unint64_t v34 = v35;
      *unint64_t v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
    goto LABEL_93;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v87, "inlineMode", 0xAuLL);
  if (!v8)
  {
    a3(v91, a4);
    if (v91[0])
    {
      int v88 = 3;
      unsigned int v89 = "expected key entry for inlineMode in DictionaryAttr to set Properties.";
      uint64_t v90 = 70;
      int64_t v36 = &v88;
      int64_t v37 = (char *)v92;
      if (v93 >= v94)
      {
        unint64_t v75 = v93 + 1;
        if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
        {
          int64_t v82 = (char *)&v88 - (unsigned char *)v92;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v75, 24);
          int64_t v37 = (char *)v92;
          int64_t v36 = (int *)((char *)v92 + v82);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v75, 24);
          int64_t v36 = &v88;
          int64_t v37 = (char *)v92;
        }
      }
      unint64_t v38 = &v37[24 * v93];
      long long v39 = *(_OWORD *)v36;
      *((void *)v38 + 2) = *((void *)v36 + 2);
      *(_OWORD *)unint64_t v38 = v39;
      ++v93;
      if (v91[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v91);
      }
    }
    if (!v100) {
      return 0;
    }
    int64_t v40 = (void **)__p;
    if (__p)
    {
      unint64_t v41 = v99;
      unint64_t v42 = __p;
      if (v99 != __p)
      {
        do
          unint64_t v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        unint64_t v42 = __p;
      }
      char v99 = v40;
      operator delete(v42);
    }
    unint64_t v21 = v96;
    if (!v96) {
      goto LABEL_95;
    }
    BOOL v43 = v97;
    uint64_t v23 = v96;
    if (v97 == v96) {
      goto LABEL_94;
    }
    do
    {
      BOOL v45 = (void *)*--v43;
      unint64_t v44 = v45;
      void *v43 = 0;
      if (v45) {
        operator delete[](v44);
      }
    }
    while (v43 != v21);
    goto LABEL_93;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id)
  {
    a3(v91, a4);
    if (v91[0])
    {
      int v88 = 3;
      uint64_t v90 = 55;
      uint64_t v10 = &v88;
      uint64_t v11 = (char *)v92;
      if (v93 >= v94)
      {
        unint64_t v74 = v93 + 1;
        if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
        {
          int64_t v81 = (char *)&v88 - (unsigned char *)v92;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v74, 24);
          uint64_t v11 = (char *)v92;
          uint64_t v10 = (int *)((char *)v92 + v81);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v74, 24);
          uint64_t v10 = &v88;
          uint64_t v11 = (char *)v92;
        }
      }
      uint64_t v12 = &v11[24 * v93];
      long long v13 = *(_OWORD *)v10;
      *((void *)v12 + 2) = *((void *)v10 + 2);
      *(_OWORD *)uint64_t v12 = v13;
      ++v93;
      if (v91[0])
      {
        unint64_t v14 = &v88;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v88, v9);
        uint64_t v15 = (char *)v92;
        if (v93 >= v94)
        {
          unint64_t v76 = v93 + 1;
          if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
          {
            int64_t v83 = (char *)&v88 - (unsigned char *)v92;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v76, 24);
            uint64_t v15 = (char *)v92;
            unint64_t v14 = (int *)((char *)v92 + v83);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v76, 24);
            unint64_t v14 = &v88;
            uint64_t v15 = (char *)v92;
          }
        }
        uint64_t v16 = &v15[24 * v93];
        long long v17 = *(_OWORD *)v14;
        *((void *)v16 + 2) = *((void *)v14 + 2);
        *(_OWORD *)uint64_t v16 = v17;
        ++v93;
        if (v91[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v91);
        }
      }
    }
    if (!v100) {
      return 0;
    }
    uint64_t v18 = (void **)__p;
    if (__p)
    {
      unint64_t v19 = v99;
      unint64_t v20 = __p;
      if (v99 != __p)
      {
        do
          unint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        unint64_t v20 = __p;
      }
      char v99 = v18;
      operator delete(v20);
    }
    unint64_t v21 = v96;
    if (!v96) {
      goto LABEL_95;
    }
    uint64_t v22 = v97;
    uint64_t v23 = v96;
    if (v97 == v96) {
      goto LABEL_94;
    }
    do
    {
      uint64_t v25 = (void *)*--v22;
      long long v24 = v25;
      *uint64_t v22 = 0;
      if (v25) {
        operator delete[](v24);
      }
    }
    while (v22 != v21);
    goto LABEL_93;
  }
  *a1 = v8;
  uint64_t v46 = mlir::DictionaryAttr::get((uint64_t)&v87, "symbolName", 0xAuLL);
  if (!v46)
  {
    a3(v91, a4);
    if (v91[0])
    {
      int v88 = 3;
      unsigned int v89 = "expected key entry for symbolName in DictionaryAttr to set Properties.";
      uint64_t v90 = 70;
      uint64_t v62 = &v88;
      unsigned int v63 = (char *)v92;
      if (v93 >= v94)
      {
        unint64_t v78 = v93 + 1;
        if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
        {
          int64_t v85 = (char *)&v88 - (unsigned char *)v92;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v78, 24);
          unsigned int v63 = (char *)v92;
          uint64_t v62 = (int *)((char *)v92 + v85);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v78, 24);
          uint64_t v62 = &v88;
          unsigned int v63 = (char *)v92;
        }
      }
      unsigned int v64 = &v63[24 * v93];
      long long v65 = *(_OWORD *)v62;
      *((void *)v64 + 2) = *((void *)v62 + 2);
      *(_OWORD *)unsigned int v64 = v65;
      ++v93;
      if (v91[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v91);
      }
    }
    if (!v100) {
      return 0;
    }
    uint64_t v66 = (void **)__p;
    if (__p)
    {
      uint64_t v67 = v99;
      uint64_t v68 = __p;
      if (v99 != __p)
      {
        do
          uint64_t v67 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v67 - 1);
        while (v67 != v66);
        uint64_t v68 = __p;
      }
      char v99 = v66;
      operator delete(v68);
    }
    unint64_t v21 = v96;
    if (!v96) {
      goto LABEL_95;
    }
    uint64_t v69 = v97;
    uint64_t v23 = v96;
    if (v97 == v96) {
      goto LABEL_94;
    }
    do
    {
      uint64_t v71 = (void *)*--v69;
      char v70 = v71;
      *uint64_t v69 = 0;
      if (v71) {
        operator delete[](v70);
      }
    }
    while (v69 != v21);
    goto LABEL_93;
  }
  uint64_t v47 = v46;
  if (*(_UNKNOWN **)(*(void *)v46 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
  {
    a1[1] = v46;
    return 1;
  }
  a3(v91, a4);
  if (v91[0])
  {
    int v88 = 3;
    uint64_t v90 = 55;
    int64_t v48 = &v88;
    int64_t v49 = (char *)v92;
    if (v93 >= v94)
    {
      unint64_t v77 = v93 + 1;
      if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
      {
        int64_t v84 = (char *)&v88 - (unsigned char *)v92;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v77, 24);
        int64_t v49 = (char *)v92;
        int64_t v48 = (int *)((char *)v92 + v84);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v77, 24);
        int64_t v48 = &v88;
        int64_t v49 = (char *)v92;
      }
    }
    int64_t v50 = &v49[24 * v93];
    long long v51 = *(_OWORD *)v48;
    *((void *)v50 + 2) = *((void *)v48 + 2);
    *(_OWORD *)int64_t v50 = v51;
    ++v93;
    if (v91[0])
    {
      __int16 v52 = &v88;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v88, v47);
      int v53 = (char *)v92;
      if (v93 >= v94)
      {
        unint64_t v79 = v93 + 1;
        if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
        {
          int64_t v86 = (char *)&v88 - (unsigned char *)v92;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v79, 24);
          int v53 = (char *)v92;
          __int16 v52 = (int *)((char *)v92 + v86);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v79, 24);
          __int16 v52 = &v88;
          int v53 = (char *)v92;
        }
      }
      char v54 = &v53[24 * v93];
      long long v55 = *(_OWORD *)v52;
      *((void *)v54 + 2) = *((void *)v52 + 2);
      *(_OWORD *)char v54 = v55;
      ++v93;
      if (v91[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v91);
      }
    }
  }
  if (v100)
  {
    char v56 = (void **)__p;
    if (__p)
    {
      uint64_t v57 = v99;
      unsigned int v58 = __p;
      if (v99 != __p)
      {
        do
          uint64_t v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        unsigned int v58 = __p;
      }
      char v99 = v56;
      operator delete(v58);
    }
    unint64_t v21 = v96;
    if (!v96) {
      goto LABEL_95;
    }
    unsigned int v59 = v97;
    uint64_t v23 = v96;
    if (v97 == v96)
    {
LABEL_94:
      uint64_t v97 = v21;
      operator delete(v23);
LABEL_95:
      if (v92 != v95) {
        free(v92);
      }
      return 0;
    }
    do
    {
      unint64_t v61 = (void *)*--v59;
      uint64_t v60 = v61;
      void *v59 = 0;
      if (v61) {
        operator delete[](v60);
      }
    }
    while (v59 != v21);
LABEL_93:
    uint64_t v23 = v96;
    goto LABEL_94;
  }
  return 0;
}

uint64_t mlir::mps::CallOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v21[6] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a1;
  unint64_t v19 = v21;
  uint64_t v20 = 0x300000000;
  if (*a2)
  {
    uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"inlineMode", 10, *a2);
    uint64_t v5 = v4;
    unsigned int v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      unsigned int v6 = v20;
    }
    uint64_t v7 = (uint64_t *)((char *)v19 + 16 * v6);
    uint64_t *v7 = NamedAttr;
    v7[1] = v5;
    unsigned int v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    uint64_t v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      uint64_t v10 = (uint64_t *)v19;
      if (v8) {
        goto LABEL_6;
      }
LABEL_13:
      uint64_t DictionaryAttr = 0;
      if (v10 == v21) {
        return DictionaryAttr;
      }
      goto LABEL_7;
    }
  }
  else
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_5;
    }
  }
  uint64_t v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"symbolName", 10, v9);
  uint64_t v15 = v14;
  unsigned int v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    unsigned int v16 = v20;
  }
  long long v17 = (uint64_t *)((char *)v19 + 16 * v16);
  *long long v17 = v13;
  v17[1] = v15;
  unsigned int v8 = v20 + 1;
  LODWORD(v20) = v8;
  uint64_t v10 = (uint64_t *)v19;
  if (!v8) {
    goto LABEL_13;
  }
LABEL_6:
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  uint64_t v10 = (uint64_t *)v19;
  if (v19 != v21) {
LABEL_7:
  }
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps3(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    long long v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    unsigned int v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        unsigned int v8 = (char *)v35;
        uint64_t v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        unsigned int v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      long long v29 = a2;
      long long v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        long long v30 = "' failed to satisfy constraint: valid CallInlineMode";
        uint64_t v31 = 52;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        uint64_t v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)uint64_t v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    unsigned int v16 = (void **)__p;
    if (__p)
    {
      long long v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          long long v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      unint64_t v42 = v16;
      operator delete(v18);
    }
    unint64_t v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      unint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = (void *)*--v20;
          uint64_t v22 = v23;
          *uint64_t v20 = 0;
          if (v23) {
            operator delete[](v22);
          }
        }
        while (v20 != v19);
        unint64_t v21 = v39;
      }
      int64_t v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CallOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x10uLL);
    *uint64_t v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CallOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CallOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CallOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CallOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::CallOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 105;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        unsigned int v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::CallOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[13];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::mps::CallInlineModeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  int v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id) {
    return 1;
  }
  unsigned char v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    unint64_t v6 = &v40;
    unint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v7 = (char *)v46;
        unint64_t v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v6 = &v40;
        unint64_t v7 = (char *)v46;
      }
    }
    unsigned int v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)unsigned int v8 = v9;
    ++v47;
  }
  int64_t v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::CallInlineModeAttr]";
  unint64_t v41 = 79;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    int64_t v40 = (const void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      unint64_t v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          unint64_t v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          unint64_t v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      unsigned int v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)unsigned int v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unint64_t v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unint64_t v19 = (char *)v46;
            uint64_t v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            unint64_t v19 = (char *)v46;
          }
        }
        uint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = (void **)__p;
    if (__p)
    {
      long long v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          long long v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      int v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          long long v30 = (void *)*--v27;
          long long v29 = v30;
          void *v27 = 0;
          if (v30) {
            operator delete[](v29);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      long long v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

void mlir::mps::CallOp::build(mlir::StringAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, mlir::MLIRContext *a8, unsigned int a9)
{
  mlir::OperationState::addOperands(a2, a5, a6);
  __int16 v24 = 261;
  uint64_t v22 = a7;
  uint64_t v23 = a8;
  uint64_t StringAttr = mlir::Builder::getStringAttr(a1, (mlir::MLIRContext *)&v22);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CallOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = StringAttr;
  unsigned int v16 = *a1;
  unsigned int v25 = a9;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v16);
  uint64_t v22 = &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id;
  uint64_t v23 = v16;
  uint64_t v18 = mlir::StorageUniquer::get<mlir::mps::detail::CallInlineModeAttrStorage,mlir::mps::CallInlineMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25CallInlineModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18CallInlineModeAttrEJNS2_14CallInlineModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v22, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id, &v25);
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CallOpGenericAdaptorBase::Properties>((void *)a2) = v18;
  uint64_t v19 = *(unsigned int *)(a2 + 72);
  if (a4 + v19 > (unint64_t)*(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), a4 + v19, 8);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  if (a4)
  {
    uint64_t v20 = 0;
    uint64_t v21 = *(void *)(a2 + 64) + 8 * v19;
    do
    {
      *(void *)(v21 + 8 * v20) = mlir::TypeRange::dereference_iterator(a3, v20);
      ++v20;
    }
    while (a4 != v20);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v19 + a4;
}

uint64_t mlir::mps::CallOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    uint64_t v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *v3;
  if (!*v3)
  {
    v31[0] = (const void **)"requires attribute 'inlineMode'";
    __int16 v32 = 259;
    mlir::OpState::emitOpError(this, v31, (uint64_t)v33);
    uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v33);
    if (v33[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v33);
    }
    if (!v40) {
      return v15;
    }
    unsigned int v16 = (void **)__p;
    if (__p)
    {
      long long v17 = v39;
      uint64_t v18 = __p;
      if (v39 != __p)
      {
        do
          long long v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      uint64_t v39 = v16;
      operator delete(v18);
    }
    uint64_t v19 = v36;
    if (v36)
    {
      uint64_t v20 = v37;
      uint64_t v21 = v36;
      if (v37 == v36) {
        goto LABEL_52;
      }
      do
      {
        uint64_t v23 = (void *)*--v20;
        uint64_t v22 = v23;
        *uint64_t v20 = 0;
        if (v23) {
          operator delete[](v22);
        }
      }
      while (v20 != v19);
LABEL_51:
      uint64_t v21 = v36;
LABEL_52:
      int64_t v37 = v19;
      operator delete(v21);
    }
LABEL_53:
    if (v34 != &v35) {
      free(v34);
    }
    return v15;
  }
  uint64_t v5 = v3[1];
  if (!v5)
  {
    v31[0] = (const void **)"requires attribute 'symbolName'";
    __int16 v32 = 259;
    mlir::OpState::emitOpError(this, v31, (uint64_t)v33);
    uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v33);
    if (v33[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v33);
    }
    if (!v40) {
      return v15;
    }
    __int16 v24 = (void **)__p;
    if (__p)
    {
      unsigned int v25 = v39;
      unint64_t v26 = __p;
      if (v39 != __p)
      {
        do
          unsigned int v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
        while (v25 != v24);
        unint64_t v26 = __p;
      }
      uint64_t v39 = v24;
      operator delete(v26);
    }
    uint64_t v19 = v36;
    if (v36)
    {
      int64_t v27 = v37;
      uint64_t v21 = v36;
      if (v37 == v36) {
        goto LABEL_52;
      }
      do
      {
        long long v29 = (void *)*--v27;
        int64_t v28 = v29;
        void *v27 = 0;
        if (v29) {
          operator delete[](v28);
        }
      }
      while (v27 != v19);
      goto LABEL_51;
    }
    goto LABEL_53;
  }
  v33[0] = v2;
  if (!mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps0(v5, (const void **)"symbolName", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps2(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v33))return 0; {
  v33[0] = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps3(v4, (const void **)"inlineMode", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps3(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v33))return 0; {
  unint64_t v6 = *this;
  }
  if ((*((unsigned char *)*this + 46) & 0x80) != 0)
  {
    uint64_t v7 = *((unsigned int *)v6 + 17);
    if (v7)
    {
      uint64_t v8 = 0;
      uint64_t v9 = v6[9] + 24;
      while (mlir::mps::__mlir_ods_local_type_constraint_MPSOps8(*this, *(void *)(*(void *)v9 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v8))
      {
        ++v8;
        v9 += 32;
        if (v7 == v8)
        {
          unint64_t v6 = *this;
          goto LABEL_14;
        }
      }
      return 0;
    }
  }
LABEL_14:
  uint64_t v10 = *((unsigned int *)v6 + 9);
  unint64_t v11 = v6 - 2;
  if (v10) {
    uint64_t v12 = (uint64_t)v11;
  }
  else {
    uint64_t v12 = 0;
  }
  if (v10)
  {
    uint64_t v13 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v12, v13);
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps8(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, v13))break; {
      if (v10 == ++v13)
      }
        return 1;
    }
    return 0;
  }
  return 1;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps8(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *(void *)a2;
  unint64_t v11 = *(void **)(*(void *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isSignlessInteger((mlir::Type *)v51, 1)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 64)
      || mlir::Type::isF16((mlir::Type *)v51)
      || mlir::Type::isF32((mlir::Type *)v51)
      || mlir::Type::isBF16((mlir::Type *)v51)
      || *((_UNKNOWN **)*v51[0] + 17) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
    {
      return 1;
    }
  }
  __int16 v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    int v53 = 3;
    char v54 = " #";
    uint64_t v55 = 2;
    uint64_t v13 = &v53;
    unint64_t v14 = (char *)v57;
    if (v58 >= v59)
    {
      unint64_t v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        int64_t v47 = (char *)&v53 - (unsigned char *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        unint64_t v14 = (char *)v57;
        uint64_t v13 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        uint64_t v13 = &v53;
        unint64_t v14 = (char *)v57;
      }
    }
    uint64_t v15 = &v14[24 * v58];
    long long v16 = *(_OWORD *)v13;
    *((void *)v15 + 2) = *((void *)v13 + 2);
    *(_OWORD *)uint64_t v15 = v16;
    uint64_t v17 = ++v58;
    if (v56[0])
    {
      int v53 = 5;
      char v54 = (const char *)a5;
      uint64_t v18 = &v53;
      uint64_t v19 = (char *)v57;
      if (v17 >= v59)
      {
        unint64_t v42 = v17 + 1;
        BOOL v43 = (char *)v57 + 24 * v17 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          int64_t v48 = (char *)&v53 - (unsigned char *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          uint64_t v19 = (char *)v57;
          uint64_t v18 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          uint64_t v18 = &v53;
          uint64_t v19 = (char *)v57;
        }
      }
      uint64_t v20 = &v19[24 * v58];
      long long v21 = *(_OWORD *)v18;
      *((void *)v20 + 2) = *((void *)v18 + 2);
      *(_OWORD *)uint64_t v20 = v21;
      uint64_t v22 = ++v58;
      if (v56[0])
      {
        int v53 = 3;
        char v54 = " must be variadic of tensor of mps native type values, but got ";
        uint64_t v55 = 63;
        uint64_t v23 = &v53;
        __int16 v24 = (char *)v57;
        if (v22 >= v59)
        {
          unint64_t v44 = v22 + 1;
          BOOL v45 = (char *)v57 + 24 * v22 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            int64_t v49 = (char *)&v53 - (unsigned char *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            __int16 v24 = (char *)v57;
            uint64_t v23 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            uint64_t v23 = &v53;
            __int16 v24 = (char *)v57;
          }
        }
        unsigned int v25 = &v24[24 * v58];
        long long v26 = *(_OWORD *)v23;
        *((void *)v25 + 2) = *((void *)v23 + 2);
        *(_OWORD *)unsigned int v25 = v26;
        ++v58;
        if (v56[0])
        {
          int64_t v27 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          int64_t v28 = (char *)v57;
          if (v58 >= v59)
          {
            unint64_t v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              int64_t v50 = (char *)&v53 - (unsigned char *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              int64_t v28 = (char *)v57;
              int64_t v27 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              int64_t v27 = &v53;
              int64_t v28 = (char *)v57;
            }
          }
          long long v29 = &v28[24 * v58];
          long long v30 = *(_OWORD *)v27;
          *((void *)v29 + 2) = *((void *)v27 + 2);
          *(_OWORD *)long long v29 = v30;
          ++v58;
        }
      }
    }
  }
  uint64_t v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  }
  if (v65)
  {
    __int16 v32 = (void **)__p;
    if (__p)
    {
      unint64_t v33 = v64;
      unint64_t v34 = __p;
      if (v64 != __p)
      {
        do
          unint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        unint64_t v34 = __p;
      }
      unsigned int v64 = v32;
      operator delete(v34);
    }
    uint64_t v35 = v61;
    if (v61)
    {
      int64_t v36 = v62;
      int64_t v37 = v61;
      if (v62 != v61)
      {
        do
        {
          uint64_t v39 = (void *)*--v36;
          unint64_t v38 = v39;
          *int64_t v36 = 0;
          if (v39) {
            operator delete[](v38);
          }
        }
        while (v36 != v35);
        int64_t v37 = v61;
      }
      uint64_t v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60) {
      free(v57);
    }
  }
  return v31;
}

uint64_t mlir::mps::CallOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.call", 8, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC9827A8;
  v4[12] = mlir::mps::CallOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::CastOpGenericAdaptorBase::CastOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  uint64_t v5 = (void *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.cast", 8, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::CastOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v55 = v6;
  if (!v6)
  {
    a3(v59, a4);
    if (v59[0])
    {
      int v56 = 3;
      uint64_t v57 = "expected DictionaryAttr to set properties";
      uint64_t v58 = 41;
      long long v26 = &v56;
      int64_t v27 = (char *)v60;
      if (v61 >= v62)
      {
        unint64_t v47 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          int64_t v51 = (char *)&v56 - (unsigned char *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v47, 24);
          int64_t v27 = (char *)v60;
          long long v26 = (int *)((char *)v60 + v51);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v47, 24);
          long long v26 = &v56;
          int64_t v27 = (char *)v60;
        }
      }
      int64_t v28 = &v27[24 * v61];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)int64_t v28 = v29;
      ++v61;
      if (v59[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
      }
    }
    if (!v68) {
      return 0;
    }
    long long v30 = (void **)__p;
    if (__p)
    {
      uint64_t v31 = v67;
      __int16 v32 = __p;
      if (v67 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        __int16 v32 = __p;
      }
      uint64_t v67 = v30;
      operator delete(v32);
    }
    long long v21 = v64;
    if (!v64) {
      goto LABEL_59;
    }
    unint64_t v33 = v65;
    uint64_t v23 = v64;
    if (v65 == v64) {
      goto LABEL_58;
    }
    do
    {
      uint64_t v35 = (void *)*--v33;
      unint64_t v34 = v35;
      *unint64_t v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
    goto LABEL_57;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v55, "resultElementType", 0x11uLL);
  if (!v8)
  {
    a3(v59, a4);
    if (v59[0])
    {
      int v56 = 3;
      uint64_t v57 = "expected key entry for resultElementType in DictionaryAttr to set Properties.";
      uint64_t v58 = 77;
      int64_t v36 = &v56;
      int64_t v37 = (char *)v60;
      if (v61 >= v62)
      {
        unint64_t v49 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          int64_t v53 = (char *)&v56 - (unsigned char *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v49, 24);
          int64_t v37 = (char *)v60;
          int64_t v36 = (int *)((char *)v60 + v53);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v49, 24);
          int64_t v36 = &v56;
          int64_t v37 = (char *)v60;
        }
      }
      unint64_t v38 = &v37[24 * v61];
      long long v39 = *(_OWORD *)v36;
      *((void *)v38 + 2) = *((void *)v36 + 2);
      *(_OWORD *)unint64_t v38 = v39;
      ++v61;
      if (v59[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
      }
    }
    if (!v68) {
      return 0;
    }
    char v40 = (void **)__p;
    if (__p)
    {
      unint64_t v41 = v67;
      unint64_t v42 = __p;
      if (v67 != __p)
      {
        do
          unint64_t v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        unint64_t v42 = __p;
      }
      uint64_t v67 = v40;
      operator delete(v42);
    }
    long long v21 = v64;
    if (!v64) {
      goto LABEL_59;
    }
    BOOL v43 = v65;
    uint64_t v23 = v64;
    if (v65 == v64) {
      goto LABEL_58;
    }
    do
    {
      BOOL v45 = (void *)*--v43;
      unint64_t v44 = v45;
      void *v43 = 0;
      if (v45) {
        operator delete[](v44);
      }
    }
    while (v43 != v21);
    goto LABEL_57;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v59, a4);
  if (v59[0])
  {
    int v56 = 3;
    uint64_t v58 = 62;
    uint64_t v10 = &v56;
    uint64_t v11 = (char *)v60;
    if (v61 >= v62)
    {
      unint64_t v48 = v61 + 1;
      if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
      {
        int64_t v52 = (char *)&v56 - (unsigned char *)v60;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
        uint64_t v11 = (char *)v60;
        uint64_t v10 = (int *)((char *)v60 + v52);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
        uint64_t v10 = &v56;
        uint64_t v11 = (char *)v60;
      }
    }
    uint64_t v12 = &v11[24 * v61];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = *((void *)v10 + 2);
    *(_OWORD *)uint64_t v12 = v13;
    ++v61;
    if (v59[0])
    {
      unint64_t v14 = &v56;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v56, v9);
      uint64_t v15 = (char *)v60;
      if (v61 >= v62)
      {
        unint64_t v50 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          int64_t v54 = (char *)&v56 - (unsigned char *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
          uint64_t v15 = (char *)v60;
          unint64_t v14 = (int *)((char *)v60 + v54);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
          unint64_t v14 = &v56;
          uint64_t v15 = (char *)v60;
        }
      }
      long long v16 = &v15[24 * v61];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = *((void *)v14 + 2);
      *(_OWORD *)long long v16 = v17;
      ++v61;
      if (v59[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
      }
    }
  }
  if (v68)
  {
    uint64_t v18 = (void **)__p;
    if (__p)
    {
      uint64_t v19 = v67;
      uint64_t v20 = __p;
      if (v67 != __p)
      {
        do
          uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        uint64_t v20 = __p;
      }
      uint64_t v67 = v18;
      operator delete(v20);
    }
    long long v21 = v64;
    if (!v64) {
      goto LABEL_59;
    }
    uint64_t v22 = v65;
    uint64_t v23 = v64;
    if (v65 == v64)
    {
LABEL_58:
      char v65 = v21;
      operator delete(v23);
LABEL_59:
      if (v60 != v63) {
        free(v60);
      }
      return 0;
    }
    do
    {
      unsigned int v25 = (void *)*--v22;
      __int16 v24 = v25;
      *uint64_t v22 = 0;
      if (v25) {
        operator delete[](v24);
      }
    }
    while (v22 != v21);
LABEL_57:
    uint64_t v23 = v64;
    goto LABEL_58;
  }
  return 0;
}

uint64_t mlir::mps::CastOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v15[6] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a1;
  long long v13 = v15;
  uint64_t v14 = 0x300000000;
  if (!*a2) {
    return 0;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"resultElementType", 17, *a2);
  uint64_t v4 = v3;
  unsigned int v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    unsigned int v5 = v14;
  }
  uint64_t v6 = (uint64_t *)((char *)v13 + 16 * v5);
  uint64_t *v6 = NamedAttr;
  v6[1] = v4;
  uint64_t v7 = v13;
  BOOL v8 = __CFADD__(v14, 1);
  uint64_t v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v13 == v15) {
      return DictionaryAttr;
    }
    goto LABEL_10;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (uint64_t *)v13, v9);
  uint64_t v7 = v13;
  if (v13 != v15) {
LABEL_10:
  }
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CastOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    *uint64_t v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CastOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CastOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CastOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CastOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    unint64_t v4 = 0x1E8EB8000uLL;
    {
      unint64_t v4 = 0x1E8EB8000;
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::CastOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 105;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        BOOL v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::CastOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        unint64_t v4 = 0x1E8EB8000;
      }
    }
    a1[33] = *(void *)(v4 + 1960);
    return a1[32];
  }
  return result;
}

void mlir::mps::CastOp::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v23[2] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v18, 1);
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CastOpGenericAdaptorBase::Properties>((void *)a2) = a4;
  __src = v23;
  uint64_t v22 = 0x200000000;
  unint64_t v7 = *a1;
  mlir::ValueRange::ValueRange(v20, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v10 = *(uint64_t **)(a2 + 256);
  mlir::ValueRange::ValueRange(v19, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::CastOp::inferReturnTypes(v7, v11, v12, v20[0], v20[1], Dictionary, v10, v13, v19[0], v19[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  unint64_t v14 = __src;
  }
  uint64_t v15 = v22;
  uint64_t v16 = *(unsigned int *)(a2 + 72);
  unint64_t v17 = v16 + v22;
  if (v17 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v17, 8);
    LODWORD(v16) = *(_DWORD *)(a2 + 72);
  }
  if (v15)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v16), v14, 8 * v15);
    LODWORD(v16) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v16 + v15;
  if (__src != v23) {
    free(__src);
  }
}

{
  uint64_t v7;
  mlir::UnknownLoc *v8;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  uint64_t *v11;
  mlir::MLIRContext *v12;
  int v13;
  int v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20[2];
  unint64_t v21[2];
  void *__src;
  uint64_t v23;
  void v24[3];

  v24[2] = *MEMORY[0x1E4F143B8];
  uint64_t v19 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v19, 1);
  unint64_t v7 = mlir::TypeAttr::get(a4);
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CastOpGenericAdaptorBase::Properties>((void *)a2) = v7;
  __src = v24;
  uint64_t v23 = 0x200000000;
  BOOL v8 = *a1;
  mlir::ValueRange::ValueRange(v21, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  unint64_t v11 = *(uint64_t **)(a2 + 256);
  mlir::ValueRange::ValueRange(v20, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::CastOp::inferReturnTypes(v8, v12, v13, v21[0], v21[1], Dictionary, v11, v14, v20[0], v20[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v15 = __src;
  }
  uint64_t v16 = v23;
  unint64_t v17 = *(unsigned int *)(a2 + 72);
  uint64_t v18 = v17 + v23;
  if (v18 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v18, 8);
    LODWORD(v17) = *(_DWORD *)(a2 + 72);
  }
  if (v16)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v17), v15, 8 * v16);
    LODWORD(v17) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v17 + v16;
  if (__src != v24) {
    free(__src);
  }
}

BOOL mlir::mps::CastOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  uint64_t v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (v3)
  {
    v18[0] = v2;
    if (mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v3, (const void **)"resultElementType", (const char *)0x11, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps4(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v18)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0))
    {
      if (*((_DWORD *)*this + 9)) {
        uint64_t v4 = (uint64_t)(*this - 2);
      }
      else {
        uint64_t v4 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    uint64_t v16 = (const void **)"requires attribute 'resultElementType'";
    __int16 v17 = 259;
    mlir::OpState::emitOpError(this, &v16, (uint64_t)v18);
    uint64_t v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v18);
    if (v18[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
    }
    if (v25)
    {
      unint64_t v7 = (void **)__p;
      if (__p)
      {
        BOOL v8 = v24;
        unint64_t v9 = __p;
        if (v24 != __p)
        {
          do
            BOOL v8 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v8 - 1);
          while (v8 != v7);
          unint64_t v9 = __p;
        }
        __int16 v24 = v7;
        operator delete(v9);
      }
      uint64_t v10 = v21;
      if (v21)
      {
        unint64_t v11 = v22;
        int v12 = v21;
        if (v22 != v21)
        {
          do
          {
            unint64_t v14 = (void *)*--v11;
            int v13 = v14;
            void *v11 = 0;
            if (v14) {
              operator delete[](v13);
            }
          }
          while (v11 != v10);
          int v12 = v21;
        }
        uint64_t v22 = v10;
        operator delete(v12);
      }
      if (v19 != &v20) {
        free(v19);
      }
    }
  }
  return v6;
}

uint64_t mlir::mps::CastOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.cast", 8, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC9D08C0;
  v4[12] = mlir::mps::CastOp::canonicalize;
  unint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::CeilOpGenericAdaptorBase::CeilOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.ceil", 8, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::CeilOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.ceil", 8, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC982800;
  v4[12] = mlir::mps::CeilOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::ClampOpGenericAdaptorBase::ClampOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.clamp", 9, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::ClampOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v19[2] = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a4;
  uint64_t v14 = a3;
  uint64_t v12 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v14, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v13, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v12, 1);
  __src = v19;
  uint64_t v18 = 0x200000000;
  uint64_t v6 = *(void *)a2;
  mlir::ValueRange::ValueRange(v16, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v15, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  __int16 v8 = __src;
  uint64_t v9 = v18;
  uint64_t v10 = *(unsigned int *)(a2 + 72);
  unint64_t v11 = v10 + v18;
  if (v11 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v11, 8);
    LODWORD(v10) = *(_DWORD *)(a2 + 72);
  }
  if (v9)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v10), v8, 8 * v9);
    LODWORD(v10) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v10 + v9;
  if (__src != v19) {
    free(__src);
  }
}

BOOL mlir::mps::ClampOp::verifyInvariantsImpl(uint64_t **this)
{
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 2u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v2 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::ClampOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.clamp", 9, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC982F38;
  v4[12] = mlir::mps::ClampOp::canonicalize;
  uint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::ColToImOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v122 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v108 = v6;
  if (!v6)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      char v110 = "expected DictionaryAttr to set properties";
      uint64_t v111 = 41;
      uint64_t v26 = &v109;
      int64_t v27 = (char *)v113;
      if (v114 >= v115)
      {
        unint64_t v91 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          int64_t v99 = (char *)&v109 - (unsigned char *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v91, 24);
          int64_t v27 = (char *)v113;
          uint64_t v26 = (uint64_t *)((char *)v113 + v99);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v91, 24);
          uint64_t v26 = &v109;
          int64_t v27 = (char *)v113;
        }
      }
      int64_t v28 = &v27[24 * v114];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)int64_t v28 = v29;
      ++v114;
      if (v112[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121) {
      return 0;
    }
    long long v30 = (void **)__p;
    if (__p)
    {
      uint64_t v31 = v120;
      __int16 v32 = __p;
      if (v120 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        __int16 v32 = __p;
      }
      char v120 = v30;
      operator delete(v32);
    }
    long long v21 = v117;
    if (!v117) {
      goto LABEL_118;
    }
    unint64_t v33 = v118;
    uint64_t v23 = v117;
    if (v118 == v117)
    {
LABEL_117:
      BOOL v118 = v21;
      operator delete(v23);
LABEL_118:
      if (v113 != v116) {
        free(v113);
      }
      return 0;
    }
    do
    {
      uint64_t v35 = (void *)*--v33;
      unint64_t v34 = v35;
      *unint64_t v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
LABEL_116:
    uint64_t v23 = v117;
    goto LABEL_117;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v108, "data_layout", 0xBuLL);
  if (!v8)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      char v110 = "expected key entry for data_layout in DictionaryAttr to set Properties.";
      uint64_t v111 = 71;
      int64_t v36 = &v109;
      int64_t v37 = (char *)v113;
      if (v114 >= v115)
      {
        unint64_t v93 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          int64_t v101 = (char *)&v109 - (unsigned char *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v93, 24);
          int64_t v37 = (char *)v113;
          int64_t v36 = (uint64_t *)((char *)v113 + v101);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v93, 24);
          int64_t v36 = &v109;
          int64_t v37 = (char *)v113;
        }
      }
      unint64_t v38 = &v37[24 * v114];
      long long v39 = *(_OWORD *)v36;
      *((void *)v38 + 2) = v36[2];
      *(_OWORD *)unint64_t v38 = v39;
      ++v114;
      if (v112[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121) {
      return 0;
    }
    char v40 = (void **)__p;
    if (__p)
    {
      unint64_t v41 = v120;
      unint64_t v42 = __p;
      if (v120 != __p)
      {
        do
          unint64_t v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        unint64_t v42 = __p;
      }
      char v120 = v40;
      operator delete(v42);
    }
    long long v21 = v117;
    if (!v117) {
      goto LABEL_118;
    }
    BOOL v43 = v118;
    uint64_t v23 = v117;
    if (v118 == v117) {
      goto LABEL_117;
    }
    do
    {
      BOOL v45 = (void *)*--v43;
      unint64_t v44 = v45;
      void *v43 = 0;
      if (v45) {
        operator delete[](v44);
      }
    }
    while (v43 != v21);
    goto LABEL_116;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      uint64_t v111 = 56;
      uint64_t v10 = &v109;
      unint64_t v11 = (char *)v113;
      if (v114 >= v115)
      {
        unint64_t v92 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          int64_t v100 = (char *)&v109 - (unsigned char *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v92, 24);
          unint64_t v11 = (char *)v113;
          uint64_t v10 = (uint64_t *)((char *)v113 + v100);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v92, 24);
          uint64_t v10 = &v109;
          unint64_t v11 = (char *)v113;
        }
      }
      uint64_t v12 = &v11[24 * v114];
      long long v13 = *(_OWORD *)v10;
      *((void *)v12 + 2) = v10[2];
      *(_OWORD *)uint64_t v12 = v13;
      ++v114;
      if (v112[0])
      {
        uint64_t v14 = &v109;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v109, v9);
        unint64_t v15 = (char *)v113;
        if (v114 >= v115)
        {
          unint64_t v94 = v114 + 1;
          if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
          {
            int64_t v102 = (char *)&v109 - (unsigned char *)v113;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v94, 24);
            unint64_t v15 = (char *)v113;
            uint64_t v14 = (uint64_t *)((char *)v113 + v102);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v94, 24);
            uint64_t v14 = &v109;
            unint64_t v15 = (char *)v113;
          }
        }
        uint64_t v16 = &v15[24 * v114];
        long long v17 = *(_OWORD *)v14;
        *((void *)v16 + 2) = v14[2];
        *(_OWORD *)uint64_t v16 = v17;
        ++v114;
        if (v112[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
        }
      }
    }
    if (!v121) {
      return 0;
    }
    uint64_t v18 = (void **)__p;
    if (__p)
    {
      uint64_t v19 = v120;
      uint64_t v20 = __p;
      if (v120 != __p)
      {
        do
          uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        uint64_t v20 = __p;
      }
      char v120 = v18;
      operator delete(v20);
    }
    long long v21 = v117;
    if (!v117) {
      goto LABEL_118;
    }
    uint64_t v22 = v118;
    uint64_t v23 = v117;
    if (v118 == v117) {
      goto LABEL_117;
    }
    do
    {
      char v25 = (void *)*--v22;
      __int16 v24 = v25;
      *uint64_t v22 = 0;
      if (v25) {
        operator delete[](v24);
      }
    }
    while (v22 != v21);
    goto LABEL_116;
  }
  *a1 = v8;
  uint64_t v46 = mlir::DictionaryAttr::get((uint64_t)&v108, "dilation_rates", 0xEuLL);
  if (!v46)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      char v110 = "expected key entry for dilation_rates in DictionaryAttr to set Properties.";
      uint64_t v111 = 74;
      uint64_t v55 = &v109;
      int v56 = (char *)v113;
      if (v114 >= v115)
      {
        unint64_t v95 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          int64_t v103 = (char *)&v109 - (unsigned char *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v95, 24);
          int v56 = (char *)v113;
          uint64_t v55 = (uint64_t *)((char *)v113 + v103);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v95, 24);
          uint64_t v55 = &v109;
          int v56 = (char *)v113;
        }
      }
      uint64_t v57 = &v56[24 * v114];
      long long v58 = *(_OWORD *)v55;
      *((void *)v57 + 2) = v55[2];
      *(_OWORD *)uint64_t v57 = v58;
      ++v114;
      if (v112[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121) {
      return 0;
    }
    unsigned int v59 = (void **)__p;
    if (__p)
    {
      uint64_t v60 = v120;
      unsigned int v61 = __p;
      if (v120 != __p)
      {
        do
          uint64_t v60 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v60 - 1);
        while (v60 != v59);
        unsigned int v61 = __p;
      }
      char v120 = v59;
      operator delete(v61);
    }
    long long v21 = v117;
    if (!v117) {
      goto LABEL_118;
    }
    unsigned int v62 = v118;
    uint64_t v23 = v117;
    if (v118 == v117) {
      goto LABEL_117;
    }
    do
    {
      unsigned int v64 = (void *)*--v62;
      unsigned int v63 = v64;
      void *v62 = 0;
      if (v64) {
        operator delete[](v63);
      }
    }
    while (v62 != v21);
    goto LABEL_116;
  }
  uint64_t v47 = v46;
  if ((mlir::DenseIntElementsAttr::classof(v46) & 1) == 0)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      uint64_t v111 = 59;
      char v65 = &v109;
      uint64_t v66 = (char *)v113;
      if (v114 >= v115)
      {
        unint64_t v96 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          int64_t v104 = (char *)&v109 - (unsigned char *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v96, 24);
          uint64_t v66 = (char *)v113;
          char v65 = (uint64_t *)((char *)v113 + v104);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v96, 24);
          char v65 = &v109;
          uint64_t v66 = (char *)v113;
        }
      }
      uint64_t v67 = &v66[24 * v114];
      long long v68 = *(_OWORD *)v65;
      *((void *)v67 + 2) = v65[2];
      *(_OWORD *)uint64_t v67 = v68;
      ++v114;
      if (v112[0])
      {
        uint64_t v69 = &v109;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v109, v47);
        char v70 = (char *)v113;
        if (v114 >= v115)
        {
          unint64_t v97 = v114 + 1;
          if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
          {
            int64_t v105 = (char *)&v109 - (unsigned char *)v113;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v97, 24);
            char v70 = (char *)v113;
            uint64_t v69 = (uint64_t *)((char *)v113 + v105);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v97, 24);
            uint64_t v69 = &v109;
            char v70 = (char *)v113;
          }
        }
        uint64_t v71 = &v70[24 * v114];
        long long v72 = *(_OWORD *)v69;
        *((void *)v71 + 2) = v69[2];
        *(_OWORD *)uint64_t v71 = v72;
        ++v114;
        if (v112[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
        }
      }
    }
    if (!v121) {
      return 0;
    }
    unint64_t v73 = (void **)__p;
    if (__p)
    {
      unint64_t v74 = v120;
      unint64_t v75 = __p;
      if (v120 != __p)
      {
        do
          unint64_t v74 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v74 - 1);
        while (v74 != v73);
        unint64_t v75 = __p;
      }
      char v120 = v73;
      operator delete(v75);
    }
    long long v21 = v117;
    if (!v117) {
      goto LABEL_118;
    }
    unint64_t v76 = v118;
    uint64_t v23 = v117;
    if (v118 == v117) {
      goto LABEL_117;
    }
    do
    {
      unint64_t v78 = (void *)*--v76;
      unint64_t v77 = v78;
      *unint64_t v76 = 0;
      if (v78) {
        operator delete[](v77);
      }
    }
    while (v76 != v21);
    goto LABEL_116;
  }
  a1[1] = v47;
  uint64_t v48 = mlir::DictionaryAttr::get((uint64_t)&v108, "explicit_padding", 0x10uLL);
  uint64_t v107 = v48;
  if (!v48)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      char v110 = "expected key entry for explicit_padding in DictionaryAttr to set Properties.";
      uint64_t v111 = 76;
      unint64_t v79 = &v109;
      int64_t v80 = (char *)v113;
      if (v114 >= v115)
      {
        unint64_t v98 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          int64_t v106 = (char *)&v109 - (unsigned char *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v98, 24);
          int64_t v80 = (char *)v113;
          unint64_t v79 = (uint64_t *)((char *)v113 + v106);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v98, 24);
          unint64_t v79 = &v109;
          int64_t v80 = (char *)v113;
        }
      }
      int64_t v81 = &v80[24 * v114];
      long long v82 = *(_OWORD *)v79;
      *((void *)v81 + 2) = v79[2];
      *(_OWORD *)int64_t v81 = v82;
      ++v114;
      if (v112[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121) {
      return 0;
    }
    int64_t v83 = (void **)__p;
    if (__p)
    {
      int64_t v84 = v120;
      int64_t v85 = __p;
      if (v120 != __p)
      {
        do
          int64_t v84 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v84 - 1);
        while (v84 != v83);
        int64_t v85 = __p;
      }
      char v120 = v83;
      operator delete(v85);
    }
    long long v21 = v117;
    if (!v117) {
      goto LABEL_118;
    }
    int64_t v86 = v118;
    uint64_t v23 = v117;
    if (v118 == v117) {
      goto LABEL_117;
    }
    do
    {
      int v88 = (void *)*--v86;
      uint64_t v87 = v88;
      void *v86 = 0;
      if (v88) {
        operator delete[](v87);
      }
    }
    while (v86 != v21);
    goto LABEL_116;
  }
  uint64_t v49 = v48;
  if (mlir::DenseIntElementsAttr::classof(v48))
  {
    a1[2] = v49;
    uint64_t v50 = mlir::DictionaryAttr::get((uint64_t)&v108, "kernel_sizes", 0xCuLL);
    uint64_t v109 = v50;
    if (v50)
    {
      uint64_t v51 = v50;
      if ((mlir::DenseIntElementsAttr::classof(v50) & 1) == 0)
      {
        a3(v112, a4);
LABEL_127:
        mlir::InFlightDiagnostic::append<mlir::Attribute>(v90, &v109);
        goto LABEL_128;
      }
      a1[3] = v51;
      uint64_t v52 = mlir::DictionaryAttr::get((uint64_t)&v108, "strides", 7uLL);
      uint64_t v109 = v52;
      if (v52)
      {
        uint64_t v53 = v52;
        if (mlir::DenseIntElementsAttr::classof(v52))
        {
          a1[4] = v53;
          return 1;
        }
        a3(v112, a4);
        goto LABEL_127;
      }
      a3(v112, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v112, "expected key entry for strides in DictionaryAttr to set Properties.");
    }
    else
    {
      a3(v112, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v112, "expected key entry for kernel_sizes in DictionaryAttr to set Properties.");
    }
LABEL_128:
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v112);
    return 0;
  }
  a3(v112, a4);
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v89, &v107);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v112);
  return 0;
}

uint64_t mlir::mps::ColToImOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v39[6] = *MEMORY[0x1E4F143B8];
  int64_t v36 = a1;
  int64_t v37 = v39;
  uint64_t v38 = 0x300000000;
  if (!*a2)
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v36, (uint64_t)"data_layout", 11, *a2);
  uint64_t v5 = v4;
  unsigned int v6 = v38;
  if (v38 >= HIDWORD(v38))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
    unsigned int v6 = v38;
  }
  uint64_t v7 = (uint64_t *)((char *)v37 + 16 * v6);
  uint64_t *v7 = NamedAttr;
  v7[1] = v5;
  unsigned int v8 = v38 + 1;
  LODWORD(v38) = v38 + 1;
  uint64_t v9 = a2[1];
  if (v9)
  {
LABEL_7:
    uint64_t v10 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"dilation_rates", 14, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      unsigned int v13 = v38;
    }
    uint64_t v14 = (uint64_t *)((char *)v37 + 16 * v13);
    *uint64_t v14 = v10;
    v14[1] = v12;
    unsigned int v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
LABEL_10:
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"explicit_padding", 16, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      unsigned int v19 = v38;
    }
    uint64_t v20 = (uint64_t *)((char *)v37 + 16 * v19);
    *uint64_t v20 = v16;
    v20[1] = v18;
    unsigned int v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  uint64_t v21 = a2[3];
  if (v21)
  {
    uint64_t v22 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"kernel_sizes", 12, v21);
    uint64_t v24 = v23;
    unsigned int v25 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      unsigned int v25 = v38;
    }
    uint64_t v26 = (uint64_t *)((char *)v37 + 16 * v25);
    *uint64_t v26 = v22;
    v26[1] = v24;
    unsigned int v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  uint64_t v27 = a2[4];
  if (v27)
  {
    uint64_t v28 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"strides", 7, v27);
    uint64_t v30 = v29;
    unsigned int v31 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      unsigned int v31 = v38;
    }
    __int16 v32 = (uint64_t *)((char *)v37 + 16 * v31);
    *__int16 v32 = v28;
    v32[1] = v30;
    unsigned int v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  unint64_t v33 = v37;
  if (!v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v37 == v39) {
      return DictionaryAttr;
    }
    goto LABEL_24;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v36, (uint64_t *)v37, v8);
  unint64_t v33 = v37;
  if (v37 != v39) {
LABEL_24:
  }
    free(v33);
  return DictionaryAttr;
}

uint64_t mlir::mps::ColToImOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[4];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xDuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x79616C5F61746164 || *(void *)(__s1 + 3) != 0x74756F79616C5F61) {
        return 0;
      }
      return *a2;
    case 0xCuLL:
      if (memcmp(__s1, "kernel_sizes", __n)) {
        return 0;
      }
      return a2[3];
    case 0xEuLL:
      if (memcmp(__s1, "dilation_rates", __n)) {
        return 0;
      }
      return a2[1];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::ColToImOp::setInherentAttr(uint64_t result, char *__s1, size_t a3, uint64_t a4)
{
  uint64_t v5 = (void *)result;
  switch(a3)
  {
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v5[4] = v11;
        }
        else
        {
          v5[4] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x79616C5F61746164 && *(void *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
            uint64_t v7 = a4;
          }
          else {
            uint64_t v7 = 0;
          }
          *(void *)uint64_t result = v7;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xCuLL:
      uint64_t result = memcmp(__s1, "kernel_sizes", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          v5[3] = v8;
        }
        else
        {
          v5[3] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v9 = a4;
          }
          else {
            uint64_t v9 = 0;
          }
          v5[1] = v9;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          void v5[2] = v10;
        }
        else
        {
          void v5[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::ColToImOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (*a2) {
    mlir::NamedAttrList::append(a3, (uint64_t)"data_layout", 11, *a2);
  }
  uint64_t v5 = a2[1];
  if (v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"dilation_rates", 14, v5);
  }
  uint64_t v6 = a2[2];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"explicit_padding", 16, v6);
  }
  uint64_t v7 = a2[3];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"kernel_sizes", 12, v7);
  }
  uint64_t v8 = a2[4];
  if (v8)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"strides", 7, v8);
  }
}

BOOL mlir::mps::ColToImOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(const void ***__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = (_DWORD *)mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps7(v8, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))a3, a4))
  {
    uint64_t v9 = (void *)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v9, (const void **)"dilation_rates", (const char *)0xE, a3, a4))
    {
      uint64_t v10 = (const void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v10, (const void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))a3, a4))
      {
        uint64_t v11 = (void *)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 24));
        if (!v11
          || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v11, (const void **)"kernel_sizes", (const char *)0xC, a3, a4))
        {
          uint64_t v12 = (void *)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v12, (const void **)"strides", (const char *)7, a3, a4))
          {
            return 1;
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps7(_DWORD *a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id
    && a1[2] < 2u)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    uint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v8 = &v29;
    uint64_t v9 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v9 = (char *)v35;
        uint64_t v8 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = &v29;
        uint64_t v9 = (char *)v35;
      }
    }
    uint64_t v10 = &v9[24 * v36];
    long long v11 = *(_OWORD *)v8;
    *((void *)v10 + 2) = v8[2];
    *(_OWORD *)uint64_t v10 = v11;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      uint64_t v29 = a2;
      uint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        uint64_t v30 = "' failed to satisfy constraint: valid TensorDataLayout is one of NCHW or NHWC";
        uint64_t v31 = 77;
        uint64_t v12 = &v29;
        unsigned int v13 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            unsigned int v13 = (char *)v35;
            uint64_t v12 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = &v29;
            unsigned int v13 = (char *)v35;
          }
        }
        uint64_t v14 = &v13[24 * v36];
        long long v15 = *(_OWORD *)v12;
        *((void *)v14 + 2) = v12[2];
        *(_OWORD *)uint64_t v14 = v15;
        ++v36;
      }
    }
  }
  uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    uint64_t v16 = (void **)__p;
    if (__p)
    {
      uint64_t v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          uint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      unint64_t v42 = v16;
      operator delete(v18);
    }
    unsigned int v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      uint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = (void *)*--v20;
          uint64_t v22 = v23;
          *uint64_t v20 = 0;
          if (v23) {
            operator delete[](v22);
          }
        }
        while (v20 != v19);
        uint64_t v21 = v39;
      }
      char v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v7;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(void *a1, const void **a2, const char *a3, void (*a4)(const void ***__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 1;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1)) {
    goto LABEL_7;
  }
  uint64_t v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*a1 + 8);
  v45[0] = a1;
  v45[1] = v10;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v45);
  uint64_t v12 = Type;
  if (Type) {
    Type = (void *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  }
  v46[0] = v12;
  v46[1] = Type;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v46);
  uint64_t v65 = 2;
  if (v14 != 1 || *ArgAttrsAttr != v65) {
    goto LABEL_7;
  }
  uint64_t v44 = a1;
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v53, (uint64_t)a1, 0);
  uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v44);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v49, (uint64_t)a1, NumElements);
  while (1)
  {
    BOOL v34 = v53 == v49 && v54[0] == v50;
    if (v34 && v55 == v51) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v53, (llvm::APInt *)&v47);
    if (v48 > 0x40)
    {
      uint64_t v33 = *(void *)v47;
      operator delete[](v47);
      if (!v33) {
        goto LABEL_7;
      }
    }
    else if (!v47)
    {
      goto LABEL_7;
    }
    ++v55;
  }
  unint64_t v41 = a1;
  v42[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v41);
  v42[1] = v35;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v42);
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
    return 1;
  }
LABEL_7:
  a4(&v53, a5);
  if (v53)
  {
    LODWORD(v49) = 3;
    uint64_t v50 = "attribute '";
    uint64_t v51 = 11;
    long long v15 = &v49;
    uint64_t v16 = (char *)v56;
    if (v57 >= v58)
    {
      unint64_t v37 = v57 + 1;
      if (v56 <= &v49 && (char *)v56 + 24 * v57 > (char *)&v49)
      {
        int64_t v39 = (char *)&v49 - (unsigned char *)v56;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v37, 24);
        uint64_t v16 = (char *)v56;
        long long v15 = (const void ***)((char *)v56 + v39);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v37, 24);
        long long v15 = &v49;
        uint64_t v16 = (char *)v56;
      }
    }
    uint64_t v17 = &v16[24 * v57];
    long long v18 = *(_OWORD *)v15;
    *((void *)v17 + 2) = v15[2];
    *(_OWORD *)uint64_t v17 = v18;
    ++v57;
    if (v53)
    {
      __int16 v52 = 261;
      uint64_t v49 = a2;
      uint64_t v50 = a3;
      mlir::Diagnostic::operator<<((uint64_t)v54, &v49);
      if (v53)
      {
        LODWORD(v49) = 3;
        uint64_t v50 = "' failed to satisfy constraint: positive ui64 elements attribute of shape {2}";
        uint64_t v51 = 77;
        unsigned int v19 = &v49;
        uint64_t v20 = (char *)v56;
        if (v57 >= v58)
        {
          unint64_t v38 = v57 + 1;
          if (v56 <= &v49 && (char *)v56 + 24 * v57 > (char *)&v49)
          {
            int64_t v40 = (char *)&v49 - (unsigned char *)v56;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v38, 24);
            uint64_t v20 = (char *)v56;
            unsigned int v19 = (const void ***)((char *)v56 + v40);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v38, 24);
            unsigned int v19 = &v49;
            uint64_t v20 = (char *)v56;
          }
        }
        uint64_t v21 = &v20[24 * v57];
        long long v22 = *(_OWORD *)v19;
        *((void *)v21 + 2) = v19[2];
        *(_OWORD *)uint64_t v21 = v22;
        ++v57;
      }
    }
  }
  uint64_t v23 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v53);
  if (v53) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v53);
  }
  if (v64)
  {
    uint64_t v24 = (void **)__p;
    if (__p)
    {
      unint64_t v25 = v63;
      unint64_t v26 = __p;
      if (v63 != __p)
      {
        do
          unint64_t v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
        while (v25 != v24);
        unint64_t v26 = __p;
      }
      unsigned int v63 = v24;
      operator delete(v26);
    }
    int64_t v27 = v60;
    if (v60)
    {
      int64_t v28 = v61;
      uint64_t v29 = v60;
      if (v61 != v60)
      {
        do
        {
          uint64_t v31 = (void *)*--v28;
          uint64_t v30 = v31;
          void *v28 = 0;
          if (v31) {
            operator delete[](v30);
          }
        }
        while (v28 != v27);
        uint64_t v29 = v60;
      }
      unsigned int v61 = v27;
      operator delete(v29);
    }
    if (v56 != v59) {
      free(v56);
    }
  }
  return v23;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(const void **a1, const void **a2, const char *a3, void (*a4)(void **__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 1;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1)) {
    goto LABEL_13;
  }
  uint64_t v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>((uint64_t)*a1 + 8);
  unint64_t v42 = a1;
  char v43 = (const char *)v10;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v42);
  uint64_t v12 = Type;
  if (Type) {
    Type = (void *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  }
  uint64_t v46 = v12;
  uint64_t v47 = Type;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v46);
  long long v57 = xmmword_18110B5E0;
  if (v14 == 2 && *ArgAttrsAttr == (void)v57 && ArgAttrsAttr[1] == *((void *)&v57 + 1))
  {
    int64_t v39 = a1;
    v40[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v39);
    v40[1] = v16;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v40);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
  }
LABEL_13:
  a4(&v46, a5);
  if (v46)
  {
    LODWORD(v42) = 3;
    char v43 = "attribute '";
    uint64_t v44 = 11;
    long long v18 = &v42;
    unsigned int v19 = (char *)v48;
    if (v49 >= v50)
    {
      unint64_t v35 = v49 + 1;
      if (v48 <= &v42 && (char *)v48 + 24 * v49 > (char *)&v42)
      {
        int64_t v37 = (char *)&v42 - (unsigned char *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
        unsigned int v19 = (char *)v48;
        long long v18 = (const void ***)((char *)v48 + v37);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
        long long v18 = &v42;
        unsigned int v19 = (char *)v48;
      }
    }
    uint64_t v20 = &v19[24 * v49];
    long long v21 = *(_OWORD *)v18;
    *((void *)v20 + 2) = v18[2];
    *(_OWORD *)uint64_t v20 = v21;
    ++v49;
    if (v46)
    {
      __int16 v45 = 261;
      unint64_t v42 = a2;
      char v43 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v47, &v42);
      if (v46)
      {
        LODWORD(v42) = 3;
        char v43 = "' failed to satisfy constraint: ui64 elements attribute of shape {4, 2}";
        uint64_t v44 = 71;
        long long v22 = &v42;
        uint64_t v23 = (char *)v48;
        if (v49 >= v50)
        {
          unint64_t v36 = v49 + 1;
          if (v48 <= &v42 && (char *)v48 + 24 * v49 > (char *)&v42)
          {
            int64_t v38 = (char *)&v42 - (unsigned char *)v48;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v36, 24);
            uint64_t v23 = (char *)v48;
            long long v22 = (const void ***)((char *)v48 + v38);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v36, 24);
            long long v22 = &v42;
            uint64_t v23 = (char *)v48;
          }
        }
        uint64_t v24 = &v23[24 * v49];
        long long v25 = *(_OWORD *)v22;
        *((void *)v24 + 2) = v22[2];
        *(_OWORD *)uint64_t v24 = v25;
        ++v49;
      }
    }
  }
  uint64_t v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v46);
  if (v46) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v46);
  }
  if (v56)
  {
    unint64_t v26 = (void **)__p;
    if (__p)
    {
      int64_t v27 = v55;
      int64_t v28 = __p;
      if (v55 != __p)
      {
        do
          int64_t v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
        while (v27 != v26);
        int64_t v28 = __p;
      }
      uint64_t v55 = v26;
      operator delete(v28);
    }
    uint64_t v29 = v52;
    if (v52)
    {
      uint64_t v30 = v53;
      uint64_t v31 = v52;
      if (v53 != v52)
      {
        do
        {
          uint64_t v33 = (void *)*--v30;
          __int16 v32 = v33;
          *uint64_t v30 = 0;
          if (v33) {
            operator delete[](v32);
          }
        }
        while (v30 != v29);
        uint64_t v31 = v52;
      }
      uint64_t v53 = v29;
      operator delete(v31);
    }
    if (v48 != v51) {
      free(v48);
    }
  }
  return v17;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x28uLL);
    *uint64_t v3 = 0u;
    v3[1] = 0u;
    *((void *)v3 + 4) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        unsigned int v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 108;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[15];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  int v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
    return 1;
  }
  unsigned char v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    unint64_t v6 = &v40;
    unint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v7 = (char *)v46;
        unint64_t v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v6 = &v40;
        unint64_t v7 = (char *)v46;
      }
    }
    uint64_t v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)uint64_t v8 = v9;
    ++v47;
  }
  int64_t v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::TensorDataLayoutAttr]";
  unint64_t v41 = 81;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    int64_t v40 = (const void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      unint64_t v14 = &v40;
      long long v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          long long v15 = (char *)v46;
          unint64_t v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          unint64_t v14 = &v40;
          long long v15 = (char *)v46;
        }
      }
      uint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)uint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        long long v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unsigned int v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unsigned int v19 = (char *)v46;
            long long v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            long long v18 = &v40;
            unsigned int v19 = (char *)v46;
          }
        }
        uint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = (void **)__p;
    if (__p)
    {
      uint64_t v24 = v53;
      long long v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        long long v25 = __p;
      }
      uint64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = (void *)*--v27;
          uint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            operator delete[](v29);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      uint64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

void mlir::mps::ColToImOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, long long *a5, uint64_t a6, long long *a7, uint64_t a8, long long *a9, uint64_t a10, uint64_t *a11, uint64_t a12, unsigned int a13)
{
  uint64_t v16 = mlir::mps::get2DElementsForImToCol(a1, a5);
  uint64_t v17 = mlir::mps::get2DElementsForImToCol(a1, a7);
  uint64_t v18 = mlir::mps::get2DElementsForImToCol(a1, a9);
  uint64_t FormattedPaddingImToCol = mlir::mps::getFormattedPaddingImToCol(a1, a11, a12, a13);

  mlir::mps::ColToImOp::build((mlir::MLIRContext **)a1, a2, a3, a4, v16, v17, v18, FormattedPaddingImToCol, a13);
}

void mlir::mps::ColToImOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  v36[2] = *MEMORY[0x1E4F143B8];
  uint64_t v29 = a4;
  uint64_t v30 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v30, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v29, 1);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties>((void *)a2)
            + 24) = a5;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties>((void *)a2)
            + 32) = a6;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = a7;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties>((void *)a2)
            + 16) = a8;
  long long v15 = *a1;
  unsigned int v31 = a9;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v15);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  uint64_t v35 = (uint64_t)v15;
  uint64_t v17 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v31);
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties>((void *)a2) = v17;
  __src = v36;
  uint64_t v35 = 0x200000000;
  mlir::ValueRange::ValueRange(v33, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v20 = *(long long **)(a2 + 256);
  long long v21 = mlir::ValueRange::ValueRange(v32, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::ColToImOp::inferReturnTypes((uint64_t)v21, v22, v23, v33[0], v33[1], Dictionary, v20, v24, v32[0], v32[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  long long v25 = __src;
  }
  uint64_t v26 = v35;
  uint64_t v27 = *(unsigned int *)(a2 + 72);
  unint64_t v28 = v27 + v35;
  if (v28 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v28, 8);
    LODWORD(v27) = *(_DWORD *)(a2 + 72);
  }
  if (v26)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v27), v25, 8 * v26);
    LODWORD(v27) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v27 + v26;
  if (__src != v36) {
    free(__src);
  }
}

BOOL mlir::mps::ColToImOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    unint64_t v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    unint64_t v3 = 0;
  }
  uint64_t v4 = *(_DWORD **)v3;
  if (*(void *)v3)
  {
    int v5 = *(void **)(v3 + 8);
    if (v5)
    {
      unint64_t v6 = *(const void ***)(v3 + 16);
      if (v6)
      {
        unint64_t v7 = *(void **)(v3 + 24);
        if (v7)
        {
          uint64_t v8 = *(void **)(v3 + 32);
          if (v8)
          {
            v47[0] = v2;
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v7, (const void **)"kernel_sizes", (const char *)0xC, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0; {
            v47[0] = *this;
            }
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v8, (const void **)"strides", (const char *)7, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0; {
            v47[0] = *this;
            }
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0; {
            v47[0] = *this;
            }
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0; {
            v47[0] = *this;
            }
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps7(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps7(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps9(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
            {
              return 0;
            }
            if (*((_DWORD *)*this + 9)) {
              uint64_t v9 = (uint64_t)(*this - 2);
            }
            else {
              uint64_t v9 = 0;
            }
            uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v9, 0);
            return mlir::mps::__mlir_ods_local_type_constraint_MPSOps10(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
          }
          v45[0] = (const void **)"requires attribute 'strides'";
          __int16 v46 = 259;
          mlir::OpState::emitOpError(this, v45, (uint64_t)v47);
          uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
          if (v47[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
          }
          if (v54)
          {
            int64_t v38 = (void **)__p;
            if (__p)
            {
              uint64_t v39 = v53;
              int64_t v40 = __p;
              if (v53 != __p)
              {
                do
                  uint64_t v39 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v39 - 1);
                while (v39 != v38);
                int64_t v40 = __p;
              }
              uint64_t v53 = v38;
              operator delete(v40);
            }
            long long v15 = v50;
            if (!v50) {
              goto LABEL_93;
            }
            unint64_t v41 = v51;
            uint64_t v17 = v50;
            if (v51 == v50)
            {
LABEL_92:
              uint64_t v51 = v15;
              operator delete(v17);
LABEL_93:
              if (v48 != &v49) {
                free(v48);
              }
              return v11;
            }
            do
            {
              __int16 v43 = (void *)*--v41;
              uint64_t v42 = v43;
              *unint64_t v41 = 0;
              if (v43) {
                operator delete[](v42);
              }
            }
            while (v41 != v15);
LABEL_91:
            uint64_t v17 = v50;
            goto LABEL_92;
          }
        }
        else
        {
          v45[0] = (const void **)"requires attribute 'kernel_sizes'";
          __int16 v46 = 259;
          mlir::OpState::emitOpError(this, v45, (uint64_t)v47);
          uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
          if (v47[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
          }
          if (v54)
          {
            unint64_t v32 = (void **)__p;
            if (__p)
            {
              unint64_t v33 = v53;
              unint64_t v34 = __p;
              if (v53 != __p)
              {
                do
                  unint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
                while (v33 != v32);
                unint64_t v34 = __p;
              }
              uint64_t v53 = v32;
              operator delete(v34);
            }
            long long v15 = v50;
            if (!v50) {
              goto LABEL_93;
            }
            uint64_t v35 = v51;
            uint64_t v17 = v50;
            if (v51 == v50) {
              goto LABEL_92;
            }
            do
            {
              int64_t v37 = (void *)*--v35;
              int64_t v36 = v37;
              *uint64_t v35 = 0;
              if (v37) {
                operator delete[](v36);
              }
            }
            while (v35 != v15);
            goto LABEL_91;
          }
        }
      }
      else
      {
        v45[0] = (const void **)"requires attribute 'explicit_padding'";
        __int16 v46 = 259;
        mlir::OpState::emitOpError(this, v45, (uint64_t)v47);
        uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
        if (v47[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
        }
        if (v54)
        {
          uint64_t v26 = (void **)__p;
          if (__p)
          {
            uint64_t v27 = v53;
            unint64_t v28 = __p;
            if (v53 != __p)
            {
              do
                uint64_t v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
              while (v27 != v26);
              unint64_t v28 = __p;
            }
            uint64_t v53 = v26;
            operator delete(v28);
          }
          long long v15 = v50;
          if (!v50) {
            goto LABEL_93;
          }
          uint64_t v29 = v51;
          uint64_t v17 = v50;
          if (v51 == v50) {
            goto LABEL_92;
          }
          do
          {
            unsigned int v31 = (void *)*--v29;
            uint64_t v30 = v31;
            void *v29 = 0;
            if (v31) {
              operator delete[](v30);
            }
          }
          while (v29 != v15);
          goto LABEL_91;
        }
      }
    }
    else
    {
      v45[0] = (const void **)"requires attribute 'dilation_rates'";
      __int16 v46 = 259;
      mlir::OpState::emitOpError(this, v45, (uint64_t)v47);
      uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
      if (v54)
      {
        uint64_t v20 = (void **)__p;
        if (__p)
        {
          long long v21 = v53;
          uint64_t v22 = __p;
          if (v53 != __p)
          {
            do
              long long v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
            while (v21 != v20);
            uint64_t v22 = __p;
          }
          uint64_t v53 = v20;
          operator delete(v22);
        }
        long long v15 = v50;
        if (!v50) {
          goto LABEL_93;
        }
        uint64_t v23 = v51;
        uint64_t v17 = v50;
        if (v51 == v50) {
          goto LABEL_92;
        }
        do
        {
          long long v25 = (void *)*--v23;
          uint64_t v24 = v25;
          *uint64_t v23 = 0;
          if (v25) {
            operator delete[](v24);
          }
        }
        while (v23 != v15);
        goto LABEL_91;
      }
    }
  }
  else
  {
    v45[0] = (const void **)"requires attribute 'data_layout'";
    __int16 v46 = 259;
    mlir::OpState::emitOpError(this, v45, (uint64_t)v47);
    uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
    if (v47[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
    if (v54)
    {
      uint64_t v12 = (void **)__p;
      if (__p)
      {
        unint64_t v13 = v53;
        unint64_t v14 = __p;
        if (v53 != __p)
        {
          do
            unint64_t v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
          while (v13 != v12);
          unint64_t v14 = __p;
        }
        uint64_t v53 = v12;
        operator delete(v14);
      }
      long long v15 = v50;
      if (!v50) {
        goto LABEL_93;
      }
      uint64_t v16 = v51;
      uint64_t v17 = v50;
      if (v51 == v50) {
        goto LABEL_92;
      }
      do
      {
        unsigned int v19 = (void *)*--v16;
        uint64_t v18 = v19;
        void *v16 = 0;
        if (v19) {
          operator delete[](v18);
        }
      }
      while (v16 != v15);
      goto LABEL_91;
    }
  }
  return v11;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps9(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  unint64_t v10 = *a2;
  uint64_t v11 = (void *)*((void *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v61[0] = a2;
    v61[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
    if (mlir::Type::isF32((mlir::Type *)&OperandRange)) {
      return 1;
    }
    unint64_t v10 = *a2;
    if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
LABEL_3:
      uint64_t v53 = a2;
      uint64_t v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53)) {
        goto LABEL_10;
      }
      uint64_t v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      uint64_t v58 = a2;
      uint64_t v59 = v12;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
      if (v13 != 3) {
        goto LABEL_10;
      }
      uint64_t v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v56[0] = a2;
      v56[1] = v14;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
      if (!mlir::Type::isF32((mlir::Type *)&OperandRange)) {
        goto LABEL_10;
      }
      return 1;
    }
  }
  else if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    goto LABEL_3;
  }
LABEL_10:
  __int16 v55 = 261;
  uint64_t v53 = a3;
  uint64_t v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v61);
  if (v61[0])
  {
    LODWORD(v58) = 3;
    uint64_t v59 = (uint64_t)" #";
    uint64_t v60 = 2;
    uint64_t v16 = &v58;
    uint64_t v17 = (char *)v62;
    if (v63 >= v64)
    {
      unint64_t v43 = v63 + 1;
      if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
      {
        int64_t v49 = (char *)&v58 - (unsigned char *)v62;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        uint64_t v17 = (char *)v62;
        uint64_t v16 = (const void ***)((char *)v62 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        uint64_t v16 = &v58;
        uint64_t v17 = (char *)v62;
      }
    }
    uint64_t v18 = &v17[24 * v63];
    long long v19 = *(_OWORD *)v16;
    *((void *)v18 + 2) = v16[2];
    *(_OWORD *)uint64_t v18 = v19;
    uint64_t v20 = ++v63;
    if (v61[0])
    {
      LODWORD(v58) = 5;
      uint64_t v59 = a5;
      long long v21 = &v58;
      uint64_t v22 = (char *)v62;
      if (v20 >= v64)
      {
        unint64_t v44 = v20 + 1;
        BOOL v45 = (char *)v62 + 24 * v20 > (char *)&v58;
        if (v62 <= &v58 && v45)
        {
          int64_t v50 = (char *)&v58 - (unsigned char *)v62;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          uint64_t v22 = (char *)v62;
          long long v21 = (const void ***)((char *)v62 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          long long v21 = &v58;
          uint64_t v22 = (char *)v62;
        }
      }
      uint64_t v23 = &v22[24 * v63];
      long long v24 = *(_OWORD *)v21;
      *((void *)v23 + 2) = v21[2];
      *(_OWORD *)uint64_t v23 = v24;
      uint64_t v25 = ++v63;
      if (v61[0])
      {
        LODWORD(v58) = 3;
        uint64_t v59 = (uint64_t)" must be unranked tensor of 32-bit float values or 3D tensor of 32-bit float values, but got ";
        uint64_t v60 = 93;
        uint64_t v26 = &v58;
        uint64_t v27 = (char *)v62;
        if (v25 >= v64)
        {
          unint64_t v46 = v25 + 1;
          BOOL v47 = (char *)v62 + 24 * v25 > (char *)&v58;
          if (v62 <= &v58 && v47)
          {
            int64_t v51 = (char *)&v58 - (unsigned char *)v62;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            uint64_t v27 = (char *)v62;
            uint64_t v26 = (const void ***)((char *)v62 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            uint64_t v26 = &v58;
            uint64_t v27 = (char *)v62;
          }
        }
        unint64_t v28 = &v27[24 * v63];
        long long v29 = *(_OWORD *)v26;
        *((void *)v28 + 2) = v26[2];
        *(_OWORD *)unint64_t v28 = v29;
        ++v63;
        if (v61[0])
        {
          uint64_t v30 = &v58;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v58, (uint64_t)a2);
          unsigned int v31 = (char *)v62;
          if (v63 >= v64)
          {
            unint64_t v48 = v63 + 1;
            if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
            {
              int64_t v52 = (char *)&v58 - (unsigned char *)v62;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              unsigned int v31 = (char *)v62;
              uint64_t v30 = (const void ***)((char *)v62 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              uint64_t v30 = &v58;
              unsigned int v31 = (char *)v62;
            }
          }
          unint64_t v32 = &v31[24 * v63];
          long long v33 = *(_OWORD *)v30;
          *((void *)v32 + 2) = v30[2];
          *(_OWORD *)unint64_t v32 = v33;
          ++v63;
        }
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v61);
  if (v61[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v61);
  }
  if (v70)
  {
    unint64_t v34 = (void **)__p;
    if (__p)
    {
      uint64_t v35 = v69;
      int64_t v36 = __p;
      if (v69 != __p)
      {
        do
          uint64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        int64_t v36 = __p;
      }
      uint64_t v69 = v34;
      operator delete(v36);
    }
    int64_t v37 = v66;
    if (v66)
    {
      int64_t v38 = v67;
      uint64_t v39 = v66;
      if (v67 != v66)
      {
        do
        {
          unint64_t v41 = (void *)*--v38;
          int64_t v40 = v41;
          void *v38 = 0;
          if (v41) {
            operator delete[](v40);
          }
        }
        while (v38 != v37);
        uint64_t v39 = v66;
      }
      uint64_t v67 = v37;
      operator delete(v39);
    }
    if (v62 != v65) {
      free(v62);
    }
  }
  return v15;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps10(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  unint64_t v10 = *a2;
  uint64_t v11 = (void *)*((void *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v61[0] = a2;
    v61[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
    if (mlir::Type::isF32((mlir::Type *)&OperandRange)) {
      return 1;
    }
    unint64_t v10 = *a2;
    if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
LABEL_3:
      uint64_t v53 = a2;
      uint64_t v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53)) {
        goto LABEL_10;
      }
      uint64_t v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      uint64_t v58 = a2;
      uint64_t v59 = v12;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
      if (v13 != 4) {
        goto LABEL_10;
      }
      uint64_t v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v56[0] = a2;
      v56[1] = v14;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
      if (!mlir::Type::isF32((mlir::Type *)&OperandRange)) {
        goto LABEL_10;
      }
      return 1;
    }
  }
  else if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    goto LABEL_3;
  }
LABEL_10:
  __int16 v55 = 261;
  uint64_t v53 = a3;
  uint64_t v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v61);
  if (v61[0])
  {
    LODWORD(v58) = 3;
    uint64_t v59 = (uint64_t)" #";
    uint64_t v60 = 2;
    uint64_t v16 = &v58;
    uint64_t v17 = (char *)v62;
    if (v63 >= v64)
    {
      unint64_t v43 = v63 + 1;
      if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
      {
        int64_t v49 = (char *)&v58 - (unsigned char *)v62;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        uint64_t v17 = (char *)v62;
        uint64_t v16 = (const void ***)((char *)v62 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        uint64_t v16 = &v58;
        uint64_t v17 = (char *)v62;
      }
    }
    uint64_t v18 = &v17[24 * v63];
    long long v19 = *(_OWORD *)v16;
    *((void *)v18 + 2) = v16[2];
    *(_OWORD *)uint64_t v18 = v19;
    uint64_t v20 = ++v63;
    if (v61[0])
    {
      LODWORD(v58) = 5;
      uint64_t v59 = a5;
      long long v21 = &v58;
      uint64_t v22 = (char *)v62;
      if (v20 >= v64)
      {
        unint64_t v44 = v20 + 1;
        BOOL v45 = (char *)v62 + 24 * v20 > (char *)&v58;
        if (v62 <= &v58 && v45)
        {
          int64_t v50 = (char *)&v58 - (unsigned char *)v62;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          uint64_t v22 = (char *)v62;
          long long v21 = (const void ***)((char *)v62 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          long long v21 = &v58;
          uint64_t v22 = (char *)v62;
        }
      }
      uint64_t v23 = &v22[24 * v63];
      long long v24 = *(_OWORD *)v21;
      *((void *)v23 + 2) = v21[2];
      *(_OWORD *)uint64_t v23 = v24;
      uint64_t v25 = ++v63;
      if (v61[0])
      {
        LODWORD(v58) = 3;
        uint64_t v59 = (uint64_t)" must be unranked tensor of 32-bit float values or 4D tensor of 32-bit float values, but got ";
        uint64_t v60 = 93;
        uint64_t v26 = &v58;
        uint64_t v27 = (char *)v62;
        if (v25 >= v64)
        {
          unint64_t v46 = v25 + 1;
          BOOL v47 = (char *)v62 + 24 * v25 > (char *)&v58;
          if (v62 <= &v58 && v47)
          {
            int64_t v51 = (char *)&v58 - (unsigned char *)v62;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            uint64_t v27 = (char *)v62;
            uint64_t v26 = (const void ***)((char *)v62 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            uint64_t v26 = &v58;
            uint64_t v27 = (char *)v62;
          }
        }
        unint64_t v28 = &v27[24 * v63];
        long long v29 = *(_OWORD *)v26;
        *((void *)v28 + 2) = v26[2];
        *(_OWORD *)unint64_t v28 = v29;
        ++v63;
        if (v61[0])
        {
          uint64_t v30 = &v58;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v58, (uint64_t)a2);
          unsigned int v31 = (char *)v62;
          if (v63 >= v64)
          {
            unint64_t v48 = v63 + 1;
            if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
            {
              int64_t v52 = (char *)&v58 - (unsigned char *)v62;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              unsigned int v31 = (char *)v62;
              uint64_t v30 = (const void ***)((char *)v62 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              uint64_t v30 = &v58;
              unsigned int v31 = (char *)v62;
            }
          }
          unint64_t v32 = &v31[24 * v63];
          long long v33 = *(_OWORD *)v30;
          *((void *)v32 + 2) = v30[2];
          *(_OWORD *)unint64_t v32 = v33;
          ++v63;
        }
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v61);
  if (v61[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v61);
  }
  if (v70)
  {
    unint64_t v34 = (void **)__p;
    if (__p)
    {
      uint64_t v35 = v69;
      int64_t v36 = __p;
      if (v69 != __p)
      {
        do
          uint64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        int64_t v36 = __p;
      }
      uint64_t v69 = v34;
      operator delete(v36);
    }
    int64_t v37 = v66;
    if (v66)
    {
      int64_t v38 = v67;
      uint64_t v39 = v66;
      if (v67 != v66)
      {
        do
        {
          unint64_t v41 = (void *)*--v38;
          int64_t v40 = v41;
          void *v38 = 0;
          if (v41) {
            operator delete[](v40);
          }
        }
        while (v38 != v37);
        uint64_t v39 = v66;
      }
      uint64_t v67 = v37;
      operator delete(v39);
    }
    if (v62 != v65) {
      free(v62);
    }
  }
  return v15;
}

uint64_t mlir::mps::ColToImOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.col_to_im", 13, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC9837D0;
  v4[12] = mlir::mps::ColToImOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::ConcatOpGenericAdaptorBase::ConcatOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  int v5 = (void *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.concat", 10, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::ConcatOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      int v44 = 3;
      BOOL v45 = "expected DictionaryAttr to set properties";
      uint64_t v46 = 41;
      uint64_t v26 = &v44;
      uint64_t v27 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v40 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          uint64_t v27 = (char *)v48;
          uint64_t v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          uint64_t v26 = &v44;
          uint64_t v27 = (char *)v48;
        }
      }
      unint64_t v28 = &v27[24 * v49];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)unint64_t v28 = v29;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
    if (!v56) {
      return 0;
    }
    uint64_t v30 = (void **)__p;
    if (__p)
    {
      unsigned int v31 = v55;
      unint64_t v32 = __p;
      if (v55 != __p)
      {
        do
          unsigned int v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unint64_t v32 = __p;
      }
      __int16 v55 = v30;
      operator delete(v32);
    }
    long long v21 = v52;
    if (!v52) {
      goto LABEL_43;
    }
    long long v33 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v35 = (void *)*--v33;
      unint64_t v34 = v35;
      *long long v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "interleave", 0xAuLL);
  if (!v8) {
    return 1;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    int v44 = 3;
    uint64_t v46 = 55;
    unint64_t v10 = &v44;
    uint64_t v11 = (char *)v48;
    if (v49 >= v50)
    {
      unint64_t v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        int64_t v41 = (char *)&v44 - (unsigned char *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v11 = (char *)v48;
        unint64_t v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        unint64_t v10 = &v44;
        uint64_t v11 = (char *)v48;
      }
    }
    uint64_t v12 = &v11[24 * v49];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = *((void *)v10 + 2);
    *(_OWORD *)uint64_t v12 = v13;
    ++v49;
    if (v47[0])
    {
      uint64_t v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      uint64_t v15 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v42 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v15 = (char *)v48;
          uint64_t v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v14 = &v44;
          uint64_t v15 = (char *)v48;
        }
      }
      uint64_t v16 = &v15[24 * v49];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = *((void *)v14 + 2);
      *(_OWORD *)uint64_t v16 = v17;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
  }
  if (!v56) {
    return 0;
  }
  uint64_t v18 = (void **)__p;
  if (__p)
  {
    long long v19 = v55;
    uint64_t v20 = __p;
    if (v55 != __p)
    {
      do
        long long v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      uint64_t v20 = __p;
    }
    __int16 v55 = v18;
    operator delete(v20);
  }
  long long v21 = v52;
  if (v52)
  {
    uint64_t v22 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v25 = (void *)*--v22;
      long long v24 = v25;
      *uint64_t v22 = 0;
      if (v25) {
        operator delete[](v24);
      }
    }
    while (v22 != v21);
LABEL_41:
    uint64_t v23 = v52;
LABEL_42:
    uint64_t v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51) {
    free(v48);
  }
  return 0;
}

uint64_t mlir::mps::ConcatOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v15[6] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a1;
  long long v13 = v15;
  uint64_t v14 = 0x300000000;
  if (!*a2) {
    return 0;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"interleave", 10, *a2);
  uint64_t v4 = v3;
  unsigned int v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    unsigned int v5 = v14;
  }
  uint64_t v6 = (uint64_t *)((char *)v13 + 16 * v5);
  uint64_t *v6 = NamedAttr;
  v6[1] = v4;
  uint64_t v7 = v13;
  BOOL v8 = __CFADD__(v14, 1);
  uint64_t v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v13 == v15) {
      return DictionaryAttr;
    }
    goto LABEL_10;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (uint64_t *)v13, v9);
  uint64_t v7 = v13;
  if (v13 != v15) {
LABEL_10:
  }
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    *uint64_t v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 107;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        BOOL v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[17];
    return a1[32];
  }
  return result;
}

void mlir::mps::ConcatOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  void v26[2] = *MEMORY[0x1E4F143B8];
  uint64_t v21 = a5;
  mlir::OperationState::addOperands(a2, a3, a4);
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  if (a6)
  {
    uint64_t UnitAttr = mlir::Builder::getUnitAttr(a1, v9);
    *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties>((void *)a2) = UnitAttr;
  }
  __src = v26;
  uint64_t v25 = 0x200000000;
  unint64_t v11 = *a1;
  uint64_t v12 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange((unint64_t *)v23, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v15 = *(uint64_t **)(a2 + 256);
  mlir::ValueRange::ValueRange(v22, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::ConcatOp::inferReturnTypes(v11, v12, 1, v23[0], (unint64_t)v23[1], Dictionary, v15, v16, v22[0], v22[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  long long v17 = __src;
  }
  uint64_t v18 = v25;
  uint64_t v19 = *(unsigned int *)(a2 + 72);
  unint64_t v20 = v19 + v25;
  if (v20 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v20, 8);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  if (v18)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v19), v17, 8 * v18);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v19 + v18;
  if (__src != v26) {
    free(__src);
  }
}

BOOL mlir::mps::ConcatOp::verifyInvariantsImpl(uint64_t **this)
{
  __int16 v2 = *this;
  uint64_t v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  uint64_t v19 = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v3, (const void **)"interleave", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v19))return 0; {
  uint64_t v4 = *this;
  }
  if ((*((unsigned char *)*this + 46) & 0x80) == 0)
  {
    uint64_t v7 = 0;
    uint64_t v6 = 0xFFFFFFFFLL;
LABEL_5:
    uint64_t v8 = 0;
    uint64_t v9 = v7 + 24;
    while (mlir::mps::__mlir_ods_local_type_constraint_MPSOps11(*this, (const void **)(*(void *)(*(void *)v9 + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, v8))
    {
      ++v8;
      v9 += 32;
      if (v6 == v8)
      {
        uint64_t v4 = *this;
        if ((*((unsigned char *)*this + 46) & 0x80) != 0) {
          goto LABEL_11;
        }
        uint64_t v10 = 0;
        int v11 = -2;
        goto LABEL_12;
      }
    }
    return 0;
  }
  int v5 = *((_DWORD *)v4 + 17);
  uint64_t v6 = (v5 - 1);
  if (v5 != 1)
  {
    uint64_t v7 = v4[9];
    goto LABEL_5;
  }
  LODWORD(v8) = 0;
LABEL_11:
  int v12 = *((_DWORD *)v4 + 17);
  uint64_t v10 = v4[9];
  int v11 = v12 - 2;
LABEL_12:
  uint64_t v13 = (v11 + 1);
  uint64_t v14 = (v11 + 2) - v13;
  for (uint64_t i = v10 + 32 * v13 + 24;
        mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(void *)(*(void *)i + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, v8);
        i += 32)
  {
    LODWORD(v8) = v8 + 1;
    if (!--v14)
    {
      if (*((_DWORD *)*this + 9)) {
        uint64_t v16 = (uint64_t)(*this - 2);
      }
      else {
        uint64_t v16 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v16, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
    }
  }
  return 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps11(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *a2;
  int v11 = (void *)*((void *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v63[0] = a2;
    v63[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v63);
    if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isF16((mlir::Type *)&OperandRange)
      || mlir::Type::isF32((mlir::Type *)&OperandRange)
      || mlir::Type::isBF16((mlir::Type *)&OperandRange)
      || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
    {
      return 1;
    }
    uint64_t v10 = *a2;
    int v11 = (void *)*((void *)*a2 + 17);
  }
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    uint64_t v54 = a2;
    uint64_t v55 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t v14 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v54);
    if (*(_UNKNOWN **)(*(void *)v14 + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      uint64_t v42 = v14;
      uint64_t v59 = v14;
      uint64_t OperandRange = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v59);
      if (mlir::Type::isF16((mlir::Type *)&OperandRange)) {
        return 1;
      }
      uint64_t v57 = v42;
      uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v57);
      if (mlir::Type::isF32((mlir::Type *)&Value)) {
        return 1;
      }
    }
  }
  __int16 v56 = 261;
  uint64_t v54 = a3;
  uint64_t v55 = a4;
  mlir::Operation::emitOpError(a1, &v54, (uint64_t)v63);
  if (v63[0])
  {
    LODWORD(OperandRange) = 3;
    unsigned int v61 = " #";
    uint64_t v62 = 2;
    p_uint64_t OperandRange = &OperandRange;
    uint64_t v16 = (char *)v64;
    if (v65 >= v66)
    {
      unint64_t v44 = v65 + 1;
      if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
      {
        int64_t v50 = (char *)&OperandRange - (unsigned char *)v64;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v44, 24);
        uint64_t v16 = (char *)v64;
        p_uint64_t OperandRange = (uint64_t *)((char *)v64 + v50);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v44, 24);
        p_uint64_t OperandRange = &OperandRange;
        uint64_t v16 = (char *)v64;
      }
    }
    long long v17 = &v16[24 * v65];
    long long v18 = *(_OWORD *)p_OperandRange;
    *((void *)v17 + 2) = p_OperandRange[2];
    *(_OWORD *)long long v17 = v18;
    uint64_t v19 = ++v65;
    if (v63[0])
    {
      LODWORD(OperandRange) = 5;
      unsigned int v61 = (const char *)a5;
      unint64_t v20 = &OperandRange;
      uint64_t v21 = (char *)v64;
      if (v19 >= v66)
      {
        unint64_t v45 = v19 + 1;
        BOOL v46 = (char *)v64 + 24 * v19 > (char *)&OperandRange;
        if (v64 <= &OperandRange && v46)
        {
          int64_t v51 = (char *)&OperandRange - (unsigned char *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
          uint64_t v21 = (char *)v64;
          unint64_t v20 = (uint64_t *)((char *)v64 + v51);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
          unint64_t v20 = &OperandRange;
          uint64_t v21 = (char *)v64;
        }
      }
      uint64_t v22 = &v21[24 * v65];
      long long v23 = *(_OWORD *)v20;
      *((void *)v22 + 2) = v20[2];
      *(_OWORD *)uint64_t v22 = v23;
      uint64_t v24 = ++v65;
      if (v63[0])
      {
        LODWORD(OperandRange) = 3;
        unsigned int v61 = " must be variadic of tensor of mps native type values or tensor of complex values, but got ";
        uint64_t v62 = 91;
        uint64_t v25 = &OperandRange;
        uint64_t v26 = (char *)v64;
        if (v24 >= v66)
        {
          unint64_t v47 = v24 + 1;
          BOOL v48 = (char *)v64 + 24 * v24 > (char *)&OperandRange;
          if (v64 <= &OperandRange && v48)
          {
            int64_t v52 = (char *)&OperandRange - (unsigned char *)v64;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
            uint64_t v26 = (char *)v64;
            uint64_t v25 = (uint64_t *)((char *)v64 + v52);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
            uint64_t v25 = &OperandRange;
            uint64_t v26 = (char *)v64;
          }
        }
        uint64_t v27 = &v26[24 * v65];
        long long v28 = *(_OWORD *)v25;
        *((void *)v27 + 2) = v25[2];
        *(_OWORD *)uint64_t v27 = v28;
        ++v65;
        if (v63[0])
        {
          long long v29 = &OperandRange;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&OperandRange, (uint64_t)a2);
          uint64_t v30 = (char *)v64;
          if (v65 >= v66)
          {
            unint64_t v49 = v65 + 1;
            if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
            {
              int64_t v53 = (char *)&OperandRange - (unsigned char *)v64;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
              uint64_t v30 = (char *)v64;
              long long v29 = (uint64_t *)((char *)v64 + v53);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
              long long v29 = &OperandRange;
              uint64_t v30 = (char *)v64;
            }
          }
          unsigned int v31 = &v30[24 * v65];
          long long v32 = *(_OWORD *)v29;
          *((void *)v31 + 2) = v29[2];
          *(_OWORD *)unsigned int v31 = v32;
          ++v65;
        }
      }
    }
  }
  uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v63);
  if (v63[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
  }
  if (v72)
  {
    unint64_t v34 = (void **)__p;
    if (__p)
    {
      uint64_t v35 = v71;
      int64_t v36 = __p;
      if (v71 != __p)
      {
        do
          uint64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        int64_t v36 = __p;
      }
      uint64_t v71 = v34;
      operator delete(v36);
    }
    unint64_t v37 = v68;
    if (v68)
    {
      unint64_t v38 = v69;
      unint64_t v39 = v68;
      if (v69 != v68)
      {
        do
        {
          int64_t v41 = (void *)*--v38;
          int64_t v40 = v41;
          void *v38 = 0;
          if (v41) {
            operator delete[](v40);
          }
        }
        while (v38 != v37);
        unint64_t v39 = v68;
      }
      uint64_t v69 = v37;
      operator delete(v39);
    }
    if (v64 != v67) {
      free(v64);
    }
  }
  return v33;
}

uint64_t mlir::mps::ConcatOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.concat", 10, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC9D0918;
  v4[12] = mlir::mps::ConcatOp::canonicalize;
  uint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::ConjugateOpGenericAdaptorBase::ConjugateOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.conjugate", 13, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::ConjugateOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.conjugate", 13, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC97FAF8;
  v4[12] = mlir::mps::ConjugateOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

mlir::Attribute *mlir::mps::detail::ConstantOpGenericAdaptorBase::ConstantOpGenericAdaptorBase(mlir::Attribute *this, uint64_t a2, void **a3, uint64_t a4, uint64_t a5)
{
  *(void *)this = a2;
  *((unsigned char *)this + 8) = 0;
  __int16 v8 = (char *)this + 8;
  *((unsigned char *)this + 16) = 0;
  uint64_t v9 = *a3;
  *((void *)this + 3) = *a3;
  if (v9
    && ((uint64_t v10 = *(void **)(*v9 + 136),
         BOOL v11 = v10 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id,
         v10 != &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
      ? (int v12 = 0)
      : (int v12 = v9),
        unint64_t v20 = v12,
        v11))
  {
    uint64_t v15 = v9[2];
    uint64_t Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
    long long v18 = (pthread_rwlock_t **)(mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v17) + 48);
    llvm::sys::RWMutexImpl::lock(v18);
    ++*(void *)(v15 + 88);
    llvm::sys::RWMutexImpl::unlock_shared(v18);
    uint64_t v19 = *(void *)this;
    *((void *)this + 4) = a4;
    *((void *)this + 5) = a5;
    if (!v19) {
      return this;
    }
  }
  else
  {
    *((void *)this + 4) = a4;
    *((void *)this + 5) = a5;
    if (!a2) {
      return this;
    }
  }
  uint64_t v13 = mlir::Attribute::getContext(this);
  if (*((unsigned char *)this + 16)) {
    *((unsigned char *)this + 16) = 0;
  }
  mlir::OperationName::OperationName(v8, "mps.constant", 12, v13);
  *((unsigned char *)this + 16) = 1;
  return this;
}

mlir::Attribute *mlir::mps::detail::ConstantOpGenericAdaptorBase::ConstantOpGenericAdaptorBase(mlir::Attribute *a1, uint64_t a2)
{
  void v10[2] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  uint64_t v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  if (BYTE3(v4)) {
    __int16 v8 = (void **)v5;
  }
  else {
    __int16 v8 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  mlir::mps::detail::ConstantOpGenericAdaptorBase::ConstantOpGenericAdaptorBase(a1, v3, v8, v10[0], v10[1]);
  return a1;
}

uint64_t mlir::mps::ConstantOp::setPropertiesFromAttr(void *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v44 = v6;
  if (!v6)
  {
    a3(v48, a4);
    if (v48[0])
    {
      int v45 = 3;
      BOOL v46 = "expected DictionaryAttr to set properties";
      uint64_t v47 = 41;
      long long v18 = &v45;
      uint64_t v19 = (char *)v49;
      if (v50 >= v51)
      {
        unint64_t v40 = v50 + 1;
        if (v49 <= &v45 && (char *)v49 + 24 * v50 > (char *)&v45)
        {
          int64_t v42 = (char *)&v45 - (unsigned char *)v49;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v40, 24);
          uint64_t v19 = (char *)v49;
          long long v18 = (int *)((char *)v49 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v40, 24);
          long long v18 = &v45;
          uint64_t v19 = (char *)v49;
        }
      }
      unint64_t v20 = &v19[24 * v50];
      long long v21 = *(_OWORD *)v18;
      *((void *)v20 + 2) = *((void *)v18 + 2);
      *(_OWORD *)unint64_t v20 = v21;
      ++v50;
      if (v48[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
      }
    }
    if (!v57) {
      return 0;
    }
    uint64_t v22 = (void **)__p;
    if (__p)
    {
      long long v23 = v56;
      uint64_t v24 = __p;
      if (v56 != __p)
      {
        do
          long long v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
        while (v23 != v22);
        uint64_t v24 = __p;
      }
      __int16 v56 = v22;
      operator delete(v24);
    }
    uint64_t v25 = v53;
    if (!v53) {
      goto LABEL_47;
    }
    uint64_t v26 = v54;
    uint64_t v27 = v53;
    if (v54 == v53) {
      goto LABEL_46;
    }
    do
    {
      long long v29 = (void *)*--v26;
      long long v28 = v29;
      *uint64_t v26 = 0;
      if (v29) {
        operator delete[](v28);
      }
    }
    while (v26 != v25);
    goto LABEL_45;
  }
  __int16 v8 = (void *)mlir::DictionaryAttr::get((uint64_t)&v44, "value", 5uLL);
  if (!v8)
  {
    a3(v48, a4);
    if (v48[0])
    {
      int v45 = 3;
      BOOL v46 = "expected key entry for value in DictionaryAttr to set Properties.";
      uint64_t v47 = 65;
      uint64_t v30 = &v45;
      unsigned int v31 = (char *)v49;
      if (v50 >= v51)
      {
        unint64_t v41 = v50 + 1;
        if (v49 <= &v45 && (char *)v49 + 24 * v50 > (char *)&v45)
        {
          int64_t v43 = (char *)&v45 - (unsigned char *)v49;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v41, 24);
          unsigned int v31 = (char *)v49;
          uint64_t v30 = (int *)((char *)v49 + v43);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v41, 24);
          uint64_t v30 = &v45;
          unsigned int v31 = (char *)v49;
        }
      }
      long long v32 = &v31[24 * v50];
      long long v33 = *(_OWORD *)v30;
      *((void *)v32 + 2) = *((void *)v30 + 2);
      *(_OWORD *)long long v32 = v33;
      ++v50;
      if (v48[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
      }
    }
    if (!v57) {
      return 0;
    }
    unint64_t v34 = (void **)__p;
    if (__p)
    {
      uint64_t v35 = v56;
      int64_t v36 = __p;
      if (v56 != __p)
      {
        do
          uint64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        int64_t v36 = __p;
      }
      __int16 v56 = v34;
      operator delete(v36);
    }
    uint64_t v25 = v53;
    if (!v53)
    {
LABEL_47:
      if (v49 != v52) {
        free(v49);
      }
      return 0;
    }
    unint64_t v37 = v54;
    uint64_t v27 = v53;
    if (v54 == v53)
    {
LABEL_46:
      uint64_t v54 = v25;
      operator delete(v27);
      goto LABEL_47;
    }
    do
    {
      unint64_t v39 = (void *)*--v37;
      unint64_t v38 = v39;
      *unint64_t v37 = 0;
      if (v39) {
        operator delete[](v38);
      }
    }
    while (v37 != v25);
LABEL_45:
    uint64_t v27 = v53;
    goto LABEL_46;
  }
  uint64_t v9 = v8;
  uint64_t v10 = *(void **)(*v8 + 136);
  BOOL v11 = v10 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id;
  if (v10 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id) {
    int v12 = v8;
  }
  else {
    int v12 = 0;
  }
  v48[0] = v12;
  if (v11)
  {
    uint64_t v13 = v8[2];
    uint64_t Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)v48);
    uint64_t v16 = (pthread_rwlock_t **)(mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v15) + 48);
    llvm::sys::RWMutexImpl::lock(v16);
    ++*(void *)(v13 + 88);
    llvm::sys::RWMutexImpl::unlock_shared(v16);
  }
  *a1 = v9;
  return 1;
}

uint64_t mlir::mps::ConstantOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, mlir::MLIRContext *a2)
{
  v16[6] = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a1;
  uint64_t v14 = v16;
  uint64_t v15 = 0x300000000;
  uint64_t v2 = *(void *)a2;
  if (!*(void *)a2) {
    uint64_t v2 = mlir::UnitAttr::get(a1, a2);
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v13, (uint64_t)"value", 5, v2);
  uint64_t v5 = v4;
  unsigned int v6 = v15;
  if (v15 >= HIDWORD(v15))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v14, v16, v15 + 1, 16);
    unsigned int v6 = v15;
  }
  uint64_t v7 = (uint64_t *)((char *)v14 + 16 * v6);
  uint64_t *v7 = NamedAttr;
  v7[1] = v5;
  BOOL v8 = __CFADD__(v15, 1);
  uint64_t v9 = (v15 + 1);
  LODWORD(v15) = v15 + 1;
  if (v8)
  {
    uint64_t DictionaryAttr = 0;
    BOOL v11 = v14;
    if (v14 == v16) {
      return DictionaryAttr;
    }
    goto LABEL_10;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v13, (uint64_t *)v14, v9);
  BOOL v11 = v14;
  if (v14 != v16) {
LABEL_10:
  }
    free(v11);
  return DictionaryAttr;
}

unint64_t mlir::mps::ConstantOp::computePropertiesHash(unint64_t *a1)
{
  unint64_t v1 = *a1;
  if (*(_UNKNOWN **)(*(void *)*a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
  {
    unint64_t v24 = llvm::hash_value(**(void ***)(v1 + 16), *(void *)(*(void *)(v1 + 16) + 8));
    unint64_t v5 = *(void *)(v1 + 40);
    {
      unint64_t v21 = v5;
      unint64_t v5 = v21;
      if (v18)
      {
        unint64_t v19 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override) {
          unint64_t v19 = 0xFF51AFD7ED558CCDLL;
        }
        llvm::hashing::detail::get_execution_seed(void)::seed = v19;
        unint64_t v5 = v21;
      }
    }
    unint64_t v6 = HIDWORD(v5);
    unint64_t v7 = 0x9DDFEA08EB382D69
       * ((llvm::hashing::detail::get_execution_seed(void)::seed + 8 * v5) ^ HIDWORD(v5));
    unint64_t v23 = 0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) >> 47));
    unint64_t v8 = *(void *)(v1 + 8);
    {
      unint64_t v20 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v20 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v20;
    }
    unint64_t v9 = 0x9DDFEA08EB382D69
       * ((llvm::hashing::detail::get_execution_seed(void)::seed + 8 * v8) ^ HIDWORD(v8));
    unint64_t v10 = 0x9DDFEA08EB382D69 * (HIDWORD(v8) ^ (v9 >> 47) ^ v9);
    unint64_t v22 = 0x9DDFEA08EB382D69 * (v10 ^ (v10 >> 47));
    unint64_t v4 = llvm::hash_combine<llvm::hash_code,llvm::hash_code,llvm::hash_code>(&v24, (uint64_t *)&v23, (uint64_t *)&v22);
  }
  else
  {
    {
      unint64_t v17 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v17 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v17;
    }
    unint64_t v2 = 0x9DDFEA08EB382D69
       * ((llvm::hashing::detail::get_execution_seed(void)::seed + 8 * v1) ^ HIDWORD(v1));
    unint64_t v3 = 0x9DDFEA08EB382D69 * (HIDWORD(v1) ^ (v2 >> 47) ^ v2);
    unint64_t v4 = 0x9DDFEA08EB382D69 * (v3 ^ (v3 >> 47));
    {
LABEL_9:
      unint64_t v14 = v4;
      unint64_t v4 = v14;
      if (v15)
      {
        unint64_t v16 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override) {
          unint64_t v16 = 0xFF51AFD7ED558CCDLL;
        }
        llvm::hashing::detail::get_execution_seed(void)::seed = v16;
        unint64_t v4 = v14;
      }
    }
  }
  uint64_t v11 = llvm::hashing::detail::get_execution_seed(void)::seed ^ HIDWORD(v4);
  unint64_t v12 = 0x9DDFEA08EB382D69 * (v11 ^ (8 * v4 + 8));
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v11 ^ (v12 >> 47) ^ v12)) ^ ((0x9DDFEA08EB382D69 * (v11 ^ (v12 >> 47) ^ v12)) >> 47));
}

uint64_t mlir::mps::ConstantOp::readProperties(uint64_t a1, void *a2)
{
  unint64_t v3 = (void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties>(a2);
  uint64_t v13 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, void **))(*(void *)a1 + 48))(a1, &v13)) {
    return 0;
  }
  unint64_t v4 = v13;
  if (v13)
  {
    unint64_t v5 = *(void **)(*v13 + 136);
    BOOL v6 = v5 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id;
    if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id) {
      unint64_t v7 = v13;
    }
    else {
      unint64_t v7 = 0;
    }
    unint64_t v14 = v7;
    if (v6)
    {
      uint64_t v8 = v13[2];
      uint64_t Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
      uint64_t v11 = (pthread_rwlock_t **)(mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v10) + 48);
      llvm::sys::RWMutexImpl::lock(v11);
      ++*(void *)(v8 + 88);
      llvm::sys::RWMutexImpl::unlock_shared(v11);
    }
  }
  *unint64_t v3 = v4;
  return 1;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    unint64_t v3 = operator new(8uLL);
    *unint64_t v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 109;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[19];
    return a1[32];
  }
  return result;
}

void mlir::mps::ConstantOp::build(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  v16[0] = a3;
  v16[1] = a4;
  if (a3)
  {
    unint64_t v6 = *(void **)(*a3 + 136);
    BOOL v7 = v6 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id;
    uint64_t v8 = v6 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id ? a3 : 0;
    unint64_t v17 = v8;
    if (v7)
    {
      uint64_t v9 = a3[2];
      uint64_t Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v17);
      uint64_t v12 = (pthread_rwlock_t **)(mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v11) + 48);
      llvm::sys::RWMutexImpl::lock(v12);
      ++*(void *)(v9 + 88);
      llvm::sys::RWMutexImpl::unlock_shared(v12);
    }
  }
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::ConstantProperty>((void *)a2) = a3;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v16);
  unint64_t v14 = Type;
  if (Type) {
    mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  }
  uint64_t v15 = *(unsigned int *)(a2 + 72);
  if (v15 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v15 + 1, 8);
    LODWORD(v15) = *(_DWORD *)(a2 + 72);
  }
  *(void *)(*(void *)(a2 + 64) + 8 * v15) = v14;
  ++*(_DWORD *)(a2 + 72);
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::ConstantProperty>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    unint64_t v3 = operator new(8uLL);
    *unint64_t v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::ConstantProperty & mlir::OperationState::getOrAddProperties<mlir::mps::ConstantProperty>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::ConstantProperty & mlir::OperationState::getOrAddProperties<mlir::mps::ConstantProperty>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    unint64_t v4 = 0x1E8EB8000uLL;
    {
      unint64_t v4 = 0x1E8EB8000;
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::ConstantProperty]";
        unint64_t v14 = 77;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::ConstantProperty,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        unint64_t v4 = 0x1E8EB8000;
      }
    }
    a1[33] = *(void *)(v4 + 1952);
    return a1[32];
  }
  return result;
}

void mlir::mps::ConstantOp::build(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a4)
  {
    unint64_t v7 = *(void **)(*a4 + 136);
    BOOL v8 = v7 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id;
    unint64_t v9 = v7 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id ? a4 : 0;
    uint64_t v15 = v9;
    if (v8)
    {
      uint64_t v11 = a4[2];
      uint64_t Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v15);
      unint64_t v14 = (pthread_rwlock_t **)(mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v13) + 48);
      llvm::sys::RWMutexImpl::lock(v14);
      ++*(void *)(v11 + 88);
      llvm::sys::RWMutexImpl::unlock_shared(v14);
      *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::ConstantProperty>((void *)a2) = a4;
      uint64_t v10 = *(unsigned int *)(a2 + 72);
      if (v10 < *(_DWORD *)(a2 + 76)) {
        goto LABEL_8;
      }
      goto LABEL_7;
    }
  }
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::ConstantProperty>((void *)a2) = a4;
  uint64_t v10 = *(unsigned int *)(a2 + 72);
  if (v10 >= *(_DWORD *)(a2 + 76))
  {
LABEL_7:
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v10 + 1, 8);
    LODWORD(v10) = *(_DWORD *)(a2 + 72);
  }
LABEL_8:
  *(void *)(*(void *)(a2 + 64) + 8 * v10) = a3;
  ++*(_DWORD *)(a2 + 72);
}

void mlir::mps::ConstantOp::build(mlir::mps::ConstantOp *this, mlir::OpBuilder *a2, mlir::OperationState *a3)
{
  int v11 = (int)a3;
  uint64_t IntegerType = mlir::Builder::getIntegerType(this, 0x20u, 1);
  int v5 = (void *)mlir::RankedTensorType::get(0, 0, IntegerType, 0);
  unint64_t v6 = v5;
  if (v5) {
    uint64_t v7 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  }
  else {
    uint64_t v7 = 0;
  }
  BOOL v8 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v6, v7, &v11, 4, 4, 1, 1);
  unint64_t v9 = v8;
  if (v8)
  {
    BOOL v8 = (void *)mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v8 + 8);
    uint64_t v10 = (uint64_t)v8;
  }
  else
  {
    uint64_t v10 = 0;
  }
  mlir::mps::ConstantOp::build((uint64_t)v8, (uint64_t)a2, v9, v10);
}

void mlir::mps::ConstantOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v14[1] = *MEMORY[0x1E4F143B8];
  v14[0] = a4;
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x20u, 1);
  BOOL v8 = (void *)mlir::RankedTensorType::get((uint64_t)v14, 1, IntegerType, 0);
  unint64_t v9 = v8;
  if (v8) {
    uint64_t v10 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v8 + 8);
  }
  else {
    uint64_t v10 = 0;
  }
  int v11 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v9, v10, a3, 4 * a4, 4, 1, 1);
  uint64_t v12 = v11;
  if (v11)
  {
    int v11 = (void *)mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v11 + 8);
    uint64_t v13 = (uint64_t)v11;
  }
  else
  {
    uint64_t v13 = 0;
  }
  mlir::mps::ConstantOp::build((uint64_t)v11, a2, v12, v13);
}

{
  uint64_t IntegerType;
  void *v8;
  void *v9;
  uint64_t v10;
  void *v11;
  void *v12;
  uint64_t v13;
  void v14[2];

  v14[1] = *MEMORY[0x1E4F143B8];
  v14[0] = a4;
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 1);
  BOOL v8 = (void *)mlir::RankedTensorType::get((uint64_t)v14, 1, IntegerType, 0);
  unint64_t v9 = v8;
  if (v8) {
    uint64_t v10 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v8 + 8);
  }
  else {
    uint64_t v10 = 0;
  }
  int v11 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v9, v10, a3, 8 * a4, 8, 1, 1);
  uint64_t v12 = v11;
  if (v11)
  {
    int v11 = (void *)mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v11 + 8);
    uint64_t v13 = (uint64_t)v11;
  }
  else
  {
    uint64_t v13 = 0;
  }
  mlir::mps::ConstantOp::build((uint64_t)v11, a2, v12, v13);
}

void mlir::mps::ConstantOp::build(mlir::Float32Type **this, mlir::OpBuilder *a2, mlir::OperationState *a3, float a4)
{
  float v12 = a4;
  uint64_t F32Type = mlir::Builder::getF32Type(this, a2);
  unint64_t v6 = (void *)mlir::RankedTensorType::get(0, 0, F32Type, 0);
  uint64_t v7 = v6;
  if (v6) {
    uint64_t v8 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v6 + 8);
  }
  else {
    uint64_t v8 = 0;
  }
  unint64_t v9 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v7, v8, &v12, 4, 4, 0, 1);
  uint64_t v10 = v9;
  if (v9)
  {
    unint64_t v9 = (void *)mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v9 + 8);
    uint64_t v11 = (uint64_t)v9;
  }
  else
  {
    uint64_t v11 = 0;
  }
  mlir::mps::ConstantOp::build((uint64_t)v9, (uint64_t)a2, v10, v11);
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps12(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *a2;
  uint64_t v11 = (void *)*((void *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v63[0] = a2;
    v63[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v63);
    if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)) {
      return 1;
    }
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)) {
      return 1;
    }
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)) {
      return 1;
    }
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)) {
      return 1;
    }
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)) {
      return 1;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)) {
      return 1;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)) {
      return 1;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
    if (mlir::Type::isF16((mlir::Type *)&OperandRange)) {
      return 1;
    }
    if (mlir::Type::isF32((mlir::Type *)&OperandRange)) {
      return 1;
    }
    if (mlir::Type::isBF16((mlir::Type *)&OperandRange)) {
      return 1;
    }
    uint64_t v13 = *(void **)(*(void *)OperandRange + 136);
    if (v13 == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id) {
      return 1;
    }
    if (v13 == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      uint64_t v58 = OperandRange;
      uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v58);
      if (mlir::Type::isF16((mlir::Type *)&Value)) {
        return 1;
      }
      uint64_t v56 = OperandRange;
      uint64_t v57 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v56);
      if (mlir::Type::isF32((mlir::Type *)&v57)) {
        return 1;
      }
    }
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 2)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 4)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 1)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 2)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 4)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::mps::NF4Type,void>::id)
    {
      return 1;
    }
    uint64_t v10 = *a2;
    uint64_t v11 = (void *)*((void *)*a2 + 17);
  }
  if (v11 == &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
  {
    int64_t v53 = a2;
    uint64_t v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v53);
    if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)) {
      return 1;
    }
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)) {
      return 1;
    }
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)) {
      return 1;
    }
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)) {
      return 1;
    }
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)) {
      return 1;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)) {
      return 1;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)) {
      return 1;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
    if (mlir::Type::isF16((mlir::Type *)&OperandRange)) {
      return 1;
    }
    if (mlir::Type::isF32((mlir::Type *)&OperandRange)) {
      return 1;
    }
    if (mlir::Type::isBF16((mlir::Type *)&OperandRange)) {
      return 1;
    }
    unint64_t v41 = *(void **)(*(void *)OperandRange + 136);
    if (v41 == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id) {
      return 1;
    }
    if (v41 == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      uint64_t v58 = OperandRange;
      uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v58);
      if (mlir::Type::isF16((mlir::Type *)&Value)) {
        return 1;
      }
      uint64_t v56 = OperandRange;
      uint64_t v57 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v56);
      if (mlir::Type::isF32((mlir::Type *)&v57)) {
        return 1;
      }
    }
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 2)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 4)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 1)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 2)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 4)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::mps::NF4Type,void>::id)
    {
      return 1;
    }
  }
  __int16 v55 = 261;
  int64_t v53 = a3;
  uint64_t v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v63);
  if (v63[0])
  {
    LODWORD(OperandRange) = 3;
    unsigned int v61 = " #";
    uint64_t v62 = 2;
    p_uint64_t OperandRange = &OperandRange;
    uint64_t v15 = (char *)v64;
    if (v65 >= v66)
    {
      unint64_t v42 = v65 + 1;
      if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
      {
        int64_t v49 = (char *)&OperandRange - (unsigned char *)v64;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v42, 24);
        uint64_t v15 = (char *)v64;
        p_uint64_t OperandRange = (uint64_t *)((char *)v64 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v42, 24);
        p_uint64_t OperandRange = &OperandRange;
        uint64_t v15 = (char *)v64;
      }
    }
    unint64_t v16 = &v15[24 * v65];
    long long v17 = *(_OWORD *)p_OperandRange;
    *((void *)v16 + 2) = p_OperandRange[2];
    *(_OWORD *)unint64_t v16 = v17;
    uint64_t v18 = ++v65;
    if (v63[0])
    {
      LODWORD(OperandRange) = 5;
      unsigned int v61 = (const char *)a5;
      unint64_t v19 = &OperandRange;
      unint64_t v20 = (char *)v64;
      if (v18 >= v66)
      {
        unint64_t v43 = v18 + 1;
        BOOL v44 = (char *)v64 + 24 * v18 > (char *)&OperandRange;
        if (v64 <= &OperandRange && v44)
        {
          int64_t v50 = (char *)&OperandRange - (unsigned char *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v43, 24);
          unint64_t v20 = (char *)v64;
          unint64_t v19 = (uint64_t *)((char *)v64 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v43, 24);
          unint64_t v19 = &OperandRange;
          unint64_t v20 = (char *)v64;
        }
      }
      unint64_t v21 = &v20[24 * v65];
      long long v22 = *(_OWORD *)v19;
      *((void *)v21 + 2) = v19[2];
      *(_OWORD *)unint64_t v21 = v22;
      uint64_t v23 = ++v65;
      if (v63[0])
      {
        LODWORD(OperandRange) = 3;
        unsigned int v61 = " must be tensor of mps native type or complex or quantized values or memref of mps native type or complex "
              "or quantized values, but got ";
        uint64_t v62 = 135;
        unint64_t v24 = &OperandRange;
        uint64_t v25 = (char *)v64;
        if (v23 >= v66)
        {
          unint64_t v45 = v23 + 1;
          BOOL v46 = (char *)v64 + 24 * v23 > (char *)&OperandRange;
          if (v64 <= &OperandRange && v46)
          {
            int64_t v51 = (char *)&OperandRange - (unsigned char *)v64;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
            uint64_t v25 = (char *)v64;
            unint64_t v24 = (uint64_t *)((char *)v64 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
            unint64_t v24 = &OperandRange;
            uint64_t v25 = (char *)v64;
          }
        }
        uint64_t v26 = &v25[24 * v65];
        long long v27 = *(_OWORD *)v24;
        *((void *)v26 + 2) = v24[2];
        *(_OWORD *)uint64_t v26 = v27;
        ++v65;
        if (v63[0])
        {
          long long v28 = &OperandRange;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&OperandRange, (uint64_t)a2);
          long long v29 = (char *)v64;
          if (v65 >= v66)
          {
            unint64_t v47 = v65 + 1;
            if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
            {
              int64_t v52 = (char *)&OperandRange - (unsigned char *)v64;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
              long long v29 = (char *)v64;
              long long v28 = (uint64_t *)((char *)v64 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
              long long v28 = &OperandRange;
              long long v29 = (char *)v64;
            }
          }
          uint64_t v30 = &v29[24 * v65];
          long long v31 = *(_OWORD *)v28;
          *((void *)v30 + 2) = v28[2];
          *(_OWORD *)uint64_t v30 = v31;
          ++v65;
        }
      }
    }
  }
  uint64_t v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v63);
  if (v63[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
  }
  if (v72)
  {
    long long v33 = (void **)__p;
    if (__p)
    {
      unint64_t v34 = v71;
      uint64_t v35 = __p;
      if (v71 != __p)
      {
        do
          unint64_t v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
        while (v34 != v33);
        uint64_t v35 = __p;
      }
      uint64_t v71 = v33;
      operator delete(v35);
    }
    int64_t v36 = v68;
    if (v68)
    {
      unint64_t v37 = v69;
      unint64_t v38 = v68;
      if (v69 != v68)
      {
        do
        {
          unint64_t v40 = (void *)*--v37;
          unint64_t v39 = v40;
          *unint64_t v37 = 0;
          if (v40) {
            operator delete[](v39);
          }
        }
        while (v37 != v36);
        unint64_t v38 = v68;
      }
      uint64_t v69 = v36;
      operator delete(v38);
    }
    if (v64 != v67) {
      free(v64);
    }
  }
  return v32;
}

uint64_t mlir::mps::ConstantOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  unint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.constant", 12, v2, v3, 0, 0);
  *unint64_t v4 = &unk_1EC97F578;
  v4[12] = mlir::mps::ConstantOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Conv2DDataGradientOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v13, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *(_OWORD *)v5;
  long long v9 = *(_OWORD *)(v5 + 16);
  long long v10 = *(_OWORD *)(v5 + 32);
  *(void *)(a1 + 72) = *(void *)(v5 + 48);
  *(_OWORD *)(a1 + 56) = v10;
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)v13;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.conv_2d_data_gradient", 25, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::Conv2DDataGradientOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v123 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v109 = v6;
  if (!v6)
  {
    a3(v113, a4);
    if (v113[0])
    {
      LODWORD(v110) = 3;
      uint64_t v111 = "expected DictionaryAttr to set properties";
      uint64_t v112 = 41;
      uint64_t v26 = &v110;
      long long v27 = (char *)v114;
      if (v115 >= v116)
      {
        unint64_t v92 = v115 + 1;
        if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
        {
          int64_t v100 = (char *)&v110 - (unsigned char *)v114;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v92, 24);
          long long v27 = (char *)v114;
          uint64_t v26 = (uint64_t *)((char *)v114 + v100);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v92, 24);
          uint64_t v26 = &v110;
          long long v27 = (char *)v114;
        }
      }
      long long v28 = &v27[24 * v115];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)long long v28 = v29;
      ++v115;
      if (v113[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
      }
    }
    if (!v122) {
      return 0;
    }
    uint64_t v30 = (void **)__p;
    if (__p)
    {
      long long v31 = v121;
      uint64_t v32 = __p;
      if (v121 != __p)
      {
        do
          long long v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        uint64_t v32 = __p;
      }
      char v121 = v30;
      operator delete(v32);
    }
    unint64_t v21 = v118;
    if (!v118) {
      goto LABEL_117;
    }
    long long v33 = v119;
    uint64_t v23 = v118;
    if (v119 == v118)
    {
LABEL_116:
      unint64_t v119 = v21;
      operator delete(v23);
LABEL_117:
      if (v114 != v117) {
        free(v114);
      }
      return 0;
    }
    do
    {
      uint64_t v35 = (void *)*--v33;
      unint64_t v34 = v35;
      *long long v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
LABEL_115:
    uint64_t v23 = v118;
    goto LABEL_116;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v109, "data_layout", 0xBuLL);
  if (!v8)
  {
    a3(v113, a4);
    if (v113[0])
    {
      LODWORD(v110) = 3;
      uint64_t v111 = "expected key entry for data_layout in DictionaryAttr to set Properties.";
      uint64_t v112 = 71;
      int64_t v36 = &v110;
      unint64_t v37 = (char *)v114;
      if (v115 >= v116)
      {
        unint64_t v94 = v115 + 1;
        if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
        {
          int64_t v102 = (char *)&v110 - (unsigned char *)v114;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v94, 24);
          unint64_t v37 = (char *)v114;
          int64_t v36 = (uint64_t *)((char *)v114 + v102);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v94, 24);
          int64_t v36 = &v110;
          unint64_t v37 = (char *)v114;
        }
      }
      unint64_t v38 = &v37[24 * v115];
      long long v39 = *(_OWORD *)v36;
      *((void *)v38 + 2) = v36[2];
      *(_OWORD *)unint64_t v38 = v39;
      ++v115;
      if (v113[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
      }
    }
    if (!v122) {
      return 0;
    }
    unint64_t v40 = (void **)__p;
    if (__p)
    {
      unint64_t v41 = v121;
      unint64_t v42 = __p;
      if (v121 != __p)
      {
        do
          unint64_t v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        unint64_t v42 = __p;
      }
      char v121 = v40;
      operator delete(v42);
    }
    unint64_t v21 = v118;
    if (!v118) {
      goto LABEL_117;
    }
    unint64_t v43 = v119;
    uint64_t v23 = v118;
    if (v119 == v118) {
      goto LABEL_116;
    }
    do
    {
      unint64_t v45 = (void *)*--v43;
      BOOL v44 = v45;
      void *v43 = 0;
      if (v45) {
        operator delete[](v44);
      }
    }
    while (v43 != v21);
    goto LABEL_115;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    a3(v113, a4);
    if (v113[0])
    {
      LODWORD(v110) = 3;
      uint64_t v112 = 56;
      long long v10 = &v110;
      uint64_t v11 = (char *)v114;
      if (v115 >= v116)
      {
        unint64_t v93 = v115 + 1;
        if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
        {
          int64_t v101 = (char *)&v110 - (unsigned char *)v114;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v93, 24);
          uint64_t v11 = (char *)v114;
          long long v10 = (uint64_t *)((char *)v114 + v101);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v93, 24);
          long long v10 = &v110;
          uint64_t v11 = (char *)v114;
        }
      }
      float v12 = &v11[24 * v115];
      long long v13 = *(_OWORD *)v10;
      *((void *)v12 + 2) = v10[2];
      *(_OWORD *)float v12 = v13;
      ++v115;
      if (v113[0])
      {
        uint64_t v14 = &v110;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v110, v9);
        uint64_t v15 = (char *)v114;
        if (v115 >= v116)
        {
          unint64_t v95 = v115 + 1;
          if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
          {
            int64_t v103 = (char *)&v110 - (unsigned char *)v114;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v95, 24);
            uint64_t v15 = (char *)v114;
            uint64_t v14 = (uint64_t *)((char *)v114 + v103);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v95, 24);
            uint64_t v14 = &v110;
            uint64_t v15 = (char *)v114;
          }
        }
        unint64_t v16 = &v15[24 * v115];
        long long v17 = *(_OWORD *)v14;
        *((void *)v16 + 2) = v14[2];
        *(_OWORD *)unint64_t v16 = v17;
        ++v115;
        if (v113[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
        }
      }
    }
    if (!v122) {
      return 0;
    }
    uint64_t v18 = (void **)__p;
    if (__p)
    {
      unint64_t v19 = v121;
      unint64_t v20 = __p;
      if (v121 != __p)
      {
        do
          unint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        unint64_t v20 = __p;
      }
      char v121 = v18;
      operator delete(v20);
    }
    unint64_t v21 = v118;
    if (!v118) {
      goto LABEL_117;
    }
    long long v22 = v119;
    uint64_t v23 = v118;
    if (v119 == v118) {
      goto LABEL_116;
    }
    do
    {
      uint64_t v25 = (void *)*--v22;
      unint64_t v24 = v25;
      *long long v22 = 0;
      if (v25) {
        operator delete[](v24);
      }
    }
    while (v22 != v21);
    goto LABEL_115;
  }
  *a1 = v8;
  uint64_t v46 = mlir::DictionaryAttr::get((uint64_t)&v109, "dilation_rates", 0xEuLL);
  if (!v46)
  {
    a3(v113, a4);
    if (v113[0])
    {
      LODWORD(v110) = 3;
      uint64_t v111 = "expected key entry for dilation_rates in DictionaryAttr to set Properties.";
      uint64_t v112 = 74;
      int64_t v52 = &v110;
      int64_t v53 = (char *)v114;
      if (v115 >= v116)
      {
        unint64_t v96 = v115 + 1;
        if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
        {
          int64_t v104 = (char *)&v110 - (unsigned char *)v114;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v96, 24);
          int64_t v53 = (char *)v114;
          int64_t v52 = (uint64_t *)((char *)v114 + v104);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v96, 24);
          int64_t v52 = &v110;
          int64_t v53 = (char *)v114;
        }
      }
      uint64_t v54 = &v53[24 * v115];
      long long v55 = *(_OWORD *)v52;
      *((void *)v54 + 2) = v52[2];
      *(_OWORD *)uint64_t v54 = v55;
      ++v115;
      if (v113[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
      }
    }
    if (!v122) {
      return 0;
    }
    uint64_t v56 = (void **)__p;
    if (__p)
    {
      uint64_t v57 = v121;
      uint64_t v58 = __p;
      if (v121 != __p)
      {
        do
          uint64_t v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        uint64_t v58 = __p;
      }
      char v121 = v56;
      operator delete(v58);
    }
    unint64_t v21 = v118;
    if (!v118) {
      goto LABEL_117;
    }
    uint64_t v59 = v119;
    uint64_t v23 = v118;
    if (v119 == v118) {
      goto LABEL_116;
    }
    do
    {
      unsigned int v61 = (void *)*--v59;
      uint64_t v60 = v61;
      void *v59 = 0;
      if (v61) {
        operator delete[](v60);
      }
    }
    while (v59 != v21);
    goto LABEL_115;
  }
  uint64_t v47 = v46;
  if ((mlir::DenseIntElementsAttr::classof(v46) & 1) == 0)
  {
    a3(v113, a4);
    if (v113[0])
    {
      LODWORD(v110) = 3;
      uint64_t v112 = 59;
      uint64_t v62 = &v110;
      unsigned int v63 = (char *)v114;
      if (v115 >= v116)
      {
        unint64_t v97 = v115 + 1;
        if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
        {
          int64_t v105 = (char *)&v110 - (unsigned char *)v114;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v97, 24);
          unsigned int v63 = (char *)v114;
          uint64_t v62 = (uint64_t *)((char *)v114 + v105);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v97, 24);
          uint64_t v62 = &v110;
          unsigned int v63 = (char *)v114;
        }
      }
      unsigned int v64 = &v63[24 * v115];
      long long v65 = *(_OWORD *)v62;
      *((void *)v64 + 2) = v62[2];
      *(_OWORD *)unsigned int v64 = v65;
      ++v115;
      if (v113[0])
      {
        unsigned int v66 = &v110;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v110, v47);
        uint64_t v67 = (char *)v114;
        if (v115 >= v116)
        {
          unint64_t v98 = v115 + 1;
          if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
          {
            int64_t v106 = (char *)&v110 - (unsigned char *)v114;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v98, 24);
            uint64_t v67 = (char *)v114;
            unsigned int v66 = (uint64_t *)((char *)v114 + v106);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v98, 24);
            unsigned int v66 = &v110;
            uint64_t v67 = (char *)v114;
          }
        }
        long long v68 = &v67[24 * v115];
        long long v69 = *(_OWORD *)v66;
        *((void *)v68 + 2) = v66[2];
        *(_OWORD *)long long v68 = v69;
        ++v115;
        if (v113[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
        }
      }
    }
    if (!v122) {
      return 0;
    }
    char v70 = (void **)__p;
    if (__p)
    {
      uint64_t v71 = v121;
      char v72 = __p;
      if (v121 != __p)
      {
        do
          uint64_t v71 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v71 - 1);
        while (v71 != v70);
        char v72 = __p;
      }
      char v121 = v70;
      operator delete(v72);
    }
    unint64_t v21 = v118;
    if (!v118) {
      goto LABEL_117;
    }
    uint64_t v73 = v119;
    uint64_t v23 = v118;
    if (v119 == v118) {
      goto LABEL_116;
    }
    do
    {
      unint64_t v75 = (void *)*--v73;
      unint64_t v74 = v75;
      *uint64_t v73 = 0;
      if (v75) {
        operator delete[](v74);
      }
    }
    while (v73 != v21);
    goto LABEL_115;
  }
  a1[1] = v47;
  uint64_t v48 = mlir::DictionaryAttr::get((uint64_t)&v109, "explicit_padding", 0x10uLL);
  uint64_t v108 = v48;
  if (!v48)
  {
    a3(v113, a4);
    if (v113[0])
    {
      LODWORD(v110) = 3;
      uint64_t v111 = "expected key entry for explicit_padding in DictionaryAttr to set Properties.";
      uint64_t v112 = 76;
      unint64_t v76 = &v110;
      unint64_t v77 = (char *)v114;
      if (v115 >= v116)
      {
        unint64_t v99 = v115 + 1;
        if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
        {
          int64_t v107 = (char *)&v110 - (unsigned char *)v114;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v99, 24);
          unint64_t v77 = (char *)v114;
          unint64_t v76 = (uint64_t *)((char *)v114 + v107);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v99, 24);
          unint64_t v76 = &v110;
          unint64_t v77 = (char *)v114;
        }
      }
      unint64_t v78 = &v77[24 * v115];
      long long v79 = *(_OWORD *)v76;
      *((void *)v78 + 2) = v76[2];
      *(_OWORD *)unint64_t v78 = v79;
      ++v115;
      if (v113[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
      }
    }
    if (!v122) {
      return 0;
    }
    int64_t v80 = (void **)__p;
    if (__p)
    {
      int64_t v81 = v121;
      long long v82 = __p;
      if (v121 != __p)
      {
        do
          int64_t v81 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v81 - 1);
        while (v81 != v80);
        long long v82 = __p;
      }
      char v121 = v80;
      operator delete(v82);
    }
    unint64_t v21 = v118;
    if (!v118) {
      goto LABEL_117;
    }
    int64_t v83 = v119;
    uint64_t v23 = v118;
    if (v119 == v118) {
      goto LABEL_116;
    }
    do
    {
      int64_t v85 = (void *)*--v83;
      int64_t v84 = v85;
      *int64_t v83 = 0;
      if (v85) {
        operator delete[](v84);
      }
    }
    while (v83 != v21);
    goto LABEL_115;
  }
  uint64_t v49 = v48;
  if (mlir::DenseIntElementsAttr::classof(v48))
  {
    a1[2] = v49;
    uint64_t v50 = mlir::DictionaryAttr::get((uint64_t)&v109, "groups", 6uLL);
    uint64_t v110 = v50;
    if (v50)
    {
      if (*(_UNKNOWN **)(*(void *)v50 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        a1[3] = v50;
        uint64_t v88 = mlir::DictionaryAttr::get((uint64_t)&v109, "padding_style", 0xDuLL);
        uint64_t v110 = v88;
        if (!v88)
        {
          a3(v113, a4);
          mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v113, "expected key entry for padding_style in DictionaryAttr to set Properties.");
          goto LABEL_123;
        }
        if (*(_UNKNOWN **)(*(void *)v88 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
        {
          a1[4] = v88;
          uint64_t v89 = mlir::DictionaryAttr::get((uint64_t)&v109, "strides", 7uLL);
          uint64_t v110 = v89;
          if (!v89)
          {
            a3(v113, a4);
            mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v113, "expected key entry for strides in DictionaryAttr to set Properties.");
            goto LABEL_123;
          }
          uint64_t v90 = v89;
          if (mlir::DenseIntElementsAttr::classof(v89))
          {
            a1[5] = v90;
            uint64_t v91 = mlir::DictionaryAttr::get((uint64_t)&v109, "weights_layout", 0xEuLL);
            uint64_t v110 = v91;
            if (!v91)
            {
              a3(v113, a4);
              mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v113, "expected key entry for weights_layout in DictionaryAttr to set Properties.");
              goto LABEL_123;
            }
            if (*(_UNKNOWN **)(*(void *)v91 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
            {
              a1[6] = v91;
              return 1;
            }
            a3(v113, a4);
          }
          else
          {
            a3(v113, a4);
          }
        }
        else
        {
          a3(v113, a4);
        }
      }
      else
      {
        a3(v113, a4);
      }
      mlir::InFlightDiagnostic::append<mlir::Attribute>(v51, &v110);
    }
    else
    {
      a3(v113, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v113, "expected key entry for groups in DictionaryAttr to set Properties.");
    }
LABEL_123:
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v113);
    return 0;
  }
  a3(v113, a4);
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v87, &v108);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v113);
  return 0;
}

uint64_t mlir::mps::Conv2DDataGradientOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v51[6] = *MEMORY[0x1E4F143B8];
  uint64_t v48 = a1;
  uint64_t v49 = v51;
  uint64_t v50 = 0x300000000;
  if (!*a2)
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v48, (uint64_t)"data_layout", 11, *a2);
  uint64_t v5 = v4;
  unsigned int v6 = v50;
  if (v50 >= HIDWORD(v50))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
    unsigned int v6 = v50;
  }
  uint64_t v7 = (uint64_t *)((char *)v49 + 16 * v6);
  uint64_t *v7 = NamedAttr;
  v7[1] = v5;
  unsigned int v8 = v50 + 1;
  LODWORD(v50) = v50 + 1;
  uint64_t v9 = a2[1];
  if (v9)
  {
LABEL_7:
    uint64_t v10 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"dilation_rates", 14, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v13 = v50;
    }
    uint64_t v14 = (uint64_t *)((char *)v49 + 16 * v13);
    *uint64_t v14 = v10;
    v14[1] = v12;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
LABEL_10:
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"explicit_padding", 16, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v19 = v50;
    }
    unint64_t v20 = (uint64_t *)((char *)v49 + 16 * v19);
    *unint64_t v20 = v16;
    v20[1] = v18;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v21 = a2[3];
  if (v21)
  {
    uint64_t v22 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"groups", 6, v21);
    uint64_t v24 = v23;
    unsigned int v25 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v25 = v50;
    }
    uint64_t v26 = (uint64_t *)((char *)v49 + 16 * v25);
    *uint64_t v26 = v22;
    v26[1] = v24;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v27 = a2[4];
  if (v27)
  {
    uint64_t v28 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"padding_style", 13, v27);
    uint64_t v30 = v29;
    unsigned int v31 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v31 = v50;
    }
    uint64_t v32 = (uint64_t *)((char *)v49 + 16 * v31);
    *uint64_t v32 = v28;
    v32[1] = v30;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v33 = a2[5];
  if (v33)
  {
    uint64_t v34 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"strides", 7, v33);
    uint64_t v36 = v35;
    unsigned int v37 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v37 = v50;
    }
    unint64_t v38 = (uint64_t *)((char *)v49 + 16 * v37);
    uint64_t *v38 = v34;
    v38[1] = v36;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v39 = a2[6];
  if (v39)
  {
    uint64_t v40 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"weights_layout", 14, v39);
    uint64_t v42 = v41;
    unsigned int v43 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v43 = v50;
    }
    BOOL v44 = (uint64_t *)((char *)v49 + 16 * v43);
    uint64_t *v44 = v40;
    v44[1] = v42;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  unint64_t v45 = v49;
  if (!v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v49 == v51) {
      return DictionaryAttr;
    }
    goto LABEL_32;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v48, (uint64_t *)v49, v8);
  unint64_t v45 = v49;
  if (v49 != v51) {
LABEL_32:
  }
    free(v45);
  return DictionaryAttr;
}

unint64_t mlir::mps::Conv2DDataGradientOp::computePropertiesHash(unint64_t *a1)
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  unint64_t v1 = *a1;
  unint64_t v2 = 0x1E8EB8000uLL;
  {
    int64_t v52 = a1;
    unint64_t v66 = v1;
    unint64_t v1 = v66;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v26 = v25;
    a1 = v52;
    if (v26)
    {
      unint64_t v27 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v27 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v27;
      unint64_t v1 = v66;
      unint64_t v2 = 0x1E8EB8000;
      a1 = v52;
    }
  }
  uint64_t v3 = *(void *)(v2 + 3024);
  unint64_t v4 = a1[1];
  {
    int64_t v53 = a1;
    uint64_t v59 = v3;
    unint64_t v67 = v1;
    unint64_t v47 = v4;
    uint64_t v3 = v59;
    unint64_t v1 = v67;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v29 = v28;
    unint64_t v4 = v47;
    a1 = v53;
    if (v29)
    {
      unint64_t v30 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v30 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v30;
      unint64_t v4 = v47;
      a1 = v53;
      uint64_t v3 = v59;
      unint64_t v1 = v67;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v5 = HIDWORD(v4);
  unint64_t v6 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v4) ^ HIDWORD(v4));
  unint64_t v79 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) ^ ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) >> 47));
  unint64_t v7 = a1[2];
  {
    uint64_t v54 = a1;
    uint64_t v60 = v3;
    unint64_t v68 = v1;
    unint64_t v48 = v7;
    uint64_t v3 = v60;
    unint64_t v1 = v68;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v32 = v31;
    unint64_t v7 = v48;
    a1 = v54;
    if (v32)
    {
      unint64_t v33 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v33 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v33;
      unint64_t v7 = v48;
      a1 = v54;
      uint64_t v3 = v60;
      unint64_t v1 = v68;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v8 = HIDWORD(v7);
  unint64_t v9 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v7) ^ HIDWORD(v7));
  unint64_t v78 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
  unint64_t v10 = a1[3];
  {
    long long v55 = a1;
    uint64_t v61 = v3;
    unint64_t v69 = v1;
    unint64_t v49 = v10;
    uint64_t v3 = v61;
    unint64_t v1 = v69;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v35 = v34;
    unint64_t v10 = v49;
    a1 = v55;
    if (v35)
    {
      unint64_t v36 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v36 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v36;
      unint64_t v10 = v49;
      a1 = v55;
      uint64_t v3 = v61;
      unint64_t v1 = v69;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v11 = HIDWORD(v10);
  unint64_t v12 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v10) ^ HIDWORD(v10));
  unint64_t v77 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v11 ^ (v12 >> 47) ^ v12)) ^ ((0x9DDFEA08EB382D69 * (v11 ^ (v12 >> 47) ^ v12)) >> 47));
  unint64_t v13 = a1[4];
  {
    uint64_t v56 = a1;
    uint64_t v62 = v3;
    unint64_t v70 = v1;
    unint64_t v50 = v13;
    uint64_t v3 = v62;
    unint64_t v1 = v70;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v38 = v37;
    unint64_t v13 = v50;
    a1 = v56;
    if (v38)
    {
      unint64_t v39 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v39 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v39;
      unint64_t v13 = v50;
      a1 = v56;
      uint64_t v3 = v62;
      unint64_t v1 = v70;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v14 = HIDWORD(v13);
  unint64_t v15 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v13) ^ HIDWORD(v13));
  unint64_t v76 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v14 ^ (v15 >> 47) ^ v15)) ^ ((0x9DDFEA08EB382D69 * (v14 ^ (v15 >> 47) ^ v15)) >> 47));
  unint64_t v16 = a1[5];
  {
    uint64_t v57 = a1;
    uint64_t v63 = v3;
    unint64_t v71 = v1;
    unint64_t v51 = v16;
    uint64_t v3 = v63;
    unint64_t v1 = v71;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v41 = v40;
    unint64_t v16 = v51;
    a1 = v57;
    if (v41)
    {
      unint64_t v42 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v42 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v42;
      unint64_t v16 = v51;
      a1 = v57;
      uint64_t v3 = v63;
      unint64_t v1 = v71;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v17 = HIDWORD(v16);
  unint64_t v18 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v16) ^ HIDWORD(v16));
  unint64_t v75 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v17 ^ (v18 >> 47) ^ v18)) ^ ((0x9DDFEA08EB382D69 * (v17 ^ (v18 >> 47) ^ v18)) >> 47));
  unint64_t v19 = a1[6];
  {
    uint64_t v64 = v3;
    unint64_t v72 = v1;
    unint64_t v58 = v19;
    unint64_t v19 = v58;
    uint64_t v3 = v64;
    unint64_t v1 = v72;
    unint64_t v2 = 0x1E8EB8000uLL;
    if (v43)
    {
      unint64_t v44 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v44 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v44;
      unint64_t v19 = v58;
      uint64_t v3 = v64;
      unint64_t v1 = v72;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v20 = HIDWORD(v19);
  unint64_t v21 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v19) ^ HIDWORD(v19));
  unint64_t v74 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v20 ^ (v21 >> 47) ^ v21)) ^ ((0x9DDFEA08EB382D69 * (v20 ^ (v21 >> 47) ^ v21)) >> 47));
  uint64_t v82 = 0;
  memset(v81, 0, sizeof(v81));
  memset(v80, 0, sizeof(v80));
  {
    uint64_t v65 = v3;
    unint64_t v73 = v1;
    uint64_t v3 = v65;
    unint64_t v1 = v73;
    unint64_t v2 = 0x1E8EB8000uLL;
    if (v45)
    {
      unint64_t v46 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v46 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v46;
      uint64_t v3 = v65;
      unint64_t v1 = v73;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v22 = HIDWORD(v1);
  unint64_t v23 = 0x9DDFEA08EB382D69 * ((v3 + 8 * v1) ^ HIDWORD(v1));
  uint64_t v83 = *(void *)(v2 + 3024);
  *(void *)&v80[0] = 0x9DDFEA08EB382D69
                     * ((0x9DDFEA08EB382D69 * (v22 ^ (v23 >> 47) ^ v23)) ^ ((0x9DDFEA08EB382D69
                                                                             * (v22 ^ (v23 >> 47) ^ v23)) >> 47));
  return llvm::hashing::detail::hash_combine_recursive_helper::combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>((llvm::hashing::detail::hash_combine_recursive_helper *)v80, 0, (void *)v80 + 1, (char *)v81, (uint64_t *)&v79, (uint64_t *)&v78, (uint64_t *)&v77, (uint64_t *)&v76, (uint64_t *)&v75, (uint64_t *)&v74);
}

uint64_t mlir::mps::Conv2DDataGradientOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 6uLL:
      if (memcmp(__s1, "groups", __n)) {
        return 0;
      }
      return a2[3];
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[5];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x79616C5F61746164 || *(void *)(__s1 + 3) != 0x74756F79616C5F61) {
        return 0;
      }
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[4];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n)) {
        return a2[1];
      }
      if (memcmp(__s1, "weights_layout", __n)) {
        return 0;
      }
      return a2[6];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::Conv2DDataGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  unint64_t v7 = (void *)result;
  switch(__n)
  {
    case 6uLL:
      uint64_t result = memcmp(__s1, "groups", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
            uint64_t v14 = a4;
          }
          else {
            uint64_t v14 = 0;
          }
          v7[3] = v14;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          v7[5] = v8;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x79616C5F61746164 && *(void *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          *(void *)uint64_t result = v10;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v7[4] = v11;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "weights_layout", __n);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
              uint64_t v12 = a4;
            }
            else {
              uint64_t v12 = 0;
            }
            v7[6] = v12;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
        if (result) {
          uint64_t v15 = a4;
        }
        else {
          uint64_t v15 = 0;
        }
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v13 = a4;
          }
          else {
            uint64_t v13 = 0;
          }
          v7[2] = v13;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::Conv2DDataGradientOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (*a2) {
    mlir::NamedAttrList::append(a3, (uint64_t)"data_layout", 11, *a2);
  }
  uint64_t v5 = a2[1];
  if (v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"dilation_rates", 14, v5);
  }
  uint64_t v6 = a2[2];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"explicit_padding", 16, v6);
  }
  uint64_t v7 = a2[3];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"groups", 6, v7);
  }
  uint64_t v8 = a2[4];
  if (v8) {
    mlir::NamedAttrList::append(a3, (uint64_t)"padding_style", 13, v8);
  }
  uint64_t v9 = a2[5];
  if (v9) {
    mlir::NamedAttrList::append(a3, (uint64_t)"strides", 7, v9);
  }
  uint64_t v10 = a2[6];
  if (v10)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"weights_layout", 14, v10);
  }
}

BOOL mlir::mps::Conv2DDataGradientOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v8, (const void **)"data_layout", (const char *)0xB, a3, a4))
  {
    uint64_t v9 = (const void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v9, (const void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))a3, a4))
    {
      uint64_t v10 = (const void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v10, (const void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))a3, a4))
      {
        uint64_t v11 = (const void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 24));
        if (!v11
          || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v11, (const void **)"groups", (const char *)6, a3, a4))
        {
          uint64_t v12 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v12, (const void **)"padding_style", (const char *)0xD, a3, a4))
          {
            uint64_t v13 = (const void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v13, (const void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))a3, a4))
            {
              uint64_t v14 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 48));
              if (!v14
                || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v14, (const void **)"weights_layout", (const char *)0xE, a3, a4))
              {
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    unint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    uint64_t v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = (char *)v35;
        uint64_t v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        uint64_t v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      int v29 = a2;
      unint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        unint64_t v30 = "' failed to satisfy constraint: valid TensorDataLayout";
        uint64_t v31 = 54;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        uint64_t v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)uint64_t v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    unint64_t v16 = (void **)__p;
    if (__p)
    {
      unint64_t v17 = v42;
      unint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          unint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        unint64_t v18 = __p;
      }
      unint64_t v42 = v16;
      operator delete(v18);
    }
    unint64_t v19 = v39;
    if (v39)
    {
      unint64_t v20 = v40;
      unint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          unint64_t v23 = (void *)*--v20;
          unint64_t v22 = v23;
          *unint64_t v20 = 0;
          if (v23) {
            operator delete[](v22);
          }
        }
        while (v20 != v19);
        unint64_t v21 = v39;
      }
      int v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(const void **a1, const void **a2, const char *a3, void (*a4)(void **__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 1;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1)) {
    goto LABEL_9;
  }
  uint64_t v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>((uint64_t)*a1 + 8);
  int v41 = a1;
  unint64_t v42 = (const char *)v10;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v41);
  uint64_t v12 = Type;
  if (Type) {
    Type = (void *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  }
  int v45 = v12;
  unint64_t v46 = Type;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v45);
  uint64_t v56 = 4;
  if (v14 == 1 && *ArgAttrsAttr == v56)
  {
    int v38 = a1;
    v39[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v38);
    v39[1] = v15;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v39);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
  }
LABEL_9:
  a4(&v45, a5);
  if (v45)
  {
    LODWORD(v41) = 3;
    unint64_t v42 = "attribute '";
    uint64_t v43 = 11;
    unint64_t v17 = &v41;
    unint64_t v18 = (char *)v47;
    if (v48 >= v49)
    {
      unint64_t v34 = v48 + 1;
      if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
      {
        int64_t v36 = (char *)&v41 - (unsigned char *)v47;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        unint64_t v18 = (char *)v47;
        unint64_t v17 = (const void ***)((char *)v47 + v36);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        unint64_t v17 = &v41;
        unint64_t v18 = (char *)v47;
      }
    }
    unint64_t v19 = &v18[24 * v48];
    long long v20 = *(_OWORD *)v17;
    *((void *)v19 + 2) = v17[2];
    *(_OWORD *)unint64_t v19 = v20;
    ++v48;
    if (v45)
    {
      __int16 v44 = 261;
      int v41 = a2;
      unint64_t v42 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v46, &v41);
      if (v45)
      {
        LODWORD(v41) = 3;
        unint64_t v42 = "' failed to satisfy constraint: ui64 elements attribute of shape {4}";
        uint64_t v43 = 68;
        unint64_t v21 = &v41;
        unint64_t v22 = (char *)v47;
        if (v48 >= v49)
        {
          unint64_t v35 = v48 + 1;
          if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
          {
            int64_t v37 = (char *)&v41 - (unsigned char *)v47;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            unint64_t v22 = (char *)v47;
            unint64_t v21 = (const void ***)((char *)v47 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            unint64_t v21 = &v41;
            unint64_t v22 = (char *)v47;
          }
        }
        unint64_t v23 = &v22[24 * v48];
        long long v24 = *(_OWORD *)v21;
        *((void *)v23 + 2) = v21[2];
        *(_OWORD *)unint64_t v23 = v24;
        ++v48;
      }
    }
  }
  uint64_t v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v45);
  if (v45) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v45);
  }
  if (v55)
  {
    unint64_t v25 = (void **)__p;
    if (__p)
    {
      unint64_t v26 = v54;
      int64_t v27 = __p;
      if (v54 != __p)
      {
        do
          unint64_t v26 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v26 - 1);
        while (v26 != v25);
        int64_t v27 = __p;
      }
      uint64_t v54 = v25;
      operator delete(v27);
    }
    int64_t v28 = v51;
    if (v51)
    {
      int v29 = v52;
      unint64_t v30 = v51;
      if (v52 != v51)
      {
        do
        {
          __int16 v32 = (void *)*--v29;
          uint64_t v31 = v32;
          void *v29 = 0;
          if (v32) {
            operator delete[](v31);
          }
        }
        while (v29 != v28);
        unint64_t v30 = v51;
      }
      int64_t v52 = v28;
      operator delete(v30);
    }
    if (v47 != v50) {
      free(v47);
    }
  }
  return v16;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(const void **a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 1;
  }
  if (*((_UNKNOWN **)*a1 + 17) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    uint64_t v31 = a1;
    uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v31);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&Value, 64)) {
      return 1;
    }
  }
  a4(&Value, a5);
  if (Value)
  {
    LODWORD(v31) = 3;
    __int16 v32 = "attribute '";
    uint64_t v33 = 11;
    uint64_t v10 = &v31;
    uint64_t v11 = (char *)v37;
    if (v38 >= v39)
    {
      unint64_t v27 = v38 + 1;
      if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
      {
        int64_t v29 = (char *)&v31 - (unsigned char *)v37;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        uint64_t v11 = (char *)v37;
        uint64_t v10 = (const void ***)((char *)v37 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        uint64_t v10 = &v31;
        uint64_t v11 = (char *)v37;
      }
    }
    uint64_t v12 = &v11[24 * v38];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = v10[2];
    *(_OWORD *)uint64_t v12 = v13;
    ++v38;
    if (Value)
    {
      __int16 v34 = 261;
      uint64_t v31 = a2;
      __int16 v32 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v36, &v31);
      if (Value)
      {
        LODWORD(v31) = 3;
        __int16 v32 = "' failed to satisfy constraint: 64-bit unsigned integer attribute";
        uint64_t v33 = 65;
        uint64_t v14 = &v31;
        uint64_t v15 = (char *)v37;
        if (v38 >= v39)
        {
          unint64_t v28 = v38 + 1;
          if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
          {
            int64_t v30 = (char *)&v31 - (unsigned char *)v37;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            uint64_t v15 = (char *)v37;
            uint64_t v14 = (const void ***)((char *)v37 + v30);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            uint64_t v14 = &v31;
            uint64_t v15 = (char *)v37;
          }
        }
        uint64_t v16 = &v15[24 * v38];
        long long v17 = *(_OWORD *)v14;
        *((void *)v16 + 2) = v14[2];
        *(_OWORD *)uint64_t v16 = v17;
        ++v38;
      }
    }
  }
  uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  }
  if (v45)
  {
    unint64_t v18 = (void **)__p;
    if (__p)
    {
      unint64_t v19 = v44;
      long long v20 = __p;
      if (v44 != __p)
      {
        do
          unint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        long long v20 = __p;
      }
      __int16 v44 = v18;
      operator delete(v20);
    }
    unint64_t v21 = v41;
    if (v41)
    {
      unint64_t v22 = v42;
      unint64_t v23 = v41;
      if (v42 != v41)
      {
        do
        {
          unint64_t v25 = (void *)*--v22;
          long long v24 = v25;
          *unint64_t v22 = 0;
          if (v25) {
            operator delete[](v24);
          }
        }
        while (v22 != v21);
        unint64_t v23 = v41;
      }
      unint64_t v42 = v21;
      operator delete(v23);
    }
    if (v37 != v40) {
      free(v37);
    }
  }
  return v9;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    int64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    uint64_t v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = (char *)v35;
        uint64_t v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        uint64_t v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      int64_t v29 = a2;
      int64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        int64_t v30 = "' failed to satisfy constraint: valid padding_style";
        uint64_t v31 = 51;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        long long v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)long long v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    uint64_t v16 = (void **)__p;
    if (__p)
    {
      long long v17 = v42;
      unint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          long long v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        unint64_t v18 = __p;
      }
      unint64_t v42 = v16;
      operator delete(v18);
    }
    unint64_t v19 = v39;
    if (v39)
    {
      long long v20 = v40;
      unint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          unint64_t v23 = (void *)*--v20;
          unint64_t v22 = v23;
          *long long v20 = 0;
          if (v23) {
            operator delete[](v22);
          }
        }
        while (v20 != v19);
        unint64_t v21 = v39;
      }
      int v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

BOOL mlir::mps::Conv2DDataGradientOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x38uLL);
    *uint64_t v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    *((void *)v3 + 6) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 119;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[21];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  int v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
    return 1;
  }
  unsigned char v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    unint64_t v6 = &v40;
    unint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v7 = (char *)v46;
        unint64_t v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v6 = &v40;
        unint64_t v7 = (char *)v46;
      }
    }
    uint64_t v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)uint64_t v8 = v9;
    ++v47;
  }
  int v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::PaddingStyleAttr]";
  unint64_t v41 = 77;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    int v40 = (const void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      unint64_t v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          unint64_t v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          unint64_t v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      uint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)uint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        unint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unint64_t v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unint64_t v19 = (char *)v46;
            unint64_t v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unint64_t v18 = &v40;
            unint64_t v19 = (char *)v46;
          }
        }
        long long v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)long long v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    unint64_t v23 = (void **)__p;
    if (__p)
    {
      long long v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          long long v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      int64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          int64_t v30 = (void *)*--v27;
          int64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            operator delete[](v29);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      unint64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

void mlir::mps::Conv2DDataGradientOp::setStridesAttr(uint64_t *a1, uint64_t a2)
{
}

void mlir::mps::Conv2DDataGradientOp::setDilationRatesAttr(uint64_t *a1, uint64_t a2)
{
}

void mlir::mps::Conv2DDataGradientOp::setExplicitPaddingAttr(uint64_t *a1, uint64_t a2)
{
}

void mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr(uint64_t *a1, uint64_t a2)
{
}

void mlir::mps::Conv2DDataGradientOp::setWeightsLayoutAttr(uint64_t *a1, uint64_t a2)
{
}

void mlir::mps::Conv2DDataGradientOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, unint64_t a8, uint64_t a9, uint64_t a10, unint64_t a11, unint64_t a12, unint64_t a13, unint64_t a14, unsigned int a15, unsigned int a16, unsigned int a17)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  int64_t v52 = v54;
  v54[0] = xmmword_181119FA8;
  v54[1] = unk_181119FB8;
  uint64_t v53 = 0x400000004;
  unsigned int v49 = v51;
  v51[0] = xmmword_181119FA8;
  v51[1] = unk_181119FB8;
  uint64_t v50 = 0x400000004;
  uint64_t v46 = v48;
  memset(v48, 0, sizeof(v48));
  uint64_t v47 = 0x800000008;
  uint64_t v39 = 0;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v34 = 0u;
  memset(v33, 0, sizeof(v33));
  mlir::mps::buildConv2DDescriptor(a3, a4, a6, a7, a8, a9, a10, a11, (uint64_t)v33, a12, a13, a14, a15, a16, a17, v54, (uint64_t)v51, (uint64_t)v48, 0);
  __int16 v43 = &v45;
  long long v45 = xmmword_18110B5E0;
  uint64_t v44 = 0x200000002;
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  unint64_t v19 = (void *)mlir::RankedTensorType::get((uint64_t)&v45, 2, IntegerType, 0);
  int v40 = v42;
  v42[0] = 4;
  uint64_t v41 = 0x200000001;
  uint64_t v20 = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  long long v21 = (void *)mlir::RankedTensorType::get((uint64_t)v42, 1, v20, 0);
  uint64_t v22 = v21;
  if (v21) {
    uint64_t v23 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v21 + 8);
  }
  else {
    uint64_t v23 = 0;
  }
  uint64_t v24 = mlir::DenseElementsAttr::getFromRawBuffer(v22, v23, v52, 8 * v53, 8, 1, 0);
  if (v22) {
    uint64_t v25 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v22 + 8);
  }
  else {
    uint64_t v25 = 0;
  }
  uint64_t v26 = mlir::DenseElementsAttr::getFromRawBuffer(v22, v25, v49, 8 * v50, 8, 1, 0);
  if (v19) {
    uint64_t v27 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v19 + 8);
  }
  else {
    uint64_t v27 = 0;
  }
  uint64_t v28 = mlir::DenseElementsAttr::getFromRawBuffer(v19, v27, v46, 8 * v47, 8, 1, 0);
  mlir::mps::Conv2DDataGradientOp::build(a1, a2, a3, a4, a5, v34, v24, v26, v28, a15, a16, a17);
  if (v40 != v42) {
    free(v40);
  }
  if (v43 != &v45) {
    free(v43);
  }
  if (v46 != v48) {
    free(v46);
  }
  if (v49 != v51) {
    free(v49);
  }
  if (v52 != v54) {
    free(v52);
  }
}

void mlir::mps::Conv2DDataGradientOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int a10, unsigned int a11, unsigned int a12)
{
  void v47[2] = *MEMORY[0x1E4F143B8];
  uint64_t v40 = a4;
  uint64_t v41 = a3;
  uint64_t v39 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v41, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v40, 1);
  if (a5) {
    mlir::OperationState::addOperands(a2, (uint64_t)&v39, 1);
  }
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  uint64_t IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a6);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 24) = IntegerAttr;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 40) = a7;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = a8;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 16) = a9;
  uint64_t v20 = *(mlir::MLIRContext **)a1;
  unsigned int v42 = a10;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v20);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  uint64_t v46 = (uint64_t)v20;
  uint64_t v22 = mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v42);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 32) = v22;
  uint64_t v23 = *(mlir::MLIRContext **)a1;
  unsigned int v42 = a11;
  uint64_t v24 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v23);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  uint64_t v46 = (uint64_t)v23;
  uint64_t v25 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v24, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v42);
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>((void *)a2) = v25;
  uint64_t v26 = *(mlir::MLIRContext **)a1;
  unsigned int v42 = a12;
  uint64_t v27 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v26);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  uint64_t v46 = (uint64_t)v26;
  uint64_t v28 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v27, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v42);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 48) = v28;
  __src = v47;
  uint64_t v46 = 0x200000000;
  int64_t v29 = *(mlir::UnknownLoc **)a1;
  int64_t v30 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v44, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  unint64_t v33 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v43, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::Conv2DDataGradientOp::inferReturnTypes(v29, v30, 1, v44[0], v44[1], Dictionary, v33, v34, v43[0], v43[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  long long v35 = __src;
  }
  uint64_t v36 = v46;
  uint64_t v37 = *(unsigned int *)(a2 + 72);
  unint64_t v38 = v37 + v46;
  if (v38 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v38, 8);
    LODWORD(v37) = *(_DWORD *)(a2 + 72);
  }
  if (v36)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v37), v35, 8 * v36);
    LODWORD(v37) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v37 + v36;
  if (__src != v47) {
    free(__src);
  }
}

BOOL mlir::mps::Conv2DDataGradientOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  unint64_t v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    uint64_t v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *v3;
  if (!*v3)
  {
    v66[0] = (const void **)"requires attribute 'data_layout'";
    __int16 v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    uint64_t v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    }
    if (!v75) {
      return v27;
    }
    uint64_t v28 = (void **)__p;
    if (__p)
    {
      int64_t v29 = v74;
      int64_t v30 = __p;
      if (v74 != __p)
      {
        do
          int64_t v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
        while (v29 != v28);
        int64_t v30 = __p;
      }
      unint64_t v74 = v28;
      operator delete(v30);
    }
    uint64_t v31 = v71;
    if (v71)
    {
      unint64_t v32 = v72;
      unint64_t v33 = v71;
      if (v72 == v71) {
        goto LABEL_97;
      }
      do
      {
        long long v35 = (void *)*--v32;
        int v34 = v35;
        *unint64_t v32 = 0;
        if (v35) {
          operator delete[](v34);
        }
      }
      while (v32 != v31);
LABEL_96:
      unint64_t v33 = v71;
LABEL_97:
      unint64_t v72 = v31;
      operator delete(v33);
    }
LABEL_98:
    if (v69 != &v70) {
      free(v69);
    }
    return v27;
  }
  int v5 = (const void **)v3[1];
  if (!v5)
  {
    v66[0] = (const void **)"requires attribute 'dilation_rates'";
    __int16 v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    uint64_t v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    }
    if (!v75) {
      return v27;
    }
    uint64_t v36 = (void **)__p;
    if (__p)
    {
      uint64_t v37 = v74;
      unint64_t v38 = __p;
      if (v74 != __p)
      {
        do
          uint64_t v37 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v37 - 1);
        while (v37 != v36);
        unint64_t v38 = __p;
      }
      unint64_t v74 = v36;
      operator delete(v38);
    }
    uint64_t v31 = v71;
    if (v71)
    {
      uint64_t v39 = v72;
      unint64_t v33 = v71;
      if (v72 == v71) {
        goto LABEL_97;
      }
      do
      {
        uint64_t v41 = (void *)*--v39;
        uint64_t v40 = v41;
        void *v39 = 0;
        if (v41) {
          operator delete[](v40);
        }
      }
      while (v39 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  unint64_t v6 = (const void **)v3[2];
  if (!v6)
  {
    v66[0] = (const void **)"requires attribute 'explicit_padding'";
    __int16 v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    uint64_t v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    }
    if (!v75) {
      return v27;
    }
    unsigned int v42 = (void **)__p;
    if (__p)
    {
      __int16 v43 = v74;
      uint64_t v44 = __p;
      if (v74 != __p)
      {
        do
          __int16 v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v43 - 1);
        while (v43 != v42);
        uint64_t v44 = __p;
      }
      unint64_t v74 = v42;
      operator delete(v44);
    }
    uint64_t v31 = v71;
    if (v71)
    {
      long long v45 = v72;
      unint64_t v33 = v71;
      if (v72 == v71) {
        goto LABEL_97;
      }
      do
      {
        uint64_t v47 = (void *)*--v45;
        uint64_t v46 = v47;
        *long long v45 = 0;
        if (v47) {
          operator delete[](v46);
        }
      }
      while (v45 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  unint64_t v7 = (const void **)v3[3];
  if (!v7)
  {
    v66[0] = (const void **)"requires attribute 'groups'";
    __int16 v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    uint64_t v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    }
    if (!v75) {
      return v27;
    }
    unsigned int v48 = (void **)__p;
    if (__p)
    {
      unsigned int v49 = v74;
      uint64_t v50 = __p;
      if (v74 != __p)
      {
        do
          unsigned int v49 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v49 - 1);
        while (v49 != v48);
        uint64_t v50 = __p;
      }
      unint64_t v74 = v48;
      operator delete(v50);
    }
    uint64_t v31 = v71;
    if (v71)
    {
      unint64_t v51 = v72;
      unint64_t v33 = v71;
      if (v72 == v71) {
        goto LABEL_97;
      }
      do
      {
        uint64_t v53 = (void *)*--v51;
        int64_t v52 = v53;
        *unint64_t v51 = 0;
        if (v53) {
          operator delete[](v52);
        }
      }
      while (v51 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  uint64_t v8 = v3[4];
  if (!v8)
  {
    v66[0] = (const void **)"requires attribute 'padding_style'";
    __int16 v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    uint64_t v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    }
    if (!v75) {
      return v27;
    }
    char v54 = (void **)__p;
    if (__p)
    {
      uint64_t v55 = v74;
      uint64_t v56 = __p;
      if (v74 != __p)
      {
        do
          uint64_t v55 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v55 - 1);
        while (v55 != v54);
        uint64_t v56 = __p;
      }
      unint64_t v74 = v54;
      operator delete(v56);
    }
    uint64_t v31 = v71;
    if (v71)
    {
      uint64_t v57 = v72;
      unint64_t v33 = v71;
      if (v72 == v71) {
        goto LABEL_97;
      }
      do
      {
        uint64_t v59 = (void *)*--v57;
        unint64_t v58 = v59;
        *uint64_t v57 = 0;
        if (v59) {
          operator delete[](v58);
        }
      }
      while (v57 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  long long v9 = (const void **)v3[5];
  if (!v9)
  {
    uint64_t v61 = "requires attribute 'strides'";
LABEL_103:
    v66[0] = (const void **)v61;
    __int16 v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    uint64_t v26 = v68;
    goto LABEL_104;
  }
  uint64_t v10 = v3[6];
  if (!v10)
  {
    uint64_t v61 = "requires attribute 'weights_layout'";
    goto LABEL_103;
  }
  v68[0] = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v7, (const void **)"groups", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  v68[0] = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v9, (const void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  v68[0] = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  v68[0] = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  v68[0] = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v8, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  v68[0] = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  v68[0] = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v10, (const void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  unint64_t v11 = *this;
  }
  unint64_t v12 = *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  unsigned int v65 = 1;
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v11, v12, (const void **)"operand", (const void **)7, 0))return 0; {
  unsigned int v13 = 1;
  }
  uint64_t ODSOperands = mlir::tensor::UnPackOp::getODSOperands((mlir::tensor::UnPackOp *)this, 1u);
  if (v15)
  {
    uint64_t v16 = v15;
    uint64_t v17 = 0;
    uint64_t v18 = ODSOperands + 24;
    while (1)
    {
      unint64_t v19 = *this;
      unint64_t v20 = *(void *)(*(void *)v18 + 8) & 0xFFFFFFFFFFFFFFF8;
      unsigned int v65 = v17 + 2;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v19, v20, (const void **)"operand", (const void **)7, (int)v17 + 1))return 0; {
      ++v17;
      }
      v18 += 32;
      if (v16 == v17)
      {
        unsigned int v13 = v17 + 1;
        break;
      }
    }
  }
  uint64_t v21 = mlir::tensor::UnPackOp::getODSOperands((mlir::tensor::UnPackOp *)this, 2u);
  uint64_t v23 = v22;
  if (v22 >= 2)
  {
    v66[0] = (const void **)"operand group starting at #";
    __int16 v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    uint64_t v24 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v68, &v65);
    uint64_t v25 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v24, " requires 0 or 1 element, but found ");
    uint64_t v64 = v23;
    uint64_t v26 = (void *)mlir::InFlightDiagnostic::operator<<<unsigned long &>(v25, &v64);
LABEL_104:
    uint64_t v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v26);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v68);
    return v27;
  }
  if (v22
    && !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)(v21 + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v13))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v62 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v62 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v62, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::Conv2DDataGradientOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.conv_2d_data_gradient", 25, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC981780;
  v4[12] = mlir::mps::Conv2DDataGradientOp::canonicalize;
  long long v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    long long v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::Conv2DOpGenericAdaptorBase::Conv2DOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v13, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *(_OWORD *)v5;
  long long v9 = *(_OWORD *)(v5 + 16);
  long long v10 = *(_OWORD *)(v5 + 32);
  *(void *)(a1 + 72) = *(void *)(v5 + 48);
  *(_OWORD *)(a1 + 56) = v10;
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)v13;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.conv_2d", 11, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::Conv2DOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 6uLL:
      if (memcmp(__s1, "groups", __n)) {
        return 0;
      }
      return a2[3];
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[5];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x79616C5F61746164 || *(void *)(__s1 + 3) != 0x74756F79616C5F61) {
        return 0;
      }
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[4];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n)) {
        return a2[1];
      }
      if (memcmp(__s1, "weights_layout", __n)) {
        return 0;
      }
      return a2[6];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::Conv2DOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  uint64_t v7 = (void *)result;
  switch(__n)
  {
    case 6uLL:
      uint64_t result = memcmp(__s1, "groups", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
            uint64_t v14 = a4;
          }
          else {
            uint64_t v14 = 0;
          }
          v7[3] = v14;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          v7[5] = v8;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x79616C5F61746164 && *(void *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          *(void *)uint64_t result = v10;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v7[4] = v11;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "weights_layout", __n);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
              uint64_t v12 = a4;
            }
            else {
              uint64_t v12 = 0;
            }
            v7[6] = v12;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
        if (result) {
          uint64_t v15 = a4;
        }
        else {
          uint64_t v15 = 0;
        }
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v13 = a4;
          }
          else {
            uint64_t v13 = 0;
          }
          v7[2] = v13;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::Conv2DOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x38uLL);
    *uint64_t v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    *((void *)v3 + 6) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    unint64_t v4 = 0x1E8EB8000uLL;
    {
      unint64_t v4 = 0x1E8EB8000;
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 107;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        unint64_t v4 = 0x1E8EB8000;
      }
    }
    a1[33] = *(void *)(v4 + 1968);
    return a1[32];
  }
  return result;
}

void mlir::mps::Conv2DOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unint64_t a7, uint64_t a8, uint64_t a9, unint64_t a10, unint64_t a11, unint64_t a12, unint64_t a13, unsigned int a14, unsigned int a15, unsigned int a16)
{
  v46[4] = *MEMORY[0x1E4F143B8];
  uint64_t v44 = v46;
  memset_pattern16(v46, &unk_1810FE350, 0x20uLL);
  uint64_t v45 = 0x400000004;
  uint64_t v41 = v43;
  memset_pattern16(v43, &unk_1810FE350, 0x20uLL);
  uint64_t v42 = 0x400000004;
  unint64_t v38 = v40;
  memset(v40, 0, sizeof(v40));
  uint64_t v39 = 0x800000008;
  mlir::mps::buildConv2DDescriptor(a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)v36, a11, a12, a13, a14, a15, a16, v46, (uint64_t)v43, (uint64_t)v40, 0);
  v36[0] = v37;
  v37[0] = xmmword_18110B5E0;
  v36[1] = (void *)0x400000002;
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  uint64_t v17 = (void *)mlir::RankedTensorType::get((uint64_t)v37, 2, IntegerType, 0);
  v35[0] = 4;
  uint64_t v18 = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  unint64_t v19 = (void *)mlir::RankedTensorType::get((uint64_t)v35, 1, v18, 0);
  unint64_t v20 = v19;
  if (v19) {
    uint64_t v21 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v19 + 8);
  }
  else {
    uint64_t v21 = 0;
  }
  uint64_t v22 = mlir::DenseElementsAttr::getFromRawBuffer(v20, v21, v44, 8 * v45, 8, 1, 0);
  if (v20) {
    uint64_t v23 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v20 + 8);
  }
  else {
    uint64_t v23 = 0;
  }
  uint64_t v24 = mlir::DenseElementsAttr::getFromRawBuffer(v20, v23, v41, 8 * v42, 8, 1, 0);
  if (v17) {
    uint64_t v25 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v17 + 8);
  }
  else {
    uint64_t v25 = 0;
  }
  uint64_t v26 = mlir::DenseElementsAttr::getFromRawBuffer(v17, v25, v38, 8 * v39, 8, 1, 0);
  mlir::mps::Conv2DOp::build(a1, a2, a3, a4, a5, v22, v24, v26, a14, a15, a16);
  if (v36[0] != v37) {
    free(v36[0]);
  }
  if (v38 != v40) {
    free(v38);
  }
  if (v41 != v43) {
    free(v41);
  }
  if (v44 != v46) {
    free(v44);
  }
}

void mlir::mps::Conv2DOp::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  unint64_t v33[2] = *MEMORY[0x1E4F143B8];
  uint64_t v27 = a4;
  uint64_t v28 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v28, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v27, 1);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((void *)a2)
            + 24) = a5;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((void *)a2)
            + 40) = a6;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = a7;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((void *)a2)
            + 16) = a8;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((void *)a2)
            + 32) = a9;
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((void *)a2) = a10;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((void *)a2)
            + 48) = a11;
  __src = v33;
  uint64_t v32 = 0x200000000;
  uint64_t v17 = *a1;
  uint64_t v18 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v30, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v21 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v29, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::Conv2DOp::inferReturnTypes(v17, v18, 1, v30[0], v30[1], Dictionary, v21, v22, v29[0], v29[1], &__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v23 = __src;
  }
  uint64_t v24 = v32;
  uint64_t v25 = *(unsigned int *)(a2 + 72);
  unint64_t v26 = v25 + v32;
  if (v26 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v26, 8);
    LODWORD(v25) = *(_DWORD *)(a2 + 72);
  }
  if (v24)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v25), v23, 8 * v24);
    LODWORD(v25) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v25 + v24;
  if (__src != v33) {
    free(__src);
  }
}

void mlir::mps::Conv2DOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, unsigned int a10, unsigned int a11)
{
  void v45[2] = *MEMORY[0x1E4F143B8];
  uint64_t v38 = a4;
  uint64_t v39 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v39, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v38, 1);
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  uint64_t IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a5);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((void *)a2)
            + 24) = IntegerAttr;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((void *)a2)
            + 40) = a6;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = a7;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((void *)a2)
            + 16) = a8;
  unint64_t v19 = *(mlir::MLIRContext **)a1;
  unsigned int v40 = a9;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v19);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  uint64_t v44 = (uint64_t)v19;
  uint64_t v21 = mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v40);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((void *)a2)
            + 32) = v21;
  int v22 = *(mlir::MLIRContext **)a1;
  unsigned int v40 = a10;
  uint64_t v23 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v22);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  uint64_t v44 = (uint64_t)v22;
  uint64_t v24 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v23, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v40);
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((void *)a2) = v24;
  uint64_t v25 = *(mlir::MLIRContext **)a1;
  unsigned int v40 = a11;
  unint64_t v26 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v25);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  uint64_t v44 = (uint64_t)v25;
  uint64_t v27 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v26, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v40);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((void *)a2)
            + 48) = v27;
  __src = v45;
  uint64_t v44 = 0x200000000;
  uint64_t v28 = *(mlir::UnknownLoc **)a1;
  int64_t v29 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v42, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v32 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v41, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::Conv2DOp::inferReturnTypes(v28, v29, 1, v42[0], v42[1], Dictionary, v32, v33, v41[0], v41[1], &__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  int v34 = __src;
  }
  uint64_t v35 = v44;
  uint64_t v36 = *(unsigned int *)(a2 + 72);
  unint64_t v37 = v36 + v44;
  if (v37 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v37, 8);
    LODWORD(v36) = *(_DWORD *)(a2 + 72);
  }
  if (v35)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v36), v34, 8 * v35);
    LODWORD(v36) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v36 + v35;
  if (__src != v45) {
    free(__src);
  }
}

BOOL mlir::mps::Conv2DOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    uint64_t v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *v3;
  if (*v3)
  {
    int v5 = (const void **)v3[1];
    if (v5)
    {
      unint64_t v6 = (const void **)v3[2];
      if (v6)
      {
        unint64_t v7 = (const void **)v3[3];
        if (v7)
        {
          uint64_t v8 = v3[4];
          if (v8)
          {
            unint64_t v9 = (const void **)v3[5];
            if (v9)
            {
              uint64_t v10 = v3[6];
              if (v10)
              {
                v50[0] = v2;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v7, (const void **)"groups", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v9, (const void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v8, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v10, (const void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
                {
                  return 0;
                }
                if (*((_DWORD *)*this + 9)) {
                  uint64_t v11 = (uint64_t)(*this - 2);
                }
                else {
                  uint64_t v11 = 0;
                }
                uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
                return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
              }
              uint64_t v47 = "requires attribute 'weights_layout'";
            }
            else
            {
              uint64_t v47 = "requires attribute 'strides'";
            }
            v48[0] = (const void **)v47;
            __int16 v49 = 259;
            mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
            uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v50);
            return v13;
          }
          v48[0] = (const void **)"requires attribute 'padding_style'";
          __int16 v49 = 259;
          mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
          uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          }
          if (v57)
          {
            unsigned int v40 = (void **)__p;
            if (__p)
            {
              uint64_t v41 = v56;
              uint64_t v42 = __p;
              if (v56 != __p)
              {
                do
                  uint64_t v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
                while (v41 != v40);
                uint64_t v42 = __p;
              }
              uint64_t v56 = v40;
              operator delete(v42);
            }
            uint64_t v17 = v53;
            if (!v53) {
              goto LABEL_96;
            }
            __int16 v43 = v54;
            unint64_t v19 = v53;
            if (v54 == v53)
            {
LABEL_95:
              char v54 = v17;
              operator delete(v19);
LABEL_96:
              if (v51 != &v52) {
                free(v51);
              }
              return v13;
            }
            do
            {
              uint64_t v45 = (void *)*--v43;
              uint64_t v44 = v45;
              void *v43 = 0;
              if (v45) {
                operator delete[](v44);
              }
            }
            while (v43 != v17);
LABEL_94:
            unint64_t v19 = v53;
            goto LABEL_95;
          }
        }
        else
        {
          v48[0] = (const void **)"requires attribute 'groups'";
          __int16 v49 = 259;
          mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
          uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          }
          if (v57)
          {
            int v34 = (void **)__p;
            if (__p)
            {
              uint64_t v35 = v56;
              uint64_t v36 = __p;
              if (v56 != __p)
              {
                do
                  uint64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
                while (v35 != v34);
                uint64_t v36 = __p;
              }
              uint64_t v56 = v34;
              operator delete(v36);
            }
            uint64_t v17 = v53;
            if (!v53) {
              goto LABEL_96;
            }
            unint64_t v37 = v54;
            unint64_t v19 = v53;
            if (v54 == v53) {
              goto LABEL_95;
            }
            do
            {
              uint64_t v39 = (void *)*--v37;
              uint64_t v38 = v39;
              *unint64_t v37 = 0;
              if (v39) {
                operator delete[](v38);
              }
            }
            while (v37 != v17);
            goto LABEL_94;
          }
        }
      }
      else
      {
        v48[0] = (const void **)"requires attribute 'explicit_padding'";
        __int16 v49 = 259;
        mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
        uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
        if (v50[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
        }
        if (v57)
        {
          uint64_t v28 = (void **)__p;
          if (__p)
          {
            int64_t v29 = v56;
            int64_t v30 = __p;
            if (v56 != __p)
            {
              do
                int64_t v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
              while (v29 != v28);
              int64_t v30 = __p;
            }
            uint64_t v56 = v28;
            operator delete(v30);
          }
          uint64_t v17 = v53;
          if (!v53) {
            goto LABEL_96;
          }
          uint64_t v31 = v54;
          unint64_t v19 = v53;
          if (v54 == v53) {
            goto LABEL_95;
          }
          do
          {
            int v33 = (void *)*--v31;
            uint64_t v32 = v33;
            *uint64_t v31 = 0;
            if (v33) {
              operator delete[](v32);
            }
          }
          while (v31 != v17);
          goto LABEL_94;
        }
      }
    }
    else
    {
      v48[0] = (const void **)"requires attribute 'dilation_rates'";
      __int16 v49 = 259;
      mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
      uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
      if (v50[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
      }
      if (v57)
      {
        int v22 = (void **)__p;
        if (__p)
        {
          uint64_t v23 = v56;
          uint64_t v24 = __p;
          if (v56 != __p)
          {
            do
              uint64_t v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
            while (v23 != v22);
            uint64_t v24 = __p;
          }
          uint64_t v56 = v22;
          operator delete(v24);
        }
        uint64_t v17 = v53;
        if (!v53) {
          goto LABEL_96;
        }
        uint64_t v25 = v54;
        unint64_t v19 = v53;
        if (v54 == v53) {
          goto LABEL_95;
        }
        do
        {
          uint64_t v27 = (void *)*--v25;
          unint64_t v26 = v27;
          *uint64_t v25 = 0;
          if (v27) {
            operator delete[](v26);
          }
        }
        while (v25 != v17);
        goto LABEL_94;
      }
    }
  }
  else
  {
    v48[0] = (const void **)"requires attribute 'data_layout'";
    __int16 v49 = 259;
    mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
    uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
    if (v50[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
    }
    if (v57)
    {
      unint64_t v14 = (void **)__p;
      if (__p)
      {
        uint64_t v15 = v56;
        uint64_t v16 = __p;
        if (v56 != __p)
        {
          do
            uint64_t v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
          while (v15 != v14);
          uint64_t v16 = __p;
        }
        uint64_t v56 = v14;
        operator delete(v16);
      }
      uint64_t v17 = v53;
      if (!v53) {
        goto LABEL_96;
      }
      uint64_t v18 = v54;
      unint64_t v19 = v53;
      if (v54 == v53) {
        goto LABEL_95;
      }
      do
      {
        uint64_t v21 = (void *)*--v18;
        unint64_t v20 = v21;
        void *v18 = 0;
        if (v21) {
          operator delete[](v20);
        }
      }
      while (v18 != v17);
      goto LABEL_94;
    }
  }
  return v13;
}

uint64_t mlir::mps::Conv2DOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.conv_2d", 11, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC9833B0;
  v4[12] = mlir::mps::Conv2DOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::Conv2DWeightsGradientOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 6uLL:
      if (memcmp(__s1, "groups", __n)) {
        return 0;
      }
      return a2[3];
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[5];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x79616C5F61746164 || *(void *)(__s1 + 3) != 0x74756F79616C5F61) {
        return 0;
      }
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[4];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n)) {
        return a2[1];
      }
      if (memcmp(__s1, "weights_layout", __n)) {
        return 0;
      }
      return a2[6];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::Conv2DWeightsGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  unint64_t v7 = (void *)result;
  switch(__n)
  {
    case 6uLL:
      uint64_t result = memcmp(__s1, "groups", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
            uint64_t v14 = a4;
          }
          else {
            uint64_t v14 = 0;
          }
          v7[3] = v14;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          v7[5] = v8;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x79616C5F61746164 && *(void *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          *(void *)uint64_t result = v10;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v7[4] = v11;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "weights_layout", __n);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
              uint64_t v12 = a4;
            }
            else {
              uint64_t v12 = 0;
            }
            v7[6] = v12;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
        if (result) {
          uint64_t v15 = a4;
        }
        else {
          uint64_t v15 = 0;
        }
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v13 = a4;
          }
          else {
            uint64_t v13 = 0;
          }
          v7[2] = v13;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::Conv2DWeightsGradientOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x38uLL);
    *uint64_t v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    *((void *)v3 + 6) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorB"
              "ase::Properties]";
        unint64_t v14 = 122;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[23];
    return a1[32];
  }
  return result;
}

void mlir::mps::Conv2DWeightsGradientOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, unint64_t a8, uint64_t a9, uint64_t a10, unint64_t a11, unint64_t a12, unint64_t a13, unint64_t a14, unsigned int a15, unsigned int a16, unsigned int a17)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v52 = v54;
  v54[0] = xmmword_181119FA8;
  v54[1] = unk_181119FB8;
  uint64_t v53 = 0x400000004;
  __int16 v49 = v51;
  v51[0] = xmmword_181119FA8;
  v51[1] = unk_181119FB8;
  uint64_t v50 = 0x400000004;
  uint64_t v46 = v48;
  memset(v48, 0, sizeof(v48));
  uint64_t v47 = 0x800000008;
  uint64_t v39 = 0;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v34 = 0u;
  memset(v33, 0, sizeof(v33));
  mlir::mps::buildConv2DDescriptor(a3, a4, a6, a7, a8, a9, a10, a11, (uint64_t)v33, a12, a13, a14, a15, a16, a17, v54, (uint64_t)v51, (uint64_t)v48, 0);
  __int16 v43 = &v45;
  long long v45 = xmmword_18110B5E0;
  uint64_t v44 = 0x200000002;
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  unint64_t v19 = (void *)mlir::RankedTensorType::get((uint64_t)&v45, 2, IntegerType, 0);
  unsigned int v40 = v42;
  v42[0] = 4;
  uint64_t v41 = 0x200000001;
  uint64_t v20 = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  uint64_t v21 = (void *)mlir::RankedTensorType::get((uint64_t)v42, 1, v20, 0);
  int v22 = v21;
  if (v21) {
    uint64_t v23 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v21 + 8);
  }
  else {
    uint64_t v23 = 0;
  }
  uint64_t v24 = mlir::DenseElementsAttr::getFromRawBuffer(v22, v23, v52, 8 * v53, 8, 1, 0);
  if (v22) {
    uint64_t v25 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v22 + 8);
  }
  else {
    uint64_t v25 = 0;
  }
  uint64_t v26 = mlir::DenseElementsAttr::getFromRawBuffer(v22, v25, v49, 8 * v50, 8, 1, 0);
  if (v19) {
    uint64_t v27 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v19 + 8);
  }
  else {
    uint64_t v27 = 0;
  }
  uint64_t v28 = mlir::DenseElementsAttr::getFromRawBuffer(v19, v27, v46, 8 * v47, 8, 1, 0);
  mlir::mps::Conv2DWeightsGradientOp::build(a1, a2, a3, a4, a5, v34, v24, v26, v28, a15, a16, a17);
  if (v40 != v42) {
    free(v40);
  }
  if (v43 != &v45) {
    free(v43);
  }
  if (v46 != v48) {
    free(v46);
  }
  if (v49 != v51) {
    free(v49);
  }
  if (v52 != v54) {
    free(v52);
  }
}

void mlir::mps::Conv2DWeightsGradientOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int a10, unsigned int a11, unsigned int a12)
{
  void v46[2] = *MEMORY[0x1E4F143B8];
  uint64_t v39 = a4;
  uint64_t v40 = a3;
  uint64_t v38 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v40, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v39, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v38, 1);
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  uint64_t IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a6);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 24) = IntegerAttr;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 40) = a7;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = a8;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 16) = a9;
  unint64_t v19 = *(mlir::MLIRContext **)a1;
  unsigned int v41 = a10;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v19);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  uint64_t v45 = (uint64_t)v19;
  uint64_t v21 = mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v41);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 32) = v21;
  int v22 = *(mlir::MLIRContext **)a1;
  unsigned int v41 = a11;
  uint64_t v23 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v22);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  uint64_t v45 = (uint64_t)v22;
  uint64_t v24 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v23, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v41);
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>((void *)a2) = v24;
  uint64_t v25 = *(mlir::MLIRContext **)a1;
  unsigned int v41 = a12;
  uint64_t v26 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v25);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  uint64_t v45 = (uint64_t)v25;
  uint64_t v27 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v26, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v41);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 48) = v27;
  __src = v46;
  uint64_t v45 = 0x200000000;
  uint64_t v28 = *(mlir::UnknownLoc **)a1;
  int64_t v29 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v43, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v32 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v42, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::Conv2DWeightsGradientOp::inferReturnTypes(v28, v29, 1, v43[0], v43[1], Dictionary, v32, v33, v42[0], v42[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  long long v34 = __src;
  }
  uint64_t v35 = v45;
  uint64_t v36 = *(unsigned int *)(a2 + 72);
  unint64_t v37 = v36 + v45;
  if (v37 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v37, 8);
    LODWORD(v36) = *(_DWORD *)(a2 + 72);
  }
  if (v35)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v36), v34, 8 * v35);
    LODWORD(v36) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v36 + v35;
  if (__src != v46) {
    free(__src);
  }
}

BOOL mlir::mps::Conv2DWeightsGradientOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    uint64_t v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *v3;
  if (*v3)
  {
    int v5 = (const void **)v3[1];
    if (v5)
    {
      unint64_t v6 = (const void **)v3[2];
      if (v6)
      {
        unint64_t v7 = (const void **)v3[3];
        if (v7)
        {
          uint64_t v8 = v3[4];
          if (v8)
          {
            unint64_t v9 = (const void **)v3[5];
            if (v9)
            {
              uint64_t v10 = v3[6];
              if (v10)
              {
                v50[0] = v2;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v7, (const void **)"groups", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v9, (const void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v8, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v10, (const void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this,
                                         *(void *)(*(void *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8,
                                         (const void **)"operand",
                                         (const void **)7,
                                         2u))
                {
                  return 0;
                }
                if (*((_DWORD *)*this + 9)) {
                  uint64_t v11 = (uint64_t)(*this - 2);
                }
                else {
                  uint64_t v11 = 0;
                }
                uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
                return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
              }
              uint64_t v47 = "requires attribute 'weights_layout'";
            }
            else
            {
              uint64_t v47 = "requires attribute 'strides'";
            }
            v48[0] = (const void **)v47;
            __int16 v49 = 259;
            mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
            uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v50);
            return v13;
          }
          v48[0] = (const void **)"requires attribute 'padding_style'";
          __int16 v49 = 259;
          mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
          uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          }
          if (v57)
          {
            uint64_t v40 = (void **)__p;
            if (__p)
            {
              unsigned int v41 = v56;
              uint64_t v42 = __p;
              if (v56 != __p)
              {
                do
                  unsigned int v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
                while (v41 != v40);
                uint64_t v42 = __p;
              }
              uint64_t v56 = v40;
              operator delete(v42);
            }
            uint64_t v17 = v53;
            if (!v53) {
              goto LABEL_97;
            }
            __int16 v43 = v54;
            unint64_t v19 = v53;
            if (v54 == v53)
            {
LABEL_96:
              char v54 = v17;
              operator delete(v19);
LABEL_97:
              if (v51 != &v52) {
                free(v51);
              }
              return v13;
            }
            do
            {
              uint64_t v45 = (void *)*--v43;
              uint64_t v44 = v45;
              void *v43 = 0;
              if (v45) {
                operator delete[](v44);
              }
            }
            while (v43 != v17);
LABEL_95:
            unint64_t v19 = v53;
            goto LABEL_96;
          }
        }
        else
        {
          v48[0] = (const void **)"requires attribute 'groups'";
          __int16 v49 = 259;
          mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
          uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          }
          if (v57)
          {
            long long v34 = (void **)__p;
            if (__p)
            {
              uint64_t v35 = v56;
              uint64_t v36 = __p;
              if (v56 != __p)
              {
                do
                  uint64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
                while (v35 != v34);
                uint64_t v36 = __p;
              }
              uint64_t v56 = v34;
              operator delete(v36);
            }
            uint64_t v17 = v53;
            if (!v53) {
              goto LABEL_97;
            }
            unint64_t v37 = v54;
            unint64_t v19 = v53;
            if (v54 == v53) {
              goto LABEL_96;
            }
            do
            {
              uint64_t v39 = (void *)*--v37;
              uint64_t v38 = v39;
              *unint64_t v37 = 0;
              if (v39) {
                operator delete[](v38);
              }
            }
            while (v37 != v17);
            goto LABEL_95;
          }
        }
      }
      else
      {
        v48[0] = (const void **)"requires attribute 'explicit_padding'";
        __int16 v49 = 259;
        mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
        uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
        if (v50[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
        }
        if (v57)
        {
          uint64_t v28 = (void **)__p;
          if (__p)
          {
            int64_t v29 = v56;
            int64_t v30 = __p;
            if (v56 != __p)
            {
              do
                int64_t v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
              while (v29 != v28);
              int64_t v30 = __p;
            }
            uint64_t v56 = v28;
            operator delete(v30);
          }
          uint64_t v17 = v53;
          if (!v53) {
            goto LABEL_97;
          }
          uint64_t v31 = v54;
          unint64_t v19 = v53;
          if (v54 == v53) {
            goto LABEL_96;
          }
          do
          {
            int v33 = (void *)*--v31;
            uint64_t v32 = v33;
            *uint64_t v31 = 0;
            if (v33) {
              operator delete[](v32);
            }
          }
          while (v31 != v17);
          goto LABEL_95;
        }
      }
    }
    else
    {
      v48[0] = (const void **)"requires attribute 'dilation_rates'";
      __int16 v49 = 259;
      mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
      uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
      if (v50[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
      }
      if (v57)
      {
        int v22 = (void **)__p;
        if (__p)
        {
          uint64_t v23 = v56;
          uint64_t v24 = __p;
          if (v56 != __p)
          {
            do
              uint64_t v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
            while (v23 != v22);
            uint64_t v24 = __p;
          }
          uint64_t v56 = v22;
          operator delete(v24);
        }
        uint64_t v17 = v53;
        if (!v53) {
          goto LABEL_97;
        }
        uint64_t v25 = v54;
        unint64_t v19 = v53;
        if (v54 == v53) {
          goto LABEL_96;
        }
        do
        {
          uint64_t v27 = (void *)*--v25;
          uint64_t v26 = v27;
          *uint64_t v25 = 0;
          if (v27) {
            operator delete[](v26);
          }
        }
        while (v25 != v17);
        goto LABEL_95;
      }
    }
  }
  else
  {
    v48[0] = (const void **)"requires attribute 'data_layout'";
    __int16 v49 = 259;
    mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
    uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
    if (v50[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
    }
    if (v57)
    {
      unint64_t v14 = (void **)__p;
      if (__p)
      {
        uint64_t v15 = v56;
        uint64_t v16 = __p;
        if (v56 != __p)
        {
          do
            uint64_t v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
          while (v15 != v14);
          uint64_t v16 = __p;
        }
        uint64_t v56 = v14;
        operator delete(v16);
      }
      uint64_t v17 = v53;
      if (!v53) {
        goto LABEL_97;
      }
      uint64_t v18 = v54;
      unint64_t v19 = v53;
      if (v54 == v53) {
        goto LABEL_96;
      }
      do
      {
        uint64_t v21 = (void *)*--v18;
        uint64_t v20 = v21;
        void *v18 = 0;
        if (v21) {
          operator delete[](v20);
        }
      }
      while (v18 != v17);
      goto LABEL_95;
    }
  }
  return v13;
}

uint64_t mlir::mps::Conv2DWeightsGradientOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.conv_2d_weights_gradient", 28, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC981CA8;
  v4[12] = mlir::mps::Conv2DWeightsGradientOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Conv3DDataGradientOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v13, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *(_OWORD *)v5;
  long long v9 = *(_OWORD *)(v5 + 16);
  long long v10 = *(_OWORD *)(v5 + 32);
  *(void *)(a1 + 72) = *(void *)(v5 + 48);
  *(_OWORD *)(a1 + 56) = v10;
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)v13;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.conv_3d_data_gradient", 25, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t llvm::all_of<mlir::DenseIntElementsAttr,mlir::mps::Conv3DDataGradientOpAdaptor::verify(mlir::Location)::$_0>(uint64_t *a1)
{
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v10, *a1, 0);
  uint64_t v2 = *a1;
  uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)a1);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v7, v2, NumElements);
  while (1)
  {
    BOOL v4 = v10 == v7 && v11 == v8;
    if (v4 && v12 == v9) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*(&v10, (llvm::APInt *)&v13);
    if (v14 <= 0x40)
    {
      if (!v13) {
        return 0;
      }
    }
    else
    {
      uint64_t v5 = *v13;
      operator delete[](v13);
      if (!v5) {
        return 0;
      }
    }
    ++v12;
  }
  return 1;
}

uint64_t mlir::mps::Conv3DDataGradientOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 6uLL:
      if (memcmp(__s1, "groups", __n)) {
        return 0;
      }
      return a2[3];
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[5];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x79616C5F61746164 || *(void *)(__s1 + 3) != 0x74756F79616C5F61) {
        return 0;
      }
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[4];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n)) {
        return a2[1];
      }
      if (memcmp(__s1, "weights_layout", __n)) {
        return 0;
      }
      return a2[6];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::Conv3DDataGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  uint64_t v7 = (void *)result;
  switch(__n)
  {
    case 6uLL:
      uint64_t result = memcmp(__s1, "groups", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
            uint64_t v14 = a4;
          }
          else {
            uint64_t v14 = 0;
          }
          v7[3] = v14;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          v7[5] = v8;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x79616C5F61746164 && *(void *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          *(void *)uint64_t result = v10;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v7[4] = v11;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "weights_layout", __n);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
              uint64_t v12 = a4;
            }
            else {
              uint64_t v12 = 0;
            }
            v7[6] = v12;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
        if (result) {
          uint64_t v15 = a4;
        }
        else {
          uint64_t v15 = 0;
        }
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v13 = a4;
          }
          else {
            uint64_t v13 = 0;
          }
          v7[2] = v13;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::Conv3DDataGradientOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = (_DWORD *)mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(v8, (const void **)"data_layout", (const char *)0xB, a3, a4))
  {
    uint64_t v9 = (void *)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v9, (const void **)"dilation_rates", (const char *)0xE, (void (*)(const void ***__return_ptr, uint64_t))a3, a4))
    {
      uint64_t v10 = (const void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(v10, (const void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))a3, a4))
      {
        uint64_t v11 = (const void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 24));
        if (!v11
          || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v11, (const void **)"groups", (const char *)6, a3, a4))
        {
          uint64_t v12 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v12, (const void **)"padding_style", (const char *)0xD, a3, a4))
          {
            uint64_t v13 = (void *)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v13, (const void **)"strides", (const char *)7, (void (*)(const void ***__return_ptr, uint64_t))a3, a4))
            {
              uint64_t v14 = (_DWORD *)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 48));
              if (!v14
                || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(v14, (const void **)"weights_layout", (const char *)0xE, a3, a4))
              {
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(_DWORD *a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id
    && (a1[2] - 7) < 2)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    int64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v8 = &v29;
    uint64_t v9 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v9 = (char *)v35;
        uint64_t v8 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = &v29;
        uint64_t v9 = (char *)v35;
      }
    }
    uint64_t v10 = &v9[24 * v36];
    long long v11 = *(_OWORD *)v8;
    *((void *)v10 + 2) = v8[2];
    *(_OWORD *)uint64_t v10 = v11;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      int64_t v29 = a2;
      int64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        int64_t v30 = "' failed to satisfy constraint: valid TensorDataLayout is one of NDHWC or NCDHW";
        uint64_t v31 = 79;
        uint64_t v12 = &v29;
        uint64_t v13 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v13 = (char *)v35;
            uint64_t v12 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = &v29;
            uint64_t v13 = (char *)v35;
          }
        }
        uint64_t v14 = &v13[24 * v36];
        long long v15 = *(_OWORD *)v12;
        *((void *)v14 + 2) = v12[2];
        *(_OWORD *)uint64_t v14 = v15;
        ++v36;
      }
    }
  }
  uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    uint64_t v16 = (void **)__p;
    if (__p)
    {
      uint64_t v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          uint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      uint64_t v42 = v16;
      operator delete(v18);
    }
    unint64_t v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      uint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = (void *)*--v20;
          int v22 = v23;
          *uint64_t v20 = 0;
          if (v23) {
            operator delete[](v22);
          }
        }
        while (v20 != v19);
        uint64_t v21 = v39;
      }
      uint64_t v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v7;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(void *a1, const void **a2, const char *a3, void (*a4)(const void ***__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 1;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1)) {
    goto LABEL_7;
  }
  uint64_t v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*a1 + 8);
  v45[0] = a1;
  v45[1] = v10;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v45);
  uint64_t v12 = Type;
  if (Type) {
    Type = (void *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  }
  v46[0] = v12;
  v46[1] = Type;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v46);
  uint64_t v65 = 5;
  if (v14 != 1 || *ArgAttrsAttr != v65) {
    goto LABEL_7;
  }
  uint64_t v44 = a1;
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v53, (uint64_t)a1, 0);
  uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v44);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v49, (uint64_t)a1, NumElements);
  while (1)
  {
    BOOL v34 = v53 == v49 && v54[0] == v50;
    if (v34 && v55 == v51) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v53, (llvm::APInt *)&v47);
    if (v48 > 0x40)
    {
      uint64_t v33 = *(void *)v47;
      operator delete[](v47);
      if (!v33) {
        goto LABEL_7;
      }
    }
    else if (!v47)
    {
      goto LABEL_7;
    }
    ++v55;
  }
  unsigned int v41 = a1;
  v42[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v41);
  v42[1] = v35;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v42);
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
    return 1;
  }
LABEL_7:
  a4(&v53, a5);
  if (v53)
  {
    LODWORD(v49) = 3;
    uint64_t v50 = "attribute '";
    uint64_t v51 = 11;
    long long v15 = &v49;
    uint64_t v16 = (char *)v56;
    if (v57 >= v58)
    {
      unint64_t v37 = v57 + 1;
      if (v56 <= &v49 && (char *)v56 + 24 * v57 > (char *)&v49)
      {
        int64_t v39 = (char *)&v49 - (unsigned char *)v56;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v37, 24);
        uint64_t v16 = (char *)v56;
        long long v15 = (const void ***)((char *)v56 + v39);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v37, 24);
        long long v15 = &v49;
        uint64_t v16 = (char *)v56;
      }
    }
    uint64_t v17 = &v16[24 * v57];
    long long v18 = *(_OWORD *)v15;
    *((void *)v17 + 2) = v15[2];
    *(_OWORD *)uint64_t v17 = v18;
    ++v57;
    if (v53)
    {
      __int16 v52 = 261;
      __int16 v49 = a2;
      uint64_t v50 = a3;
      mlir::Diagnostic::operator<<((uint64_t)v54, &v49);
      if (v53)
      {
        LODWORD(v49) = 3;
        uint64_t v50 = "' failed to satisfy constraint: positive ui64 elements attribute of shape {5}";
        uint64_t v51 = 77;
        unint64_t v19 = &v49;
        uint64_t v20 = (char *)v56;
        if (v57 >= v58)
        {
          unint64_t v38 = v57 + 1;
          if (v56 <= &v49 && (char *)v56 + 24 * v57 > (char *)&v49)
          {
            int64_t v40 = (char *)&v49 - (unsigned char *)v56;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v38, 24);
            uint64_t v20 = (char *)v56;
            unint64_t v19 = (const void ***)((char *)v56 + v40);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v38, 24);
            unint64_t v19 = &v49;
            uint64_t v20 = (char *)v56;
          }
        }
        uint64_t v21 = &v20[24 * v57];
        long long v22 = *(_OWORD *)v19;
        *((void *)v21 + 2) = v19[2];
        *(_OWORD *)uint64_t v21 = v22;
        ++v57;
      }
    }
  }
  uint64_t v23 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v53);
  if (v53) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v53);
  }
  if (v64)
  {
    uint64_t v24 = (void **)__p;
    if (__p)
    {
      unint64_t v25 = v63;
      unint64_t v26 = __p;
      if (v63 != __p)
      {
        do
          unint64_t v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
        while (v25 != v24);
        unint64_t v26 = __p;
      }
      uint64_t v63 = v24;
      operator delete(v26);
    }
    int64_t v27 = v60;
    if (v60)
    {
      int64_t v28 = v61;
      int64_t v29 = v60;
      if (v61 != v60)
      {
        do
        {
          uint64_t v31 = (void *)*--v28;
          int64_t v30 = v31;
          void *v28 = 0;
          if (v31) {
            operator delete[](v30);
          }
        }
        while (v28 != v27);
        int64_t v29 = v60;
      }
      uint64_t v61 = v27;
      operator delete(v29);
    }
    if (v56 != v59) {
      free(v56);
    }
  }
  return v23;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(const void **a1, const void **a2, const char *a3, void (*a4)(void **__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 1;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1)) {
    goto LABEL_13;
  }
  uint64_t v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>((uint64_t)*a1 + 8);
  uint64_t v42 = a1;
  char v43 = (const char *)v10;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v42);
  uint64_t v12 = Type;
  if (Type) {
    Type = (void *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  }
  uint64_t v46 = v12;
  uint64_t v47 = Type;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v46);
  long long v57 = xmmword_1810FE2F0;
  if (v14 == 2 && *ArgAttrsAttr == (void)v57 && ArgAttrsAttr[1] == *((void *)&v57 + 1))
  {
    int64_t v39 = a1;
    v40[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v39);
    v40[1] = v16;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v40);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
  }
LABEL_13:
  a4(&v46, a5);
  if (v46)
  {
    LODWORD(v42) = 3;
    char v43 = "attribute '";
    uint64_t v44 = 11;
    long long v18 = &v42;
    unint64_t v19 = (char *)v48;
    if (v49 >= v50)
    {
      unint64_t v35 = v49 + 1;
      if (v48 <= &v42 && (char *)v48 + 24 * v49 > (char *)&v42)
      {
        int64_t v37 = (char *)&v42 - (unsigned char *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
        unint64_t v19 = (char *)v48;
        long long v18 = (const void ***)((char *)v48 + v37);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
        long long v18 = &v42;
        unint64_t v19 = (char *)v48;
      }
    }
    uint64_t v20 = &v19[24 * v49];
    long long v21 = *(_OWORD *)v18;
    *((void *)v20 + 2) = v18[2];
    *(_OWORD *)uint64_t v20 = v21;
    ++v49;
    if (v46)
    {
      __int16 v45 = 261;
      uint64_t v42 = a2;
      char v43 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v47, &v42);
      if (v46)
      {
        LODWORD(v42) = 3;
        char v43 = "' failed to satisfy constraint: ui64 elements attribute of shape {5, 2}";
        uint64_t v44 = 71;
        long long v22 = &v42;
        uint64_t v23 = (char *)v48;
        if (v49 >= v50)
        {
          unint64_t v36 = v49 + 1;
          if (v48 <= &v42 && (char *)v48 + 24 * v49 > (char *)&v42)
          {
            int64_t v38 = (char *)&v42 - (unsigned char *)v48;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v36, 24);
            uint64_t v23 = (char *)v48;
            long long v22 = (const void ***)((char *)v48 + v38);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v36, 24);
            long long v22 = &v42;
            uint64_t v23 = (char *)v48;
          }
        }
        uint64_t v24 = &v23[24 * v49];
        long long v25 = *(_OWORD *)v22;
        *((void *)v24 + 2) = v22[2];
        *(_OWORD *)uint64_t v24 = v25;
        ++v49;
      }
    }
  }
  uint64_t v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v46);
  if (v46) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v46);
  }
  if (v56)
  {
    unint64_t v26 = (void **)__p;
    if (__p)
    {
      int64_t v27 = v55;
      int64_t v28 = __p;
      if (v55 != __p)
      {
        do
          int64_t v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
        while (v27 != v26);
        int64_t v28 = __p;
      }
      uint64_t v55 = v26;
      operator delete(v28);
    }
    int64_t v29 = v52;
    if (v52)
    {
      int64_t v30 = v53;
      uint64_t v31 = v52;
      if (v53 != v52)
      {
        do
        {
          uint64_t v33 = (void *)*--v30;
          __int16 v32 = v33;
          *int64_t v30 = 0;
          if (v33) {
            operator delete[](v32);
          }
        }
        while (v30 != v29);
        uint64_t v31 = v52;
      }
      uint64_t v53 = v29;
      operator delete(v31);
    }
    if (v48 != v51) {
      free(v48);
    }
  }
  return v17;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(_DWORD *a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id
    && (a1[2] - 9) < 2)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    int64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v8 = &v29;
    uint64_t v9 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v9 = (char *)v35;
        uint64_t v8 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = &v29;
        uint64_t v9 = (char *)v35;
      }
    }
    uint64_t v10 = &v9[24 * v36];
    long long v11 = *(_OWORD *)v8;
    *((void *)v10 + 2) = v8[2];
    *(_OWORD *)uint64_t v10 = v11;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      int64_t v29 = a2;
      int64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        int64_t v30 = "' failed to satisfy constraint: valid TensorDataLayout is one of DHWIO or OIDHW";
        uint64_t v31 = 79;
        uint64_t v12 = &v29;
        uint64_t v13 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v13 = (char *)v35;
            uint64_t v12 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = &v29;
            uint64_t v13 = (char *)v35;
          }
        }
        uint64_t v14 = &v13[24 * v36];
        long long v15 = *(_OWORD *)v12;
        *((void *)v14 + 2) = v12[2];
        *(_OWORD *)uint64_t v14 = v15;
        ++v36;
      }
    }
  }
  uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    uint64_t v16 = (void **)__p;
    if (__p)
    {
      uint64_t v17 = v42;
      long long v18 = __p;
      if (v42 != __p)
      {
        do
          uint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        long long v18 = __p;
      }
      uint64_t v42 = v16;
      operator delete(v18);
    }
    unint64_t v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      long long v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = (void *)*--v20;
          long long v22 = v23;
          *uint64_t v20 = 0;
          if (v23) {
            operator delete[](v22);
          }
        }
        while (v20 != v19);
        long long v21 = v39;
      }
      int64_t v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v7;
}

BOOL mlir::mps::Conv3DDataGradientOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x38uLL);
    *uint64_t v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    *((void *)v3 + 6) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 119;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[25];
    return a1[32];
  }
  return result;
}

void mlir::mps::Conv3DDataGradientOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t *a9, uint64_t a10, uint64_t *a11, uint64_t a12, unsigned int a13, unsigned int a14, unsigned int a15)
{
  uint64_t v17 = mlir::mps::get5DElementsAttrFrom3DSpatialValues(a1, a7, a8, a14);
  uint64_t v18 = mlir::mps::get5DElementsAttrFrom3DSpatialValues(a1, a9, a10, a14);
  uint64_t v24 = mlir::mps::get5DElementsAttrFrom3DPaddingValues(a1, a11, a12, a14);

  mlir::mps::Conv3DDataGradientOp::build(a1, a2, a3, a4, a5, a6, v17, v18, v24, a13, a14, a15);
}

void mlir::mps::Conv3DDataGradientOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int a10, unsigned int a11, unsigned int a12)
{
  v48[2] = *MEMORY[0x1E4F143B8];
  uint64_t v41 = a4;
  uint64_t v42 = a3;
  uint64_t v40 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v42, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v41, 1);
  if (a5) {
    mlir::OperationState::addOperands(a2, (uint64_t)&v40, 1);
  }
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  uint64_t IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a6);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 24) = IntegerAttr;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 40) = a7;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = a8;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 16) = a9;
  uint64_t v20 = *(mlir::MLIRContext **)a1;
  unsigned int v43 = a10;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v20);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  uint64_t v47 = (uint64_t)v20;
  uint64_t v22 = mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v43);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 32) = v22;
  uint64_t v23 = *(mlir::MLIRContext **)a1;
  unsigned int v43 = a11;
  uint64_t v24 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v23);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  uint64_t v47 = (uint64_t)v23;
  uint64_t v25 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v24, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v43);
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>((void *)a2) = v25;
  unint64_t v26 = *(mlir::MLIRContext **)a1;
  unsigned int v43 = a12;
  int64_t v27 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v26);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  uint64_t v47 = (uint64_t)v26;
  uint64_t v28 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v27, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v43);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 48) = v28;
  __src = v48;
  uint64_t v47 = 0x200000000;
  int64_t v29 = *(mlir::UnknownLoc **)a1;
  mlir::ValueRange::ValueRange(v45, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  __int16 v32 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v44, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::Conv3DDataGradientOp::inferReturnTypes(v29, v33, v34, v45[0], v45[1], Dictionary, v32, v35, v44[0], v44[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  unsigned int v36 = __src;
  }
  uint64_t v37 = v47;
  uint64_t v38 = *(unsigned int *)(a2 + 72);
  unint64_t v39 = v38 + v47;
  if (v39 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v39, 8);
    LODWORD(v38) = *(_DWORD *)(a2 + 72);
  }
  if (v37)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v38), v36, 8 * v37);
    LODWORD(v38) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v38 + v37;
  if (__src != v48) {
    free(__src);
  }
}

BOOL mlir::mps::Conv3DDataGradientOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    unint64_t v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    unint64_t v3 = 0;
  }
  BOOL v4 = *(_DWORD **)v3;
  if (!*(void *)v3)
  {
    v66[0] = (const void **)"requires attribute 'data_layout'";
    __int16 v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    uint64_t v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    }
    if (!v75) {
      return v27;
    }
    uint64_t v28 = (void **)__p;
    if (__p)
    {
      int64_t v29 = v74;
      int64_t v30 = __p;
      if (v74 != __p)
      {
        do
          int64_t v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
        while (v29 != v28);
        int64_t v30 = __p;
      }
      unint64_t v74 = v28;
      operator delete(v30);
    }
    uint64_t v31 = v71;
    if (v71)
    {
      __int16 v32 = v72;
      uint64_t v33 = v71;
      if (v72 == v71) {
        goto LABEL_97;
      }
      do
      {
        int v35 = (void *)*--v32;
        int v34 = v35;
        *__int16 v32 = 0;
        if (v35) {
          operator delete[](v34);
        }
      }
      while (v32 != v31);
LABEL_96:
      uint64_t v33 = v71;
LABEL_97:
      unint64_t v72 = v31;
      operator delete(v33);
    }
LABEL_98:
    if (v69 != &v70) {
      free(v69);
    }
    return v27;
  }
  int v5 = *(void **)(v3 + 8);
  if (!v5)
  {
    v66[0] = (const void **)"requires attribute 'dilation_rates'";
    __int16 v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    uint64_t v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    }
    if (!v75) {
      return v27;
    }
    unsigned int v36 = (void **)__p;
    if (__p)
    {
      uint64_t v37 = v74;
      uint64_t v38 = __p;
      if (v74 != __p)
      {
        do
          uint64_t v37 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v37 - 1);
        while (v37 != v36);
        uint64_t v38 = __p;
      }
      unint64_t v74 = v36;
      operator delete(v38);
    }
    uint64_t v31 = v71;
    if (v71)
    {
      unint64_t v39 = v72;
      uint64_t v33 = v71;
      if (v72 == v71) {
        goto LABEL_97;
      }
      do
      {
        uint64_t v41 = (void *)*--v39;
        uint64_t v40 = v41;
        void *v39 = 0;
        if (v41) {
          operator delete[](v40);
        }
      }
      while (v39 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  unint64_t v6 = *(const void ***)(v3 + 16);
  if (!v6)
  {
    v66[0] = (const void **)"requires attribute 'explicit_padding'";
    __int16 v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    uint64_t v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    }
    if (!v75) {
      return v27;
    }
    uint64_t v42 = (void **)__p;
    if (__p)
    {
      unsigned int v43 = v74;
      uint64_t v44 = __p;
      if (v74 != __p)
      {
        do
          unsigned int v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v43 - 1);
        while (v43 != v42);
        uint64_t v44 = __p;
      }
      unint64_t v74 = v42;
      operator delete(v44);
    }
    uint64_t v31 = v71;
    if (v71)
    {
      __int16 v45 = v72;
      uint64_t v33 = v71;
      if (v72 == v71) {
        goto LABEL_97;
      }
      do
      {
        uint64_t v47 = (void *)*--v45;
        uint64_t v46 = v47;
        *__int16 v45 = 0;
        if (v47) {
          operator delete[](v46);
        }
      }
      while (v45 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  unint64_t v7 = *(const void ***)(v3 + 24);
  if (!v7)
  {
    v66[0] = (const void **)"requires attribute 'groups'";
    __int16 v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    uint64_t v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    }
    if (!v75) {
      return v27;
    }
    unsigned int v48 = (void **)__p;
    if (__p)
    {
      unsigned int v49 = v74;
      unsigned int v50 = __p;
      if (v74 != __p)
      {
        do
          unsigned int v49 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v49 - 1);
        while (v49 != v48);
        unsigned int v50 = __p;
      }
      unint64_t v74 = v48;
      operator delete(v50);
    }
    uint64_t v31 = v71;
    if (v71)
    {
      uint64_t v51 = v72;
      uint64_t v33 = v71;
      if (v72 == v71) {
        goto LABEL_97;
      }
      do
      {
        uint64_t v53 = (void *)*--v51;
        __int16 v52 = v53;
        *uint64_t v51 = 0;
        if (v53) {
          operator delete[](v52);
        }
      }
      while (v51 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  uint64_t v8 = *(void *)(v3 + 32);
  if (!v8)
  {
    v66[0] = (const void **)"requires attribute 'padding_style'";
    __int16 v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    uint64_t v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    }
    if (!v75) {
      return v27;
    }
    char v54 = (void **)__p;
    if (__p)
    {
      uint64_t v55 = v74;
      char v56 = __p;
      if (v74 != __p)
      {
        do
          uint64_t v55 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v55 - 1);
        while (v55 != v54);
        char v56 = __p;
      }
      unint64_t v74 = v54;
      operator delete(v56);
    }
    uint64_t v31 = v71;
    if (v71)
    {
      long long v57 = v72;
      uint64_t v33 = v71;
      if (v72 == v71) {
        goto LABEL_97;
      }
      do
      {
        uint64_t v59 = (void *)*--v57;
        uint64_t v58 = v59;
        *long long v57 = 0;
        if (v59) {
          operator delete[](v58);
        }
      }
      while (v57 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  unint64_t v9 = *(void **)(v3 + 40);
  if (!v9)
  {
    uint64_t v61 = "requires attribute 'strides'";
LABEL_103:
    v66[0] = (const void **)v61;
    __int16 v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    unint64_t v26 = v68;
    goto LABEL_104;
  }
  uint64_t v10 = *(_DWORD **)(v3 + 48);
  if (!v10)
  {
    uint64_t v61 = "requires attribute 'weights_layout'";
    goto LABEL_103;
  }
  v68[0] = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v7, (const void **)"groups", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  v68[0] = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v9, (const void **)"strides", (const char *)7, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  v68[0] = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  v68[0] = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  v68[0] = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v8, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  v68[0] = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  v68[0] = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(v10, (const void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  unint64_t v11 = *this;
  }
  uint64_t v12 = (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  unsigned int v65 = 1;
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(v11, v12, (const void **)"operand", 7, 0))return 0; {
  unsigned int v13 = 1;
  }
  uint64_t ODSOperands = mlir::tensor::UnPackOp::getODSOperands((mlir::tensor::UnPackOp *)this, 1u);
  if (v15)
  {
    uint64_t v16 = v15;
    uint64_t v17 = 0;
    uint64_t v18 = ODSOperands + 24;
    while (1)
    {
      unint64_t v19 = *this;
      uint64_t v20 = (const void **)(*(void *)(*(void *)v18 + 8) & 0xFFFFFFFFFFFFFFF8);
      unsigned int v65 = v17 + 2;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps14(v19, v20, (const void **)"operand", 7, (int)v17 + 1))return 0; {
      ++v17;
      }
      v18 += 32;
      if (v16 == v17)
      {
        unsigned int v13 = v17 + 1;
        break;
      }
    }
  }
  uint64_t v21 = mlir::tensor::UnPackOp::getODSOperands((mlir::tensor::UnPackOp *)this, 2u);
  uint64_t v23 = v22;
  if (v22 >= 2)
  {
    v66[0] = (const void **)"operand group starting at #";
    __int16 v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    uint64_t v24 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v68, &v65);
    uint64_t v25 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v24, " requires 0 or 1 element, but found ");
    uint64_t v64 = v23;
    unint64_t v26 = (void *)mlir::InFlightDiagnostic::operator<<<unsigned long &>(v25, &v64);
LABEL_104:
    uint64_t v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v26);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v68);
    return v27;
  }
  if (v22
    && !mlir::mps::__mlir_ods_local_type_constraint_MPSOps15(*this, (const void **)(*(void *)(*(void *)(v21 + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, v13))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v62 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v62 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v62, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *a2;
  unint64_t v11 = (void *)*((void *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v62[0] = a2;
    v62[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v62);
    if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isF16((mlir::Type *)&OperandRange)
      || mlir::Type::isF32((mlir::Type *)&OperandRange)
      || mlir::Type::isBF16((mlir::Type *)&OperandRange)
      || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
    {
      return 1;
    }
    uint64_t v10 = *a2;
    uint64_t v42 = (void *)*((void *)*a2 + 17);
    if (v42 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v42 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_21;
    }
  }
  else if (v11 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id {
         && v11 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  }
  {
    goto LABEL_21;
  }
  uint64_t v55 = a2;
  uint64_t v56 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v55);
  if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
    || mlir::Type::isF16((mlir::Type *)&OperandRange)
    || mlir::Type::isF32((mlir::Type *)&OperandRange)
    || mlir::Type::isBF16((mlir::Type *)&OperandRange)
    || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
  {
    uint64_t v13 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
    uint64_t v59 = a2;
    uint64_t v60 = v13;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v59);
    if (v14 >= 5) {
      return 1;
    }
  }
LABEL_21:
  __int16 v57 = 261;
  uint64_t v55 = a3;
  uint64_t v56 = a4;
  mlir::Operation::emitOpError(a1, &v55, (uint64_t)v62);
  if (v62[0])
  {
    LODWORD(v59) = 3;
    uint64_t v60 = (uint64_t)" #";
    uint64_t v61 = 2;
    uint64_t v15 = &v59;
    uint64_t v16 = (char *)v63;
    if (v64 >= v65)
    {
      unint64_t v45 = v64 + 1;
      if (v63 <= &v59 && (char *)v63 + 24 * v64 > (char *)&v59)
      {
        int64_t v51 = (char *)&v59 - (unsigned char *)v63;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v45, 24);
        uint64_t v16 = (char *)v63;
        uint64_t v15 = (const void ***)((char *)v63 + v51);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v45, 24);
        uint64_t v15 = &v59;
        uint64_t v16 = (char *)v63;
      }
    }
    uint64_t v17 = &v16[24 * v64];
    long long v18 = *(_OWORD *)v15;
    *((void *)v17 + 2) = v15[2];
    *(_OWORD *)uint64_t v17 = v18;
    uint64_t v19 = ++v64;
    if (v62[0])
    {
      LODWORD(v59) = 5;
      uint64_t v60 = a5;
      uint64_t v20 = &v59;
      uint64_t v21 = (char *)v63;
      if (v19 >= v65)
      {
        unint64_t v46 = v19 + 1;
        BOOL v47 = (char *)v63 + 24 * v19 > (char *)&v59;
        if (v63 <= &v59 && v47)
        {
          int64_t v52 = (char *)&v59 - (unsigned char *)v63;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v46, 24);
          uint64_t v21 = (char *)v63;
          uint64_t v20 = (const void ***)((char *)v63 + v52);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v46, 24);
          uint64_t v20 = &v59;
          uint64_t v21 = (char *)v63;
        }
      }
      unint64_t v22 = &v21[24 * v64];
      long long v23 = *(_OWORD *)v20;
      *((void *)v22 + 2) = v20[2];
      *(_OWORD *)unint64_t v22 = v23;
      uint64_t v24 = ++v64;
      if (v62[0])
      {
        LODWORD(v59) = 3;
        uint64_t v60 = (uint64_t)" must be unranked tensor of mps native type values or ranked tensor type with rank equal to or gr"
                       "eater than 5, but got ";
        uint64_t v61 = 119;
        uint64_t v25 = &v59;
        unint64_t v26 = (char *)v63;
        if (v24 >= v65)
        {
          unint64_t v48 = v24 + 1;
          BOOL v49 = (char *)v63 + 24 * v24 > (char *)&v59;
          if (v63 <= &v59 && v49)
          {
            int64_t v53 = (char *)&v59 - (unsigned char *)v63;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v48, 24);
            unint64_t v26 = (char *)v63;
            uint64_t v25 = (const void ***)((char *)v63 + v53);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v48, 24);
            uint64_t v25 = &v59;
            unint64_t v26 = (char *)v63;
          }
        }
        uint64_t v27 = &v26[24 * v64];
        long long v28 = *(_OWORD *)v25;
        *((void *)v27 + 2) = v25[2];
        *(_OWORD *)uint64_t v27 = v28;
        ++v64;
        if (v62[0])
        {
          int64_t v29 = &v59;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v59, (uint64_t)a2);
          int64_t v30 = (char *)v63;
          if (v64 >= v65)
          {
            unint64_t v50 = v64 + 1;
            if (v63 <= &v59 && (char *)v63 + 24 * v64 > (char *)&v59)
            {
              int64_t v54 = (char *)&v59 - (unsigned char *)v63;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v50, 24);
              int64_t v30 = (char *)v63;
              int64_t v29 = (const void ***)((char *)v63 + v54);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v50, 24);
              int64_t v29 = &v59;
              int64_t v30 = (char *)v63;
            }
          }
          uint64_t v31 = &v30[24 * v64];
          long long v32 = *(_OWORD *)v29;
          *((void *)v31 + 2) = v29[2];
          *(_OWORD *)uint64_t v31 = v32;
          ++v64;
        }
      }
    }
  }
  uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v62);
  if (v62[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v62);
  }
  if (v71)
  {
    int v34 = (void **)__p;
    if (__p)
    {
      int v35 = v70;
      unsigned int v36 = __p;
      if (v70 != __p)
      {
        do
          int v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        unsigned int v36 = __p;
      }
      uint64_t v70 = v34;
      operator delete(v36);
    }
    uint64_t v37 = v67;
    if (v67)
    {
      uint64_t v38 = v68;
      unint64_t v39 = v67;
      if (v68 != v67)
      {
        do
        {
          uint64_t v41 = (void *)*--v38;
          uint64_t v40 = v41;
          void *v38 = 0;
          if (v41) {
            operator delete[](v40);
          }
        }
        while (v38 != v37);
        unint64_t v39 = v67;
      }
      unint64_t v68 = v37;
      operator delete(v39);
    }
    if (v63 != v66) {
      free(v63);
    }
  }
  return v33;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps14(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *a2;
  unint64_t v11 = (void *)*((void *)*a2 + 17);
  if (v11 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    if (v11 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
      goto LABEL_33;
    }
    goto LABEL_3;
  }
  v61[0] = a2;
  v61[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
  if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
    || mlir::Type::isF16((mlir::Type *)&OperandRange)
    || mlir::Type::isF32((mlir::Type *)&OperandRange)
    || mlir::Type::isBF16((mlir::Type *)&OperandRange)
    || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
  {
    return 1;
  }
  uint64_t v10 = *a2;
  if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
LABEL_3:
    int64_t v53 = a2;
    uint64_t v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53))
    {
      uint64_t v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      uint64_t v58 = a2;
      uint64_t v59 = v12;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
      if (v13 == 5)
      {
        uint64_t v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
        v56[0] = a2;
        v56[1] = v14;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
        if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isF16((mlir::Type *)&OperandRange)
          || mlir::Type::isF32((mlir::Type *)&OperandRange)
          || mlir::Type::isBF16((mlir::Type *)&OperandRange)
          || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
        {
          return 1;
        }
      }
    }
  }
LABEL_33:
  __int16 v55 = 261;
  int64_t v53 = a3;
  uint64_t v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v61);
  if (v61[0])
  {
    LODWORD(v58) = 3;
    uint64_t v59 = (uint64_t)" #";
    uint64_t v60 = 2;
    uint64_t v15 = &v58;
    uint64_t v16 = (char *)v62;
    if (v63 >= v64)
    {
      unint64_t v43 = v63 + 1;
      if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
      {
        int64_t v49 = (char *)&v58 - (unsigned char *)v62;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        uint64_t v16 = (char *)v62;
        uint64_t v15 = (const void ***)((char *)v62 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        uint64_t v15 = &v58;
        uint64_t v16 = (char *)v62;
      }
    }
    uint64_t v17 = &v16[24 * v63];
    long long v18 = *(_OWORD *)v15;
    *((void *)v17 + 2) = v15[2];
    *(_OWORD *)uint64_t v17 = v18;
    uint64_t v19 = ++v63;
    if (v61[0])
    {
      LODWORD(v58) = 5;
      uint64_t v59 = a5;
      uint64_t v20 = &v58;
      uint64_t v21 = (char *)v62;
      if (v19 >= v64)
      {
        unint64_t v44 = v19 + 1;
        BOOL v45 = (char *)v62 + 24 * v19 > (char *)&v58;
        if (v62 <= &v58 && v45)
        {
          int64_t v50 = (char *)&v58 - (unsigned char *)v62;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          uint64_t v21 = (char *)v62;
          uint64_t v20 = (const void ***)((char *)v62 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          uint64_t v20 = &v58;
          uint64_t v21 = (char *)v62;
        }
      }
      unint64_t v22 = &v21[24 * v63];
      long long v23 = *(_OWORD *)v20;
      *((void *)v22 + 2) = v20[2];
      *(_OWORD *)unint64_t v22 = v23;
      uint64_t v24 = ++v63;
      if (v61[0])
      {
        LODWORD(v58) = 3;
        uint64_t v59 = (uint64_t)" must be unranked tensor of mps native type values or 5D tensor of mps native type values, but got ";
        uint64_t v60 = 99;
        uint64_t v25 = &v58;
        unint64_t v26 = (char *)v62;
        if (v24 >= v64)
        {
          unint64_t v46 = v24 + 1;
          BOOL v47 = (char *)v62 + 24 * v24 > (char *)&v58;
          if (v62 <= &v58 && v47)
          {
            int64_t v51 = (char *)&v58 - (unsigned char *)v62;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            unint64_t v26 = (char *)v62;
            uint64_t v25 = (const void ***)((char *)v62 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            uint64_t v25 = &v58;
            unint64_t v26 = (char *)v62;
          }
        }
        uint64_t v27 = &v26[24 * v63];
        long long v28 = *(_OWORD *)v25;
        *((void *)v27 + 2) = v25[2];
        *(_OWORD *)uint64_t v27 = v28;
        ++v63;
        if (v61[0])
        {
          int64_t v29 = &v58;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v58, (uint64_t)a2);
          int64_t v30 = (char *)v62;
          if (v63 >= v64)
          {
            unint64_t v48 = v63 + 1;
            if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
            {
              int64_t v52 = (char *)&v58 - (unsigned char *)v62;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              int64_t v30 = (char *)v62;
              int64_t v29 = (const void ***)((char *)v62 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              int64_t v29 = &v58;
              int64_t v30 = (char *)v62;
            }
          }
          uint64_t v31 = &v30[24 * v63];
          long long v32 = *(_OWORD *)v29;
          *((void *)v31 + 2) = v29[2];
          *(_OWORD *)uint64_t v31 = v32;
          ++v63;
        }
      }
    }
  }
  uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v61);
  if (v61[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v61);
  }
  if (v70)
  {
    int v34 = (void **)__p;
    if (__p)
    {
      int v35 = v69;
      unsigned int v36 = __p;
      if (v69 != __p)
      {
        do
          int v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        unsigned int v36 = __p;
      }
      unint64_t v69 = v34;
      operator delete(v36);
    }
    uint64_t v37 = v66;
    if (v66)
    {
      uint64_t v38 = v67;
      unint64_t v39 = v66;
      if (v67 != v66)
      {
        do
        {
          uint64_t v41 = (void *)*--v38;
          uint64_t v40 = v41;
          void *v38 = 0;
          if (v41) {
            operator delete[](v40);
          }
        }
        while (v38 != v37);
        unint64_t v39 = v66;
      }
      __int16 v67 = v37;
      operator delete(v39);
    }
    if (v62 != v65) {
      free(v62);
    }
  }
  return v33;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps15(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *a2;
  unint64_t v11 = (void *)*((void *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v61[0] = a2;
    v61[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)) {
      return 1;
    }
    uint64_t v10 = *a2;
    if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
LABEL_3:
      int64_t v53 = a2;
      uint64_t v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53)) {
        goto LABEL_10;
      }
      uint64_t v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      uint64_t v58 = a2;
      uint64_t v59 = v12;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
      if (v13 != 1) {
        goto LABEL_10;
      }
      uint64_t v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v56[0] = a2;
      v56[1] = v14;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
      if (!mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)) {
        goto LABEL_10;
      }
      return 1;
    }
  }
  else if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    goto LABEL_3;
  }
LABEL_10:
  __int16 v55 = 261;
  int64_t v53 = a3;
  uint64_t v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v61);
  if (v61[0])
  {
    LODWORD(v58) = 3;
    uint64_t v59 = (uint64_t)" #";
    uint64_t v60 = 2;
    uint64_t v16 = &v58;
    uint64_t v17 = (char *)v62;
    if (v63 >= v64)
    {
      unint64_t v43 = v63 + 1;
      if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
      {
        int64_t v49 = (char *)&v58 - (unsigned char *)v62;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        uint64_t v17 = (char *)v62;
        uint64_t v16 = (const void ***)((char *)v62 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        uint64_t v16 = &v58;
        uint64_t v17 = (char *)v62;
      }
    }
    long long v18 = &v17[24 * v63];
    long long v19 = *(_OWORD *)v16;
    *((void *)v18 + 2) = v16[2];
    *(_OWORD *)long long v18 = v19;
    uint64_t v20 = ++v63;
    if (v61[0])
    {
      LODWORD(v58) = 5;
      uint64_t v59 = a5;
      uint64_t v21 = &v58;
      unint64_t v22 = (char *)v62;
      if (v20 >= v64)
      {
        unint64_t v44 = v20 + 1;
        BOOL v45 = (char *)v62 + 24 * v20 > (char *)&v58;
        if (v62 <= &v58 && v45)
        {
          int64_t v50 = (char *)&v58 - (unsigned char *)v62;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          unint64_t v22 = (char *)v62;
          uint64_t v21 = (const void ***)((char *)v62 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          uint64_t v21 = &v58;
          unint64_t v22 = (char *)v62;
        }
      }
      long long v23 = &v22[24 * v63];
      long long v24 = *(_OWORD *)v21;
      *((void *)v23 + 2) = v21[2];
      *(_OWORD *)long long v23 = v24;
      uint64_t v25 = ++v63;
      if (v61[0])
      {
        LODWORD(v58) = 3;
        uint64_t v59 = (uint64_t)" must be unranked tensor of 32-bit signed integer values or 1D tensor of 32-bit signed integer values, but got ";
        uint64_t v60 = 111;
        unint64_t v26 = &v58;
        uint64_t v27 = (char *)v62;
        if (v25 >= v64)
        {
          unint64_t v46 = v25 + 1;
          BOOL v47 = (char *)v62 + 24 * v25 > (char *)&v58;
          if (v62 <= &v58 && v47)
          {
            int64_t v51 = (char *)&v58 - (unsigned char *)v62;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            uint64_t v27 = (char *)v62;
            unint64_t v26 = (const void ***)((char *)v62 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            unint64_t v26 = &v58;
            uint64_t v27 = (char *)v62;
          }
        }
        long long v28 = &v27[24 * v63];
        long long v29 = *(_OWORD *)v26;
        *((void *)v28 + 2) = v26[2];
        *(_OWORD *)long long v28 = v29;
        ++v63;
        if (v61[0])
        {
          int64_t v30 = &v58;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v58, (uint64_t)a2);
          uint64_t v31 = (char *)v62;
          if (v63 >= v64)
          {
            unint64_t v48 = v63 + 1;
            if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
            {
              int64_t v52 = (char *)&v58 - (unsigned char *)v62;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              uint64_t v31 = (char *)v62;
              int64_t v30 = (const void ***)((char *)v62 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              int64_t v30 = &v58;
              uint64_t v31 = (char *)v62;
            }
          }
          long long v32 = &v31[24 * v63];
          long long v33 = *(_OWORD *)v30;
          *((void *)v32 + 2) = v30[2];
          *(_OWORD *)long long v32 = v33;
          ++v63;
        }
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v61);
  if (v61[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v61);
  }
  if (v70)
  {
    int v34 = (void **)__p;
    if (__p)
    {
      int v35 = v69;
      unsigned int v36 = __p;
      if (v69 != __p)
      {
        do
          int v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        unsigned int v36 = __p;
      }
      unint64_t v69 = v34;
      operator delete(v36);
    }
    uint64_t v37 = v66;
    if (v66)
    {
      uint64_t v38 = v67;
      unint64_t v39 = v66;
      if (v67 != v66)
      {
        do
        {
          uint64_t v41 = (void *)*--v38;
          uint64_t v40 = v41;
          void *v38 = 0;
          if (v41) {
            operator delete[](v40);
          }
        }
        while (v38 != v37);
        unint64_t v39 = v66;
      }
      __int16 v67 = v37;
      operator delete(v39);
    }
    if (v62 != v65) {
      free(v62);
    }
  }
  return v15;
}

uint64_t mlir::mps::Conv3DDataGradientOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  BOOL v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.conv_3d_data_gradient", 25, v2, v3, 0, 0);
  *BOOL v4 = &unk_1EC9817D8;
  v4[12] = mlir::mps::Conv3DDataGradientOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::Conv3DOpGenericAdaptorBase::Conv3DOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v13, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *(_OWORD *)v5;
  long long v9 = *(_OWORD *)(v5 + 16);
  long long v10 = *(_OWORD *)(v5 + 32);
  *(void *)(a1 + 72) = *(void *)(v5 + 48);
  *(_OWORD *)(a1 + 56) = v10;
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)v13;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.conv_3d", 11, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::Conv3DOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 6uLL:
      if (memcmp(__s1, "groups", __n)) {
        return 0;
      }
      return a2[3];
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[5];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x79616C5F61746164 || *(void *)(__s1 + 3) != 0x74756F79616C5F61) {
        return 0;
      }
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[4];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n)) {
        return a2[1];
      }
      if (memcmp(__s1, "weights_layout", __n)) {
        return 0;
      }
      return a2[6];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::Conv3DOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  uint64_t v7 = (void *)result;
  switch(__n)
  {
    case 6uLL:
      uint64_t result = memcmp(__s1, "groups", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
            uint64_t v14 = a4;
          }
          else {
            uint64_t v14 = 0;
          }
          v7[3] = v14;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          v7[5] = v8;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x79616C5F61746164 && *(void *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          *(void *)uint64_t result = v10;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v7[4] = v11;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "weights_layout", __n);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
              uint64_t v12 = a4;
            }
            else {
              uint64_t v12 = 0;
            }
            v7[6] = v12;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
        if (result) {
          uint64_t v15 = a4;
        }
        else {
          uint64_t v15 = 0;
        }
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v13 = a4;
          }
          else {
            uint64_t v13 = 0;
          }
          v7[2] = v13;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::Conv3DOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x38uLL);
    *uint64_t v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    *((void *)v3 + 6) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 107;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[27];
    return a1[32];
  }
  return result;
}

void mlir::mps::Conv3DOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t a8, uint64_t *a9, uint64_t a10, uint64_t *a11, uint64_t a12, unsigned int a13, unsigned int a14, unsigned int a15)
{
  uint64_t v17 = mlir::mps::get5DElementsAttrFrom3DSpatialValues(a1, a6, a7, a14);
  uint64_t v18 = mlir::mps::get5DElementsAttrFrom3DSpatialValues(a1, a9, a10, a14);
  uint64_t v19 = mlir::mps::get5DElementsAttrFrom3DPaddingValues(a1, a11, a12, a14);

  mlir::mps::Conv3DOp::build(a1, a2, a3, a4, a5, v17, v18, v19, a13, a14, a15);
}

void mlir::mps::Conv3DOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, unsigned int a10, unsigned int a11)
{
  void v46[2] = *MEMORY[0x1E4F143B8];
  uint64_t v39 = a4;
  uint64_t v40 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v40, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v39, 1);
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  uint64_t IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a5);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>((void *)a2)
            + 24) = IntegerAttr;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>((void *)a2)
            + 40) = a6;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = a7;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>((void *)a2)
            + 16) = a8;
  uint64_t v19 = *(mlir::MLIRContext **)a1;
  unsigned int v41 = a9;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v19);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  uint64_t v45 = (uint64_t)v19;
  uint64_t v21 = mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v41);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>((void *)a2)
            + 32) = v21;
  unint64_t v22 = *(mlir::MLIRContext **)a1;
  unsigned int v41 = a10;
  long long v23 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v22);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  uint64_t v45 = (uint64_t)v22;
  uint64_t v24 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v23, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v41);
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>((void *)a2) = v24;
  uint64_t v25 = *(mlir::MLIRContext **)a1;
  unsigned int v41 = a11;
  unint64_t v26 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v25);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  uint64_t v45 = (uint64_t)v25;
  uint64_t v27 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v26, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v41);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>((void *)a2)
            + 48) = v27;
  __src = v46;
  uint64_t v45 = 0x200000000;
  long long v28 = *(mlir::UnknownLoc **)a1;
  mlir::ValueRange::ValueRange(v43, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v31 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v42, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::Conv3DOp::inferReturnTypes(v28, v32, v33, v43[0], v43[1], Dictionary, v31, v34, v42[0], v42[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  int v35 = __src;
  }
  uint64_t v36 = v45;
  uint64_t v37 = *(unsigned int *)(a2 + 72);
  unint64_t v38 = v37 + v45;
  if (v38 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v38, 8);
    LODWORD(v37) = *(_DWORD *)(a2 + 72);
  }
  if (v36)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v37), v35, 8 * v36);
    LODWORD(v37) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v37 + v36;
  if (__src != v46) {
    free(__src);
  }
}

BOOL mlir::mps::Conv3DOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    unint64_t v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    unint64_t v3 = 0;
  }
  unint64_t v4 = *(_DWORD **)v3;
  if (*(void *)v3)
  {
    int v5 = *(void **)(v3 + 8);
    if (v5)
    {
      unint64_t v6 = *(const void ***)(v3 + 16);
      if (v6)
      {
        unint64_t v7 = *(const void ***)(v3 + 24);
        if (v7)
        {
          uint64_t v8 = *(void *)(v3 + 32);
          if (v8)
          {
            unint64_t v9 = *(void **)(v3 + 40);
            if (v9)
            {
              uint64_t v10 = *(_DWORD **)(v3 + 48);
              if (v10)
              {
                v50[0] = v2;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v7, (const void **)"groups", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v9, (const void **)"strides", (const char *)7, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v8, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(v10, (const void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps14(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
                {
                  return 0;
                }
                if (*((_DWORD *)*this + 9)) {
                  uint64_t v11 = (uint64_t)(*this - 2);
                }
                else {
                  uint64_t v11 = 0;
                }
                uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
                return mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
              }
              BOOL v47 = "requires attribute 'weights_layout'";
            }
            else
            {
              BOOL v47 = "requires attribute 'strides'";
            }
            v48[0] = (const void **)v47;
            __int16 v49 = 259;
            mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
            uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v50);
            return v13;
          }
          v48[0] = (const void **)"requires attribute 'padding_style'";
          __int16 v49 = 259;
          mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
          uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          }
          if (v57)
          {
            uint64_t v40 = (void **)__p;
            if (__p)
            {
              unsigned int v41 = v56;
              uint64_t v42 = __p;
              if (v56 != __p)
              {
                do
                  unsigned int v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
                while (v41 != v40);
                uint64_t v42 = __p;
              }
              uint64_t v56 = v40;
              operator delete(v42);
            }
            uint64_t v17 = v53;
            if (!v53) {
              goto LABEL_96;
            }
            unint64_t v43 = v54;
            uint64_t v19 = v53;
            if (v54 == v53)
            {
LABEL_95:
              uint64_t v54 = v17;
              operator delete(v19);
LABEL_96:
              if (v51 != &v52) {
                free(v51);
              }
              return v13;
            }
            do
            {
              uint64_t v45 = (void *)*--v43;
              unint64_t v44 = v45;
              void *v43 = 0;
              if (v45) {
                operator delete[](v44);
              }
            }
            while (v43 != v17);
LABEL_94:
            uint64_t v19 = v53;
            goto LABEL_95;
          }
        }
        else
        {
          v48[0] = (const void **)"requires attribute 'groups'";
          __int16 v49 = 259;
          mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
          uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          }
          if (v57)
          {
            int v34 = (void **)__p;
            if (__p)
            {
              int v35 = v56;
              uint64_t v36 = __p;
              if (v56 != __p)
              {
                do
                  int v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
                while (v35 != v34);
                uint64_t v36 = __p;
              }
              uint64_t v56 = v34;
              operator delete(v36);
            }
            uint64_t v17 = v53;
            if (!v53) {
              goto LABEL_96;
            }
            uint64_t v37 = v54;
            uint64_t v19 = v53;
            if (v54 == v53) {
              goto LABEL_95;
            }
            do
            {
              uint64_t v39 = (void *)*--v37;
              unint64_t v38 = v39;
              *uint64_t v37 = 0;
              if (v39) {
                operator delete[](v38);
              }
            }
            while (v37 != v17);
            goto LABEL_94;
          }
        }
      }
      else
      {
        v48[0] = (const void **)"requires attribute 'explicit_padding'";
        __int16 v49 = 259;
        mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
        uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
        if (v50[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
        }
        if (v57)
        {
          long long v28 = (void **)__p;
          if (__p)
          {
            long long v29 = v56;
            int64_t v30 = __p;
            if (v56 != __p)
            {
              do
                long long v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
              while (v29 != v28);
              int64_t v30 = __p;
            }
            uint64_t v56 = v28;
            operator delete(v30);
          }
          uint64_t v17 = v53;
          if (!v53) {
            goto LABEL_96;
          }
          uint64_t v31 = v54;
          uint64_t v19 = v53;
          if (v54 == v53) {
            goto LABEL_95;
          }
          do
          {
            int v33 = (void *)*--v31;
            long long v32 = v33;
            *uint64_t v31 = 0;
            if (v33) {
              operator delete[](v32);
            }
          }
          while (v31 != v17);
          goto LABEL_94;
        }
      }
    }
    else
    {
      v48[0] = (const void **)"requires attribute 'dilation_rates'";
      __int16 v49 = 259;
      mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
      uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
      if (v50[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
      }
      if (v57)
      {
        unint64_t v22 = (void **)__p;
        if (__p)
        {
          long long v23 = v56;
          uint64_t v24 = __p;
          if (v56 != __p)
          {
            do
              long long v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
            while (v23 != v22);
            uint64_t v24 = __p;
          }
          uint64_t v56 = v22;
          operator delete(v24);
        }
        uint64_t v17 = v53;
        if (!v53) {
          goto LABEL_96;
        }
        uint64_t v25 = v54;
        uint64_t v19 = v53;
        if (v54 == v53) {
          goto LABEL_95;
        }
        do
        {
          uint64_t v27 = (void *)*--v25;
          unint64_t v26 = v27;
          *uint64_t v25 = 0;
          if (v27) {
            operator delete[](v26);
          }
        }
        while (v25 != v17);
        goto LABEL_94;
      }
    }
  }
  else
  {
    v48[0] = (const void **)"requires attribute 'data_layout'";
    __int16 v49 = 259;
    mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
    uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
    if (v50[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
    }
    if (v57)
    {
      unint64_t v14 = (void **)__p;
      if (__p)
      {
        uint64_t v15 = v56;
        uint64_t v16 = __p;
        if (v56 != __p)
        {
          do
            uint64_t v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
          while (v15 != v14);
          uint64_t v16 = __p;
        }
        uint64_t v56 = v14;
        operator delete(v16);
      }
      uint64_t v17 = v53;
      if (!v53) {
        goto LABEL_96;
      }
      uint64_t v18 = v54;
      uint64_t v19 = v53;
      if (v54 == v53) {
        goto LABEL_95;
      }
      do
      {
        uint64_t v21 = (void *)*--v18;
        uint64_t v20 = v21;
        void *v18 = 0;
        if (v21) {
          operator delete[](v20);
        }
      }
      while (v18 != v17);
      goto LABEL_94;
    }
  }
  return v13;
}

uint64_t mlir::mps::Conv3DOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  unint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.conv_3d", 11, v2, v3, 0, 0);
  *unint64_t v4 = &unk_1EC983408;
  v4[12] = mlir::mps::Conv3DOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::Conv3DWeightsGradientOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 6uLL:
      if (memcmp(__s1, "groups", __n)) {
        return 0;
      }
      return a2[3];
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[5];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x79616C5F61746164 || *(void *)(__s1 + 3) != 0x74756F79616C5F61) {
        return 0;
      }
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[4];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n)) {
        return a2[1];
      }
      if (memcmp(__s1, "weights_layout", __n)) {
        return 0;
      }
      return a2[6];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::Conv3DWeightsGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  unint64_t v7 = (void *)result;
  switch(__n)
  {
    case 6uLL:
      uint64_t result = memcmp(__s1, "groups", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
            uint64_t v14 = a4;
          }
          else {
            uint64_t v14 = 0;
          }
          v7[3] = v14;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          v7[5] = v8;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x79616C5F61746164 && *(void *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          *(void *)uint64_t result = v10;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v7[4] = v11;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "weights_layout", __n);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
              uint64_t v12 = a4;
            }
            else {
              uint64_t v12 = 0;
            }
            v7[6] = v12;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
        if (result) {
          uint64_t v15 = a4;
        }
        else {
          uint64_t v15 = 0;
        }
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v13 = a4;
          }
          else {
            uint64_t v13 = 0;
          }
          v7[2] = v13;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::Conv3DWeightsGradientOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x38uLL);
    *uint64_t v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    *((void *)v3 + 6) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorB"
              "ase::Properties]";
        unint64_t v14 = 122;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[29];
    return a1[32];
  }
  return result;
}

void mlir::mps::Conv3DWeightsGradientOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t *a9, uint64_t a10, uint64_t *a11, uint64_t a12, unsigned int a13, unsigned int a14, unsigned int a15)
{
  uint64_t v17 = mlir::mps::get5DElementsAttrFrom3DSpatialValues(a1, a7, a8, a14);
  uint64_t v18 = mlir::mps::get5DElementsAttrFrom3DSpatialValues(a1, a9, a10, a14);
  uint64_t v24 = mlir::mps::get5DElementsAttrFrom3DPaddingValues(a1, a11, a12, a14);

  mlir::mps::Conv3DWeightsGradientOp::build(a1, a2, a3, a4, a5, a6, v17, v18, v24, a13, a14, a15);
}

void mlir::mps::Conv3DWeightsGradientOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int a10, unsigned int a11, unsigned int a12)
{
  void v47[2] = *MEMORY[0x1E4F143B8];
  uint64_t v40 = a4;
  uint64_t v41 = a3;
  uint64_t v39 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v41, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v40, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v39, 1);
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  uint64_t IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a6);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 24) = IntegerAttr;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 40) = a7;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = a8;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 16) = a9;
  uint64_t v19 = *(mlir::MLIRContext **)a1;
  unsigned int v42 = a10;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v19);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  uint64_t v46 = (uint64_t)v19;
  uint64_t v21 = mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v42);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 32) = v21;
  unint64_t v22 = *(mlir::MLIRContext **)a1;
  unsigned int v42 = a11;
  long long v23 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v22);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  uint64_t v46 = (uint64_t)v22;
  uint64_t v24 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v23, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v42);
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>((void *)a2) = v24;
  uint64_t v25 = *(mlir::MLIRContext **)a1;
  unsigned int v42 = a12;
  unint64_t v26 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v25);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  uint64_t v46 = (uint64_t)v25;
  uint64_t v27 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v26, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v42);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 48) = v27;
  __src = v47;
  uint64_t v46 = 0x200000000;
  long long v28 = *(mlir::UnknownLoc **)a1;
  mlir::ValueRange::ValueRange((unint64_t *)v44, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v31 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v43, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::Conv3DWeightsGradientOp::inferReturnTypes(v28, v32, v33, v44[0], (unint64_t)v44[1], Dictionary, v31, v34, v43[0], v43[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  int v35 = __src;
  }
  uint64_t v36 = v46;
  uint64_t v37 = *(unsigned int *)(a2 + 72);
  unint64_t v38 = v37 + v46;
  if (v38 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v38, 8);
    LODWORD(v37) = *(_DWORD *)(a2 + 72);
  }
  if (v36)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v37), v35, 8 * v36);
    LODWORD(v37) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v37 + v36;
  if (__src != v47) {
    free(__src);
  }
}

BOOL mlir::mps::Conv3DWeightsGradientOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    unint64_t v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    unint64_t v3 = 0;
  }
  unint64_t v4 = *(_DWORD **)v3;
  if (*(void *)v3)
  {
    int v5 = *(void **)(v3 + 8);
    if (v5)
    {
      unint64_t v6 = *(const void ***)(v3 + 16);
      if (v6)
      {
        unint64_t v7 = *(const void ***)(v3 + 24);
        if (v7)
        {
          uint64_t v8 = *(void *)(v3 + 32);
          if (v8)
          {
            unint64_t v9 = *(void **)(v3 + 40);
            if (v9)
            {
              uint64_t v10 = *(_DWORD **)(v3 + 48);
              if (v10)
              {
                v50[0] = v2;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v7, (const void **)"groups", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v9, (const void **)"strides", (const char *)7, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v8, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(v10, (const void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps16(*this,
                                         (const void **)(*(void *)(*(void *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8),
                                         (const void **)"operand",
                                         7,
                                         2u))
                {
                  return 0;
                }
                if (*((_DWORD *)*this + 9)) {
                  uint64_t v11 = (uint64_t)(*this - 2);
                }
                else {
                  uint64_t v11 = 0;
                }
                uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
                return mlir::mps::__mlir_ods_local_type_constraint_MPSOps14(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
              }
              BOOL v47 = "requires attribute 'weights_layout'";
            }
            else
            {
              BOOL v47 = "requires attribute 'strides'";
            }
            v48[0] = (const void **)v47;
            __int16 v49 = 259;
            mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
            uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v50);
            return v13;
          }
          v48[0] = (const void **)"requires attribute 'padding_style'";
          __int16 v49 = 259;
          mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
          uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          }
          if (v57)
          {
            uint64_t v40 = (void **)__p;
            if (__p)
            {
              uint64_t v41 = v56;
              unsigned int v42 = __p;
              if (v56 != __p)
              {
                do
                  uint64_t v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
                while (v41 != v40);
                unsigned int v42 = __p;
              }
              uint64_t v56 = v40;
              operator delete(v42);
            }
            uint64_t v17 = v53;
            if (!v53) {
              goto LABEL_97;
            }
            unint64_t v43 = v54;
            uint64_t v19 = v53;
            if (v54 == v53)
            {
LABEL_96:
              uint64_t v54 = v17;
              operator delete(v19);
LABEL_97:
              if (v51 != &v52) {
                free(v51);
              }
              return v13;
            }
            do
            {
              uint64_t v45 = (void *)*--v43;
              unint64_t v44 = v45;
              void *v43 = 0;
              if (v45) {
                operator delete[](v44);
              }
            }
            while (v43 != v17);
LABEL_95:
            uint64_t v19 = v53;
            goto LABEL_96;
          }
        }
        else
        {
          v48[0] = (const void **)"requires attribute 'groups'";
          __int16 v49 = 259;
          mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
          uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          }
          if (v57)
          {
            int v34 = (void **)__p;
            if (__p)
            {
              int v35 = v56;
              uint64_t v36 = __p;
              if (v56 != __p)
              {
                do
                  int v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
                while (v35 != v34);
                uint64_t v36 = __p;
              }
              uint64_t v56 = v34;
              operator delete(v36);
            }
            uint64_t v17 = v53;
            if (!v53) {
              goto LABEL_97;
            }
            uint64_t v37 = v54;
            uint64_t v19 = v53;
            if (v54 == v53) {
              goto LABEL_96;
            }
            do
            {
              uint64_t v39 = (void *)*--v37;
              unint64_t v38 = v39;
              *uint64_t v37 = 0;
              if (v39) {
                operator delete[](v38);
              }
            }
            while (v37 != v17);
            goto LABEL_95;
          }
        }
      }
      else
      {
        v48[0] = (const void **)"requires attribute 'explicit_padding'";
        __int16 v49 = 259;
        mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
        uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
        if (v50[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
        }
        if (v57)
        {
          long long v28 = (void **)__p;
          if (__p)
          {
            long long v29 = v56;
            int64_t v30 = __p;
            if (v56 != __p)
            {
              do
                long long v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
              while (v29 != v28);
              int64_t v30 = __p;
            }
            uint64_t v56 = v28;
            operator delete(v30);
          }
          uint64_t v17 = v53;
          if (!v53) {
            goto LABEL_97;
          }
          uint64_t v31 = v54;
          uint64_t v19 = v53;
          if (v54 == v53) {
            goto LABEL_96;
          }
          do
          {
            int v33 = (void *)*--v31;
            long long v32 = v33;
            *uint64_t v31 = 0;
            if (v33) {
              operator delete[](v32);
            }
          }
          while (v31 != v17);
          goto LABEL_95;
        }
      }
    }
    else
    {
      v48[0] = (const void **)"requires attribute 'dilation_rates'";
      __int16 v49 = 259;
      mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
      uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
      if (v50[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
      }
      if (v57)
      {
        unint64_t v22 = (void **)__p;
        if (__p)
        {
          long long v23 = v56;
          uint64_t v24 = __p;
          if (v56 != __p)
          {
            do
              long long v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
            while (v23 != v22);
            uint64_t v24 = __p;
          }
          uint64_t v56 = v22;
          operator delete(v24);
        }
        uint64_t v17 = v53;
        if (!v53) {
          goto LABEL_97;
        }
        uint64_t v25 = v54;
        uint64_t v19 = v53;
        if (v54 == v53) {
          goto LABEL_96;
        }
        do
        {
          uint64_t v27 = (void *)*--v25;
          unint64_t v26 = v27;
          *uint64_t v25 = 0;
          if (v27) {
            operator delete[](v26);
          }
        }
        while (v25 != v17);
        goto LABEL_95;
      }
    }
  }
  else
  {
    v48[0] = (const void **)"requires attribute 'data_layout'";
    __int16 v49 = 259;
    mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
    uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
    if (v50[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
    }
    if (v57)
    {
      unint64_t v14 = (void **)__p;
      if (__p)
      {
        uint64_t v15 = v56;
        uint64_t v16 = __p;
        if (v56 != __p)
        {
          do
            uint64_t v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
          while (v15 != v14);
          uint64_t v16 = __p;
        }
        uint64_t v56 = v14;
        operator delete(v16);
      }
      uint64_t v17 = v53;
      if (!v53) {
        goto LABEL_97;
      }
      uint64_t v18 = v54;
      uint64_t v19 = v53;
      if (v54 == v53) {
        goto LABEL_96;
      }
      do
      {
        uint64_t v21 = (void *)*--v18;
        uint64_t v20 = v21;
        void *v18 = 0;
        if (v21) {
          operator delete[](v20);
        }
      }
      while (v18 != v17);
      goto LABEL_95;
    }
  }
  return v13;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps16(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *a2;
  uint64_t v11 = (void *)*((void *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v63[0] = a2;
    v63[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v63);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)) {
      return 1;
    }
    uint64_t v10 = *a2;
    uint64_t v17 = (void *)*((void *)*a2 + 17);
    if (v17 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v17 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_17;
    }
  }
  else if (v11 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id {
         && v11 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  }
  {
    goto LABEL_17;
  }
  uint64_t v56 = a2;
  uint64_t v57 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v56);
  if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32))
  {
    uint64_t v13 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
    uint64_t v60 = a2;
    uint64_t v61 = v13;
    ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v60);
    uint64_t v73 = 5;
    if (v15 == 1 && *ArgAttrsAttr == v73) {
      return 1;
    }
  }
LABEL_17:
  __int16 v58 = 261;
  uint64_t v56 = a3;
  uint64_t v57 = a4;
  mlir::Operation::emitOpError(a1, &v56, (uint64_t)v63);
  if (v63[0])
  {
    LODWORD(v60) = 3;
    uint64_t v61 = (uint64_t)" #";
    uint64_t v62 = 2;
    uint64_t v19 = &v60;
    uint64_t v20 = (char *)v64;
    if (v65 >= v66)
    {
      unint64_t v46 = v65 + 1;
      if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
      {
        int64_t v52 = (char *)&v60 - (unsigned char *)v64;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v46, 24);
        uint64_t v20 = (char *)v64;
        uint64_t v19 = (const void ***)((char *)v64 + v52);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v46, 24);
        uint64_t v19 = &v60;
        uint64_t v20 = (char *)v64;
      }
    }
    uint64_t v21 = &v20[24 * v65];
    long long v22 = *(_OWORD *)v19;
    *((void *)v21 + 2) = v19[2];
    *(_OWORD *)uint64_t v21 = v22;
    uint64_t v23 = ++v65;
    if (v63[0])
    {
      LODWORD(v60) = 5;
      uint64_t v61 = a5;
      uint64_t v24 = &v60;
      uint64_t v25 = (char *)v64;
      if (v23 >= v66)
      {
        unint64_t v47 = v23 + 1;
        BOOL v48 = (char *)v64 + 24 * v23 > (char *)&v60;
        if (v64 <= &v60 && v48)
        {
          int64_t v53 = (char *)&v60 - (unsigned char *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
          uint64_t v25 = (char *)v64;
          uint64_t v24 = (const void ***)((char *)v64 + v53);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
          uint64_t v24 = &v60;
          uint64_t v25 = (char *)v64;
        }
      }
      unint64_t v26 = &v25[24 * v65];
      long long v27 = *(_OWORD *)v24;
      *((void *)v26 + 2) = v24[2];
      *(_OWORD *)unint64_t v26 = v27;
      uint64_t v28 = ++v65;
      if (v63[0])
      {
        LODWORD(v60) = 3;
        uint64_t v61 = (uint64_t)" must be unranked tensor of 32-bit signed integer values or static-shape defined tensor with shap"
                       "e equal to [5], but got ";
        uint64_t v62 = 121;
        long long v29 = &v60;
        int64_t v30 = (char *)v64;
        if (v28 >= v66)
        {
          unint64_t v49 = v28 + 1;
          BOOL v50 = (char *)v64 + 24 * v28 > (char *)&v60;
          if (v64 <= &v60 && v50)
          {
            int64_t v54 = (char *)&v60 - (unsigned char *)v64;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
            int64_t v30 = (char *)v64;
            long long v29 = (const void ***)((char *)v64 + v54);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
            long long v29 = &v60;
            int64_t v30 = (char *)v64;
          }
        }
        uint64_t v31 = &v30[24 * v65];
        long long v32 = *(_OWORD *)v29;
        *((void *)v31 + 2) = v29[2];
        *(_OWORD *)uint64_t v31 = v32;
        ++v65;
        if (v63[0])
        {
          int v33 = &v60;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v60, (uint64_t)a2);
          int v34 = (char *)v64;
          if (v65 >= v66)
          {
            unint64_t v51 = v65 + 1;
            if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
            {
              int64_t v55 = (char *)&v60 - (unsigned char *)v64;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v51, 24);
              int v34 = (char *)v64;
              int v33 = (const void ***)((char *)v64 + v55);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v51, 24);
              int v33 = &v60;
              int v34 = (char *)v64;
            }
          }
          int v35 = &v34[24 * v65];
          long long v36 = *(_OWORD *)v33;
          *((void *)v35 + 2) = v33[2];
          *(_OWORD *)int v35 = v36;
          ++v65;
        }
      }
    }
  }
  uint64_t v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v63);
  if (v63[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
  }
  if (v72)
  {
    uint64_t v37 = (void **)__p;
    if (__p)
    {
      unint64_t v38 = v71;
      uint64_t v39 = __p;
      if (v71 != __p)
      {
        do
          unint64_t v38 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v38 - 1);
        while (v38 != v37);
        uint64_t v39 = __p;
      }
      uint64_t v71 = v37;
      operator delete(v39);
    }
    uint64_t v40 = v68;
    if (v68)
    {
      uint64_t v41 = v69;
      unsigned int v42 = v68;
      if (v69 != v68)
      {
        do
        {
          unint64_t v44 = (void *)*--v41;
          unint64_t v43 = v44;
          *uint64_t v41 = 0;
          if (v44) {
            operator delete[](v43);
          }
        }
        while (v41 != v40);
        unsigned int v42 = v68;
      }
      unint64_t v69 = v40;
      operator delete(v42);
    }
    if (v64 != v67) {
      free(v64);
    }
  }
  return v16;
}

uint64_t mlir::mps::Conv3DWeightsGradientOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  unint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.conv_3d_weights_gradient", 28, v2, v3, 0, 0);
  *unint64_t v4 = &unk_1EC981D00;
  v4[12] = mlir::mps::Conv3DWeightsGradientOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::CosOpGenericAdaptorBase::CosOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.cos", 7, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::CosOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  unint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.cos", 7, v2, v3, 0, 0);
  *unint64_t v4 = &unk_1EC982330;
  v4[12] = mlir::mps::CosOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::CoshOpGenericAdaptorBase::CoshOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.cosh", 8, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::CoshOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  unint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.cosh", 8, v2, v3, 0, 0);
  *unint64_t v4 = &unk_1EC982858;
  v4[12] = mlir::mps::CoshOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::CostVolumeOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v69 = v6;
  if (!v6)
  {
    a3(v73, a4);
    if (v73[0])
    {
      LODWORD(v70) = 3;
      uint64_t v71 = "expected DictionaryAttr to set properties";
      uint64_t v72 = 41;
      uint64_t v28 = &v70;
      long long v29 = (char *)v74;
      if (v75 >= v76)
      {
        unint64_t v59 = v75 + 1;
        if (v74 <= &v70 && (char *)v74 + 24 * v75 > (char *)&v70)
        {
          int64_t v64 = (char *)&v70 - (unsigned char *)v74;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v59, 24);
          long long v29 = (char *)v74;
          uint64_t v28 = (uint64_t *)((char *)v74 + v64);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v59, 24);
          uint64_t v28 = &v70;
          long long v29 = (char *)v74;
        }
      }
      int64_t v30 = &v29[24 * v75];
      long long v31 = *(_OWORD *)v28;
      *((void *)v30 + 2) = v28[2];
      *(_OWORD *)int64_t v30 = v31;
      ++v75;
      if (v73[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v73);
      }
    }
    if (!v82) {
      return 0;
    }
    long long v32 = (void **)__p;
    if (__p)
    {
      int v33 = v81;
      int v34 = __p;
      if (v81 != __p)
      {
        do
          int v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        int v34 = __p;
      }
      int64_t v81 = v32;
      operator delete(v34);
    }
    uint64_t v23 = v78;
    if (!v78) {
      goto LABEL_64;
    }
    int v35 = v79;
    uint64_t v25 = v78;
    if (v79 == v78)
    {
LABEL_63:
      unint64_t v79 = v23;
      operator delete(v25);
LABEL_64:
      if (v74 != v77) {
        free(v74);
      }
      return 0;
    }
    do
    {
      uint64_t v37 = (void *)*--v35;
      long long v36 = v37;
      *int v35 = 0;
      if (v37) {
        operator delete[](v36);
      }
    }
    while (v35 != v23);
LABEL_62:
    uint64_t v25 = v78;
    goto LABEL_63;
  }
  __int16 v8 = (void *)mlir::DictionaryAttr::get((uint64_t)&v69, "coord_is_x_only", 0xFuLL);
  if (!v8) {
    goto LABEL_8;
  }
  uint64_t v9 = (uint64_t)v8;
  if (!mlir::BoolAttr::classof(v8))
  {
    a3(v73, a4);
    if (v73[0])
    {
      LODWORD(v70) = 3;
      uint64_t v72 = 60;
      unint64_t v38 = &v70;
      uint64_t v39 = (char *)v74;
      if (v75 >= v76)
      {
        unint64_t v60 = v75 + 1;
        if (v74 <= &v70 && (char *)v74 + 24 * v75 > (char *)&v70)
        {
          int64_t v65 = (char *)&v70 - (unsigned char *)v74;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v60, 24);
          uint64_t v39 = (char *)v74;
          unint64_t v38 = (uint64_t *)((char *)v74 + v65);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v60, 24);
          unint64_t v38 = &v70;
          uint64_t v39 = (char *)v74;
        }
      }
      uint64_t v40 = &v39[24 * v75];
      long long v41 = *(_OWORD *)v38;
      *((void *)v40 + 2) = v38[2];
      *(_OWORD *)uint64_t v40 = v41;
      ++v75;
      if (v73[0])
      {
        unsigned int v42 = &v70;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v70, v9);
        unint64_t v43 = (char *)v74;
        if (v75 >= v76)
        {
          unint64_t v62 = v75 + 1;
          if (v74 <= &v70 && (char *)v74 + 24 * v75 > (char *)&v70)
          {
            int64_t v67 = (char *)&v70 - (unsigned char *)v74;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v62, 24);
            unint64_t v43 = (char *)v74;
            unsigned int v42 = (uint64_t *)((char *)v74 + v67);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v62, 24);
            unsigned int v42 = &v70;
            unint64_t v43 = (char *)v74;
          }
        }
        unint64_t v44 = &v43[24 * v75];
        long long v45 = *(_OWORD *)v42;
        *((void *)v44 + 2) = v42[2];
        *(_OWORD *)unint64_t v44 = v45;
        ++v75;
        if (v73[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v73);
        }
      }
    }
    if (!v82) {
      return 0;
    }
    unint64_t v46 = (void **)__p;
    if (__p)
    {
      unint64_t v47 = v81;
      BOOL v48 = __p;
      if (v81 != __p)
      {
        do
          unint64_t v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        BOOL v48 = __p;
      }
      int64_t v81 = v46;
      operator delete(v48);
    }
    uint64_t v23 = v78;
    if (!v78) {
      goto LABEL_64;
    }
    unint64_t v49 = v79;
    uint64_t v25 = v78;
    if (v79 == v78) {
      goto LABEL_63;
    }
    do
    {
      unint64_t v51 = (void *)*--v49;
      BOOL v50 = v51;
      void *v49 = 0;
      if (v51) {
        operator delete[](v50);
      }
    }
    while (v49 != v23);
    goto LABEL_62;
  }
  *a1 = v9;
LABEL_8:
  uint64_t v10 = mlir::DictionaryAttr::get((uint64_t)&v69, "data_layout", 0xBuLL);
  if (v10)
  {
    uint64_t v11 = v10;
    if (*(_UNKNOWN **)(*(void *)v10 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
    {
      a3(v73, a4);
      if (v73[0])
      {
        LODWORD(v70) = 3;
        uint64_t v72 = 56;
        uint64_t v12 = &v70;
        uint64_t v13 = (char *)v74;
        if (v75 >= v76)
        {
          unint64_t v61 = v75 + 1;
          if (v74 <= &v70 && (char *)v74 + 24 * v75 > (char *)&v70)
          {
            int64_t v66 = (char *)&v70 - (unsigned char *)v74;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v61, 24);
            uint64_t v13 = (char *)v74;
            uint64_t v12 = (uint64_t *)((char *)v74 + v66);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v61, 24);
            uint64_t v12 = &v70;
            uint64_t v13 = (char *)v74;
          }
        }
        unint64_t v14 = &v13[24 * v75];
        long long v15 = *(_OWORD *)v12;
        *((void *)v14 + 2) = v12[2];
        *(_OWORD *)unint64_t v14 = v15;
        ++v75;
        if (v73[0])
        {
          uint64_t v16 = &v70;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v70, v11);
          uint64_t v17 = (char *)v74;
          if (v75 >= v76)
          {
            unint64_t v63 = v75 + 1;
            if (v74 <= &v70 && (char *)v74 + 24 * v75 > (char *)&v70)
            {
              int64_t v68 = (char *)&v70 - (unsigned char *)v74;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v63, 24);
              uint64_t v17 = (char *)v74;
              uint64_t v16 = (uint64_t *)((char *)v74 + v68);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v63, 24);
              uint64_t v16 = &v70;
              uint64_t v17 = (char *)v74;
            }
          }
          uint64_t v18 = &v17[24 * v75];
          long long v19 = *(_OWORD *)v16;
          *((void *)v18 + 2) = v16[2];
          *(_OWORD *)uint64_t v18 = v19;
          ++v75;
          if (v73[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v73);
          }
        }
      }
      if (!v82) {
        return 0;
      }
      uint64_t v20 = (void **)__p;
      if (__p)
      {
        uint64_t v21 = v81;
        long long v22 = __p;
        if (v81 != __p)
        {
          do
            uint64_t v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
          while (v21 != v20);
          long long v22 = __p;
        }
        int64_t v81 = v20;
        operator delete(v22);
      }
      uint64_t v23 = v78;
      if (!v78) {
        goto LABEL_64;
      }
      uint64_t v24 = v79;
      uint64_t v25 = v78;
      if (v79 == v78) {
        goto LABEL_63;
      }
      do
      {
        long long v27 = (void *)*--v24;
        unint64_t v26 = v27;
        void *v24 = 0;
        if (v27) {
          operator delete[](v26);
        }
      }
      while (v24 != v23);
      goto LABEL_62;
    }
    a1[1] = v10;
  }
  uint64_t v52 = mlir::DictionaryAttr::get((uint64_t)&v69, "normalize_coordinates", 0x15uLL);
  uint64_t v70 = v52;
  if (!v52)
  {
LABEL_71:
    uint64_t v54 = mlir::DictionaryAttr::get((uint64_t)&v69, "relative_coordinates", 0x14uLL);
    uint64_t v70 = v54;
    if (v54)
    {
      if (*(_UNKNOWN **)(*(void *)v54 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
      {
        a3(v73, a4);
        goto LABEL_86;
      }
      a1[3] = v54;
    }
    uint64_t v55 = mlir::DictionaryAttr::get((uint64_t)&v69, "similarity_type", 0xFuLL);
    uint64_t v70 = v55;
    if (v55)
    {
      if (*(_UNKNOWN **)(*(void *)v55 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id)
      {
        a3(v73, a4);
        goto LABEL_86;
      }
      a1[4] = v55;
    }
    uint64_t v56 = mlir::DictionaryAttr::get((uint64_t)&v69, "window_height", 0xDuLL);
    uint64_t v70 = v56;
    if (v56)
    {
      if (*(_UNKNOWN **)(*(void *)v56 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        a3(v73, a4);
        goto LABEL_86;
      }
      a1[5] = v56;
    }
    uint64_t v57 = mlir::DictionaryAttr::get((uint64_t)&v69, "window_width", 0xCuLL);
    uint64_t v70 = v57;
    if (v57)
    {
      if (*(_UNKNOWN **)(*(void *)v57 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        a3(v73, a4);
        goto LABEL_86;
      }
      a1[6] = v57;
    }
    return 1;
  }
  if (*(_UNKNOWN **)(*(void *)v52 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    a1[2] = v52;
    goto LABEL_71;
  }
  a3(v73, a4);
LABEL_86:
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v53, &v70);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v73);
  return 0;
}

uint64_t mlir::mps::CostVolumeOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v51[6] = *MEMORY[0x1E4F143B8];
  BOOL v48 = a1;
  unint64_t v49 = v51;
  uint64_t v50 = 0x300000000;
  if (!*a2)
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v48, (uint64_t)"coord_is_x_only", 15, *a2);
  uint64_t v5 = v4;
  unsigned int v6 = v50;
  if (v50 >= HIDWORD(v50))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
    unsigned int v6 = v50;
  }
  uint64_t v7 = (uint64_t *)((char *)v49 + 16 * v6);
  uint64_t *v7 = NamedAttr;
  v7[1] = v5;
  unsigned int v8 = v50 + 1;
  LODWORD(v50) = v50 + 1;
  uint64_t v9 = a2[1];
  if (v9)
  {
LABEL_7:
    uint64_t v10 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"data_layout", 11, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v13 = v50;
    }
    unint64_t v14 = (uint64_t *)((char *)v49 + 16 * v13);
    *unint64_t v14 = v10;
    v14[1] = v12;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
LABEL_10:
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"normalize_coordinates", 21, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v19 = v50;
    }
    uint64_t v20 = (uint64_t *)((char *)v49 + 16 * v19);
    *uint64_t v20 = v16;
    v20[1] = v18;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v21 = a2[3];
  if (v21)
  {
    uint64_t v22 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"relative_coordinates", 20, v21);
    uint64_t v24 = v23;
    unsigned int v25 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v25 = v50;
    }
    unint64_t v26 = (uint64_t *)((char *)v49 + 16 * v25);
    *unint64_t v26 = v22;
    v26[1] = v24;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v27 = a2[4];
  if (v27)
  {
    uint64_t v28 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"similarity_type", 15, v27);
    uint64_t v30 = v29;
    unsigned int v31 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v31 = v50;
    }
    long long v32 = (uint64_t *)((char *)v49 + 16 * v31);
    *long long v32 = v28;
    v32[1] = v30;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v33 = a2[5];
  if (v33)
  {
    uint64_t v34 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"window_height", 13, v33);
    uint64_t v36 = v35;
    unsigned int v37 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v37 = v50;
    }
    unint64_t v38 = (uint64_t *)((char *)v49 + 16 * v37);
    uint64_t *v38 = v34;
    v38[1] = v36;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v39 = a2[6];
  if (v39)
  {
    uint64_t v40 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"window_width", 12, v39);
    uint64_t v42 = v41;
    unsigned int v43 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v43 = v50;
    }
    unint64_t v44 = (uint64_t *)((char *)v49 + 16 * v43);
    uint64_t *v44 = v40;
    v44[1] = v42;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  long long v45 = v49;
  if (!v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v49 == v51) {
      return DictionaryAttr;
    }
    goto LABEL_32;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v48, (uint64_t *)v49, v8);
  long long v45 = v49;
  if (v49 != v51) {
LABEL_32:
  }
    free(v45);
  return DictionaryAttr;
}

uint64_t mlir::mps::CostVolumeOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 0xBuLL:
      if (memcmp(__s1, "data_layout", __n)) {
        return 0;
      }
      return a2[1];
    case 0xCuLL:
      if (memcmp(__s1, "window_width", __n)) {
        return 0;
      }
      return a2[6];
    case 0xDuLL:
      if (memcmp(__s1, "window_height", __n)) {
        return 0;
      }
      return a2[5];
    case 0xEuLL:
    case 0x10uLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x13uLL:
      return 0;
    case 0xFuLL:
      if (*(void *)__s1 == 0x73695F64726F6F63 && *(void *)(__s1 + 7) == 0x796C6E6F5F785F73) {
        return *a2;
      }
      if (memcmp(__s1, "similarity_type", __n)) {
        return 0;
      }
      return a2[4];
    case 0x14uLL:
      if (memcmp(__s1, "relative_coordinates", __n)) {
        return 0;
      }
      return a2[3];
    case 0x15uLL:
      if (memcmp(__s1, "normalize_coordinates", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::CostVolumeOp::setInherentAttr(uint64_t result, char *__s1, size_t a3, void *a4)
{
  uint64_t v5 = (void *)result;
  switch(a3)
  {
    case 0xBuLL:
      uint64_t result = memcmp(__s1, "data_layout", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
            uint64_t v12 = a4;
          }
          else {
            uint64_t v12 = 0;
          }
          v5[1] = v12;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0xCuLL:
      uint64_t result = memcmp(__s1, "window_width", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
            unsigned int v6 = a4;
          }
          else {
            unsigned int v6 = 0;
          }
          v5[6] = v6;
        }
        else
        {
          v5[6] = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "window_height", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
            uint64_t v7 = a4;
          }
          else {
            uint64_t v7 = 0;
          }
          v5[5] = v7;
        }
        else
        {
          v5[5] = 0;
        }
      }
      break;
    case 0xFuLL:
      if (*(void *)__s1 == 0x73695F64726F6F63 && *(void *)(__s1 + 7) == 0x796C6E6F5F785F73)
      {
        if (a4)
        {
          uint64_t result = mlir::BoolAttr::classof(a4);
          if (result) {
            unsigned int v13 = a4;
          }
          else {
            unsigned int v13 = 0;
          }
          void *v5 = v13;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      else
      {
        uint64_t result = memcmp(__s1, "similarity_type", a3);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id) {
              uint64_t v9 = a4;
            }
            else {
              uint64_t v9 = 0;
            }
            v5[4] = v9;
          }
          else
          {
            v5[4] = 0;
          }
        }
      }
      break;
    case 0x14uLL:
      uint64_t result = memcmp(__s1, "relative_coordinates", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          v5[3] = v10;
        }
        else
        {
          v5[3] = 0;
        }
      }
      break;
    case 0x15uLL:
      uint64_t result = memcmp(__s1, "normalize_coordinates", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          void v5[2] = v11;
        }
        else
        {
          void v5[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::CostVolumeOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (*a2) {
    mlir::NamedAttrList::append(a3, (uint64_t)"coord_is_x_only", 15, *a2);
  }
  uint64_t v5 = a2[1];
  if (v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"data_layout", 11, v5);
  }
  uint64_t v6 = a2[2];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"normalize_coordinates", 21, v6);
  }
  uint64_t v7 = a2[3];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"relative_coordinates", 20, v7);
  }
  uint64_t v8 = a2[4];
  if (v8) {
    mlir::NamedAttrList::append(a3, (uint64_t)"similarity_type", 15, v8);
  }
  uint64_t v9 = a2[5];
  if (v9) {
    mlir::NamedAttrList::append(a3, (uint64_t)"window_height", 13, v9);
  }
  uint64_t v10 = a2[6];
  if (v10)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"window_width", 12, v10);
  }
}

BOOL mlir::mps::CostVolumeOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = (void *)mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps2(v8, (const void **)"coord_is_x_only", (const char *)0xF, a3, a4))
  {
    uint64_t v9 = (_DWORD *)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(v9, (const void **)"data_layout", (const char *)0xB, a3, a4))
    {
      uint64_t v10 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v10, (const void **)"normalize_coordinates", (const char *)0x15, a3, a4))
      {
        uint64_t v11 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 24));
        if (!v11
          || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v11, (const void **)"relative_coordinates", (const char *)0x14, a3, a4))
        {
          uint64_t v12 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps16(v12, (const void **)"similarity_type", (const char *)0xF, a3, a4))
          {
            unsigned int v13 = (const void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v13, (const void **)"window_height", (const char *)0xD, a3, a4))
            {
              unint64_t v14 = (const void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 48));
              if (!v14
                || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v14, (const void **)"window_width", (const char *)0xC, a3, a4))
              {
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps16(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    uint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    uint64_t v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = (char *)v35;
        uint64_t v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        uint64_t v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      uint64_t v29 = a2;
      uint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        uint64_t v30 = "' failed to satisfy constraint: valid SimilarityType";
        uint64_t v31 = 52;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        unsigned int v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)unsigned int v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    uint64_t v16 = (void **)__p;
    if (__p)
    {
      uint64_t v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          uint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      uint64_t v42 = v16;
      operator delete(v18);
    }
    unsigned int v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      uint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = (void *)*--v20;
          uint64_t v22 = v23;
          *uint64_t v20 = 0;
          if (v23) {
            operator delete[](v22);
          }
        }
        while (v20 != v19);
        uint64_t v21 = v39;
      }
      uint64_t v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

BOOL mlir::mps::CostVolumeOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::BoolAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 1)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 2)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 3)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::SimilarityTypeAttr>(a1, v3 + 4)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::IntegerAttr>(a1, v3 + 5)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::IntegerAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x38uLL);
    *uint64_t v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    *((void *)v3 + 6) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        unsigned int v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 111;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[31];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::SimilarityTypeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  if (!v39) {
    return 1;
  }
  int v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id) {
    return 1;
  }
  unsigned char v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    unint64_t v6 = &v40;
    unint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v7 = (char *)v46;
        unint64_t v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v6 = &v40;
        unint64_t v7 = (char *)v46;
      }
    }
    uint64_t v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)uint64_t v8 = v9;
    ++v47;
  }
  uint64_t v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::SimilarityTypeAttr]";
  unint64_t v41 = 79;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    uint64_t v40 = (const void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      unint64_t v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          unint64_t v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          unint64_t v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      uint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)uint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unsigned int v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unsigned int v19 = (char *)v46;
            uint64_t v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            unsigned int v19 = (char *)v46;
          }
        }
        uint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = (void **)__p;
    if (__p)
    {
      uint64_t v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      uint64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = (void *)*--v27;
          uint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            operator delete[](v29);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      unint64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

BOOL mlir::mps::CostVolumeOp::getNormalizeCoordinates(mlir::mps::CostVolumeOp *this)
{
  unint64_t v1 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v1 = 0;
  }
  return *(void *)(v1 + 16) != 0;
}

void mlir::mps::CostVolumeOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7, uint64_t a8, uint64_t a9, unsigned int a10, unsigned int a11, uint64_t a12)
{
  v49[2] = *MEMORY[0x1E4F143B8];
  uint64_t v42 = a4;
  uint64_t v43 = a3;
  uint64_t v41 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v43, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v42, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v41, 1);
  if (a6)
  {
    uint64_t UnitAttr = mlir::Builder::getUnitAttr(a1, v17);
    *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>((void *)a2)
              + 16) = UnitAttr;
  }
  if (a7)
  {
    uint64_t v19 = mlir::Builder::getUnitAttr(a1, v17);
    *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>((void *)a2)
              + 24) = v19;
  }
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)a1, 0x40u, 0);
  uint64_t IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a8);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>((void *)a2)
            + 40) = IntegerAttr;
  uint64_t v22 = mlir::Builder::getIntegerType((mlir::Builder *)a1, 0x40u, 0);
  uint64_t v23 = mlir::Builder::getIntegerAttr((uint64_t)a1, v22, a9);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>((void *)a2)
            + 48) = v23;
  uint64_t v24 = *a1;
  unsigned int v44 = a10;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v24);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id;
  uint64_t v48 = (uint64_t)v24;
  uint64_t v26 = mlir::StorageUniquer::get<mlir::mps::detail::SimilarityTypeAttrStorage,mlir::mps::SimilarityType>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25SimilarityTypeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18SimilarityTypeAttrEJNS2_14SimilarityTypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id, &v44);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>((void *)a2)
            + 32) = v26;
  int64_t v27 = *a1;
  unsigned int v44 = a11;
  int64_t v28 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v27);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  uint64_t v48 = (uint64_t)v27;
  uint64_t v29 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v28, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v44);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = v29;
  if (a12) {
    *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>((void *)a2) = a12;
  }
  __src = v49;
  uint64_t v48 = 0x200000000;
  uint64_t v30 = *a1;
  mlir::ValueRange::ValueRange(v46, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  unint64_t v33 = *(uint64_t **)(a2 + 256);
  mlir::ValueRange::ValueRange(v45, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::CostVolumeOp::inferReturnTypes(v30, v34, v35, v46[0], v46[1], Dictionary, v33, v36, v45[0], v45[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  int64_t v37 = __src;
  }
  uint64_t v38 = v48;
  uint64_t v39 = *(unsigned int *)(a2 + 72);
  unint64_t v40 = v39 + v48;
  if (v40 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v40, 8);
    LODWORD(v39) = *(_DWORD *)(a2 + 72);
  }
  if (v38)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v39), v37, 8 * v38);
    LODWORD(v39) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v39 + v38;
  if (__src != v49) {
    free(__src);
  }
}

mlir::MLIRContext *mlir::mps::CostVolumeOp::populateDefaultProperties(uint64_t a1, void *a2)
{
  uint64_t v12 = *(void **)(a1 + 8);
  uint64_t result = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  unint64_t v10 = result;
  if (a2[5])
  {
    if (a2[6]) {
      goto LABEL_3;
    }
  }
  else
  {
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)&v10, 0x40u, 0);
    uint64_t result = (mlir::MLIRContext *)mlir::Builder::getIntegerAttr((uint64_t)&v10, IntegerType, 1);
    a2[5] = result;
    if (a2[6])
    {
LABEL_3:
      if (a2[4]) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  uint64_t v5 = mlir::Builder::getIntegerType((mlir::Builder *)&v10, 0x40u, 0);
  uint64_t result = (mlir::MLIRContext *)mlir::Builder::getIntegerAttr((uint64_t)&v10, v5, 1);
  a2[6] = result;
  if (a2[4])
  {
LABEL_4:
    if (a2[1]) {
      return result;
    }
LABEL_9:
    uint64_t v8 = v10;
    unsigned int v11 = 0;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v10);
    uint64_t v12 = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
    unint64_t v13 = v8;
    uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v11);
    a2[1] = result;
    return result;
  }
LABEL_8:
  unint64_t v6 = v10;
  unsigned int v11 = 0;
  unint64_t v7 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v10);
  uint64_t v12 = &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id;
  unint64_t v13 = v6;
  uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::SimilarityTypeAttrStorage,mlir::mps::SimilarityType>(v7, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25SimilarityTypeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18SimilarityTypeAttrEJNS2_14SimilarityTypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id, &v11);
  a2[4] = result;
  if (!a2[1]) {
    goto LABEL_9;
  }
  return result;
}

BOOL mlir::mps::CostVolumeOp::verifyInvariantsImpl(uint64_t **this)
{
  __int16 v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    unint64_t v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    unint64_t v3 = 0;
  }
  uint64_t v4 = *(void **)v3;
  uint64_t v5 = *(_DWORD **)(v3 + 8);
  uint64_t v6 = *(void *)(v3 + 16);
  uint64_t v7 = *(void *)(v3 + 24);
  uint64_t v8 = *(void *)(v3 + 32);
  long long v9 = *(const void ***)(v3 + 40);
  unint64_t v10 = *(const void ***)(v3 + 48);
  unint64_t v14 = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v6, (const void **)"normalize_coordinates", (const char *)0x15, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0; {
  unint64_t v14 = *this;
  }
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (const void **)"relative_coordinates", (const char *)0x14, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0; {
  unint64_t v14 = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v9, (const void **)"window_height", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0; {
  unint64_t v14 = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v10, (const void **)"window_width", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0; {
  unint64_t v14 = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps16(v8, (const void **)"similarity_type", (const char *)0xF, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps16(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0; {
  unint64_t v14 = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(v5, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0; {
  unint64_t v14 = *this;
  }
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps2(v4, (const void **)"coord_is_x_only", (const char *)0xF, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps17(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps17(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps17(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps17(*this,
                           (const void **)(*(void *)(*(void *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8),
                           (const void **)"operand",
                           7,
                           2u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v11 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps17(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  unint64_t v10 = *a2;
  uint64_t v11 = (void *)*((void *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v61[0] = a2;
    v61[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
    if (mlir::Type::isF16((mlir::Type *)&OperandRange)
      || mlir::Type::isF32((mlir::Type *)&OperandRange)
      || mlir::Type::isBF16((mlir::Type *)&OperandRange))
    {
      return 1;
    }
    unint64_t v10 = *a2;
    if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
LABEL_3:
      uint64_t v53 = a2;
      uint64_t v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53)) {
        goto LABEL_14;
      }
      uint64_t v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      __int16 v58 = a2;
      uint64_t v59 = v12;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
      if (v13 != 4) {
        goto LABEL_14;
      }
      uint64_t v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v56[0] = a2;
      v56[1] = v14;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
      if (!mlir::Type::isF16((mlir::Type *)&OperandRange)
        && !mlir::Type::isF32((mlir::Type *)&OperandRange)
        && !mlir::Type::isBF16((mlir::Type *)&OperandRange))
      {
        goto LABEL_14;
      }
      return 1;
    }
  }
  else if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    goto LABEL_3;
  }
LABEL_14:
  __int16 v55 = 261;
  uint64_t v53 = a3;
  uint64_t v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v61);
  if (v61[0])
  {
    LODWORD(v58) = 3;
    uint64_t v59 = (uint64_t)" #";
    uint64_t v60 = 2;
    uint64_t v16 = &v58;
    long long v17 = (char *)v62;
    if (v63 >= v64)
    {
      unint64_t v43 = v63 + 1;
      if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
      {
        int64_t v49 = (char *)&v58 - (unsigned char *)v62;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        long long v17 = (char *)v62;
        uint64_t v16 = (const void ***)((char *)v62 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        uint64_t v16 = &v58;
        long long v17 = (char *)v62;
      }
    }
    uint64_t v18 = &v17[24 * v63];
    long long v19 = *(_OWORD *)v16;
    *((void *)v18 + 2) = v16[2];
    *(_OWORD *)uint64_t v18 = v19;
    uint64_t v20 = ++v63;
    if (v61[0])
    {
      LODWORD(v58) = 5;
      uint64_t v59 = a5;
      long long v21 = &v58;
      uint64_t v22 = (char *)v62;
      if (v20 >= v64)
      {
        unint64_t v44 = v20 + 1;
        BOOL v45 = (char *)v62 + 24 * v20 > (char *)&v58;
        if (v62 <= &v58 && v45)
        {
          int64_t v50 = (char *)&v58 - (unsigned char *)v62;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          uint64_t v22 = (char *)v62;
          long long v21 = (const void ***)((char *)v62 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          long long v21 = &v58;
          uint64_t v22 = (char *)v62;
        }
      }
      uint64_t v23 = &v22[24 * v63];
      long long v24 = *(_OWORD *)v21;
      *((void *)v23 + 2) = v21[2];
      *(_OWORD *)uint64_t v23 = v24;
      uint64_t v25 = ++v63;
      if (v61[0])
      {
        LODWORD(v58) = 3;
        uint64_t v59 = (uint64_t)" must be unranked tensor of floating point values or 4D tensor of floating point values, but got ";
        uint64_t v60 = 97;
        uint64_t v26 = &v58;
        int64_t v27 = (char *)v62;
        if (v25 >= v64)
        {
          unint64_t v46 = v25 + 1;
          BOOL v47 = (char *)v62 + 24 * v25 > (char *)&v58;
          if (v62 <= &v58 && v47)
          {
            int64_t v51 = (char *)&v58 - (unsigned char *)v62;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            int64_t v27 = (char *)v62;
            uint64_t v26 = (const void ***)((char *)v62 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            uint64_t v26 = &v58;
            int64_t v27 = (char *)v62;
          }
        }
        int64_t v28 = &v27[24 * v63];
        long long v29 = *(_OWORD *)v26;
        *((void *)v28 + 2) = v26[2];
        *(_OWORD *)int64_t v28 = v29;
        ++v63;
        if (v61[0])
        {
          uint64_t v30 = &v58;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v58, (uint64_t)a2);
          uint64_t v31 = (char *)v62;
          if (v63 >= v64)
          {
            unint64_t v48 = v63 + 1;
            if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
            {
              int64_t v52 = (char *)&v58 - (unsigned char *)v62;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              uint64_t v31 = (char *)v62;
              uint64_t v30 = (const void ***)((char *)v62 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              uint64_t v30 = &v58;
              uint64_t v31 = (char *)v62;
            }
          }
          unint64_t v32 = &v31[24 * v63];
          long long v33 = *(_OWORD *)v30;
          *((void *)v32 + 2) = v30[2];
          *(_OWORD *)unint64_t v32 = v33;
          ++v63;
        }
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v61);
  if (v61[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v61);
  }
  if (v70)
  {
    uint64_t v34 = (void **)__p;
    if (__p)
    {
      uint64_t v35 = v69;
      uint64_t v36 = __p;
      if (v69 != __p)
      {
        do
          uint64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        uint64_t v36 = __p;
      }
      uint64_t v69 = v34;
      operator delete(v36);
    }
    int64_t v37 = v66;
    if (v66)
    {
      uint64_t v38 = v67;
      uint64_t v39 = v66;
      if (v67 != v66)
      {
        do
        {
          uint64_t v41 = (void *)*--v38;
          unint64_t v40 = v41;
          void *v38 = 0;
          if (v41) {
            operator delete[](v40);
          }
        }
        while (v38 != v37);
        uint64_t v39 = v66;
      }
      int64_t v67 = v37;
      operator delete(v39);
    }
    if (v62 != v65) {
      free(v62);
    }
  }
  return v15;
}

uint64_t mlir::mps::CostVolumeOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.cost_volume", 15, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC97FDB8;
  v4[12] = mlir::mps::CostVolumeOp::canonicalize;
  long long v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    long long v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::CreateComplexOpGenericAdaptorBase::CreateComplexOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.create_complex", 18, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::CreateComplexOp::build(mlir::Float32Type **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v25[2] = *MEMORY[0x1E4F143B8];
  uint64_t v19 = a4;
  uint64_t v20 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v20, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v19, 1);
  __src = v25;
  uint64_t v24 = 0x200000000;
  unint64_t v6 = *a1;
  mlir::ValueRange::ValueRange((unint64_t *)v22, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v21, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::CreateComplexOp::inferReturnTypes(v6, v8, v9, v22[0], (uint64_t)v22[1], v10, v11, v12, v17, v18, (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v13 = __src;
  }
  uint64_t v14 = v24;
  uint64_t v15 = *(unsigned int *)(a2 + 72);
  unint64_t v16 = v15 + v24;
  if (v16 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v16, 8);
    LODWORD(v15) = *(_DWORD *)(a2 + 72);
  }
  if (v14)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v15), v13, 8 * v14);
    LODWORD(v15) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v15 + v14;
  if (__src != v25) {
    free(__src);
  }
}

uint64_t mlir::mps::CreateComplexOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps18(*this, *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps18(*this, *(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
  {
    return 0;
  }
  uint64_t v2 = *((_DWORD *)*this + 9) ? (uint64_t)(*this - 2) : 0;
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps19(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0))return 0; {
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(void *)((*this)[9] + 24));
  }
  if (ElementTypeOrSelf == mlir::getElementTypeOrSelf(*(void *)((*this)[9] + 56)))
  {
    uint64_t v5 = mlir::getElementTypeOrSelf(*(void *)((*this)[9] + 56));
    if (v5 == mlir::getElementTypeOrSelf(*(void *)((*this)[9] + 24))) {
      return 1;
    }
  }
  unint64_t v16 = (const void **)"failed to verify that all of {real, imag} have same element type";
  __int16 v17 = 259;
  mlir::OpState::emitOpError(this, &v16, (uint64_t)v18);
  uint64_t v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v18);
  if (v18[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
  }
  if (v25)
  {
    uint64_t v7 = (void **)__p;
    if (__p)
    {
      uint64_t v8 = v24;
      uint64_t v9 = __p;
      if (v24 != __p)
      {
        do
          uint64_t v8 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v8 - 1);
        while (v8 != v7);
        uint64_t v9 = __p;
      }
      uint64_t v24 = v7;
      operator delete(v9);
    }
    uint64_t v10 = v21;
    if (v21)
    {
      uint64_t v11 = v22;
      uint64_t v12 = v21;
      if (v22 != v21)
      {
        do
        {
          uint64_t v14 = (void *)*--v11;
          uint64_t v13 = v14;
          void *v11 = 0;
          if (v14) {
            operator delete[](v13);
          }
        }
        while (v11 != v10);
        uint64_t v12 = v21;
      }
      uint64_t v22 = v10;
      operator delete(v12);
    }
    if (v19 != &v20) {
      free(v19);
    }
  }
  return v6;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps18(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *(void *)a2;
  uint64_t v11 = *(void **)(*(void *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isF16((mlir::Type *)v51) || mlir::Type::isF32((mlir::Type *)v51)) {
      return 1;
    }
  }
  __int16 v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    int v53 = 3;
    uint64_t v54 = " #";
    uint64_t v55 = 2;
    uint64_t v14 = &v53;
    uint64_t v15 = (char *)v57;
    if (v58 >= v59)
    {
      unint64_t v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        int64_t v47 = (char *)&v53 - (unsigned char *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        uint64_t v15 = (char *)v57;
        uint64_t v14 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        uint64_t v14 = &v53;
        uint64_t v15 = (char *)v57;
      }
    }
    unint64_t v16 = &v15[24 * v58];
    long long v17 = *(_OWORD *)v14;
    *((void *)v16 + 2) = *((void *)v14 + 2);
    *(_OWORD *)unint64_t v16 = v17;
    uint64_t v18 = ++v58;
    if (v56[0])
    {
      int v53 = 5;
      uint64_t v54 = (const char *)a5;
      uint64_t v19 = &v53;
      uint64_t v20 = (char *)v57;
      if (v18 >= v59)
      {
        unint64_t v42 = v18 + 1;
        BOOL v43 = (char *)v57 + 24 * v18 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          int64_t v48 = (char *)&v53 - (unsigned char *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          uint64_t v20 = (char *)v57;
          uint64_t v19 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          uint64_t v19 = &v53;
          uint64_t v20 = (char *)v57;
        }
      }
      unint64_t v21 = &v20[24 * v58];
      long long v22 = *(_OWORD *)v19;
      *((void *)v21 + 2) = *((void *)v19 + 2);
      *(_OWORD *)unint64_t v21 = v22;
      uint64_t v23 = ++v58;
      if (v56[0])
      {
        int v53 = 3;
        uint64_t v54 = " must be tensor of 16-bit float or 32-bit float values, but got ";
        uint64_t v55 = 64;
        uint64_t v24 = &v53;
        char v25 = (char *)v57;
        if (v23 >= v59)
        {
          unint64_t v44 = v23 + 1;
          BOOL v45 = (char *)v57 + 24 * v23 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            int64_t v49 = (char *)&v53 - (unsigned char *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            char v25 = (char *)v57;
            uint64_t v24 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            uint64_t v24 = &v53;
            char v25 = (char *)v57;
          }
        }
        uint64_t v26 = &v25[24 * v58];
        long long v27 = *(_OWORD *)v24;
        *((void *)v26 + 2) = *((void *)v24 + 2);
        *(_OWORD *)uint64_t v26 = v27;
        ++v58;
        if (v56[0])
        {
          int64_t v28 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          long long v29 = (char *)v57;
          if (v58 >= v59)
          {
            unint64_t v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              int64_t v50 = (char *)&v53 - (unsigned char *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              long long v29 = (char *)v57;
              int64_t v28 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              int64_t v28 = &v53;
              long long v29 = (char *)v57;
            }
          }
          uint64_t v30 = &v29[24 * v58];
          long long v31 = *(_OWORD *)v28;
          *((void *)v30 + 2) = *((void *)v28 + 2);
          *(_OWORD *)uint64_t v30 = v31;
          ++v58;
        }
      }
    }
  }
  uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  }
  if (v65)
  {
    unint64_t v32 = (void **)__p;
    if (__p)
    {
      long long v33 = v64;
      uint64_t v34 = __p;
      if (v64 != __p)
      {
        do
          long long v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        uint64_t v34 = __p;
      }
      unsigned int v64 = v32;
      operator delete(v34);
    }
    uint64_t v35 = v61;
    if (v61)
    {
      uint64_t v36 = v62;
      int64_t v37 = v61;
      if (v62 != v61)
      {
        do
        {
          uint64_t v39 = (void *)*--v36;
          uint64_t v38 = v39;
          *uint64_t v36 = 0;
          if (v39) {
            operator delete[](v38);
          }
        }
        while (v36 != v35);
        int64_t v37 = v61;
      }
      unint64_t v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60) {
      free(v57);
    }
  }
  return v13;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps19(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *(void *)a2;
  uint64_t v11 = *(void **)(*(void *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v60[0] = a2;
    v60[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v60);
    if (*(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      uint64_t v41 = OperandRange;
      uint64_t v57 = OperandRange;
      v53[0] = (const void **)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v57);
      if (mlir::Type::isF16((mlir::Type *)v53)) {
        return 1;
      }
      uint64_t v55 = v41;
      uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v55);
      if (mlir::Type::isF32((mlir::Type *)&Value)) {
        return 1;
      }
    }
  }
  __int16 v54 = 261;
  v53[0] = a3;
  v53[1] = a4;
  mlir::Operation::emitOpError(a1, v53, (uint64_t)v60);
  if (v60[0])
  {
    LODWORD(v57) = 3;
    unsigned int v58 = " #";
    uint64_t v59 = 2;
    uint64_t v14 = &v57;
    uint64_t v15 = (char *)v61;
    if (v62 >= v63)
    {
      unint64_t v43 = v62 + 1;
      if (v61 <= &v57 && (char *)v61 + 24 * v62 > (char *)&v57)
      {
        int64_t v49 = (char *)&v57 - (unsigned char *)v61;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v43, 24);
        uint64_t v15 = (char *)v61;
        uint64_t v14 = (uint64_t *)((char *)v61 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v43, 24);
        uint64_t v14 = &v57;
        uint64_t v15 = (char *)v61;
      }
    }
    unint64_t v16 = &v15[24 * v62];
    long long v17 = *(_OWORD *)v14;
    *((void *)v16 + 2) = v14[2];
    *(_OWORD *)unint64_t v16 = v17;
    uint64_t v18 = ++v62;
    if (v60[0])
    {
      LODWORD(v57) = 5;
      unsigned int v58 = (const char *)a5;
      uint64_t v19 = &v57;
      uint64_t v20 = (char *)v61;
      if (v18 >= v63)
      {
        unint64_t v44 = v18 + 1;
        BOOL v45 = (char *)v61 + 24 * v18 > (char *)&v57;
        if (v61 <= &v57 && v45)
        {
          int64_t v50 = (char *)&v57 - (unsigned char *)v61;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v44, 24);
          uint64_t v20 = (char *)v61;
          uint64_t v19 = (uint64_t *)((char *)v61 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v44, 24);
          uint64_t v19 = &v57;
          uint64_t v20 = (char *)v61;
        }
      }
      unint64_t v21 = &v20[24 * v62];
      long long v22 = *(_OWORD *)v19;
      *((void *)v21 + 2) = v19[2];
      *(_OWORD *)unint64_t v21 = v22;
      uint64_t v23 = ++v62;
      if (v60[0])
      {
        LODWORD(v57) = 3;
        unsigned int v58 = " must be tensor of complex values, but got ";
        uint64_t v59 = 43;
        uint64_t v24 = &v57;
        char v25 = (char *)v61;
        if (v23 >= v63)
        {
          unint64_t v46 = v23 + 1;
          BOOL v47 = (char *)v61 + 24 * v23 > (char *)&v57;
          if (v61 <= &v57 && v47)
          {
            int64_t v51 = (char *)&v57 - (unsigned char *)v61;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v46, 24);
            char v25 = (char *)v61;
            uint64_t v24 = (uint64_t *)((char *)v61 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v46, 24);
            uint64_t v24 = &v57;
            char v25 = (char *)v61;
          }
        }
        uint64_t v26 = &v25[24 * v62];
        long long v27 = *(_OWORD *)v24;
        *((void *)v26 + 2) = v24[2];
        *(_OWORD *)uint64_t v26 = v27;
        ++v62;
        if (v60[0])
        {
          int64_t v28 = &v57;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v57, a2);
          long long v29 = (char *)v61;
          if (v62 >= v63)
          {
            unint64_t v48 = v62 + 1;
            if (v61 <= &v57 && (char *)v61 + 24 * v62 > (char *)&v57)
            {
              int64_t v52 = (char *)&v57 - (unsigned char *)v61;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v48, 24);
              long long v29 = (char *)v61;
              int64_t v28 = (uint64_t *)((char *)v61 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v48, 24);
              int64_t v28 = &v57;
              long long v29 = (char *)v61;
            }
          }
          uint64_t v30 = &v29[24 * v62];
          long long v31 = *(_OWORD *)v28;
          *((void *)v30 + 2) = v28[2];
          *(_OWORD *)uint64_t v30 = v31;
          ++v62;
        }
      }
    }
  }
  uint64_t v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v60);
  if (v60[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v60);
  }
  if (v69)
  {
    long long v33 = (void **)__p;
    if (__p)
    {
      uint64_t v34 = v68;
      uint64_t v35 = __p;
      if (v68 != __p)
      {
        do
          uint64_t v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
        while (v34 != v33);
        uint64_t v35 = __p;
      }
      int64_t v68 = v33;
      operator delete(v35);
    }
    uint64_t v36 = v65;
    if (v65)
    {
      int64_t v37 = v66;
      uint64_t v38 = v65;
      if (v66 != v65)
      {
        do
        {
          unint64_t v40 = (void *)*--v37;
          uint64_t v39 = v40;
          *int64_t v37 = 0;
          if (v40) {
            operator delete[](v39);
          }
        }
        while (v37 != v36);
        uint64_t v38 = v65;
      }
      uint64_t v66 = v36;
      operator delete(v38);
    }
    if (v61 != v64) {
      free(v61);
    }
  }
  return v32;
}

uint64_t mlir::mps::CreateComplexOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.create_complex", 18, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC9807B0;
  v4[12] = mlir::mps::CreateComplexOp::canonicalize;
  uint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::CreateTextureTensorOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v89 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v75 = v6;
  if (!v6)
  {
    a3(v79, a4);
    if (v79[0])
    {
      int v76 = 3;
      unint64_t v77 = "expected DictionaryAttr to set properties";
      uint64_t v78 = 41;
      uint64_t v26 = &v76;
      long long v27 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v63 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v69 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          long long v27 = (char *)v80;
          uint64_t v26 = (int *)((char *)v80 + v69);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          uint64_t v26 = &v76;
          long long v27 = (char *)v80;
        }
      }
      int64_t v28 = &v27[24 * v81];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)int64_t v28 = v29;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
    if (!v88) {
      return 0;
    }
    uint64_t v30 = (void **)__p;
    if (__p)
    {
      long long v31 = v87;
      uint64_t v32 = __p;
      if (v87 != __p)
      {
        do
          long long v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        uint64_t v32 = __p;
      }
      uint64_t v87 = v30;
      operator delete(v32);
    }
    unint64_t v21 = v84;
    if (!v84) {
      goto LABEL_80;
    }
    long long v33 = v85;
    uint64_t v23 = v84;
    if (v85 == v84) {
      goto LABEL_79;
    }
    do
    {
      uint64_t v35 = (void *)*--v33;
      uint64_t v34 = v35;
      *long long v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
    goto LABEL_78;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v75, "compressed", 0xAuLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v79, a4);
      if (v79[0])
      {
        int v76 = 3;
        uint64_t v78 = 55;
        uint64_t v10 = &v76;
        uint64_t v11 = (char *)v80;
        if (v81 >= v82)
        {
          unint64_t v64 = v81 + 1;
          if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
          {
            int64_t v70 = (char *)&v76 - (unsigned char *)v80;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            uint64_t v11 = (char *)v80;
            uint64_t v10 = (int *)((char *)v80 + v70);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            uint64_t v10 = &v76;
            uint64_t v11 = (char *)v80;
          }
        }
        uint64_t v12 = &v11[24 * v81];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = *((void *)v10 + 2);
        *(_OWORD *)uint64_t v12 = v13;
        ++v81;
        if (v79[0])
        {
          uint64_t v14 = &v76;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v9);
          uint64_t v15 = (char *)v80;
          if (v81 >= v82)
          {
            unint64_t v65 = v81 + 1;
            if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
            {
              int64_t v71 = (char *)&v76 - (unsigned char *)v80;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              uint64_t v15 = (char *)v80;
              uint64_t v14 = (int *)((char *)v80 + v71);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              uint64_t v14 = &v76;
              uint64_t v15 = (char *)v80;
            }
          }
          unint64_t v16 = &v15[24 * v81];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = *((void *)v14 + 2);
          *(_OWORD *)unint64_t v16 = v17;
          ++v81;
          if (v79[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
          }
        }
      }
      if (!v88) {
        return 0;
      }
      uint64_t v18 = (void **)__p;
      if (__p)
      {
        uint64_t v19 = v87;
        uint64_t v20 = __p;
        if (v87 != __p)
        {
          do
            uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          uint64_t v20 = __p;
        }
        uint64_t v87 = v18;
        operator delete(v20);
      }
      unint64_t v21 = v84;
      if (!v84) {
        goto LABEL_80;
      }
      long long v22 = v85;
      uint64_t v23 = v84;
      if (v85 == v84) {
        goto LABEL_79;
      }
      do
      {
        char v25 = (void *)*--v22;
        uint64_t v24 = v25;
        *long long v22 = 0;
        if (v25) {
          operator delete[](v24);
        }
      }
      while (v22 != v21);
      goto LABEL_78;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v75, "pixel_format", 0xCuLL);
  if (!v36)
  {
    a3(v79, a4);
    if (v79[0])
    {
      int v76 = 3;
      unint64_t v77 = "expected key entry for pixel_format in DictionaryAttr to set Properties.";
      uint64_t v78 = 72;
      int64_t v52 = &v76;
      int v53 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v67 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v73 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          int v53 = (char *)v80;
          int64_t v52 = (int *)((char *)v80 + v73);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          int64_t v52 = &v76;
          int v53 = (char *)v80;
        }
      }
      __int16 v54 = &v53[24 * v81];
      long long v55 = *(_OWORD *)v52;
      *((void *)v54 + 2) = *((void *)v52 + 2);
      *(_OWORD *)__int16 v54 = v55;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
    if (!v88) {
      return 0;
    }
    uint64_t v56 = (void **)__p;
    if (__p)
    {
      uint64_t v57 = v87;
      unsigned int v58 = __p;
      if (v87 != __p)
      {
        do
          uint64_t v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        unsigned int v58 = __p;
      }
      uint64_t v87 = v56;
      operator delete(v58);
    }
    unint64_t v21 = v84;
    if (!v84) {
      goto LABEL_80;
    }
    uint64_t v59 = v85;
    uint64_t v23 = v84;
    if (v85 == v84) {
      goto LABEL_79;
    }
    do
    {
      unint64_t v61 = (void *)*--v59;
      uint64_t v60 = v61;
      void *v59 = 0;
      if (v61) {
        operator delete[](v60);
      }
    }
    while (v59 != v21);
    goto LABEL_78;
  }
  uint64_t v37 = v36;
  if (*(_UNKNOWN **)(*(void *)v36 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id)
  {
    a1[1] = v36;
    return 1;
  }
  a3(v79, a4);
  if (v79[0])
  {
    int v76 = 3;
    uint64_t v78 = 57;
    uint64_t v38 = &v76;
    uint64_t v39 = (char *)v80;
    if (v81 >= v82)
    {
      unint64_t v66 = v81 + 1;
      if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
      {
        int64_t v72 = (char *)&v76 - (unsigned char *)v80;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        uint64_t v39 = (char *)v80;
        uint64_t v38 = (int *)((char *)v80 + v72);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        uint64_t v38 = &v76;
        uint64_t v39 = (char *)v80;
      }
    }
    unint64_t v40 = &v39[24 * v81];
    long long v41 = *(_OWORD *)v38;
    *((void *)v40 + 2) = *((void *)v38 + 2);
    *(_OWORD *)unint64_t v40 = v41;
    ++v81;
    if (v79[0])
    {
      unint64_t v42 = &v76;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v37);
      unint64_t v43 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v68 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v74 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          unint64_t v43 = (char *)v80;
          unint64_t v42 = (int *)((char *)v80 + v74);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          unint64_t v42 = &v76;
          unint64_t v43 = (char *)v80;
        }
      }
      unint64_t v44 = &v43[24 * v81];
      long long v45 = *(_OWORD *)v42;
      *((void *)v44 + 2) = *((void *)v42 + 2);
      *(_OWORD *)unint64_t v44 = v45;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
  }
  if (v88)
  {
    unint64_t v46 = (void **)__p;
    if (__p)
    {
      BOOL v47 = v87;
      unint64_t v48 = __p;
      if (v87 != __p)
      {
        do
          BOOL v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        unint64_t v48 = __p;
      }
      uint64_t v87 = v46;
      operator delete(v48);
    }
    unint64_t v21 = v84;
    if (!v84) {
      goto LABEL_80;
    }
    int64_t v49 = v85;
    uint64_t v23 = v84;
    if (v85 == v84)
    {
LABEL_79:
      int64_t v85 = v21;
      operator delete(v23);
LABEL_80:
      if (v80 != v83) {
        free(v80);
      }
      return 0;
    }
    do
    {
      int64_t v51 = (void *)*--v49;
      int64_t v50 = v51;
      void *v49 = 0;
      if (v51) {
        operator delete[](v50);
      }
    }
    while (v49 != v21);
LABEL_78:
    uint64_t v23 = v84;
    goto LABEL_79;
  }
  return 0;
}

uint64_t mlir::mps::CreateTextureTensorOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v21[6] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a1;
  uint64_t v19 = v21;
  uint64_t v20 = 0x300000000;
  if (*a2)
  {
    uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"compressed", 10, *a2);
    uint64_t v5 = v4;
    unsigned int v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      unsigned int v6 = v20;
    }
    uint64_t v7 = (uint64_t *)((char *)v19 + 16 * v6);
    uint64_t *v7 = NamedAttr;
    v7[1] = v5;
    unsigned int v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    uint64_t v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      uint64_t v10 = (uint64_t *)v19;
      if (v8) {
        goto LABEL_6;
      }
LABEL_13:
      uint64_t DictionaryAttr = 0;
      if (v10 == v21) {
        return DictionaryAttr;
      }
      goto LABEL_7;
    }
  }
  else
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_5;
    }
  }
  uint64_t v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"pixel_format", 12, v9);
  uint64_t v15 = v14;
  unsigned int v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    unsigned int v16 = v20;
  }
  long long v17 = (uint64_t *)((char *)v19 + 16 * v16);
  *long long v17 = v13;
  v17[1] = v15;
  unsigned int v8 = v20 + 1;
  LODWORD(v20) = v8;
  uint64_t v10 = (uint64_t *)v19;
  if (!v8) {
    goto LABEL_13;
  }
LABEL_6:
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  uint64_t v10 = (uint64_t *)v19;
  if (v19 != v21) {
LABEL_7:
  }
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps18(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    uint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    unsigned int v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        unsigned int v8 = (char *)v35;
        uint64_t v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        unsigned int v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      long long v29 = a2;
      uint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        uint64_t v30 = "' failed to satisfy constraint: valid MetalPixelFormat";
        uint64_t v31 = 54;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        uint64_t v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)uint64_t v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    unsigned int v16 = (void **)__p;
    if (__p)
    {
      long long v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          long long v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      unint64_t v42 = v16;
      operator delete(v18);
    }
    uint64_t v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      unint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = (void *)*--v20;
          long long v22 = v23;
          *uint64_t v20 = 0;
          if (v23) {
            operator delete[](v22);
          }
        }
        while (v20 != v19);
        unint64_t v21 = v39;
      }
      unint64_t v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x10uLL);
    *uint64_t v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 120;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        unsigned int v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[33];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::mps::MetalPixelFormatAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  int v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id) {
    return 1;
  }
  unsigned char v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    unint64_t v6 = &v40;
    unint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v7 = (char *)v46;
        unint64_t v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v6 = &v40;
        unint64_t v7 = (char *)v46;
      }
    }
    unsigned int v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)unsigned int v8 = v9;
    ++v47;
  }
  unint64_t v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::MetalPixelFormatAttr]";
  unint64_t v41 = 81;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    unint64_t v40 = (const void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      unint64_t v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          unint64_t v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          unint64_t v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      unsigned int v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)unsigned int v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        uint64_t v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v19 = (char *)v46;
            uint64_t v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            uint64_t v19 = (char *)v46;
          }
        }
        uint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = (void **)__p;
    if (__p)
    {
      uint64_t v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      int v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = (void *)*--v27;
          long long v29 = v30;
          void *v27 = 0;
          if (v30) {
            operator delete[](v29);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      int64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

void mlir::mps::CreateTextureTensorOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v21 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  long long v9 = *a1;
  v27[0] = a4;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v9);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id;
  uint64_t v25 = (uint64_t)v9;
  uint64_t v11 = mlir::StorageUniquer::get<mlir::mps::detail::MetalPixelFormatAttrStorage,mlir::mps::MetalPixelFormat>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27MetalPixelFormatAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20MetalPixelFormatAttrEJNS2_16MetalPixelFormatEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id, v27);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = v11;
  if (a5)
  {
    uint64_t UnitAttr = mlir::Builder::getUnitAttr(a1, v12);
    *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties>((void *)a2) = UnitAttr;
  }
  __src = v26;
  uint64_t v25 = 0x200000000;
  mlir::ValueRange::ValueRange((unint64_t *)&v23, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v22, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  *(_OWORD *)int64_t v27 = v23;
  if (v25 != 1)
  {
    if (!v25)
    {
      if (HIDWORD(v25))
      {
        unsigned int v15 = 0;
LABEL_8:
        bzero((char *)__src + 8 * v15, 8 - 8 * v15);
        goto LABEL_9;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v26, 1uLL, 8);
      unsigned int v15 = v25;
      if (v25 != 1) {
        goto LABEL_8;
      }
    }
LABEL_9:
    LODWORD(v25) = 1;
  }
  uint64_t v16 = mlir::ValueRange::dereference_iterator(v27, 0);
  *(void *)__src = *(void *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8;
  long long v17 = __src;
  uint64_t v18 = v25;
  uint64_t v19 = *(unsigned int *)(a2 + 72);
  unint64_t v20 = v19 + v25;
  if (v20 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v20, 8);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  if (v18)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v19), v17, 8 * v18);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v19 + v18;
  if (__src != v26) {
    free(__src);
  }
}

BOOL mlir::mps::CreateTextureTensorOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    uint64_t v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = v3[1];
  if (v4)
  {
    uint64_t v5 = *v3;
    v71[0] = v2;
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps18(v4, (const void **)"pixel_format", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps18(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v71))return 0; {
    v71[0] = *this;
    }
    if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (const void **)"compressed", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v71))return 0; {
    unint64_t v6 = *this;
    }
    unint64_t v7 = (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
    unsigned int v8 = *v7;
    long long v9 = (void *)*((void *)*v7 + 17);
    if (v9 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      uint64_t v22 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v8 + 8);
      v71[0] = v7;
      v71[1] = v22;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v71);
      if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
        || mlir::Type::isF16((mlir::Type *)&OperandRange)
        || mlir::Type::isF32((mlir::Type *)&OperandRange)
        || mlir::Type::isBF16((mlir::Type *)&OperandRange)
        || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
      {
LABEL_85:
        if (*((_DWORD *)*this + 9)) {
          uint64_t v50 = (uint64_t)(*this - 2);
        }
        else {
          uint64_t v50 = 0;
        }
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v50, 0);
        return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
      }
      unsigned int v8 = *v7;
      if (*((_UNKNOWN **)*v7 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
        goto LABEL_53;
      }
    }
    else if (v9 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
LABEL_53:
      __int16 v65 = 261;
      unint64_t v63 = (const void **)"operand";
      uint64_t v64 = 7;
      mlir::Operation::emitOpError(v6, &v63, (uint64_t)v71);
      if (v71[0])
      {
        LODWORD(v68) = 3;
        int64_t v69 = " #";
        uint64_t v70 = 2;
        long long v23 = &v68;
        uint64_t v24 = (char *)v72;
        if (v73 >= v74)
        {
          unint64_t v53 = v73 + 1;
          if (v72 <= &v68 && (char *)v72 + 24 * v73 > (char *)&v68)
          {
            int64_t v59 = (char *)&v68 - (unsigned char *)v72;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v53, 24);
            uint64_t v24 = (char *)v72;
            long long v23 = (const void ***)((char *)v72 + v59);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v53, 24);
            long long v23 = &v68;
            uint64_t v24 = (char *)v72;
          }
        }
        uint64_t v25 = &v24[24 * v73];
        long long v26 = *(_OWORD *)v23;
        *((void *)v25 + 2) = v23[2];
        *(_OWORD *)uint64_t v25 = v26;
        uint64_t v27 = ++v73;
        if (v71[0])
        {
          LODWORD(v68) = 5;
          int64_t v69 = 0;
          uint64_t v28 = &v68;
          long long v29 = (char *)v72;
          if (v27 >= v74)
          {
            unint64_t v54 = v27 + 1;
            BOOL v55 = (char *)v72 + 24 * v27 > (char *)&v68;
            if (v72 <= &v68 && v55)
            {
              int64_t v60 = (char *)&v68 - (unsigned char *)v72;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v54, 24);
              long long v29 = (char *)v72;
              uint64_t v28 = (const void ***)((char *)v72 + v60);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v54, 24);
              uint64_t v28 = &v68;
              long long v29 = (char *)v72;
            }
          }
          uint64_t v30 = &v29[24 * v73];
          long long v31 = *(_OWORD *)v28;
          *((void *)v30 + 2) = v28[2];
          *(_OWORD *)uint64_t v30 = v31;
          uint64_t v32 = ++v73;
          if (v71[0])
          {
            LODWORD(v68) = 3;
            int64_t v69 = " must be unranked tensor of mps native type values or 4D tensor of mps native type values, but got ";
            uint64_t v70 = 99;
            unint64_t v33 = &v68;
            unint64_t v34 = (char *)v72;
            if (v32 >= v74)
            {
              unint64_t v56 = v32 + 1;
              BOOL v57 = (char *)v72 + 24 * v32 > (char *)&v68;
              if (v72 <= &v68 && v57)
              {
                int64_t v61 = (char *)&v68 - (unsigned char *)v72;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v56, 24);
                unint64_t v34 = (char *)v72;
                unint64_t v33 = (const void ***)((char *)v72 + v61);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v56, 24);
                unint64_t v33 = &v68;
                unint64_t v34 = (char *)v72;
              }
            }
            int64_t v35 = &v34[24 * v73];
            long long v36 = *(_OWORD *)v33;
            *((void *)v35 + 2) = v33[2];
            *(_OWORD *)int64_t v35 = v36;
            ++v73;
            if (v71[0])
            {
              int64_t v37 = &v68;
              mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v68, (uint64_t)v7);
              uint64_t v38 = (char *)v72;
              if (v73 >= v74)
              {
                unint64_t v58 = v73 + 1;
                if (v72 <= &v68 && (char *)v72 + 24 * v73 > (char *)&v68)
                {
                  int64_t v62 = (char *)&v68 - (unsigned char *)v72;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v58, 24);
                  uint64_t v38 = (char *)v72;
                  int64_t v37 = (const void ***)((char *)v72 + v62);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v58, 24);
                  int64_t v37 = &v68;
                  uint64_t v38 = (char *)v72;
                }
              }
              uint64_t v39 = &v38[24 * v73];
              long long v40 = *(_OWORD *)v37;
              *((void *)v39 + 2) = v37[2];
              *(_OWORD *)uint64_t v39 = v40;
              ++v73;
            }
          }
        }
      }
      char v41 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v71);
      if (v71[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v71);
      }
      if (v80)
      {
        uint64_t v42 = (void **)__p;
        if (__p)
        {
          __int16 v43 = v79;
          uint64_t v44 = __p;
          if (v79 != __p)
          {
            do
              __int16 v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v43 - 1);
            while (v43 != v42);
            uint64_t v44 = __p;
          }
          unint64_t v79 = v42;
          operator delete(v44);
        }
        uint64_t v45 = v76;
        if (v76)
        {
          unint64_t v46 = v77;
          unsigned int v47 = v76;
          if (v77 != v76)
          {
            do
            {
              int64_t v49 = (void *)*--v46;
              unsigned int v48 = v49;
              *unint64_t v46 = 0;
              if (v49) {
                operator delete[](v48);
              }
            }
            while (v46 != v45);
            unsigned int v47 = v76;
          }
          unint64_t v77 = v45;
          operator delete(v47);
        }
        if (v72 != v75) {
          free(v72);
        }
      }
      if (v41) {
        goto LABEL_85;
      }
      return 0;
    }
    unint64_t v63 = v7;
    uint64_t v64 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v8 + 8);
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v63))
    {
      uint64_t v10 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v7 + 8);
      unint64_t v68 = v7;
      int64_t v69 = (const char *)v10;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v68);
      if (v11 == 4)
      {
        uint64_t v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v7 + 8);
        v66[0] = v7;
        v66[1] = v12;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v66);
        if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isF16((mlir::Type *)&OperandRange)
          || mlir::Type::isF32((mlir::Type *)&OperandRange)
          || mlir::Type::isBF16((mlir::Type *)&OperandRange)
          || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
        {
          goto LABEL_85;
        }
      }
    }
    goto LABEL_53;
  }
  unint64_t v63 = (const void **)"requires attribute 'pixel_format'";
  __int16 v65 = 259;
  mlir::OpState::emitOpError(this, &v63, (uint64_t)v71);
  uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v71);
  if (v71[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v71);
  }
  if (v80)
  {
    unint64_t v14 = (void **)__p;
    if (__p)
    {
      unsigned int v15 = v79;
      uint64_t v16 = __p;
      if (v79 != __p)
      {
        do
          unsigned int v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
        while (v15 != v14);
        uint64_t v16 = __p;
      }
      unint64_t v79 = v14;
      operator delete(v16);
    }
    long long v17 = v76;
    if (v76)
    {
      uint64_t v18 = v77;
      uint64_t v19 = v76;
      if (v77 != v76)
      {
        do
        {
          uint64_t v21 = (void *)*--v18;
          unint64_t v20 = v21;
          void *v18 = 0;
          if (v21) {
            operator delete[](v20);
          }
        }
        while (v18 != v17);
        uint64_t v19 = v76;
      }
      unint64_t v77 = v17;
      operator delete(v19);
    }
    if (v72 != v75) {
      free(v72);
    }
  }
  return v13;
}

uint64_t mlir::mps::CreateTextureTensorOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.create_texture_tensor", 25, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC981A98;
  v4[12] = mlir::mps::CreateTextureTensorOp::canonicalize;
  long long v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    long long v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::CropOpGenericAdaptorBase::CropOpGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  unint64_t v5 = a2[11];
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.crop", 8, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::CropOp::build(mlir::mps::ConstantOp *a1, uint64_t *a2, uint64_t a3, unsigned int a4, unsigned int a5, unsigned int a6)
{
  unsigned int v13 = a5;
  unsigned int v14 = a4;
  unsigned int v12 = a6;
  long long v9 = (char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,int &>(a1, *a2, &v14) - 16;
  uint64_t v10 = (char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,int &>(a1, *a2, &v13) - 16;
  uint64_t v11 = mlir::OpBuilder::create<mlir::mps::ConstantOp,int &>(a1, *a2, &v12);
  mlir::mps::CropOp::build((mlir::UnknownLoc **)a1, (uint64_t)a2, a3, (uint64_t)v9, (uint64_t)v10, (uint64_t)v11 - 16);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ConstantOp,int &>(mlir::mps::ConstantOp *a1, uint64_t a2, unsigned int *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.constant", (const unsigned __int8 *)0xC, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"mps.constant";
    void v15[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ConstantOp::build(a1, (mlir::OpBuilder *)v17, (mlir::OperationState *)*a3);
  long long v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

void mlir::mps::CropOp::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  void v27[2] = *MEMORY[0x1E4F143B8];
  uint64_t v21 = a4;
  uint64_t v22 = a3;
  uint64_t v19 = a6;
  uint64_t v20 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v22, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v20, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v19, 1);
  __src = v27;
  uint64_t v26 = 0x200000000;
  char v8 = *a1;
  mlir::ValueRange::ValueRange((unint64_t *)v24, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(v23, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::CropOp::inferReturnTypes(v8, v11, v12, v24[0], (unint64_t)v24[1], Dictionary, v13, v14, v23[0], v23[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  unsigned int v15 = __src;
  }
  uint64_t v16 = v26;
  uint64_t v17 = *(unsigned int *)(a2 + 72);
  unint64_t v18 = v17 + v26;
  if (v18 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v18, 8);
    LODWORD(v17) = *(_DWORD *)(a2 + 72);
  }
  if (v16)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v17), v15, 8 * v16);
    LODWORD(v17) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v17 + v16;
  if (__src != v27) {
    free(__src);
  }
}

void mlir::mps::CropOp::build(mlir::mps::ConstantOp *a1, uint64_t *a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6)
{
  unsigned int v12 = a6;
  unsigned int v13 = a5;
  uint64_t v10 = (char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,int &>(a1, *a2, &v13) - 16;
  uint64_t v11 = mlir::OpBuilder::create<mlir::mps::ConstantOp,int &>(a1, *a2, &v12);
  mlir::mps::CropOp::build((mlir::UnknownLoc **)a1, (uint64_t)a2, a3, a4, (uint64_t)v10, (uint64_t)v11 - 16);
}

uint64_t mlir::mps::CropOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 2u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this,
                           (const void **)(*(void *)(*(void *)((*this)[9] + 120) + 8) & 0xFFFFFFFFFFFFFFF8),
                           (const void **)"operand",
                           7,
                           3u))
  {
    return 0;
  }
  uint64_t v2 = *((_DWORD *)*this + 9) ? (uint64_t)(*this - 2) : 0;
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0))return 0; {
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(void *)((*this)[9] + 24));
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v5 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0);
  if (ElementTypeOrSelf == mlir::getElementTypeOrSelf(v6))
  {
    uint64_t v7 = *((_DWORD *)*this + 9) ? (uint64_t)(*this - 2) : 0;
    uint64_t v8 = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0);
    uint64_t v9 = mlir::getElementTypeOrSelf(v8);
    if (v9 == mlir::getElementTypeOrSelf(*(void *)((*this)[9] + 24))) {
      return 1;
    }
  }
  uint64_t v20 = (const void **)"failed to verify that all of {input, result} have same element type";
  __int16 v21 = 259;
  mlir::OpState::emitOpError(this, &v20, (uint64_t)v22);
  uint64_t v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v22);
  if (v22[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v22);
  }
  if (v29)
  {
    uint64_t v11 = (void **)__p;
    if (__p)
    {
      unsigned int v12 = v28;
      unsigned int v13 = __p;
      if (v28 != __p)
      {
        do
          unsigned int v12 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v12 - 1);
        while (v12 != v11);
        unsigned int v13 = __p;
      }
      uint64_t v28 = v11;
      operator delete(v13);
    }
    int v14 = v25;
    if (v25)
    {
      unsigned int v15 = v26;
      uint64_t v16 = v25;
      if (v26 != v25)
      {
        do
        {
          uint64_t v19 = (void *)*--v15;
          unint64_t v18 = v19;
          *unsigned int v15 = 0;
          if (v19) {
            operator delete[](v18);
          }
        }
        while (v15 != v14);
        uint64_t v16 = v25;
      }
      uint64_t v26 = v14;
      operator delete(v16);
    }
    if (v23 != &v24) {
      free(v23);
    }
  }
  return v10;
}

uint64_t mlir::mps::CropOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.crop", 8, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC9828B0;
  v4[12] = mlir::mps::CropOp::canonicalize;
  uint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::CropResizeOpGenericAdaptorBase::CropResizeOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v13, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *(_OWORD *)v5;
  long long v9 = *(_OWORD *)(v5 + 16);
  long long v10 = *(_OWORD *)(v5 + 32);
  *(void *)(a1 + 72) = *(void *)(v5 + 48);
  *(_OWORD *)(a1 + 56) = v10;
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)v13;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.crop_resize", 15, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::CropResizeOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v70 = v6;
  if (!v6)
  {
    a3(v74, a4);
    if (v74[0])
    {
      LODWORD(v71) = 3;
      int64_t v72 = "expected DictionaryAttr to set properties";
      uint64_t v73 = 41;
      uint64_t v26 = &v71;
      uint64_t v27 = (char *)v75;
      if (v76 >= v77)
      {
        unint64_t v60 = v76 + 1;
        if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
        {
          int64_t v65 = (char *)&v71 - (unsigned char *)v75;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v60, 24);
          uint64_t v27 = (char *)v75;
          uint64_t v26 = (uint64_t *)((char *)v75 + v65);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v60, 24);
          uint64_t v26 = &v71;
          uint64_t v27 = (char *)v75;
        }
      }
      uint64_t v28 = &v27[24 * v76];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)uint64_t v28 = v29;
      ++v76;
      if (v74[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
      }
    }
    if (!v83) {
      return 0;
    }
    uint64_t v30 = (void **)__p;
    if (__p)
    {
      long long v31 = v82;
      uint64_t v32 = __p;
      if (v82 != __p)
      {
        do
          long long v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        uint64_t v32 = __p;
      }
      unsigned int v82 = v30;
      operator delete(v32);
    }
    __int16 v21 = v79;
    if (!v79) {
      goto LABEL_64;
    }
    unint64_t v33 = v80;
    long long v23 = v79;
    if (v80 == v79)
    {
LABEL_63:
      char v80 = v21;
      operator delete(v23);
LABEL_64:
      if (v75 != v78) {
        free(v75);
      }
      return 0;
    }
    do
    {
      int64_t v35 = (void *)*--v33;
      unint64_t v34 = v35;
      *unint64_t v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
LABEL_62:
    long long v23 = v79;
    goto LABEL_63;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v70, "alignment_mode", 0xEuLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id)
    {
      a3(v74, a4);
      if (v74[0])
      {
        LODWORD(v71) = 3;
        uint64_t v73 = 59;
        long long v10 = &v71;
        uint64_t v11 = (char *)v75;
        if (v76 >= v77)
        {
          unint64_t v61 = v76 + 1;
          if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
          {
            int64_t v66 = (char *)&v71 - (unsigned char *)v75;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v61, 24);
            uint64_t v11 = (char *)v75;
            long long v10 = (uint64_t *)((char *)v75 + v66);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v61, 24);
            long long v10 = &v71;
            uint64_t v11 = (char *)v75;
          }
        }
        unsigned int v12 = &v11[24 * v76];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = v10[2];
        *(_OWORD *)unsigned int v12 = v13;
        ++v76;
        if (v74[0])
        {
          uint64_t v14 = &v71;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v71, v9);
          unsigned int v15 = (char *)v75;
          if (v76 >= v77)
          {
            unint64_t v62 = v76 + 1;
            if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
            {
              int64_t v67 = (char *)&v71 - (unsigned char *)v75;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v62, 24);
              unsigned int v15 = (char *)v75;
              uint64_t v14 = (uint64_t *)((char *)v75 + v67);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v62, 24);
              uint64_t v14 = &v71;
              unsigned int v15 = (char *)v75;
            }
          }
          uint64_t v16 = &v15[24 * v76];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = v14[2];
          *(_OWORD *)uint64_t v16 = v17;
          ++v76;
          if (v74[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
          }
        }
      }
      if (!v83) {
        return 0;
      }
      unint64_t v18 = (void **)__p;
      if (__p)
      {
        uint64_t v19 = v82;
        uint64_t v20 = __p;
        if (v82 != __p)
        {
          do
            uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          uint64_t v20 = __p;
        }
        unsigned int v82 = v18;
        operator delete(v20);
      }
      __int16 v21 = v79;
      if (!v79) {
        goto LABEL_64;
      }
      uint64_t v22 = v80;
      long long v23 = v79;
      if (v80 == v79) {
        goto LABEL_63;
      }
      do
      {
        uint64_t v25 = (void *)*--v22;
        uint64_t v24 = v25;
        *uint64_t v22 = 0;
        if (v25) {
          operator delete[](v24);
        }
      }
      while (v22 != v21);
      goto LABEL_62;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v70, "coordinate_mode", 0xFuLL);
  if (v36)
  {
    uint64_t v37 = v36;
    if (*(_UNKNOWN **)(*(void *)v36 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id)
    {
      a3(v74, a4);
      if (v74[0])
      {
        LODWORD(v71) = 3;
        uint64_t v73 = 60;
        uint64_t v38 = &v71;
        uint64_t v39 = (char *)v75;
        if (v76 >= v77)
        {
          unint64_t v63 = v76 + 1;
          if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
          {
            int64_t v68 = (char *)&v71 - (unsigned char *)v75;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v63, 24);
            uint64_t v39 = (char *)v75;
            uint64_t v38 = (uint64_t *)((char *)v75 + v68);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v63, 24);
            uint64_t v38 = &v71;
            uint64_t v39 = (char *)v75;
          }
        }
        long long v40 = &v39[24 * v76];
        long long v41 = *(_OWORD *)v38;
        *((void *)v40 + 2) = v38[2];
        *(_OWORD *)long long v40 = v41;
        ++v76;
        if (v74[0])
        {
          uint64_t v42 = &v71;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v71, v37);
          __int16 v43 = (char *)v75;
          if (v76 >= v77)
          {
            unint64_t v64 = v76 + 1;
            if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
            {
              int64_t v69 = (char *)&v71 - (unsigned char *)v75;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v64, 24);
              __int16 v43 = (char *)v75;
              uint64_t v42 = (uint64_t *)((char *)v75 + v69);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v64, 24);
              uint64_t v42 = &v71;
              __int16 v43 = (char *)v75;
            }
          }
          uint64_t v44 = &v43[24 * v76];
          long long v45 = *(_OWORD *)v42;
          *((void *)v44 + 2) = v42[2];
          *(_OWORD *)uint64_t v44 = v45;
          ++v76;
          if (v74[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
          }
        }
      }
      if (!v83) {
        return 0;
      }
      unint64_t v46 = (void **)__p;
      if (__p)
      {
        unsigned int v47 = v82;
        unsigned int v48 = __p;
        if (v82 != __p)
        {
          do
            unsigned int v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
          while (v47 != v46);
          unsigned int v48 = __p;
        }
        unsigned int v82 = v46;
        operator delete(v48);
      }
      __int16 v21 = v79;
      if (!v79) {
        goto LABEL_64;
      }
      int64_t v49 = v80;
      long long v23 = v79;
      if (v80 == v79) {
        goto LABEL_63;
      }
      do
      {
        int64_t v51 = (void *)*--v49;
        uint64_t v50 = v51;
        void *v49 = 0;
        if (v51) {
          operator delete[](v50);
        }
      }
      while (v49 != v21);
      goto LABEL_62;
    }
    a1[1] = v36;
  }
  uint64_t v52 = mlir::DictionaryAttr::get((uint64_t)&v70, "interpolation_mode", 0x12uLL);
  uint64_t v71 = v52;
  if (!v52)
  {
LABEL_71:
    uint64_t v54 = mlir::DictionaryAttr::get((uint64_t)&v70, "normalize_coordinates", 0x15uLL);
    uint64_t v71 = v54;
    if (v54)
    {
      if (*(_UNKNOWN **)(*(void *)v54 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
      {
        a3(v74, a4);
        goto LABEL_87;
      }
      a1[3] = v54;
    }
    uint64_t v55 = mlir::DictionaryAttr::get((uint64_t)&v70, "resize_height", 0xDuLL);
    uint64_t v71 = v55;
    if (v55)
    {
      if (*(_UNKNOWN **)(*(void *)v55 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        a3(v74, a4);
LABEL_86:
        uint64_t v53 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v74, v56);
        goto LABEL_87;
      }
      a1[4] = v55;
    }
    uint64_t v57 = mlir::DictionaryAttr::get((uint64_t)&v70, "resize_width", 0xCuLL);
    uint64_t v71 = v57;
    if (v57)
    {
      if (*(_UNKNOWN **)(*(void *)v57 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        a3(v74, a4);
        goto LABEL_87;
      }
      a1[5] = v57;
    }
    uint64_t v58 = mlir::DictionaryAttr::get((uint64_t)&v70, "spatial_scale", 0xDuLL);
    uint64_t v71 = v58;
    if (v58)
    {
      if (*(_UNKNOWN **)(*(void *)v58 + 136) != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
      {
        a3(v74, a4);
        goto LABEL_86;
      }
      a1[6] = v58;
    }
    return 1;
  }
  if (*(_UNKNOWN **)(*(void *)v52 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id)
  {
    a1[2] = v52;
    goto LABEL_71;
  }
  a3(v74, a4);
LABEL_87:
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v53, &v71);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v74);
  return 0;
}

uint64_t mlir::mps::CropResizeOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v51[6] = *MEMORY[0x1E4F143B8];
  unsigned int v48 = a1;
  int64_t v49 = v51;
  uint64_t v50 = 0x300000000;
  if (!*a2)
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v48, (uint64_t)"alignment_mode", 14, *a2);
  uint64_t v5 = v4;
  unsigned int v6 = v50;
  if (v50 >= HIDWORD(v50))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
    unsigned int v6 = v50;
  }
  uint64_t v7 = (uint64_t *)((char *)v49 + 16 * v6);
  uint64_t *v7 = NamedAttr;
  v7[1] = v5;
  unsigned int v8 = v50 + 1;
  LODWORD(v50) = v50 + 1;
  uint64_t v9 = a2[1];
  if (v9)
  {
LABEL_7:
    uint64_t v10 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"coordinate_mode", 15, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v13 = v50;
    }
    uint64_t v14 = (uint64_t *)((char *)v49 + 16 * v13);
    *uint64_t v14 = v10;
    v14[1] = v12;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
LABEL_10:
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"interpolation_mode", 18, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v19 = v50;
    }
    uint64_t v20 = (uint64_t *)((char *)v49 + 16 * v19);
    *uint64_t v20 = v16;
    v20[1] = v18;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v21 = a2[3];
  if (v21)
  {
    uint64_t v22 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"normalize_coordinates", 21, v21);
    uint64_t v24 = v23;
    unsigned int v25 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v25 = v50;
    }
    uint64_t v26 = (uint64_t *)((char *)v49 + 16 * v25);
    *uint64_t v26 = v22;
    v26[1] = v24;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v27 = a2[4];
  if (v27)
  {
    uint64_t v28 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"resize_height", 13, v27);
    uint64_t v30 = v29;
    unsigned int v31 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v31 = v50;
    }
    uint64_t v32 = (uint64_t *)((char *)v49 + 16 * v31);
    *uint64_t v32 = v28;
    v32[1] = v30;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v33 = a2[5];
  if (v33)
  {
    uint64_t v34 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"resize_width", 12, v33);
    uint64_t v36 = v35;
    unsigned int v37 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v37 = v50;
    }
    uint64_t v38 = (uint64_t *)((char *)v49 + 16 * v37);
    uint64_t *v38 = v34;
    v38[1] = v36;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v39 = a2[6];
  if (v39)
  {
    uint64_t v40 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"spatial_scale", 13, v39);
    uint64_t v42 = v41;
    unsigned int v43 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v43 = v50;
    }
    uint64_t v44 = (uint64_t *)((char *)v49 + 16 * v43);
    uint64_t *v44 = v40;
    v44[1] = v42;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  long long v45 = v49;
  if (!v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v49 == v51) {
      return DictionaryAttr;
    }
    goto LABEL_32;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v48, (uint64_t *)v49, v8);
  long long v45 = v49;
  if (v49 != v51) {
LABEL_32:
  }
    free(v45);
  return DictionaryAttr;
}

uint64_t mlir::mps::CropResizeOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 0xCuLL:
      if (memcmp(__s1, "resize_width", __n)) {
        return 0;
      }
      return a2[5];
    case 0xDuLL:
      if (!memcmp(__s1, "resize_height", __n)) {
        return a2[4];
      }
      if (memcmp(__s1, "spatial_scale", __n)) {
        return 0;
      }
      return a2[6];
    case 0xEuLL:
      if (*(void *)__s1 != 0x6E656D6E67696C61 || *(void *)(__s1 + 6) != 0x65646F6D5F746E65) {
        return 0;
      }
      return *a2;
    case 0xFuLL:
      if (memcmp(__s1, "coordinate_mode", __n)) {
        return 0;
      }
      return a2[1];
    case 0x10uLL:
    case 0x11uLL:
    case 0x13uLL:
    case 0x14uLL:
      return 0;
    case 0x12uLL:
      if (memcmp(__s1, "interpolation_mode", __n)) {
        return 0;
      }
      return a2[2];
    case 0x15uLL:
      if (memcmp(__s1, "normalize_coordinates", __n)) {
        return 0;
      }
      return a2[3];
    default:
      return 0;
  }
}

uint64_t mlir::mps::CropResizeOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  uint64_t v7 = (void *)result;
  switch(__n)
  {
    case 0xCuLL:
      uint64_t result = memcmp(__s1, "resize_width", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
            uint64_t v14 = a4;
          }
          else {
            uint64_t v14 = 0;
          }
          v7[5] = v14;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "resize_height", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "spatial_scale", __n);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id) {
              uint64_t v8 = a4;
            }
            else {
              uint64_t v8 = 0;
            }
            v7[6] = v8;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
          uint64_t v15 = a4;
        }
        else {
          uint64_t v15 = 0;
        }
        v7[4] = v15;
      }
      else
      {
        v7[4] = 0;
      }
      break;
    case 0xEuLL:
      if (*(void *)__s1 == 0x6E656D6E67696C61 && *(void *)(__s1 + 6) == 0x65646F6D5F746E65)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          *(void *)uint64_t result = v10;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xFuLL:
      uint64_t result = memcmp(__s1, "coordinate_mode", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v7[1] = v11;
        }
        else
        {
          v7[1] = 0;
        }
      }
      break;
    case 0x12uLL:
      uint64_t result = memcmp(__s1, "interpolation_mode", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id) {
            uint64_t v12 = a4;
          }
          else {
            uint64_t v12 = 0;
          }
          v7[2] = v12;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    case 0x15uLL:
      uint64_t result = memcmp(__s1, "normalize_coordinates", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
            uint64_t v13 = a4;
          }
          else {
            uint64_t v13 = 0;
          }
          v7[3] = v13;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::CropResizeOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (*a2) {
    mlir::NamedAttrList::append(a3, (uint64_t)"alignment_mode", 14, *a2);
  }
  uint64_t v5 = a2[1];
  if (v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"coordinate_mode", 15, v5);
  }
  uint64_t v6 = a2[2];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"interpolation_mode", 18, v6);
  }
  uint64_t v7 = a2[3];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"normalize_coordinates", 21, v7);
  }
  uint64_t v8 = a2[4];
  if (v8) {
    mlir::NamedAttrList::append(a3, (uint64_t)"resize_height", 13, v8);
  }
  uint64_t v9 = a2[5];
  if (v9) {
    mlir::NamedAttrList::append(a3, (uint64_t)"resize_width", 12, v9);
  }
  uint64_t v10 = a2[6];
  if (v10)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"spatial_scale", 13, v10);
  }
}

BOOL mlir::mps::CropResizeOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps22(v8, (const void **)"alignment_mode", (const char *)0xE, a3, a4))
  {
    uint64_t v9 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps23(v9, (const void **)"coordinate_mode", (const char *)0xF, a3, a4))
    {
      uint64_t v10 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps21(v10, (const void **)"interpolation_mode", (const char *)0x12, a3, a4))
      {
        uint64_t v11 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 24));
        if (!v11
          || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v11, (const void **)"normalize_coordinates", (const char *)0x15, a3, a4))
        {
          uint64_t v12 = (const void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v12, (const void **)"resize_height", (const char *)0xD, a3, a4))
          {
            uint64_t v13 = (const void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v13, (const void **)"resize_width", (const char *)0xC, a3, a4))
            {
              uint64_t v14 = (const void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 48));
              if (!v14
                || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(v14, (const void **)"spatial_scale", (const char *)0xD, a3, a4))
              {
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps22(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    uint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    uint64_t v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = (char *)v35;
        uint64_t v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        uint64_t v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      uint64_t v29 = a2;
      uint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        uint64_t v30 = "' failed to satisfy constraint: valid CropResizeAlignmentMode";
        uint64_t v31 = 61;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        uint64_t v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)uint64_t v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    uint64_t v16 = (void **)__p;
    if (__p)
    {
      uint64_t v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          uint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      uint64_t v42 = v16;
      operator delete(v18);
    }
    unsigned int v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      uint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = (void *)*--v20;
          uint64_t v22 = v23;
          *uint64_t v20 = 0;
          if (v23) {
            operator delete[](v22);
          }
        }
        while (v20 != v19);
        uint64_t v21 = v39;
      }
      uint64_t v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps23(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    uint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    uint64_t v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = (char *)v35;
        uint64_t v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        uint64_t v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      uint64_t v29 = a2;
      uint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        uint64_t v30 = "' failed to satisfy constraint: valid CropResizeCoordinateMode";
        uint64_t v31 = 62;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        uint64_t v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)uint64_t v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    uint64_t v16 = (void **)__p;
    if (__p)
    {
      uint64_t v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          uint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      uint64_t v42 = v16;
      operator delete(v18);
    }
    unsigned int v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      uint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = (void *)*--v20;
          uint64_t v22 = v23;
          *uint64_t v20 = 0;
          if (v23) {
            operator delete[](v22);
          }
        }
        while (v20 != v19);
        uint64_t v21 = v39;
      }
      uint64_t v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps21(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    uint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    uint64_t v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = (char *)v35;
        uint64_t v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        uint64_t v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      uint64_t v29 = a2;
      uint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        uint64_t v30 = "' failed to satisfy constraint: valid sampling modes";
        uint64_t v31 = 52;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        uint64_t v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)uint64_t v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    uint64_t v16 = (void **)__p;
    if (__p)
    {
      uint64_t v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          uint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      uint64_t v42 = v16;
      operator delete(v18);
    }
    unsigned int v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      uint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = (void *)*--v20;
          uint64_t v22 = v23;
          *uint64_t v20 = 0;
          if (v23) {
            operator delete[](v22);
          }
        }
        while (v20 != v19);
        uint64_t v21 = v39;
      }
      uint64_t v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(const void **a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 1;
  }
  if (*((_UNKNOWN **)*a1 + 17) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    uint64_t v31 = a1;
    uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v31);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&Value, 32)) {
      return 1;
    }
  }
  a4(&Value, a5);
  if (Value)
  {
    LODWORD(v31) = 3;
    __int16 v32 = "attribute '";
    uint64_t v33 = 11;
    long long v10 = &v31;
    uint64_t v11 = (char *)v37;
    if (v38 >= v39)
    {
      unint64_t v27 = v38 + 1;
      if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
      {
        int64_t v29 = (char *)&v31 - (unsigned char *)v37;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        uint64_t v11 = (char *)v37;
        long long v10 = (const void ***)((char *)v37 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        long long v10 = &v31;
        uint64_t v11 = (char *)v37;
      }
    }
    uint64_t v12 = &v11[24 * v38];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = v10[2];
    *(_OWORD *)uint64_t v12 = v13;
    ++v38;
    if (Value)
    {
      __int16 v34 = 261;
      uint64_t v31 = a2;
      __int16 v32 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v36, &v31);
      if (Value)
      {
        LODWORD(v31) = 3;
        __int16 v32 = "' failed to satisfy constraint: 32-bit unsigned integer attribute";
        uint64_t v33 = 65;
        long long v14 = &v31;
        uint64_t v15 = (char *)v37;
        if (v38 >= v39)
        {
          unint64_t v28 = v38 + 1;
          if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
          {
            int64_t v30 = (char *)&v31 - (unsigned char *)v37;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            uint64_t v15 = (char *)v37;
            long long v14 = (const void ***)((char *)v37 + v30);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            long long v14 = &v31;
            uint64_t v15 = (char *)v37;
          }
        }
        uint64_t v16 = &v15[24 * v38];
        long long v17 = *(_OWORD *)v14;
        *((void *)v16 + 2) = v14[2];
        *(_OWORD *)uint64_t v16 = v17;
        ++v38;
      }
    }
  }
  uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  }
  if (v45)
  {
    uint64_t v18 = (void **)__p;
    if (__p)
    {
      unsigned int v19 = v44;
      uint64_t v20 = __p;
      if (v44 != __p)
      {
        do
          unsigned int v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        uint64_t v20 = __p;
      }
      uint64_t v44 = v18;
      operator delete(v20);
    }
    uint64_t v21 = v41;
    if (v41)
    {
      uint64_t v22 = v42;
      uint64_t v23 = v41;
      if (v42 != v41)
      {
        do
        {
          unint64_t v25 = (void *)*--v22;
          uint64_t v24 = v25;
          *uint64_t v22 = 0;
          if (v25) {
            operator delete[](v24);
          }
        }
        while (v22 != v21);
        uint64_t v23 = v41;
      }
      uint64_t v42 = v21;
      operator delete(v23);
    }
    if (v37 != v40) {
      free(v37);
    }
  }
  return v9;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(const void **a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 1;
  }
  if (*((_UNKNOWN **)*a1 + 17) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    uint64_t v31 = a1;
    uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v31);
    if (mlir::Type::isF32((mlir::Type *)&Value)) {
      return 1;
    }
  }
  a4(&Value, a5);
  if (Value)
  {
    LODWORD(v31) = 3;
    __int16 v32 = "attribute '";
    uint64_t v33 = 11;
    long long v10 = &v31;
    uint64_t v11 = (char *)v37;
    if (v38 >= v39)
    {
      unint64_t v27 = v38 + 1;
      if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
      {
        int64_t v29 = (char *)&v31 - (unsigned char *)v37;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        uint64_t v11 = (char *)v37;
        long long v10 = (const void ***)((char *)v37 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        long long v10 = &v31;
        uint64_t v11 = (char *)v37;
      }
    }
    uint64_t v12 = &v11[24 * v38];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = v10[2];
    *(_OWORD *)uint64_t v12 = v13;
    ++v38;
    if (Value)
    {
      __int16 v34 = 261;
      uint64_t v31 = a2;
      __int16 v32 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v36, &v31);
      if (Value)
      {
        LODWORD(v31) = 3;
        __int16 v32 = "' failed to satisfy constraint: 32-bit float attribute";
        uint64_t v33 = 54;
        long long v14 = &v31;
        uint64_t v15 = (char *)v37;
        if (v38 >= v39)
        {
          unint64_t v28 = v38 + 1;
          if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
          {
            int64_t v30 = (char *)&v31 - (unsigned char *)v37;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            uint64_t v15 = (char *)v37;
            long long v14 = (const void ***)((char *)v37 + v30);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            long long v14 = &v31;
            uint64_t v15 = (char *)v37;
          }
        }
        uint64_t v16 = &v15[24 * v38];
        long long v17 = *(_OWORD *)v14;
        *((void *)v16 + 2) = v14[2];
        *(_OWORD *)uint64_t v16 = v17;
        ++v38;
      }
    }
  }
  uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  }
  if (v45)
  {
    uint64_t v18 = (void **)__p;
    if (__p)
    {
      unsigned int v19 = v44;
      uint64_t v20 = __p;
      if (v44 != __p)
      {
        do
          unsigned int v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        uint64_t v20 = __p;
      }
      uint64_t v44 = v18;
      operator delete(v20);
    }
    uint64_t v21 = v41;
    if (v41)
    {
      uint64_t v22 = v42;
      uint64_t v23 = v41;
      if (v42 != v41)
      {
        do
        {
          unint64_t v25 = (void *)*--v22;
          uint64_t v24 = v25;
          *uint64_t v22 = 0;
          if (v25) {
            operator delete[](v24);
          }
        }
        while (v22 != v21);
        uint64_t v23 = v41;
      }
      uint64_t v42 = v21;
      operator delete(v23);
    }
    if (v37 != v40) {
      free(v37);
    }
  }
  return v9;
}

BOOL mlir::mps::CropResizeOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::CropResizeAlignmentModeAttr>(a1, v3)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::CropResizeCoordinateModeAttr>(a1, v3 + 1)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::SamplingModeAttr>(a1, v3 + 2)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 3)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::IntegerAttr>(a1, v3 + 4)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::IntegerAttr>(a1, v3 + 5)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::FloatAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x38uLL);
    *uint64_t v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    *((void *)v3 + 6) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 111;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[35];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::CropResizeAlignmentModeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  if (!v39) {
    return 1;
  }
  int v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id) {
    return 1;
  }
  unsigned char v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    unint64_t v6 = &v40;
    unint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v7 = (char *)v46;
        unint64_t v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v6 = &v40;
        unint64_t v7 = (char *)v46;
      }
    }
    uint64_t v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)uint64_t v8 = v9;
    ++v47;
  }
  uint64_t v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::CropResizeAlignmentModeAttr]";
  unint64_t v41 = 88;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    uint64_t v40 = (const void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      unint64_t v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          unint64_t v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          unint64_t v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      uint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)uint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unsigned int v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unsigned int v19 = (char *)v46;
            uint64_t v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            unsigned int v19 = (char *)v46;
          }
        }
        uint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = (void **)__p;
    if (__p)
    {
      uint64_t v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      uint64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      unint64_t v27 = v51;
      unint64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          int64_t v30 = (void *)*--v27;
          int64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            operator delete[](v29);
          }
        }
        while (v27 != v26);
        unint64_t v28 = v50;
      }
      int64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::CropResizeCoordinateModeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  if (!v39) {
    return 1;
  }
  int v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id) {
    return 1;
  }
  unsigned char v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    unint64_t v6 = &v40;
    unint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v7 = (char *)v46;
        unint64_t v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v6 = &v40;
        unint64_t v7 = (char *)v46;
      }
    }
    uint64_t v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)uint64_t v8 = v9;
    ++v47;
  }
  uint64_t v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::CropResizeCoordinateModeAttr]";
  unint64_t v41 = 89;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    uint64_t v40 = (const void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      unint64_t v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          unint64_t v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          unint64_t v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      uint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)uint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unsigned int v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unsigned int v19 = (char *)v46;
            uint64_t v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            unsigned int v19 = (char *)v46;
          }
        }
        uint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = (void **)__p;
    if (__p)
    {
      uint64_t v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      uint64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      unint64_t v27 = v51;
      unint64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          int64_t v30 = (void *)*--v27;
          int64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            operator delete[](v29);
          }
        }
        while (v27 != v26);
        unint64_t v28 = v50;
      }
      int64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::SamplingModeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  if (!v39) {
    return 1;
  }
  int v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id) {
    return 1;
  }
  unsigned char v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    unint64_t v6 = &v40;
    unint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v7 = (char *)v46;
        unint64_t v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v6 = &v40;
        unint64_t v7 = (char *)v46;
      }
    }
    uint64_t v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)uint64_t v8 = v9;
    ++v47;
  }
  uint64_t v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::SamplingModeAttr]";
  unint64_t v41 = 77;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    uint64_t v40 = (const void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      unint64_t v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          unint64_t v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          unint64_t v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      uint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)uint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unsigned int v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unsigned int v19 = (char *)v46;
            uint64_t v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            unsigned int v19 = (char *)v46;
          }
        }
        uint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = (void **)__p;
    if (__p)
    {
      uint64_t v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      uint64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      unint64_t v27 = v51;
      unint64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          int64_t v30 = (void *)*--v27;
          int64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            operator delete[](v29);
          }
        }
        while (v27 != v26);
        unint64_t v28 = v50;
      }
      int64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::FloatAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  if (!v39) {
    return 1;
  }
  int v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id) {
    return 1;
  }
  unsigned char v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    unint64_t v6 = &v40;
    unint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v7 = (char *)v46;
        unint64_t v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v6 = &v40;
        unint64_t v7 = (char *)v46;
      }
    }
    uint64_t v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)uint64_t v8 = v9;
    ++v47;
  }
  uint64_t v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::FloatAttr]";
  unint64_t v41 = 65;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    uint64_t v40 = (const void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      unint64_t v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          unint64_t v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          unint64_t v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      uint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)uint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unsigned int v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unsigned int v19 = (char *)v46;
            uint64_t v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            unsigned int v19 = (char *)v46;
          }
        }
        uint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = (void **)__p;
    if (__p)
    {
      uint64_t v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      uint64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      unint64_t v27 = v51;
      unint64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          int64_t v30 = (void *)*--v27;
          int64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            operator delete[](v29);
          }
        }
        while (v27 != v26);
        unint64_t v28 = v50;
      }
      int64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

void *mlir::mps::CropResizeOp::getResizeHeight(mlir::mps::CropResizeOp *this)
{
  unint64_t v1 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v1 = 0;
  }
  uint64_t v6 = *(void *)(v1 + 32);
  mlir::IntegerAttr::getValue(&v6, (llvm::APInt *)&__p);
  if (v5 <= 0x40) {
    return __p;
  }
  uint64_t v3 = *(void *)__p;
  operator delete[](__p);
  return (void *)v3;
}

llvm::detail::DoubleAPFloat *mlir::mps::CropResizeOp::getSpatialScale@<X0>(mlir::mps::CropResizeOp *this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v2 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v2 = 0;
  }
  uint64_t v4 = *(void *)(v2 + 48);
  return mlir::FloatAttr::getValue((mlir::FloatAttr *)&v4, a2);
}

void mlir::mps::CropResizeOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, int a7, uint64_t a8, unsigned int a9, unsigned int a10, unsigned int a11)
{
  v52[2] = *MEMORY[0x1E4F143B8];
  uint64_t v45 = a4;
  uint64_t v46 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v46, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v45, 1);
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x20u, 0);
  uint64_t IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a5);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>((void *)a2)
            + 32) = IntegerAttr;
  uint64_t v19 = mlir::Builder::getIntegerType(a1, 0x20u, 0);
  uint64_t v20 = mlir::Builder::getIntegerAttr((uint64_t)a1, v19, a6);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>((void *)a2)
            + 40) = v20;
  if (a7)
  {
    uint64_t UnitAttr = mlir::Builder::getUnitAttr((mlir::UnitAttr **)a1, v21);
    *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>((void *)a2)
              + 24) = UnitAttr;
  }
  uint64_t F32Type = mlir::Builder::getF32Type((mlir::Float32Type **)a1, v21);
  uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)a1, F32Type, a8);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>((void *)a2)
            + 48) = FloatAttr;
  unint64_t v25 = *(mlir::MLIRContext **)a1;
  unsigned int v47 = a9;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v25);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id;
  uint64_t v51 = (uint64_t)v25;
  uint64_t v27 = mlir::StorageUniquer::get<mlir::mps::detail::SamplingModeAttrStorage,mlir::mps::SamplingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23SamplingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16SamplingModeAttrEJNS2_12SamplingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id, &v47);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>((void *)a2)
            + 16) = v27;
  unint64_t v28 = *(mlir::MLIRContext **)a1;
  unsigned int v47 = a10;
  int64_t v29 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v28);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id;
  uint64_t v51 = (uint64_t)v28;
  uint64_t v30 = mlir::StorageUniquer::get<mlir::mps::detail::CropResizeAlignmentModeAttrStorage,mlir::mps::CropResizeAlignmentMode>(v29, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail34CropResizeAlignmentModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_27CropResizeAlignmentModeAttrEJNS2_23CropResizeAlignmentModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id, &v47);
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>((void *)a2) = v30;
  uint64_t v31 = *(mlir::MLIRContext **)a1;
  unsigned int v47 = a11;
  unint64_t v32 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v31);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id;
  uint64_t v51 = (uint64_t)v31;
  uint64_t v33 = mlir::StorageUniquer::get<mlir::mps::detail::CropResizeCoordinateModeAttrStorage,mlir::mps::CropResizeCoordinateMode>(v32, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail35CropResizeCoordinateModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_28CropResizeCoordinateModeAttrEJNS2_24CropResizeCoordinateModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id, &v47);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = v33;
  __src = v52;
  uint64_t v51 = 0x200000000;
  unint64_t v34 = *(mlir::UnknownLoc **)a1;
  mlir::ValueRange::ValueRange(v49, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  int64_t v37 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v48, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::CropResizeOp::inferReturnTypes(v34, v38, v39, v49[0], v49[1], Dictionary, v37, v40, v48[0], v48[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  unint64_t v41 = __src;
  }
  uint64_t v42 = v51;
  uint64_t v43 = *(unsigned int *)(a2 + 72);
  unint64_t v44 = v43 + v51;
  if (v44 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v44, 8);
    LODWORD(v43) = *(_DWORD *)(a2 + 72);
  }
  if (v42)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v43), v41, 8 * v42);
    LODWORD(v43) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v43 + v42;
  if (__src != v52) {
    free(__src);
  }
}

mlir::MLIRContext *mlir::mps::CropResizeOp::populateDefaultProperties(uint64_t a1, mlir::MLIRContext **a2)
{
  uint64_t v16 = *(void **)(a1 + 8);
  uint64_t result = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  unint64_t v14 = result;
  if (a2[4])
  {
    if (a2[5]) {
      goto LABEL_3;
    }
  }
  else
  {
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)&v14, 0x20u, 0);
    uint64_t result = (mlir::MLIRContext *)mlir::Builder::getIntegerAttr((uint64_t)&v14, IntegerType, 1);
    a2[4] = result;
    if (a2[5])
    {
LABEL_3:
      if (a2[6]) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }
  uint64_t v6 = mlir::Builder::getIntegerType((mlir::Builder *)&v14, 0x20u, 0);
  uint64_t result = (mlir::MLIRContext *)mlir::Builder::getIntegerAttr((uint64_t)&v14, v6, 1);
  a2[5] = result;
  if (a2[6])
  {
LABEL_4:
    if (a2[2]) {
      goto LABEL_5;
    }
    goto LABEL_11;
  }
LABEL_10:
  uint64_t F32Type = mlir::Builder::getF32Type(&v14, v4);
  uint64_t result = mlir::Builder::getFloatAttr(1.0, (uint64_t)&v14, F32Type);
  a2[6] = result;
  if (a2[2])
  {
LABEL_5:
    if (*a2) {
      goto LABEL_6;
    }
    goto LABEL_12;
  }
LABEL_11:
  uint64_t v8 = v14;
  unsigned int v15 = 1;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v14);
  uint64_t v16 = &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id;
  long long v17 = v8;
  uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::SamplingModeAttrStorage,mlir::mps::SamplingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23SamplingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16SamplingModeAttrEJNS2_12SamplingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v16, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id, &v15);
  a2[2] = result;
  if (*a2)
  {
LABEL_6:
    if (a2[1]) {
      return result;
    }
LABEL_13:
    uint64_t v12 = v14;
    unsigned int v15 = 0;
    unint64_t v13 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v14);
    uint64_t v16 = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id;
    long long v17 = v12;
    uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::CropResizeCoordinateModeAttrStorage,mlir::mps::CropResizeCoordinateMode>(v13, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail35CropResizeCoordinateModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_28CropResizeCoordinateModeAttrEJNS2_24CropResizeCoordinateModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v16, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id, &v15);
    a2[1] = result;
    return result;
  }
LABEL_12:
  unint64_t v10 = v14;
  unsigned int v15 = 0;
  unint64_t v11 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v14);
  uint64_t v16 = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id;
  long long v17 = v10;
  uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::CropResizeAlignmentModeAttrStorage,mlir::mps::CropResizeAlignmentMode>(v11, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail34CropResizeAlignmentModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_27CropResizeAlignmentModeAttrEJNS2_23CropResizeAlignmentModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v16, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id, &v15);
  *a2 = result;
  if (!a2[1]) {
    goto LABEL_13;
  }
  return result;
}

BOOL mlir::mps::CropResizeOp::verifyInvariantsImpl(uint64_t **this)
{
  unint64_t v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    uint64_t v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v5 = *v3;
  uint64_t v4 = v3[1];
  uint64_t v6 = v3[2];
  uint64_t v7 = v3[3];
  uint64_t v8 = (const void **)v3[4];
  long long v9 = (const void **)v3[5];
  unint64_t v10 = (const void **)v3[6];
  unint64_t v14 = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v8, (const void **)"resize_height", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0; {
  unint64_t v14 = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v9, (const void **)"resize_width", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0; {
  unint64_t v14 = *this;
  }
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (const void **)"normalize_coordinates", (const char *)0x15, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0; {
  unint64_t v14 = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(v10, (const void **)"spatial_scale", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0; {
  unint64_t v14 = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps21(v6, (const void **)"interpolation_mode", (const char *)0x12, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps21(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0; {
  unint64_t v14 = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps22(v5, (const void **)"alignment_mode", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps22(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0; {
  unint64_t v14 = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps23(v4, (const void **)"coordinate_mode", (const char *)0xF, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps23(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v11 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::CropResizeOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.crop_resize", 15, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC97FE10;
  v4[12] = mlir::mps::CropResizeOp::canonicalize;
  long long v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    long long v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::CumulativeMaximumOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v63 = v6;
  if (!v6)
  {
    a3(v67, a4);
    if (v67[0])
    {
      int v64 = 3;
      int64_t v65 = "expected DictionaryAttr to set properties";
      uint64_t v66 = 41;
      unint64_t v26 = &v64;
      uint64_t v27 = (char *)v68;
      if (v69 >= v70)
      {
        unint64_t v53 = v69 + 1;
        if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
        {
          int64_t v58 = (char *)&v64 - (unsigned char *)v68;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v53, 24);
          uint64_t v27 = (char *)v68;
          unint64_t v26 = (int *)((char *)v68 + v58);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v53, 24);
          unint64_t v26 = &v64;
          uint64_t v27 = (char *)v68;
        }
      }
      unint64_t v28 = &v27[24 * v69];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)unint64_t v28 = v29;
      ++v69;
      if (v67[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v67);
      }
    }
    if (!v76) {
      return 0;
    }
    uint64_t v30 = (void **)__p;
    if (__p)
    {
      uint64_t v31 = v75;
      unint64_t v32 = __p;
      if (v75 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unint64_t v32 = __p;
      }
      uint64_t v75 = v30;
      operator delete(v32);
    }
    long long v21 = v72;
    if (!v72) {
      goto LABEL_64;
    }
    uint64_t v33 = v73;
    uint64_t v23 = v72;
    if (v73 == v72) {
      goto LABEL_63;
    }
    do
    {
      int64_t v35 = (void *)*--v33;
      unint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
    goto LABEL_62;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v63, "exclusive", 9uLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v67, a4);
      if (v67[0])
      {
        int v64 = 3;
        uint64_t v66 = 54;
        unint64_t v10 = &v64;
        uint64_t v11 = (char *)v68;
        if (v69 >= v70)
        {
          unint64_t v54 = v69 + 1;
          if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
          {
            int64_t v59 = (char *)&v64 - (unsigned char *)v68;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v54, 24);
            uint64_t v11 = (char *)v68;
            unint64_t v10 = (int *)((char *)v68 + v59);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v54, 24);
            unint64_t v10 = &v64;
            uint64_t v11 = (char *)v68;
          }
        }
        uint64_t v12 = &v11[24 * v69];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = *((void *)v10 + 2);
        *(_OWORD *)uint64_t v12 = v13;
        ++v69;
        if (v67[0])
        {
          unint64_t v14 = &v64;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v64, v9);
          unsigned int v15 = (char *)v68;
          if (v69 >= v70)
          {
            unint64_t v55 = v69 + 1;
            if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
            {
              int64_t v60 = (char *)&v64 - (unsigned char *)v68;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v55, 24);
              unsigned int v15 = (char *)v68;
              unint64_t v14 = (int *)((char *)v68 + v60);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v55, 24);
              unint64_t v14 = &v64;
              unsigned int v15 = (char *)v68;
            }
          }
          uint64_t v16 = &v15[24 * v69];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = *((void *)v14 + 2);
          *(_OWORD *)uint64_t v16 = v17;
          ++v69;
          if (v67[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v67);
          }
        }
      }
      if (!v76) {
        return 0;
      }
      uint64_t v18 = (void **)__p;
      if (__p)
      {
        uint64_t v19 = v75;
        uint64_t v20 = __p;
        if (v75 != __p)
        {
          do
            uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          uint64_t v20 = __p;
        }
        uint64_t v75 = v18;
        operator delete(v20);
      }
      long long v21 = v72;
      if (!v72) {
        goto LABEL_64;
      }
      uint64_t v22 = v73;
      uint64_t v23 = v72;
      if (v73 == v72) {
        goto LABEL_63;
      }
      do
      {
        unint64_t v25 = (void *)*--v22;
        uint64_t v24 = v25;
        *uint64_t v22 = 0;
        if (v25) {
          operator delete[](v24);
        }
      }
      while (v22 != v21);
      goto LABEL_62;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v63, "reverse", 7uLL);
  if (!v36) {
    return 1;
  }
  uint64_t v37 = v36;
  if (*(_UNKNOWN **)(*(void *)v36 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    a1[1] = v36;
    return 1;
  }
  a3(v67, a4);
  if (v67[0])
  {
    int v64 = 3;
    uint64_t v66 = 52;
    unsigned int v38 = &v64;
    int v39 = (char *)v68;
    if (v69 >= v70)
    {
      unint64_t v56 = v69 + 1;
      if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
      {
        int64_t v61 = (char *)&v64 - (unsigned char *)v68;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v56, 24);
        int v39 = (char *)v68;
        unsigned int v38 = (int *)((char *)v68 + v61);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v56, 24);
        unsigned int v38 = &v64;
        int v39 = (char *)v68;
      }
    }
    int v40 = &v39[24 * v69];
    long long v41 = *(_OWORD *)v38;
    *((void *)v40 + 2) = *((void *)v38 + 2);
    *(_OWORD *)int v40 = v41;
    ++v69;
    if (v67[0])
    {
      uint64_t v42 = &v64;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v64, v37);
      uint64_t v43 = (char *)v68;
      if (v69 >= v70)
      {
        unint64_t v57 = v69 + 1;
        if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
        {
          int64_t v62 = (char *)&v64 - (unsigned char *)v68;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v57, 24);
          uint64_t v43 = (char *)v68;
          uint64_t v42 = (int *)((char *)v68 + v62);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v57, 24);
          uint64_t v42 = &v64;
          uint64_t v43 = (char *)v68;
        }
      }
      unint64_t v44 = &v43[24 * v69];
      long long v45 = *(_OWORD *)v42;
      *((void *)v44 + 2) = *((void *)v42 + 2);
      *(_OWORD *)unint64_t v44 = v45;
      ++v69;
      if (v67[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v67);
      }
    }
  }
  if (v76)
  {
    uint64_t v46 = (void **)__p;
    if (__p)
    {
      unsigned int v47 = v75;
      unsigned int v48 = __p;
      if (v75 != __p)
      {
        do
          unsigned int v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        unsigned int v48 = __p;
      }
      uint64_t v75 = v46;
      operator delete(v48);
    }
    long long v21 = v72;
    if (!v72) {
      goto LABEL_64;
    }
    int64_t v49 = v73;
    uint64_t v23 = v72;
    if (v73 == v72)
    {
LABEL_63:
      uint64_t v73 = v21;
      operator delete(v23);
LABEL_64:
      if (v68 != v71) {
        free(v68);
      }
      return 0;
    }
    do
    {
      uint64_t v51 = (void *)*--v49;
      uint64_t v50 = v51;
      void *v49 = 0;
      if (v51) {
        operator delete[](v50);
      }
    }
    while (v49 != v21);
LABEL_62:
    uint64_t v23 = v72;
    goto LABEL_63;
  }
  return 0;
}

uint64_t mlir::mps::CumulativeMaximumOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v21[6] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a1;
  uint64_t v19 = v21;
  uint64_t v20 = 0x300000000;
  if (*a2)
  {
    uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"exclusive", 9, *a2);
    uint64_t v5 = v4;
    unsigned int v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      unsigned int v6 = v20;
    }
    uint64_t v7 = (uint64_t *)((char *)v19 + 16 * v6);
    uint64_t *v7 = NamedAttr;
    v7[1] = v5;
    unsigned int v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    uint64_t v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      unint64_t v10 = (uint64_t *)v19;
      if (v8) {
        goto LABEL_6;
      }
LABEL_13:
      uint64_t DictionaryAttr = 0;
      if (v10 == v21) {
        return DictionaryAttr;
      }
      goto LABEL_7;
    }
  }
  else
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_5;
    }
  }
  uint64_t v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"reverse", 7, v9);
  uint64_t v15 = v14;
  unsigned int v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    unsigned int v16 = v20;
  }
  long long v17 = (uint64_t *)((char *)v19 + 16 * v16);
  *long long v17 = v13;
  v17[1] = v15;
  unsigned int v8 = v20 + 1;
  LODWORD(v20) = v8;
  unint64_t v10 = (uint64_t *)v19;
  if (!v8) {
    goto LABEL_13;
  }
LABEL_6:
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  unint64_t v10 = (uint64_t *)v19;
  if (v19 != v21) {
LABEL_7:
  }
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeMaximumOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x10uLL);
    *uint64_t v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CumulativeMaximumOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeMaximumOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CumulativeMaximumOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeMaximumOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::CumulativeMaximumOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 118;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        unsigned int v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::CumulativeMaximumOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[37];
    return a1[32];
  }
  return result;
}

void mlir::mps::CumulativeMaximumOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  unint64_t v29[2] = *MEMORY[0x1E4F143B8];
  uint64_t v21 = a4;
  uint64_t v22 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v22, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  if (a5)
  {
    uint64_t UnitAttr = mlir::Builder::getUnitAttr(a1, v10);
    *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeMaximumOpGenericAdaptorBase::Properties>((void *)a2) = UnitAttr;
  }
  if (a6)
  {
    uint64_t v12 = mlir::Builder::getUnitAttr(a1, v10);
    *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeMaximumOpGenericAdaptorBase::Properties>((void *)a2)
              + 8) = v12;
  }
  __src = v28;
  uint64_t v27 = 0x200000000;
  uint64_t v13 = *(void *)a2;
  mlir::ValueRange::ValueRange(&v24, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v23, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v29[0] = v24;
  v29[1] = v25;
  if (v25)
  {
    unint64_t v15 = *(void *)(mlir::ValueRange::dereference_iterator(v29, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    unsigned int v16 = v27;
    if (v27 >= HIDWORD(v27))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v28, v27 + 1, 8);
      unsigned int v16 = v27;
    }
    *((void *)__src + v16) = v15;
    unsigned int v17 = v27 + 1;
    LODWORD(v27) = v17;
    uint64_t v18 = __src;
    uint64_t v19 = *(unsigned int *)(a2 + 72);
    unint64_t v20 = v19 + v17;
    if (v20 > *(unsigned int *)(a2 + 76))
    {
LABEL_9:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v20, 8);
      LODWORD(v19) = *(_DWORD *)(a2 + 72);
    }
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(v13, 1, "invalid number of operands")) {
      llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
    }
    unsigned int v17 = v27;
    uint64_t v18 = __src;
    uint64_t v19 = *(unsigned int *)(a2 + 72);
    unint64_t v20 = v19 + v27;
    if (v20 > *(unsigned int *)(a2 + 76)) {
      goto LABEL_9;
    }
  }
  if (v17)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v19), v18, 8 * v17);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v19 + v17;
  if (__src != v28) {
    free(__src);
  }
}

BOOL mlir::mps::CumulativeMaximumOp::verifyInvariantsImpl(uint64_t **this)
{
  __int16 v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    uint64_t v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  unint64_t v9 = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v4, (const void **)"exclusive", (const char *)9, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v9))return 0; {
  unint64_t v9 = *this;
  }
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (const void **)"reverse", (const char *)7, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v9)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v6 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::CumulativeMaximumOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.cumulative_maximum", 22, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC981570;
  v4[12] = mlir::mps::CumulativeMaximumOp::canonicalize;
  unint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeMinimumOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x10uLL);
    *uint64_t v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CumulativeMinimumOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeMinimumOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CumulativeMinimumOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeMinimumOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::CumulativeMinimumOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 118;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        __int16 v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::CumulativeMinimumOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[39];
    return a1[32];
  }
  return result;
}

void mlir::mps::CumulativeMinimumOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  unint64_t v29[2] = *MEMORY[0x1E4F143B8];
  uint64_t v21 = a4;
  uint64_t v22 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v22, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  if (a5)
  {
    uint64_t UnitAttr = mlir::Builder::getUnitAttr(a1, v10);
    *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeMinimumOpGenericAdaptorBase::Properties>((void *)a2) = UnitAttr;
  }
  if (a6)
  {
    uint64_t v12 = mlir::Builder::getUnitAttr(a1, v10);
    *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeMinimumOpGenericAdaptorBase::Properties>((void *)a2)
              + 8) = v12;
  }
  __src = v28;
  uint64_t v27 = 0x200000000;
  uint64_t v13 = *(void *)a2;
  mlir::ValueRange::ValueRange(&v24, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v23, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v29[0] = v24;
  v29[1] = v25;
  if (v25)
  {
    unint64_t v15 = *(void *)(mlir::ValueRange::dereference_iterator(v29, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    unsigned int v16 = v27;
    if (v27 >= HIDWORD(v27))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v28, v27 + 1, 8);
      unsigned int v16 = v27;
    }
    *((void *)__src + v16) = v15;
    unsigned int v17 = v27 + 1;
    LODWORD(v27) = v17;
    uint64_t v18 = __src;
    uint64_t v19 = *(unsigned int *)(a2 + 72);
    unint64_t v20 = v19 + v17;
    if (v20 > *(unsigned int *)(a2 + 76))
    {
LABEL_9:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v20, 8);
      LODWORD(v19) = *(_DWORD *)(a2 + 72);
    }
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(v13, 1, "invalid number of operands")) {
      llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
    }
    unsigned int v17 = v27;
    uint64_t v18 = __src;
    uint64_t v19 = *(unsigned int *)(a2 + 72);
    unint64_t v20 = v19 + v27;
    if (v20 > *(unsigned int *)(a2 + 76)) {
      goto LABEL_9;
    }
  }
  if (v17)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v19), v18, 8 * v17);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v19 + v17;
  if (__src != v28) {
    free(__src);
  }
}

uint64_t mlir::mps::CumulativeMinimumOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.cumulative_minimum", 22, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC9815C8;
  v4[12] = mlir::mps::CumulativeMinimumOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeProductOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x10uLL);
    *uint64_t v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CumulativeProductOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeProductOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CumulativeProductOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeProductOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::CumulativeProductOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 118;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        __int16 v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::CumulativeProductOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[41];
    return a1[32];
  }
  return result;
}

void mlir::mps::CumulativeProductOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  unint64_t v29[2] = *MEMORY[0x1E4F143B8];
  uint64_t v21 = a4;
  uint64_t v22 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v22, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  if (a5)
  {
    uint64_t UnitAttr = mlir::Builder::getUnitAttr(a1, v10);
    *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeProductOpGenericAdaptorBase::Properties>((void *)a2) = UnitAttr;
  }
  if (a6)
  {
    uint64_t v12 = mlir::Builder::getUnitAttr(a1, v10);
    *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeProductOpGenericAdaptorBase::Properties>((void *)a2)
              + 8) = v12;
  }
  __src = v28;
  uint64_t v27 = 0x200000000;
  uint64_t v13 = *(void *)a2;
  mlir::ValueRange::ValueRange(&v24, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v23, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v29[0] = v24;
  v29[1] = v25;
  if (v25)
  {
    unint64_t v15 = *(void *)(mlir::ValueRange::dereference_iterator(v29, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    unsigned int v16 = v27;
    if (v27 >= HIDWORD(v27))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v28, v27 + 1, 8);
      unsigned int v16 = v27;
    }
    *((void *)__src + v16) = v15;
    unsigned int v17 = v27 + 1;
    LODWORD(v27) = v17;
    uint64_t v18 = __src;
    uint64_t v19 = *(unsigned int *)(a2 + 72);
    unint64_t v20 = v19 + v17;
    if (v20 > *(unsigned int *)(a2 + 76))
    {
LABEL_9:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v20, 8);
      LODWORD(v19) = *(_DWORD *)(a2 + 72);
    }
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(v13, 1, "invalid number of operands")) {
      llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
    }
    unsigned int v17 = v27;
    uint64_t v18 = __src;
    uint64_t v19 = *(unsigned int *)(a2 + 72);
    unint64_t v20 = v19 + v27;
    if (v20 > *(unsigned int *)(a2 + 76)) {
      goto LABEL_9;
    }
  }
  if (v17)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v19), v18, 8 * v17);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v19 + v17;
  if (__src != v28) {
    free(__src);
  }
}

uint64_t mlir::mps::CumulativeProductOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.cumulative_product", 22, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC981620;
  v4[12] = mlir::mps::CumulativeProductOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeSumOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x10uLL);
    *uint64_t v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CumulativeSumOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeSumOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CumulativeSumOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeSumOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::CumulativeSumOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 114;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        __int16 v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::CumulativeSumOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[43];
    return a1[32];
  }
  return result;
}

void mlir::mps::CumulativeSumOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  unint64_t v29[2] = *MEMORY[0x1E4F143B8];
  uint64_t v21 = a4;
  uint64_t v22 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v22, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  if (a5)
  {
    uint64_t UnitAttr = mlir::Builder::getUnitAttr(a1, v10);
    *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeSumOpGenericAdaptorBase::Properties>((void *)a2) = UnitAttr;
  }
  if (a6)
  {
    uint64_t v12 = mlir::Builder::getUnitAttr(a1, v10);
    *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeSumOpGenericAdaptorBase::Properties>((void *)a2)
              + 8) = v12;
  }
  __src = v28;
  uint64_t v27 = 0x200000000;
  uint64_t v13 = *(void *)a2;
  mlir::ValueRange::ValueRange(&v24, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v23, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v29[0] = v24;
  v29[1] = v25;
  if (v25)
  {
    unint64_t v15 = *(void *)(mlir::ValueRange::dereference_iterator(v29, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    unsigned int v16 = v27;
    if (v27 >= HIDWORD(v27))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v28, v27 + 1, 8);
      unsigned int v16 = v27;
    }
    *((void *)__src + v16) = v15;
    unsigned int v17 = v27 + 1;
    LODWORD(v27) = v17;
    uint64_t v18 = __src;
    uint64_t v19 = *(unsigned int *)(a2 + 72);
    unint64_t v20 = v19 + v17;
    if (v20 > *(unsigned int *)(a2 + 76))
    {
LABEL_9:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v20, 8);
      LODWORD(v19) = *(_DWORD *)(a2 + 72);
    }
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(v13, 1, "invalid number of operands")) {
      llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
    }
    unsigned int v17 = v27;
    uint64_t v18 = __src;
    uint64_t v19 = *(unsigned int *)(a2 + 72);
    unint64_t v20 = v19 + v27;
    if (v20 > *(unsigned int *)(a2 + 76)) {
      goto LABEL_9;
    }
  }
  if (v17)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v19), v18, 8 * v17);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v19 + v17;
  if (__src != v28) {
    free(__src);
  }
}

uint64_t mlir::mps::CumulativeSumOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.cumulative_sum", 18, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC980808;
  v4[12] = mlir::mps::CumulativeSumOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::DegammaOpGenericAdaptorBase::DegammaOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.degamma", 11, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::DegammaOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.degamma", 11, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC983828;
  v4[12] = mlir::mps::DegammaOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::DepthToSpace2DOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v5 = (_OWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  }
  else {
    unint64_t v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v11, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *(_OWORD *)v11;
  *(_OWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 40) = v8;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.depth_to_space_2d", 21, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::DepthToSpace2DOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v89 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v75 = v6;
  if (!v6)
  {
    a3(v79, a4);
    if (v79[0])
    {
      int v76 = 3;
      uint64_t v77 = "expected DictionaryAttr to set properties";
      uint64_t v78 = 41;
      unint64_t v26 = &v76;
      uint64_t v27 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v63 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v69 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          uint64_t v27 = (char *)v80;
          unint64_t v26 = (int *)((char *)v80 + v69);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          unint64_t v26 = &v76;
          uint64_t v27 = (char *)v80;
        }
      }
      unint64_t v28 = &v27[24 * v81];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)unint64_t v28 = v29;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
    if (!v88) {
      return 0;
    }
    uint64_t v30 = (void **)__p;
    if (__p)
    {
      uint64_t v31 = v87;
      unint64_t v32 = __p;
      if (v87 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unint64_t v32 = __p;
      }
      uint64_t v87 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v84;
    if (!v84) {
      goto LABEL_79;
    }
    uint64_t v33 = v85;
    unint64_t v23 = v84;
    if (v85 == v84) {
      goto LABEL_78;
    }
    do
    {
      int64_t v35 = (void *)*--v33;
      unint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
    goto LABEL_77;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v75, "block_size", 0xAuLL);
  if (!v8)
  {
    a3(v79, a4);
    if (v79[0])
    {
      int v76 = 3;
      uint64_t v77 = "expected key entry for block_size in DictionaryAttr to set Properties.";
      uint64_t v78 = 70;
      uint64_t v36 = &v76;
      uint64_t v37 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v65 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v71 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
          uint64_t v37 = (char *)v80;
          uint64_t v36 = (int *)((char *)v80 + v71);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
          uint64_t v36 = &v76;
          uint64_t v37 = (char *)v80;
        }
      }
      unsigned int v38 = &v37[24 * v81];
      long long v39 = *(_OWORD *)v36;
      *((void *)v38 + 2) = *((void *)v36 + 2);
      *(_OWORD *)unsigned int v38 = v39;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
    if (!v88) {
      return 0;
    }
    int v40 = (void **)__p;
    if (__p)
    {
      long long v41 = v87;
      uint64_t v42 = __p;
      if (v87 != __p)
      {
        do
          long long v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        uint64_t v42 = __p;
      }
      uint64_t v87 = v40;
      operator delete(v42);
    }
    uint64_t v21 = v84;
    if (!v84) {
      goto LABEL_79;
    }
    uint64_t v43 = v85;
    unint64_t v23 = v84;
    if (v85 == v84) {
      goto LABEL_78;
    }
    do
    {
      long long v45 = (void *)*--v43;
      unint64_t v44 = v45;
      void *v43 = 0;
      if (v45) {
        operator delete[](v44);
      }
    }
    while (v43 != v21);
    goto LABEL_77;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    a3(v79, a4);
    if (v79[0])
    {
      int v76 = 3;
      uint64_t v78 = 55;
      uint64_t v10 = &v76;
      uint64_t v11 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v64 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v70 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
          uint64_t v11 = (char *)v80;
          uint64_t v10 = (int *)((char *)v80 + v70);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
          uint64_t v10 = &v76;
          uint64_t v11 = (char *)v80;
        }
      }
      uint64_t v12 = &v11[24 * v81];
      long long v13 = *(_OWORD *)v10;
      *((void *)v12 + 2) = *((void *)v10 + 2);
      *(_OWORD *)uint64_t v12 = v13;
      ++v81;
      if (v79[0])
      {
        unint64_t v14 = &v76;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v9);
        unint64_t v15 = (char *)v80;
        if (v81 >= v82)
        {
          unint64_t v66 = v81 + 1;
          if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
          {
            int64_t v72 = (char *)&v76 - (unsigned char *)v80;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
            unint64_t v15 = (char *)v80;
            unint64_t v14 = (int *)((char *)v80 + v72);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
            unint64_t v14 = &v76;
            unint64_t v15 = (char *)v80;
          }
        }
        unsigned int v16 = &v15[24 * v81];
        long long v17 = *(_OWORD *)v14;
        *((void *)v16 + 2) = *((void *)v14 + 2);
        *(_OWORD *)unsigned int v16 = v17;
        ++v81;
        if (v79[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
        }
      }
    }
    if (!v88) {
      return 0;
    }
    uint64_t v18 = (void **)__p;
    if (__p)
    {
      uint64_t v19 = v87;
      unint64_t v20 = __p;
      if (v87 != __p)
      {
        do
          uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        unint64_t v20 = __p;
      }
      uint64_t v87 = v18;
      operator delete(v20);
    }
    uint64_t v21 = v84;
    if (!v84) {
      goto LABEL_79;
    }
    uint64_t v22 = v85;
    unint64_t v23 = v84;
    if (v85 == v84) {
      goto LABEL_78;
    }
    do
    {
      uint64_t v25 = (void *)*--v22;
      unint64_t v24 = v25;
      *uint64_t v22 = 0;
      if (v25) {
        operator delete[](v24);
      }
    }
    while (v22 != v21);
    goto LABEL_77;
  }
  *a1 = v8;
  uint64_t v46 = mlir::DictionaryAttr::get((uint64_t)&v75, "pixel_shuffle", 0xDuLL);
  if (!v46) {
    return 1;
  }
  uint64_t v47 = v46;
  if (*(_UNKNOWN **)(*(void *)v46 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    a1[1] = v46;
    return 1;
  }
  a3(v79, a4);
  if (v79[0])
  {
    int v76 = 3;
    uint64_t v78 = 58;
    unsigned int v48 = &v76;
    int64_t v49 = (char *)v80;
    if (v81 >= v82)
    {
      unint64_t v67 = v81 + 1;
      if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
      {
        int64_t v73 = (char *)&v76 - (unsigned char *)v80;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
        int64_t v49 = (char *)v80;
        unsigned int v48 = (int *)((char *)v80 + v73);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
        unsigned int v48 = &v76;
        int64_t v49 = (char *)v80;
      }
    }
    uint64_t v50 = &v49[24 * v81];
    long long v51 = *(_OWORD *)v48;
    *((void *)v50 + 2) = *((void *)v48 + 2);
    *(_OWORD *)uint64_t v50 = v51;
    ++v81;
    if (v79[0])
    {
      uint64_t v52 = &v76;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v47);
      unint64_t v53 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v68 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v74 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          unint64_t v53 = (char *)v80;
          uint64_t v52 = (int *)((char *)v80 + v74);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          uint64_t v52 = &v76;
          unint64_t v53 = (char *)v80;
        }
      }
      unint64_t v54 = &v53[24 * v81];
      long long v55 = *(_OWORD *)v52;
      *((void *)v54 + 2) = *((void *)v52 + 2);
      *(_OWORD *)unint64_t v54 = v55;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
  }
  if (v88)
  {
    unint64_t v56 = (void **)__p;
    if (__p)
    {
      unint64_t v57 = v87;
      int64_t v58 = __p;
      if (v87 != __p)
      {
        do
          unint64_t v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        int64_t v58 = __p;
      }
      uint64_t v87 = v56;
      operator delete(v58);
    }
    uint64_t v21 = v84;
    if (!v84) {
      goto LABEL_79;
    }
    int64_t v59 = v85;
    unint64_t v23 = v84;
    if (v85 == v84)
    {
LABEL_78:
      int64_t v85 = v21;
      operator delete(v23);
LABEL_79:
      if (v80 != v83) {
        free(v80);
      }
      return 0;
    }
    do
    {
      int64_t v61 = (void *)*--v59;
      int64_t v60 = v61;
      void *v59 = 0;
      if (v61) {
        operator delete[](v60);
      }
    }
    while (v59 != v21);
LABEL_77:
    unint64_t v23 = v84;
    goto LABEL_78;
  }
  return 0;
}

uint64_t mlir::mps::DepthToSpace2DOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v21[6] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a1;
  uint64_t v19 = v21;
  uint64_t v20 = 0x300000000;
  if (*a2)
  {
    uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"block_size", 10, *a2);
    uint64_t v5 = v4;
    unsigned int v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      unsigned int v6 = v20;
    }
    uint64_t v7 = (uint64_t *)((char *)v19 + 16 * v6);
    uint64_t *v7 = NamedAttr;
    v7[1] = v5;
    unsigned int v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    uint64_t v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      uint64_t v10 = (uint64_t *)v19;
      if (v8) {
        goto LABEL_6;
      }
LABEL_13:
      uint64_t DictionaryAttr = 0;
      if (v10 == v21) {
        return DictionaryAttr;
      }
      goto LABEL_7;
    }
  }
  else
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_5;
    }
  }
  uint64_t v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"pixel_shuffle", 13, v9);
  uint64_t v15 = v14;
  unsigned int v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    unsigned int v16 = v20;
  }
  long long v17 = (uint64_t *)((char *)v19 + 16 * v16);
  *long long v17 = v13;
  v17[1] = v15;
  unsigned int v8 = v20 + 1;
  LODWORD(v20) = v8;
  uint64_t v10 = (uint64_t *)v19;
  if (!v8) {
    goto LABEL_13;
  }
LABEL_6:
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  uint64_t v10 = (uint64_t *)v19;
  if (v19 != v21) {
LABEL_7:
  }
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x10uLL);
    *uint64_t v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 115;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        unsigned int v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[45];
    return a1[32];
  }
  return result;
}

void mlir::mps::DepthToSpace2DOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, int a8)
{
  v34[2] = *MEMORY[0x1E4F143B8];
  uint64_t v28 = a4;
  uint64_t v29 = a3;
  uint64_t v26 = a6;
  uint64_t v27 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v29, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v28, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v27, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v26, 1);
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x20u, 0);
  uint64_t IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a7);
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::Properties>((void *)a2) = IntegerAttr;
  if (a8)
  {
    uint64_t UnitAttr = mlir::Builder::getUnitAttr((mlir::UnitAttr **)a1, v14);
    *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::Properties>((void *)a2)
              + 8) = UnitAttr;
  }
  __src = v34;
  uint64_t v33 = 0x200000000;
  unsigned int v16 = *(mlir::UnknownLoc **)a1;
  long long v17 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v31, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v20 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v30, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::DepthToSpace2DOp::inferReturnTypes(v16, v17, 1, v31[0], v31[1], Dictionary, v20, v21, v30[0], v30[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v22 = __src;
  }
  uint64_t v23 = v33;
  uint64_t v24 = *(unsigned int *)(a2 + 72);
  unint64_t v25 = v24 + v33;
  if (v25 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v25, 8);
    LODWORD(v24) = *(_DWORD *)(a2 + 72);
  }
  if (v23)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v24), v22, 8 * v23);
    LODWORD(v24) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v24 + v23;
  if (__src != v34) {
    free(__src);
  }
}

BOOL mlir::mps::DepthToSpace2DOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    unint64_t v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    unint64_t v3 = 0;
  }
  uint64_t v4 = *(const void ***)v3;
  if (*(void *)v3)
  {
    uint64_t v5 = *(void *)(v3 + 8);
    v20[0] = v2;
    if (mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v4, (const void **)"block_size", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20)&& (v20[0] = *this, mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (const void **)"pixel_shuffle", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20))&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(
                            *this,
                            (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8),
                            (const void **)"operand",
                            7,
                            1u)
      && mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 2u)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 120) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 3u))
    {
      if (*((_DWORD *)*this + 9)) {
        uint64_t v6 = (uint64_t)(*this - 2);
      }
      else {
        uint64_t v6 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    uint64_t v18 = (const void **)"requires attribute 'block_size'";
    __int16 v19 = 259;
    mlir::OpState::emitOpError(this, &v18, (uint64_t)v20);
    uint64_t v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v20);
    if (v20[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v20);
    }
    if (v27)
    {
      uint64_t v10 = (void **)__p;
      if (__p)
      {
        unint64_t v11 = v26;
        uint64_t v12 = __p;
        if (v26 != __p)
        {
          do
            unint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
          while (v11 != v10);
          uint64_t v12 = __p;
        }
        uint64_t v26 = v10;
        operator delete(v12);
      }
      uint64_t v13 = v23;
      if (v23)
      {
        unint64_t v14 = v24;
        uint64_t v15 = v23;
        if (v24 != v23)
        {
          do
          {
            long long v17 = (void *)*--v14;
            unsigned int v16 = v17;
            *unint64_t v14 = 0;
            if (v17) {
              operator delete[](v16);
            }
          }
          while (v14 != v13);
          uint64_t v15 = v23;
        }
        uint64_t v24 = v13;
        operator delete(v15);
      }
      if (v21 != &v22) {
        free(v21);
      }
    }
  }
  return v8;
}

uint64_t mlir::mps::DepthToSpace2DOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.depth_to_space_2d", 21, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC980C80;
  v4[12] = mlir::mps::DepthToSpace2DOp::canonicalize;
  unint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::DepthwiseConv2DDataGradientOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v122 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v108 = v6;
  if (!v6)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      uint64_t v110 = "expected DictionaryAttr to set properties";
      uint64_t v111 = 41;
      uint64_t v26 = &v109;
      char v27 = (char *)v113;
      if (v114 >= v115)
      {
        unint64_t v91 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          int64_t v99 = (char *)&v109 - (unsigned char *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v91, 24);
          char v27 = (char *)v113;
          uint64_t v26 = (uint64_t *)((char *)v113 + v99);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v91, 24);
          uint64_t v26 = &v109;
          char v27 = (char *)v113;
        }
      }
      uint64_t v28 = &v27[24 * v114];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)uint64_t v28 = v29;
      ++v114;
      if (v112[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121) {
      return 0;
    }
    uint64_t v30 = (void **)__p;
    if (__p)
    {
      uint64_t v31 = v120;
      unint64_t v32 = __p;
      if (v120 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unint64_t v32 = __p;
      }
      char v120 = v30;
      operator delete(v32);
    }
    int v21 = v117;
    if (!v117) {
      goto LABEL_117;
    }
    uint64_t v33 = v118;
    uint64_t v23 = v117;
    if (v118 == v117)
    {
LABEL_116:
      BOOL v118 = v21;
      operator delete(v23);
LABEL_117:
      if (v113 != v116) {
        free(v113);
      }
      return 0;
    }
    do
    {
      int64_t v35 = (void *)*--v33;
      unint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
LABEL_115:
    uint64_t v23 = v117;
    goto LABEL_116;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v108, "data_layout", 0xBuLL);
  if (!v8)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      uint64_t v110 = "expected key entry for data_layout in DictionaryAttr to set Properties.";
      uint64_t v111 = 71;
      uint64_t v36 = &v109;
      uint64_t v37 = (char *)v113;
      if (v114 >= v115)
      {
        unint64_t v93 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          int64_t v101 = (char *)&v109 - (unsigned char *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v93, 24);
          uint64_t v37 = (char *)v113;
          uint64_t v36 = (uint64_t *)((char *)v113 + v101);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v93, 24);
          uint64_t v36 = &v109;
          uint64_t v37 = (char *)v113;
        }
      }
      unsigned int v38 = &v37[24 * v114];
      long long v39 = *(_OWORD *)v36;
      *((void *)v38 + 2) = v36[2];
      *(_OWORD *)unsigned int v38 = v39;
      ++v114;
      if (v112[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121) {
      return 0;
    }
    int v40 = (void **)__p;
    if (__p)
    {
      long long v41 = v120;
      uint64_t v42 = __p;
      if (v120 != __p)
      {
        do
          long long v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        uint64_t v42 = __p;
      }
      char v120 = v40;
      operator delete(v42);
    }
    int v21 = v117;
    if (!v117) {
      goto LABEL_117;
    }
    uint64_t v43 = v118;
    uint64_t v23 = v117;
    if (v118 == v117) {
      goto LABEL_116;
    }
    do
    {
      long long v45 = (void *)*--v43;
      unint64_t v44 = v45;
      void *v43 = 0;
      if (v45) {
        operator delete[](v44);
      }
    }
    while (v43 != v21);
    goto LABEL_115;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      uint64_t v111 = 56;
      uint64_t v10 = &v109;
      unint64_t v11 = (char *)v113;
      if (v114 >= v115)
      {
        unint64_t v92 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          int64_t v100 = (char *)&v109 - (unsigned char *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v92, 24);
          unint64_t v11 = (char *)v113;
          uint64_t v10 = (uint64_t *)((char *)v113 + v100);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v92, 24);
          uint64_t v10 = &v109;
          unint64_t v11 = (char *)v113;
        }
      }
      uint64_t v12 = &v11[24 * v114];
      long long v13 = *(_OWORD *)v10;
      *((void *)v12 + 2) = v10[2];
      *(_OWORD *)uint64_t v12 = v13;
      ++v114;
      if (v112[0])
      {
        unint64_t v14 = &v109;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v109, v9);
        uint64_t v15 = (char *)v113;
        if (v114 >= v115)
        {
          unint64_t v94 = v114 + 1;
          if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
          {
            int64_t v102 = (char *)&v109 - (unsigned char *)v113;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v94, 24);
            uint64_t v15 = (char *)v113;
            unint64_t v14 = (uint64_t *)((char *)v113 + v102);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v94, 24);
            unint64_t v14 = &v109;
            uint64_t v15 = (char *)v113;
          }
        }
        unsigned int v16 = &v15[24 * v114];
        long long v17 = *(_OWORD *)v14;
        *((void *)v16 + 2) = v14[2];
        *(_OWORD *)unsigned int v16 = v17;
        ++v114;
        if (v112[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
        }
      }
    }
    if (!v121) {
      return 0;
    }
    uint64_t v18 = (void **)__p;
    if (__p)
    {
      __int16 v19 = v120;
      uint64_t v20 = __p;
      if (v120 != __p)
      {
        do
          __int16 v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        uint64_t v20 = __p;
      }
      char v120 = v18;
      operator delete(v20);
    }
    int v21 = v117;
    if (!v117) {
      goto LABEL_117;
    }
    uint64_t v22 = v118;
    uint64_t v23 = v117;
    if (v118 == v117) {
      goto LABEL_116;
    }
    do
    {
      unint64_t v25 = (void *)*--v22;
      uint64_t v24 = v25;
      *uint64_t v22 = 0;
      if (v25) {
        operator delete[](v24);
      }
    }
    while (v22 != v21);
    goto LABEL_115;
  }
  *a1 = v8;
  uint64_t v46 = mlir::DictionaryAttr::get((uint64_t)&v108, "dilation_rates", 0xEuLL);
  if (!v46)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      uint64_t v110 = "expected key entry for dilation_rates in DictionaryAttr to set Properties.";
      uint64_t v111 = 74;
      uint64_t v52 = &v109;
      unint64_t v53 = (char *)v113;
      if (v114 >= v115)
      {
        unint64_t v95 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          int64_t v103 = (char *)&v109 - (unsigned char *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v95, 24);
          unint64_t v53 = (char *)v113;
          uint64_t v52 = (uint64_t *)((char *)v113 + v103);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v95, 24);
          uint64_t v52 = &v109;
          unint64_t v53 = (char *)v113;
        }
      }
      unint64_t v54 = &v53[24 * v114];
      long long v55 = *(_OWORD *)v52;
      *((void *)v54 + 2) = v52[2];
      *(_OWORD *)unint64_t v54 = v55;
      ++v114;
      if (v112[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121) {
      return 0;
    }
    unint64_t v56 = (void **)__p;
    if (__p)
    {
      unint64_t v57 = v120;
      int64_t v58 = __p;
      if (v120 != __p)
      {
        do
          unint64_t v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        int64_t v58 = __p;
      }
      char v120 = v56;
      operator delete(v58);
    }
    int v21 = v117;
    if (!v117) {
      goto LABEL_117;
    }
    int64_t v59 = v118;
    uint64_t v23 = v117;
    if (v118 == v117) {
      goto LABEL_116;
    }
    do
    {
      int64_t v61 = (void *)*--v59;
      int64_t v60 = v61;
      void *v59 = 0;
      if (v61) {
        operator delete[](v60);
      }
    }
    while (v59 != v21);
    goto LABEL_115;
  }
  uint64_t v47 = v46;
  if ((mlir::DenseIntElementsAttr::classof(v46) & 1) == 0)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      uint64_t v111 = 59;
      int64_t v62 = &v109;
      unint64_t v63 = (char *)v113;
      if (v114 >= v115)
      {
        unint64_t v96 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          int64_t v104 = (char *)&v109 - (unsigned char *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v96, 24);
          unint64_t v63 = (char *)v113;
          int64_t v62 = (uint64_t *)((char *)v113 + v104);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v96, 24);
          int64_t v62 = &v109;
          unint64_t v63 = (char *)v113;
        }
      }
      unint64_t v64 = &v63[24 * v114];
      long long v65 = *(_OWORD *)v62;
      *((void *)v64 + 2) = v62[2];
      *(_OWORD *)unint64_t v64 = v65;
      ++v114;
      if (v112[0])
      {
        unint64_t v66 = &v109;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v109, v47);
        unint64_t v67 = (char *)v113;
        if (v114 >= v115)
        {
          unint64_t v97 = v114 + 1;
          if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
          {
            int64_t v105 = (char *)&v109 - (unsigned char *)v113;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v97, 24);
            unint64_t v67 = (char *)v113;
            unint64_t v66 = (uint64_t *)((char *)v113 + v105);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v97, 24);
            unint64_t v66 = &v109;
            unint64_t v67 = (char *)v113;
          }
        }
        unint64_t v68 = &v67[24 * v114];
        long long v69 = *(_OWORD *)v66;
        *((void *)v68 + 2) = v66[2];
        *(_OWORD *)unint64_t v68 = v69;
        ++v114;
        if (v112[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
        }
      }
    }
    if (!v121) {
      return 0;
    }
    int64_t v70 = (void **)__p;
    if (__p)
    {
      int64_t v71 = v120;
      int64_t v72 = __p;
      if (v120 != __p)
      {
        do
          int64_t v71 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v71 - 1);
        while (v71 != v70);
        int64_t v72 = __p;
      }
      char v120 = v70;
      operator delete(v72);
    }
    int v21 = v117;
    if (!v117) {
      goto LABEL_117;
    }
    int64_t v73 = v118;
    uint64_t v23 = v117;
    if (v118 == v117) {
      goto LABEL_116;
    }
    do
    {
      uint64_t v75 = (void *)*--v73;
      int64_t v74 = v75;
      *int64_t v73 = 0;
      if (v75) {
        operator delete[](v74);
      }
    }
    while (v73 != v21);
    goto LABEL_115;
  }
  a1[1] = v47;
  uint64_t v48 = mlir::DictionaryAttr::get((uint64_t)&v108, "explicit_padding", 0x10uLL);
  uint64_t v107 = v48;
  if (!v48)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      uint64_t v110 = "expected key entry for explicit_padding in DictionaryAttr to set Properties.";
      uint64_t v111 = 76;
      int v76 = &v109;
      uint64_t v77 = (char *)v113;
      if (v114 >= v115)
      {
        unint64_t v98 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          int64_t v106 = (char *)&v109 - (unsigned char *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v98, 24);
          uint64_t v77 = (char *)v113;
          int v76 = (uint64_t *)((char *)v113 + v106);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v98, 24);
          int v76 = &v109;
          uint64_t v77 = (char *)v113;
        }
      }
      uint64_t v78 = &v77[24 * v114];
      long long v79 = *(_OWORD *)v76;
      *((void *)v78 + 2) = v76[2];
      *(_OWORD *)uint64_t v78 = v79;
      ++v114;
      if (v112[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121) {
      return 0;
    }
    char v80 = (void **)__p;
    if (__p)
    {
      unsigned int v81 = v120;
      unsigned int v82 = __p;
      if (v120 != __p)
      {
        do
          unsigned int v81 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v81 - 1);
        while (v81 != v80);
        unsigned int v82 = __p;
      }
      char v120 = v80;
      operator delete(v82);
    }
    int v21 = v117;
    if (!v117) {
      goto LABEL_117;
    }
    char v83 = v118;
    uint64_t v23 = v117;
    if (v118 == v117) {
      goto LABEL_116;
    }
    do
    {
      int64_t v85 = (void *)*--v83;
      uint64_t v84 = v85;
      *char v83 = 0;
      if (v85) {
        operator delete[](v84);
      }
    }
    while (v83 != v21);
    goto LABEL_115;
  }
  uint64_t v49 = v48;
  if (mlir::DenseIntElementsAttr::classof(v48))
  {
    a1[2] = v49;
    uint64_t v50 = mlir::DictionaryAttr::get((uint64_t)&v108, "padding_style", 0xDuLL);
    uint64_t v109 = v50;
    if (v50)
    {
      if (*(_UNKNOWN **)(*(void *)v50 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
      {
        a1[3] = v50;
        uint64_t v88 = mlir::DictionaryAttr::get((uint64_t)&v108, "strides", 7uLL);
        uint64_t v109 = v88;
        if (!v88)
        {
          a3(v112, a4);
          mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v112, "expected key entry for strides in DictionaryAttr to set Properties.");
          goto LABEL_123;
        }
        uint64_t v89 = v88;
        if (mlir::DenseIntElementsAttr::classof(v88))
        {
          a1[4] = v89;
          uint64_t v90 = mlir::DictionaryAttr::get((uint64_t)&v108, "weights_layout", 0xEuLL);
          uint64_t v109 = v90;
          if (!v90)
          {
            a3(v112, a4);
            mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v112, "expected key entry for weights_layout in DictionaryAttr to set Properties.");
            goto LABEL_123;
          }
          if (*(_UNKNOWN **)(*(void *)v90 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
          {
            a1[5] = v90;
            return 1;
          }
          a3(v112, a4);
        }
        else
        {
          a3(v112, a4);
        }
      }
      else
      {
        a3(v112, a4);
      }
      mlir::InFlightDiagnostic::append<mlir::Attribute>(v51, &v109);
    }
    else
    {
      a3(v112, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v112, "expected key entry for padding_style in DictionaryAttr to set Properties.");
    }
LABEL_123:
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v112);
    return 0;
  }
  a3(v112, a4);
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v87, &v107);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v112);
  return 0;
}

uint64_t mlir::mps::DepthwiseConv2DDataGradientOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v45[6] = *MEMORY[0x1E4F143B8];
  uint64_t v42 = a1;
  uint64_t v43 = v45;
  uint64_t v44 = 0x300000000;
  if (!*a2)
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v42, (uint64_t)"data_layout", 11, *a2);
  uint64_t v5 = v4;
  unsigned int v6 = v44;
  if (v44 >= HIDWORD(v44))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v43, v45, v44 + 1, 16);
    unsigned int v6 = v44;
  }
  unint64_t v7 = (uint64_t *)((char *)v43 + 16 * v6);
  uint64_t *v7 = NamedAttr;
  v7[1] = v5;
  unsigned int v8 = v44 + 1;
  LODWORD(v44) = v44 + 1;
  uint64_t v9 = a2[1];
  if (v9)
  {
LABEL_7:
    uint64_t v10 = mlir::Builder::getNamedAttr(&v42, (uint64_t)"dilation_rates", 14, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v44;
    if (v44 >= HIDWORD(v44))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v43, v45, v44 + 1, 16);
      unsigned int v13 = v44;
    }
    unint64_t v14 = (uint64_t *)((char *)v43 + 16 * v13);
    *unint64_t v14 = v10;
    v14[1] = v12;
    unsigned int v8 = v44 + 1;
    LODWORD(v44) = v44 + 1;
  }
LABEL_10:
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v42, (uint64_t)"explicit_padding", 16, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v44;
    if (v44 >= HIDWORD(v44))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v43, v45, v44 + 1, 16);
      unsigned int v19 = v44;
    }
    uint64_t v20 = (uint64_t *)((char *)v43 + 16 * v19);
    *uint64_t v20 = v16;
    v20[1] = v18;
    unsigned int v8 = v44 + 1;
    LODWORD(v44) = v44 + 1;
  }
  uint64_t v21 = a2[3];
  if (v21)
  {
    uint64_t v22 = mlir::Builder::getNamedAttr(&v42, (uint64_t)"padding_style", 13, v21);
    uint64_t v24 = v23;
    unsigned int v25 = v44;
    if (v44 >= HIDWORD(v44))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v43, v45, v44 + 1, 16);
      unsigned int v25 = v44;
    }
    uint64_t v26 = (uint64_t *)((char *)v43 + 16 * v25);
    *uint64_t v26 = v22;
    v26[1] = v24;
    unsigned int v8 = v44 + 1;
    LODWORD(v44) = v44 + 1;
  }
  uint64_t v27 = a2[4];
  if (v27)
  {
    uint64_t v28 = mlir::Builder::getNamedAttr(&v42, (uint64_t)"strides", 7, v27);
    uint64_t v30 = v29;
    unsigned int v31 = v44;
    if (v44 >= HIDWORD(v44))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v43, v45, v44 + 1, 16);
      unsigned int v31 = v44;
    }
    unint64_t v32 = (uint64_t *)((char *)v43 + 16 * v31);
    *unint64_t v32 = v28;
    v32[1] = v30;
    unsigned int v8 = v44 + 1;
    LODWORD(v44) = v44 + 1;
  }
  uint64_t v33 = a2[5];
  if (v33)
  {
    uint64_t v34 = mlir::Builder::getNamedAttr(&v42, (uint64_t)"weights_layout", 14, v33);
    uint64_t v36 = v35;
    unsigned int v37 = v44;
    if (v44 >= HIDWORD(v44))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v43, v45, v44 + 1, 16);
      unsigned int v37 = v44;
    }
    unsigned int v38 = (uint64_t *)((char *)v43 + 16 * v37);
    uint64_t *v38 = v34;
    v38[1] = v36;
    unsigned int v8 = v44 + 1;
    LODWORD(v44) = v44 + 1;
  }
  long long v39 = v43;
  if (!v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v43 == v45) {
      return DictionaryAttr;
    }
    goto LABEL_28;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v42, (uint64_t *)v43, v8);
  long long v39 = v43;
  if (v43 != v45) {
LABEL_28:
  }
    free(v39);
  return DictionaryAttr;
}

uint64_t mlir::mps::DepthwiseConv2DDataGradientOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[4];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x79616C5F61746164 || *(void *)(__s1 + 3) != 0x74756F79616C5F61) {
        return 0;
      }
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[3];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n)) {
        return a2[1];
      }
      if (memcmp(__s1, "weights_layout", __n)) {
        return 0;
      }
      return a2[5];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::DepthwiseConv2DDataGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  unint64_t v7 = (void *)result;
  switch(__n)
  {
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v13 = a4;
          }
          else {
            uint64_t v13 = 0;
          }
          v7[4] = v13;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x79616C5F61746164 && *(void *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
            uint64_t v9 = a4;
          }
          else {
            uint64_t v9 = 0;
          }
          *(void *)uint64_t result = v9;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          v7[3] = v10;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "weights_layout", __n);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
              uint64_t v11 = a4;
            }
            else {
              uint64_t v11 = 0;
            }
            v7[5] = v11;
          }
          else
          {
            v7[5] = 0;
          }
        }
      }
      else if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
        if (result) {
          uint64_t v14 = a4;
        }
        else {
          uint64_t v14 = 0;
        }
        v7[1] = v14;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v12 = a4;
          }
          else {
            uint64_t v12 = 0;
          }
          v7[2] = v12;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::DepthwiseConv2DDataGradientOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (*a2) {
    mlir::NamedAttrList::append(a3, (uint64_t)"data_layout", 11, *a2);
  }
  uint64_t v5 = a2[1];
  if (v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"dilation_rates", 14, v5);
  }
  uint64_t v6 = a2[2];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"explicit_padding", 16, v6);
  }
  uint64_t v7 = a2[3];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"padding_style", 13, v7);
  }
  uint64_t v8 = a2[4];
  if (v8) {
    mlir::NamedAttrList::append(a3, (uint64_t)"strides", 7, v8);
  }
  uint64_t v9 = a2[5];
  if (v9)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"weights_layout", 14, v9);
  }
}

BOOL mlir::mps::DepthwiseConv2DDataGradientOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v8, (const void **)"data_layout", (const char *)0xB, a3, a4))
  {
    uint64_t v9 = (const void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v9, (const void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))a3, a4))
    {
      uint64_t v10 = (const void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v10, (const void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))a3, a4))
      {
        uint64_t v11 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 24));
        if (!v11
          || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v11, (const void **)"padding_style", (const char *)0xD, a3, a4))
        {
          uint64_t v12 = (const void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v12, (const void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))a3, a4))
          {
            uint64_t v13 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v13, (const void **)"weights_layout", (const char *)0xE, a3, a4))
            {
              return 1;
            }
          }
        }
      }
    }
  }
  return result;
}

BOOL mlir::mps::DepthwiseConv2DDataGradientOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 5) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x30uLL);
    *uint64_t v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAd"
              "aptorBase::Properties]";
        unint64_t v14 = 128;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[47];
    return a1[32];
  }
  return result;
}

uint64_t mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle(mlir::mps::DepthwiseConv2DDataGradientOp *this)
{
  unint64_t v1 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v1 = 0;
  }
  return *(unsigned int *)(*(void *)(v1 + 24) + 8);
}

void mlir::mps::DepthwiseConv2DDataGradientOp::setStridesAttr(uint64_t *a1, uint64_t a2)
{
}

void mlir::mps::DepthwiseConv2DDataGradientOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, unsigned int a14, unsigned int a15, unsigned int a16)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  v36[0] = xmmword_181119FA8;
  v36[1] = unk_181119FB8;
  v35[0] = xmmword_181119FA8;
  v35[1] = unk_181119FB8;
  memset(v34, 0, sizeof(v34));
  uint64_t v18 = operator new(0x10uLL);
  _OWORD *v18 = xmmword_18110B5E0;
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  uint64_t v20 = (void *)mlir::RankedTensorType::get((uint64_t)v18, 2, IntegerType, 0);
  uint64_t v21 = operator new(8uLL);
  *uint64_t v21 = 4;
  uint64_t v22 = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  uint64_t v23 = (void *)mlir::RankedTensorType::get((uint64_t)v21, 1, v22, 0);
  uint64_t v24 = v23;
  if (v23) {
    uint64_t v25 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v23 + 8);
  }
  else {
    uint64_t v25 = 0;
  }
  uint64_t v26 = mlir::DenseElementsAttr::getFromRawBuffer(v24, v25, v36, 32, 8, 1, 0);
  if (v24) {
    uint64_t v27 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v24 + 8);
  }
  else {
    uint64_t v27 = 0;
  }
  uint64_t v28 = mlir::DenseElementsAttr::getFromRawBuffer(v24, v27, v35, 32, 8, 1, 0);
  if (v20) {
    uint64_t v29 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v20 + 8);
  }
  else {
    uint64_t v29 = 0;
  }
  uint64_t v30 = mlir::DenseElementsAttr::getFromRawBuffer(v20, v29, v34, 64, 8, 1, 0);
  mlir::mps::DepthwiseConv2DDataGradientOp::build((mlir::MLIRContext **)a1, a2, a3, a4, a5, v26, v28, v30, a14, a15, a16);
  operator delete(v21);
  operator delete(v18);
}

void mlir::mps::DepthwiseConv2DDataGradientOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, unsigned int a10, unsigned int a11)
{
  unint64_t v43[2] = *MEMORY[0x1E4F143B8];
  uint64_t v36 = a4;
  uint64_t v37 = a3;
  uint64_t v35 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v37, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v36, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v35, 1);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 32) = a6;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = a7;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 16) = a8;
  uint64_t v16 = *a1;
  unsigned int v38 = a9;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v16);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  uint64_t v42 = (uint64_t)v16;
  uint64_t v18 = mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v38);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 24) = v18;
  unsigned int v19 = *a1;
  unsigned int v38 = a10;
  uint64_t v20 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v19);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  uint64_t v42 = (uint64_t)v19;
  uint64_t v21 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v20, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v38);
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties>((void *)a2) = v21;
  uint64_t v22 = *a1;
  unsigned int v38 = a11;
  uint64_t v23 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v22);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  uint64_t v42 = (uint64_t)v22;
  uint64_t v24 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v23, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v38);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 40) = v24;
  __src = v43;
  uint64_t v42 = 0x200000000;
  uint64_t v25 = *a1;
  uint64_t v26 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v40, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v29 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v39, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::DepthwiseConv2DDataGradientOp::inferReturnTypes(v25, v26, 1, v40[0], v40[1], Dictionary, v29, v30, v39[0], v39[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  unsigned int v31 = __src;
  }
  uint64_t v32 = v42;
  uint64_t v33 = *(unsigned int *)(a2 + 72);
  unint64_t v34 = v33 + v42;
  if (v34 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v34, 8);
    LODWORD(v33) = *(_DWORD *)(a2 + 72);
  }
  if (v32)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v33), v31, 8 * v32);
    LODWORD(v33) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v33 + v32;
  if (__src != v43) {
    free(__src);
  }
}

BOOL mlir::mps::DepthwiseConv2DDataGradientOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    uint64_t v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *v3;
  if (*v3)
  {
    int v5 = (const void **)v3[1];
    if (v5)
    {
      unint64_t v6 = (const void **)v3[2];
      if (v6)
      {
        uint64_t v7 = v3[3];
        if (v7)
        {
          uint64_t v8 = (const void **)v3[4];
          if (v8)
          {
            uint64_t v9 = v3[5];
            if (v9)
            {
              v48[0] = v2;
              if (mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v8, (const void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48)&& (v48[0] = *this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))&& (v48[0] = *this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))
                && (v48[0] = *this,
                    mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v7, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))&& (v48[0] = *this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))&& (v48[0] = *this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v9, (const void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))
                && mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 2u))
              {
                if (*((_DWORD *)*this + 9)) {
                  uint64_t v10 = (uint64_t)(*this - 2);
                }
                else {
                  uint64_t v10 = 0;
                }
                uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 0);
                return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
              }
              else
              {
                return 0;
              }
            }
            else
            {
              v46[0] = (const void **)"requires attribute 'weights_layout'";
              __int16 v47 = 259;
              mlir::OpState::emitOpError(this, v46, (uint64_t)v48);
              uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
              mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v48);
            }
            return v12;
          }
          v46[0] = (const void **)"requires attribute 'strides'";
          __int16 v47 = 259;
          mlir::OpState::emitOpError(this, v46, (uint64_t)v48);
          uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
          if (v48[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
          }
          if (v55)
          {
            long long v39 = (void **)__p;
            if (__p)
            {
              int v40 = v54;
              long long v41 = __p;
              if (v54 != __p)
              {
                do
                  int v40 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v40 - 1);
                while (v40 != v39);
                long long v41 = __p;
              }
              unint64_t v54 = v39;
              operator delete(v41);
            }
            uint64_t v16 = v51;
            if (!v51) {
              goto LABEL_96;
            }
            uint64_t v42 = v52;
            uint64_t v18 = v51;
            if (v52 == v51)
            {
LABEL_95:
              uint64_t v52 = v16;
              operator delete(v18);
LABEL_96:
              if (v49 != &v50) {
                free(v49);
              }
              return v12;
            }
            do
            {
              uint64_t v44 = (void *)*--v42;
              uint64_t v43 = v44;
              void *v42 = 0;
              if (v44) {
                operator delete[](v43);
              }
            }
            while (v42 != v16);
LABEL_94:
            uint64_t v18 = v51;
            goto LABEL_95;
          }
        }
        else
        {
          v46[0] = (const void **)"requires attribute 'padding_style'";
          __int16 v47 = 259;
          mlir::OpState::emitOpError(this, v46, (uint64_t)v48);
          uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
          if (v48[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
          }
          if (v55)
          {
            uint64_t v33 = (void **)__p;
            if (__p)
            {
              unint64_t v34 = v54;
              uint64_t v35 = __p;
              if (v54 != __p)
              {
                do
                  unint64_t v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
                while (v34 != v33);
                uint64_t v35 = __p;
              }
              unint64_t v54 = v33;
              operator delete(v35);
            }
            uint64_t v16 = v51;
            if (!v51) {
              goto LABEL_96;
            }
            uint64_t v36 = v52;
            uint64_t v18 = v51;
            if (v52 == v51) {
              goto LABEL_95;
            }
            do
            {
              unsigned int v38 = (void *)*--v36;
              uint64_t v37 = v38;
              *uint64_t v36 = 0;
              if (v38) {
                operator delete[](v37);
              }
            }
            while (v36 != v16);
            goto LABEL_94;
          }
        }
      }
      else
      {
        v46[0] = (const void **)"requires attribute 'explicit_padding'";
        __int16 v47 = 259;
        mlir::OpState::emitOpError(this, v46, (uint64_t)v48);
        uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
        if (v48[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
        }
        if (v55)
        {
          uint64_t v27 = (void **)__p;
          if (__p)
          {
            uint64_t v28 = v54;
            uint64_t v29 = __p;
            if (v54 != __p)
            {
              do
                uint64_t v28 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v28 - 1);
              while (v28 != v27);
              uint64_t v29 = __p;
            }
            unint64_t v54 = v27;
            operator delete(v29);
          }
          uint64_t v16 = v51;
          if (!v51) {
            goto LABEL_96;
          }
          int v30 = v52;
          uint64_t v18 = v51;
          if (v52 == v51) {
            goto LABEL_95;
          }
          do
          {
            uint64_t v32 = (void *)*--v30;
            unsigned int v31 = v32;
            *int v30 = 0;
            if (v32) {
              operator delete[](v31);
            }
          }
          while (v30 != v16);
          goto LABEL_94;
        }
      }
    }
    else
    {
      v46[0] = (const void **)"requires attribute 'dilation_rates'";
      __int16 v47 = 259;
      mlir::OpState::emitOpError(this, v46, (uint64_t)v48);
      uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
      if (v48[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
      }
      if (v55)
      {
        uint64_t v21 = (void **)__p;
        if (__p)
        {
          uint64_t v22 = v54;
          uint64_t v23 = __p;
          if (v54 != __p)
          {
            do
              uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
            while (v22 != v21);
            uint64_t v23 = __p;
          }
          unint64_t v54 = v21;
          operator delete(v23);
        }
        uint64_t v16 = v51;
        if (!v51) {
          goto LABEL_96;
        }
        uint64_t v24 = v52;
        uint64_t v18 = v51;
        if (v52 == v51) {
          goto LABEL_95;
        }
        do
        {
          uint64_t v26 = (void *)*--v24;
          uint64_t v25 = v26;
          void *v24 = 0;
          if (v26) {
            operator delete[](v25);
          }
        }
        while (v24 != v16);
        goto LABEL_94;
      }
    }
  }
  else
  {
    v46[0] = (const void **)"requires attribute 'data_layout'";
    __int16 v47 = 259;
    mlir::OpState::emitOpError(this, v46, (uint64_t)v48);
    uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
    if (v48[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
    }
    if (v55)
    {
      uint64_t v13 = (void **)__p;
      if (__p)
      {
        unint64_t v14 = v54;
        uint64_t v15 = __p;
        if (v54 != __p)
        {
          do
            unint64_t v14 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v14 - 1);
          while (v14 != v13);
          uint64_t v15 = __p;
        }
        unint64_t v54 = v13;
        operator delete(v15);
      }
      uint64_t v16 = v51;
      if (!v51) {
        goto LABEL_96;
      }
      uint64_t v17 = v52;
      uint64_t v18 = v51;
      if (v52 == v51) {
        goto LABEL_95;
      }
      do
      {
        uint64_t v20 = (void *)*--v17;
        unsigned int v19 = v20;
        *uint64_t v17 = 0;
        if (v20) {
          operator delete[](v19);
        }
      }
      while (v17 != v16);
      goto LABEL_94;
    }
  }
  return v12;
}

uint64_t mlir::mps::DepthwiseConv2DDataGradientOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.depthwise_conv_2d_data_gradient", 35, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC982018;
  v4[12] = mlir::mps::DepthwiseConv2DDataGradientOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::DepthwiseConv2DOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    int v5 = (long long *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  }
  else {
    int v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v12, v7, v6);
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *v5;
  long long v9 = v5[1];
  *(_OWORD *)(a1 + 56) = v5[2];
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)v12;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.depthwise_conv_2d", 21, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::DepthwiseConv2DOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[4];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x79616C5F61746164 || *(void *)(__s1 + 3) != 0x74756F79616C5F61) {
        return 0;
      }
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[3];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n)) {
        return a2[1];
      }
      if (memcmp(__s1, "weights_layout", __n)) {
        return 0;
      }
      return a2[5];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::DepthwiseConv2DOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  uint64_t v7 = (void *)result;
  switch(__n)
  {
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v13 = a4;
          }
          else {
            uint64_t v13 = 0;
          }
          v7[4] = v13;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x79616C5F61746164 && *(void *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
            uint64_t v9 = a4;
          }
          else {
            uint64_t v9 = 0;
          }
          *(void *)uint64_t result = v9;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          v7[3] = v10;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "weights_layout", __n);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
              uint64_t v11 = a4;
            }
            else {
              uint64_t v11 = 0;
            }
            v7[5] = v11;
          }
          else
          {
            v7[5] = 0;
          }
        }
      }
      else if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
        if (result) {
          uint64_t v14 = a4;
        }
        else {
          uint64_t v14 = 0;
        }
        v7[1] = v14;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v12 = a4;
          }
          else {
            uint64_t v12 = 0;
          }
          v7[2] = v12;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::DepthwiseConv2DOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 5) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x30uLL);
    *uint64_t v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 116;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        long long v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[49];
    return a1[32];
  }
  return result;
}

void mlir::mps::DepthwiseConv2DOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unint64_t a10, unint64_t a11, unint64_t a12, unsigned int a13, unsigned int a14, unsigned int a15)
{
  v45[4] = *MEMORY[0x1E4F143B8];
  uint64_t v43 = v45;
  memset_pattern16(v45, &unk_1810FE350, 0x20uLL);
  uint64_t v44 = 0x400000004;
  int v40 = v42;
  memset_pattern16(v42, &unk_1810FE350, 0x20uLL);
  uint64_t v41 = 0x400000004;
  uint64_t v37 = v39;
  memset_pattern16(v39, &unk_1810FE350, 0x40uLL);
  uint64_t v38 = 0x800000008;
  mlir::mps::buildConv2DDescriptor(a3, a4, 1, a5, a6, a7, a8, a9, (uint64_t)v35, a10, a11, a12, a13, a14, a15, v45, (uint64_t)v42, (uint64_t)v39, 1);
  v35[0] = v36;
  v36[0] = xmmword_18110B5E0;
  v35[1] = (void *)0x200000002;
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  uint64_t v17 = (void *)mlir::RankedTensorType::get((uint64_t)v36, 2, IntegerType, 0);
  uint64_t v34 = 4;
  uint64_t v18 = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  unsigned int v19 = (void *)mlir::RankedTensorType::get((uint64_t)&v34, 1, v18, 0);
  uint64_t v20 = v19;
  if (v19) {
    uint64_t v21 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v19 + 8);
  }
  else {
    uint64_t v21 = 0;
  }
  uint64_t v22 = mlir::DenseElementsAttr::getFromRawBuffer(v20, v21, v43, 8 * v44, 8, 1, 0);
  if (v20) {
    uint64_t v23 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v20 + 8);
  }
  else {
    uint64_t v23 = 0;
  }
  uint64_t v24 = mlir::DenseElementsAttr::getFromRawBuffer(v20, v23, v40, 8 * v41, 8, 1, 0);
  if (v17) {
    uint64_t v25 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v17 + 8);
  }
  else {
    uint64_t v25 = 0;
  }
  uint64_t v26 = mlir::DenseElementsAttr::getFromRawBuffer(v17, v25, v37, 8 * v38, 8, 1, 0);
  mlir::mps::DepthwiseConv2DOp::build((mlir::MLIRContext **)a1, a2, a3, a4, v22, v24, v26, a13, a14, a15);
  if (v35[0] != v36) {
    free(v35[0]);
  }
  if (v37 != v39) {
    free(v37);
  }
  if (v40 != v42) {
    free(v40);
  }
  if (v43 != v45) {
    free(v43);
  }
}

void mlir::mps::DepthwiseConv2DOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8, unsigned int a9, unsigned int a10)
{
  unint64_t v42[2] = *MEMORY[0x1E4F143B8];
  uint64_t v35 = a4;
  uint64_t v36 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v36, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v35, 1);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties>((void *)a2)
            + 32) = a5;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = a6;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties>((void *)a2)
            + 16) = a7;
  uint64_t v16 = *a1;
  unsigned int v37 = a8;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v16);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  uint64_t v41 = (uint64_t)v16;
  uint64_t v18 = mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v37);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties>((void *)a2)
            + 24) = v18;
  unsigned int v19 = *a1;
  unsigned int v37 = a9;
  uint64_t v20 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v19);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  uint64_t v41 = (uint64_t)v19;
  uint64_t v21 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v20, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v37);
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties>((void *)a2) = v21;
  uint64_t v22 = *a1;
  unsigned int v37 = a10;
  uint64_t v23 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v22);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  uint64_t v41 = (uint64_t)v22;
  uint64_t v24 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v23, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v37);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties>((void *)a2)
            + 40) = v24;
  __src = v42;
  uint64_t v41 = 0x200000000;
  uint64_t v25 = *a1;
  uint64_t v26 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v39, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v29 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v38, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::DepthwiseConv2DOp::inferReturnTypes(v25, v26, 1, v39[0], v39[1], Dictionary, v29, v30, v38[0], v38[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  unsigned int v31 = __src;
  }
  uint64_t v32 = v41;
  uint64_t v33 = *(unsigned int *)(a2 + 72);
  unint64_t v34 = v33 + v41;
  if (v34 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v34, 8);
    LODWORD(v33) = *(_DWORD *)(a2 + 72);
  }
  if (v32)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v33), v31, 8 * v32);
    LODWORD(v33) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v33 + v32;
  if (__src != v42) {
    free(__src);
  }
}

BOOL mlir::mps::DepthwiseConv2DOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    uint64_t v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *v3;
  if (*v3)
  {
    int v5 = (const void **)v3[1];
    if (v5)
    {
      unint64_t v6 = (const void **)v3[2];
      if (v6)
      {
        uint64_t v7 = v3[3];
        if (v7)
        {
          long long v8 = (const void **)v3[4];
          if (v8)
          {
            uint64_t v9 = v3[5];
            if (v9)
            {
              v48[0] = v2;
              if (mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v8, (const void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48)&& (v48[0] = *this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))&& (v48[0] = *this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))
                && (v48[0] = *this,
                    mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v7, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))&& (v48[0] = *this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))&& (v48[0] = *this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v9, (const void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))
                && mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
              {
                if (*((_DWORD *)*this + 9)) {
                  uint64_t v10 = (uint64_t)(*this - 2);
                }
                else {
                  uint64_t v10 = 0;
                }
                uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 0);
                return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
              }
              else
              {
                return 0;
              }
            }
            else
            {
              v46[0] = (const void **)"requires attribute 'weights_layout'";
              __int16 v47 = 259;
              mlir::OpState::emitOpError(this, v46, (uint64_t)v48);
              uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
              mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v48);
            }
            return v12;
          }
          v46[0] = (const void **)"requires attribute 'strides'";
          __int16 v47 = 259;
          mlir::OpState::emitOpError(this, v46, (uint64_t)v48);
          uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
          if (v48[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
          }
          if (v55)
          {
            long long v39 = (void **)__p;
            if (__p)
            {
              int v40 = v54;
              uint64_t v41 = __p;
              if (v54 != __p)
              {
                do
                  int v40 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v40 - 1);
                while (v40 != v39);
                uint64_t v41 = __p;
              }
              unint64_t v54 = v39;
              operator delete(v41);
            }
            uint64_t v16 = v51;
            if (!v51) {
              goto LABEL_95;
            }
            uint64_t v42 = v52;
            uint64_t v18 = v51;
            if (v52 == v51)
            {
LABEL_94:
              uint64_t v52 = v16;
              operator delete(v18);
LABEL_95:
              if (v49 != &v50) {
                free(v49);
              }
              return v12;
            }
            do
            {
              uint64_t v44 = (void *)*--v42;
              uint64_t v43 = v44;
              void *v42 = 0;
              if (v44) {
                operator delete[](v43);
              }
            }
            while (v42 != v16);
LABEL_93:
            uint64_t v18 = v51;
            goto LABEL_94;
          }
        }
        else
        {
          v46[0] = (const void **)"requires attribute 'padding_style'";
          __int16 v47 = 259;
          mlir::OpState::emitOpError(this, v46, (uint64_t)v48);
          uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
          if (v48[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
          }
          if (v55)
          {
            uint64_t v33 = (void **)__p;
            if (__p)
            {
              unint64_t v34 = v54;
              uint64_t v35 = __p;
              if (v54 != __p)
              {
                do
                  unint64_t v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
                while (v34 != v33);
                uint64_t v35 = __p;
              }
              unint64_t v54 = v33;
              operator delete(v35);
            }
            uint64_t v16 = v51;
            if (!v51) {
              goto LABEL_95;
            }
            uint64_t v36 = v52;
            uint64_t v18 = v51;
            if (v52 == v51) {
              goto LABEL_94;
            }
            do
            {
              uint64_t v38 = (void *)*--v36;
              unsigned int v37 = v38;
              *uint64_t v36 = 0;
              if (v38) {
                operator delete[](v37);
              }
            }
            while (v36 != v16);
            goto LABEL_93;
          }
        }
      }
      else
      {
        v46[0] = (const void **)"requires attribute 'explicit_padding'";
        __int16 v47 = 259;
        mlir::OpState::emitOpError(this, v46, (uint64_t)v48);
        uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
        if (v48[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
        }
        if (v55)
        {
          uint64_t v27 = (void **)__p;
          if (__p)
          {
            uint64_t v28 = v54;
            uint64_t v29 = __p;
            if (v54 != __p)
            {
              do
                uint64_t v28 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v28 - 1);
              while (v28 != v27);
              uint64_t v29 = __p;
            }
            unint64_t v54 = v27;
            operator delete(v29);
          }
          uint64_t v16 = v51;
          if (!v51) {
            goto LABEL_95;
          }
          int v30 = v52;
          uint64_t v18 = v51;
          if (v52 == v51) {
            goto LABEL_94;
          }
          do
          {
            uint64_t v32 = (void *)*--v30;
            unsigned int v31 = v32;
            *int v30 = 0;
            if (v32) {
              operator delete[](v31);
            }
          }
          while (v30 != v16);
          goto LABEL_93;
        }
      }
    }
    else
    {
      v46[0] = (const void **)"requires attribute 'dilation_rates'";
      __int16 v47 = 259;
      mlir::OpState::emitOpError(this, v46, (uint64_t)v48);
      uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
      if (v48[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
      }
      if (v55)
      {
        uint64_t v21 = (void **)__p;
        if (__p)
        {
          uint64_t v22 = v54;
          uint64_t v23 = __p;
          if (v54 != __p)
          {
            do
              uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
            while (v22 != v21);
            uint64_t v23 = __p;
          }
          unint64_t v54 = v21;
          operator delete(v23);
        }
        uint64_t v16 = v51;
        if (!v51) {
          goto LABEL_95;
        }
        uint64_t v24 = v52;
        uint64_t v18 = v51;
        if (v52 == v51) {
          goto LABEL_94;
        }
        do
        {
          uint64_t v26 = (void *)*--v24;
          uint64_t v25 = v26;
          void *v24 = 0;
          if (v26) {
            operator delete[](v25);
          }
        }
        while (v24 != v16);
        goto LABEL_93;
      }
    }
  }
  else
  {
    v46[0] = (const void **)"requires attribute 'data_layout'";
    __int16 v47 = 259;
    mlir::OpState::emitOpError(this, v46, (uint64_t)v48);
    uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
    if (v48[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
    }
    if (v55)
    {
      uint64_t v13 = (void **)__p;
      if (__p)
      {
        unint64_t v14 = v54;
        uint64_t v15 = __p;
        if (v54 != __p)
        {
          do
            unint64_t v14 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v14 - 1);
          while (v14 != v13);
          uint64_t v15 = __p;
        }
        unint64_t v54 = v13;
        operator delete(v15);
      }
      uint64_t v16 = v51;
      if (!v51) {
        goto LABEL_95;
      }
      uint64_t v17 = v52;
      uint64_t v18 = v51;
      if (v52 == v51) {
        goto LABEL_94;
      }
      do
      {
        uint64_t v20 = (void *)*--v17;
        unsigned int v19 = v20;
        *uint64_t v17 = 0;
        if (v20) {
          operator delete[](v19);
        }
      }
      while (v17 != v16);
      goto LABEL_93;
    }
  }
  return v12;
}

uint64_t mlir::mps::DepthwiseConv2DOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.depthwise_conv_2d", 21, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC980F98;
  v4[12] = mlir::mps::DepthwiseConv2DOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::DepthwiseConv2DWeightsGradientOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[4];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x79616C5F61746164 || *(void *)(__s1 + 3) != 0x74756F79616C5F61) {
        return 0;
      }
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[3];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n)) {
        return a2[1];
      }
      if (memcmp(__s1, "weights_layout", __n)) {
        return 0;
      }
      return a2[5];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::DepthwiseConv2DWeightsGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  uint64_t v7 = (void *)result;
  switch(__n)
  {
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v13 = a4;
          }
          else {
            uint64_t v13 = 0;
          }
          v7[4] = v13;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x79616C5F61746164 && *(void *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
            uint64_t v9 = a4;
          }
          else {
            uint64_t v9 = 0;
          }
          *(void *)uint64_t result = v9;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          v7[3] = v10;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "weights_layout", __n);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
              uint64_t v11 = a4;
            }
            else {
              uint64_t v11 = 0;
            }
            v7[5] = v11;
          }
          else
          {
            v7[5] = 0;
          }
        }
      }
      else if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
        if (result) {
          uint64_t v14 = a4;
        }
        else {
          uint64_t v14 = 0;
        }
        v7[1] = v14;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v12 = a4;
          }
          else {
            uint64_t v12 = 0;
          }
          v7[2] = v12;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::DepthwiseConv2DWeightsGradientOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 5) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x30uLL);
    *uint64_t v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGeneri"
              "cAdaptorBase::Properties]";
        unint64_t v14 = 131;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        __int16 v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[51];
    return a1[32];
  }
  return result;
}

void mlir::mps::DepthwiseConv2DWeightsGradientOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, unsigned int a14, unsigned int a15, unsigned int a16)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  v36[0] = xmmword_181119FA8;
  v36[1] = unk_181119FB8;
  v35[0] = xmmword_181119FA8;
  v35[1] = unk_181119FB8;
  memset(v34, 0, sizeof(v34));
  uint64_t v18 = operator new(0x10uLL);
  _OWORD *v18 = xmmword_18110B5E0;
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  uint64_t v20 = (void *)mlir::RankedTensorType::get((uint64_t)v18, 2, IntegerType, 0);
  uint64_t v21 = operator new(8uLL);
  *uint64_t v21 = 4;
  uint64_t v22 = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  uint64_t v23 = (void *)mlir::RankedTensorType::get((uint64_t)v21, 1, v22, 0);
  uint64_t v24 = v23;
  if (v23) {
    uint64_t v25 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v23 + 8);
  }
  else {
    uint64_t v25 = 0;
  }
  uint64_t v26 = mlir::DenseElementsAttr::getFromRawBuffer(v24, v25, v36, 32, 8, 1, 0);
  if (v24) {
    uint64_t v27 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v24 + 8);
  }
  else {
    uint64_t v27 = 0;
  }
  uint64_t v28 = mlir::DenseElementsAttr::getFromRawBuffer(v24, v27, v35, 32, 8, 1, 0);
  if (v20) {
    uint64_t v29 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v20 + 8);
  }
  else {
    uint64_t v29 = 0;
  }
  uint64_t v30 = mlir::DenseElementsAttr::getFromRawBuffer(v20, v29, v34, 64, 8, 1, 0);
  mlir::mps::DepthwiseConv2DWeightsGradientOp::build((mlir::MLIRContext **)a1, a2, a3, a4, a5, v26, v28, v30, a14, a15, a16);
  operator delete(v21);
  operator delete(v18);
}

void mlir::mps::DepthwiseConv2DWeightsGradientOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, unsigned int a10, unsigned int a11)
{
  unint64_t v43[2] = *MEMORY[0x1E4F143B8];
  uint64_t v36 = a4;
  uint64_t v37 = a3;
  uint64_t v35 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v37, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v36, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v35, 1);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 32) = a6;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = a7;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 16) = a8;
  uint64_t v16 = *a1;
  unsigned int v38 = a9;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v16);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  uint64_t v42 = (uint64_t)v16;
  uint64_t v18 = mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v38);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 24) = v18;
  unsigned int v19 = *a1;
  unsigned int v38 = a10;
  uint64_t v20 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v19);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  uint64_t v42 = (uint64_t)v19;
  uint64_t v21 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v20, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v38);
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties>((void *)a2) = v21;
  uint64_t v22 = *a1;
  unsigned int v38 = a11;
  uint64_t v23 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v22);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  uint64_t v42 = (uint64_t)v22;
  uint64_t v24 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v23, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v38);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 40) = v24;
  __src = v43;
  uint64_t v42 = 0x200000000;
  uint64_t v25 = *a1;
  uint64_t v26 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v40, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v29 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v39, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::DepthwiseConv2DWeightsGradientOp::inferReturnTypes(v25, v26, 1, v40[0], v40[1], Dictionary, v29, v30, v39[0], v39[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  unsigned int v31 = __src;
  }
  uint64_t v32 = v42;
  uint64_t v33 = *(unsigned int *)(a2 + 72);
  unint64_t v34 = v33 + v42;
  if (v34 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v34, 8);
    LODWORD(v33) = *(_DWORD *)(a2 + 72);
  }
  if (v32)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v33), v31, 8 * v32);
    LODWORD(v33) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v33 + v32;
  if (__src != v43) {
    free(__src);
  }
}

uint64_t mlir::mps::DepthwiseConv2DWeightsGradientOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.depthwise_conv_2d_weights_gradient", 38, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC982120;
  v4[12] = mlir::mps::DepthwiseConv2DWeightsGradientOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::DepthwiseConv3DDataGradientOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v125 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v111 = v6;
  if (!v6)
  {
    a3(v115, a4);
    if (v115[0])
    {
      LODWORD(v112) = 3;
      unint64_t v113 = "expected DictionaryAttr to set properties";
      uint64_t v114 = 41;
      uint64_t v26 = &v112;
      uint64_t v27 = (char *)v116;
      if (v117 >= v118)
      {
        unint64_t v93 = v117 + 1;
        if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
        {
          int64_t v102 = (char *)&v112 - (unsigned char *)v116;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v93, 24);
          uint64_t v27 = (char *)v116;
          uint64_t v26 = (uint64_t *)((char *)v116 + v102);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v93, 24);
          uint64_t v26 = &v112;
          uint64_t v27 = (char *)v116;
        }
      }
      uint64_t v28 = &v27[24 * v117];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)uint64_t v28 = v29;
      ++v117;
      if (v115[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
      }
    }
    if (!v124) {
      return 0;
    }
    int v30 = (void **)__p;
    if (__p)
    {
      unsigned int v31 = v123;
      uint64_t v32 = __p;
      if (v123 != __p)
      {
        do
          unsigned int v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        uint64_t v32 = __p;
      }
      uint64_t v123 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v120;
    if (!v120) {
      goto LABEL_120;
    }
    uint64_t v33 = v121;
    uint64_t v23 = v120;
    if (v121 == v120)
    {
LABEL_119:
      char v121 = v21;
      operator delete(v23);
LABEL_120:
      if (v116 != v119) {
        free(v116);
      }
      return 0;
    }
    do
    {
      uint64_t v35 = (void *)*--v33;
      unint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
LABEL_118:
    uint64_t v23 = v120;
    goto LABEL_119;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v111, "channelAxis", 0xBuLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      a3(v115, a4);
      if (v115[0])
      {
        LODWORD(v112) = 3;
        uint64_t v114 = 56;
        uint64_t v10 = &v112;
        unint64_t v11 = (char *)v116;
        if (v117 >= v118)
        {
          unint64_t v94 = v117 + 1;
          if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
          {
            int64_t v103 = (char *)&v112 - (unsigned char *)v116;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v94, 24);
            unint64_t v11 = (char *)v116;
            uint64_t v10 = (uint64_t *)((char *)v116 + v103);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v94, 24);
            uint64_t v10 = &v112;
            unint64_t v11 = (char *)v116;
          }
        }
        uint64_t v12 = &v11[24 * v117];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = v10[2];
        *(_OWORD *)uint64_t v12 = v13;
        ++v117;
        if (v115[0])
        {
          unint64_t v14 = &v112;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v112, v9);
          uint64_t v15 = (char *)v116;
          if (v117 >= v118)
          {
            unint64_t v95 = v117 + 1;
            if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
            {
              int64_t v104 = (char *)&v112 - (unsigned char *)v116;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v95, 24);
              uint64_t v15 = (char *)v116;
              unint64_t v14 = (uint64_t *)((char *)v116 + v104);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v95, 24);
              unint64_t v14 = &v112;
              uint64_t v15 = (char *)v116;
            }
          }
          uint64_t v16 = &v15[24 * v117];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = v14[2];
          *(_OWORD *)uint64_t v16 = v17;
          ++v117;
          if (v115[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
          }
        }
      }
      if (!v124) {
        return 0;
      }
      uint64_t v18 = (void **)__p;
      if (__p)
      {
        unsigned int v19 = v123;
        uint64_t v20 = __p;
        if (v123 != __p)
        {
          do
            unsigned int v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          uint64_t v20 = __p;
        }
        uint64_t v123 = v18;
        operator delete(v20);
      }
      uint64_t v21 = v120;
      if (!v120) {
        goto LABEL_120;
      }
      uint64_t v22 = v121;
      uint64_t v23 = v120;
      if (v121 == v120) {
        goto LABEL_119;
      }
      do
      {
        uint64_t v25 = (void *)*--v22;
        uint64_t v24 = v25;
        *uint64_t v22 = 0;
        if (v25) {
          operator delete[](v24);
        }
      }
      while (v22 != v21);
      goto LABEL_118;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v111, "dilation_rates", 0xEuLL);
  if (!v36)
  {
    a3(v115, a4);
    if (v115[0])
    {
      LODWORD(v112) = 3;
      unint64_t v113 = "expected key entry for dilation_rates in DictionaryAttr to set Properties.";
      uint64_t v114 = 74;
      uint64_t v42 = &v112;
      uint64_t v43 = (char *)v116;
      if (v117 >= v118)
      {
        unint64_t v96 = v117 + 1;
        if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
        {
          int64_t v105 = (char *)&v112 - (unsigned char *)v116;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v96, 24);
          uint64_t v43 = (char *)v116;
          uint64_t v42 = (uint64_t *)((char *)v116 + v105);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v96, 24);
          uint64_t v42 = &v112;
          uint64_t v43 = (char *)v116;
        }
      }
      uint64_t v44 = &v43[24 * v117];
      long long v45 = *(_OWORD *)v42;
      *((void *)v44 + 2) = v42[2];
      *(_OWORD *)uint64_t v44 = v45;
      ++v117;
      if (v115[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
      }
    }
    if (!v124) {
      return 0;
    }
    uint64_t v46 = (void **)__p;
    if (__p)
    {
      __int16 v47 = v123;
      uint64_t v48 = __p;
      if (v123 != __p)
      {
        do
          __int16 v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        uint64_t v48 = __p;
      }
      uint64_t v123 = v46;
      operator delete(v48);
    }
    uint64_t v21 = v120;
    if (!v120) {
      goto LABEL_120;
    }
    uint64_t v49 = v121;
    uint64_t v23 = v120;
    if (v121 == v120) {
      goto LABEL_119;
    }
    do
    {
      uint64_t v51 = (void *)*--v49;
      uint64_t v50 = v51;
      void *v49 = 0;
      if (v51) {
        operator delete[](v50);
      }
    }
    while (v49 != v21);
    goto LABEL_118;
  }
  uint64_t v37 = v36;
  if ((mlir::DenseIntElementsAttr::classof(v36) & 1) == 0)
  {
    a3(v115, a4);
    if (v115[0])
    {
      LODWORD(v112) = 3;
      uint64_t v114 = 59;
      uint64_t v52 = &v112;
      unint64_t v53 = (char *)v116;
      if (v117 >= v118)
      {
        unint64_t v97 = v117 + 1;
        if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
        {
          int64_t v106 = (char *)&v112 - (unsigned char *)v116;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v97, 24);
          unint64_t v53 = (char *)v116;
          uint64_t v52 = (uint64_t *)((char *)v116 + v106);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v97, 24);
          uint64_t v52 = &v112;
          unint64_t v53 = (char *)v116;
        }
      }
      unint64_t v54 = &v53[24 * v117];
      long long v55 = *(_OWORD *)v52;
      *((void *)v54 + 2) = v52[2];
      *(_OWORD *)unint64_t v54 = v55;
      ++v117;
      if (v115[0])
      {
        uint64_t v56 = &v112;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v112, v37);
        unint64_t v57 = (char *)v116;
        if (v117 >= v118)
        {
          unint64_t v98 = v117 + 1;
          if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
          {
            int64_t v107 = (char *)&v112 - (unsigned char *)v116;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v98, 24);
            unint64_t v57 = (char *)v116;
            uint64_t v56 = (uint64_t *)((char *)v116 + v107);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v98, 24);
            uint64_t v56 = &v112;
            unint64_t v57 = (char *)v116;
          }
        }
        int64_t v58 = &v57[24 * v117];
        long long v59 = *(_OWORD *)v56;
        *((void *)v58 + 2) = v56[2];
        *(_OWORD *)int64_t v58 = v59;
        ++v117;
        if (v115[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
        }
      }
    }
    if (!v124) {
      return 0;
    }
    int64_t v60 = (void **)__p;
    if (__p)
    {
      int64_t v61 = v123;
      int64_t v62 = __p;
      if (v123 != __p)
      {
        do
          int64_t v61 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v61 - 1);
        while (v61 != v60);
        int64_t v62 = __p;
      }
      uint64_t v123 = v60;
      operator delete(v62);
    }
    uint64_t v21 = v120;
    if (!v120) {
      goto LABEL_120;
    }
    unint64_t v63 = v121;
    uint64_t v23 = v120;
    if (v121 == v120) {
      goto LABEL_119;
    }
    do
    {
      long long v65 = (void *)*--v63;
      unint64_t v64 = v65;
      void *v63 = 0;
      if (v65) {
        operator delete[](v64);
      }
    }
    while (v63 != v21);
    goto LABEL_118;
  }
  a1[1] = v37;
  uint64_t v38 = mlir::DictionaryAttr::get((uint64_t)&v111, "explicit_padding", 0x10uLL);
  if (!v38)
  {
    a3(v115, a4);
    if (v115[0])
    {
      LODWORD(v112) = 3;
      unint64_t v113 = "expected key entry for explicit_padding in DictionaryAttr to set Properties.";
      uint64_t v114 = 76;
      unint64_t v66 = &v112;
      unint64_t v67 = (char *)v116;
      if (v117 >= v118)
      {
        unint64_t v99 = v117 + 1;
        if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
        {
          int64_t v108 = (char *)&v112 - (unsigned char *)v116;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v99, 24);
          unint64_t v67 = (char *)v116;
          unint64_t v66 = (uint64_t *)((char *)v116 + v108);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v99, 24);
          unint64_t v66 = &v112;
          unint64_t v67 = (char *)v116;
        }
      }
      unint64_t v68 = &v67[24 * v117];
      long long v69 = *(_OWORD *)v66;
      *((void *)v68 + 2) = v66[2];
      *(_OWORD *)unint64_t v68 = v69;
      ++v117;
      if (v115[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
      }
    }
    if (!v124) {
      return 0;
    }
    int64_t v70 = (void **)__p;
    if (__p)
    {
      int64_t v71 = v123;
      int64_t v72 = __p;
      if (v123 != __p)
      {
        do
          int64_t v71 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v71 - 1);
        while (v71 != v70);
        int64_t v72 = __p;
      }
      uint64_t v123 = v70;
      operator delete(v72);
    }
    uint64_t v21 = v120;
    if (!v120) {
      goto LABEL_120;
    }
    int64_t v73 = v121;
    uint64_t v23 = v120;
    if (v121 == v120) {
      goto LABEL_119;
    }
    do
    {
      uint64_t v75 = (void *)*--v73;
      int64_t v74 = v75;
      *int64_t v73 = 0;
      if (v75) {
        operator delete[](v74);
      }
    }
    while (v73 != v21);
    goto LABEL_118;
  }
  uint64_t v39 = v38;
  if ((mlir::DenseIntElementsAttr::classof(v38) & 1) == 0)
  {
    a3(v115, a4);
    if (v115[0])
    {
      LODWORD(v112) = 3;
      uint64_t v114 = 61;
      int v76 = &v112;
      uint64_t v77 = (char *)v116;
      if (v117 >= v118)
      {
        unint64_t v100 = v117 + 1;
        if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
        {
          int64_t v109 = (char *)&v112 - (unsigned char *)v116;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v100, 24);
          uint64_t v77 = (char *)v116;
          int v76 = (uint64_t *)((char *)v116 + v109);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v100, 24);
          int v76 = &v112;
          uint64_t v77 = (char *)v116;
        }
      }
      uint64_t v78 = &v77[24 * v117];
      long long v79 = *(_OWORD *)v76;
      *((void *)v78 + 2) = v76[2];
      *(_OWORD *)uint64_t v78 = v79;
      ++v117;
      if (v115[0])
      {
        char v80 = &v112;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v112, v39);
        unsigned int v81 = (char *)v116;
        if (v117 >= v118)
        {
          unint64_t v101 = v117 + 1;
          if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
          {
            int64_t v110 = (char *)&v112 - (unsigned char *)v116;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v101, 24);
            unsigned int v81 = (char *)v116;
            char v80 = (uint64_t *)((char *)v116 + v110);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v101, 24);
            char v80 = &v112;
            unsigned int v81 = (char *)v116;
          }
        }
        unsigned int v82 = &v81[24 * v117];
        long long v83 = *(_OWORD *)v80;
        *((void *)v82 + 2) = v80[2];
        *(_OWORD *)unsigned int v82 = v83;
        ++v117;
        if (v115[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
        }
      }
    }
    if (!v124) {
      return 0;
    }
    uint64_t v84 = (void **)__p;
    if (__p)
    {
      int64_t v85 = v123;
      int64_t v86 = __p;
      if (v123 != __p)
      {
        do
          int64_t v85 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v85 - 1);
        while (v85 != v84);
        int64_t v86 = __p;
      }
      uint64_t v123 = v84;
      operator delete(v86);
    }
    uint64_t v21 = v120;
    if (!v120) {
      goto LABEL_120;
    }
    uint64_t v87 = v121;
    uint64_t v23 = v120;
    if (v121 == v120) {
      goto LABEL_119;
    }
    do
    {
      uint64_t v89 = (void *)*--v87;
      uint64_t v88 = v89;
      *uint64_t v87 = 0;
      if (v89) {
        operator delete[](v88);
      }
    }
    while (v87 != v21);
    goto LABEL_118;
  }
  a1[2] = v39;
  uint64_t v40 = mlir::DictionaryAttr::get((uint64_t)&v111, "padding_style", 0xDuLL);
  uint64_t v112 = v40;
  if (v40)
  {
    if (*(_UNKNOWN **)(*(void *)v40 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
    {
      a1[3] = v40;
      uint64_t v91 = mlir::DictionaryAttr::get((uint64_t)&v111, "strides", 7uLL);
      uint64_t v112 = v91;
      if (!v91)
      {
        a3(v115, a4);
        mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v115, "expected key entry for strides in DictionaryAttr to set Properties.");
        goto LABEL_125;
      }
      uint64_t v92 = v91;
      if (mlir::DenseIntElementsAttr::classof(v91))
      {
        a1[4] = v92;
        return 1;
      }
      a3(v115, a4);
    }
    else
    {
      a3(v115, a4);
    }
    mlir::InFlightDiagnostic::append<mlir::Attribute>(v41, &v112);
  }
  else
  {
    a3(v115, a4);
    mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v115, "expected key entry for padding_style in DictionaryAttr to set Properties.");
  }
LABEL_125:
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v115);
  return 0;
}

uint64_t mlir::mps::DepthwiseConv3DDataGradientOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v39[6] = *MEMORY[0x1E4F143B8];
  uint64_t v36 = a1;
  uint64_t v37 = v39;
  uint64_t v38 = 0x300000000;
  if (!*a2)
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v36, (uint64_t)"channelAxis", 11, *a2);
  uint64_t v5 = v4;
  unsigned int v6 = v38;
  if (v38 >= HIDWORD(v38))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
    unsigned int v6 = v38;
  }
  unint64_t v7 = (uint64_t *)((char *)v37 + 16 * v6);
  uint64_t *v7 = NamedAttr;
  v7[1] = v5;
  unsigned int v8 = v38 + 1;
  LODWORD(v38) = v38 + 1;
  uint64_t v9 = a2[1];
  if (v9)
  {
LABEL_7:
    uint64_t v10 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"dilation_rates", 14, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      unsigned int v13 = v38;
    }
    unint64_t v14 = (uint64_t *)((char *)v37 + 16 * v13);
    *unint64_t v14 = v10;
    v14[1] = v12;
    unsigned int v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
LABEL_10:
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"explicit_padding", 16, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      unsigned int v19 = v38;
    }
    uint64_t v20 = (uint64_t *)((char *)v37 + 16 * v19);
    *uint64_t v20 = v16;
    v20[1] = v18;
    unsigned int v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  uint64_t v21 = a2[3];
  if (v21)
  {
    uint64_t v22 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"padding_style", 13, v21);
    uint64_t v24 = v23;
    unsigned int v25 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      unsigned int v25 = v38;
    }
    uint64_t v26 = (uint64_t *)((char *)v37 + 16 * v25);
    *uint64_t v26 = v22;
    v26[1] = v24;
    unsigned int v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  uint64_t v27 = a2[4];
  if (v27)
  {
    uint64_t v28 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"strides", 7, v27);
    uint64_t v30 = v29;
    unsigned int v31 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      unsigned int v31 = v38;
    }
    uint64_t v32 = (uint64_t *)((char *)v37 + 16 * v31);
    *uint64_t v32 = v28;
    v32[1] = v30;
    unsigned int v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  uint64_t v33 = v37;
  if (!v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v37 == v39) {
      return DictionaryAttr;
    }
    goto LABEL_24;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v36, (uint64_t *)v37, v8);
  uint64_t v33 = v37;
  if (v37 != v39) {
LABEL_24:
  }
    free(v33);
  return DictionaryAttr;
}

uint64_t mlir::mps::DepthwiseConv3DDataGradientOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[4];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x416C656E6E616863 || *(void *)(__s1 + 3) != 0x736978416C656E6ELL) {
        return 0;
      }
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[3];
    case 0xEuLL:
      if (memcmp(__s1, "dilation_rates", __n)) {
        return 0;
      }
      return a2[1];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::DepthwiseConv3DDataGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t a3, uint64_t a4)
{
  uint64_t v5 = (void *)result;
  switch(a3)
  {
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v5[4] = v11;
        }
        else
        {
          v5[4] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x416C656E6E616863 && *(void *)(__s1 + 3) == 0x736978416C656E6ELL)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
            uint64_t v7 = a4;
          }
          else {
            uint64_t v7 = 0;
          }
          *(void *)uint64_t result = v7;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          v5[3] = v8;
        }
        else
        {
          v5[3] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v9 = a4;
          }
          else {
            uint64_t v9 = 0;
          }
          v5[1] = v9;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          void v5[2] = v10;
        }
        else
        {
          void v5[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::DepthwiseConv3DDataGradientOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (*a2) {
    mlir::NamedAttrList::append(a3, (uint64_t)"channelAxis", 11, *a2);
  }
  uint64_t v5 = a2[1];
  if (v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"dilation_rates", 14, v5);
  }
  uint64_t v6 = a2[2];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"explicit_padding", 16, v6);
  }
  uint64_t v7 = a2[3];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"padding_style", 13, v7);
  }
  uint64_t v8 = a2[4];
  if (v8)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"strides", 7, v8);
  }
}

BOOL mlir::mps::DepthwiseConv3DDataGradientOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = (const void **)mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(v8, (const void **)"channelAxis", (const char *)0xB, a3, a4))
  {
    uint64_t v9 = (const void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(v9, (const void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))a3, a4))
    {
      uint64_t v10 = (const void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps25(v10, (const void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))a3, a4))
      {
        uint64_t v11 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 24));
        if (!v11
          || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v11, (const void **)"padding_style", (const char *)0xD, a3, a4))
        {
          uint64_t v12 = (const void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(v12, (const void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))a3, a4))
          {
            return 1;
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(const void **a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 1;
  }
  if (*((_UNKNOWN **)*a1 + 17) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    unsigned int v31 = a1;
    uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v31);
    if (mlir::Type::isSignedInteger((mlir::Type *)&Value, 32)) {
      return 1;
    }
  }
  a4(&Value, a5);
  if (Value)
  {
    LODWORD(v31) = 3;
    uint64_t v32 = "attribute '";
    uint64_t v33 = 11;
    uint64_t v10 = &v31;
    uint64_t v11 = (char *)v37;
    if (v38 >= v39)
    {
      unint64_t v27 = v38 + 1;
      if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
      {
        int64_t v29 = (char *)&v31 - (unsigned char *)v37;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        uint64_t v11 = (char *)v37;
        uint64_t v10 = (const void ***)((char *)v37 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        uint64_t v10 = &v31;
        uint64_t v11 = (char *)v37;
      }
    }
    uint64_t v12 = &v11[24 * v38];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = v10[2];
    *(_OWORD *)uint64_t v12 = v13;
    ++v38;
    if (Value)
    {
      __int16 v34 = 261;
      unsigned int v31 = a2;
      uint64_t v32 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v36, &v31);
      if (Value)
      {
        LODWORD(v31) = 3;
        uint64_t v32 = "' failed to satisfy constraint: 32-bit signed integer attribute";
        uint64_t v33 = 63;
        unint64_t v14 = &v31;
        uint64_t v15 = (char *)v37;
        if (v38 >= v39)
        {
          unint64_t v28 = v38 + 1;
          if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
          {
            int64_t v30 = (char *)&v31 - (unsigned char *)v37;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            uint64_t v15 = (char *)v37;
            unint64_t v14 = (const void ***)((char *)v37 + v30);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            unint64_t v14 = &v31;
            uint64_t v15 = (char *)v37;
          }
        }
        uint64_t v16 = &v15[24 * v38];
        long long v17 = *(_OWORD *)v14;
        *((void *)v16 + 2) = v14[2];
        *(_OWORD *)uint64_t v16 = v17;
        ++v38;
      }
    }
  }
  uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  }
  if (v45)
  {
    uint64_t v18 = (void **)__p;
    if (__p)
    {
      unsigned int v19 = v44;
      uint64_t v20 = __p;
      if (v44 != __p)
      {
        do
          unsigned int v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        uint64_t v20 = __p;
      }
      uint64_t v44 = v18;
      operator delete(v20);
    }
    uint64_t v21 = v41;
    if (v41)
    {
      uint64_t v22 = v42;
      uint64_t v23 = v41;
      if (v42 != v41)
      {
        do
        {
          unsigned int v25 = (void *)*--v22;
          uint64_t v24 = v25;
          *uint64_t v22 = 0;
          if (v25) {
            operator delete[](v24);
          }
        }
        while (v22 != v21);
        uint64_t v23 = v41;
      }
      uint64_t v42 = v21;
      operator delete(v23);
    }
    if (v37 != v40) {
      free(v37);
    }
  }
  return v9;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(const void **a1, const void **a2, const char *a3, void (*a4)(void **__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 1;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1)) {
    goto LABEL_9;
  }
  uint64_t v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>((uint64_t)*a1 + 8);
  uint64_t v41 = a1;
  uint64_t v42 = (const char *)v10;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v41);
  uint64_t v12 = Type;
  if (Type) {
    Type = (void *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  }
  char v45 = v12;
  uint64_t v46 = Type;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v45);
  uint64_t v56 = 3;
  if (v14 == 1 && *ArgAttrsAttr == v56)
  {
    unsigned int v38 = a1;
    v39[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v38);
    v39[1] = v15;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v39);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
  }
LABEL_9:
  a4(&v45, a5);
  if (v45)
  {
    LODWORD(v41) = 3;
    uint64_t v42 = "attribute '";
    uint64_t v43 = 11;
    long long v17 = &v41;
    uint64_t v18 = (char *)v47;
    if (v48 >= v49)
    {
      unint64_t v34 = v48 + 1;
      if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
      {
        int64_t v36 = (char *)&v41 - (unsigned char *)v47;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        uint64_t v18 = (char *)v47;
        long long v17 = (const void ***)((char *)v47 + v36);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        long long v17 = &v41;
        uint64_t v18 = (char *)v47;
      }
    }
    unsigned int v19 = &v18[24 * v48];
    long long v20 = *(_OWORD *)v17;
    *((void *)v19 + 2) = v17[2];
    *(_OWORD *)unsigned int v19 = v20;
    ++v48;
    if (v45)
    {
      __int16 v44 = 261;
      uint64_t v41 = a2;
      uint64_t v42 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v46, &v41);
      if (v45)
      {
        LODWORD(v41) = 3;
        uint64_t v42 = "' failed to satisfy constraint: ui64 elements attribute of shape {3}";
        uint64_t v43 = 68;
        uint64_t v21 = &v41;
        uint64_t v22 = (char *)v47;
        if (v48 >= v49)
        {
          unint64_t v35 = v48 + 1;
          if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
          {
            int64_t v37 = (char *)&v41 - (unsigned char *)v47;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            uint64_t v22 = (char *)v47;
            uint64_t v21 = (const void ***)((char *)v47 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            uint64_t v21 = &v41;
            uint64_t v22 = (char *)v47;
          }
        }
        uint64_t v23 = &v22[24 * v48];
        long long v24 = *(_OWORD *)v21;
        *((void *)v23 + 2) = v21[2];
        *(_OWORD *)uint64_t v23 = v24;
        ++v48;
      }
    }
  }
  uint64_t v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v45);
  if (v45) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v45);
  }
  if (v55)
  {
    unsigned int v25 = (void **)__p;
    if (__p)
    {
      uint64_t v26 = v54;
      unint64_t v27 = __p;
      if (v54 != __p)
      {
        do
          uint64_t v26 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v26 - 1);
        while (v26 != v25);
        unint64_t v27 = __p;
      }
      unint64_t v54 = v25;
      operator delete(v27);
    }
    unint64_t v28 = v51;
    if (v51)
    {
      int64_t v29 = v52;
      int64_t v30 = v51;
      if (v52 != v51)
      {
        do
        {
          uint64_t v32 = (void *)*--v29;
          unsigned int v31 = v32;
          void *v29 = 0;
          if (v32) {
            operator delete[](v31);
          }
        }
        while (v29 != v28);
        int64_t v30 = v51;
      }
      uint64_t v52 = v28;
      operator delete(v30);
    }
    if (v47 != v50) {
      free(v47);
    }
  }
  return v16;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps25(const void **a1, const void **a2, const char *a3, void (*a4)(void **__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 1;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1)) {
    goto LABEL_9;
  }
  uint64_t v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>((uint64_t)*a1 + 8);
  uint64_t v41 = a1;
  uint64_t v42 = (const char *)v10;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v41);
  uint64_t v12 = Type;
  if (Type) {
    Type = (void *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  }
  char v45 = v12;
  uint64_t v46 = Type;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v45);
  uint64_t v56 = 6;
  if (v14 == 1 && *ArgAttrsAttr == v56)
  {
    unsigned int v38 = a1;
    v39[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v38);
    v39[1] = v15;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v39);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
  }
LABEL_9:
  a4(&v45, a5);
  if (v45)
  {
    LODWORD(v41) = 3;
    uint64_t v42 = "attribute '";
    uint64_t v43 = 11;
    long long v17 = &v41;
    uint64_t v18 = (char *)v47;
    if (v48 >= v49)
    {
      unint64_t v34 = v48 + 1;
      if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
      {
        int64_t v36 = (char *)&v41 - (unsigned char *)v47;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        uint64_t v18 = (char *)v47;
        long long v17 = (const void ***)((char *)v47 + v36);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        long long v17 = &v41;
        uint64_t v18 = (char *)v47;
      }
    }
    unsigned int v19 = &v18[24 * v48];
    long long v20 = *(_OWORD *)v17;
    *((void *)v19 + 2) = v17[2];
    *(_OWORD *)unsigned int v19 = v20;
    ++v48;
    if (v45)
    {
      __int16 v44 = 261;
      uint64_t v41 = a2;
      uint64_t v42 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v46, &v41);
      if (v45)
      {
        LODWORD(v41) = 3;
        uint64_t v42 = "' failed to satisfy constraint: ui64 elements attribute of shape {6}";
        uint64_t v43 = 68;
        uint64_t v21 = &v41;
        uint64_t v22 = (char *)v47;
        if (v48 >= v49)
        {
          unint64_t v35 = v48 + 1;
          if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
          {
            int64_t v37 = (char *)&v41 - (unsigned char *)v47;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            uint64_t v22 = (char *)v47;
            uint64_t v21 = (const void ***)((char *)v47 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            uint64_t v21 = &v41;
            uint64_t v22 = (char *)v47;
          }
        }
        uint64_t v23 = &v22[24 * v48];
        long long v24 = *(_OWORD *)v21;
        *((void *)v23 + 2) = v21[2];
        *(_OWORD *)uint64_t v23 = v24;
        ++v48;
      }
    }
  }
  uint64_t v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v45);
  if (v45) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v45);
  }
  if (v55)
  {
    unsigned int v25 = (void **)__p;
    if (__p)
    {
      uint64_t v26 = v54;
      unint64_t v27 = __p;
      if (v54 != __p)
      {
        do
          uint64_t v26 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v26 - 1);
        while (v26 != v25);
        unint64_t v27 = __p;
      }
      unint64_t v54 = v25;
      operator delete(v27);
    }
    unint64_t v28 = v51;
    if (v51)
    {
      int64_t v29 = v52;
      int64_t v30 = v51;
      if (v52 != v51)
      {
        do
        {
          uint64_t v32 = (void *)*--v29;
          unsigned int v31 = v32;
          void *v29 = 0;
          if (v32) {
            operator delete[](v31);
          }
        }
        while (v29 != v28);
        int64_t v30 = v51;
      }
      uint64_t v52 = v28;
      operator delete(v30);
    }
    if (v47 != v50) {
      free(v47);
    }
  }
  return v16;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x28uLL);
    *uint64_t v3 = 0u;
    v3[1] = 0u;
    *((void *)v3 + 4) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAd"
              "aptorBase::Properties]";
        unint64_t v14 = 128;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[53];
    return a1[32];
  }
  return result;
}

uint64_t mlir::mps::DepthwiseConv3DDataGradientOp::getChannelAxis(mlir::mps::DepthwiseConv3DDataGradientOp *this)
{
  uint64_t v5 = *(void *)(*(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64);
  mlir::IntegerAttr::getValue(&v5, (llvm::APInt *)&__p);
  if (v4 <= 0x40) {
    return (uint64_t)((void)__p << -(uint64_t)v4) >> -(uint64_t)v4;
  }
  uint64_t v2 = *(void *)__p;
  operator delete[](__p);
  return v2;
}

void mlir::mps::DepthwiseConv3DDataGradientOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, int a10)
{
  void v39[2] = *MEMORY[0x1E4F143B8];
  uint64_t v32 = a4;
  uint64_t v33 = a3;
  uint64_t v31 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v33, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v32, 1);
  if (a5) {
    mlir::OperationState::addOperands(a2, (uint64_t)&v31, 1);
  }
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 32) = a6;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = a7;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 16) = a8;
  uint64_t v16 = *(mlir::MLIRContext **)a1;
  unsigned int v34 = a9;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v16);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  uint64_t v38 = (uint64_t)v16;
  uint64_t v18 = mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v34);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 24) = v18;
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x20u, 1);
  uint64_t IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a10);
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAdaptorBase::Properties>((void *)a2) = IntegerAttr;
  __src = v39;
  uint64_t v38 = 0x200000000;
  uint64_t v21 = *(mlir::UnknownLoc **)a1;
  uint64_t v22 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v36, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  unsigned int v25 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v35, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::DepthwiseConv3DDataGradientOp::inferReturnTypes(v21, v22, 1, v36[0], v36[1], Dictionary, v25, v26, v35[0], v35[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  unint64_t v27 = __src;
  }
  uint64_t v28 = v38;
  uint64_t v29 = *(unsigned int *)(a2 + 72);
  unint64_t v30 = v29 + v38;
  if (v30 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v30, 8);
    LODWORD(v29) = *(_DWORD *)(a2 + 72);
  }
  if (v28)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v29), v27, 8 * v28);
    LODWORD(v29) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v29 + v28;
  if (__src != v39) {
    free(__src);
  }
}

BOOL mlir::mps::DepthwiseConv3DDataGradientOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    unint64_t v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    unint64_t v3 = 0;
  }
  unsigned int v4 = *(const void ***)(v3 + 8);
  if (!v4)
  {
    v57[0] = (const void **)"requires attribute 'dilation_rates'";
    __int16 v58 = 259;
    mlir::OpState::emitOpError(this, v57, (uint64_t)v59);
    uint64_t v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v59);
    if (v59[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
    if (!v66) {
      return v25;
    }
    int v26 = (void **)__p;
    if (__p)
    {
      unint64_t v27 = v65;
      uint64_t v28 = __p;
      if (v65 != __p)
      {
        do
          unint64_t v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
        while (v27 != v26);
        uint64_t v28 = __p;
      }
      long long v65 = v26;
      operator delete(v28);
    }
    uint64_t v29 = v62;
    if (v62)
    {
      unint64_t v30 = v63;
      uint64_t v31 = v62;
      if (v63 == v62) {
        goto LABEL_78;
      }
      do
      {
        uint64_t v33 = (void *)*--v30;
        uint64_t v32 = v33;
        *unint64_t v30 = 0;
        if (v33) {
          operator delete[](v32);
        }
      }
      while (v30 != v29);
LABEL_77:
      uint64_t v31 = v62;
LABEL_78:
      unint64_t v63 = v29;
      operator delete(v31);
    }
LABEL_79:
    if (v60 != &v61) {
      free(v60);
    }
    return v25;
  }
  uint64_t v5 = *(const void ***)(v3 + 16);
  if (!v5)
  {
    v57[0] = (const void **)"requires attribute 'explicit_padding'";
    __int16 v58 = 259;
    mlir::OpState::emitOpError(this, v57, (uint64_t)v59);
    uint64_t v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v59);
    if (v59[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
    if (!v66) {
      return v25;
    }
    unsigned int v34 = (void **)__p;
    if (__p)
    {
      unint64_t v35 = v65;
      int64_t v36 = __p;
      if (v65 != __p)
      {
        do
          unint64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        int64_t v36 = __p;
      }
      long long v65 = v34;
      operator delete(v36);
    }
    uint64_t v29 = v62;
    if (v62)
    {
      int64_t v37 = v63;
      uint64_t v31 = v62;
      if (v63 == v62) {
        goto LABEL_78;
      }
      do
      {
        unsigned int v39 = (void *)*--v37;
        uint64_t v38 = v39;
        *int64_t v37 = 0;
        if (v39) {
          operator delete[](v38);
        }
      }
      while (v37 != v29);
      goto LABEL_77;
    }
    goto LABEL_79;
  }
  uint64_t v6 = *(void *)(v3 + 24);
  if (!v6)
  {
    v57[0] = (const void **)"requires attribute 'padding_style'";
    __int16 v58 = 259;
    mlir::OpState::emitOpError(this, v57, (uint64_t)v59);
    uint64_t v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v59);
    if (v59[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
    if (!v66) {
      return v25;
    }
    uint64_t v40 = (void **)__p;
    if (__p)
    {
      uint64_t v41 = v65;
      uint64_t v42 = __p;
      if (v65 != __p)
      {
        do
          uint64_t v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        uint64_t v42 = __p;
      }
      long long v65 = v40;
      operator delete(v42);
    }
    uint64_t v29 = v62;
    if (v62)
    {
      uint64_t v43 = v63;
      uint64_t v31 = v62;
      if (v63 == v62) {
        goto LABEL_78;
      }
      do
      {
        char v45 = (void *)*--v43;
        __int16 v44 = v45;
        void *v43 = 0;
        if (v45) {
          operator delete[](v44);
        }
      }
      while (v43 != v29);
      goto LABEL_77;
    }
    goto LABEL_79;
  }
  unint64_t v7 = *(const void ***)(v3 + 32);
  if (!v7)
  {
    v57[0] = (const void **)"requires attribute 'strides'";
    __int16 v58 = 259;
    mlir::OpState::emitOpError(this, v57, (uint64_t)v59);
    uint64_t v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v59);
    if (v59[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
    if (!v66) {
      return v25;
    }
    uint64_t v46 = (void **)__p;
    if (__p)
    {
      __int16 v47 = v65;
      unsigned int v48 = __p;
      if (v65 != __p)
      {
        do
          __int16 v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        unsigned int v48 = __p;
      }
      long long v65 = v46;
      operator delete(v48);
    }
    uint64_t v29 = v62;
    if (v62)
    {
      unsigned int v49 = v63;
      uint64_t v31 = v62;
      if (v63 == v62) {
        goto LABEL_78;
      }
      do
      {
        uint64_t v51 = (void *)*--v49;
        uint64_t v50 = v51;
        void *v49 = 0;
        if (v51) {
          operator delete[](v50);
        }
      }
      while (v49 != v29);
      goto LABEL_77;
    }
    goto LABEL_79;
  }
  uint64_t v8 = *(const void ***)v3;
  v59[0] = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(v7, (const void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v59))return 0; {
  v59[0] = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(v4, (const void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v59))return 0; {
  v59[0] = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps25(v5, (const void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps25(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v59))return 0; {
  v59[0] = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v6, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v59))return 0; {
  v59[0] = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(v8, (const void **)"channelAxis", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v59))return 0; {
  unint64_t v9 = *this;
  }
  unint64_t v10 = *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  unsigned int v56 = 1;
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v9, v10, (const void **)"operand", (const void **)7, 0))return 0; {
  unsigned int v11 = 1;
  }
  uint64_t ODSOperands = mlir::tensor::UnPackOp::getODSOperands((mlir::tensor::UnPackOp *)this, 1u);
  if (v13)
  {
    uint64_t v14 = v13;
    uint64_t v15 = 0;
    uint64_t v16 = ODSOperands + 24;
    while (1)
    {
      long long v17 = *this;
      unint64_t v18 = *(void *)(*(void *)v16 + 8) & 0xFFFFFFFFFFFFFFF8;
      unsigned int v56 = v15 + 2;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v17, v18, (const void **)"operand", (const void **)7, (int)v15 + 1))return 0; {
      ++v15;
      }
      v16 += 32;
      if (v14 == v15)
      {
        unsigned int v11 = v15 + 1;
        break;
      }
    }
  }
  uint64_t v19 = mlir::tensor::UnPackOp::getODSOperands((mlir::tensor::UnPackOp *)this, 2u);
  uint64_t v21 = v20;
  if (v20 >= 2)
  {
    v57[0] = (const void **)"operand group starting at #";
    __int16 v58 = 259;
    mlir::OpState::emitOpError(this, v57, (uint64_t)v59);
    uint64_t v22 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v59, &v56);
    uint64_t v23 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v22, " requires 0 or 1 element, but found ");
    uint64_t v55 = v21;
    uint64_t v24 = mlir::InFlightDiagnostic::operator<<<unsigned long &>(v23, &v55);
    uint64_t v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v24);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v59);
    return v25;
  }
  if (v20
    && !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)(v19 + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v11))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v52 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v52 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v52, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::DepthwiseConv3DDataGradientOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  unsigned int v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.depthwise_conv_3d_data_gradient", 35, v2, v3, 0, 0);
  *unsigned int v4 = &unk_1EC982070;
  v4[12] = mlir::mps::DepthwiseConv3DDataGradientOp::canonicalize;
  unint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::DepthwiseConv3DOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v12, v7, v6);
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *(_OWORD *)v5;
  long long v9 = *(_OWORD *)(v5 + 16);
  *(void *)(a1 + 56) = *(void *)(v5 + 32);
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)v12;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.depthwise_conv_3d", 21, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::DepthwiseConv3DOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[4];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x416C656E6E616863 || *(void *)(__s1 + 3) != 0x736978416C656E6ELL) {
        return 0;
      }
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[3];
    case 0xEuLL:
      if (memcmp(__s1, "dilation_rates", __n)) {
        return 0;
      }
      return a2[1];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::DepthwiseConv3DOp::setInherentAttr(uint64_t result, char *__s1, size_t a3, uint64_t a4)
{
  uint64_t v5 = (void *)result;
  switch(a3)
  {
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v5[4] = v11;
        }
        else
        {
          v5[4] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x416C656E6E616863 && *(void *)(__s1 + 3) == 0x736978416C656E6ELL)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
            uint64_t v7 = a4;
          }
          else {
            uint64_t v7 = 0;
          }
          *(void *)uint64_t result = v7;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          v5[3] = v8;
        }
        else
        {
          v5[3] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v9 = a4;
          }
          else {
            uint64_t v9 = 0;
          }
          v5[1] = v9;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          void v5[2] = v10;
        }
        else
        {
          void v5[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x28uLL);
    *uint64_t v3 = 0u;
    v3[1] = 0u;
    *((void *)v3 + 4) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 116;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[55];
    return a1[32];
  }
  return result;
}

void mlir::mps::DepthwiseConv3DOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8, int a9)
{
  unint64_t v38[2] = *MEMORY[0x1E4F143B8];
  uint64_t v31 = a4;
  uint64_t v32 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v32, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v31, 1);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties>((void *)a2)
            + 32) = a5;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = a6;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties>((void *)a2)
            + 16) = a7;
  uint64_t v15 = *(mlir::MLIRContext **)a1;
  unsigned int v33 = a8;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v15);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  uint64_t v37 = (uint64_t)v15;
  uint64_t v17 = mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v33);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties>((void *)a2)
            + 24) = v17;
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x20u, 1);
  uint64_t IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a9);
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties>((void *)a2) = IntegerAttr;
  __src = v38;
  uint64_t v37 = 0x200000000;
  unint64_t v20 = *(mlir::UnknownLoc **)a1;
  mlir::ValueRange::ValueRange(v35, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v23 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v34, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::DepthwiseConv3DOp::inferReturnTypes(v20, v24, v25, v35[0], v35[1], Dictionary, v23, v26, v34[0], v34[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  unint64_t v27 = __src;
  }
  uint64_t v28 = v37;
  uint64_t v29 = *(unsigned int *)(a2 + 72);
  unint64_t v30 = v29 + v37;
  if (v30 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v30, 8);
    LODWORD(v29) = *(_DWORD *)(a2 + 72);
  }
  if (v28)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v29), v27, 8 * v28);
    LODWORD(v29) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v29 + v28;
  if (__src != v38) {
    free(__src);
  }
}

BOOL mlir::mps::DepthwiseConv3DOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    unint64_t v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    unint64_t v3 = 0;
  }
  unint64_t v4 = *(const void ***)(v3 + 8);
  if (v4)
  {
    int v5 = *(const void ***)(v3 + 16);
    if (v5)
    {
      uint64_t v6 = *(void *)(v3 + 24);
      if (v6)
      {
        unint64_t v7 = *(const void ***)(v3 + 32);
        if (v7)
        {
          uint64_t v8 = *(const void ***)v3;
          v41[0] = v2;
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(v7, (const void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0; {
          v41[0] = *this;
          }
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(v4, (const void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0; {
          v41[0] = *this;
          }
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps25(v5, (const void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps25(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0; {
          v41[0] = *this;
          }
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v6, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0; {
          v41[0] = *this;
          }
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(v8, (const void **)"channelAxis", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
          {
            return 0;
          }
          if (*((_DWORD *)*this + 9)) {
            uint64_t v9 = (uint64_t)(*this - 2);
          }
          else {
            uint64_t v9 = 0;
          }
          uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v9, 0);
          return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
        }
        v39[0] = (const void **)"requires attribute 'strides'";
        __int16 v40 = 259;
        mlir::OpState::emitOpError(this, v39, (uint64_t)v41);
        uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
        if (v41[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
        }
        if (v48)
        {
          uint64_t v32 = (void **)__p;
          if (__p)
          {
            unsigned int v33 = v47;
            unsigned int v34 = __p;
            if (v47 != __p)
            {
              do
                unsigned int v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
              while (v33 != v32);
              unsigned int v34 = __p;
            }
            __int16 v47 = v32;
            operator delete(v34);
          }
          uint64_t v15 = v44;
          if (!v44) {
            goto LABEL_78;
          }
          unint64_t v35 = v45;
          uint64_t v17 = v44;
          if (v45 == v44)
          {
LABEL_77:
            char v45 = v15;
            operator delete(v17);
LABEL_78:
            if (v42 != &v43) {
              free(v42);
            }
            return v11;
          }
          do
          {
            uint64_t v37 = (void *)*--v35;
            int64_t v36 = v37;
            *unint64_t v35 = 0;
            if (v37) {
              operator delete[](v36);
            }
          }
          while (v35 != v15);
LABEL_76:
          uint64_t v17 = v44;
          goto LABEL_77;
        }
      }
      else
      {
        v39[0] = (const void **)"requires attribute 'padding_style'";
        __int16 v40 = 259;
        mlir::OpState::emitOpError(this, v39, (uint64_t)v41);
        uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
        if (v41[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
        }
        if (v48)
        {
          int v26 = (void **)__p;
          if (__p)
          {
            unint64_t v27 = v47;
            uint64_t v28 = __p;
            if (v47 != __p)
            {
              do
                unint64_t v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
              while (v27 != v26);
              uint64_t v28 = __p;
            }
            __int16 v47 = v26;
            operator delete(v28);
          }
          uint64_t v15 = v44;
          if (!v44) {
            goto LABEL_78;
          }
          uint64_t v29 = v45;
          uint64_t v17 = v44;
          if (v45 == v44) {
            goto LABEL_77;
          }
          do
          {
            uint64_t v31 = (void *)*--v29;
            unint64_t v30 = v31;
            void *v29 = 0;
            if (v31) {
              operator delete[](v30);
            }
          }
          while (v29 != v15);
          goto LABEL_76;
        }
      }
    }
    else
    {
      v39[0] = (const void **)"requires attribute 'explicit_padding'";
      __int16 v40 = 259;
      mlir::OpState::emitOpError(this, v39, (uint64_t)v41);
      uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
      if (v41[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
      }
      if (v48)
      {
        unint64_t v20 = (void **)__p;
        if (__p)
        {
          uint64_t v21 = v47;
          uint64_t v22 = __p;
          if (v47 != __p)
          {
            do
              uint64_t v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
            while (v21 != v20);
            uint64_t v22 = __p;
          }
          __int16 v47 = v20;
          operator delete(v22);
        }
        uint64_t v15 = v44;
        if (!v44) {
          goto LABEL_78;
        }
        uint64_t v23 = v45;
        uint64_t v17 = v44;
        if (v45 == v44) {
          goto LABEL_77;
        }
        do
        {
          int v25 = (void *)*--v23;
          uint64_t v24 = v25;
          *uint64_t v23 = 0;
          if (v25) {
            operator delete[](v24);
          }
        }
        while (v23 != v15);
        goto LABEL_76;
      }
    }
  }
  else
  {
    v39[0] = (const void **)"requires attribute 'dilation_rates'";
    __int16 v40 = 259;
    mlir::OpState::emitOpError(this, v39, (uint64_t)v41);
    uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
    if (v41[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
    }
    if (v48)
    {
      uint64_t v12 = (void **)__p;
      if (__p)
      {
        uint64_t v13 = v47;
        unint64_t v14 = __p;
        if (v47 != __p)
        {
          do
            uint64_t v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
          while (v13 != v12);
          unint64_t v14 = __p;
        }
        __int16 v47 = v12;
        operator delete(v14);
      }
      uint64_t v15 = v44;
      if (!v44) {
        goto LABEL_78;
      }
      uint64_t v16 = v45;
      uint64_t v17 = v44;
      if (v45 == v44) {
        goto LABEL_77;
      }
      do
      {
        uint64_t v19 = (void *)*--v16;
        unint64_t v18 = v19;
        void *v16 = 0;
        if (v19) {
          operator delete[](v18);
        }
      }
      while (v16 != v15);
      goto LABEL_76;
    }
  }
  return v11;
}

uint64_t mlir::mps::DepthwiseConv3DOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  unint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.depthwise_conv_3d", 21, v2, v3, 0, 0);
  *unint64_t v4 = &unk_1EC980FF0;
  v4[12] = mlir::mps::DepthwiseConv3DOp::canonicalize;
  uint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::DepthwiseConv3DWeightsGradientOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[4];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x416C656E6E616863 || *(void *)(__s1 + 3) != 0x736978416C656E6ELL) {
        return 0;
      }
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[3];
    case 0xEuLL:
      if (memcmp(__s1, "dilation_rates", __n)) {
        return 0;
      }
      return a2[1];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::DepthwiseConv3DWeightsGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t a3, uint64_t a4)
{
  int v5 = (void *)result;
  switch(a3)
  {
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v5[4] = v11;
        }
        else
        {
          v5[4] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x416C656E6E616863 && *(void *)(__s1 + 3) == 0x736978416C656E6ELL)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
            uint64_t v7 = a4;
          }
          else {
            uint64_t v7 = 0;
          }
          *(void *)uint64_t result = v7;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          v5[3] = v8;
        }
        else
        {
          v5[3] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v9 = a4;
          }
          else {
            uint64_t v9 = 0;
          }
          v5[1] = v9;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          void v5[2] = v10;
        }
        else
        {
          void v5[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x28uLL);
    *uint64_t v3 = 0u;
    v3[1] = 0u;
    *((void *)v3 + 4) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGeneri"
              "cAdaptorBase::Properties]";
        unint64_t v14 = 131;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[57];
    return a1[32];
  }
  return result;
}

void mlir::mps::DepthwiseConv3DWeightsGradientOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, int a10)
{
  unint64_t v40[2] = *MEMORY[0x1E4F143B8];
  uint64_t v33 = a4;
  uint64_t v34 = a3;
  uint64_t v32 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v34, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v33, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v32, 1);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 32) = a6;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = a7;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 16) = a8;
  uint64_t v15 = *(mlir::MLIRContext **)a1;
  unsigned int v35 = a9;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v15);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  uint64_t v39 = (uint64_t)v15;
  uint64_t v17 = mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v35);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 24) = v17;
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x20u, 1);
  uint64_t IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a10);
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGenericAdaptorBase::Properties>((void *)a2) = IntegerAttr;
  __src = v40;
  uint64_t v39 = 0x200000000;
  uint64_t v20 = *(void *)a2;
  mlir::ValueRange::ValueRange(v37, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v22 = mlir::ValueRange::ValueRange(&v36, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::DepthwiseConv3DWeightsGradientOp::inferReturnTypes((uint64_t)v22, v20, 1, v37[0], v37[1], v23, v24, v25, v30, v31, (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  int v26 = __src;
  }
  uint64_t v27 = v39;
  uint64_t v28 = *(unsigned int *)(a2 + 72);
  unint64_t v29 = v28 + v39;
  if (v29 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v29, 8);
    LODWORD(v28) = *(_DWORD *)(a2 + 72);
  }
  if (v27)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v28), v26, 8 * v27);
    LODWORD(v28) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v28 + v27;
  if (__src != v40) {
    free(__src);
  }
}

BOOL mlir::mps::DepthwiseConv3DWeightsGradientOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    unint64_t v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    unint64_t v3 = 0;
  }
  unint64_t v4 = *(const void ***)(v3 + 8);
  if (v4)
  {
    int v5 = *(const void ***)(v3 + 16);
    if (v5)
    {
      uint64_t v6 = *(void *)(v3 + 24);
      if (v6)
      {
        unint64_t v7 = *(const void ***)(v3 + 32);
        if (v7)
        {
          uint64_t v8 = *(const void ***)v3;
          v41[0] = v2;
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(v7, (const void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0; {
          v41[0] = *this;
          }
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(v4, (const void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0; {
          v41[0] = *this;
          }
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps25(v5, (const void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps25(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0; {
          v41[0] = *this;
          }
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v6, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0; {
          v41[0] = *this;
          }
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(v8, (const void **)"channelAxis", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this,
                                   *(void *)(*(void *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8,
                                   (const void **)"operand",
                                   (const void **)7,
                                   2u))
          {
            return 0;
          }
          if (*((_DWORD *)*this + 9)) {
            uint64_t v9 = (uint64_t)(*this - 2);
          }
          else {
            uint64_t v9 = 0;
          }
          uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v9, 0);
          return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
        }
        v39[0] = (const void **)"requires attribute 'strides'";
        __int16 v40 = 259;
        mlir::OpState::emitOpError(this, v39, (uint64_t)v41);
        uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
        if (v41[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
        }
        if (v48)
        {
          uint64_t v32 = (void **)__p;
          if (__p)
          {
            uint64_t v33 = v47;
            uint64_t v34 = __p;
            if (v47 != __p)
            {
              do
                uint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
              while (v33 != v32);
              uint64_t v34 = __p;
            }
            __int16 v47 = v32;
            operator delete(v34);
          }
          uint64_t v15 = v44;
          if (!v44) {
            goto LABEL_79;
          }
          unsigned int v35 = v45;
          uint64_t v17 = v44;
          if (v45 == v44)
          {
LABEL_78:
            char v45 = v15;
            operator delete(v17);
LABEL_79:
            if (v42 != &v43) {
              free(v42);
            }
            return v11;
          }
          do
          {
            uint64_t v37 = (void *)*--v35;
            unint64_t v36 = v37;
            *unsigned int v35 = 0;
            if (v37) {
              operator delete[](v36);
            }
          }
          while (v35 != v15);
LABEL_77:
          uint64_t v17 = v44;
          goto LABEL_78;
        }
      }
      else
      {
        v39[0] = (const void **)"requires attribute 'padding_style'";
        __int16 v40 = 259;
        mlir::OpState::emitOpError(this, v39, (uint64_t)v41);
        uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
        if (v41[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
        }
        if (v48)
        {
          int v26 = (void **)__p;
          if (__p)
          {
            uint64_t v27 = v47;
            uint64_t v28 = __p;
            if (v47 != __p)
            {
              do
                uint64_t v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
              while (v27 != v26);
              uint64_t v28 = __p;
            }
            __int16 v47 = v26;
            operator delete(v28);
          }
          uint64_t v15 = v44;
          if (!v44) {
            goto LABEL_79;
          }
          unint64_t v29 = v45;
          uint64_t v17 = v44;
          if (v45 == v44) {
            goto LABEL_78;
          }
          do
          {
            uint64_t v31 = (void *)*--v29;
            uint64_t v30 = v31;
            void *v29 = 0;
            if (v31) {
              operator delete[](v30);
            }
          }
          while (v29 != v15);
          goto LABEL_77;
        }
      }
    }
    else
    {
      v39[0] = (const void **)"requires attribute 'explicit_padding'";
      __int16 v40 = 259;
      mlir::OpState::emitOpError(this, v39, (uint64_t)v41);
      uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
      if (v41[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
      }
      if (v48)
      {
        uint64_t v20 = (void **)__p;
        if (__p)
        {
          uint64_t v21 = v47;
          uint64_t v22 = __p;
          if (v47 != __p)
          {
            do
              uint64_t v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
            while (v21 != v20);
            uint64_t v22 = __p;
          }
          __int16 v47 = v20;
          operator delete(v22);
        }
        uint64_t v15 = v44;
        if (!v44) {
          goto LABEL_79;
        }
        uint64_t v23 = v45;
        uint64_t v17 = v44;
        if (v45 == v44) {
          goto LABEL_78;
        }
        do
        {
          uint64_t v25 = (void *)*--v23;
          uint64_t v24 = v25;
          *uint64_t v23 = 0;
          if (v25) {
            operator delete[](v24);
          }
        }
        while (v23 != v15);
        goto LABEL_77;
      }
    }
  }
  else
  {
    v39[0] = (const void **)"requires attribute 'dilation_rates'";
    __int16 v40 = 259;
    mlir::OpState::emitOpError(this, v39, (uint64_t)v41);
    uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
    if (v41[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
    }
    if (v48)
    {
      uint64_t v12 = (void **)__p;
      if (__p)
      {
        uint64_t v13 = v47;
        unint64_t v14 = __p;
        if (v47 != __p)
        {
          do
            uint64_t v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
          while (v13 != v12);
          unint64_t v14 = __p;
        }
        __int16 v47 = v12;
        operator delete(v14);
      }
      uint64_t v15 = v44;
      if (!v44) {
        goto LABEL_79;
      }
      uint64_t v16 = v45;
      uint64_t v17 = v44;
      if (v45 == v44) {
        goto LABEL_78;
      }
      do
      {
        uint64_t v19 = (void *)*--v16;
        unint64_t v18 = v19;
        void *v16 = 0;
        if (v19) {
          operator delete[](v18);
        }
      }
      while (v16 != v15);
      goto LABEL_77;
    }
  }
  return v11;
}

uint64_t mlir::mps::DepthwiseConv3DWeightsGradientOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  unint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.depthwise_conv_3d_weights_gradient", 38, v2, v3, 0, 0);
  *unint64_t v4 = &unk_1EC982178;
  v4[12] = mlir::mps::DepthwiseConv3DWeightsGradientOp::canonicalize;
  uint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::DequantizeLUTOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  int v5 = (void *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.dequantize_lut", 18, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::DequantizeLUTOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      int v44 = 3;
      char v45 = "expected DictionaryAttr to set properties";
      uint64_t v46 = 41;
      int v26 = &v44;
      uint64_t v27 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v40 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          uint64_t v27 = (char *)v48;
          int v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          int v26 = &v44;
          uint64_t v27 = (char *)v48;
        }
      }
      uint64_t v28 = &v27[24 * v49];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)uint64_t v28 = v29;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
    if (!v56) {
      return 0;
    }
    uint64_t v30 = (void **)__p;
    if (__p)
    {
      uint64_t v31 = v55;
      uint64_t v32 = __p;
      if (v55 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        uint64_t v32 = __p;
      }
      uint64_t v55 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v52;
    if (!v52) {
      goto LABEL_43;
    }
    uint64_t v33 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      unsigned int v35 = (void *)*--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "axis", 4uLL);
  if (!v8) {
    return 1;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    int v44 = 3;
    uint64_t v46 = 49;
    uint64_t v10 = &v44;
    uint64_t v11 = (char *)v48;
    if (v49 >= v50)
    {
      unint64_t v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        int64_t v41 = (char *)&v44 - (unsigned char *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v11 = (char *)v48;
        uint64_t v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v10 = &v44;
        uint64_t v11 = (char *)v48;
      }
    }
    uint64_t v12 = &v11[24 * v49];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = *((void *)v10 + 2);
    *(_OWORD *)uint64_t v12 = v13;
    ++v49;
    if (v47[0])
    {
      unint64_t v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      uint64_t v15 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v42 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v15 = (char *)v48;
          unint64_t v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          unint64_t v14 = &v44;
          uint64_t v15 = (char *)v48;
        }
      }
      uint64_t v16 = &v15[24 * v49];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = *((void *)v14 + 2);
      *(_OWORD *)uint64_t v16 = v17;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
  }
  if (!v56) {
    return 0;
  }
  unint64_t v18 = (void **)__p;
  if (__p)
  {
    uint64_t v19 = v55;
    uint64_t v20 = __p;
    if (v55 != __p)
    {
      do
        uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      uint64_t v20 = __p;
    }
    uint64_t v55 = v18;
    operator delete(v20);
  }
  uint64_t v21 = v52;
  if (v52)
  {
    uint64_t v22 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v25 = (void *)*--v22;
      uint64_t v24 = v25;
      *uint64_t v22 = 0;
      if (v25) {
        operator delete[](v24);
      }
    }
    while (v22 != v21);
LABEL_41:
    uint64_t v23 = v52;
LABEL_42:
    unint64_t v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51) {
    free(v48);
  }
  return 0;
}

uint64_t mlir::mps::DequantizeLUTOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v15[6] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a1;
  long long v13 = v15;
  uint64_t v14 = 0x300000000;
  if (!*a2) {
    return 0;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"axis", 4, *a2);
  uint64_t v4 = v3;
  unsigned int v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    unsigned int v5 = v14;
  }
  uint64_t v6 = (uint64_t *)((char *)v13 + 16 * v5);
  uint64_t *v6 = NamedAttr;
  v6[1] = v4;
  uint64_t v7 = v13;
  BOOL v8 = __CFADD__(v14, 1);
  uint64_t v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v13 == v15) {
      return DictionaryAttr;
    }
    goto LABEL_10;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (uint64_t *)v13, v9);
  uint64_t v7 = v13;
  if (v13 != v15) {
LABEL_10:
  }
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    *uint64_t v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 114;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        BOOL v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[59];
    return a1[32];
  }
  return result;
}

void mlir::mps::DequantizeLUTOp::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v24[2] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a4;
  uint64_t v19 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v19, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v18, 1);
  if (a5) {
    *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::Properties>((void *)a2) = a5;
  }
  __src = v24;
  uint64_t v23 = 0x200000000;
  BOOL v8 = *a1;
  unint64_t v9 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v21, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v12 = *(uint64_t **)(a2 + 256);
  mlir::ValueRange::ValueRange(v20, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::DequantizeLUTOp::inferReturnTypes(v8, v9, 1, v21[0], v21[1], Dictionary, v12, v13, v20[0], v20[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  unint64_t v14 = __src;
  }
  uint64_t v15 = v23;
  uint64_t v16 = *(unsigned int *)(a2 + 72);
  unint64_t v17 = v16 + v23;
  if (v17 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v17, 8);
    LODWORD(v16) = *(_DWORD *)(a2 + 72);
  }
  if (v15)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v16), v14, 8 * v15);
    LODWORD(v16) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v16 + v15;
  if (__src != v24) {
    free(__src);
  }
}

BOOL mlir::mps::DequantizeLUTOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  uint64_t v3 = (const void **)(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  v54[0] = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(v3, (const void **)"axis", (const char *)4, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v54))return 0; {
  uint64_t v4 = *this;
  }
  unint64_t v5 = *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  unint64_t v6 = *(void **)(*(void *)v5 + 136);
  BOOL v7 = v6 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v6 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id;
  if (!v7
    || (uint64_t v8 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(void *)v5 + 8),
        v54[0] = v5,
        v54[1] = v8,
        v49[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v54),
        !mlir::Type::isUnsignedInteger((mlir::Type *)v49, 2))
    && !mlir::Type::isUnsignedInteger((mlir::Type *)v49, 4)
    && !mlir::Type::isUnsignedInteger((mlir::Type *)v49, 8))
  {
    __int16 v50 = 261;
    v49[0] = (const void **)"operand";
    v49[1] = (const void **)7;
    mlir::Operation::emitOpError(v4, v49, (uint64_t)v54);
    if (v54[0])
    {
      int v51 = 3;
      uint64_t v52 = " #";
      uint64_t v53 = 2;
      unint64_t v9 = &v51;
      uint64_t v10 = (char *)v55;
      if (v56 >= v57)
      {
        unint64_t v39 = v56 + 1;
        if (v55 <= &v51 && (char *)v55 + 24 * v56 > (char *)&v51)
        {
          int64_t v45 = (char *)&v51 - (unsigned char *)v55;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v39, 24);
          uint64_t v10 = (char *)v55;
          unint64_t v9 = (int *)((char *)v55 + v45);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v39, 24);
          unint64_t v9 = &v51;
          uint64_t v10 = (char *)v55;
        }
      }
      unint64_t v11 = &v10[24 * v56];
      long long v12 = *(_OWORD *)v9;
      *((void *)v11 + 2) = *((void *)v9 + 2);
      *(_OWORD *)unint64_t v11 = v12;
      uint64_t v13 = ++v56;
      if (v54[0])
      {
        int v51 = 5;
        uint64_t v52 = 0;
        unint64_t v14 = &v51;
        uint64_t v15 = (char *)v55;
        if (v13 >= v57)
        {
          unint64_t v40 = v13 + 1;
          BOOL v41 = (char *)v55 + 24 * v13 > (char *)&v51;
          if (v55 <= &v51 && v41)
          {
            int64_t v46 = (char *)&v51 - (unsigned char *)v55;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v40, 24);
            uint64_t v15 = (char *)v55;
            unint64_t v14 = (int *)((char *)v55 + v46);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v40, 24);
            unint64_t v14 = &v51;
            uint64_t v15 = (char *)v55;
          }
        }
        uint64_t v16 = &v15[24 * v56];
        long long v17 = *(_OWORD *)v14;
        *((void *)v16 + 2) = *((void *)v14 + 2);
        *(_OWORD *)uint64_t v16 = v17;
        uint64_t v18 = ++v56;
        if (v54[0])
        {
          int v51 = 3;
          uint64_t v52 = " must be tensor of palette LUT index values, but got ";
          uint64_t v53 = 53;
          uint64_t v19 = &v51;
          uint64_t v20 = (char *)v55;
          if (v18 >= v57)
          {
            unint64_t v42 = v18 + 1;
            BOOL v43 = (char *)v55 + 24 * v18 > (char *)&v51;
            if (v55 <= &v51 && v43)
            {
              int64_t v47 = (char *)&v51 - (unsigned char *)v55;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v42, 24);
              uint64_t v20 = (char *)v55;
              uint64_t v19 = (int *)((char *)v55 + v47);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v42, 24);
              uint64_t v19 = &v51;
              uint64_t v20 = (char *)v55;
            }
          }
          uint64_t v21 = &v20[24 * v56];
          long long v22 = *(_OWORD *)v19;
          *((void *)v21 + 2) = *((void *)v19 + 2);
          *(_OWORD *)uint64_t v21 = v22;
          ++v56;
          if (v54[0])
          {
            uint64_t v23 = &v51;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v51, v5);
            uint64_t v24 = (char *)v55;
            if (v56 >= v57)
            {
              unint64_t v44 = v56 + 1;
              if (v55 <= &v51 && (char *)v55 + 24 * v56 > (char *)&v51)
              {
                int64_t v48 = (char *)&v51 - (unsigned char *)v55;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v44, 24);
                uint64_t v24 = (char *)v55;
                uint64_t v23 = (int *)((char *)v55 + v48);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v44, 24);
                uint64_t v23 = &v51;
                uint64_t v24 = (char *)v55;
              }
            }
            uint64_t v25 = &v24[24 * v56];
            long long v26 = *(_OWORD *)v23;
            *((void *)v25 + 2) = *((void *)v23 + 2);
            *(_OWORD *)uint64_t v25 = v26;
            ++v56;
          }
        }
      }
    }
    char v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v54);
    if (v54[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v54);
    }
    if (v63)
    {
      uint64_t v28 = (void **)__p;
      if (__p)
      {
        long long v29 = v62;
        uint64_t v30 = __p;
        if (v62 != __p)
        {
          do
            long long v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
          while (v29 != v28);
          uint64_t v30 = __p;
        }
        int64_t v62 = v28;
        operator delete(v30);
      }
      uint64_t v31 = v59;
      if (v59)
      {
        uint64_t v32 = v60;
        uint64_t v33 = v59;
        if (v60 != v59)
        {
          do
          {
            unsigned int v35 = (void *)*--v32;
            uint64_t v34 = v35;
            *uint64_t v32 = 0;
            if (v35) {
              operator delete[](v34);
            }
          }
          while (v32 != v31);
          uint64_t v33 = v59;
        }
        int64_t v60 = v31;
        operator delete(v33);
      }
      if (v55 != v58) {
        free(v55);
      }
    }
    if (!v27) {
      return 0;
    }
  }
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps5(*this, *(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))return 0; {
  if (*((_DWORD *)*this + 9))
  }
    uint64_t v36 = (uint64_t)(*this - 2);
  else {
    uint64_t v36 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v36, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps5(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::DequantizeLUTOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.dequantize_lut", 18, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC980860;
  v4[12] = mlir::mps::DequantizeLUTOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    BOOL v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::DequantizeOpGenericAdaptorBase::DequantizeOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v5 = (_OWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  }
  else {
    unint64_t v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v11, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *(_OWORD *)v11;
  *(_OWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 40) = v8;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.dequantize", 14, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::DequantizeOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v89 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v75 = v6;
  if (!v6)
  {
    a3(v79, a4);
    if (v79[0])
    {
      int v76 = 3;
      uint64_t v77 = "expected DictionaryAttr to set properties";
      uint64_t v78 = 41;
      long long v26 = &v76;
      char v27 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v63 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v69 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          char v27 = (char *)v80;
          long long v26 = (int *)((char *)v80 + v69);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          long long v26 = &v76;
          char v27 = (char *)v80;
        }
      }
      uint64_t v28 = &v27[24 * v81];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)uint64_t v28 = v29;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
    if (!v88) {
      return 0;
    }
    uint64_t v30 = (void **)__p;
    if (__p)
    {
      uint64_t v31 = v87;
      uint64_t v32 = __p;
      if (v87 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        uint64_t v32 = __p;
      }
      uint64_t v87 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v84;
    if (!v84) {
      goto LABEL_80;
    }
    uint64_t v33 = v85;
    uint64_t v23 = v84;
    if (v85 == v84) {
      goto LABEL_79;
    }
    do
    {
      unsigned int v35 = (void *)*--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
    goto LABEL_78;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v75, "axis", 4uLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      a3(v79, a4);
      if (v79[0])
      {
        int v76 = 3;
        uint64_t v78 = 49;
        uint64_t v10 = &v76;
        unint64_t v11 = (char *)v80;
        if (v81 >= v82)
        {
          unint64_t v64 = v81 + 1;
          if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
          {
            int64_t v70 = (char *)&v76 - (unsigned char *)v80;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            unint64_t v11 = (char *)v80;
            uint64_t v10 = (int *)((char *)v80 + v70);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            uint64_t v10 = &v76;
            unint64_t v11 = (char *)v80;
          }
        }
        uint64_t v12 = &v11[24 * v81];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = *((void *)v10 + 2);
        *(_OWORD *)uint64_t v12 = v13;
        ++v81;
        if (v79[0])
        {
          unint64_t v14 = &v76;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v9);
          uint64_t v15 = (char *)v80;
          if (v81 >= v82)
          {
            unint64_t v65 = v81 + 1;
            if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
            {
              int64_t v71 = (char *)&v76 - (unsigned char *)v80;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              uint64_t v15 = (char *)v80;
              unint64_t v14 = (int *)((char *)v80 + v71);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              unint64_t v14 = &v76;
              uint64_t v15 = (char *)v80;
            }
          }
          uint64_t v16 = &v15[24 * v81];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = *((void *)v14 + 2);
          *(_OWORD *)uint64_t v16 = v17;
          ++v81;
          if (v79[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
          }
        }
      }
      if (!v88) {
        return 0;
      }
      uint64_t v18 = (void **)__p;
      if (__p)
      {
        uint64_t v19 = v87;
        uint64_t v20 = __p;
        if (v87 != __p)
        {
          do
            uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          uint64_t v20 = __p;
        }
        uint64_t v87 = v18;
        operator delete(v20);
      }
      uint64_t v21 = v84;
      if (!v84) {
        goto LABEL_80;
      }
      long long v22 = v85;
      uint64_t v23 = v84;
      if (v85 == v84) {
        goto LABEL_79;
      }
      do
      {
        uint64_t v25 = (void *)*--v22;
        uint64_t v24 = v25;
        *long long v22 = 0;
        if (v25) {
          operator delete[](v24);
        }
      }
      while (v22 != v21);
      goto LABEL_78;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v75, "dtype", 5uLL);
  if (!v36)
  {
    a3(v79, a4);
    if (v79[0])
    {
      int v76 = 3;
      uint64_t v77 = "expected key entry for dtype in DictionaryAttr to set Properties.";
      uint64_t v78 = 65;
      uint64_t v52 = &v76;
      uint64_t v53 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v67 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v73 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          uint64_t v53 = (char *)v80;
          uint64_t v52 = (int *)((char *)v80 + v73);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          uint64_t v52 = &v76;
          uint64_t v53 = (char *)v80;
        }
      }
      unint64_t v54 = &v53[24 * v81];
      long long v55 = *(_OWORD *)v52;
      *((void *)v54 + 2) = *((void *)v52 + 2);
      *(_OWORD *)unint64_t v54 = v55;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
    if (!v88) {
      return 0;
    }
    unsigned int v56 = (void **)__p;
    if (__p)
    {
      unsigned int v57 = v87;
      __int16 v58 = __p;
      if (v87 != __p)
      {
        do
          unsigned int v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        __int16 v58 = __p;
      }
      uint64_t v87 = v56;
      operator delete(v58);
    }
    uint64_t v21 = v84;
    if (!v84) {
      goto LABEL_80;
    }
    long long v59 = v85;
    uint64_t v23 = v84;
    if (v85 == v84) {
      goto LABEL_79;
    }
    do
    {
      uint64_t v61 = (void *)*--v59;
      int64_t v60 = v61;
      void *v59 = 0;
      if (v61) {
        operator delete[](v60);
      }
    }
    while (v59 != v21);
    goto LABEL_78;
  }
  uint64_t v37 = v36;
  if (*(_UNKNOWN **)(*(void *)v36 + 136) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
  {
    a1[1] = v36;
    return 1;
  }
  a3(v79, a4);
  if (v79[0])
  {
    int v76 = 3;
    uint64_t v78 = 50;
    unint64_t v38 = &v76;
    unint64_t v39 = (char *)v80;
    if (v81 >= v82)
    {
      unint64_t v66 = v81 + 1;
      if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
      {
        int64_t v72 = (char *)&v76 - (unsigned char *)v80;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        unint64_t v39 = (char *)v80;
        unint64_t v38 = (int *)((char *)v80 + v72);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        unint64_t v38 = &v76;
        unint64_t v39 = (char *)v80;
      }
    }
    unint64_t v40 = &v39[24 * v81];
    long long v41 = *(_OWORD *)v38;
    *((void *)v40 + 2) = *((void *)v38 + 2);
    *(_OWORD *)unint64_t v40 = v41;
    ++v81;
    if (v79[0])
    {
      unint64_t v42 = &v76;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v37);
      BOOL v43 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v68 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v74 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          BOOL v43 = (char *)v80;
          unint64_t v42 = (int *)((char *)v80 + v74);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          unint64_t v42 = &v76;
          BOOL v43 = (char *)v80;
        }
      }
      unint64_t v44 = &v43[24 * v81];
      long long v45 = *(_OWORD *)v42;
      *((void *)v44 + 2) = *((void *)v42 + 2);
      *(_OWORD *)unint64_t v44 = v45;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
  }
  if (v88)
  {
    int64_t v46 = (void **)__p;
    if (__p)
    {
      int64_t v47 = v87;
      int64_t v48 = __p;
      if (v87 != __p)
      {
        do
          int64_t v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        int64_t v48 = __p;
      }
      uint64_t v87 = v46;
      operator delete(v48);
    }
    uint64_t v21 = v84;
    if (!v84) {
      goto LABEL_80;
    }
    unsigned int v49 = v85;
    uint64_t v23 = v84;
    if (v85 == v84)
    {
LABEL_79:
      int64_t v85 = v21;
      operator delete(v23);
LABEL_80:
      if (v80 != v83) {
        free(v80);
      }
      return 0;
    }
    do
    {
      int v51 = (void *)*--v49;
      __int16 v50 = v51;
      void *v49 = 0;
      if (v51) {
        operator delete[](v50);
      }
    }
    while (v49 != v21);
LABEL_78:
    uint64_t v23 = v84;
    goto LABEL_79;
  }
  return 0;
}

uint64_t mlir::mps::DequantizeOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v21[6] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a1;
  uint64_t v19 = v21;
  uint64_t v20 = 0x300000000;
  if (*a2)
  {
    uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"axis", 4, *a2);
    uint64_t v5 = v4;
    unsigned int v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      unsigned int v6 = v20;
    }
    uint64_t v7 = (uint64_t *)((char *)v19 + 16 * v6);
    uint64_t *v7 = NamedAttr;
    v7[1] = v5;
    unsigned int v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    uint64_t v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      uint64_t v10 = (uint64_t *)v19;
      if (v8) {
        goto LABEL_6;
      }
LABEL_13:
      uint64_t DictionaryAttr = 0;
      if (v10 == v21) {
        return DictionaryAttr;
      }
      goto LABEL_7;
    }
  }
  else
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_5;
    }
  }
  uint64_t v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"dtype", 5, v9);
  uint64_t v15 = v14;
  unsigned int v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    unsigned int v16 = v20;
  }
  long long v17 = (uint64_t *)((char *)v19 + 16 * v16);
  *long long v17 = v13;
  v17[1] = v15;
  unsigned int v8 = v20 + 1;
  LODWORD(v20) = v8;
  uint64_t v10 = (uint64_t *)v19;
  if (!v8) {
    goto LABEL_13;
  }
LABEL_6:
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  uint64_t v10 = (uint64_t *)v19;
  if (v19 != v21) {
LABEL_7:
  }
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x10uLL);
    *uint64_t v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 111;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        unsigned int v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[61];
    return a1[32];
  }
  return result;
}

void mlir::mps::DequantizeOp::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v32[2] = *MEMORY[0x1E4F143B8];
  uint64_t v26 = a4;
  uint64_t v27 = a3;
  uint64_t v24 = a6;
  uint64_t v25 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v27, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v26, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v25, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v24, 1);
  uint64_t v12 = mlir::TypeAttr::get(a7);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = v12;
  if (a8) {
    *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties>((void *)a2) = a8;
  }
  __src = v32;
  uint64_t v31 = 0x200000000;
  uint64_t v13 = *a1;
  mlir::ValueRange::ValueRange(v29, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  unsigned int v16 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v28, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::DequantizeOp::inferReturnTypes(v13, v17, v18, v29[0], v29[1], Dictionary, v16, v19, v28[0], v28[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v20 = __src;
  }
  uint64_t v21 = v31;
  uint64_t v22 = *(unsigned int *)(a2 + 72);
  unint64_t v23 = v22 + v31;
  if (v23 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v23, 8);
    LODWORD(v22) = *(_DWORD *)(a2 + 72);
  }
  if (v21)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v22), v20, 8 * v21);
    LODWORD(v22) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v22 + v21;
  if (__src != v32) {
    free(__src);
  }
}

{
  mlir::UnknownLoc *v12;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  long long *v15;
  mlir::MLIRContext *v16;
  int v17;
  int v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27[2];
  unint64_t v28[2];
  void *__src;
  uint64_t v30;
  void v31[3];

  unint64_t v31[2] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = a4;
  uint64_t v26 = a3;
  unint64_t v23 = a6;
  uint64_t v24 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v26, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v25, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v24, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v23, 1);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = a7;
  if (a8) {
    *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties>((void *)a2) = a8;
  }
  __src = v31;
  uint64_t v30 = 0x200000000;
  uint64_t v12 = *a1;
  mlir::ValueRange::ValueRange(v28, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v15 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v27, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::DequantizeOp::inferReturnTypes(v12, v16, v17, v28[0], v28[1], Dictionary, v15, v18, v27[0], v27[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  int v19 = __src;
  }
  uint64_t v20 = v30;
  uint64_t v21 = *(unsigned int *)(a2 + 72);
  uint64_t v22 = v21 + v30;
  if (v22 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v22, 8);
    LODWORD(v21) = *(_DWORD *)(a2 + 72);
  }
  if (v20)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v21), v19, 8 * v20);
    LODWORD(v21) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v21 + v20;
  if (__src != v31) {
    free(__src);
  }
}

void mlir::mps::DequantizeOp::build(mlir::Float32Type **a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14 = *a2;
  int v16 = 0;
  uint64_t v15 = mlir::OpBuilder::create<mlir::mps::ConstantOp,float>(a1, v14, (float *)&v16);
  mlir::mps::DequantizeOp::build(a1, (uint64_t)a2, a3, a4, a5, (uint64_t)v15 - 16, a6, a7);
}

BOOL mlir::mps::DequantizeOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v121 = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    unint64_t v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    unint64_t v3 = 0;
  }
  uint64_t v4 = *(void *)(v3 + 8);
  if (v4)
  {
    int v5 = *(const void ***)v3;
    unint64_t v110 = (unint64_t)v2;
    if (!mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v4, (const void **)"dtype", (const char *)5, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps4(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v110))return 0; {
    unint64_t v110 = (unint64_t)*this;
    }
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(v5, (const void **)"axis", (const char *)4, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v110))return 0; {
    unint64_t v6 = *this;
    }
    unint64_t v7 = (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
    unsigned int v8 = *v7;
    unint64_t v9 = (void *)*((void *)*v7 + 17);
    if (v9 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      || v9 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      uint64_t v11 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v8 + 8);
      unint64_t v110 = (unint64_t)v7;
      uint64_t v111 = v11;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v110);
      if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
        || mlir::Type::isF16((mlir::Type *)&OperandRange)
        || mlir::Type::isF32((mlir::Type *)&OperandRange)
        || mlir::Type::isBF16((mlir::Type *)&OperandRange)
        || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
      {
LABEL_89:
        if (mlir::mps::__mlir_ods_local_type_constraint_MPSOps5(*this, *(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
        {
          unsigned int v49 = *this;
          unint64_t v50 = *(void *)(*(void *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8;
          int v51 = *(void **)(*(void *)v50 + 136);
          if (v51 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
            || v51 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
          {
            uint64_t v53 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(void *)v50 + 8);
            unint64_t v110 = v50;
            uint64_t v111 = v53;
            int64_t v104 = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v110);
            if (mlir::Type::isSignedInteger((mlir::Type *)&v104, 2)
              || mlir::Type::isSignedInteger((mlir::Type *)&v104, 4)
              || mlir::Type::isSignedInteger((mlir::Type *)&v104, 8)
              || mlir::Type::isSignedInteger((mlir::Type *)&v104, 16)
              || mlir::Type::isSignedInteger((mlir::Type *)&v104, 32)
              || mlir::Type::isUnsignedInteger((mlir::Type *)&v104, 1)
              || mlir::Type::isUnsignedInteger((mlir::Type *)&v104, 2)
              || mlir::Type::isUnsignedInteger((mlir::Type *)&v104, 4)
              || mlir::Type::isUnsignedInteger((mlir::Type *)&v104, 8)
              || mlir::Type::isUnsignedInteger((mlir::Type *)&v104, 16)
              || mlir::Type::isUnsignedInteger((mlir::Type *)&v104, 32)
              || *((_UNKNOWN **)*v104 + 17) == &mlir::detail::TypeIDResolver<mlir::mps::NF4Type,void>::id)
            {
              goto LABEL_176;
            }
          }
          __int16 v106 = 261;
          int64_t v104 = (const void **)"operand";
          uint64_t v105 = 7;
          mlir::Operation::emitOpError(v49, &v104, (uint64_t)&v110);
          if (v110)
          {
            LODWORD(OperandRange) = 3;
            int64_t v108 = " #";
            uint64_t v109 = 2;
            p_uint64_t OperandRange = &OperandRange;
            long long v55 = (char *)v112;
            if (v113 >= v114)
            {
              unint64_t v84 = v113 + 1;
              if (v112 <= &OperandRange && (char *)v112 + 24 * v113 > (char *)&OperandRange)
              {
                int64_t v96 = (char *)&OperandRange - (unsigned char *)v112;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v84, 24);
                long long v55 = (char *)v112;
                p_uint64_t OperandRange = (uint64_t *)((char *)v112 + v96);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v84, 24);
                p_uint64_t OperandRange = &OperandRange;
                long long v55 = (char *)v112;
              }
            }
            unsigned int v56 = &v55[24 * v113];
            long long v57 = *(_OWORD *)p_OperandRange;
            *((void *)v56 + 2) = p_OperandRange[2];
            *(_OWORD *)unsigned int v56 = v57;
            uint64_t v58 = ++v113;
            if (v110)
            {
              LODWORD(OperandRange) = 5;
              int64_t v108 = (const char *)2;
              long long v59 = &OperandRange;
              int64_t v60 = (char *)v112;
              if (v58 >= v114)
              {
                unint64_t v86 = v58 + 1;
                BOOL v87 = (char *)v112 + 24 * v58 > (char *)&OperandRange;
                if (v112 <= &OperandRange && v87)
                {
                  int64_t v98 = (char *)&OperandRange - (unsigned char *)v112;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v86, 24);
                  int64_t v60 = (char *)v112;
                  long long v59 = (uint64_t *)((char *)v112 + v98);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v86, 24);
                  long long v59 = &OperandRange;
                  int64_t v60 = (char *)v112;
                }
              }
              uint64_t v61 = &v60[24 * v113];
              long long v62 = *(_OWORD *)v59;
              *((void *)v61 + 2) = v59[2];
              *(_OWORD *)uint64_t v61 = v62;
              uint64_t v63 = ++v113;
              if (v110)
              {
                LODWORD(OperandRange) = 3;
                int64_t v108 = " must be tensor of quantized values, but got ";
                uint64_t v109 = 45;
                unint64_t v64 = &OperandRange;
                unint64_t v65 = (char *)v112;
                if (v63 >= v114)
                {
                  unint64_t v90 = v63 + 1;
                  BOOL v91 = (char *)v112 + 24 * v63 > (char *)&OperandRange;
                  if (v112 <= &OperandRange && v91)
                  {
                    int64_t v100 = (char *)&OperandRange - (unsigned char *)v112;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v90, 24);
                    unint64_t v65 = (char *)v112;
                    unint64_t v64 = (uint64_t *)((char *)v112 + v100);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v90, 24);
                    unint64_t v64 = &OperandRange;
                    unint64_t v65 = (char *)v112;
                  }
                }
                unint64_t v66 = &v65[24 * v113];
                long long v67 = *(_OWORD *)v64;
                *((void *)v66 + 2) = v64[2];
                *(_OWORD *)unint64_t v66 = v67;
                ++v113;
                if (v110)
                {
                  unint64_t v68 = &OperandRange;
                  mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&OperandRange, v50);
                  int64_t v69 = (char *)v112;
                  if (v113 >= v114)
                  {
                    unint64_t v94 = v113 + 1;
                    if (v112 <= &OperandRange && (char *)v112 + 24 * v113 > (char *)&OperandRange)
                    {
                      int64_t v102 = (char *)&OperandRange - (unsigned char *)v112;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v94, 24);
                      int64_t v69 = (char *)v112;
                      unint64_t v68 = (uint64_t *)((char *)v112 + v102);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v94, 24);
                      unint64_t v68 = &OperandRange;
                      int64_t v69 = (char *)v112;
                    }
                  }
                  int64_t v70 = &v69[24 * v113];
                  long long v71 = *(_OWORD *)v68;
                  *((void *)v70 + 2) = v68[2];
                  *(_OWORD *)int64_t v70 = v71;
                  ++v113;
                }
              }
            }
          }
          char v72 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v110);
          if (v110) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v110);
          }
          if (v120)
          {
            int64_t v73 = (void **)__p;
            if (__p)
            {
              int64_t v74 = v119;
              uint64_t v75 = __p;
              if (v119 != __p)
              {
                do
                  int64_t v74 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v74 - 1);
                while (v74 != v73);
                uint64_t v75 = __p;
              }
              unint64_t v119 = v73;
              operator delete(v75);
            }
            int v76 = v116;
            if (v116)
            {
              uint64_t v77 = v117;
              uint64_t v78 = v116;
              if (v117 != v116)
              {
                do
                {
                  char v80 = (void *)*--v77;
                  long long v79 = v80;
                  *uint64_t v77 = 0;
                  if (v80) {
                    operator delete[](v79);
                  }
                }
                while (v77 != v76);
                uint64_t v78 = v116;
              }
              unsigned int v117 = v76;
              operator delete(v78);
            }
            if (v112 != v115) {
              free(v112);
            }
          }
          if (v72)
          {
LABEL_176:
            if (mlir::mps::__mlir_ods_local_type_constraint_MPSOps5(*this, *(void *)(*(void *)((*this)[9] + 120) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 3u))
            {
              if (*((_DWORD *)*this + 9)) {
                uint64_t v81 = (uint64_t)(*this - 2);
              }
              else {
                uint64_t v81 = 0;
              }
              uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v81, 0);
              return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
            }
          }
        }
        return 0;
      }
      unsigned int v8 = *v7;
      unint64_t v9 = (void *)*((void *)*v7 + 17);
    }
    BOOL v12 = v9 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
       || v9 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id;
    if (!v12
      || (int64_t v104 = v7,
          uint64_t v105 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v8 + 8),
          uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v104),
          !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 2))
      && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 4)
      && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
      && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
      && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 1)
      && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 2)
      && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 4)
      && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
      && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
      && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      && *(_UNKNOWN **)(*(void *)OperandRange + 136) != &mlir::detail::TypeIDResolver<mlir::mps::NF4Type,void>::id)
    {
      __int16 v106 = 261;
      int64_t v104 = (const void **)"operand";
      uint64_t v105 = 7;
      mlir::Operation::emitOpError(v6, &v104, (uint64_t)&v110);
      if (v110)
      {
        LODWORD(OperandRange) = 3;
        int64_t v108 = " #";
        uint64_t v109 = 2;
        uint64_t v13 = &OperandRange;
        uint64_t v14 = (char *)v112;
        if (v113 >= v114)
        {
          unint64_t v85 = v113 + 1;
          if (v112 <= &OperandRange && (char *)v112 + 24 * v113 > (char *)&OperandRange)
          {
            int64_t v97 = (char *)&OperandRange - (unsigned char *)v112;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v85, 24);
            uint64_t v14 = (char *)v112;
            uint64_t v13 = (uint64_t *)((char *)v112 + v97);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v85, 24);
            uint64_t v13 = &OperandRange;
            uint64_t v14 = (char *)v112;
          }
        }
        uint64_t v15 = &v14[24 * v113];
        long long v16 = *(_OWORD *)v13;
        *((void *)v15 + 2) = v13[2];
        *(_OWORD *)uint64_t v15 = v16;
        uint64_t v17 = ++v113;
        if (v110)
        {
          LODWORD(OperandRange) = 5;
          int64_t v108 = 0;
          int v18 = &OperandRange;
          int v19 = (char *)v112;
          if (v17 >= v114)
          {
            unint64_t v88 = v17 + 1;
            BOOL v89 = (char *)v112 + 24 * v17 > (char *)&OperandRange;
            if (v112 <= &OperandRange && v89)
            {
              int64_t v99 = (char *)&OperandRange - (unsigned char *)v112;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v88, 24);
              int v19 = (char *)v112;
              int v18 = (uint64_t *)((char *)v112 + v99);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v88, 24);
              int v18 = &OperandRange;
              int v19 = (char *)v112;
            }
          }
          uint64_t v20 = &v19[24 * v113];
          long long v21 = *(_OWORD *)v18;
          *((void *)v20 + 2) = v18[2];
          *(_OWORD *)uint64_t v20 = v21;
          uint64_t v22 = ++v113;
          if (v110)
          {
            LODWORD(OperandRange) = 3;
            int64_t v108 = " must be tensor of mps native type values or tensor of quantized values, but got ";
            uint64_t v109 = 81;
            unint64_t v23 = &OperandRange;
            uint64_t v24 = (char *)v112;
            if (v22 >= v114)
            {
              unint64_t v92 = v22 + 1;
              BOOL v93 = (char *)v112 + 24 * v22 > (char *)&OperandRange;
              if (v112 <= &OperandRange && v93)
              {
                int64_t v101 = (char *)&OperandRange - (unsigned char *)v112;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v92, 24);
                uint64_t v24 = (char *)v112;
                unint64_t v23 = (uint64_t *)((char *)v112 + v101);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v92, 24);
                unint64_t v23 = &OperandRange;
                uint64_t v24 = (char *)v112;
              }
            }
            uint64_t v25 = &v24[24 * v113];
            long long v26 = *(_OWORD *)v23;
            *((void *)v25 + 2) = v23[2];
            *(_OWORD *)uint64_t v25 = v26;
            ++v113;
            if (v110)
            {
              uint64_t v27 = &OperandRange;
              mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&OperandRange, (uint64_t)v7);
              uint64_t v28 = (char *)v112;
              if (v113 >= v114)
              {
                unint64_t v95 = v113 + 1;
                if (v112 <= &OperandRange && (char *)v112 + 24 * v113 > (char *)&OperandRange)
                {
                  int64_t v103 = (char *)&OperandRange - (unsigned char *)v112;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v95, 24);
                  uint64_t v28 = (char *)v112;
                  uint64_t v27 = (uint64_t *)((char *)v112 + v103);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v95, 24);
                  uint64_t v27 = &OperandRange;
                  uint64_t v28 = (char *)v112;
                }
              }
              long long v29 = &v28[24 * v113];
              long long v30 = *(_OWORD *)v27;
              *((void *)v29 + 2) = v27[2];
              *(_OWORD *)long long v29 = v30;
              ++v113;
            }
          }
        }
      }
      char v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v110);
      if (v110) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v110);
      }
      if (v120)
      {
        uint64_t v32 = (void **)__p;
        if (__p)
        {
          uint64_t v33 = v119;
          uint64_t v34 = __p;
          if (v119 != __p)
          {
            do
              uint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
            while (v33 != v32);
            uint64_t v34 = __p;
          }
          unint64_t v119 = v32;
          operator delete(v34);
        }
        unsigned int v35 = v116;
        if (v116)
        {
          uint64_t v36 = v117;
          uint64_t v37 = v116;
          if (v117 != v116)
          {
            do
            {
              unint64_t v39 = (void *)*--v36;
              unint64_t v38 = v39;
              *uint64_t v36 = 0;
              if (v39) {
                operator delete[](v38);
              }
            }
            while (v36 != v35);
            uint64_t v37 = v116;
          }
          unsigned int v117 = v35;
          operator delete(v37);
        }
        if (v112 != v115) {
          free(v112);
        }
      }
      if (!v31) {
        return 0;
      }
    }
    goto LABEL_89;
  }
  int64_t v104 = (const void **)"requires attribute 'dtype'";
  __int16 v106 = 259;
  mlir::OpState::emitOpError(this, &v104, (uint64_t)&v110);
  uint64_t v40 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v110);
  if (v110) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v110);
  }
  if (v120)
  {
    long long v41 = (void **)__p;
    if (__p)
    {
      unint64_t v42 = v119;
      BOOL v43 = __p;
      if (v119 != __p)
      {
        do
          unint64_t v42 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v42 - 1);
        while (v42 != v41);
        BOOL v43 = __p;
      }
      unint64_t v119 = v41;
      operator delete(v43);
    }
    unint64_t v44 = v116;
    if (v116)
    {
      long long v45 = v117;
      int64_t v46 = v116;
      if (v117 != v116)
      {
        do
        {
          int64_t v48 = (void *)*--v45;
          int64_t v47 = v48;
          *long long v45 = 0;
          if (v48) {
            operator delete[](v47);
          }
        }
        while (v45 != v44);
        int64_t v46 = v116;
      }
      unsigned int v117 = v44;
      operator delete(v46);
    }
    if (v112 != v115) {
      free(v112);
    }
  }
  return v40;
}

uint64_t mlir::mps::DequantizeOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.dequantize", 14, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC9D07B8;
  v4[12] = mlir::mps::DequantizeOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::DimensionSizeOpGenericAdaptorBase::DimensionSizeOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.dimension_size", 18, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::DimensionSizeOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v23[2] = *MEMORY[0x1E4F143B8];
  uint64_t v17 = a4;
  uint64_t v18 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v18, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v17, 1);
  __src = v23;
  uint64_t v22 = 0x200000000;
  uint64_t v5 = *(void *)a2;
  mlir::ValueRange::ValueRange(v20, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v7 = mlir::ValueRange::ValueRange(&v19, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::DimensionSizeOp::inferReturnTypes((uint64_t)v7, v5, 1, v20[0], v20[1], v8, v9, v10, v15, v16, (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v11 = __src;
  }
  uint64_t v12 = v22;
  uint64_t v13 = *(unsigned int *)(a2 + 72);
  unint64_t v14 = v13 + v22;
  if (v14 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v14, 8);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  if (v12)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v13), v11, 8 * v12);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v13 + v12;
  if (__src != v23) {
    free(__src);
  }
}

BOOL mlir::mps::DimensionSizeOp::verifyInvariantsImpl(uint64_t **this)
{
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps24(*this, *(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v2 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps24(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *(void *)a2;
  uint64_t v11 = *(void **)(*(void *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isSignedInteger((mlir::Type *)v51, 32) || mlir::Type::isSignedInteger((mlir::Type *)v51, 64)) {
      return 1;
    }
  }
  __int16 v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    int v53 = 3;
    unint64_t v54 = " #";
    uint64_t v55 = 2;
    unint64_t v14 = &v53;
    uint64_t v15 = (char *)v57;
    if (v58 >= v59)
    {
      unint64_t v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        int64_t v47 = (char *)&v53 - (unsigned char *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        uint64_t v15 = (char *)v57;
        unint64_t v14 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        unint64_t v14 = &v53;
        uint64_t v15 = (char *)v57;
      }
    }
    uint64_t v16 = &v15[24 * v58];
    long long v17 = *(_OWORD *)v14;
    *((void *)v16 + 2) = *((void *)v14 + 2);
    *(_OWORD *)uint64_t v16 = v17;
    uint64_t v18 = ++v58;
    if (v56[0])
    {
      int v53 = 5;
      unint64_t v54 = (const char *)a5;
      unint64_t v19 = &v53;
      uint64_t v20 = (char *)v57;
      if (v18 >= v59)
      {
        unint64_t v42 = v18 + 1;
        BOOL v43 = (char *)v57 + 24 * v18 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          int64_t v48 = (char *)&v53 - (unsigned char *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          uint64_t v20 = (char *)v57;
          unint64_t v19 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          unint64_t v19 = &v53;
          uint64_t v20 = (char *)v57;
        }
      }
      long long v21 = &v20[24 * v58];
      long long v22 = *(_OWORD *)v19;
      *((void *)v21 + 2) = *((void *)v19 + 2);
      *(_OWORD *)long long v21 = v22;
      uint64_t v23 = ++v58;
      if (v56[0])
      {
        int v53 = 3;
        unint64_t v54 = " must be tensor of mps index type values, but got ";
        uint64_t v55 = 50;
        uint64_t v24 = &v53;
        uint64_t v25 = (char *)v57;
        if (v23 >= v59)
        {
          unint64_t v44 = v23 + 1;
          BOOL v45 = (char *)v57 + 24 * v23 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            int64_t v49 = (char *)&v53 - (unsigned char *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            uint64_t v25 = (char *)v57;
            uint64_t v24 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            uint64_t v24 = &v53;
            uint64_t v25 = (char *)v57;
          }
        }
        long long v26 = &v25[24 * v58];
        long long v27 = *(_OWORD *)v24;
        *((void *)v26 + 2) = *((void *)v24 + 2);
        *(_OWORD *)long long v26 = v27;
        ++v58;
        if (v56[0])
        {
          uint64_t v28 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          long long v29 = (char *)v57;
          if (v58 >= v59)
          {
            unint64_t v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              int64_t v50 = (char *)&v53 - (unsigned char *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              long long v29 = (char *)v57;
              uint64_t v28 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              uint64_t v28 = &v53;
              long long v29 = (char *)v57;
            }
          }
          long long v30 = &v29[24 * v58];
          long long v31 = *(_OWORD *)v28;
          *((void *)v30 + 2) = *((void *)v28 + 2);
          *(_OWORD *)long long v30 = v31;
          ++v58;
        }
      }
    }
  }
  uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  }
  if (v65)
  {
    uint64_t v32 = (void **)__p;
    if (__p)
    {
      uint64_t v33 = v64;
      uint64_t v34 = __p;
      if (v64 != __p)
      {
        do
          uint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        uint64_t v34 = __p;
      }
      unint64_t v64 = v32;
      operator delete(v34);
    }
    unsigned int v35 = v61;
    if (v61)
    {
      uint64_t v36 = v62;
      uint64_t v37 = v61;
      if (v62 != v61)
      {
        do
        {
          unint64_t v39 = (void *)*--v36;
          unint64_t v38 = v39;
          *uint64_t v36 = 0;
          if (v39) {
            operator delete[](v38);
          }
        }
        while (v36 != v35);
        uint64_t v37 = v61;
      }
      long long v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60) {
      free(v57);
    }
  }
  return v13;
}

uint64_t mlir::mps::DimensionSizeOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.dimension_size", 18, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC9808B8;
  v4[12] = mlir::mps::DimensionSizeOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::DiracOpGenericAdaptorBase::DiracOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.dirac", 9, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::DiracOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.dirac", 9, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC982F90;
  v4[12] = mlir::mps::DiracOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::DivideOpGenericAdaptorBase::DivideOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.divide", 10, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::DivideOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.divide", 10, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC983460;
  v4[12] = mlir::mps::DivideOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::DynamicShapeCastOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      int v44 = 3;
      BOOL v45 = "expected DictionaryAttr to set properties";
      uint64_t v46 = 41;
      long long v26 = &v44;
      long long v27 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v40 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          long long v27 = (char *)v48;
          long long v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          long long v26 = &v44;
          long long v27 = (char *)v48;
        }
      }
      uint64_t v28 = &v27[24 * v49];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)uint64_t v28 = v29;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
    if (!v56) {
      return 0;
    }
    long long v30 = (void **)__p;
    if (__p)
    {
      long long v31 = v55;
      uint64_t v32 = __p;
      if (v55 != __p)
      {
        do
          long long v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        uint64_t v32 = __p;
      }
      uint64_t v55 = v30;
      operator delete(v32);
    }
    long long v21 = v52;
    if (!v52) {
      goto LABEL_43;
    }
    uint64_t v33 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      unsigned int v35 = (void *)*--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "unranked", 8uLL);
  if (!v8) {
    return 1;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    int v44 = 3;
    uint64_t v46 = 53;
    uint64_t v10 = &v44;
    uint64_t v11 = (char *)v48;
    if (v49 >= v50)
    {
      unint64_t v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        int64_t v41 = (char *)&v44 - (unsigned char *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v11 = (char *)v48;
        uint64_t v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v10 = &v44;
        uint64_t v11 = (char *)v48;
      }
    }
    uint64_t v12 = &v11[24 * v49];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = *((void *)v10 + 2);
    *(_OWORD *)uint64_t v12 = v13;
    ++v49;
    if (v47[0])
    {
      unint64_t v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      uint64_t v15 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v42 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v15 = (char *)v48;
          unint64_t v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          unint64_t v14 = &v44;
          uint64_t v15 = (char *)v48;
        }
      }
      uint64_t v16 = &v15[24 * v49];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = *((void *)v14 + 2);
      *(_OWORD *)uint64_t v16 = v17;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
  }
  if (!v56) {
    return 0;
  }
  uint64_t v18 = (void **)__p;
  if (__p)
  {
    unint64_t v19 = v55;
    uint64_t v20 = __p;
    if (v55 != __p)
    {
      do
        unint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      uint64_t v20 = __p;
    }
    uint64_t v55 = v18;
    operator delete(v20);
  }
  long long v21 = v52;
  if (v52)
  {
    long long v22 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v25 = (void *)*--v22;
      uint64_t v24 = v25;
      *long long v22 = 0;
      if (v25) {
        operator delete[](v24);
      }
    }
    while (v22 != v21);
LABEL_41:
    uint64_t v23 = v52;
LABEL_42:
    int v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51) {
    free(v48);
  }
  return 0;
}

uint64_t mlir::mps::DynamicShapeCastOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v15[6] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a1;
  long long v13 = v15;
  uint64_t v14 = 0x300000000;
  if (!*a2) {
    return 0;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"unranked", 8, *a2);
  uint64_t v4 = v3;
  unsigned int v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    unsigned int v5 = v14;
  }
  uint64_t v6 = (uint64_t *)((char *)v13 + 16 * v5);
  uint64_t *v6 = NamedAttr;
  v6[1] = v4;
  uint64_t v7 = v13;
  BOOL v8 = __CFADD__(v14, 1);
  uint64_t v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v13 == v15) {
      return DictionaryAttr;
    }
    goto LABEL_10;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (uint64_t *)v13, v9);
  uint64_t v7 = v13;
  if (v13 != v15) {
LABEL_10:
  }
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DynamicShapeCastOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    *uint64_t v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DynamicShapeCastOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DynamicShapeCastOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DynamicShapeCastOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DynamicShapeCastOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::DynamicShapeCastOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 117;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        BOOL v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::DynamicShapeCastOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[63];
    return a1[32];
  }
  return result;
}

void mlir::mps::DynamicShapeCastOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  unint64_t v28[2] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = a4;
  uint64_t v23 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v23, 1);
  if (a4) {
    mlir::OperationState::addOperands(a2, (uint64_t)&v22, 1);
  }
  if (a5)
  {
    uint64_t UnitAttr = mlir::Builder::getUnitAttr(a1, v9);
    *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DynamicShapeCastOpGenericAdaptorBase::Properties>((void *)a2) = UnitAttr;
  }
  __src = v28;
  uint64_t v27 = 0x200000000;
  unint64_t v11 = *a1;
  mlir::ValueRange::ValueRange((unint64_t *)v25, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  unint64_t v14 = *(uint64_t **)(a2 + 256);
  mlir::ValueRange::ValueRange(v24, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::DynamicShapeCastOp::inferReturnTypes(v11, v15, v16, v25[0], (uint64_t)v25[1], Dictionary, v14, v17, v24[0], v24[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v18 = __src;
  }
  uint64_t v19 = v27;
  uint64_t v20 = *(unsigned int *)(a2 + 72);
  unint64_t v21 = v20 + v27;
  if (v21 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v21, 8);
    LODWORD(v20) = *(_DWORD *)(a2 + 72);
  }
  if (v19)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v20), v18, 8 * v19);
    LODWORD(v20) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v20 + v19;
  if (__src != v28) {
    free(__src);
  }
}

BOOL mlir::mps::DynamicShapeCastOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  uint64_t v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  v50[0] = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v3, (const void **)"unranked", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0))
  {
    return 0;
  }
  uint64_t v4 = *this;
  if ((*((unsigned char *)*this + 46) & 0x80) == 0)
  {
    uint64_t v6 = -1;
    goto LABEL_5;
  }
  uint64_t v5 = *((unsigned int *)v4 + 17);
  uint64_t v6 = v5 - 1;
  if ((unint64_t)(v5 - 1) <= 1)
  {
    if (v5 == 1)
    {
LABEL_31:
      int v32 = *((_DWORD *)v4 + 9);
      uint64_t v33 = v4 - 2;
      if (v32) {
        uint64_t v34 = (uint64_t)v33;
      }
      else {
        uint64_t v34 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v34, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
    }
    uint64_t v30 = v4[9] + 56;
    uint64_t v31 = 1;
    while (mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*this, (const void **)(*(void *)(*(void *)v30 + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, v31))
    {
      ++v31;
      v30 += 32;
      if (v5 == v31)
      {
        uint64_t v4 = *this;
        goto LABEL_31;
      }
    }
    return 0;
  }
LABEL_5:
  BOOL v45 = (const void **)"operand group starting at #";
  __int16 v46 = 259;
  mlir::OpState::emitOpError(this, &v45, (uint64_t)v50);
  if (v50[0])
  {
    int v47 = 5;
    uint64_t v48 = 1;
    unint64_t v7 = &v47;
    BOOL v8 = (char *)v51;
    if (v52 >= v53)
    {
      unint64_t v37 = v52 + 1;
      if (v51 <= &v47 && (char *)v51 + 24 * v52 > (char *)&v47)
      {
        int64_t v42 = (char *)&v47 - (unsigned char *)v51;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v54, v37, 24);
        BOOL v8 = (char *)v51;
        unint64_t v7 = (int *)((char *)v51 + v42);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v54, v37, 24);
        unint64_t v7 = &v47;
        BOOL v8 = (char *)v51;
      }
    }
    unint64_t v9 = &v8[24 * v52];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = *((void *)v7 + 2);
    *(_OWORD *)unint64_t v9 = v10;
    uint64_t v11 = ++v52;
    if (v50[0])
    {
      int v47 = 3;
      uint64_t v48 = (uint64_t)" requires 0 or 1 element, but found ";
      uint64_t v49 = 36;
      uint64_t v12 = &v47;
      long long v13 = (char *)v51;
      if (v11 >= v53)
      {
        unint64_t v38 = v11 + 1;
        BOOL v39 = (char *)v51 + 24 * v11 > (char *)&v47;
        if (v51 <= &v47 && v39)
        {
          int64_t v43 = (char *)&v47 - (unsigned char *)v51;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v54, v38, 24);
          long long v13 = (char *)v51;
          uint64_t v12 = (int *)((char *)v51 + v43);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v54, v38, 24);
          uint64_t v12 = &v47;
          long long v13 = (char *)v51;
        }
      }
      unint64_t v14 = &v13[24 * v52];
      long long v15 = *(_OWORD *)v12;
      *((void *)v14 + 2) = *((void *)v12 + 2);
      *(_OWORD *)unint64_t v14 = v15;
      uint64_t v16 = ++v52;
      if (v50[0])
      {
        int v47 = 5;
        uint64_t v48 = v6;
        uint64_t v17 = &v47;
        uint64_t v18 = (char *)v51;
        if (v16 >= v53)
        {
          unint64_t v40 = v16 + 1;
          BOOL v41 = (char *)v51 + 24 * v16 > (char *)&v47;
          if (v51 <= &v47 && v41)
          {
            int64_t v44 = (char *)&v47 - (unsigned char *)v51;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v54, v40, 24);
            uint64_t v18 = (char *)v51;
            uint64_t v17 = (int *)((char *)v51 + v44);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v54, v40, 24);
            uint64_t v17 = &v47;
            uint64_t v18 = (char *)v51;
          }
        }
        uint64_t v19 = &v18[24 * v52];
        long long v20 = *(_OWORD *)v17;
        *((void *)v19 + 2) = *((void *)v17 + 2);
        *(_OWORD *)uint64_t v19 = v20;
        ++v52;
      }
    }
  }
  uint64_t v21 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
  if (v50[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
  }
  if (v59)
  {
    uint64_t v22 = (void **)__p;
    if (__p)
    {
      uint64_t v23 = v58;
      uint64_t v24 = __p;
      if (v58 != __p)
      {
        do
          uint64_t v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
        while (v23 != v22);
        uint64_t v24 = __p;
      }
      unsigned int v58 = v22;
      operator delete(v24);
    }
    uint64_t v25 = v55;
    if (v55)
    {
      long long v26 = v56;
      uint64_t v27 = v55;
      if (v56 != v55)
      {
        do
        {
          long long v29 = (void *)*--v26;
          uint64_t v28 = v29;
          *long long v26 = 0;
          if (v29) {
            operator delete[](v28);
          }
        }
        while (v26 != v25);
        uint64_t v27 = v55;
      }
      char v56 = v25;
      operator delete(v27);
    }
    if (v51 != v54) {
      free(v51);
    }
  }
  return v21;
}

uint64_t mlir::mps::DynamicShapeCastOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.dynamic_shape_cast", 22, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC981410;
  v4[12] = mlir::mps::DynamicShapeCastOp::canonicalize;
  unint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::EluOpGenericAdaptorBase::EluOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.elu", 7, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::EluOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.elu", 7, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC982388;
  v4[12] = mlir::mps::EluOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::EqualToOpGenericAdaptorBase::EqualToOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.equal", 9, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::EqualToOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v17[2] = *MEMORY[0x1E4F143B8];
  uint64_t v11 = a4;
  uint64_t v12 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v12, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v11, 1);
  __src = v17;
  uint64_t v16 = 0x200000000;
  uint64_t v5 = *(void *)a2;
  mlir::ValueRange::ValueRange(v14, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v13, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  uint64_t v7 = __src;
  uint64_t v8 = v16;
  uint64_t v9 = *(unsigned int *)(a2 + 72);
  unint64_t v10 = v9 + v16;
  if (v10 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v10, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
  }
  if (v8)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v9), v7, 8 * v8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v9 + v8;
  if (__src != v17) {
    free(__src);
  }
}

BOOL mlir::mps::EqualToOp::verifyInvariantsImpl(uint64_t **this)
{
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v2 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps25(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps25(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *(void *)a2;
  uint64_t v11 = *(void **)(*(void *)a2 + 136);
  BOOL v12 = v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
     || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id;
  if (!v12
    || (v56[0] = a2,
        v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8),
        v51[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56),
        uint64_t v13 = 1,
        !mlir::Type::isSignlessInteger((mlir::Type *)v51, 1)))
  {
    __int16 v52 = 261;
    v51[0] = a3;
    v51[1] = a4;
    mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
    if (v56[0])
    {
      int v53 = 3;
      unint64_t v54 = " #";
      uint64_t v55 = 2;
      unint64_t v14 = &v53;
      long long v15 = (char *)v57;
      if (v58 >= v59)
      {
        unint64_t v41 = v58 + 1;
        if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
        {
          int64_t v47 = (char *)&v53 - (unsigned char *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
          long long v15 = (char *)v57;
          unint64_t v14 = (int *)((char *)v57 + v47);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
          unint64_t v14 = &v53;
          long long v15 = (char *)v57;
        }
      }
      uint64_t v16 = &v15[24 * v58];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = *((void *)v14 + 2);
      *(_OWORD *)uint64_t v16 = v17;
      uint64_t v18 = ++v58;
      if (v56[0])
      {
        int v53 = 5;
        unint64_t v54 = (const char *)a5;
        uint64_t v19 = &v53;
        long long v20 = (char *)v57;
        if (v18 >= v59)
        {
          unint64_t v42 = v18 + 1;
          BOOL v43 = (char *)v57 + 24 * v18 > (char *)&v53;
          if (v57 <= &v53 && v43)
          {
            int64_t v48 = (char *)&v53 - (unsigned char *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
            long long v20 = (char *)v57;
            uint64_t v19 = (int *)((char *)v57 + v48);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
            uint64_t v19 = &v53;
            long long v20 = (char *)v57;
          }
        }
        uint64_t v21 = &v20[24 * v58];
        long long v22 = *(_OWORD *)v19;
        *((void *)v21 + 2) = *((void *)v19 + 2);
        *(_OWORD *)uint64_t v21 = v22;
        uint64_t v23 = ++v58;
        if (v56[0])
        {
          int v53 = 3;
          unint64_t v54 = " must be tensor of 1-bit signless integer values, but got ";
          uint64_t v55 = 58;
          uint64_t v24 = &v53;
          uint64_t v25 = (char *)v57;
          if (v23 >= v59)
          {
            unint64_t v44 = v23 + 1;
            BOOL v45 = (char *)v57 + 24 * v23 > (char *)&v53;
            if (v57 <= &v53 && v45)
            {
              int64_t v49 = (char *)&v53 - (unsigned char *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
              uint64_t v25 = (char *)v57;
              uint64_t v24 = (int *)((char *)v57 + v49);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
              uint64_t v24 = &v53;
              uint64_t v25 = (char *)v57;
            }
          }
          long long v26 = &v25[24 * v58];
          long long v27 = *(_OWORD *)v24;
          *((void *)v26 + 2) = *((void *)v24 + 2);
          *(_OWORD *)long long v26 = v27;
          ++v58;
          if (v56[0])
          {
            uint64_t v28 = &v53;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
            long long v29 = (char *)v57;
            if (v58 >= v59)
            {
              unint64_t v46 = v58 + 1;
              if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
              {
                int64_t v50 = (char *)&v53 - (unsigned char *)v57;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
                long long v29 = (char *)v57;
                uint64_t v28 = (int *)((char *)v57 + v50);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
                uint64_t v28 = &v53;
                long long v29 = (char *)v57;
              }
            }
            uint64_t v30 = &v29[24 * v58];
            long long v31 = *(_OWORD *)v28;
            *((void *)v30 + 2) = *((void *)v28 + 2);
            *(_OWORD *)uint64_t v30 = v31;
            ++v58;
          }
        }
      }
    }
    uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
    if (v56[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
    }
    if (v65)
    {
      int v32 = (void **)__p;
      if (__p)
      {
        uint64_t v33 = v64;
        uint64_t v34 = __p;
        if (v64 != __p)
        {
          do
            uint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
          while (v33 != v32);
          uint64_t v34 = __p;
        }
        unint64_t v64 = v32;
        operator delete(v34);
      }
      unsigned int v35 = v61;
      if (v61)
      {
        uint64_t v36 = v62;
        unint64_t v37 = v61;
        if (v62 != v61)
        {
          do
          {
            BOOL v39 = (void *)*--v36;
            unint64_t v38 = v39;
            *uint64_t v36 = 0;
            if (v39) {
              operator delete[](v38);
            }
          }
          while (v36 != v35);
          unint64_t v37 = v61;
        }
        long long v62 = v35;
        operator delete(v37);
      }
      if (v57 != v60) {
        free(v57);
      }
    }
  }
  return v13;
}

uint64_t mlir::mps::EqualToOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.equal", 9, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC983880;
  v4[12] = mlir::mps::EqualToOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::ErfOpGenericAdaptorBase::ErfOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.erf", 7, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::ErfOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.erf", 7, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC9823E0;
  v4[12] = mlir::mps::ErfOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::ExpandDimsOpGenericAdaptorBase::ExpandDimsOpGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  unint64_t v5 = a2[11];
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.expand_dims", 15, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::ExpandDimsOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v23[2] = *MEMORY[0x1E4F143B8];
  uint64_t v17 = a4;
  uint64_t v18 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v18, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v17, 1);
  __src = v23;
  uint64_t v22 = 0x200000000;
  uint64_t v5 = *(void *)a2;
  mlir::ValueRange::ValueRange(v20, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v7 = mlir::ValueRange::ValueRange(&v19, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::ExpandDimsOp::inferReturnTypes((uint64_t)v7, v5, 1, v20[0], v20[1], v8, v9, v10, v15, v16, (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v11 = __src;
  }
  uint64_t v12 = v22;
  uint64_t v13 = *(unsigned int *)(a2 + 72);
  unint64_t v14 = v13 + v22;
  if (v14 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v14, 8);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  if (v12)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v13), v11, 8 * v12);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v13 + v12;
  if (__src != v23) {
    free(__src);
  }
}

uint64_t mlir::mps::ExpandDimsOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.expand_dims", 15, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC9D0810;
  v4[12] = mlir::mps::ExpandDimsOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::ExponentBase10OpGenericAdaptorBase::ExponentBase10OpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.exponent_base_10", 20, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::ExponentBase10Op::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.exponent_base_10", 20, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC980CD8;
  v4[12] = mlir::mps::ExponentBase10Op::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::ExponentBase2OpGenericAdaptorBase::ExponentBase2OpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.exponent_base_2", 19, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::ExponentBase2Op::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.exponent_base_2", 19, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC980910;
  v4[12] = mlir::mps::ExponentBase2Op::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::ExponentOpGenericAdaptorBase::ExponentOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.exponent", 12, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::ExponentOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.exponent", 12, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC97F5D0;
  v4[12] = mlir::mps::ExponentOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::FastFourierTransformOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v89 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v75 = v6;
  if (!v6)
  {
    a3(v79, a4);
    if (v79[0])
    {
      int v76 = 3;
      uint64_t v77 = "expected DictionaryAttr to set properties";
      uint64_t v78 = 41;
      long long v26 = &v76;
      long long v27 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v63 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v69 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          long long v27 = (char *)v80;
          long long v26 = (int *)((char *)v80 + v69);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          long long v26 = &v76;
          long long v27 = (char *)v80;
        }
      }
      uint64_t v28 = &v27[24 * v81];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)uint64_t v28 = v29;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
    if (!v88) {
      return 0;
    }
    uint64_t v30 = (void **)__p;
    if (__p)
    {
      long long v31 = v87;
      int v32 = __p;
      if (v87 != __p)
      {
        do
          long long v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        int v32 = __p;
      }
      BOOL v87 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v84;
    if (!v84) {
      goto LABEL_80;
    }
    uint64_t v33 = v85;
    uint64_t v23 = v84;
    if (v85 == v84) {
      goto LABEL_79;
    }
    do
    {
      unsigned int v35 = (void *)*--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
    goto LABEL_78;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v75, "inverse", 7uLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v79, a4);
      if (v79[0])
      {
        int v76 = 3;
        uint64_t v78 = 52;
        uint64_t v10 = &v76;
        uint64_t v11 = (char *)v80;
        if (v81 >= v82)
        {
          unint64_t v64 = v81 + 1;
          if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
          {
            int64_t v70 = (char *)&v76 - (unsigned char *)v80;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            uint64_t v11 = (char *)v80;
            uint64_t v10 = (int *)((char *)v80 + v70);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            uint64_t v10 = &v76;
            uint64_t v11 = (char *)v80;
          }
        }
        uint64_t v12 = &v11[24 * v81];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = *((void *)v10 + 2);
        *(_OWORD *)uint64_t v12 = v13;
        ++v81;
        if (v79[0])
        {
          unint64_t v14 = &v76;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v9);
          uint64_t v15 = (char *)v80;
          if (v81 >= v82)
          {
            unint64_t v65 = v81 + 1;
            if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
            {
              int64_t v71 = (char *)&v76 - (unsigned char *)v80;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              uint64_t v15 = (char *)v80;
              unint64_t v14 = (int *)((char *)v80 + v71);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              unint64_t v14 = &v76;
              uint64_t v15 = (char *)v80;
            }
          }
          uint64_t v16 = &v15[24 * v81];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = *((void *)v14 + 2);
          *(_OWORD *)uint64_t v16 = v17;
          ++v81;
          if (v79[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
          }
        }
      }
      if (!v88) {
        return 0;
      }
      uint64_t v18 = (void **)__p;
      if (__p)
      {
        unint64_t v19 = v87;
        long long v20 = __p;
        if (v87 != __p)
        {
          do
            unint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          long long v20 = __p;
        }
        BOOL v87 = v18;
        operator delete(v20);
      }
      uint64_t v21 = v84;
      if (!v84) {
        goto LABEL_80;
      }
      uint64_t v22 = v85;
      uint64_t v23 = v84;
      if (v85 == v84) {
        goto LABEL_79;
      }
      do
      {
        uint64_t v25 = (void *)*--v22;
        uint64_t v24 = v25;
        *uint64_t v22 = 0;
        if (v25) {
          operator delete[](v24);
        }
      }
      while (v22 != v21);
      goto LABEL_78;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v75, "scaling_mode", 0xCuLL);
  if (!v36)
  {
    a3(v79, a4);
    if (v79[0])
    {
      int v76 = 3;
      uint64_t v77 = "expected key entry for scaling_mode in DictionaryAttr to set Properties.";
      uint64_t v78 = 72;
      __int16 v52 = &v76;
      int v53 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v67 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v73 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          int v53 = (char *)v80;
          __int16 v52 = (int *)((char *)v80 + v73);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          __int16 v52 = &v76;
          int v53 = (char *)v80;
        }
      }
      unint64_t v54 = &v53[24 * v81];
      long long v55 = *(_OWORD *)v52;
      *((void *)v54 + 2) = *((void *)v52 + 2);
      *(_OWORD *)unint64_t v54 = v55;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
    if (!v88) {
      return 0;
    }
    char v56 = (void **)__p;
    if (__p)
    {
      uint64_t v57 = v87;
      unsigned int v58 = __p;
      if (v87 != __p)
      {
        do
          uint64_t v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        unsigned int v58 = __p;
      }
      BOOL v87 = v56;
      operator delete(v58);
    }
    uint64_t v21 = v84;
    if (!v84) {
      goto LABEL_80;
    }
    unsigned int v59 = v85;
    uint64_t v23 = v84;
    if (v85 == v84) {
      goto LABEL_79;
    }
    do
    {
      uint64_t v61 = (void *)*--v59;
      uint64_t v60 = v61;
      void *v59 = 0;
      if (v61) {
        operator delete[](v60);
      }
    }
    while (v59 != v21);
    goto LABEL_78;
  }
  uint64_t v37 = v36;
  if (*(_UNKNOWN **)(*(void *)v36 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id)
  {
    a1[1] = v36;
    return 1;
  }
  a3(v79, a4);
  if (v79[0])
  {
    int v76 = 3;
    uint64_t v78 = 57;
    unint64_t v38 = &v76;
    BOOL v39 = (char *)v80;
    if (v81 >= v82)
    {
      unint64_t v66 = v81 + 1;
      if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
      {
        int64_t v72 = (char *)&v76 - (unsigned char *)v80;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        BOOL v39 = (char *)v80;
        unint64_t v38 = (int *)((char *)v80 + v72);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        unint64_t v38 = &v76;
        BOOL v39 = (char *)v80;
      }
    }
    unint64_t v40 = &v39[24 * v81];
    long long v41 = *(_OWORD *)v38;
    *((void *)v40 + 2) = *((void *)v38 + 2);
    *(_OWORD *)unint64_t v40 = v41;
    ++v81;
    if (v79[0])
    {
      unint64_t v42 = &v76;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v37);
      BOOL v43 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v68 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v74 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          BOOL v43 = (char *)v80;
          unint64_t v42 = (int *)((char *)v80 + v74);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          unint64_t v42 = &v76;
          BOOL v43 = (char *)v80;
        }
      }
      unint64_t v44 = &v43[24 * v81];
      long long v45 = *(_OWORD *)v42;
      *((void *)v44 + 2) = *((void *)v42 + 2);
      *(_OWORD *)unint64_t v44 = v45;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
  }
  if (v88)
  {
    unint64_t v46 = (void **)__p;
    if (__p)
    {
      int64_t v47 = v87;
      int64_t v48 = __p;
      if (v87 != __p)
      {
        do
          int64_t v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        int64_t v48 = __p;
      }
      BOOL v87 = v46;
      operator delete(v48);
    }
    uint64_t v21 = v84;
    if (!v84) {
      goto LABEL_80;
    }
    int64_t v49 = v85;
    uint64_t v23 = v84;
    if (v85 == v84)
    {
LABEL_79:
      unint64_t v85 = v21;
      operator delete(v23);
LABEL_80:
      if (v80 != v83) {
        free(v80);
      }
      return 0;
    }
    do
    {
      int v51 = (void *)*--v49;
      int64_t v50 = v51;
      void *v49 = 0;
      if (v51) {
        operator delete[](v50);
      }
    }
    while (v49 != v21);
LABEL_78:
    uint64_t v23 = v84;
    goto LABEL_79;
  }
  return 0;
}

uint64_t mlir::mps::FastFourierTransformOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v21[6] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a1;
  unint64_t v19 = v21;
  uint64_t v20 = 0x300000000;
  if (*a2)
  {
    uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"inverse", 7, *a2);
    uint64_t v5 = v4;
    unsigned int v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      unsigned int v6 = v20;
    }
    uint64_t v7 = (uint64_t *)((char *)v19 + 16 * v6);
    uint64_t *v7 = NamedAttr;
    v7[1] = v5;
    unsigned int v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    uint64_t v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      uint64_t v10 = (uint64_t *)v19;
      if (v8) {
        goto LABEL_6;
      }
LABEL_13:
      uint64_t DictionaryAttr = 0;
      if (v10 == v21) {
        return DictionaryAttr;
      }
      goto LABEL_7;
    }
  }
  else
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_5;
    }
  }
  uint64_t v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"scaling_mode", 12, v9);
  uint64_t v15 = v14;
  unsigned int v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    unsigned int v16 = v20;
  }
  long long v17 = (uint64_t *)((char *)v19 + 16 * v16);
  *long long v17 = v13;
  v17[1] = v15;
  unsigned int v8 = v20 + 1;
  LODWORD(v20) = v8;
  uint64_t v10 = (uint64_t *)v19;
  if (!v8) {
    goto LABEL_13;
  }
LABEL_6:
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  uint64_t v10 = (uint64_t *)v19;
  if (v19 != v21) {
LABEL_7:
  }
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps27(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    uint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    unsigned int v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        unsigned int v8 = (char *)v35;
        uint64_t v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        unsigned int v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      long long v29 = a2;
      uint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        uint64_t v30 = "' failed to satisfy constraint: valid FFT scaling mode";
        uint64_t v31 = 54;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        uint64_t v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)uint64_t v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    unsigned int v16 = (void **)__p;
    if (__p)
    {
      long long v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          long long v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      unint64_t v42 = v16;
      operator delete(v18);
    }
    unint64_t v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      uint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = (void *)*--v20;
          uint64_t v22 = v23;
          *uint64_t v20 = 0;
          if (v23) {
            operator delete[](v22);
          }
        }
        while (v20 != v19);
        uint64_t v21 = v39;
      }
      unint64_t v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::FastFourierTransformOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x10uLL);
    *uint64_t v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::FastFourierTransformOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::FastFourierTransformOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::FastFourierTransformOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::FastFourierTransformOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::FastFourierTransformOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 121;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        unsigned int v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::FastFourierTransformOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[65];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::mps::FFTScalingModeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  int v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id) {
    return 1;
  }
  unsigned char v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    unint64_t v6 = &v40;
    unint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v7 = (char *)v46;
        unint64_t v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v6 = &v40;
        unint64_t v7 = (char *)v46;
      }
    }
    unsigned int v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)unsigned int v8 = v9;
    ++v47;
  }
  unint64_t v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::FFTScalingModeAttr]";
  unint64_t v41 = 79;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    unint64_t v40 = (const void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      unint64_t v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          unint64_t v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          unint64_t v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      unsigned int v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)unsigned int v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unint64_t v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unint64_t v19 = (char *)v46;
            uint64_t v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            unint64_t v19 = (char *)v46;
          }
        }
        uint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = (void **)__p;
    if (__p)
    {
      uint64_t v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      int v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = (void *)*--v27;
          long long v29 = v30;
          void *v27 = 0;
          if (v30) {
            operator delete[](v29);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      int v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

void mlir::mps::FastFourierTransformOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6)
{
  unint64_t v33[2] = *MEMORY[0x1E4F143B8];
  uint64_t v26 = a4;
  uint64_t v27 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v27, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v26, 1);
  unint64_t v10 = *a1;
  unsigned int v28 = a5;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v10);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id;
  uint64_t v32 = (uint64_t)v10;
  uint64_t v12 = mlir::StorageUniquer::get<mlir::mps::detail::FFTScalingModeAttrStorage,mlir::mps::FFTScalingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25FFTScalingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18FFTScalingModeAttrEJNS2_14FFTScalingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id, &v28);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::FastFourierTransformOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = v12;
  if (a6)
  {
    uint64_t UnitAttr = mlir::Builder::getUnitAttr(a1, v13);
    *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::FastFourierTransformOpGenericAdaptorBase::Properties>((void *)a2) = UnitAttr;
  }
  __src = v33;
  uint64_t v32 = 0x200000000;
  uint64_t v15 = *a1;
  mlir::ValueRange::ValueRange(v30, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v18 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v29, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::FastFourierTransformOp::inferReturnTypes(v15, v19, v20, v30[0], v30[1], Dictionary, v18, v21, v29[0], v29[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v22 = __src;
  }
  uint64_t v23 = v32;
  uint64_t v24 = *(unsigned int *)(a2 + 72);
  unint64_t v25 = v24 + v32;
  if (v25 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v25, 8);
    LODWORD(v24) = *(_DWORD *)(a2 + 72);
  }
  if (v23)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v24), v22, 8 * v23);
    LODWORD(v24) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v24 + v23;
  if (__src != v33) {
    free(__src);
  }
}

BOOL mlir::mps::FastFourierTransformOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    uint64_t v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = v3[1];
  if (v4)
  {
    uint64_t v5 = *v3;
    v20[0] = v2;
    if (mlir::mps::__mlir_ods_local_attr_constraint_MPSOps27(v4, (const void **)"scaling_mode", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps27(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20)&& (v20[0] = *this, mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (const void **)"inverse", (const char *)7, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20))&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps26(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(
                            *this,
                            (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8),
                            (const void **)"operand",
                            7,
                            1u))
    {
      if (*((_DWORD *)*this + 9)) {
        uint64_t v6 = (uint64_t)(*this - 2);
      }
      else {
        uint64_t v6 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps19(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    uint64_t v18 = (const void **)"requires attribute 'scaling_mode'";
    __int16 v19 = 259;
    mlir::OpState::emitOpError(this, &v18, (uint64_t)v20);
    uint64_t v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v20);
    if (v20[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v20);
    }
    if (v27)
    {
      long long v9 = (void **)__p;
      if (__p)
      {
        unint64_t v10 = v26;
        unint64_t v11 = __p;
        if (v26 != __p)
        {
          do
            unint64_t v10 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v10 - 1);
          while (v10 != v9);
          unint64_t v11 = __p;
        }
        uint64_t v26 = v9;
        operator delete(v11);
      }
      uint64_t v12 = v23;
      if (v23)
      {
        unint64_t v13 = v24;
        unint64_t v14 = v23;
        if (v24 != v23)
        {
          do
          {
            unsigned int v16 = (void *)*--v13;
            uint64_t v15 = v16;
            void *v13 = 0;
            if (v16) {
              operator delete[](v15);
            }
          }
          while (v13 != v12);
          unint64_t v14 = v23;
        }
        uint64_t v24 = v12;
        operator delete(v14);
      }
      if (v21 != &v22) {
        free(v21);
      }
    }
  }
  return v8;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps26(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  unint64_t v10 = *a2;
  unint64_t v11 = (void *)*((void *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v63[0] = a2;
    v63[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v63);
    if (mlir::Type::isF16((mlir::Type *)&OperandRange)
      || mlir::Type::isF32((mlir::Type *)&OperandRange)
      || mlir::Type::isBF16((mlir::Type *)&OperandRange))
    {
      return 1;
    }
    unint64_t v10 = *a2;
    unint64_t v11 = (void *)*((void *)*a2 + 17);
  }
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    char v54 = a2;
    uint64_t v55 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t v14 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v54);
    if (*(_UNKNOWN **)(*(void *)v14 + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      uint64_t v42 = v14;
      uint64_t v59 = v14;
      uint64_t OperandRange = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v59);
      if (mlir::Type::isF16((mlir::Type *)&OperandRange)) {
        return 1;
      }
      uint64_t v57 = v42;
      uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v57);
      if (mlir::Type::isF32((mlir::Type *)&Value)) {
        return 1;
      }
    }
  }
  __int16 v56 = 261;
  char v54 = a3;
  uint64_t v55 = a4;
  mlir::Operation::emitOpError(a1, &v54, (uint64_t)v63);
  if (v63[0])
  {
    LODWORD(OperandRange) = 3;
    uint64_t v61 = " #";
    uint64_t v62 = 2;
    p_uint64_t OperandRange = &OperandRange;
    unsigned int v16 = (char *)v64;
    if (v65 >= v66)
    {
      unint64_t v44 = v65 + 1;
      if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
      {
        int64_t v50 = (char *)&OperandRange - (unsigned char *)v64;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v44, 24);
        unsigned int v16 = (char *)v64;
        p_uint64_t OperandRange = (uint64_t *)((char *)v64 + v50);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v44, 24);
        p_uint64_t OperandRange = &OperandRange;
        unsigned int v16 = (char *)v64;
      }
    }
    long long v17 = &v16[24 * v65];
    long long v18 = *(_OWORD *)p_OperandRange;
    *((void *)v17 + 2) = p_OperandRange[2];
    *(_OWORD *)long long v17 = v18;
    uint64_t v19 = ++v65;
    if (v63[0])
    {
      LODWORD(OperandRange) = 5;
      uint64_t v61 = (const char *)a5;
      int v20 = &OperandRange;
      int v21 = (char *)v64;
      if (v19 >= v66)
      {
        unint64_t v45 = v19 + 1;
        BOOL v46 = (char *)v64 + 24 * v19 > (char *)&OperandRange;
        if (v64 <= &OperandRange && v46)
        {
          int64_t v51 = (char *)&OperandRange - (unsigned char *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
          int v21 = (char *)v64;
          int v20 = (uint64_t *)((char *)v64 + v51);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
          int v20 = &OperandRange;
          int v21 = (char *)v64;
        }
      }
      uint64_t v22 = &v21[24 * v65];
      long long v23 = *(_OWORD *)v20;
      *((void *)v22 + 2) = v20[2];
      *(_OWORD *)uint64_t v22 = v23;
      uint64_t v24 = ++v65;
      if (v63[0])
      {
        LODWORD(OperandRange) = 3;
        uint64_t v61 = " must be tensor of floating point values or tensor of complex values, but got ";
        uint64_t v62 = 78;
        unint64_t v25 = &OperandRange;
        uint64_t v26 = (char *)v64;
        if (v24 >= v66)
        {
          unint64_t v47 = v24 + 1;
          BOOL v48 = (char *)v64 + 24 * v24 > (char *)&OperandRange;
          if (v64 <= &OperandRange && v48)
          {
            int64_t v52 = (char *)&OperandRange - (unsigned char *)v64;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
            uint64_t v26 = (char *)v64;
            unint64_t v25 = (uint64_t *)((char *)v64 + v52);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
            unint64_t v25 = &OperandRange;
            uint64_t v26 = (char *)v64;
          }
        }
        char v27 = &v26[24 * v65];
        long long v28 = *(_OWORD *)v25;
        *((void *)v27 + 2) = v25[2];
        *(_OWORD *)char v27 = v28;
        ++v65;
        if (v63[0])
        {
          long long v29 = &OperandRange;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&OperandRange, (uint64_t)a2);
          uint64_t v30 = (char *)v64;
          if (v65 >= v66)
          {
            unint64_t v49 = v65 + 1;
            if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
            {
              int64_t v53 = (char *)&OperandRange - (unsigned char *)v64;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
              uint64_t v30 = (char *)v64;
              long long v29 = (uint64_t *)((char *)v64 + v53);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
              long long v29 = &OperandRange;
              uint64_t v30 = (char *)v64;
            }
          }
          uint64_t v31 = &v30[24 * v65];
          long long v32 = *(_OWORD *)v29;
          *((void *)v31 + 2) = v29[2];
          *(_OWORD *)uint64_t v31 = v32;
          ++v65;
        }
      }
    }
  }
  uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v63);
  if (v63[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
  }
  if (v72)
  {
    unint64_t v34 = (void **)__p;
    if (__p)
    {
      int64_t v35 = v71;
      int64_t v36 = __p;
      if (v71 != __p)
      {
        do
          int64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        int64_t v36 = __p;
      }
      int64_t v71 = v34;
      operator delete(v36);
    }
    int64_t v37 = v68;
    if (v68)
    {
      unint64_t v38 = v69;
      uint64_t v39 = v68;
      if (v69 != v68)
      {
        do
        {
          unint64_t v41 = (void *)*--v38;
          unint64_t v40 = v41;
          void *v38 = 0;
          if (v41) {
            operator delete[](v40);
          }
        }
        while (v38 != v37);
        uint64_t v39 = v68;
      }
      int64_t v69 = v37;
      operator delete(v39);
    }
    if (v64 != v67) {
      free(v64);
    }
  }
  return v33;
}

uint64_t mlir::mps::FastFourierTransformOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.fast_fourier_transform", 26, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC981AF0;
  v4[12] = mlir::mps::FastFourierTransformOp::canonicalize;
  long long v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    long long v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::Flatten2DOpGenericAdaptorBase::Flatten2DOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.flatten_2d", 14, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::Flatten2DOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v23[2] = *MEMORY[0x1E4F143B8];
  uint64_t v17 = a4;
  uint64_t v18 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v18, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v17, 1);
  __src = v23;
  uint64_t v22 = 0x200000000;
  uint64_t v5 = *(void *)a2;
  mlir::ValueRange::ValueRange(v20, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v7 = mlir::ValueRange::ValueRange(&v19, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::Flatten2DOp::inferReturnTypes((uint64_t)v7, v5, 1, v20[0], v20[1], v8, v9, v10, v15, v16, (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v11 = __src;
  }
  uint64_t v12 = v22;
  uint64_t v13 = *(unsigned int *)(a2 + 72);
  unint64_t v14 = v13 + v22;
  if (v14 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v14, 8);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  if (v12)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v13), v11, 8 * v12);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v13 + v12;
  if (__src != v23) {
    free(__src);
  }
}

BOOL mlir::mps::Flatten2DOp::verifyInvariantsImpl(uint64_t **this)
{
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v2 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::Flatten2DOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.flatten_2d", 14, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC9D0760;
  v4[12] = mlir::mps::Flatten2DOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::FloorDivideOpGenericAdaptorBase::FloorDivideOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.floor_divide", 16, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::mps::FloorDivideOp::verifyInvariantsImpl(uint64_t **this)
{
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v2 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::FloorDivideOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.floor_divide", 16, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC980128;
  v4[12] = mlir::mps::FloorDivideOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::FloorOpGenericAdaptorBase::FloorOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.floor", 9, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::FloorOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.floor", 9, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC982FE8;
  v4[12] = mlir::mps::FloorOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::GRUGradientOp::getAsmResultNames(uint64_t *a1, void (*a2)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a3)
{
  if (*(_DWORD *)(*a1 + 36)) {
    uint64_t v5 = *a1 - 16;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0);
  a2(a3, NextResultAtOffset, "gradient_output_sequence", 24);
  if (*(_DWORD *)(*a1 + 36)) {
    uint64_t v7 = *a1 - 16;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 1);
  uint64_t v9 = mlir::detail::OpResultImpl::getNextResultAtOffset(v8, 0);
  a2(a3, v9, "gradient_recurrent_weight", 25);
  if (*(_DWORD *)(*a1 + 36)) {
    uint64_t v10 = *a1 - 16;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 2);
  uint64_t v12 = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
  a2(a3, v12, "gradient_input_state", 20);
  uint64_t v13 = *a1;
  int v14 = *(_DWORD *)(*a1 + 36);
  uint64_t v15 = v13 - 16;
  if (v14) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t result = mlir::detail::OpResultImpl::getNextResultAtOffset(v16, 3);
  if (v14 != 3)
  {
    uint64_t v18 = mlir::detail::OpResultImpl::getNextResultAtOffset(result, 0);
    return ((uint64_t (*)(uint64_t, uint64_t, const char *, uint64_t))a2)(a3, v18, "gradient_bias", 13);
  }
  return result;
}

uint64_t mlir::mps::GRUGradientOp::getODSResults(mlir::mps::GRUGradientOp *this, unsigned int a2)
{
  if (a2)
  {
    if (a2 >= 8)
    {
      int32x4_t v4 = (int32x4_t)xmmword_1810FFF10;
      unsigned int v3 = a2 & 0xFFFFFFF8;
      int32x4_t v5 = 0uLL;
      v6.i64[0] = 0x300000003;
      v6.i64[1] = 0x300000003;
      v7.i64[0] = -1;
      v7.i64[1] = -1;
      v8.i64[0] = 0x800000008;
      v8.i64[1] = 0x800000008;
      unsigned int v9 = a2 & 0xFFFFFFF8;
      int32x4_t v10 = 0uLL;
      do
      {
        int32x4_t v5 = vsubq_s32(v5, vceqq_s32(v4, v6));
        int32x4_t v10 = vsubq_s32(v10, vceqq_s32(v4, v7));
        int32x4_t v4 = vaddq_s32(v4, v8);
        v9 -= 8;
      }
      while (v9);
      int v2 = vaddvq_s32(vaddq_s32(v10, v5));
      if (v3 == a2) {
        goto LABEL_11;
      }
    }
    else
    {
      int v2 = 0;
      unsigned int v3 = 0;
    }
    do
    {
      if (v3 == 3) {
        ++v2;
      }
      ++v3;
    }
    while (a2 != v3);
  }
  else
  {
    int v2 = 0;
  }
LABEL_11:
  int v11 = *(_DWORD *)(*(void *)this + 36);
  if (v11) {
    uint64_t result = *(void *)this - 16;
  }
  else {
    uint64_t result = 0;
  }
  if (a2 + (v11 - 4) * v2) {
    return mlir::detail::OpResultImpl::getNextResultAtOffset(result, a2 + (v11 - 4) * v2);
  }
  return result;
}

uint64_t mlir::mps::GRUGradientOp::getODSOperands(mlir::mps::GRUGradientOp *this, unsigned int a2)
{
  unint64_t v2 = *(unsigned int *)(*(void *)this + 44);
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v3 = *(void *)this + 16 * ((v2 >> 23) & 1) + 64;
  }
  else {
    uint64_t v3 = 0;
  }
  if (!a2)
  {
    uint64_t v6 = 0;
    goto LABEL_14;
  }
  if (a2 >= 8)
  {
    uint64_t v4 = a2 & 0xFFFFFFF8;
    int32x4_t v7 = (int32x4_t *)(v3 + 64);
    int32x4_t v8 = 0uLL;
    uint64_t v9 = v4;
    int32x4_t v10 = 0uLL;
    do
    {
      int32x4_t v8 = vaddq_s32(v7[-1], v8);
      int32x4_t v10 = vaddq_s32(*v7, v10);
      v7 += 2;
      v9 -= 8;
    }
    while (v9);
    unsigned int v5 = vaddvq_s32(vaddq_s32(v10, v8));
    if (v4 == a2) {
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v4 = 0;
    unsigned int v5 = 0;
  }
  uint64_t v11 = a2 - v4;
  uint64_t v12 = (int *)(v3 + 4 * v4 + 48);
  do
  {
    int v13 = *v12++;
    v5 += v13;
    --v11;
  }
  while (v11);
LABEL_13:
  uint64_t v6 = v5;
LABEL_14:
  if ((v2 & 0x800000) != 0) {
    return *(void *)(*(void *)this + 72) + 32 * v6;
  }
  else {
    return 32 * v6;
  }
}

uint64_t mlir::mps::GRUGradientOp::getGradientInputState(mlir::mps::GRUGradientOp *this)
{
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v1 = *(void *)this - 16;
  }
  else {
    uint64_t v1 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v1, 2);

  return mlir::detail::OpResultImpl::getNextResultAtOffset(NextResultAtOffset, 0);
}

uint64_t mlir::mps::GRUGradientOp::getGradientBias(mlir::mps::GRUGradientOp *this)
{
  int v1 = *(_DWORD *)(*(void *)this + 36);
  if (v1) {
    uint64_t v2 = *(void *)this - 16;
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 3);
  uint64_t v4 = 0;
  if (v1 != 3) {
    return mlir::detail::OpResultImpl::getNextResultAtOffset(NextResultAtOffset, 0);
  }
  return v4;
}

BOOL mlir::mps::GRUGradientOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v70 = v6;
  if (!v6)
  {
    a3(v74, a4);
    if (v74[0])
    {
      LODWORD(v71) = 3;
      char v72 = "expected DictionaryAttr to set properties";
      uint64_t v73 = 41;
      uint64_t v26 = &v71;
      char v27 = (char *)v75;
      if (v76 >= v77)
      {
        unint64_t v60 = v76 + 1;
        if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
        {
          int64_t v65 = (char *)&v71 - (unsigned char *)v75;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v60, 24);
          char v27 = (char *)v75;
          uint64_t v26 = (uint64_t *)((char *)v75 + v65);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v60, 24);
          uint64_t v26 = &v71;
          char v27 = (char *)v75;
        }
      }
      long long v28 = &v27[24 * v76];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)long long v28 = v29;
      ++v76;
      if (v74[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
      }
    }
    if (!v83) {
      return 0;
    }
    uint64_t v30 = (void **)__p;
    if (__p)
    {
      uint64_t v31 = v82;
      long long v32 = __p;
      if (v82 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        long long v32 = __p;
      }
      unsigned int v82 = v30;
      operator delete(v32);
    }
    int v21 = v79;
    if (!v79) {
      goto LABEL_64;
    }
    uint64_t v33 = v80;
    long long v23 = v79;
    if (v80 == v79)
    {
LABEL_63:
      char v80 = v21;
      operator delete(v23);
LABEL_64:
      if (v75 != v78) {
        free(v75);
      }
      return 0;
    }
    do
    {
      int64_t v35 = (void *)*--v33;
      unint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
LABEL_62:
    long long v23 = v79;
    goto LABEL_63;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v70, "flip_z", 6uLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v74, a4);
      if (v74[0])
      {
        LODWORD(v71) = 3;
        uint64_t v73 = 51;
        int32x4_t v10 = &v71;
        uint64_t v11 = (char *)v75;
        if (v76 >= v77)
        {
          unint64_t v61 = v76 + 1;
          if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
          {
            int64_t v66 = (char *)&v71 - (unsigned char *)v75;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v61, 24);
            uint64_t v11 = (char *)v75;
            int32x4_t v10 = (uint64_t *)((char *)v75 + v66);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v61, 24);
            int32x4_t v10 = &v71;
            uint64_t v11 = (char *)v75;
          }
        }
        uint64_t v12 = &v11[24 * v76];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = v10[2];
        *(_OWORD *)uint64_t v12 = v13;
        ++v76;
        if (v74[0])
        {
          int v14 = &v71;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v71, v9);
          uint64_t v15 = (char *)v75;
          if (v76 >= v77)
          {
            unint64_t v62 = v76 + 1;
            if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
            {
              int64_t v67 = (char *)&v71 - (unsigned char *)v75;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v62, 24);
              uint64_t v15 = (char *)v75;
              int v14 = (uint64_t *)((char *)v75 + v67);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v62, 24);
              int v14 = &v71;
              uint64_t v15 = (char *)v75;
            }
          }
          uint64_t v16 = &v15[24 * v76];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = v14[2];
          *(_OWORD *)uint64_t v16 = v17;
          ++v76;
          if (v74[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
          }
        }
      }
      if (!v83) {
        return 0;
      }
      uint64_t v18 = (void **)__p;
      if (__p)
      {
        unint64_t v19 = v82;
        int v20 = __p;
        if (v82 != __p)
        {
          do
            unint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          int v20 = __p;
        }
        unsigned int v82 = v18;
        operator delete(v20);
      }
      int v21 = v79;
      if (!v79) {
        goto LABEL_64;
      }
      uint64_t v22 = v80;
      long long v23 = v79;
      if (v80 == v79) {
        goto LABEL_63;
      }
      do
      {
        unint64_t v25 = (void *)*--v22;
        uint64_t v24 = v25;
        *uint64_t v22 = 0;
        if (v25) {
          operator delete[](v24);
        }
      }
      while (v22 != v21);
      goto LABEL_62;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v70, "gate_layout", 0xBuLL);
  if (v36)
  {
    uint64_t v37 = v36;
    if (*(_UNKNOWN **)(*(void *)v36 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id)
    {
      a3(v74, a4);
      if (v74[0])
      {
        LODWORD(v71) = 3;
        uint64_t v73 = 56;
        unint64_t v38 = &v71;
        uint64_t v39 = (char *)v75;
        if (v76 >= v77)
        {
          unint64_t v63 = v76 + 1;
          if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
          {
            int64_t v68 = (char *)&v71 - (unsigned char *)v75;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v63, 24);
            uint64_t v39 = (char *)v75;
            unint64_t v38 = (uint64_t *)((char *)v75 + v68);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v63, 24);
            unint64_t v38 = &v71;
            uint64_t v39 = (char *)v75;
          }
        }
        unint64_t v40 = &v39[24 * v76];
        long long v41 = *(_OWORD *)v38;
        *((void *)v40 + 2) = v38[2];
        *(_OWORD *)unint64_t v40 = v41;
        ++v76;
        if (v74[0])
        {
          uint64_t v42 = &v71;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v71, v37);
          __int16 v43 = (char *)v75;
          if (v76 >= v77)
          {
            unint64_t v64 = v76 + 1;
            if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
            {
              int64_t v69 = (char *)&v71 - (unsigned char *)v75;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v64, 24);
              __int16 v43 = (char *)v75;
              uint64_t v42 = (uint64_t *)((char *)v75 + v69);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v64, 24);
              uint64_t v42 = &v71;
              __int16 v43 = (char *)v75;
            }
          }
          unint64_t v44 = &v43[24 * v76];
          long long v45 = *(_OWORD *)v42;
          *((void *)v44 + 2) = v42[2];
          *(_OWORD *)unint64_t v44 = v45;
          ++v76;
          if (v74[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
          }
        }
      }
      if (!v83) {
        return 0;
      }
      BOOL v46 = (void **)__p;
      if (__p)
      {
        unint64_t v47 = v82;
        BOOL v48 = __p;
        if (v82 != __p)
        {
          do
            unint64_t v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
          while (v47 != v46);
          BOOL v48 = __p;
        }
        unsigned int v82 = v46;
        operator delete(v48);
      }
      int v21 = v79;
      if (!v79) {
        goto LABEL_64;
      }
      unint64_t v49 = v80;
      long long v23 = v79;
      if (v80 == v79) {
        goto LABEL_63;
      }
      do
      {
        int64_t v51 = (void *)*--v49;
        int64_t v50 = v51;
        void *v49 = 0;
        if (v51) {
          operator delete[](v50);
        }
      }
      while (v49 != v21);
      goto LABEL_62;
    }
    a1[1] = v36;
  }
  uint64_t v52 = mlir::DictionaryAttr::get((uint64_t)&v70, "ogate_activation", 0x10uLL);
  uint64_t v71 = v52;
  if (v52)
  {
    if (*(_UNKNOWN **)(*(void *)v52 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v74, a4);
LABEL_82:
      uint64_t v55 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v74, v53);
      goto LABEL_83;
    }
    a1[2] = v52;
  }
  uint64_t v54 = mlir::DictionaryAttr::get((uint64_t)&v70, "reset_after", 0xBuLL);
  uint64_t v71 = v54;
  if (v54)
  {
    if (*(_UNKNOWN **)(*(void *)v54 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v74, a4);
LABEL_83:
      mlir::InFlightDiagnostic::append<mlir::Attribute>(v55, &v71);
LABEL_84:
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v74);
      return 0;
    }
    a1[3] = v54;
  }
  uint64_t v56 = mlir::DictionaryAttr::get((uint64_t)&v70, "rgate_activation", 0x10uLL);
  uint64_t v71 = v56;
  if (v56)
  {
    if (*(_UNKNOWN **)(*(void *)v56 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v74, a4);
      goto LABEL_82;
    }
    a1[4] = v56;
  }
  uint64_t v57 = mlir::DictionaryAttr::get((uint64_t)&v70, "zgate_activation", 0x10uLL);
  uint64_t v71 = v57;
  if (v57)
  {
    if (*(_UNKNOWN **)(*(void *)v57 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v74, a4);
      goto LABEL_82;
    }
    a1[5] = v57;
  }
  uint64_t v59 = (void *)mlir::DictionaryAttr::get((uint64_t)&v70, "operandSegmentSizes", 0x13uLL);
  if (!v59)
  {
    uint64_t v59 = (void *)mlir::DictionaryAttr::get((uint64_t)&v70, "operand_segment_sizes", 0x15uLL);
    if (!v59)
    {
      a3(v74, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v74, "expected key entry for operandSegmentSizes in DictionaryAttr to set Properties.");
      goto LABEL_84;
    }
  }
  return mlir::convertFromAttribute(a1 + 6, (const char *)7, v59, a3, a4) != 0;
}

uint64_t mlir::mps::GRUGradientOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v53[6] = *MEMORY[0x1E4F143B8];
  int64_t v50 = a1;
  int64_t v51 = v53;
  uint64_t v52 = 0x300000000;
  if (*a2)
  {
    uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v50, (uint64_t)"flip_z", 6, *a2);
    uint64_t v6 = v5;
    unsigned int v7 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      unsigned int v7 = v52;
    }
    uint64_t v8 = (uint64_t *)((char *)v51 + 16 * v7);
    uint64_t *v8 = NamedAttr;
    v8[1] = v6;
    LODWORD(v52) = v52 + 1;
  }
  uint64_t v9 = a2[1];
  if (v9)
  {
    uint64_t v10 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"gate_layout", 11, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      unsigned int v13 = v52;
    }
    int v14 = (uint64_t *)((char *)v51 + 16 * v13);
    *int v14 = v10;
    v14[1] = v12;
    LODWORD(v52) = v52 + 1;
  }
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"ogate_activation", 16, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      unsigned int v19 = v52;
    }
    int v20 = (uint64_t *)((char *)v51 + 16 * v19);
    *int v20 = v16;
    v20[1] = v18;
    LODWORD(v52) = v52 + 1;
  }
  uint64_t v21 = a2[3];
  if (v21)
  {
    uint64_t v22 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"reset_after", 11, v21);
    uint64_t v24 = v23;
    unsigned int v25 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      unsigned int v25 = v52;
    }
    uint64_t v26 = (uint64_t *)((char *)v51 + 16 * v25);
    *uint64_t v26 = v22;
    v26[1] = v24;
    LODWORD(v52) = v52 + 1;
  }
  uint64_t v27 = a2[4];
  if (v27)
  {
    uint64_t v28 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"rgate_activation", 16, v27);
    uint64_t v30 = v29;
    unsigned int v31 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      unsigned int v31 = v52;
    }
    long long v32 = (uint64_t *)((char *)v51 + 16 * v31);
    *long long v32 = v28;
    v32[1] = v30;
    LODWORD(v52) = v52 + 1;
  }
  uint64_t v33 = a2[5];
  if (v33)
  {
    uint64_t v34 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"zgate_activation", 16, v33);
    uint64_t v36 = v35;
    unsigned int v37 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      unsigned int v37 = v52;
    }
    unint64_t v38 = (uint64_t *)((char *)v51 + 16 * v37);
    uint64_t *v38 = v34;
    v38[1] = v36;
    LODWORD(v52) = v52 + 1;
  }
  uint64_t v39 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 6), 7);
  uint64_t v40 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"operandSegmentSizes", 19, v39);
  uint64_t v42 = v41;
  unsigned int v43 = v52;
  if (v52 >= HIDWORD(v52))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
    unsigned int v43 = v52;
  }
  unint64_t v44 = (uint64_t *)((char *)v51 + 16 * v43);
  uint64_t *v44 = v40;
  v44[1] = v42;
  BOOL v45 = __CFADD__(v52, 1);
  uint64_t v46 = (v52 + 1);
  LODWORD(v52) = v52 + 1;
  if (v45)
  {
    uint64_t DictionaryAttr = 0;
    BOOL v48 = v51;
    if (v51 == v53) {
      return DictionaryAttr;
    }
    goto LABEL_32;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v50, (uint64_t *)v51, v46);
  BOOL v48 = v51;
  if (v51 != v53) {
LABEL_32:
  }
    free(v48);
  return DictionaryAttr;
}

unint64_t mlir::mps::GRUGradientOp::computePropertiesHash(unint64_t *a1)
{
  uint64_t v87 = *MEMORY[0x1E4F143B8];
  unint64_t v1 = *a1;
  unint64_t v2 = 0x1E8EB8000uLL;
  {
    unint64_t v62 = a1;
    unint64_t v69 = v1;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v28 = v27;
    a1 = v62;
    unint64_t v1 = v69;
    if (v28)
    {
      unint64_t v29 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v29 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v29;
      a1 = v62;
      unint64_t v1 = v69;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  uint64_t v3 = *(void *)(v2 + 3024);
  unint64_t v4 = a1[1];
  {
    unint64_t v63 = a1;
    unint64_t v70 = v1;
    unint64_t v50 = v4;
    uint64_t v55 = v3;
    unint64_t v4 = v50;
    uint64_t v3 = v55;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v31 = v30;
    a1 = v63;
    unint64_t v1 = v70;
    if (v31)
    {
      unint64_t v32 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v32 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v32;
      unint64_t v4 = v50;
      uint64_t v3 = v55;
      a1 = v63;
      unint64_t v1 = v70;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v5 = HIDWORD(v4);
  unint64_t v6 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v4) ^ HIDWORD(v4));
  unint64_t v82 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) ^ ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) >> 47));
  unint64_t v7 = a1[2];
  {
    unint64_t v64 = a1;
    unint64_t v71 = v1;
    unint64_t v51 = v7;
    uint64_t v56 = v3;
    unint64_t v7 = v51;
    uint64_t v3 = v56;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v34 = v33;
    a1 = v64;
    unint64_t v1 = v71;
    if (v34)
    {
      unint64_t v35 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v35 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v35;
      unint64_t v7 = v51;
      uint64_t v3 = v56;
      a1 = v64;
      unint64_t v1 = v71;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v8 = HIDWORD(v7);
  unint64_t v9 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v7) ^ HIDWORD(v7));
  unint64_t v81 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
  unint64_t v10 = a1[3];
  {
    int64_t v65 = a1;
    unint64_t v72 = v1;
    unint64_t v52 = v10;
    uint64_t v57 = v3;
    unint64_t v10 = v52;
    uint64_t v3 = v57;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v37 = v36;
    a1 = v65;
    unint64_t v1 = v72;
    if (v37)
    {
      unint64_t v38 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v38 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v38;
      unint64_t v10 = v52;
      uint64_t v3 = v57;
      a1 = v65;
      unint64_t v1 = v72;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v11 = HIDWORD(v10);
  unint64_t v12 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v10) ^ HIDWORD(v10));
  unint64_t v80 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v11 ^ (v12 >> 47) ^ v12)) ^ ((0x9DDFEA08EB382D69 * (v11 ^ (v12 >> 47) ^ v12)) >> 47));
  unint64_t v13 = a1[4];
  {
    int64_t v66 = a1;
    unint64_t v73 = v1;
    unint64_t v53 = v13;
    uint64_t v58 = v3;
    unint64_t v13 = v53;
    uint64_t v3 = v58;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v40 = v39;
    a1 = v66;
    unint64_t v1 = v73;
    if (v40)
    {
      unint64_t v41 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v41 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v41;
      unint64_t v13 = v53;
      uint64_t v3 = v58;
      a1 = v66;
      unint64_t v1 = v73;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v14 = HIDWORD(v13);
  unint64_t v15 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v13) ^ HIDWORD(v13));
  unint64_t v79 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v14 ^ (v15 >> 47) ^ v15)) ^ ((0x9DDFEA08EB382D69 * (v14 ^ (v15 >> 47) ^ v15)) >> 47));
  unint64_t v16 = a1[5];
  {
    int64_t v67 = a1;
    unint64_t v74 = v1;
    unint64_t v54 = v16;
    uint64_t v59 = v3;
    unint64_t v16 = v54;
    uint64_t v3 = v59;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v43 = v42;
    a1 = v67;
    unint64_t v1 = v74;
    if (v43)
    {
      unint64_t v44 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v44 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v44;
      unint64_t v16 = v54;
      uint64_t v3 = v59;
      a1 = v67;
      unint64_t v1 = v74;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v17 = HIDWORD(v16);
  unint64_t v18 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v16) ^ HIDWORD(v16));
  unint64_t v78 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v17 ^ (v18 >> 47) ^ v18)) ^ ((0x9DDFEA08EB382D69 * (v17 ^ (v18 >> 47) ^ v18)) >> 47));
  {
    int64_t v68 = a1;
    unint64_t v75 = v1;
    uint64_t v60 = v3;
    unint64_t v1 = v75;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v46 = v45;
    uint64_t v3 = v60;
    a1 = v68;
    if (v46)
    {
      unint64_t v47 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v47 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v47;
      uint64_t v3 = v60;
      a1 = v68;
      unint64_t v1 = v75;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  uint64_t v19 = *(void *)(v2 + 3024);
  unint64_t v20 = a1[7];
  unint64_t v21 = 0x9AE16A3B2F90404FLL * *(unint64_t *)((char *)a1 + 68);
  uint64_t v22 = __ROR8__(0xB492B66FBE98F273 * a1[6] - v20, 43)
      - 0x3C5A37A36834CED9 * *(unint64_t *)((char *)a1 + 60)
      + __ROR8__(v21 ^ v19, 30);
  uint64_t v23 = v19 + __ROR8__(v20 ^ 0xC949D7C7509E6557, 20) - 0x4B6D499041670D8DLL * a1[6] - v21 + 28;
  unint64_t v77 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v23 ^ ((0x9DDFEA08EB382D69 * (v22 ^ v23)) >> 47) ^ (0x9DDFEA08EB382D69 * (v22 ^ v23)))) ^ ((0x9DDFEA08EB382D69 * (v23 ^ ((0x9DDFEA08EB382D69 * (v22 ^ v23)) >> 47) ^ (0x9DDFEA08EB382D69 * (v22 ^ v23)))) >> 47));
  uint64_t v85 = 0;
  memset(v84, 0, sizeof(v84));
  memset(v83, 0, sizeof(v83));
  {
    unint64_t v76 = v1;
    uint64_t v61 = v3;
    uint64_t v3 = v61;
    unint64_t v1 = v76;
    unint64_t v2 = 0x1E8EB8000uLL;
    if (v48)
    {
      unint64_t v49 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v49 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v49;
      uint64_t v3 = v61;
      unint64_t v1 = v76;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v24 = HIDWORD(v1);
  unint64_t v25 = 0x9DDFEA08EB382D69 * ((v3 + 8 * v1) ^ HIDWORD(v1));
  uint64_t v86 = *(void *)(v2 + 3024);
  *(void *)&v83[0] = 0x9DDFEA08EB382D69
                     * ((0x9DDFEA08EB382D69 * (v24 ^ (v25 >> 47) ^ v25)) ^ ((0x9DDFEA08EB382D69
                                                                             * (v24 ^ (v25 >> 47) ^ v25)) >> 47));
  return llvm::hashing::detail::hash_combine_recursive_helper::combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>((llvm::hashing::detail::hash_combine_recursive_helper *)v83, 0, (void *)v83 + 1, (char *)v84, (uint64_t *)&v82, (uint64_t *)&v81, (uint64_t *)&v80, (uint64_t *)&v79, (uint64_t *)&v78, (uint64_t *)&v77);
}

uint64_t mlir::mps::GRUGradientOp::getInherentAttr(mlir::MLIRContext *a1, void *a2, _WORD *__s1, size_t __n)
{
  uint64_t result = 0;
  switch(__n)
  {
    case 6uLL:
      if (*(_DWORD *)__s1 != 1885957222 || __s1[2] != 31327) {
        goto LABEL_20;
      }
      return *a2;
    case 7uLL:
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0xFuLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x14uLL:
      goto LABEL_20;
    case 0xBuLL:
      if (!memcmp(__s1, "gate_layout", __n))
      {
        uint64_t result = a2[1];
      }
      else
      {
        if (memcmp(__s1, "reset_after", __n)) {
          goto LABEL_20;
        }
        uint64_t result = a2[3];
      }
      break;
    case 0x10uLL:
      if (!memcmp(__s1, "ogate_activation", __n))
      {
        uint64_t result = a2[2];
      }
      else if (!memcmp(__s1, "rgate_activation", __n))
      {
        uint64_t result = a2[4];
      }
      else if (*(void *)__s1 == 0x63615F657461677ALL && *((void *)__s1 + 1) == 0x6E6F697461766974)
      {
        uint64_t result = a2[5];
      }
      else
      {
LABEL_20:
        uint64_t result = 0;
      }
      break;
    case 0x13uLL:
      if (memcmp(__s1, "operandSegmentSizes", __n)) {
        goto LABEL_20;
      }
      return mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 6), 7);
    case 0x15uLL:
      if (memcmp(__s1, "operand_segment_sizes", __n)) {
        goto LABEL_20;
      }
      return mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 6), 7);
    default:
      return result;
  }
  return result;
}

uint64_t mlir::mps::GRUGradientOp::setInherentAttr(uint64_t result, _WORD *__s1, size_t __n, void *a4)
{
  unint64_t v7 = (void *)result;
  switch(__n)
  {
    case 6uLL:
      if (*(_DWORD *)__s1 == 1885957222 && __s1[2] == 31327)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
            unint64_t v14 = a4;
          }
          else {
            unint64_t v14 = 0;
          }
          *(void *)uint64_t result = v14;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xBuLL:
      uint64_t result = memcmp(__s1, "gate_layout", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "reset_after", __n);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
              unint64_t v9 = a4;
            }
            else {
              unint64_t v9 = 0;
            }
            v7[3] = v9;
          }
          else
          {
            v7[3] = 0;
          }
        }
      }
      else if (a4)
      {
        if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id) {
          unint64_t v15 = a4;
        }
        else {
          unint64_t v15 = 0;
        }
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "ogate_activation", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "rgate_activation", __n);
        if (result)
        {
          if (*(void *)__s1 == 0x63615F657461677ALL && *((void *)__s1 + 1) == 0x6E6F697461766974)
          {
            if (a4)
            {
              if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
                unint64_t v11 = a4;
              }
              else {
                unint64_t v11 = 0;
              }
              v7[5] = v11;
            }
            else
            {
              v7[5] = 0;
            }
          }
        }
        else if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
            unint64_t v17 = a4;
          }
          else {
            unint64_t v17 = 0;
          }
          v7[4] = v17;
        }
        else
        {
          v7[4] = 0;
        }
      }
      else if (a4)
      {
        if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
          unint64_t v16 = a4;
        }
        else {
          unint64_t v16 = 0;
        }
        v7[2] = v16;
      }
      else
      {
        v7[2] = 0;
      }
      break;
    case 0x13uLL:
      uint64_t result = memcmp(__s1, "operandSegmentSizes", __n);
      if (!result) {
        goto LABEL_29;
      }
      break;
    case 0x15uLL:
      uint64_t result = memcmp(__s1, "operand_segment_sizes", __n);
      if (!result)
      {
LABEL_29:
        if (a4)
        {
          uint64_t result = mlir::detail::DenseArrayAttrImpl<int>::classof(a4);
          unint64_t v12 = result ? a4 : 0;
          unint64_t v18 = v12;
          if (result)
          {
            uint64_t result = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v18);
            if (result == 7)
            {
              uint64_t result = mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v18);
              if (v13) {
                uint64_t result = (uint64_t)memmove(v7 + 6, (const void *)result, 4 * v13);
              }
            }
          }
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::GRUGradientOp::populateInherentAttrs(mlir::MLIRContext *a1, uint64_t *a2, uint64_t a3)
{
  if (*a2) {
    mlir::NamedAttrList::append(a3, (uint64_t)"flip_z", 6, *a2);
  }
  uint64_t v6 = a2[1];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"gate_layout", 11, v6);
  }
  uint64_t v7 = a2[2];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"ogate_activation", 16, v7);
  }
  uint64_t v8 = a2[3];
  if (v8) {
    mlir::NamedAttrList::append(a3, (uint64_t)"reset_after", 11, v8);
  }
  uint64_t v9 = a2[4];
  if (v9) {
    mlir::NamedAttrList::append(a3, (uint64_t)"rgate_activation", 16, v9);
  }
  uint64_t v10 = a2[5];
  if (v10) {
    mlir::NamedAttrList::append(a3, (uint64_t)"zgate_activation", 16, v10);
  }
  uint64_t v11 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 6), 7);

  mlir::NamedAttrList::append(a3, (uint64_t)"operandSegmentSizes", 19, v11);
}

BOOL mlir::mps::GRUGradientOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v8, (const void **)"flip_z", (const char *)6, a3, a4))
  {
    uint64_t v9 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps29(v9, (const void **)"gate_layout", (const char *)0xB, a3, a4))
    {
      uint64_t v10 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v10, (const void **)"ogate_activation", (const char *)0x10, a3, a4))
      {
        uint64_t v11 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 24));
        if (!v11
          || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v11, (const void **)"reset_after", (const char *)0xB, a3, a4))
        {
          uint64_t v12 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v12, (const void **)"rgate_activation", (const char *)0x10, a3, a4))
          {
            uint64_t v13 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v13, (const void **)"zgate_activation", (const char *)0x10, a3, a4))
            {
              return 1;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps29(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    int v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    uint64_t v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = (char *)v35;
        uint64_t v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        uint64_t v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      unint64_t v29 = a2;
      int v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        int v30 = "' failed to satisfy constraint: valid GRU gate layout";
        uint64_t v31 = 53;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        uint64_t v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)uint64_t v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    unint64_t v16 = (void **)__p;
    if (__p)
    {
      unint64_t v17 = v42;
      unint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          unint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        unint64_t v18 = __p;
      }
      int v42 = v16;
      operator delete(v18);
    }
    uint64_t v19 = v39;
    if (v39)
    {
      unint64_t v20 = v40;
      unint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = (void *)*--v20;
          uint64_t v22 = v23;
          *unint64_t v20 = 0;
          if (v23) {
            operator delete[](v22);
          }
        }
        while (v20 != v19);
        unint64_t v21 = v39;
      }
      int v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    int v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    uint64_t v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = (char *)v35;
        uint64_t v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        uint64_t v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      unint64_t v29 = a2;
      int v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        int v30 = "' failed to satisfy constraint: valid RNN activation";
        uint64_t v31 = 52;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        uint64_t v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)uint64_t v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    unint64_t v16 = (void **)__p;
    if (__p)
    {
      unint64_t v17 = v42;
      unint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          unint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        unint64_t v18 = __p;
      }
      int v42 = v16;
      operator delete(v18);
    }
    uint64_t v19 = v39;
    if (v39)
    {
      unint64_t v20 = v40;
      unint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = (void *)*--v20;
          uint64_t v22 = v23;
          *unint64_t v20 = 0;
          if (v23) {
            operator delete[](v22);
          }
        }
        while (v20 != v19);
        unint64_t v21 = v39;
      }
      int v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

BOOL mlir::mps::GRUGradientOp::readProperties(uint64_t a1, void *a2)
{
  v10[24] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties>(a2);
  if (!mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::GRUGateLayoutAttr>(a1, v3 + 1)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 2))
  {
    return 0;
  }
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) <= 5)
  {
    uint64_t v9 = 0;
    if (!mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<int>>(a1, &v9)) {
      return 0;
    }
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v9) >= 8)
    {
      v7[0] = (uint64_t)"size mismatch for operand/result_segment_size";
      __int16 v8 = 259;
      (*(void (**)(void *__return_ptr, uint64_t, uint64_t *))(*(void *)a1 + 16))(v10, a1, v7);
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v10);
      return 0;
    }
    unint64_t v4 = (const void *)mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v9);
    if (v5) {
      memmove(v3 + 6, v4, 4 * v5);
    }
  }
  if (mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 3)
    && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 4)
    && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 5))
  {
    v7[0] = a1;
    v7[1] = (uint64_t)(v3 + 6);
    return mlir::mps::GRUGradientOp::readProperties(mlir::DialectBytecodeReader &,mlir::OperationState &)::$_0::operator()(v7) != 0;
  }
  return 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x50uLL);
    *uint64_t v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    v3[3] = 0u;
    *(_OWORD *)((char *)v3 + 60) = 0u;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 112;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        __int16 v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[67];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::GRUGateLayoutAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  if (!v39) {
    return 1;
  }
  int v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id) {
    return 1;
  }
  unsigned char v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    unint64_t v6 = &v40;
    unint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v7 = (char *)v46;
        unint64_t v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v6 = &v40;
        unint64_t v7 = (char *)v46;
      }
    }
    __int16 v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)__int16 v8 = v9;
    ++v47;
  }
  int v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::GRUGateLayoutAttr]";
  unint64_t v41 = 78;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    int v40 = (const void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      unint64_t v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          unint64_t v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          unint64_t v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      unint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)unint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        unint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        uint64_t v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v19 = (char *)v46;
            unint64_t v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unint64_t v18 = &v40;
            uint64_t v19 = (char *)v46;
          }
        }
        unint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)unint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = (void **)__p;
    if (__p)
    {
      unint64_t v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          unint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      unint64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          int v30 = (void *)*--v27;
          unint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            operator delete[](v29);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      unint64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  if (!v39) {
    return 1;
  }
  int v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
    return 1;
  }
  unsigned char v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    unint64_t v6 = &v40;
    unint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v7 = (char *)v46;
        unint64_t v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v6 = &v40;
        unint64_t v7 = (char *)v46;
      }
    }
    __int16 v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)__int16 v8 = v9;
    ++v47;
  }
  int v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::RNNActivationAttr]";
  unint64_t v41 = 78;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    int v40 = (const void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      unint64_t v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          unint64_t v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          unint64_t v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      unint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)unint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        unint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        uint64_t v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v19 = (char *)v46;
            unint64_t v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unint64_t v18 = &v40;
            uint64_t v19 = (char *)v46;
          }
        }
        unint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)unint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = (void **)__p;
    if (__p)
    {
      unint64_t v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          unint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      unint64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          int v30 = (void *)*--v27;
          unint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            operator delete[](v29);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      unint64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

uint64_t mlir::mps::GRUGradientOp::readProperties(mlir::DialectBytecodeReader &,mlir::OperationState &)::$_0::operator()(uint64_t *a1)
{
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)*a1 + 40))(*a1) < 6) {
    return 1;
  }
  uint64_t v2 = *a1;
  uint64_t v3 = (_DWORD *)a1[1];

  return mlir::DialectBytecodeReader::readSparseArray<int>(v2, v3, (const char *)7);
}

uint64_t mlir::mps::GRUGradientOp::writeProperties(uint64_t a1, uint64_t a2)
{
  if (HIBYTE(*(_DWORD *)(*(void *)a1 + 44))) {
    unint64_t v4 = *(void *)a1 + 16 * (((unint64_t)*(unsigned int *)(*(void *)a1 + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)v4);
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 8));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 16));
  if ((*(uint64_t (**)(uint64_t))(*(void *)a2 + 104))(a2) <= 5)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(*(void *)a1 + 24));
    uint64_t v6 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v4 + 48, 7);
    (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, v6);
  }
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 24));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 32));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 40));
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 104))(a2);
  if (result >= 6)
  {
    return mlir::DialectBytecodeWriter::writeSparseArray<int>(a2, (int *)(v4 + 48), 7);
  }
  return result;
}

void mlir::mps::GRUGradientOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, unsigned int a8, unsigned int a9, unsigned int a10, char a11, char a12, uint64_t a13, uint64_t a14, BOOL a15)
{
  BOOL v19 = a15;
  void v61[2] = *MEMORY[0x1E4F143B8];
  uint64_t v54 = a4;
  uint64_t v55 = a3;
  uint64_t v52 = a6;
  uint64_t v53 = a5;
  uint64_t v50 = a14;
  uint64_t v51 = a13;
  BOOL v49 = a15;
  mlir::OperationState::addOperands(a2, (uint64_t)&v55, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v54, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v53, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v52, 1);
  if (a13) {
    mlir::OperationState::addOperands(a2, (uint64_t)&v51, 1);
  }
  if (a14) {
    mlir::OperationState::addOperands(a2, (uint64_t)&v50, 1);
  }
  if (a15)
  {
    mlir::OperationState::addOperands(a2, (uint64_t)&v49, 1);
    BOOL v19 = v49;
  }
  BOOL v20 = v51 != 0;
  BOOL v21 = v50 != 0;
  uint64_t v22 = mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties>((void *)a2);
  *(void *)&long long v23 = 0x100000001;
  *((void *)&v23 + 1) = 0x100000001;
  *(_OWORD *)(v22 + 48) = v23;
  *(_DWORD *)(v22 + 64) = v20;
  *(_DWORD *)(v22 + 68) = v21;
  *(_DWORD *)(v22 + 72) = v19;
  unint64_t v24 = *a1;
  unsigned int v56 = a7;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v24);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  uint64_t v60 = (uint64_t)v24;
  uint64_t v26 = mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v56);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 40) = v26;
  int64_t v27 = *a1;
  unsigned int v56 = a8;
  int64_t v28 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v27);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  uint64_t v60 = (uint64_t)v27;
  uint64_t v29 = mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v28, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v56);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 32) = v29;
  int v30 = *a1;
  unsigned int v56 = a9;
  uint64_t v31 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v30);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  uint64_t v60 = (uint64_t)v30;
  uint64_t v32 = mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v31, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v56);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 16) = v32;
  unint64_t v33 = *a1;
  unsigned int v56 = a10;
  unint64_t v34 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v33);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id;
  uint64_t v60 = (uint64_t)v33;
  uint64_t v35 = mlir::StorageUniquer::get<mlir::mps::detail::GRUGateLayoutAttrStorage,mlir::mps::GRUGateLayout>(v34, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24GRUGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17GRUGateLayoutAttrEJNS2_13GRUGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id, &v56);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = v35;
  if (a11)
  {
    uint64_t UnitAttr = mlir::Builder::getUnitAttr(a1, v36);
    *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties>((void *)a2)
              + 24) = UnitAttr;
  }
  if (a12)
  {
    uint64_t v38 = mlir::Builder::getUnitAttr(a1, v36);
    *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties>((void *)a2) = v38;
  }
  __src = v61;
  uint64_t v60 = 0x200000000;
  uint64_t v39 = *(void *)a2;
  mlir::ValueRange::ValueRange(v58, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v42 = *(long long **)(a2 + 256);
  __int16 v43 = mlir::ValueRange::ValueRange(v57, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::GRUGradientOp::inferReturnTypes((uint64_t)v43, v39, 1, v58[0], v58[1], Dictionary, v42, v44, v57[0], v57[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v45 = __src;
  }
  uint64_t v46 = v60;
  uint64_t v47 = *(unsigned int *)(a2 + 72);
  unint64_t v48 = v47 + v60;
  if (v48 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v48, 8);
    LODWORD(v47) = *(_DWORD *)(a2 + 72);
  }
  if (v46)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v47), v45, 8 * v46);
    LODWORD(v47) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v47 + v46;
  if (__src != v61) {
    free(__src);
  }
}

mlir::MLIRContext *mlir::mps::GRUGradientOp::populateDefaultProperties(uint64_t a1, void *a2)
{
  unint64_t v10 = *(void **)(a1 + 8);
  uint64_t result = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v10);
  unint64_t v4 = result;
  if (a2[5])
  {
    if (a2[4]) {
      goto LABEL_3;
    }
  }
  else
  {
    unsigned int v9 = 3;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(result);
    unint64_t v10 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
    unint64_t v11 = v4;
    uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v10, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v9);
    a2[5] = result;
    if (a2[4])
    {
LABEL_3:
      if (a2[2]) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  unsigned int v9 = 3;
  uint64_t v6 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  unint64_t v10 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  unint64_t v11 = v4;
  uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v6, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v10, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v9);
  a2[4] = result;
  if (a2[2])
  {
LABEL_4:
    if (a2[1]) {
      return result;
    }
LABEL_9:
    unsigned int v9 = 0;
    __int16 v8 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
    unint64_t v10 = &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id;
    unint64_t v11 = v4;
    uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::GRUGateLayoutAttrStorage,mlir::mps::GRUGateLayout>(v8, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24GRUGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17GRUGateLayoutAttrEJNS2_13GRUGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v10, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id, &v9);
    a2[1] = result;
    return result;
  }
LABEL_8:
  unsigned int v9 = 2;
  unint64_t v7 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  unint64_t v10 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  unint64_t v11 = v4;
  uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v7, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v10, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v9);
  a2[2] = result;
  if (!a2[1]) {
    goto LABEL_9;
  }
  return result;
}

uint64_t mlir::mps::GRUGradientOp::verifyInvariantsImpl(uint64_t **this)
{
  v96[24] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    uint64_t v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  uint64_t v7 = v3[2];
  uint64_t v6 = v3[3];
  uint64_t v9 = v3[4];
  uint64_t v8 = v3[5];
  v96[0] = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v8, (const void **)"zgate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v96))return 0; {
  v96[0] = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v9, (const void **)"rgate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v96))return 0; {
  v96[0] = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v7, (const void **)"ogate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v96))return 0; {
  v96[0] = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps29(v5, (const void **)"gate_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps29(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v96))return 0; {
  v96[0] = *this;
  }
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v6, (const void **)"reset_after", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v96))return 0; {
  v96[0] = *this;
  }
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v4, (const void **)"flip_z", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v96))return 0; {
  unsigned int v95 = 0;
  }
  unint64_t v10 = *((unsigned int *)*this + 11);
  uint64_t v11 = (uint64_t)&(*this)[2 * ((v10 >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11))) {
    uint64_t v11 = 0;
  }
  uint64_t v12 = *(unsigned int *)(v11 + 48);
  if ((v10 & 0x800000) != 0)
  {
    uint64_t v13 = (*this)[9];
    if (v12) {
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v13 = 0;
    if (v12)
    {
LABEL_14:
      uint64_t v14 = v13 + 24;
      do
      {
        uint64_t v15 = *this;
        unint64_t v16 = *(void *)(*(void *)v14 + 8) & 0xFFFFFFFFFFFFFFF8;
        unsigned int v17 = v95++;
        if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v15, v16, (const void **)"operand", (const void **)7, v17))return 0; {
        v14 += 32;
        }
      }
      while (--v12);
    }
  }
  uint64_t ODSOperands = mlir::mps::GRUGradientOp::getODSOperands((mlir::mps::GRUGradientOp *)this, 1u);
  if (v19)
  {
    uint64_t v20 = v19;
    uint64_t v21 = ODSOperands + 24;
    do
    {
      uint64_t v22 = *this;
      unint64_t v23 = *(void *)(*(void *)v21 + 8) & 0xFFFFFFFFFFFFFFF8;
      unsigned int v24 = v95++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v22, v23, (const void **)"operand", (const void **)7, v24))return 0; {
      v21 += 32;
      }
    }
    while (--v20);
  }
  uint64_t v25 = mlir::mps::GRUGradientOp::getODSOperands((mlir::mps::GRUGradientOp *)this, 2u);
  if (v26)
  {
    uint64_t v27 = v26;
    uint64_t v28 = v25 + 24;
    do
    {
      uint64_t v29 = *this;
      unint64_t v30 = *(void *)(*(void *)v28 + 8) & 0xFFFFFFFFFFFFFFF8;
      unsigned int v31 = v95++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v29, v30, (const void **)"operand", (const void **)7, v31))return 0; {
      v28 += 32;
      }
    }
    while (--v27);
  }
  uint64_t v32 = mlir::mps::GRUGradientOp::getODSOperands((mlir::mps::GRUGradientOp *)this, 3u);
  if (v33)
  {
    uint64_t v34 = v33;
    uint64_t v35 = v32 + 24;
    do
    {
      int64_t v36 = *this;
      unint64_t v37 = *(void *)(*(void *)v35 + 8) & 0xFFFFFFFFFFFFFFF8;
      unsigned int v38 = v95++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v36, v37, (const void **)"operand", (const void **)7, v38))return 0; {
      v35 += 32;
      }
    }
    while (--v34);
  }
  uint64_t v39 = mlir::mps::GRUGradientOp::getODSOperands((mlir::mps::GRUGradientOp *)this, 4u);
  uint64_t v41 = v40;
  if (v40 >= 2) {
    goto LABEL_36;
  }
  if (v40)
  {
    uint64_t v42 = *(void *)(v39 + 24);
    __int16 v43 = *this;
    unint64_t v44 = *(void *)(v42 + 8) & 0xFFFFFFFFFFFFFFF8;
    unsigned int v45 = v95++;
    if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v43, v44, (const void **)"operand", (const void **)7, v45))return 0; {
  }
    }
  uint64_t v46 = mlir::mps::GRUGradientOp::getODSOperands((mlir::mps::GRUGradientOp *)this, 5u);
  uint64_t v41 = v47;
  if (v47 < 2)
  {
    if (!v47
      || (uint64_t v48 = *(void *)(v46 + 24),
          BOOL v49 = *this,
          unint64_t v50 = *(void *)(v48 + 8) & 0xFFFFFFFFFFFFFFF8,
          unsigned int v51 = v95,
          ++v95,
          mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v49, v50, (const void **)"operand", (const void **)7, v51)))
    {
      uint64_t v52 = mlir::mps::GRUGradientOp::getODSOperands((mlir::mps::GRUGradientOp *)this, 6u);
      uint64_t v41 = v53;
      if (v53 >= 2) {
        goto LABEL_36;
      }
      if (!v53
        || (uint64_t v58 = *(void *)(v52 + 24),
            uint64_t v59 = *this,
            unint64_t v60 = *(void *)(v58 + 8) & 0xFFFFFFFFFFFFFFF8,
            unsigned int v61 = v95,
            ++v95,
            mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v59, v60, (const void **)"operand", (const void **)7, v61)))
      {
        unsigned int v95 = 0;
        uint64_t ODSResults = mlir::mps::GRUGradientOp::getODSResults((mlir::mps::GRUGradientOp *)this, 0);
        if (v63)
        {
          uint64_t v64 = ODSResults;
          uint64_t v65 = v63;
          uint64_t v66 = 0;
          while (1)
          {
            uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v64, v66);
            int64_t v68 = *this;
            unint64_t v69 = *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8;
            unsigned int v95 = v66 + 1;
            if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v68, v69, (const void **)"result", (const void **)6, v66))break; {
            if (v65 == ++v66)
            }
              goto LABEL_46;
          }
        }
        else
        {
          LODWORD(v66) = 0;
LABEL_46:
          uint64_t v70 = mlir::mps::GRUGradientOp::getODSResults((mlir::mps::GRUGradientOp *)this, 1u);
          if (v71)
          {
            uint64_t v72 = v70;
            uint64_t v73 = v71;
            uint64_t v74 = 0;
            while (1)
            {
              uint64_t v75 = mlir::detail::OpResultImpl::getNextResultAtOffset(v72, v74);
              unint64_t v76 = *this;
              unint64_t v77 = *(void *)(v75 + 8) & 0xFFFFFFFFFFFFFFF8;
              unsigned int v95 = v66 + v74 + 1;
              if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v76, v77, (const void **)"result", (const void **)6, (int)v66 + (int)v74))break; {
              if (v73 == ++v74)
              }
              {
                LODWORD(v66) = v66 + v74;
                goto LABEL_51;
              }
            }
          }
          else
          {
LABEL_51:
            uint64_t v78 = mlir::mps::GRUGradientOp::getODSResults((mlir::mps::GRUGradientOp *)this, 2u);
            if (v79)
            {
              uint64_t v80 = v78;
              uint64_t v81 = v79;
              uint64_t v82 = 0;
              while (1)
              {
                uint64_t v83 = mlir::detail::OpResultImpl::getNextResultAtOffset(v80, v82);
                uint64_t v84 = *this;
                unint64_t v85 = *(void *)(v83 + 8) & 0xFFFFFFFFFFFFFFF8;
                unsigned int v95 = v66 + v82 + 1;
                if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v84, v85, (const void **)"result", (const void **)6, (int)v66 + (int)v82))break; {
                if (v81 == ++v82)
                }
                {
                  LODWORD(v66) = v66 + v82;
                  goto LABEL_56;
                }
              }
            }
            else
            {
LABEL_56:
              uint64_t v86 = mlir::mps::GRUGradientOp::getODSResults((mlir::mps::GRUGradientOp *)this, 3u);
              uint64_t v88 = v87;
              if (v87 >= 2)
              {
                v93[0] = (const void **)"result group starting at #";
                __int16 v94 = 259;
                mlir::OpState::emitOpError(this, v93, (uint64_t)v96);
                uint64_t v89 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v96, &v95);
                uint64_t v55 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v89, " requires 0 or 1 element, but found ");
                uint64_t v92 = v88;
                goto LABEL_37;
              }
              if (!v87) {
                return 1;
              }
              uint64_t v90 = mlir::detail::OpResultImpl::getNextResultAtOffset(v86, 0);
              if (mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(v90 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, v66))return 1; {
            }
              }
          }
        }
      }
    }
    return 0;
  }
LABEL_36:
  v93[0] = (const void **)"operand group starting at #";
  __int16 v94 = 259;
  mlir::OpState::emitOpError(this, v93, (uint64_t)v96);
  uint64_t v54 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v96, &v95);
  uint64_t v55 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v54, " requires 0 or 1 element, but found ");
  uint64_t v92 = v41;
LABEL_37:
  uint64_t v56 = mlir::InFlightDiagnostic::operator<<<unsigned long &>(v55, &v92);
  uint64_t v57 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v56);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v96);
  return v57;
}

uint64_t mlir::mps::GRUGradientOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.gru_gradient", 16, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC980180;
  v4[12] = mlir::mps::GRUGradientOp::canonicalize;
  uint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::GRUOp::getODSResults(mlir::mps::GRUOp *this, unsigned int a2)
{
  if (a2)
  {
    if (a2 >= 8)
    {
      int32x4_t v4 = (int32x4_t)xmmword_1810FFF10;
      unsigned int v3 = a2 & 0xFFFFFFF8;
      int32x4_t v5 = 0uLL;
      v6.i64[0] = 0x300000003;
      v6.i64[1] = 0x300000003;
      v7.i64[0] = 0x800000008;
      v7.i64[1] = 0x800000008;
      unsigned int v8 = a2 & 0xFFFFFFF8;
      int32x4_t v9 = 0uLL;
      do
      {
        int32x4_t v5 = vsubq_s32(v5, vtstq_s32(v4, v4));
        int32x4_t v9 = vsubq_s32(v9, (int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32(v4, v6)));
        int32x4_t v4 = vaddq_s32(v4, v7);
        v8 -= 8;
      }
      while (v8);
      int v2 = vaddvq_s32(vaddq_s32(v9, v5));
      if (v3 == a2) {
        goto LABEL_11;
      }
    }
    else
    {
      int v2 = 0;
      unsigned int v3 = 0;
    }
    do
    {
      if (v3) {
        ++v2;
      }
      ++v3;
    }
    while (a2 != v3);
  }
  else
  {
    int v2 = 0;
  }
LABEL_11:
  int v10 = *(_DWORD *)(*(void *)this + 36);
  if (v10) {
    uint64_t result = *(void *)this - 16;
  }
  else {
    uint64_t result = 0;
  }
  if (a2 + (v10 - 2) * v2) {
    return mlir::detail::OpResultImpl::getNextResultAtOffset(result, a2 + (v10 - 2) * v2);
  }
  return result;
}

uint64_t mlir::mps::GRUOp::getODSOperands(mlir::mps::GRUOp *this, unsigned int a2)
{
  unint64_t v2 = *(unsigned int *)(*(void *)this + 44);
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v3 = *(void *)this + 16 * ((v2 >> 23) & 1) + 64;
  }
  else {
    uint64_t v3 = 0;
  }
  if (!a2)
  {
    uint64_t v6 = 0;
    goto LABEL_14;
  }
  if (a2 >= 8)
  {
    uint64_t v4 = a2 & 0xFFFFFFF8;
    int32x4_t v7 = (int32x4_t *)(v3 + 72);
    int32x4_t v8 = 0uLL;
    uint64_t v9 = v4;
    int32x4_t v10 = 0uLL;
    do
    {
      int32x4_t v8 = vaddq_s32(v7[-1], v8);
      int32x4_t v10 = vaddq_s32(*v7, v10);
      v7 += 2;
      v9 -= 8;
    }
    while (v9);
    unsigned int v5 = vaddvq_s32(vaddq_s32(v10, v8));
    if (v4 == a2) {
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v4 = 0;
    unsigned int v5 = 0;
  }
  uint64_t v11 = a2 - v4;
  uint64_t v12 = (int *)(v3 + 4 * v4 + 56);
  do
  {
    int v13 = *v12++;
    v5 += v13;
    --v11;
  }
  while (v11);
LABEL_13:
  uint64_t v6 = v5;
LABEL_14:
  if ((v2 & 0x800000) != 0) {
    return *(void *)(*(void *)this + 72) + 32 * v6;
  }
  else {
    return 32 * v6;
  }
}

uint64_t mlir::mps::GRUOp::getTrainingState(mlir::mps::GRUOp *this)
{
  int v1 = *(_DWORD *)(*(void *)this + 36);
  if (v1) {
    uint64_t v2 = *(void *)this - 16;
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 1);
  uint64_t v4 = 0;
  if (v1 != 1) {
    return mlir::detail::OpResultImpl::getNextResultAtOffset(NextResultAtOffset, 0);
  }
  return v4;
}

BOOL mlir::mps::GRUOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v71 = v6;
  if (!v6)
  {
    a3(v75, a4);
    if (v75[0])
    {
      LODWORD(v72) = 3;
      uint64_t v73 = "expected DictionaryAttr to set properties";
      uint64_t v74 = 41;
      uint64_t v26 = &v72;
      uint64_t v27 = (char *)v76;
      if (v77 >= v78)
      {
        unint64_t v61 = v77 + 1;
        if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
        {
          int64_t v66 = (char *)&v72 - (unsigned char *)v76;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v61, 24);
          uint64_t v27 = (char *)v76;
          uint64_t v26 = (uint64_t *)((char *)v76 + v66);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v61, 24);
          uint64_t v26 = &v72;
          uint64_t v27 = (char *)v76;
        }
      }
      uint64_t v28 = &v27[24 * v77];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)uint64_t v28 = v29;
      ++v77;
      if (v75[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v75);
      }
    }
    if (!v84) {
      return 0;
    }
    unint64_t v30 = (void **)__p;
    if (__p)
    {
      unsigned int v31 = v83;
      uint64_t v32 = __p;
      if (v83 != __p)
      {
        do
          unsigned int v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        uint64_t v32 = __p;
      }
      uint64_t v83 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v80;
    if (!v80) {
      goto LABEL_64;
    }
    uint64_t v33 = v81;
    unint64_t v23 = v80;
    if (v81 == v80)
    {
LABEL_63:
      uint64_t v81 = v21;
      operator delete(v23);
LABEL_64:
      if (v76 != v79) {
        free(v76);
      }
      return 0;
    }
    do
    {
      uint64_t v35 = (void *)*--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
LABEL_62:
    unint64_t v23 = v80;
    goto LABEL_63;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v71, "flip_z", 6uLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v75, a4);
      if (v75[0])
      {
        LODWORD(v72) = 3;
        uint64_t v74 = 51;
        int32x4_t v10 = &v72;
        uint64_t v11 = (char *)v76;
        if (v77 >= v78)
        {
          unint64_t v62 = v77 + 1;
          if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
          {
            int64_t v67 = (char *)&v72 - (unsigned char *)v76;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v62, 24);
            uint64_t v11 = (char *)v76;
            int32x4_t v10 = (uint64_t *)((char *)v76 + v67);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v62, 24);
            int32x4_t v10 = &v72;
            uint64_t v11 = (char *)v76;
          }
        }
        uint64_t v12 = &v11[24 * v77];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = v10[2];
        *(_OWORD *)uint64_t v12 = v13;
        ++v77;
        if (v75[0])
        {
          uint64_t v14 = &v72;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v72, v9);
          uint64_t v15 = (char *)v76;
          if (v77 >= v78)
          {
            unint64_t v63 = v77 + 1;
            if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
            {
              int64_t v68 = (char *)&v72 - (unsigned char *)v76;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v63, 24);
              uint64_t v15 = (char *)v76;
              uint64_t v14 = (uint64_t *)((char *)v76 + v68);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v63, 24);
              uint64_t v14 = &v72;
              uint64_t v15 = (char *)v76;
            }
          }
          unint64_t v16 = &v15[24 * v77];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = v14[2];
          *(_OWORD *)unint64_t v16 = v17;
          ++v77;
          if (v75[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v75);
          }
        }
      }
      if (!v84) {
        return 0;
      }
      unint64_t v18 = (void **)__p;
      if (__p)
      {
        uint64_t v19 = v83;
        uint64_t v20 = __p;
        if (v83 != __p)
        {
          do
            uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          uint64_t v20 = __p;
        }
        uint64_t v83 = v18;
        operator delete(v20);
      }
      uint64_t v21 = v80;
      if (!v80) {
        goto LABEL_64;
      }
      uint64_t v22 = v81;
      unint64_t v23 = v80;
      if (v81 == v80) {
        goto LABEL_63;
      }
      do
      {
        uint64_t v25 = (void *)*--v22;
        unsigned int v24 = v25;
        *uint64_t v22 = 0;
        if (v25) {
          operator delete[](v24);
        }
      }
      while (v22 != v21);
      goto LABEL_62;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v71, "gate_layout", 0xBuLL);
  if (v36)
  {
    uint64_t v37 = v36;
    if (*(_UNKNOWN **)(*(void *)v36 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id)
    {
      a3(v75, a4);
      if (v75[0])
      {
        LODWORD(v72) = 3;
        uint64_t v74 = 56;
        unsigned int v38 = &v72;
        uint64_t v39 = (char *)v76;
        if (v77 >= v78)
        {
          unint64_t v64 = v77 + 1;
          if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
          {
            int64_t v69 = (char *)&v72 - (unsigned char *)v76;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v64, 24);
            uint64_t v39 = (char *)v76;
            unsigned int v38 = (uint64_t *)((char *)v76 + v69);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v64, 24);
            unsigned int v38 = &v72;
            uint64_t v39 = (char *)v76;
          }
        }
        unint64_t v40 = &v39[24 * v77];
        long long v41 = *(_OWORD *)v38;
        *((void *)v40 + 2) = v38[2];
        *(_OWORD *)unint64_t v40 = v41;
        ++v77;
        if (v75[0])
        {
          uint64_t v42 = &v72;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v72, v37);
          __int16 v43 = (char *)v76;
          if (v77 >= v78)
          {
            unint64_t v65 = v77 + 1;
            if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
            {
              int64_t v70 = (char *)&v72 - (unsigned char *)v76;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v65, 24);
              __int16 v43 = (char *)v76;
              uint64_t v42 = (uint64_t *)((char *)v76 + v70);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v65, 24);
              uint64_t v42 = &v72;
              __int16 v43 = (char *)v76;
            }
          }
          unint64_t v44 = &v43[24 * v77];
          long long v45 = *(_OWORD *)v42;
          *((void *)v44 + 2) = v42[2];
          *(_OWORD *)unint64_t v44 = v45;
          ++v77;
          if (v75[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v75);
          }
        }
      }
      if (!v84) {
        return 0;
      }
      uint64_t v46 = (void **)__p;
      if (__p)
      {
        unint64_t v47 = v83;
        uint64_t v48 = __p;
        if (v83 != __p)
        {
          do
            unint64_t v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
          while (v47 != v46);
          uint64_t v48 = __p;
        }
        uint64_t v83 = v46;
        operator delete(v48);
      }
      uint64_t v21 = v80;
      if (!v80) {
        goto LABEL_64;
      }
      BOOL v49 = v81;
      unint64_t v23 = v80;
      if (v81 == v80) {
        goto LABEL_63;
      }
      do
      {
        unsigned int v51 = (void *)*--v49;
        unint64_t v50 = v51;
        void *v49 = 0;
        if (v51) {
          operator delete[](v50);
        }
      }
      while (v49 != v21);
      goto LABEL_62;
    }
    a1[1] = v36;
  }
  uint64_t v52 = mlir::DictionaryAttr::get((uint64_t)&v71, "ogate_activation", 0x10uLL);
  uint64_t v72 = v52;
  if (v52)
  {
    if (*(_UNKNOWN **)(*(void *)v52 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v75, a4);
LABEL_86:
      uint64_t v55 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v75, v53);
      goto LABEL_87;
    }
    a1[2] = v52;
  }
  uint64_t v54 = mlir::DictionaryAttr::get((uint64_t)&v71, "reset_after", 0xBuLL);
  uint64_t v72 = v54;
  if (v54)
  {
    if (*(_UNKNOWN **)(*(void *)v54 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v75, a4);
LABEL_87:
      mlir::InFlightDiagnostic::append<mlir::Attribute>(v55, &v72);
LABEL_88:
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v75);
      return 0;
    }
    a1[3] = v54;
  }
  uint64_t v56 = mlir::DictionaryAttr::get((uint64_t)&v71, "rgate_activation", 0x10uLL);
  uint64_t v72 = v56;
  if (v56)
  {
    if (*(_UNKNOWN **)(*(void *)v56 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v75, a4);
      goto LABEL_86;
    }
    a1[4] = v56;
  }
  uint64_t v57 = mlir::DictionaryAttr::get((uint64_t)&v71, "training", 8uLL);
  uint64_t v72 = v57;
  if (v57)
  {
    if (*(_UNKNOWN **)(*(void *)v57 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v75, a4);
      goto LABEL_87;
    }
    a1[5] = v57;
  }
  uint64_t v58 = mlir::DictionaryAttr::get((uint64_t)&v71, "zgate_activation", 0x10uLL);
  uint64_t v72 = v58;
  if (v58)
  {
    if (*(_UNKNOWN **)(*(void *)v58 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v75, a4);
      goto LABEL_86;
    }
    a1[6] = v58;
  }
  unint64_t v60 = (void *)mlir::DictionaryAttr::get((uint64_t)&v71, "operandSegmentSizes", 0x13uLL);
  if (!v60)
  {
    unint64_t v60 = (void *)mlir::DictionaryAttr::get((uint64_t)&v71, "operand_segment_sizes", 0x15uLL);
    if (!v60)
    {
      a3(v75, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v75, "expected key entry for operandSegmentSizes in DictionaryAttr to set Properties.");
      goto LABEL_88;
    }
  }
  return mlir::convertFromAttribute(a1 + 7, (const char *)5, v60, a3, a4) != 0;
}

uint64_t mlir::mps::GRUOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v59[6] = *MEMORY[0x1E4F143B8];
  uint64_t v56 = a1;
  uint64_t v57 = v59;
  uint64_t v58 = 0x300000000;
  if (*a2)
  {
    uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v56, (uint64_t)"flip_z", 6, *a2);
    uint64_t v6 = v5;
    unsigned int v7 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      unsigned int v7 = v58;
    }
    uint64_t v8 = (uint64_t *)((char *)v57 + 16 * v7);
    uint64_t *v8 = NamedAttr;
    v8[1] = v6;
    LODWORD(v58) = v58 + 1;
  }
  uint64_t v9 = a2[1];
  if (v9)
  {
    uint64_t v10 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"gate_layout", 11, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      unsigned int v13 = v58;
    }
    uint64_t v14 = (uint64_t *)((char *)v57 + 16 * v13);
    *uint64_t v14 = v10;
    v14[1] = v12;
    LODWORD(v58) = v58 + 1;
  }
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"ogate_activation", 16, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      unsigned int v19 = v58;
    }
    uint64_t v20 = (uint64_t *)((char *)v57 + 16 * v19);
    *uint64_t v20 = v16;
    v20[1] = v18;
    LODWORD(v58) = v58 + 1;
  }
  uint64_t v21 = a2[3];
  if (v21)
  {
    uint64_t v22 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"reset_after", 11, v21);
    uint64_t v24 = v23;
    unsigned int v25 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      unsigned int v25 = v58;
    }
    uint64_t v26 = (uint64_t *)((char *)v57 + 16 * v25);
    *uint64_t v26 = v22;
    v26[1] = v24;
    LODWORD(v58) = v58 + 1;
  }
  uint64_t v27 = a2[4];
  if (v27)
  {
    uint64_t v28 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"rgate_activation", 16, v27);
    uint64_t v30 = v29;
    unsigned int v31 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      unsigned int v31 = v58;
    }
    uint64_t v32 = (uint64_t *)((char *)v57 + 16 * v31);
    *uint64_t v32 = v28;
    v32[1] = v30;
    LODWORD(v58) = v58 + 1;
  }
  uint64_t v33 = a2[5];
  if (v33)
  {
    uint64_t v34 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"training", 8, v33);
    uint64_t v36 = v35;
    unsigned int v37 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      unsigned int v37 = v58;
    }
    unsigned int v38 = (uint64_t *)((char *)v57 + 16 * v37);
    uint64_t *v38 = v34;
    v38[1] = v36;
    LODWORD(v58) = v58 + 1;
  }
  uint64_t v39 = a2[6];
  if (v39)
  {
    uint64_t v40 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"zgate_activation", 16, v39);
    uint64_t v42 = v41;
    unsigned int v43 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      unsigned int v43 = v58;
    }
    unint64_t v44 = (uint64_t *)((char *)v57 + 16 * v43);
    uint64_t *v44 = v40;
    v44[1] = v42;
    LODWORD(v58) = v58 + 1;
  }
  uint64_t v45 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 7), 5);
  uint64_t v46 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"operandSegmentSizes", 19, v45);
  uint64_t v48 = v47;
  unsigned int v49 = v58;
  if (v58 >= HIDWORD(v58))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
    unsigned int v49 = v58;
  }
  unint64_t v50 = (uint64_t *)((char *)v57 + 16 * v49);
  *unint64_t v50 = v46;
  v50[1] = v48;
  BOOL v51 = __CFADD__(v58, 1);
  uint64_t v52 = (v58 + 1);
  LODWORD(v58) = v58 + 1;
  if (v51)
  {
    uint64_t DictionaryAttr = 0;
    uint64_t v54 = v57;
    if (v57 == v59) {
      return DictionaryAttr;
    }
    goto LABEL_36;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v56, (uint64_t *)v57, v52);
  uint64_t v54 = v57;
  if (v57 != v59) {
LABEL_36:
  }
    free(v54);
  return DictionaryAttr;
}

unint64_t mlir::mps::GRUOp::computePropertiesHash(unint64_t *a1)
{
  uint64_t v114 = *MEMORY[0x1E4F143B8];
  unint64_t v1 = *a1;
  unint64_t v2 = 0x1E8EB8000uLL;
  {
    uint64_t v86 = a1;
    unint64_t v94 = v1;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v33 = v32;
    a1 = v86;
    unint64_t v1 = v94;
    if (v33)
    {
      unint64_t v34 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v34 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v34;
      a1 = v86;
      unint64_t v1 = v94;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  uint64_t v3 = *(void *)(v2 + 3024);
  unint64_t v4 = a1[1];
  {
    unint64_t v87 = a1;
    unint64_t v95 = v1;
    uint64_t v70 = v3;
    unint64_t v78 = v4;
    uint64_t v3 = v70;
    unint64_t v4 = v78;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v36 = v35;
    a1 = v87;
    unint64_t v1 = v95;
    if (v36)
    {
      unint64_t v37 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v37 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v37;
      uint64_t v3 = v70;
      unint64_t v4 = v78;
      a1 = v87;
      unint64_t v1 = v95;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  uint64_t v5 = *(void *)(v2 + 3024);
  unint64_t v6 = a1[2];
  {
    uint64_t v88 = a1;
    unint64_t v96 = v1;
    uint64_t v71 = v3;
    unint64_t v79 = v4;
    unint64_t v58 = v6;
    uint64_t v63 = v5;
    unint64_t v6 = v58;
    uint64_t v5 = v63;
    uint64_t v3 = v71;
    unint64_t v4 = v79;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v39 = v38;
    a1 = v88;
    unint64_t v1 = v96;
    if (v39)
    {
      unint64_t v40 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v40 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v40;
      unint64_t v6 = v58;
      uint64_t v5 = v63;
      uint64_t v3 = v71;
      unint64_t v4 = v79;
      a1 = v88;
      unint64_t v1 = v96;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v7 = HIDWORD(v6);
  unint64_t v8 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v6) ^ HIDWORD(v6));
  unint64_t v108 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) ^ ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) >> 47));
  unint64_t v9 = a1[3];
  {
    uint64_t v89 = a1;
    unint64_t v97 = v1;
    uint64_t v72 = v3;
    unint64_t v80 = v4;
    unint64_t v59 = v9;
    uint64_t v64 = v5;
    unint64_t v9 = v59;
    uint64_t v5 = v64;
    uint64_t v3 = v72;
    unint64_t v4 = v80;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v42 = v41;
    a1 = v89;
    unint64_t v1 = v97;
    if (v42)
    {
      unint64_t v43 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v43 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v43;
      unint64_t v9 = v59;
      uint64_t v5 = v64;
      uint64_t v3 = v72;
      unint64_t v4 = v80;
      a1 = v89;
      unint64_t v1 = v97;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v10 = HIDWORD(v9);
  unint64_t v11 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v9) ^ HIDWORD(v9));
  unint64_t v107 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) ^ ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) >> 47));
  unint64_t v12 = a1[4];
  {
    uint64_t v90 = a1;
    unint64_t v98 = v1;
    uint64_t v73 = v3;
    unint64_t v81 = v4;
    unint64_t v60 = v12;
    uint64_t v65 = v5;
    unint64_t v12 = v60;
    uint64_t v5 = v65;
    uint64_t v3 = v73;
    unint64_t v4 = v81;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v45 = v44;
    a1 = v90;
    unint64_t v1 = v98;
    if (v45)
    {
      unint64_t v46 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v46 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v46;
      unint64_t v12 = v60;
      uint64_t v5 = v65;
      uint64_t v3 = v73;
      unint64_t v4 = v81;
      a1 = v90;
      unint64_t v1 = v98;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v13 = HIDWORD(v12);
  unint64_t v14 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v12) ^ HIDWORD(v12));
  unint64_t v106 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v13 ^ (v14 >> 47) ^ v14)) ^ ((0x9DDFEA08EB382D69 * (v13 ^ (v14 >> 47) ^ v14)) >> 47));
  unint64_t v15 = a1[5];
  {
    BOOL v91 = a1;
    unint64_t v99 = v1;
    uint64_t v74 = v3;
    unint64_t v82 = v4;
    unint64_t v61 = v15;
    uint64_t v66 = v5;
    unint64_t v15 = v61;
    uint64_t v5 = v66;
    uint64_t v3 = v74;
    unint64_t v4 = v82;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v48 = v47;
    a1 = v91;
    unint64_t v1 = v99;
    if (v48)
    {
      unint64_t v49 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v49 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v49;
      unint64_t v15 = v61;
      uint64_t v5 = v66;
      uint64_t v3 = v74;
      unint64_t v4 = v82;
      a1 = v91;
      unint64_t v1 = v99;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v16 = HIDWORD(v15);
  unint64_t v17 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v15) ^ HIDWORD(v15));
  unint64_t v105 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v16 ^ (v17 >> 47) ^ v17)) ^ ((0x9DDFEA08EB382D69 * (v16 ^ (v17 >> 47) ^ v17)) >> 47));
  unint64_t v18 = a1[6];
  {
    uint64_t v92 = a1;
    unint64_t v100 = v1;
    uint64_t v75 = v3;
    unint64_t v83 = v4;
    unint64_t v62 = v18;
    uint64_t v67 = v5;
    unint64_t v18 = v62;
    uint64_t v5 = v67;
    uint64_t v3 = v75;
    unint64_t v4 = v83;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v51 = v50;
    a1 = v92;
    unint64_t v1 = v100;
    if (v51)
    {
      unint64_t v52 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v52 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v52;
      unint64_t v18 = v62;
      uint64_t v5 = v67;
      uint64_t v3 = v75;
      unint64_t v4 = v83;
      a1 = v92;
      unint64_t v1 = v100;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v19 = HIDWORD(v18);
  unint64_t v20 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v18) ^ HIDWORD(v18));
  unint64_t v104 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v19 ^ (v20 >> 47) ^ v20)) ^ ((0x9DDFEA08EB382D69 * (v19 ^ (v20 >> 47) ^ v20)) >> 47));
  {
    BOOL v93 = a1;
    unint64_t v101 = v1;
    uint64_t v76 = v3;
    unint64_t v84 = v4;
    uint64_t v68 = v5;
    uint64_t v5 = v68;
    uint64_t v3 = v76;
    unint64_t v1 = v101;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v54 = v53;
    unint64_t v4 = v84;
    a1 = v93;
    if (v54)
    {
      unint64_t v55 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v55 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v55;
      uint64_t v5 = v68;
      uint64_t v3 = v76;
      unint64_t v4 = v84;
      a1 = v93;
      unint64_t v1 = v101;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  uint64_t v21 = *(void *)(v2 + 3024);
  unint64_t v22 = 0xB492B66FBE98F273 * a1[7];
  unint64_t v23 = a1[8];
  unint64_t v24 = 0x9AE16A3B2F90404FLL * *(unint64_t *)((char *)a1 + 68);
  uint64_t v25 = __ROR8__(v22 - v23, 43)
      - 0x3C5A37A36834CED9 * *(unint64_t *)((char *)a1 + 60)
      + __ROR8__(v24 ^ v21, 30);
  uint64_t v26 = v21 + __ROR8__(v23 ^ 0xC949D7C7509E6557, 20) + v22 - v24 + 20;
  unint64_t v103 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69
         * (v26 ^ ((0x9DDFEA08EB382D69 * (v25 ^ v26)) >> 47) ^ (0x9DDFEA08EB382D69 * (v25 ^ v26)))) ^ ((0x9DDFEA08EB382D69 * (v26 ^ ((0x9DDFEA08EB382D69 * (v25 ^ v26)) >> 47) ^ (0x9DDFEA08EB382D69 * (v25 ^ v26)))) >> 47));
  uint64_t v112 = 0;
  memset(v111, 0, sizeof(v111));
  memset(v110, 0, sizeof(v110));
  long long v109 = 0u;
  {
    unint64_t v102 = v1;
    uint64_t v77 = v3;
    unint64_t v85 = v4;
    uint64_t v69 = v5;
    uint64_t v5 = v69;
    uint64_t v3 = v77;
    unint64_t v4 = v85;
    unint64_t v1 = v102;
    unint64_t v2 = 0x1E8EB8000uLL;
    if (v56)
    {
      unint64_t v57 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v57 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v57;
      uint64_t v5 = v69;
      uint64_t v3 = v77;
      unint64_t v4 = v85;
      unint64_t v1 = v102;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v27 = 0x9DDFEA08EB382D69 * ((v5 + 8 * v4) ^ HIDWORD(v4));
  unint64_t v28 = 0x9DDFEA08EB382D69 * (HIDWORD(v4) ^ (v27 >> 47) ^ v27);
  unint64_t v29 = HIDWORD(v1);
  unint64_t v30 = 0x9DDFEA08EB382D69 * ((v3 + 8 * v1) ^ HIDWORD(v1));
  uint64_t v113 = *(void *)(v2 + 3024);
  *(void *)&long long v109 = 0x9DDFEA08EB382D69
                   * ((0x9DDFEA08EB382D69 * (v29 ^ (v30 >> 47) ^ v30)) ^ ((0x9DDFEA08EB382D69
                                                                           * (v29 ^ (v30 >> 47) ^ v30)) >> 47));
  *((void *)&v109 + 1) = 0x9DDFEA08EB382D69 * (v28 ^ (v28 >> 47));
  return llvm::hashing::detail::hash_combine_recursive_helper::combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>((llvm::hashing::detail::hash_combine_recursive_helper *)&v109, 0, v110, (char *)v111, (uint64_t *)&v108, (uint64_t *)&v107, (uint64_t *)&v106, (uint64_t *)&v105, (uint64_t *)&v104, (uint64_t *)&v103);
}

uint64_t mlir::mps::GRUOp::getInherentAttr(mlir::MLIRContext *a1, void *a2, _WORD *__s1, size_t __n)
{
  uint64_t result = 0;
  switch(__n)
  {
    case 6uLL:
      if (*(_DWORD *)__s1 != 1885957222 || __s1[2] != 31327) {
        goto LABEL_18;
      }
      return *a2;
    case 7uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0xFuLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x14uLL:
      goto LABEL_18;
    case 8uLL:
      if (memcmp(__s1, "training", __n)) {
        goto LABEL_18;
      }
      return a2[5];
    case 0xBuLL:
      if (!memcmp(__s1, "gate_layout", __n))
      {
        uint64_t result = a2[1];
      }
      else
      {
        if (memcmp(__s1, "reset_after", __n)) {
          goto LABEL_18;
        }
        uint64_t result = a2[3];
      }
      break;
    case 0x10uLL:
      if (!memcmp(__s1, "ogate_activation", __n))
      {
        uint64_t result = a2[2];
      }
      else if (!memcmp(__s1, "rgate_activation", __n))
      {
        uint64_t result = a2[4];
      }
      else if (!memcmp(__s1, "zgate_activation", __n))
      {
        uint64_t result = a2[6];
      }
      else
      {
LABEL_18:
        uint64_t result = 0;
      }
      break;
    case 0x13uLL:
      if (memcmp(__s1, "operandSegmentSizes", __n)) {
        goto LABEL_18;
      }
      return mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 7), 5);
    case 0x15uLL:
      if (memcmp(__s1, "operand_segment_sizes", __n)) {
        goto LABEL_18;
      }
      return mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 7), 5);
    default:
      return result;
  }
  return result;
}

uint64_t mlir::mps::GRUOp::setInherentAttr(uint64_t result, _WORD *__s1, size_t __n, void *a4)
{
  unint64_t v7 = (void *)result;
  switch(__n)
  {
    case 6uLL:
      if (*(_DWORD *)__s1 == 1885957222 && __s1[2] == 31327)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
            unint64_t v14 = a4;
          }
          else {
            unint64_t v14 = 0;
          }
          *(void *)uint64_t result = v14;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 8uLL:
      uint64_t result = memcmp(__s1, "training", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
            unint64_t v9 = a4;
          }
          else {
            unint64_t v9 = 0;
          }
          v7[5] = v9;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      uint64_t result = memcmp(__s1, "gate_layout", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "reset_after", __n);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
              unint64_t v10 = a4;
            }
            else {
              unint64_t v10 = 0;
            }
            v7[3] = v10;
          }
          else
          {
            v7[3] = 0;
          }
        }
      }
      else if (a4)
      {
        if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id) {
          unint64_t v15 = a4;
        }
        else {
          unint64_t v15 = 0;
        }
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "ogate_activation", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "rgate_activation", __n);
        if (result)
        {
          uint64_t result = memcmp(__s1, "zgate_activation", __n);
          if (!result)
          {
            if (a4)
            {
              if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
                unint64_t v11 = a4;
              }
              else {
                unint64_t v11 = 0;
              }
              v7[6] = v11;
            }
            else
            {
              v7[6] = 0;
            }
          }
        }
        else if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
            unint64_t v17 = a4;
          }
          else {
            unint64_t v17 = 0;
          }
          uint64_t v7[4] = v17;
        }
        else
        {
          uint64_t v7[4] = 0;
        }
      }
      else if (a4)
      {
        if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
          unint64_t v16 = a4;
        }
        else {
          unint64_t v16 = 0;
        }
        v7[2] = v16;
      }
      else
      {
        v7[2] = 0;
      }
      break;
    case 0x13uLL:
      uint64_t result = memcmp(__s1, "operandSegmentSizes", __n);
      if (!result) {
        goto LABEL_31;
      }
      break;
    case 0x15uLL:
      uint64_t result = memcmp(__s1, "operand_segment_sizes", __n);
      if (!result)
      {
LABEL_31:
        if (a4)
        {
          uint64_t result = mlir::detail::DenseArrayAttrImpl<int>::classof(a4);
          unint64_t v12 = result ? a4 : 0;
          unint64_t v18 = v12;
          if (result)
          {
            uint64_t result = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v18);
            if (result == 5)
            {
              uint64_t result = mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v18);
              if (v13) {
                uint64_t result = (uint64_t)memmove(v7 + 7, (const void *)result, 4 * v13);
              }
            }
          }
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::GRUOp::populateInherentAttrs(mlir::MLIRContext *a1, uint64_t *a2, uint64_t a3)
{
  if (*a2) {
    mlir::NamedAttrList::append(a3, (uint64_t)"flip_z", 6, *a2);
  }
  uint64_t v6 = a2[1];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"gate_layout", 11, v6);
  }
  uint64_t v7 = a2[2];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"ogate_activation", 16, v7);
  }
  uint64_t v8 = a2[3];
  if (v8) {
    mlir::NamedAttrList::append(a3, (uint64_t)"reset_after", 11, v8);
  }
  uint64_t v9 = a2[4];
  if (v9) {
    mlir::NamedAttrList::append(a3, (uint64_t)"rgate_activation", 16, v9);
  }
  uint64_t v10 = a2[5];
  if (v10) {
    mlir::NamedAttrList::append(a3, (uint64_t)"training", 8, v10);
  }
  uint64_t v11 = a2[6];
  if (v11) {
    mlir::NamedAttrList::append(a3, (uint64_t)"zgate_activation", 16, v11);
  }
  uint64_t v12 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 7), 5);

  mlir::NamedAttrList::append(a3, (uint64_t)"operandSegmentSizes", 19, v12);
}

BOOL mlir::mps::GRUOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v8, (const void **)"flip_z", (const char *)6, a3, a4))
  {
    uint64_t v9 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps29(v9, (const void **)"gate_layout", (const char *)0xB, a3, a4))
    {
      uint64_t v10 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v10, (const void **)"ogate_activation", (const char *)0x10, a3, a4))
      {
        uint64_t v11 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 24));
        if (!v11
          || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v11, (const void **)"reset_after", (const char *)0xB, a3, a4))
        {
          uint64_t v12 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v12, (const void **)"rgate_activation", (const char *)0x10, a3, a4))
          {
            uint64_t v13 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 40));
            if (!v13
              || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v13, (const void **)"training", (const char *)8, a3, a4))
            {
              uint64_t v14 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 48));
              if (!v14
                || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v14, (const void **)"zgate_activation", (const char *)0x10, a3, a4))
              {
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

BOOL mlir::mps::GRUOp::readProperties(uint64_t a1, void *a2)
{
  v10[24] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>(a2);
  if (!mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::GRUGateLayoutAttr>(a1, v3 + 1)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 2))
  {
    return 0;
  }
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) <= 5)
  {
    uint64_t v9 = 0;
    if (!mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<int>>(a1, &v9)) {
      return 0;
    }
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v9) >= 6)
    {
      v7[0] = (uint64_t)"size mismatch for operand/result_segment_size";
      __int16 v8 = 259;
      (*(void (**)(void *__return_ptr, uint64_t, uint64_t *))(*(void *)a1 + 16))(v10, a1, v7);
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v10);
      return 0;
    }
    unint64_t v4 = (const void *)mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v9);
    if (v5) {
      memmove(v3 + 7, v4, 4 * v5);
    }
  }
  if (mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 3)
    && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 4)
    && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 5)
    && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 6))
  {
    v7[0] = a1;
    v7[1] = (uint64_t)(v3 + 7);
    return mlir::mps::GRUOp::readProperties(mlir::DialectBytecodeReader &,mlir::OperationState &)::$_0::operator()(v7) != 0;
  }
  return 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x50uLL);
    *uint64_t v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    v3[3] = 0u;
    *(_OWORD *)((char *)v3 + 60) = 0u;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::GRUOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 104;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        __int16 v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[69];
    return a1[32];
  }
  return result;
}

uint64_t mlir::mps::GRUOp::readProperties(mlir::DialectBytecodeReader &,mlir::OperationState &)::$_0::operator()(uint64_t *a1)
{
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)*a1 + 40))(*a1) < 6) {
    return 1;
  }
  uint64_t v2 = *a1;
  uint64_t v3 = (_DWORD *)a1[1];

  return mlir::DialectBytecodeReader::readSparseArray<int>(v2, v3, (const char *)5);
}

uint64_t mlir::mps::GRUOp::writeProperties(uint64_t a1, uint64_t a2)
{
  if (HIBYTE(*(_DWORD *)(*(void *)a1 + 44))) {
    unint64_t v4 = *(void *)a1 + 16 * (((unint64_t)*(unsigned int *)(*(void *)a1 + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)v4);
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 8));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 16));
  if ((*(uint64_t (**)(uint64_t))(*(void *)a2 + 104))(a2) <= 5)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(*(void *)a1 + 24));
    uint64_t v6 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v4 + 56, 5);
    (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, v6);
  }
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 24));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 32));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 40));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 48));
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 104))(a2);
  if (result >= 6)
  {
    return mlir::DialectBytecodeWriter::writeSparseArray<int>(a2, (int *)(v4 + 56), 5);
  }
  return result;
}

BOOL mlir::mps::GRUOp::getTraining(mlir::mps::GRUOp *this)
{
  unint64_t v1 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v1 = 0;
  }
  return *(void *)(v1 + 40) != 0;
}

void mlir::mps::GRUOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, unsigned int a7, unsigned int a8, char a9, char a10, unsigned __int8 a11, uint64_t a12, uint64_t a13, BOOL a14)
{
  BOOL v19 = a14;
  void v61[2] = *MEMORY[0x1E4F143B8];
  uint64_t v54 = a4;
  uint64_t v55 = a3;
  uint64_t v52 = a13;
  uint64_t v53 = a12;
  BOOL v51 = a14;
  mlir::OperationState::addOperands(a2, (uint64_t)&v55, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v54, 1);
  if (a12) {
    mlir::OperationState::addOperands(a2, (uint64_t)&v53, 1);
  }
  if (a13) {
    mlir::OperationState::addOperands(a2, (uint64_t)&v52, 1);
  }
  if (a14)
  {
    mlir::OperationState::addOperands(a2, (uint64_t)&v51, 1);
    BOOL v19 = v51;
  }
  BOOL v20 = v53 != 0;
  BOOL v21 = v52 != 0;
  uint64_t v22 = mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>((void *)a2);
  *(void *)(v22 + 56) = 0x100000001;
  *(_DWORD *)(v22 + 64) = v20;
  *(_DWORD *)(v22 + 68) = v21;
  *(_DWORD *)(v22 + 72) = v19;
  unint64_t v23 = *a1;
  unsigned int v56 = a5;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v23);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  uint64_t v60 = (uint64_t)v23;
  uint64_t v25 = mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v56);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>((void *)a2)
            + 48) = v25;
  uint64_t v26 = *a1;
  unsigned int v56 = a6;
  unint64_t v27 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v26);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  uint64_t v60 = (uint64_t)v26;
  uint64_t v28 = mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v27, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v56);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>((void *)a2)
            + 32) = v28;
  unint64_t v29 = *a1;
  unsigned int v56 = a7;
  unint64_t v30 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v29);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  uint64_t v60 = (uint64_t)v29;
  uint64_t v31 = mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v30, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v56);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>((void *)a2)
            + 16) = v31;
  int v32 = *a1;
  unsigned int v56 = a8;
  int v33 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v32);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id;
  uint64_t v60 = (uint64_t)v32;
  uint64_t v34 = mlir::StorageUniquer::get<mlir::mps::detail::GRUGateLayoutAttrStorage,mlir::mps::GRUGateLayout>(v33, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24GRUGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17GRUGateLayoutAttrEJNS2_13GRUGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id, &v56);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = v34;
  if (a9)
  {
    uint64_t UnitAttr = mlir::Builder::getUnitAttr(a1, v35);
    *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>((void *)a2)
              + 40) = UnitAttr;
    int v36 = a11;
    if (!a10)
    {
LABEL_9:
      if (!v36) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
  }
  else
  {
    int v36 = a11;
    if (!a10) {
      goto LABEL_9;
    }
  }
  uint64_t v49 = mlir::Builder::getUnitAttr(a1, v35);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>((void *)a2)
            + 24) = v49;
  if (v36)
  {
LABEL_10:
    uint64_t v37 = mlir::Builder::getUnitAttr(a1, v35);
    *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>((void *)a2) = v37;
  }
LABEL_11:
  __src = v61;
  uint64_t v60 = 0x200000000;
  int v38 = *a1;
  int v39 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v58, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  int v42 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v57, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::GRUOp::inferReturnTypes(v38, v39, 1, v58[0], v58[1], Dictionary, v42, v43, v57[0], v57[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  int v44 = __src;
  }
  uint64_t v45 = v60;
  uint64_t v46 = *(unsigned int *)(a2 + 72);
  unint64_t v47 = v46 + v60;
  if (v47 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v47, 8);
    LODWORD(v46) = *(_DWORD *)(a2 + 72);
  }
  if (v45)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v46), v44, 8 * v45);
    LODWORD(v46) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v46 + v45;
  if (__src != v61) {
    free(__src);
  }
}

mlir::MLIRContext *mlir::mps::GRUOp::populateDefaultProperties(uint64_t a1, void *a2)
{
  uint64_t v10 = *(void **)(a1 + 8);
  uint64_t result = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v10);
  unint64_t v4 = result;
  if (a2[6])
  {
    if (a2[4]) {
      goto LABEL_3;
    }
  }
  else
  {
    unsigned int v9 = 3;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(result);
    uint64_t v10 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
    unint64_t v11 = v4;
    uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v10, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v9);
    a2[6] = result;
    if (a2[4])
    {
LABEL_3:
      if (a2[2]) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  unsigned int v9 = 3;
  uint64_t v6 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  uint64_t v10 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  unint64_t v11 = v4;
  uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v6, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v10, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v9);
  a2[4] = result;
  if (a2[2])
  {
LABEL_4:
    if (a2[1]) {
      return result;
    }
LABEL_9:
    unsigned int v9 = 0;
    __int16 v8 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
    uint64_t v10 = &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id;
    unint64_t v11 = v4;
    uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::GRUGateLayoutAttrStorage,mlir::mps::GRUGateLayout>(v8, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24GRUGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17GRUGateLayoutAttrEJNS2_13GRUGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v10, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id, &v9);
    a2[1] = result;
    return result;
  }
LABEL_8:
  unsigned int v9 = 2;
  unint64_t v7 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  uint64_t v10 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  unint64_t v11 = v4;
  uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v7, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v10, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v9);
  a2[2] = result;
  if (!a2[1]) {
    goto LABEL_9;
  }
  return result;
}

uint64_t mlir::mps::GRUOp::verifyInvariantsImpl(uint64_t **this)
{
  v67[24] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    uint64_t v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  uint64_t v7 = v3[2];
  uint64_t v6 = v3[3];
  uint64_t v9 = v3[4];
  uint64_t v8 = v3[5];
  uint64_t v10 = v3[6];
  v67[0] = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v10, (const void **)"zgate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v67))return 0; {
  v67[0] = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v9, (const void **)"rgate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v67))return 0; {
  v67[0] = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v7, (const void **)"ogate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v67))return 0; {
  v67[0] = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps29(v5, (const void **)"gate_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps29(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v67))return 0; {
  v67[0] = *this;
  }
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v8, (const void **)"training", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v67))return 0; {
  v67[0] = *this;
  }
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v6, (const void **)"reset_after", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v67))return 0; {
  v67[0] = *this;
  }
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v4, (const void **)"flip_z", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v67))return 0; {
  unsigned int v66 = 0;
  }
  unint64_t v11 = *((unsigned int *)*this + 11);
  uint64_t v12 = (uint64_t)&(*this)[2 * ((v11 >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11))) {
    uint64_t v12 = 0;
  }
  uint64_t v13 = *(unsigned int *)(v12 + 56);
  if ((v11 & 0x800000) != 0)
  {
    uint64_t v14 = (*this)[9];
    if (v13) {
      goto LABEL_15;
    }
  }
  else
  {
    uint64_t v14 = 0;
    if (v13)
    {
LABEL_15:
      uint64_t v15 = v14 + 24;
      do
      {
        unint64_t v16 = *this;
        unint64_t v17 = *(void *)(*(void *)v15 + 8) & 0xFFFFFFFFFFFFFFF8;
        unsigned int v18 = v66++;
        if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v16, v17, (const void **)"operand", (const void **)7, v18))return 0; {
        v15 += 32;
        }
      }
      while (--v13);
    }
  }
  uint64_t ODSOperands = mlir::mps::GRUOp::getODSOperands((mlir::mps::GRUOp *)this, 1u);
  if (v20)
  {
    uint64_t v21 = v20;
    uint64_t v22 = ODSOperands + 24;
    do
    {
      unint64_t v23 = *this;
      unint64_t v24 = *(void *)(*(void *)v22 + 8) & 0xFFFFFFFFFFFFFFF8;
      unsigned int v25 = v66++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v23, v24, (const void **)"operand", (const void **)7, v25))return 0; {
      v22 += 32;
      }
    }
    while (--v21);
  }
  uint64_t v26 = mlir::mps::GRUOp::getODSOperands((mlir::mps::GRUOp *)this, 2u);
  uint64_t v28 = v27;
  if (v27 >= 2) {
    goto LABEL_29;
  }
  if (v27)
  {
    uint64_t v29 = *(void *)(v26 + 24);
    unint64_t v30 = *this;
    unint64_t v31 = *(void *)(v29 + 8) & 0xFFFFFFFFFFFFFFF8;
    unsigned int v32 = v66++;
    if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v30, v31, (const void **)"operand", (const void **)7, v32))return 0; {
  }
    }
  uint64_t v33 = mlir::mps::GRUOp::getODSOperands((mlir::mps::GRUOp *)this, 3u);
  uint64_t v28 = v34;
  if (v34 < 2)
  {
    if (!v34
      || (uint64_t v35 = *(void *)(v33 + 24),
          int v36 = *this,
          unint64_t v37 = *(void *)(v35 + 8) & 0xFFFFFFFFFFFFFFF8,
          unsigned int v38 = v66,
          ++v66,
          mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v36, v37, (const void **)"operand", (const void **)7, v38)))
    {
      uint64_t v39 = mlir::mps::GRUOp::getODSOperands((mlir::mps::GRUOp *)this, 4u);
      uint64_t v28 = v40;
      if (v40 >= 2) {
        goto LABEL_29;
      }
      if (!v40
        || (uint64_t v45 = *(void *)(v39 + 24),
            uint64_t v46 = *this,
            unint64_t v47 = *(void *)(v45 + 8) & 0xFFFFFFFFFFFFFFF8,
            unsigned int v48 = v66,
            ++v66,
            mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v46, v47, (const void **)"operand", (const void **)7, v48)))
      {
        unsigned int v66 = 0;
        uint64_t ODSResults = mlir::mps::GRUOp::getODSResults((mlir::mps::GRUOp *)this, 0);
        if (v50)
        {
          uint64_t v51 = ODSResults;
          uint64_t v52 = v50;
          uint64_t v53 = 0;
          while (1)
          {
            uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v51, v53);
            uint64_t v55 = *this;
            unint64_t v56 = *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8;
            unsigned int v66 = v53 + 1;
            if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v55, v56, (const void **)"result", (const void **)6, v53))break; {
            if (v52 == ++v53)
            }
              goto LABEL_39;
          }
        }
        else
        {
          LODWORD(v53) = 0;
LABEL_39:
          uint64_t v57 = mlir::mps::GRUOp::getODSResults((mlir::mps::GRUOp *)this, 1u);
          uint64_t v59 = v58;
          if (v58 >= 2)
          {
            v64[0] = (const void **)"result group starting at #";
            __int16 v65 = 259;
            mlir::OpState::emitOpError(this, v64, (uint64_t)v67);
            uint64_t v60 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v67, &v66);
            uint64_t v42 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v60, " requires 0 or 1 element, but found ");
            uint64_t v63 = v59;
            goto LABEL_30;
          }
          if (!v58) {
            return 1;
          }
          uint64_t v61 = mlir::detail::OpResultImpl::getNextResultAtOffset(v57, 0);
          if (mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(v61 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, v53))return 1; {
        }
          }
      }
    }
    return 0;
  }
LABEL_29:
  v64[0] = (const void **)"operand group starting at #";
  __int16 v65 = 259;
  mlir::OpState::emitOpError(this, v64, (uint64_t)v67);
  uint64_t v41 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v67, &v66);
  uint64_t v42 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v41, " requires 0 or 1 element, but found ");
  uint64_t v63 = v28;
LABEL_30:
  uint64_t v43 = mlir::InFlightDiagnostic::operator<<<unsigned long &>(v42, &v63);
  uint64_t v44 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v43);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v67);
  return v44;
}

uint64_t mlir::mps::GRUOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.gru", 7, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC982438;
  v4[12] = mlir::mps::GRUOp::canonicalize;
  uint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::GatherAlongAxisOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      int v44 = 3;
      uint64_t v45 = "expected DictionaryAttr to set properties";
      uint64_t v46 = 41;
      uint64_t v26 = &v44;
      unint64_t v27 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v40 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          unint64_t v27 = (char *)v48;
          uint64_t v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          uint64_t v26 = &v44;
          unint64_t v27 = (char *)v48;
        }
      }
      uint64_t v28 = &v27[24 * v49];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)uint64_t v28 = v29;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
    if (!v56) {
      return 0;
    }
    unint64_t v30 = (void **)__p;
    if (__p)
    {
      unint64_t v31 = v55;
      unsigned int v32 = __p;
      if (v55 != __p)
      {
        do
          unint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unsigned int v32 = __p;
      }
      uint64_t v55 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v52;
    if (!v52) {
      goto LABEL_43;
    }
    uint64_t v33 = v53;
    unint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v35 = (void *)*--v33;
      unint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "allow_negative_indices", 0x16uLL);
  if (!v8) {
    return 1;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    int v44 = 3;
    uint64_t v46 = 67;
    uint64_t v10 = &v44;
    unint64_t v11 = (char *)v48;
    if (v49 >= v50)
    {
      unint64_t v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        int64_t v41 = (char *)&v44 - (unsigned char *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        unint64_t v11 = (char *)v48;
        uint64_t v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v10 = &v44;
        unint64_t v11 = (char *)v48;
      }
    }
    uint64_t v12 = &v11[24 * v49];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = *((void *)v10 + 2);
    *(_OWORD *)uint64_t v12 = v13;
    ++v49;
    if (v47[0])
    {
      uint64_t v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      uint64_t v15 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v42 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v15 = (char *)v48;
          uint64_t v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v14 = &v44;
          uint64_t v15 = (char *)v48;
        }
      }
      unint64_t v16 = &v15[24 * v49];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = *((void *)v14 + 2);
      *(_OWORD *)unint64_t v16 = v17;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
  }
  if (!v56) {
    return 0;
  }
  unsigned int v18 = (void **)__p;
  if (__p)
  {
    BOOL v19 = v55;
    uint64_t v20 = __p;
    if (v55 != __p)
    {
      do
        BOOL v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      uint64_t v20 = __p;
    }
    uint64_t v55 = v18;
    operator delete(v20);
  }
  uint64_t v21 = v52;
  if (v52)
  {
    uint64_t v22 = v53;
    unint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      unsigned int v25 = (void *)*--v22;
      unint64_t v24 = v25;
      *uint64_t v22 = 0;
      if (v25) {
        operator delete[](v24);
      }
    }
    while (v22 != v21);
LABEL_41:
    unint64_t v23 = v52;
LABEL_42:
    uint64_t v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51) {
    free(v48);
  }
  return 0;
}

uint64_t mlir::mps::GatherAlongAxisOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v15[6] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a1;
  long long v13 = v15;
  uint64_t v14 = 0x300000000;
  if (!*a2) {
    return 0;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"allow_negative_indices", 22, *a2);
  uint64_t v4 = v3;
  unsigned int v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    unsigned int v5 = v14;
  }
  uint64_t v6 = (uint64_t *)((char *)v13 + 16 * v5);
  uint64_t *v6 = NamedAttr;
  v6[1] = v4;
  uint64_t v7 = v13;
  BOOL v8 = __CFADD__(v14, 1);
  uint64_t v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v13 == v15) {
      return DictionaryAttr;
    }
    goto LABEL_10;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (uint64_t *)v13, v9);
  uint64_t v7 = v13;
  if (v13 != v15) {
LABEL_10:
  }
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherAlongAxisOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    *uint64_t v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::GatherAlongAxisOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherAlongAxisOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::GatherAlongAxisOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherAlongAxisOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::GatherAlongAxisOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 116;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        BOOL v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::GatherAlongAxisOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[71];
    return a1[32];
  }
  return result;
}

void mlir::mps::GatherAlongAxisOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  void v27[2] = *MEMORY[0x1E4F143B8];
  uint64_t v21 = a4;
  uint64_t v22 = a3;
  uint64_t v20 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v22, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v20, 1);
  if (a6) {
    *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherAlongAxisOpGenericAdaptorBase::Properties>((void *)a2) = a6;
  }
  __src = v27;
  uint64_t v26 = 0x200000000;
  uint64_t v8 = *(void *)a2;
  mlir::ValueRange::ValueRange(v24, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v10 = mlir::ValueRange::ValueRange(&v23, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::GatherAlongAxisOp::inferReturnTypes((uint64_t)v10, v8, 1, v24[0], v24[1], v11, v12, v13, v18, v19, (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  unint64_t v14 = __src;
  }
  uint64_t v15 = v26;
  uint64_t v16 = *(unsigned int *)(a2 + 72);
  unint64_t v17 = v16 + v26;
  if (v17 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v17, 8);
    LODWORD(v16) = *(_DWORD *)(a2 + 72);
  }
  if (v15)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v16), v14, 8 * v15);
    LODWORD(v16) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v16 + v15;
  if (__src != v27) {
    free(__src);
  }
}

void mlir::mps::GatherAlongAxisOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  unint64_t v30[2] = *MEMORY[0x1E4F143B8];
  uint64_t v24 = a4;
  uint64_t v25 = a3;
  uint64_t v23 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v25, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v24, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v23, 1);
  if (a6)
  {
    uint64_t UnitAttr = mlir::Builder::getUnitAttr(a1, v9);
    *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherAlongAxisOpGenericAdaptorBase::Properties>((void *)a2) = UnitAttr;
  }
  __src = v30;
  uint64_t v29 = 0x200000000;
  uint64_t v11 = *(void *)a2;
  mlir::ValueRange::ValueRange(v27, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v13 = mlir::ValueRange::ValueRange(&v26, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::GatherAlongAxisOp::inferReturnTypes((uint64_t)v13, v11, 1, v27[0], v27[1], v14, v15, v16, v21, v22, (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  unint64_t v17 = __src;
  }
  uint64_t v18 = v29;
  uint64_t v19 = *(unsigned int *)(a2 + 72);
  unint64_t v20 = v19 + v29;
  if (v20 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v20, 8);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  if (v18)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v19), v17, 8 * v18);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v19 + v18;
  if (__src != v30) {
    free(__src);
  }
}

BOOL mlir::mps::GatherAlongAxisOp::verifyInvariantsImpl(uint64_t **this)
{
  __int16 v2 = *this;
  uint64_t v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  unint64_t v7 = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v3, (const void **)"allow_negative_indices", (const char *)0x16, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v7)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps7(*this, *(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this,
                           (const void **)(*(void *)(*(void *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8),
                           (const void **)"operand",
                           7,
                           2u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v4 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::GatherAlongAxisOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.gather_along_axis", 21, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC981048;
  v4[12] = mlir::mps::GatherAlongAxisOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::GatherNDOpGenericAdaptorBase::GatherNDOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    int v5 = (_OWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  }
  else {
    int v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v11, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *(_OWORD *)v11;
  *(_OWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 40) = v8;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.gather_nd", 13, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::GatherNDOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v89 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v75 = v6;
  if (!v6)
  {
    a3(v79, a4);
    if (v79[0])
    {
      int v76 = 3;
      uint64_t v77 = "expected DictionaryAttr to set properties";
      uint64_t v78 = 41;
      unint64_t v26 = &v76;
      unint64_t v27 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v63 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v69 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          unint64_t v27 = (char *)v80;
          unint64_t v26 = (int *)((char *)v80 + v69);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          unint64_t v26 = &v76;
          unint64_t v27 = (char *)v80;
        }
      }
      uint64_t v28 = &v27[24 * v81];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)uint64_t v28 = v29;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
    if (!v88) {
      return 0;
    }
    unint64_t v30 = (void **)__p;
    if (__p)
    {
      unint64_t v31 = v87;
      unsigned int v32 = __p;
      if (v87 != __p)
      {
        do
          unint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unsigned int v32 = __p;
      }
      unint64_t v87 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v84;
    if (!v84) {
      goto LABEL_80;
    }
    uint64_t v33 = v85;
    uint64_t v23 = v84;
    if (v85 == v84) {
      goto LABEL_79;
    }
    do
    {
      uint64_t v35 = (void *)*--v33;
      unint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
    goto LABEL_78;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v75, "allow_negative_indices", 0x16uLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v79, a4);
      if (v79[0])
      {
        int v76 = 3;
        uint64_t v78 = 67;
        uint64_t v10 = &v76;
        uint64_t v11 = (char *)v80;
        if (v81 >= v82)
        {
          unint64_t v64 = v81 + 1;
          if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
          {
            int64_t v70 = (char *)&v76 - (unsigned char *)v80;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            uint64_t v11 = (char *)v80;
            uint64_t v10 = (int *)((char *)v80 + v70);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            uint64_t v10 = &v76;
            uint64_t v11 = (char *)v80;
          }
        }
        uint64_t v12 = &v11[24 * v81];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = *((void *)v10 + 2);
        *(_OWORD *)uint64_t v12 = v13;
        ++v81;
        if (v79[0])
        {
          uint64_t v14 = &v76;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v9);
          uint64_t v15 = (char *)v80;
          if (v81 >= v82)
          {
            unint64_t v65 = v81 + 1;
            if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
            {
              int64_t v71 = (char *)&v76 - (unsigned char *)v80;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              uint64_t v15 = (char *)v80;
              uint64_t v14 = (int *)((char *)v80 + v71);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              uint64_t v14 = &v76;
              uint64_t v15 = (char *)v80;
            }
          }
          uint64_t v16 = &v15[24 * v81];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = *((void *)v14 + 2);
          *(_OWORD *)uint64_t v16 = v17;
          ++v81;
          if (v79[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
          }
        }
      }
      if (!v88) {
        return 0;
      }
      uint64_t v18 = (void **)__p;
      if (__p)
      {
        uint64_t v19 = v87;
        unint64_t v20 = __p;
        if (v87 != __p)
        {
          do
            uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          unint64_t v20 = __p;
        }
        unint64_t v87 = v18;
        operator delete(v20);
      }
      uint64_t v21 = v84;
      if (!v84) {
        goto LABEL_80;
      }
      uint64_t v22 = v85;
      uint64_t v23 = v84;
      if (v85 == v84) {
        goto LABEL_79;
      }
      do
      {
        uint64_t v25 = (void *)*--v22;
        uint64_t v24 = v25;
        *uint64_t v22 = 0;
        if (v25) {
          operator delete[](v24);
        }
      }
      while (v22 != v21);
      goto LABEL_78;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v75, "batch_dims", 0xAuLL);
  if (!v36)
  {
    a3(v79, a4);
    if (v79[0])
    {
      int v76 = 3;
      uint64_t v77 = "expected key entry for batch_dims in DictionaryAttr to set Properties.";
      uint64_t v78 = 70;
      uint64_t v52 = &v76;
      uint64_t v53 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v67 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v73 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          uint64_t v53 = (char *)v80;
          uint64_t v52 = (int *)((char *)v80 + v73);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          uint64_t v52 = &v76;
          uint64_t v53 = (char *)v80;
        }
      }
      uint64_t v54 = &v53[24 * v81];
      long long v55 = *(_OWORD *)v52;
      *((void *)v54 + 2) = *((void *)v52 + 2);
      *(_OWORD *)uint64_t v54 = v55;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
    if (!v88) {
      return 0;
    }
    char v56 = (void **)__p;
    if (__p)
    {
      uint64_t v57 = v87;
      unint64_t v58 = __p;
      if (v87 != __p)
      {
        do
          uint64_t v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        unint64_t v58 = __p;
      }
      unint64_t v87 = v56;
      operator delete(v58);
    }
    uint64_t v21 = v84;
    if (!v84) {
      goto LABEL_80;
    }
    uint64_t v59 = v85;
    uint64_t v23 = v84;
    if (v85 == v84) {
      goto LABEL_79;
    }
    do
    {
      uint64_t v61 = (void *)*--v59;
      uint64_t v60 = v61;
      void *v59 = 0;
      if (v61) {
        operator delete[](v60);
      }
    }
    while (v59 != v21);
    goto LABEL_78;
  }
  uint64_t v37 = v36;
  if (*(_UNKNOWN **)(*(void *)v36 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    a1[1] = v36;
    return 1;
  }
  a3(v79, a4);
  if (v79[0])
  {
    int v76 = 3;
    uint64_t v78 = 55;
    unint64_t v38 = &v76;
    unint64_t v39 = (char *)v80;
    if (v81 >= v82)
    {
      unint64_t v66 = v81 + 1;
      if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
      {
        int64_t v72 = (char *)&v76 - (unsigned char *)v80;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        unint64_t v39 = (char *)v80;
        unint64_t v38 = (int *)((char *)v80 + v72);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        unint64_t v38 = &v76;
        unint64_t v39 = (char *)v80;
      }
    }
    int64_t v40 = &v39[24 * v81];
    long long v41 = *(_OWORD *)v38;
    *((void *)v40 + 2) = *((void *)v38 + 2);
    *(_OWORD *)int64_t v40 = v41;
    ++v81;
    if (v79[0])
    {
      int64_t v42 = &v76;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v37);
      uint64_t v43 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v68 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v74 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          uint64_t v43 = (char *)v80;
          int64_t v42 = (int *)((char *)v80 + v74);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          int64_t v42 = &v76;
          uint64_t v43 = (char *)v80;
        }
      }
      int v44 = &v43[24 * v81];
      long long v45 = *(_OWORD *)v42;
      *((void *)v44 + 2) = *((void *)v42 + 2);
      *(_OWORD *)int v44 = v45;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
  }
  if (v88)
  {
    uint64_t v46 = (void **)__p;
    if (__p)
    {
      unint64_t v47 = v87;
      unsigned int v48 = __p;
      if (v87 != __p)
      {
        do
          unint64_t v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        unsigned int v48 = __p;
      }
      unint64_t v87 = v46;
      operator delete(v48);
    }
    uint64_t v21 = v84;
    if (!v84) {
      goto LABEL_80;
    }
    unsigned int v49 = v85;
    uint64_t v23 = v84;
    if (v85 == v84)
    {
LABEL_79:
      unint64_t v85 = v21;
      operator delete(v23);
LABEL_80:
      if (v80 != v83) {
        free(v80);
      }
      return 0;
    }
    do
    {
      uint64_t v51 = (void *)*--v49;
      unsigned int v50 = v51;
      void *v49 = 0;
      if (v51) {
        operator delete[](v50);
      }
    }
    while (v49 != v21);
LABEL_78:
    uint64_t v23 = v84;
    goto LABEL_79;
  }
  return 0;
}

uint64_t mlir::mps::GatherNDOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v21[6] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a1;
  uint64_t v19 = v21;
  uint64_t v20 = 0x300000000;
  if (*a2)
  {
    uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"allow_negative_indices", 22, *a2);
    uint64_t v5 = v4;
    unsigned int v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      unsigned int v6 = v20;
    }
    uint64_t v7 = (uint64_t *)((char *)v19 + 16 * v6);
    uint64_t *v7 = NamedAttr;
    v7[1] = v5;
    unsigned int v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    uint64_t v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      uint64_t v10 = (uint64_t *)v19;
      if (v8) {
        goto LABEL_6;
      }
LABEL_13:
      uint64_t DictionaryAttr = 0;
      if (v10 == v21) {
        return DictionaryAttr;
      }
      goto LABEL_7;
    }
  }
  else
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_5;
    }
  }
  uint64_t v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"batch_dims", 10, v9);
  uint64_t v15 = v14;
  unsigned int v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    unsigned int v16 = v20;
  }
  long long v17 = (uint64_t *)((char *)v19 + 16 * v16);
  *long long v17 = v13;
  v17[1] = v15;
  unsigned int v8 = v20 + 1;
  LODWORD(v20) = v8;
  uint64_t v10 = (uint64_t *)v19;
  if (!v8) {
    goto LABEL_13;
  }
LABEL_6:
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  uint64_t v10 = (uint64_t *)v19;
  if (v19 != v21) {
LABEL_7:
  }
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherNDOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x10uLL);
    *uint64_t v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::GatherNDOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherNDOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::GatherNDOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherNDOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::GatherNDOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 109;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        unsigned int v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::GatherNDOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[73];
    return a1[32];
  }
  return result;
}

void mlir::mps::GatherNDOp::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  void v26[2] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a4;
  uint64_t v21 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v20, 1);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherNDOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = a5;
  if (a6) {
    *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherNDOpGenericAdaptorBase::Properties>((void *)a2) = a6;
  }
  __src = v26;
  uint64_t v25 = 0x200000000;
  uint64_t v10 = *a1;
  unint64_t v11 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v23, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  unint64_t v14 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v22, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::GatherNDOp::inferReturnTypes(v10, v11, 1, v23[0], v23[1], Dictionary, v14, v15, v22[0], v22[1], &__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  unsigned int v16 = __src;
  }
  uint64_t v17 = v25;
  uint64_t v18 = *(unsigned int *)(a2 + 72);
  unint64_t v19 = v18 + v25;
  if (v19 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v19, 8);
    LODWORD(v18) = *(_DWORD *)(a2 + 72);
  }
  if (v17)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v18), v16, 8 * v17);
    LODWORD(v18) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v18 + v17;
  if (__src != v26) {
    free(__src);
  }
}

void mlir::mps::GatherNDOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6)
{
  unint64_t v30[2] = *MEMORY[0x1E4F143B8];
  uint64_t v24 = a4;
  uint64_t v25 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v25, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v24, 1);
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x20u, 0);
  uint64_t IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a5);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherNDOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = IntegerAttr;
  if (a6)
  {
    uint64_t UnitAttr = mlir::Builder::getUnitAttr((mlir::UnitAttr **)a1, v12);
    *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherNDOpGenericAdaptorBase::Properties>((void *)a2) = UnitAttr;
  }
  __src = v30;
  uint64_t v29 = 0x200000000;
  unint64_t v14 = *(mlir::UnknownLoc **)a1;
  int v15 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v27, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v18 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v26, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::GatherNDOp::inferReturnTypes(v14, v15, 1, v27[0], v27[1], Dictionary, v18, v19, v26[0], v26[1], &__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v20 = __src;
  }
  uint64_t v21 = v29;
  uint64_t v22 = *(unsigned int *)(a2 + 72);
  unint64_t v23 = v22 + v29;
  if (v23 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v23, 8);
    LODWORD(v22) = *(_DWORD *)(a2 + 72);
  }
  if (v21)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v22), v20, 8 * v21);
    LODWORD(v22) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v22 + v21;
  if (__src != v30) {
    free(__src);
  }
}

BOOL mlir::mps::GatherNDOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    uint64_t v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = (const void **)v3[1];
  if (v4)
  {
    uint64_t v5 = *v3;
    v20[0] = v2;
    if (mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v4, (const void **)"batch_dims", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20)&& (v20[0] = *this, mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (const void **)"allow_negative_indices", (const char *)0x16, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20))&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps7(
                            *this,
                            *(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8,
                            (const void **)"operand",
                            (const void **)7,
                            1u))
    {
      if (*((_DWORD *)*this + 9)) {
        uint64_t v6 = (uint64_t)(*this - 2);
      }
      else {
        uint64_t v6 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    uint64_t v18 = (const void **)"requires attribute 'batch_dims'";
    __int16 v19 = 259;
    mlir::OpState::emitOpError(this, &v18, (uint64_t)v20);
    uint64_t v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v20);
    if (v20[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v20);
    }
    if (v27)
    {
      unint64_t v9 = (void **)__p;
      if (__p)
      {
        uint64_t v10 = v26;
        unint64_t v11 = __p;
        if (v26 != __p)
        {
          do
            uint64_t v10 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v10 - 1);
          while (v10 != v9);
          unint64_t v11 = __p;
        }
        unint64_t v26 = v9;
        operator delete(v11);
      }
      uint64_t v12 = v23;
      if (v23)
      {
        uint64_t v13 = v24;
        unint64_t v14 = v23;
        if (v24 != v23)
        {
          do
          {
            unsigned int v16 = (void *)*--v13;
            int v15 = v16;
            void *v13 = 0;
            if (v16) {
              operator delete[](v15);
            }
          }
          while (v13 != v12);
          unint64_t v14 = v23;
        }
        uint64_t v24 = v12;
        operator delete(v14);
      }
      if (v21 != &v22) {
        free(v21);
      }
    }
  }
  return v8;
}

uint64_t mlir::mps::GatherNDOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.gather_nd", 13, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC97F628;
  v4[12] = mlir::mps::GatherNDOp::canonicalize;
  unint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::GatherOpGenericAdaptorBase::GatherOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (_OWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v11, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *(_OWORD *)v11;
  *(_OWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 40) = v8;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.gather", 10, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x10uLL);
    *uint64_t v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::GatherOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::GatherOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::GatherOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 107;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        long long v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::GatherOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[75];
    return a1[32];
  }
  return result;
}

void mlir::mps::GatherOp::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unint64_t v28[2] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = a4;
  uint64_t v23 = a3;
  uint64_t v21 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v23, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v22, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = a6;
  if (a7) {
    *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherOpGenericAdaptorBase::Properties>((void *)a2) = a7;
  }
  __src = v28;
  uint64_t v27 = 0x200000000;
  unint64_t v11 = *a1;
  uint64_t v12 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v25, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  int v15 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v24, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::GatherOp::inferReturnTypes(v11, v12, 1, v25[0], v25[1], Dictionary, v15, v16, v24[0], v24[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v17 = __src;
  }
  uint64_t v18 = v27;
  uint64_t v19 = *(unsigned int *)(a2 + 72);
  unint64_t v20 = v19 + v27;
  if (v20 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v20, 8);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  if (v18)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v19), v17, 8 * v18);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v19 + v18;
  if (__src != v28) {
    free(__src);
  }
}

void mlir::mps::GatherOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, int a7)
{
  unint64_t v32[2] = *MEMORY[0x1E4F143B8];
  uint64_t v26 = a4;
  uint64_t v27 = a3;
  uint64_t v25 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v27, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v26, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v25, 1);
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x20u, 0);
  uint64_t IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a6);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = IntegerAttr;
  if (a7)
  {
    uint64_t UnitAttr = mlir::Builder::getUnitAttr((mlir::UnitAttr **)a1, v13);
    *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherOpGenericAdaptorBase::Properties>((void *)a2) = UnitAttr;
  }
  __src = v32;
  uint64_t v31 = 0x200000000;
  int v15 = *(mlir::UnknownLoc **)a1;
  int v16 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v29, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v19 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v28, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::GatherOp::inferReturnTypes(v15, v16, 1, v29[0], v29[1], Dictionary, v19, v20, v28[0], v28[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v21 = __src;
  }
  uint64_t v22 = v31;
  uint64_t v23 = *(unsigned int *)(a2 + 72);
  unint64_t v24 = v23 + v31;
  if (v24 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v24, 8);
    LODWORD(v23) = *(_DWORD *)(a2 + 72);
  }
  if (v22)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v23), v21, 8 * v22);
    LODWORD(v23) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v23 + v22;
  if (__src != v32) {
    free(__src);
  }
}

BOOL mlir::mps::GatherOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    uint64_t v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    uint64_t v3 = 0;
  }
  unint64_t v4 = (const void **)v3[1];
  if (v4)
  {
    uint64_t v5 = *v3;
    v20[0] = v2;
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v4, (const void **)"batch_dims", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20))return 0; {
    v20[0] = *this;
    }
    if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (const void **)"allow_negative_indices", (const char *)0x16, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0))
    {
      return 0;
    }
    if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps7(*this, *(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))return 0; {
    if (mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 2u))
    }
    {
      if (*((_DWORD *)*this + 9)) {
        uint64_t v6 = (uint64_t)(*this - 2);
      }
      else {
        uint64_t v6 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    uint64_t v18 = (const void **)"requires attribute 'batch_dims'";
    __int16 v19 = 259;
    mlir::OpState::emitOpError(this, &v18, (uint64_t)v20);
    uint64_t v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v20);
    if (v20[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v20);
    }
    if (v27)
    {
      unint64_t v9 = (void **)__p;
      if (__p)
      {
        uint64_t v10 = v26;
        unint64_t v11 = __p;
        if (v26 != __p)
        {
          do
            uint64_t v10 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v10 - 1);
          while (v10 != v9);
          unint64_t v11 = __p;
        }
        uint64_t v26 = v9;
        operator delete(v11);
      }
      uint64_t v12 = v23;
      if (v23)
      {
        uint64_t v13 = v24;
        unint64_t v14 = v23;
        if (v24 != v23)
        {
          do
          {
            int v16 = (void *)*--v13;
            int v15 = v16;
            void *v13 = 0;
            if (v16) {
              operator delete[](v15);
            }
          }
          while (v13 != v12);
          unint64_t v14 = v23;
        }
        unint64_t v24 = v12;
        operator delete(v14);
      }
      if (v21 != &v22) {
        free(v21);
      }
    }
  }
  return v8;
}

uint64_t mlir::mps::GatherOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  unint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.gather", 10, v2, v3, 0, 0);
  *unint64_t v4 = &unk_1EC9834B8;
  v4[12] = mlir::mps::GatherOp::canonicalize;
  unint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::GeluOpGenericAdaptorBase::GeluOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.gelu", 8, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::GeluOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  unint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.gelu", 8, v2, v3, 0, 0);
  *unint64_t v4 = &unk_1EC982908;
  v4[12] = mlir::mps::GeluOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::GetCoordOpAdaptor::GetCoordOpAdaptor(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned char *)(a2 + 46) & 0x80) != 0)
  {
    uint64_t v4 = *(void *)(a2 + 72);
    unint64_t v5 = *(unsigned int *)(a2 + 68);
  }
  else
  {
    uint64_t v4 = 0;
    unint64_t v5 = 0;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v14, v4, v5);
  uint64_t v6 = *(void *)(a2 + 56);
  unint64_t v7 = *(unsigned int *)(a2 + 44);
  __int16 v8 = (void *)(a2 + 16 * ((v7 >> 23) & 1) + 64);
  unint64_t v9 = v7 & 0x7FFFFF;
  if ((v7 & 0x7FFFFF) != 0)
  {
    uint64_t v10 = (((unint64_t)v8 + ((v7 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v10 = 0;
    unint64_t v9 = 0;
  }
  long long v13 = v14;
  mlir::ValueRange::ValueRange(v15, v10, v9);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v6;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = *v8;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v15;
  if (v6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.get_coordinates", 19, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  *(_OWORD *)(a1 + 48) = v13;
  return a1;
}

uint64_t mlir::mps::GetCoordOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      int v44 = 3;
      long long v45 = "expected DictionaryAttr to set properties";
      uint64_t v46 = 41;
      uint64_t v26 = &v44;
      char v27 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v40 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          char v27 = (char *)v48;
          uint64_t v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          uint64_t v26 = &v44;
          char v27 = (char *)v48;
        }
      }
      uint64_t v28 = &v27[24 * v49];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)uint64_t v28 = v29;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
    if (!v56) {
      return 0;
    }
    unint64_t v30 = (void **)__p;
    if (__p)
    {
      uint64_t v31 = v55;
      unsigned int v32 = __p;
      if (v55 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unsigned int v32 = __p;
      }
      long long v55 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v52;
    if (!v52) {
      goto LABEL_43;
    }
    uint64_t v33 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v35 = (void *)*--v33;
      unint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "result_type", 0xBuLL);
  if (!v8) {
    return 1;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    int v44 = 3;
    uint64_t v46 = 56;
    uint64_t v10 = &v44;
    uint64_t v11 = (char *)v48;
    if (v49 >= v50)
    {
      unint64_t v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        int64_t v41 = (char *)&v44 - (unsigned char *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v11 = (char *)v48;
        uint64_t v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v10 = &v44;
        uint64_t v11 = (char *)v48;
      }
    }
    uint64_t v12 = &v11[24 * v49];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = *((void *)v10 + 2);
    *(_OWORD *)uint64_t v12 = v13;
    ++v49;
    if (v47[0])
    {
      long long v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      int v15 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v42 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          int v15 = (char *)v48;
          long long v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          long long v14 = &v44;
          int v15 = (char *)v48;
        }
      }
      uint64_t v16 = &v15[24 * v49];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = *((void *)v14 + 2);
      *(_OWORD *)uint64_t v16 = v17;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
  }
  if (!v56) {
    return 0;
  }
  uint64_t v18 = (void **)__p;
  if (__p)
  {
    __int16 v19 = v55;
    int v20 = __p;
    if (v55 != __p)
    {
      do
        __int16 v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      int v20 = __p;
    }
    long long v55 = v18;
    operator delete(v20);
  }
  uint64_t v21 = v52;
  if (v52)
  {
    uint64_t v22 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v25 = (void *)*--v22;
      unint64_t v24 = v25;
      *uint64_t v22 = 0;
      if (v25) {
        operator delete[](v24);
      }
    }
    while (v22 != v21);
LABEL_41:
    uint64_t v23 = v52;
LABEL_42:
    uint64_t v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51) {
    free(v48);
  }
  return 0;
}

uint64_t mlir::mps::GetCoordOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v15[6] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a1;
  long long v13 = v15;
  uint64_t v14 = 0x300000000;
  if (!*a2) {
    return 0;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"result_type", 11, *a2);
  uint64_t v4 = v3;
  unsigned int v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    unsigned int v5 = v14;
  }
  uint64_t v6 = (uint64_t *)((char *)v13 + 16 * v5);
  uint64_t *v6 = NamedAttr;
  v6[1] = v4;
  unint64_t v7 = v13;
  BOOL v8 = __CFADD__(v14, 1);
  uint64_t v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v13 == v15) {
      return DictionaryAttr;
    }
    goto LABEL_10;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (uint64_t *)v13, v9);
  unint64_t v7 = v13;
  if (v13 != v15) {
LABEL_10:
  }
    free(v7);
  return DictionaryAttr;
}

void mlir::mps::GetCoordOp::build(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void mlir::mps::GetCoordOp::build(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v25[2] = *MEMORY[0x1E4F143B8];
  uint64_t v19 = a4;
  uint64_t v20 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v20, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v19, 1);
  if (a5) {
    *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GetCoordOpGenericAdaptorBase::Properties>((void *)a2) = a5;
  }
  __src = v25;
  uint64_t v24 = 0x200000000;
  uint64_t v8 = *a1;
  mlir::ValueRange::ValueRange((unint64_t *)v22, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v11 = *(void **)(a2 + 256);
  mlir::ValueRange::ValueRange(v21, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::GetCoordOp::inferReturnTypes(v8, v12, v13, v22[0], (uint64_t)v22[1], Dictionary, v11, v14, v21[0], v21[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  int v15 = __src;
  }
  uint64_t v16 = v24;
  uint64_t v17 = *(unsigned int *)(a2 + 72);
  unint64_t v18 = v17 + v24;
  if (v18 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v18, 8);
    LODWORD(v17) = *(_DWORD *)(a2 + 72);
  }
  if (v16)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v17), v15, 8 * v16);
    LODWORD(v17) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v17 + v16;
  if (__src != v25) {
    free(__src);
  }
}

BOOL mlir::mps::GetCoordOp::verifyInvariantsImpl(uint64_t **this)
{
  __int16 v2 = *this;
  uint64_t v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  unint64_t v7 = v2;
  if (!mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v3, (const void **)"result_type", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps4(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v7)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v4 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps24(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::GetCoordOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.get_coordinates", 19, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC97F680;
  v4[12] = mlir::mps::GetCoordOp::canonicalize;
  uint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::GreaterThanOpGenericAdaptorBase::GreaterThanOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.greater", 11, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::GreaterThanOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.greater", 11, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC9801D8;
  v4[12] = mlir::mps::GreaterThanOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::GreaterThanOrEqualToOpGenericAdaptorBase::GreaterThanOrEqualToOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.greater_equal", 17, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::GreaterThanOrEqualToOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.greater_equal", 17, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC981B48;
  v4[12] = mlir::mps::GreaterThanOrEqualToOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::HammingDistanceOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    *uint64_t v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::HammingDistanceOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::HammingDistanceOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::HammingDistanceOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::HammingDistanceOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::HammingDistanceOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 116;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        __int16 v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::HammingDistanceOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[77];
    return a1[32];
  }
  return result;
}

void mlir::mps::HammingDistanceOp::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v26[2] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a4;
  uint64_t v21 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v20, 1);
  uint64_t v8 = mlir::TypeAttr::get(a5);
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::HammingDistanceOpGenericAdaptorBase::Properties>((void *)a2) = v8;
  __src = v26;
  uint64_t v25 = 0x200000000;
  unint64_t v9 = *a1;
  mlir::ValueRange::ValueRange(v23, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v12 = *(uint64_t **)(a2 + 256);
  mlir::ValueRange::ValueRange(v22, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::HammingDistanceOp::inferReturnTypes(v9, v13, v14, v23[0], v23[1], Dictionary, v12, v15, v22[0], v22[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v16 = __src;
  }
  uint64_t v17 = v25;
  uint64_t v18 = *(unsigned int *)(a2 + 72);
  unint64_t v19 = v18 + v25;
  if (v19 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v19, 8);
    LODWORD(v18) = *(_DWORD *)(a2 + 72);
  }
  if (v17)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v18), v16, 8 * v17);
    LODWORD(v18) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v18 + v17;
  if (__src != v26) {
    free(__src);
  }
}

BOOL mlir::mps::HammingDistanceOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  uint64_t v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (v3)
  {
    v18[0] = v2;
    if (mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v3, (const void **)"resultElementType", (const char *)0x11, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps4(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v18)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps27(*this, *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps27(*this, *(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
    {
      if (*((_DWORD *)*this + 9)) {
        uint64_t v4 = (uint64_t)(*this - 2);
      }
      else {
        uint64_t v4 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    uint64_t v16 = (const void **)"requires attribute 'resultElementType'";
    __int16 v17 = 259;
    mlir::OpState::emitOpError(this, &v16, (uint64_t)v18);
    uint64_t v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v18);
    if (v18[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
    }
    if (v25)
    {
      unint64_t v7 = (void **)__p;
      if (__p)
      {
        uint64_t v8 = v24;
        unint64_t v9 = __p;
        if (v24 != __p)
        {
          do
            uint64_t v8 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v8 - 1);
          while (v8 != v7);
          unint64_t v9 = __p;
        }
        uint64_t v24 = v7;
        operator delete(v9);
      }
      uint64_t v10 = v21;
      if (v21)
      {
        unint64_t v11 = v22;
        uint64_t v12 = v21;
        if (v22 != v21)
        {
          do
          {
            int v14 = (void *)*--v11;
            uint64_t v13 = v14;
            void *v11 = 0;
            if (v14) {
              operator delete[](v13);
            }
          }
          while (v11 != v10);
          uint64_t v12 = v21;
        }
        uint64_t v22 = v10;
        operator delete(v12);
      }
      if (v19 != &v20) {
        free(v19);
      }
    }
  }
  return v6;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps27(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *(void *)a2;
  unint64_t v11 = *(void **)(*(void *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)v51, 32)) {
      return 1;
    }
  }
  __int16 v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    int v53 = 3;
    uint64_t v54 = " #";
    uint64_t v55 = 2;
    int v14 = &v53;
    int v15 = (char *)v57;
    if (v58 >= v59)
    {
      unint64_t v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        int64_t v47 = (char *)&v53 - (unsigned char *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        int v15 = (char *)v57;
        int v14 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        int v14 = &v53;
        int v15 = (char *)v57;
      }
    }
    uint64_t v16 = &v15[24 * v58];
    long long v17 = *(_OWORD *)v14;
    *((void *)v16 + 2) = *((void *)v14 + 2);
    *(_OWORD *)uint64_t v16 = v17;
    uint64_t v18 = ++v58;
    if (v56[0])
    {
      int v53 = 5;
      uint64_t v54 = (const char *)a5;
      unint64_t v19 = &v53;
      uint64_t v20 = (char *)v57;
      if (v18 >= v59)
      {
        unint64_t v42 = v18 + 1;
        BOOL v43 = (char *)v57 + 24 * v18 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          int64_t v48 = (char *)&v53 - (unsigned char *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          uint64_t v20 = (char *)v57;
          unint64_t v19 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          unint64_t v19 = &v53;
          uint64_t v20 = (char *)v57;
        }
      }
      uint64_t v21 = &v20[24 * v58];
      long long v22 = *(_OWORD *)v19;
      *((void *)v21 + 2) = *((void *)v19 + 2);
      *(_OWORD *)uint64_t v21 = v22;
      uint64_t v23 = ++v58;
      if (v56[0])
      {
        int v53 = 3;
        uint64_t v54 = " must be tensor of 32-bit unsigned integer values, but got ";
        uint64_t v55 = 59;
        uint64_t v24 = &v53;
        char v25 = (char *)v57;
        if (v23 >= v59)
        {
          unint64_t v44 = v23 + 1;
          BOOL v45 = (char *)v57 + 24 * v23 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            int64_t v49 = (char *)&v53 - (unsigned char *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            char v25 = (char *)v57;
            uint64_t v24 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            uint64_t v24 = &v53;
            char v25 = (char *)v57;
          }
        }
        uint64_t v26 = &v25[24 * v58];
        long long v27 = *(_OWORD *)v24;
        *((void *)v26 + 2) = *((void *)v24 + 2);
        *(_OWORD *)uint64_t v26 = v27;
        ++v58;
        if (v56[0])
        {
          uint64_t v28 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          long long v29 = (char *)v57;
          if (v58 >= v59)
          {
            unint64_t v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              int64_t v50 = (char *)&v53 - (unsigned char *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              long long v29 = (char *)v57;
              uint64_t v28 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              uint64_t v28 = &v53;
              long long v29 = (char *)v57;
            }
          }
          unint64_t v30 = &v29[24 * v58];
          long long v31 = *(_OWORD *)v28;
          *((void *)v30 + 2) = *((void *)v28 + 2);
          *(_OWORD *)unint64_t v30 = v31;
          ++v58;
        }
      }
    }
  }
  uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  }
  if (v65)
  {
    unsigned int v32 = (void **)__p;
    if (__p)
    {
      uint64_t v33 = v64;
      unint64_t v34 = __p;
      if (v64 != __p)
      {
        do
          uint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        unint64_t v34 = __p;
      }
      unint64_t v64 = v32;
      operator delete(v34);
    }
    uint64_t v35 = v61;
    if (v61)
    {
      uint64_t v36 = v62;
      unint64_t v37 = v61;
      if (v62 != v61)
      {
        do
        {
          unint64_t v39 = (void *)*--v36;
          unint64_t v38 = v39;
          *uint64_t v36 = 0;
          if (v39) {
            operator delete[](v38);
          }
        }
        while (v36 != v35);
        unint64_t v37 = v61;
      }
      unint64_t v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60) {
      free(v57);
    }
  }
  return v13;
}

uint64_t mlir::mps::HammingDistanceOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.hamming_distance", 20, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC9810A0;
  v4[12] = mlir::mps::HammingDistanceOp::canonicalize;
  unint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::HermiteanToRealFFTOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v109 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v95 = v6;
  if (!v6)
  {
    a3(v99, a4);
    if (v99[0])
    {
      int v96 = 3;
      unint64_t v97 = "expected DictionaryAttr to set properties";
      uint64_t v98 = 41;
      uint64_t v26 = &v96;
      long long v27 = (char *)v100;
      if (v101 >= v102)
      {
        unint64_t v79 = v101 + 1;
        if (v100 <= &v96 && (char *)v100 + 24 * v101 > (char *)&v96)
        {
          int64_t v87 = (char *)&v96 - (unsigned char *)v100;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v79, 24);
          long long v27 = (char *)v100;
          uint64_t v26 = (int *)((char *)v100 + v87);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v79, 24);
          uint64_t v26 = &v96;
          long long v27 = (char *)v100;
        }
      }
      uint64_t v28 = &v27[24 * v101];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)uint64_t v28 = v29;
      ++v101;
      if (v99[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v99);
      }
    }
    if (!v108) {
      return 0;
    }
    unint64_t v30 = (void **)__p;
    if (__p)
    {
      long long v31 = v107;
      unsigned int v32 = __p;
      if (v107 != __p)
      {
        do
          long long v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unsigned int v32 = __p;
      }
      unint64_t v107 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v104;
    if (!v104) {
      goto LABEL_101;
    }
    uint64_t v33 = v105;
    uint64_t v23 = v104;
    if (v105 == v104) {
      goto LABEL_100;
    }
    do
    {
      uint64_t v35 = (void *)*--v33;
      unint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
    goto LABEL_99;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v95, "inverse", 7uLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v99, a4);
      if (v99[0])
      {
        int v96 = 3;
        uint64_t v98 = 52;
        uint64_t v10 = &v96;
        unint64_t v11 = (char *)v100;
        if (v101 >= v102)
        {
          unint64_t v80 = v101 + 1;
          if (v100 <= &v96 && (char *)v100 + 24 * v101 > (char *)&v96)
          {
            int64_t v88 = (char *)&v96 - (unsigned char *)v100;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v80, 24);
            unint64_t v11 = (char *)v100;
            uint64_t v10 = (int *)((char *)v100 + v88);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v80, 24);
            uint64_t v10 = &v96;
            unint64_t v11 = (char *)v100;
          }
        }
        uint64_t v12 = &v11[24 * v101];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = *((void *)v10 + 2);
        *(_OWORD *)uint64_t v12 = v13;
        ++v101;
        if (v99[0])
        {
          int v14 = &v96;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v96, v9);
          int v15 = (char *)v100;
          if (v101 >= v102)
          {
            unint64_t v81 = v101 + 1;
            if (v100 <= &v96 && (char *)v100 + 24 * v101 > (char *)&v96)
            {
              int64_t v89 = (char *)&v96 - (unsigned char *)v100;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v81, 24);
              int v15 = (char *)v100;
              int v14 = (int *)((char *)v100 + v89);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v81, 24);
              int v14 = &v96;
              int v15 = (char *)v100;
            }
          }
          uint64_t v16 = &v15[24 * v101];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = *((void *)v14 + 2);
          *(_OWORD *)uint64_t v16 = v17;
          ++v101;
          if (v99[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v99);
          }
        }
      }
      if (!v108) {
        return 0;
      }
      uint64_t v18 = (void **)__p;
      if (__p)
      {
        unint64_t v19 = v107;
        uint64_t v20 = __p;
        if (v107 != __p)
        {
          do
            unint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          uint64_t v20 = __p;
        }
        unint64_t v107 = v18;
        operator delete(v20);
      }
      uint64_t v21 = v104;
      if (!v104) {
        goto LABEL_101;
      }
      long long v22 = v105;
      uint64_t v23 = v104;
      if (v105 == v104) {
        goto LABEL_100;
      }
      do
      {
        char v25 = (void *)*--v22;
        uint64_t v24 = v25;
        *long long v22 = 0;
        if (v25) {
          operator delete[](v24);
        }
      }
      while (v22 != v21);
      goto LABEL_99;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v95, "round_to_odd", 0xCuLL);
  if (v36)
  {
    uint64_t v37 = v36;
    if (*(_UNKNOWN **)(*(void *)v36 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v99, a4);
      if (v99[0])
      {
        int v96 = 3;
        uint64_t v98 = 57;
        unint64_t v38 = &v96;
        unint64_t v39 = (char *)v100;
        if (v101 >= v102)
        {
          unint64_t v82 = v101 + 1;
          if (v100 <= &v96 && (char *)v100 + 24 * v101 > (char *)&v96)
          {
            int64_t v90 = (char *)&v96 - (unsigned char *)v100;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v82, 24);
            unint64_t v39 = (char *)v100;
            unint64_t v38 = (int *)((char *)v100 + v90);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v82, 24);
            unint64_t v38 = &v96;
            unint64_t v39 = (char *)v100;
          }
        }
        int64_t v40 = &v39[24 * v101];
        long long v41 = *(_OWORD *)v38;
        *((void *)v40 + 2) = *((void *)v38 + 2);
        *(_OWORD *)int64_t v40 = v41;
        ++v101;
        if (v99[0])
        {
          unint64_t v42 = &v96;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v96, v37);
          BOOL v43 = (char *)v100;
          if (v101 >= v102)
          {
            unint64_t v83 = v101 + 1;
            if (v100 <= &v96 && (char *)v100 + 24 * v101 > (char *)&v96)
            {
              int64_t v91 = (char *)&v96 - (unsigned char *)v100;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v83, 24);
              BOOL v43 = (char *)v100;
              unint64_t v42 = (int *)((char *)v100 + v91);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v83, 24);
              unint64_t v42 = &v96;
              BOOL v43 = (char *)v100;
            }
          }
          unint64_t v44 = &v43[24 * v101];
          long long v45 = *(_OWORD *)v42;
          *((void *)v44 + 2) = *((void *)v42 + 2);
          *(_OWORD *)unint64_t v44 = v45;
          ++v101;
          if (v99[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v99);
          }
        }
      }
      if (!v108) {
        return 0;
      }
      unint64_t v46 = (void **)__p;
      if (__p)
      {
        int64_t v47 = v107;
        int64_t v48 = __p;
        if (v107 != __p)
        {
          do
            int64_t v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
          while (v47 != v46);
          int64_t v48 = __p;
        }
        unint64_t v107 = v46;
        operator delete(v48);
      }
      uint64_t v21 = v104;
      if (!v104) {
        goto LABEL_101;
      }
      int64_t v49 = v105;
      uint64_t v23 = v104;
      if (v105 == v104) {
        goto LABEL_100;
      }
      do
      {
        uint64_t v51 = (void *)*--v49;
        int64_t v50 = v51;
        void *v49 = 0;
        if (v51) {
          operator delete[](v50);
        }
      }
      while (v49 != v21);
      goto LABEL_99;
    }
    a1[1] = v36;
  }
  uint64_t v52 = mlir::DictionaryAttr::get((uint64_t)&v95, "scaling_mode", 0xCuLL);
  if (!v52)
  {
    a3(v99, a4);
    if (v99[0])
    {
      int v96 = 3;
      unint64_t v97 = "expected key entry for scaling_mode in DictionaryAttr to set Properties.";
      uint64_t v98 = 72;
      unint64_t v68 = &v96;
      int64_t v69 = (char *)v100;
      if (v101 >= v102)
      {
        unint64_t v85 = v101 + 1;
        if (v100 <= &v96 && (char *)v100 + 24 * v101 > (char *)&v96)
        {
          int64_t v93 = (char *)&v96 - (unsigned char *)v100;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v85, 24);
          int64_t v69 = (char *)v100;
          unint64_t v68 = (int *)((char *)v100 + v93);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v85, 24);
          unint64_t v68 = &v96;
          int64_t v69 = (char *)v100;
        }
      }
      int64_t v70 = &v69[24 * v101];
      long long v71 = *(_OWORD *)v68;
      *((void *)v70 + 2) = *((void *)v68 + 2);
      *(_OWORD *)int64_t v70 = v71;
      ++v101;
      if (v99[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v99);
      }
    }
    if (!v108) {
      return 0;
    }
    int64_t v72 = (void **)__p;
    if (__p)
    {
      int64_t v73 = v107;
      int64_t v74 = __p;
      if (v107 != __p)
      {
        do
          int64_t v73 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v73 - 1);
        while (v73 != v72);
        int64_t v74 = __p;
      }
      unint64_t v107 = v72;
      operator delete(v74);
    }
    uint64_t v21 = v104;
    if (!v104) {
      goto LABEL_101;
    }
    uint64_t v75 = v105;
    uint64_t v23 = v104;
    if (v105 == v104) {
      goto LABEL_100;
    }
    do
    {
      uint64_t v77 = (void *)*--v75;
      int v76 = v77;
      *uint64_t v75 = 0;
      if (v77) {
        operator delete[](v76);
      }
    }
    while (v75 != v21);
    goto LABEL_99;
  }
  uint64_t v53 = v52;
  if (*(_UNKNOWN **)(*(void *)v52 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id)
  {
    a1[2] = v52;
    return 1;
  }
  a3(v99, a4);
  if (v99[0])
  {
    int v96 = 3;
    uint64_t v98 = 57;
    uint64_t v54 = &v96;
    uint64_t v55 = (char *)v100;
    if (v101 >= v102)
    {
      unint64_t v84 = v101 + 1;
      if (v100 <= &v96 && (char *)v100 + 24 * v101 > (char *)&v96)
      {
        int64_t v92 = (char *)&v96 - (unsigned char *)v100;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v84, 24);
        uint64_t v55 = (char *)v100;
        uint64_t v54 = (int *)((char *)v100 + v92);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v84, 24);
        uint64_t v54 = &v96;
        uint64_t v55 = (char *)v100;
      }
    }
    char v56 = &v55[24 * v101];
    long long v57 = *(_OWORD *)v54;
    *((void *)v56 + 2) = *((void *)v54 + 2);
    *(_OWORD *)char v56 = v57;
    ++v101;
    if (v99[0])
    {
      unsigned int v58 = &v96;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v96, v53);
      unsigned int v59 = (char *)v100;
      if (v101 >= v102)
      {
        unint64_t v86 = v101 + 1;
        if (v100 <= &v96 && (char *)v100 + 24 * v101 > (char *)&v96)
        {
          int64_t v94 = (char *)&v96 - (unsigned char *)v100;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v86, 24);
          unsigned int v59 = (char *)v100;
          unsigned int v58 = (int *)((char *)v100 + v94);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v86, 24);
          unsigned int v58 = &v96;
          unsigned int v59 = (char *)v100;
        }
      }
      uint64_t v60 = &v59[24 * v101];
      long long v61 = *(_OWORD *)v58;
      *((void *)v60 + 2) = *((void *)v58 + 2);
      *(_OWORD *)uint64_t v60 = v61;
      ++v101;
      if (v99[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v99);
      }
    }
  }
  if (v108)
  {
    unint64_t v62 = (void **)__p;
    if (__p)
    {
      unint64_t v63 = v107;
      unint64_t v64 = __p;
      if (v107 != __p)
      {
        do
          unint64_t v63 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v63 - 1);
        while (v63 != v62);
        unint64_t v64 = __p;
      }
      unint64_t v107 = v62;
      operator delete(v64);
    }
    uint64_t v21 = v104;
    if (!v104) {
      goto LABEL_101;
    }
    char v65 = v105;
    uint64_t v23 = v104;
    if (v105 == v104)
    {
LABEL_100:
      unint64_t v105 = v21;
      operator delete(v23);
LABEL_101:
      if (v100 != v103) {
        free(v100);
      }
      return 0;
    }
    do
    {
      unint64_t v67 = (void *)*--v65;
      uint64_t v66 = v67;
      *char v65 = 0;
      if (v67) {
        operator delete[](v66);
      }
    }
    while (v65 != v21);
LABEL_99:
    uint64_t v23 = v104;
    goto LABEL_100;
  }
  return 0;
}

uint64_t mlir::mps::HermiteanToRealFFTOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  unsigned int v27[6] = *MEMORY[0x1E4F143B8];
  uint64_t v24 = a1;
  char v25 = v27;
  uint64_t v26 = 0x300000000;
  if (!*a2)
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v24, (uint64_t)"inverse", 7, *a2);
  uint64_t v5 = v4;
  unsigned int v6 = v26;
  if (v26 >= HIDWORD(v26))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 16);
    unsigned int v6 = v26;
  }
  unint64_t v7 = (uint64_t *)((char *)v25 + 16 * v6);
  uint64_t *v7 = NamedAttr;
  v7[1] = v5;
  unsigned int v8 = v26 + 1;
  LODWORD(v26) = v26 + 1;
  uint64_t v9 = a2[1];
  if (v9)
  {
LABEL_7:
    uint64_t v10 = mlir::Builder::getNamedAttr(&v24, (uint64_t)"round_to_odd", 12, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v26;
    if (v26 >= HIDWORD(v26))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 16);
      unsigned int v13 = v26;
    }
    int v14 = (uint64_t *)((char *)v25 + 16 * v13);
    *int v14 = v10;
    v14[1] = v12;
    unsigned int v8 = v26 + 1;
    LODWORD(v26) = v26 + 1;
  }
LABEL_10:
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v24, (uint64_t)"scaling_mode", 12, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v26;
    if (v26 >= HIDWORD(v26))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 16);
      unsigned int v19 = v26;
    }
    uint64_t v20 = (uint64_t *)((char *)v25 + 16 * v19);
    *uint64_t v20 = v16;
    v20[1] = v18;
    unsigned int v8 = v26 + 1;
    LODWORD(v26) = v26 + 1;
  }
  uint64_t v21 = v25;
  if (!v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v25 == v27) {
      return DictionaryAttr;
    }
    goto LABEL_16;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v24, (uint64_t *)v25, v8);
  uint64_t v21 = v25;
  if (v25 != v27) {
LABEL_16:
  }
    free(v21);
  return DictionaryAttr;
}

uint64_t mlir::mps::HermiteanToRealFFTOp::setInherentAttr(uint64_t result, char *__s1, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = result;
  if (a3 == 12)
  {
    uint64_t result = memcmp(__s1, "round_to_odd", 0xCuLL);
    if (result)
    {
      if (*(void *)__s1 == 0x5F676E696C616373 && *((_DWORD *)__s1 + 2) == 1701080941)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id) {
            uint64_t v9 = a4;
          }
          else {
            uint64_t v9 = 0;
          }
          *(void *)(v6 + 16) = v9;
        }
        else
        {
          *(void *)(v6 + 16) = 0;
        }
      }
    }
    else if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
        uint64_t v11 = a4;
      }
      else {
        uint64_t v11 = 0;
      }
      *(void *)(v6 + 8) = v11;
    }
    else
    {
      *(void *)(v6 + 8) = 0;
    }
  }
  else if (a3 == 7 && *(_DWORD *)__s1 == 1702260329 && *(_DWORD *)(__s1 + 3) == 1702064741)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
        uint64_t v10 = a4;
      }
      else {
        uint64_t v10 = 0;
      }
      *(void *)uint64_t result = v10;
    }
    else
    {
      *(void *)uint64_t result = 0;
    }
  }
  return result;
}

BOOL mlir::mps::HermiteanToRealFFTOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v8, (const void **)"inverse", (const char *)7, a3, a4))
  {
    uint64_t v9 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v9, (const void **)"round_to_odd", (const char *)0xC, a3, a4))
    {
      uint64_t v10 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps27(v10, (const void **)"scaling_mode", (const char *)0xC, a3, a4))
      {
        return 1;
      }
    }
  }
  return result;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::HermiteanToRealFFTOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x18uLL);
    v3[1] = 0;
    v3[2] = 0;
    *uint64_t v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::HermiteanToRealFFTOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::HermiteanToRealFFTOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::HermiteanToRealFFTOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::HermiteanToRealFFTOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        unsigned int v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::HermiteanToRealFFTOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 119;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::HermiteanToRealFFTOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[79];
    return a1[32];
  }
  return result;
}

void mlir::mps::HermiteanToRealFFTOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6, int a7)
{
  unint64_t v36[2] = *MEMORY[0x1E4F143B8];
  uint64_t v29 = a4;
  uint64_t v30 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v30, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v29, 1);
  uint64_t v12 = *a1;
  unsigned int v31 = a5;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v12);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id;
  uint64_t v35 = (uint64_t)v12;
  uint64_t v14 = mlir::StorageUniquer::get<mlir::mps::detail::FFTScalingModeAttrStorage,mlir::mps::FFTScalingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25FFTScalingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18FFTScalingModeAttrEJNS2_14FFTScalingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id, &v31);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::HermiteanToRealFFTOpGenericAdaptorBase::Properties>((void *)a2)
            + 16) = v14;
  if (a6)
  {
    uint64_t UnitAttr = mlir::Builder::getUnitAttr(a1, v15);
    *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::HermiteanToRealFFTOpGenericAdaptorBase::Properties>((void *)a2) = UnitAttr;
  }
  if (a7)
  {
    uint64_t v17 = mlir::Builder::getUnitAttr(a1, v15);
    *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::HermiteanToRealFFTOpGenericAdaptorBase::Properties>((void *)a2)
              + 8) = v17;
  }
  __src = v36;
  uint64_t v35 = 0x200000000;
  uint64_t v18 = *a1;
  mlir::ValueRange::ValueRange(v33, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v21 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v32, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::HermiteanToRealFFTOp::inferReturnTypes(v18, v22, v23, v33[0], v33[1], Dictionary, v21, v24, v32[0], v32[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  char v25 = __src;
  }
  uint64_t v26 = v35;
  uint64_t v27 = *(unsigned int *)(a2 + 72);
  unint64_t v28 = v27 + v35;
  if (v28 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v28, 8);
    LODWORD(v27) = *(_DWORD *)(a2 + 72);
  }
  if (v26)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v27), v25, 8 * v26);
    LODWORD(v27) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v27 + v26;
  if (__src != v36) {
    free(__src);
  }
}

BOOL mlir::mps::HermiteanToRealFFTOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    uint64_t v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = v3[2];
  if (v4)
  {
    uint64_t v6 = *v3;
    uint64_t v5 = v3[1];
    v21[0] = v2;
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps27(v4, (const void **)"scaling_mode", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps27(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v21))return 0; {
    v21[0] = *this;
    }
    if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v6, (const void **)"inverse", (const char *)7, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v21))return 0; {
    v21[0] = *this;
    }
    if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (const void **)"round_to_odd", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v21))return 0; {
    if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps19(*this, *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0))return 0;
    }
    if (mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
    {
      if (*((_DWORD *)*this + 9)) {
        uint64_t v7 = (uint64_t)(*this - 2);
      }
      else {
        uint64_t v7 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps5(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    unsigned int v19 = (const void **)"requires attribute 'scaling_mode'";
    __int16 v20 = 259;
    mlir::OpState::emitOpError(this, &v19, (uint64_t)v21);
    uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v21);
    if (v21[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v21);
    }
    if (v28)
    {
      uint64_t v10 = (void **)__p;
      if (__p)
      {
        unint64_t v11 = v27;
        uint64_t v12 = __p;
        if (v27 != __p)
        {
          do
            unint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
          while (v11 != v10);
          uint64_t v12 = __p;
        }
        uint64_t v27 = v10;
        operator delete(v12);
      }
      unsigned int v13 = v24;
      if (v24)
      {
        uint64_t v14 = v25;
        uint64_t v15 = v24;
        if (v25 != v24)
        {
          do
          {
            uint64_t v17 = (void *)*--v14;
            uint64_t v16 = v17;
            *uint64_t v14 = 0;
            if (v17) {
              operator delete[](v16);
            }
          }
          while (v14 != v13);
          uint64_t v15 = v24;
        }
        char v25 = v13;
        operator delete(v15);
      }
      if (v22 != &v23) {
        free(v22);
      }
    }
  }
  return v9;
}

uint64_t mlir::mps::HermiteanToRealFFTOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.hermitean_to_real_fft", 25, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC981830;
  v4[12] = mlir::mps::HermiteanToRealFFTOp::canonicalize;
  uint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::IdentityOpGenericAdaptorBase::IdentityOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.identity", 12, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::IdentityOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.identity", 12, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC97F6D8;
  v4[12] = mlir::mps::IdentityOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::ImToColOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[4];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xDuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x79616C5F61746164 || *(void *)(__s1 + 3) != 0x74756F79616C5F61) {
        return 0;
      }
      return *a2;
    case 0xCuLL:
      if (memcmp(__s1, "kernel_sizes", __n)) {
        return 0;
      }
      return a2[3];
    case 0xEuLL:
      if (memcmp(__s1, "dilation_rates", __n)) {
        return 0;
      }
      return a2[1];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::ImToColOp::setInherentAttr(uint64_t result, char *__s1, size_t a3, uint64_t a4)
{
  unint64_t v5 = (void *)result;
  switch(a3)
  {
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v5[4] = v11;
        }
        else
        {
          v5[4] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x79616C5F61746164 && *(void *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
            uint64_t v7 = a4;
          }
          else {
            uint64_t v7 = 0;
          }
          *(void *)uint64_t result = v7;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xCuLL:
      uint64_t result = memcmp(__s1, "kernel_sizes", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          v5[3] = v8;
        }
        else
        {
          v5[3] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v9 = a4;
          }
          else {
            uint64_t v9 = 0;
          }
          v5[1] = v9;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          void v5[2] = v10;
        }
        else
        {
          void v5[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x28uLL);
    *uint64_t v3 = 0u;
    v3[1] = 0u;
    *((void *)v3 + 4) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        unsigned int v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 108;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[81];
    return a1[32];
  }
  return result;
}

void mlir::mps::ImToColOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5, long long *a6, uint64_t a7, uint64_t a8, long long *a9, uint64_t a10, uint64_t *a11, uint64_t a12, unsigned int a13)
{
  uint64_t v16 = mlir::mps::get2DElementsForImToCol(a1, a4);
  uint64_t v17 = mlir::mps::get2DElementsForImToCol(a1, a6);
  uint64_t v18 = mlir::mps::get2DElementsForImToCol(a1, a9);
  uint64_t FormattedPaddingImToCol = mlir::mps::getFormattedPaddingImToCol(a1, a11, a12, a13);

  mlir::mps::ImToColOp::build((mlir::MLIRContext **)a1, a2, a3, v16, v17, v18, FormattedPaddingImToCol, a13);
}

void mlir::mps::ImToColOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8)
{
  unint64_t v35[2] = *MEMORY[0x1E4F143B8];
  uint64_t v29 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v29, 1);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties>((void *)a2)
            + 24) = a4;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties>((void *)a2)
            + 32) = a5;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties>((void *)a2)
            + 8) = a6;
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties>((void *)a2)
            + 16) = a7;
  uint64_t v15 = *a1;
  unsigned int v30 = a8;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v15);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  uint64_t v34 = (uint64_t)v15;
  uint64_t v17 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v30);
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties>((void *)a2) = v17;
  __src = v35;
  uint64_t v34 = 0x200000000;
  uint64_t v18 = *a1;
  mlir::ValueRange::ValueRange(v32, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v21 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v31, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::ImToColOp::inferReturnTypes(v18, v22, v23, v32[0], v32[1], Dictionary, v21, v24, v31[0], v31[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  char v25 = __src;
  }
  uint64_t v26 = v34;
  uint64_t v27 = *(unsigned int *)(a2 + 72);
  unint64_t v28 = v27 + v34;
  if (v28 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v28, 8);
    LODWORD(v27) = *(_DWORD *)(a2 + 72);
  }
  if (v26)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v27), v25, 8 * v26);
    LODWORD(v27) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v27 + v26;
  if (__src != v35) {
    free(__src);
  }
}

BOOL mlir::mps::ImToColOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    unint64_t v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    unint64_t v3 = 0;
  }
  uint64_t v4 = *(_DWORD **)v3;
  if (*(void *)v3)
  {
    int v5 = *(void **)(v3 + 8);
    if (v5)
    {
      unint64_t v6 = *(const void ***)(v3 + 16);
      if (v6)
      {
        unint64_t v7 = *(void **)(v3 + 24);
        if (v7)
        {
          uint64_t v8 = *(void **)(v3 + 32);
          if (v8)
          {
            v47[0] = v2;
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v7, (const void **)"kernel_sizes", (const char *)0xC, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0; {
            v47[0] = *this;
            }
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v8, (const void **)"strides", (const char *)7, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0; {
            v47[0] = *this;
            }
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0; {
            v47[0] = *this;
            }
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0; {
            v47[0] = *this;
            }
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps7(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps7(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps10(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0))
            {
              return 0;
            }
            if (*((_DWORD *)*this + 9)) {
              uint64_t v9 = (uint64_t)(*this - 2);
            }
            else {
              uint64_t v9 = 0;
            }
            uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v9, 0);
            return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
          }
          v45[0] = (const void **)"requires attribute 'strides'";
          __int16 v46 = 259;
          mlir::OpState::emitOpError(this, v45, (uint64_t)v47);
          uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
          if (v47[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
          }
          if (v54)
          {
            unint64_t v38 = (void **)__p;
            if (__p)
            {
              unint64_t v39 = v53;
              int64_t v40 = __p;
              if (v53 != __p)
              {
                do
                  unint64_t v39 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v39 - 1);
                while (v39 != v38);
                int64_t v40 = __p;
              }
              uint64_t v53 = v38;
              operator delete(v40);
            }
            uint64_t v15 = v50;
            if (!v50) {
              goto LABEL_92;
            }
            long long v41 = v51;
            uint64_t v17 = v50;
            if (v51 == v50)
            {
LABEL_91:
              uint64_t v51 = v15;
              operator delete(v17);
LABEL_92:
              if (v48 != &v49) {
                free(v48);
              }
              return v11;
            }
            do
            {
              BOOL v43 = (void *)*--v41;
              unint64_t v42 = v43;
              *long long v41 = 0;
              if (v43) {
                operator delete[](v42);
              }
            }
            while (v41 != v15);
LABEL_90:
            uint64_t v17 = v50;
            goto LABEL_91;
          }
        }
        else
        {
          v45[0] = (const void **)"requires attribute 'kernel_sizes'";
          __int16 v46 = 259;
          mlir::OpState::emitOpError(this, v45, (uint64_t)v47);
          uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
          if (v47[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
          }
          if (v54)
          {
            unsigned int v32 = (void **)__p;
            if (__p)
            {
              uint64_t v33 = v53;
              uint64_t v34 = __p;
              if (v53 != __p)
              {
                do
                  uint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
                while (v33 != v32);
                uint64_t v34 = __p;
              }
              uint64_t v53 = v32;
              operator delete(v34);
            }
            uint64_t v15 = v50;
            if (!v50) {
              goto LABEL_92;
            }
            uint64_t v35 = v51;
            uint64_t v17 = v50;
            if (v51 == v50) {
              goto LABEL_91;
            }
            do
            {
              uint64_t v37 = (void *)*--v35;
              uint64_t v36 = v37;
              *uint64_t v35 = 0;
              if (v37) {
                operator delete[](v36);
              }
            }
            while (v35 != v15);
            goto LABEL_90;
          }
        }
      }
      else
      {
        v45[0] = (const void **)"requires attribute 'explicit_padding'";
        __int16 v46 = 259;
        mlir::OpState::emitOpError(this, v45, (uint64_t)v47);
        uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
        if (v47[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
        }
        if (v54)
        {
          uint64_t v26 = (void **)__p;
          if (__p)
          {
            uint64_t v27 = v53;
            unint64_t v28 = __p;
            if (v53 != __p)
            {
              do
                uint64_t v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
              while (v27 != v26);
              unint64_t v28 = __p;
            }
            uint64_t v53 = v26;
            operator delete(v28);
          }
          uint64_t v15 = v50;
          if (!v50) {
            goto LABEL_92;
          }
          uint64_t v29 = v51;
          uint64_t v17 = v50;
          if (v51 == v50) {
            goto LABEL_91;
          }
          do
          {
            unsigned int v31 = (void *)*--v29;
            unsigned int v30 = v31;
            void *v29 = 0;
            if (v31) {
              operator delete[](v30);
            }
          }
          while (v29 != v15);
          goto LABEL_90;
        }
      }
    }
    else
    {
      v45[0] = (const void **)"requires attribute 'dilation_rates'";
      __int16 v46 = 259;
      mlir::OpState::emitOpError(this, v45, (uint64_t)v47);
      uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
      if (v54)
      {
        __int16 v20 = (void **)__p;
        if (__p)
        {
          uint64_t v21 = v53;
          long long v22 = __p;
          if (v53 != __p)
          {
            do
              uint64_t v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
            while (v21 != v20);
            long long v22 = __p;
          }
          uint64_t v53 = v20;
          operator delete(v22);
        }
        uint64_t v15 = v50;
        if (!v50) {
          goto LABEL_92;
        }
        int v23 = v51;
        uint64_t v17 = v50;
        if (v51 == v50) {
          goto LABEL_91;
        }
        do
        {
          char v25 = (void *)*--v23;
          int v24 = v25;
          *int v23 = 0;
          if (v25) {
            operator delete[](v24);
          }
        }
        while (v23 != v15);
        goto LABEL_90;
      }
    }
  }
  else
  {
    v45[0] = (const void **)"requires attribute 'data_layout'";
    __int16 v46 = 259;
    mlir::OpState::emitOpError(this, v45, (uint64_t)v47);
    uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
    if (v47[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
    if (v54)
    {
      uint64_t v12 = (void **)__p;
      if (__p)
      {
        unsigned int v13 = v53;
        unint64_t v14 = __p;
        if (v53 != __p)
        {
          do
            unsigned int v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
          while (v13 != v12);
          unint64_t v14 = __p;
        }
        uint64_t v53 = v12;
        operator delete(v14);
      }
      uint64_t v15 = v50;
      if (!v50) {
        goto LABEL_92;
      }
      uint64_t v16 = v51;
      uint64_t v17 = v50;
      if (v51 == v50) {
        goto LABEL_91;
      }
      do
      {
        unsigned int v19 = (void *)*--v16;
        uint64_t v18 = v19;
        void *v16 = 0;
        if (v19) {
          operator delete[](v18);
        }
      }
      while (v16 != v15);
      goto LABEL_90;
    }
  }
  return v11;
}

uint64_t mlir::mps::ImToColOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.im_to_col", 13, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC9838D8;
  v4[12] = mlir::mps::ImToColOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::ImaginaryPartOpGenericAdaptorBase::ImaginaryPartOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.imaginary_part", 18, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::ImaginaryPartOp::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3)
{
  unint64_t v21[2] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v16, 1);
  __src = v21;
  uint64_t v20 = 0x200000000;
  unint64_t v5 = *a1;
  mlir::ValueRange::ValueRange(v18, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(v17, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::ImaginaryPartOp::inferReturnTypes(v5, v8, v9, v18[0], v18[1], Dictionary, v10, v11, v17[0], v17[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v12 = __src;
  }
  uint64_t v13 = v20;
  uint64_t v14 = *(unsigned int *)(a2 + 72);
  unint64_t v15 = v14 + v20;
  if (v15 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v15, 8);
    LODWORD(v14) = *(_DWORD *)(a2 + 72);
  }
  if (v13)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v14), v12, 8 * v13);
    LODWORD(v14) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v14 + v13;
  if (__src != v21) {
    free(__src);
  }
}

uint64_t mlir::mps::ImaginaryPartOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.imaginary_part", 18, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC980968;
  v4[12] = mlir::mps::ImaginaryPartOp::canonicalize;
  int v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    int v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::InitRandomPhiloxStateOpGenericAdaptorBase::InitRandomPhiloxStateOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.init_random_philox_state", 28, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::InitRandomPhiloxStateOp::build(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v23[1] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a4;
  uint64_t v17 = a3;
  uint64_t v15 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v17, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v16, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v15, 1);
  __src = v22;
  uint64_t v21 = 0x200000000;
  uint64_t v7 = *a1;
  mlir::ValueRange::ValueRange(&v19, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v18, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v23[0] = 7;
  uint64_t v9 = mlir::IntegerType::get(v7, 0x20u, 1u);
  uint64_t v10 = mlir::RankedTensorType::get((uint64_t)v23, 1, v9, 0);
  unsigned int v11 = v21;
  if (v21 >= HIDWORD(v21))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v22, v21 + 1, 8);
    unsigned int v11 = v21;
  }
  *((void *)__src + v11) = v10;
  LODWORD(v21) = v21 + 1;
  unsigned int v12 = v21;
  uint64_t v13 = __src;
  uint64_t v14 = *(unsigned int *)(a2 + 72);
  if (v14 + (unint64_t)v21 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v14 + v21, 8);
    LODWORD(v14) = *(_DWORD *)(a2 + 72);
  }
  if (v12)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v14), v13, 8 * v12);
    LODWORD(v14) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v14 + v12;
  if (__src != v22) {
    free(__src);
  }
}

BOOL mlir::mps::InitRandomPhiloxStateOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps28(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps28(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps28(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 2u))
  {
    return 0;
  }
  uint64_t v2 = *((_DWORD *)*this + 9) ? (uint64_t)(*this - 2) : 0;
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  uint64_t v4 = *this;
  unint64_t v5 = (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
  unint64_t v6 = *v5;
  uint64_t v7 = (void *)*((void *)*v5 + 17);
  if (v7 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v7 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v58[0] = *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8;
    v58[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v6 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v58);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32))
    {
      uint64_t v9 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v5 + 8);
      uint64_t v51 = v5;
      uint64_t v52 = v9;
      ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v51);
      uint64_t v68 = 7;
      if (v11 == 1 && *ArgAttrsAttr == v68) {
        return 1;
      }
    }
  }
  if (*((_UNKNOWN **)*v5 + 17) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    uint64_t v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v5 + 8);
    uint64_t v55 = v5;
    char v56 = (const char *)v12;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v55);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)) {
      return 1;
    }
  }
  __int16 v53 = 261;
  uint64_t v51 = (const void **)"result";
  uint64_t v52 = 6;
  mlir::Operation::emitOpError(v4, &v51, (uint64_t)v58);
  if (v58[0])
  {
    LODWORD(v55) = 3;
    char v56 = " #";
    uint64_t v57 = 2;
    uint64_t v13 = &v55;
    uint64_t v14 = (char *)v59;
    if (v60 >= v61)
    {
      unint64_t v41 = v60 + 1;
      if (v59 <= &v55 && (char *)v59 + 24 * v60 > (char *)&v55)
      {
        int64_t v47 = (char *)&v55 - (unsigned char *)v59;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v41, 24);
        uint64_t v14 = (char *)v59;
        uint64_t v13 = (const void ***)((char *)v59 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v41, 24);
        uint64_t v13 = &v55;
        uint64_t v14 = (char *)v59;
      }
    }
    uint64_t v15 = &v14[24 * v60];
    long long v16 = *(_OWORD *)v13;
    *((void *)v15 + 2) = v13[2];
    *(_OWORD *)uint64_t v15 = v16;
    uint64_t v17 = ++v60;
    if (v58[0])
    {
      LODWORD(v55) = 5;
      char v56 = 0;
      unint64_t v18 = &v55;
      unint64_t v19 = (char *)v59;
      if (v17 >= v61)
      {
        unint64_t v42 = v17 + 1;
        BOOL v43 = (char *)v59 + 24 * v17 > (char *)&v55;
        if (v59 <= &v55 && v43)
        {
          int64_t v48 = (char *)&v55 - (unsigned char *)v59;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v42, 24);
          unint64_t v19 = (char *)v59;
          unint64_t v18 = (const void ***)((char *)v59 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v42, 24);
          unint64_t v18 = &v55;
          unint64_t v19 = (char *)v59;
        }
      }
      uint64_t v20 = &v19[24 * v60];
      long long v21 = *(_OWORD *)v18;
      *((void *)v20 + 2) = v18[2];
      *(_OWORD *)uint64_t v20 = v21;
      uint64_t v22 = ++v60;
      if (v58[0])
      {
        LODWORD(v55) = 3;
        char v56 = " must be static-shape defined tensor with shape equal to [7] or unranked tensor of 32-bit signed integer values, but got ";
        uint64_t v57 = 121;
        int v23 = &v55;
        int v24 = (char *)v59;
        if (v22 >= v61)
        {
          unint64_t v44 = v22 + 1;
          BOOL v45 = (char *)v59 + 24 * v22 > (char *)&v55;
          if (v59 <= &v55 && v45)
          {
            int64_t v49 = (char *)&v55 - (unsigned char *)v59;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v44, 24);
            int v24 = (char *)v59;
            int v23 = (const void ***)((char *)v59 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v44, 24);
            int v23 = &v55;
            int v24 = (char *)v59;
          }
        }
        char v25 = &v24[24 * v60];
        long long v26 = *(_OWORD *)v23;
        *((void *)v25 + 2) = v23[2];
        *(_OWORD *)char v25 = v26;
        ++v60;
        if (v58[0])
        {
          uint64_t v27 = &v55;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v55, (uint64_t)v5);
          unint64_t v28 = (char *)v59;
          if (v60 >= v61)
          {
            unint64_t v46 = v60 + 1;
            if (v59 <= &v55 && (char *)v59 + 24 * v60 > (char *)&v55)
            {
              int64_t v50 = (char *)&v55 - (unsigned char *)v59;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v46, 24);
              unint64_t v28 = (char *)v59;
              uint64_t v27 = (const void ***)((char *)v59 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v46, 24);
              uint64_t v27 = &v55;
              unint64_t v28 = (char *)v59;
            }
          }
          uint64_t v29 = &v28[24 * v60];
          long long v30 = *(_OWORD *)v27;
          *((void *)v29 + 2) = v27[2];
          *(_OWORD *)uint64_t v29 = v30;
          ++v60;
        }
      }
    }
  }
  char v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v58);
  if (v58[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v58);
  }
  if (v67)
  {
    unsigned int v32 = (void **)__p;
    if (__p)
    {
      uint64_t v33 = v66;
      uint64_t v34 = __p;
      if (v66 != __p)
      {
        do
          uint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        uint64_t v34 = __p;
      }
      uint64_t v66 = v32;
      operator delete(v34);
    }
    uint64_t v35 = v63;
    if (v63)
    {
      uint64_t v36 = v64;
      uint64_t v37 = v63;
      if (v64 != v63)
      {
        do
        {
          unint64_t v39 = (void *)*--v36;
          unint64_t v38 = v39;
          *uint64_t v36 = 0;
          if (v39) {
            operator delete[](v38);
          }
        }
        while (v36 != v35);
        uint64_t v37 = v63;
      }
      unint64_t v64 = v35;
      operator delete(v37);
    }
    if (v59 != v62) {
      free(v59);
    }
  }
  return v31 != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps28(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v82 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *a2;
  if (*((_UNKNOWN **)*a2 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    goto LABEL_4;
  }
  v71[0] = a2;
  v71[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  int ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v71);
  uint64_t v10 = *a2;
  if (!ArgOperands
    || (unsigned int v61 = a2,
        uint64_t v62 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1)),
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v61),
        uint64_t v10 = *a2,
        v12))
  {
LABEL_4:
    uint64_t v13 = (void *)v10[17];
    if (v13 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v13 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_12;
    }
    goto LABEL_9;
  }
  uint64_t v48 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  uint64_t v68 = a2;
  uint64_t v69 = v48;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v68);
  if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)) {
    return 1;
  }
  uint64_t v10 = *a2;
  int64_t v49 = (void *)*((void *)*a2 + 17);
  if (v49 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v49 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
LABEL_9:
    uint64_t v15 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
    v66[0] = a2;
    v66[1] = v15;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v66);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
    {
      uint64_t v16 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v65[0] = a2;
      v65[1] = v16;
      ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v65);
      uint64_t v81 = 1;
      if (v18 == 1 && *ArgAttrsAttr == v81) {
        return 1;
      }
    }
  }
LABEL_12:
  if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    uint64_t v19 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
    v64[0] = a2;
    v64[1] = v19;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v64);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
  }
  __int16 v63 = 261;
  unsigned int v61 = a3;
  uint64_t v62 = a4;
  mlir::Operation::emitOpError(a1, &v61, (uint64_t)v71);
  if (v71[0])
  {
    LODWORD(v68) = 3;
    uint64_t v69 = (uint64_t)" #";
    uint64_t v70 = 2;
    long long v21 = &v68;
    uint64_t v22 = (char *)v72;
    if (v73 >= v74)
    {
      unint64_t v51 = v73 + 1;
      if (v72 <= &v68 && (char *)v72 + 24 * v73 > (char *)&v68)
      {
        int64_t v57 = (char *)&v68 - (unsigned char *)v72;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v51, 24);
        uint64_t v22 = (char *)v72;
        long long v21 = (const void ***)((char *)v72 + v57);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v51, 24);
        long long v21 = &v68;
        uint64_t v22 = (char *)v72;
      }
    }
    int v23 = &v22[24 * v73];
    long long v24 = *(_OWORD *)v21;
    *((void *)v23 + 2) = v21[2];
    *(_OWORD *)int v23 = v24;
    uint64_t v25 = ++v73;
    if (v71[0])
    {
      LODWORD(v68) = 5;
      uint64_t v69 = a5;
      long long v26 = &v68;
      uint64_t v27 = (char *)v72;
      if (v25 >= v74)
      {
        unint64_t v52 = v25 + 1;
        BOOL v53 = (char *)v72 + 24 * v25 > (char *)&v68;
        if (v72 <= &v68 && v53)
        {
          int64_t v58 = (char *)&v68 - (unsigned char *)v72;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v52, 24);
          uint64_t v27 = (char *)v72;
          long long v26 = (const void ***)((char *)v72 + v58);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v52, 24);
          long long v26 = &v68;
          uint64_t v27 = (char *)v72;
        }
      }
      unint64_t v28 = &v27[24 * v73];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)unint64_t v28 = v29;
      uint64_t v30 = ++v73;
      if (v71[0])
      {
        LODWORD(v68) = 3;
        uint64_t v69 = (uint64_t)" must be 0D tensor of 64-bit signed integer values or static-shape defined tensor with shape equa"
                       "l to [1] or unranked tensor of 64-bit signed integer values, but got ";
        uint64_t v70 = 166;
        char v31 = &v68;
        unsigned int v32 = (char *)v72;
        if (v30 >= v74)
        {
          unint64_t v54 = v30 + 1;
          BOOL v55 = (char *)v72 + 24 * v30 > (char *)&v68;
          if (v72 <= &v68 && v55)
          {
            int64_t v59 = (char *)&v68 - (unsigned char *)v72;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v54, 24);
            unsigned int v32 = (char *)v72;
            char v31 = (const void ***)((char *)v72 + v59);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v54, 24);
            char v31 = &v68;
            unsigned int v32 = (char *)v72;
          }
        }
        uint64_t v33 = &v32[24 * v73];
        long long v34 = *(_OWORD *)v31;
        *((void *)v33 + 2) = v31[2];
        *(_OWORD *)uint64_t v33 = v34;
        ++v73;
        if (v71[0])
        {
          uint64_t v35 = &v68;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v68, (uint64_t)a2);
          uint64_t v36 = (char *)v72;
          if (v73 >= v74)
          {
            unint64_t v56 = v73 + 1;
            if (v72 <= &v68 && (char *)v72 + 24 * v73 > (char *)&v68)
            {
              int64_t v60 = (char *)&v68 - (unsigned char *)v72;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v56, 24);
              uint64_t v36 = (char *)v72;
              uint64_t v35 = (const void ***)((char *)v72 + v60);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v56, 24);
              uint64_t v35 = &v68;
              uint64_t v36 = (char *)v72;
            }
          }
          uint64_t v37 = &v36[24 * v73];
          long long v38 = *(_OWORD *)v35;
          *((void *)v37 + 2) = v35[2];
          *(_OWORD *)uint64_t v37 = v38;
          ++v73;
        }
      }
    }
  }
  uint64_t v20 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v71);
  if (v71[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v71);
  }
  if (v80)
  {
    unint64_t v39 = (void **)__p;
    if (__p)
    {
      int64_t v40 = v79;
      unint64_t v41 = __p;
      if (v79 != __p)
      {
        do
          int64_t v40 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v40 - 1);
        while (v40 != v39);
        unint64_t v41 = __p;
      }
      unint64_t v79 = v39;
      operator delete(v41);
    }
    unint64_t v42 = v76;
    if (v76)
    {
      BOOL v43 = v77;
      unint64_t v44 = v76;
      if (v77 != v76)
      {
        do
        {
          unint64_t v46 = (void *)*--v43;
          BOOL v45 = v46;
          void *v43 = 0;
          if (v46) {
            operator delete[](v45);
          }
        }
        while (v43 != v42);
        unint64_t v44 = v76;
      }
      uint64_t v77 = v42;
      operator delete(v44);
    }
    if (v72 != v75) {
      free(v72);
    }
  }
  return v20;
}

uint64_t mlir::mps::InitRandomPhiloxStateOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.init_random_philox_state", 28, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC981D58;
  v4[12] = mlir::mps::InitRandomPhiloxStateOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::InstanceNormOpGenericAdaptorBase::InstanceNormOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  unint64_t v5 = (void *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.instance_norm", 17, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

llvm::detail::DoubleAPFloat *mlir::mps::detail::InstanceNormOpGenericAdaptorBase::getEpsilon@<X0>(mlir::mps::detail::InstanceNormOpGenericAdaptorBase *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *((void *)this + 3);
  return mlir::FloatAttr::getValue((mlir::FloatAttr *)&v3, a2);
}

uint64_t mlir::mps::InstanceNormOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      int v44 = 3;
      BOOL v45 = "expected DictionaryAttr to set properties";
      uint64_t v46 = 41;
      long long v26 = &v44;
      uint64_t v27 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v40 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          uint64_t v27 = (char *)v48;
          long long v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          long long v26 = &v44;
          uint64_t v27 = (char *)v48;
        }
      }
      unint64_t v28 = &v27[24 * v49];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)unint64_t v28 = v29;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
    if (!v56) {
      return 0;
    }
    uint64_t v30 = (void **)__p;
    if (__p)
    {
      char v31 = v55;
      unsigned int v32 = __p;
      if (v55 != __p)
      {
        do
          char v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unsigned int v32 = __p;
      }
      BOOL v55 = v30;
      operator delete(v32);
    }
    long long v21 = v52;
    if (!v52) {
      goto LABEL_43;
    }
    uint64_t v33 = v53;
    int v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v35 = (void *)*--v33;
      long long v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "epsilon", 7uLL);
  if (!v8) {
    return 1;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    int v44 = 3;
    uint64_t v46 = 52;
    uint64_t v10 = &v44;
    uint64_t v11 = (char *)v48;
    if (v49 >= v50)
    {
      unint64_t v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        int64_t v41 = (char *)&v44 - (unsigned char *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v11 = (char *)v48;
        uint64_t v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v10 = &v44;
        uint64_t v11 = (char *)v48;
      }
    }
    uint64_t v12 = &v11[24 * v49];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = *((void *)v10 + 2);
    *(_OWORD *)uint64_t v12 = v13;
    ++v49;
    if (v47[0])
    {
      uint64_t v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      uint64_t v15 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v42 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v15 = (char *)v48;
          uint64_t v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v14 = &v44;
          uint64_t v15 = (char *)v48;
        }
      }
      uint64_t v16 = &v15[24 * v49];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = *((void *)v14 + 2);
      *(_OWORD *)uint64_t v16 = v17;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
  }
  if (!v56) {
    return 0;
  }
  uint64_t v18 = (void **)__p;
  if (__p)
  {
    uint64_t v19 = v55;
    uint64_t v20 = __p;
    if (v55 != __p)
    {
      do
        uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      uint64_t v20 = __p;
    }
    BOOL v55 = v18;
    operator delete(v20);
  }
  long long v21 = v52;
  if (v52)
  {
    uint64_t v22 = v53;
    int v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v25 = (void *)*--v22;
      long long v24 = v25;
      *uint64_t v22 = 0;
      if (v25) {
        operator delete[](v24);
      }
    }
    while (v22 != v21);
LABEL_41:
    int v23 = v52;
LABEL_42:
    BOOL v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51) {
    free(v48);
  }
  return 0;
}

uint64_t mlir::mps::InstanceNormOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v15[6] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a1;
  long long v13 = v15;
  uint64_t v14 = 0x300000000;
  if (!*a2) {
    return 0;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"epsilon", 7, *a2);
  uint64_t v4 = v3;
  unsigned int v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    unsigned int v5 = v14;
  }
  uint64_t v6 = (uint64_t *)((char *)v13 + 16 * v5);
  uint64_t *v6 = NamedAttr;
  v6[1] = v4;
  uint64_t v7 = v13;
  BOOL v8 = __CFADD__(v14, 1);
  uint64_t v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v13 == v15) {
      return DictionaryAttr;
    }
    goto LABEL_10;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (uint64_t *)v13, v9);
  uint64_t v7 = v13;
  if (v13 != v15) {
LABEL_10:
  }
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::InstanceNormOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    *uint64_t v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::InstanceNormOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::InstanceNormOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::InstanceNormOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::InstanceNormOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    {
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::InstanceNormOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 113;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        BOOL v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::mps::detail::InstanceNormOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      }
    }
    a1[33] = v4[83];
    return a1[32];
  }
  return result;
}

llvm::detail::DoubleAPFloat *mlir::mps::InstanceNormOp::getEpsilon@<X0>(mlir::mps::InstanceNormOp *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(*(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64);
  return mlir::FloatAttr::getValue((mlir::FloatAttr *)&v3, a2);
}

void mlir::mps::InstanceNormOp::build(mlir::Float32Type **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v27[2] = *MEMORY[0x1E4F143B8];
  uint64_t v19 = a4;
  uint64_t v20 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v20, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v19, 1);
  uint64_t F32Type = mlir::Builder::getF32Type(a1, v8);
  uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)a1, F32Type, a5);
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::InstanceNormOpGenericAdaptorBase::Properties>((void *)a2) = FloatAttr;
  __src = v26;
  uint64_t v25 = 0x200000000;
  uint64_t v11 = *(void *)a2;
  mlir::ValueRange::ValueRange(&v22, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v21, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v27[0] = v22;
  v27[1] = v23;
  if (v23)
  {
    unint64_t v13 = *(void *)(mlir::ValueRange::dereference_iterator(v27, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    unsigned int v14 = v25;
    if (v25 >= HIDWORD(v25))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v26, v25 + 1, 8);
      unsigned int v14 = v25;
    }
    *((void *)__src + v14) = v13;
    unsigned int v15 = v25 + 1;
    LODWORD(v25) = v15;
    uint64_t v16 = __src;
    uint64_t v17 = *(unsigned int *)(a2 + 72);
    unint64_t v18 = v17 + v15;
    if (v18 > *(unsigned int *)(a2 + 76))
    {
LABEL_5:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v18, 8);
      LODWORD(v17) = *(_DWORD *)(a2 + 72);
    }
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(v11, 1, "invalid number of operands")) {
      llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
    }
    unsigned int v15 = v25;
    uint64_t v16 = __src;
    uint64_t v17 = *(unsigned int *)(a2 + 72);
    unint64_t v18 = v17 + v25;
    if (v18 > *(unsigned int *)(a2 + 76)) {
      goto LABEL_5;
    }
  }
  if (v15)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v17), v16, 8 * v15);
    LODWORD(v17) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v17 + v15;
  if (__src != v26) {
    free(__src);
  }
}

BOOL mlir::mps::InstanceNormOp::verifyInvariantsImpl(uint64_t **this)
{
  __int16 v2 = *this;
  uint64_t v3 = (const void **)(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  unint64_t v7 = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(v3, (const void **)"epsilon", (const char *)7, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v7)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v4 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::InstanceNormOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.instance_norm", 17, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC9803E8;
  v4[12] = mlir::mps::InstanceNormOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::IsFiniteOpGenericAdaptorBase::IsFiniteOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.is_finite", 13, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::IsFiniteOp::build(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  void v16[2] = *MEMORY[0x1E4F143B8];
  uint64_t v11 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v11, 1);
  __src = v16;
  uint64_t v15 = 0x200000000;
  uint64_t v5 = *a1;
  mlir::ValueRange::ValueRange(v13, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v12, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  uint64_t v7 = __src;
  uint64_t v8 = v15;
  uint64_t v9 = *(unsigned int *)(a2 + 72);
  unint64_t v10 = v9 + v15;
  if (v10 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v10, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
  }
  if (v8)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v9), v7, 8 * v8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v9 + v8;
  if (__src != v16) {
    free(__src);
  }
}

uint64_t mlir::mps::IsFiniteOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.is_finite", 13, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC97F730;
  v4[12] = mlir::mps::IsFiniteOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::IsInfiniteOpGenericAdaptorBase::IsInfiniteOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.is_infinite", 15, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::IsInfiniteOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.is_infinite", 15, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC97FE68;
  v4[12] = mlir::mps::IsInfiniteOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::IsNaNOpGenericAdaptorBase::IsNaNOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.is_nan", 10, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::IsNaNOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.is_nan", 10, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC983040;
  v4[12] = mlir::mps::IsNaNOp::canonicalize;
  uint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::detail::LPNormOpGenericAdaptorBase::LPNormOpGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  unint64_t v5 = a2[11];
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.lp_norm", 11, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::LPNormOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v25[2] = *MEMORY[0x1E4F143B8];
  uint64_t v17 = a4;
  uint64_t v18 = a3;
  uint64_t v15 = a6;
  uint64_t v16 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v18, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v17, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v16, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v15, 1);
  __src = v24;
  uint64_t v23 = 0x200000000;
  uint64_t v7 = *(void *)a2;
  mlir::ValueRange::ValueRange(&v20, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v19, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v25[0] = v20;
  v25[1] = v21;
  if (v21)
  {
    unint64_t v9 = *(void *)(mlir::ValueRange::dereference_iterator(v25, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    unsigned int v10 = v23;
    if (v23 >= HIDWORD(v23))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v24, v23 + 1, 8);
      unsigned int v10 = v23;
    }
    *((void *)__src + v10) = v9;
    unsigned int v11 = v23 + 1;
    LODWORD(v23) = v11;
    unint64_t v12 = __src;
    uint64_t v13 = *(unsigned int *)(a2 + 72);
    unint64_t v14 = v13 + v11;
    if (v14 > *(unsigned int *)(a2 + 76))
    {
LABEL_5:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v14, 8);
      LODWORD(v13) = *(_DWORD *)(a2 + 72);
    }
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(v7, 1, "invalid number of operands")) {
      llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
    }
    unsigned int v11 = v23;
    unint64_t v12 = __src;
    uint64_t v13 = *(unsigned int *)(a2 + 72);
    unint64_t v14 = v13 + v23;
    if (v14 > *(unsigned int *)(a2 + 76)) {
      goto LABEL_5;
    }
  }
  if (v11)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v13), v12, 8 * v11);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v13 + v11;
  if (__src != v24) {
    free(__src);
  }
}

BOOL mlir::mps::LPNormOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0))return 0; {
  __int16 v2 = *this;
  }
  uint64_t v3 = (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v4 = *v3;
  if (*((_UNKNOWN **)*v3 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v67[0] = *(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8;
    v67[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v4 + 1));
    int ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v67);
    uint64_t v4 = *v3;
    if (ArgOperands)
    {
      uint64_t v57 = v3;
      uint64_t v58 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v4 + 1));
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v57);
      uint64_t v4 = *v3;
      if (!v6)
      {
        uint64_t v44 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v4 + 1));
        unint64_t v64 = v3;
        uint64_t v65 = v44;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v64);
        if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isF16((mlir::Type *)&OperandRange)
          || mlir::Type::isF32((mlir::Type *)&OperandRange)
          || mlir::Type::isBF16((mlir::Type *)&OperandRange)
          || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
        {
          goto LABEL_68;
        }
        uint64_t v4 = *v3;
        BOOL v45 = (void *)*((void *)*v3 + 17);
        if (v45 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
          && v45 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
        {
          goto LABEL_25;
        }
LABEL_10:
        uint64_t v9 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v4 + 1));
        v62[0] = v3;
        v62[1] = v9;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v62);
        if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isF16((mlir::Type *)&OperandRange)
          || mlir::Type::isF32((mlir::Type *)&OperandRange)
          || mlir::Type::isBF16((mlir::Type *)&OperandRange)
          || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
        {
          uint64_t v10 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v3 + 8);
          v61[0] = v3;
          v61[1] = v10;
          ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v61);
          uint64_t v77 = 1;
          if (v12 == 1 && *ArgAttrsAttr == v77) {
            goto LABEL_68;
          }
        }
        goto LABEL_25;
      }
    }
  }
  uint64_t v7 = (void *)v4[17];
  if (v7 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v7 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    goto LABEL_10;
  }
LABEL_25:
  if (*((_UNKNOWN **)*v3 + 17) != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id
    || (uint64_t v40 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v3 + 8),
        v60[0] = v3,
        v60[1] = v40,
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v60),
        !mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1))
    && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
    && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
    && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
    && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
    && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
    && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
    && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
    && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
    && !mlir::Type::isF16((mlir::Type *)&OperandRange)
    && !mlir::Type::isF32((mlir::Type *)&OperandRange)
    && !mlir::Type::isBF16((mlir::Type *)&OperandRange)
    && *(_UNKNOWN **)(*(void *)OperandRange + 136) != &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
  {
    __int16 v59 = 261;
    uint64_t v57 = (const void **)"operand";
    uint64_t v58 = 7;
    mlir::Operation::emitOpError(v2, &v57, (uint64_t)v67);
    if (v67[0])
    {
      LODWORD(v64) = 3;
      uint64_t v65 = (uint64_t)" #";
      uint64_t v66 = 2;
      uint64_t v13 = &v64;
      unint64_t v14 = (char *)v68;
      if (v69 >= v70)
      {
        unint64_t v47 = v69 + 1;
        if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
        {
          int64_t v53 = (char *)&v64 - (unsigned char *)v68;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v47, 24);
          unint64_t v14 = (char *)v68;
          uint64_t v13 = (const void ***)((char *)v68 + v53);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v47, 24);
          uint64_t v13 = &v64;
          unint64_t v14 = (char *)v68;
        }
      }
      uint64_t v15 = &v14[24 * v69];
      long long v16 = *(_OWORD *)v13;
      *((void *)v15 + 2) = v13[2];
      *(_OWORD *)uint64_t v15 = v16;
      uint64_t v17 = ++v69;
      if (v67[0])
      {
        LODWORD(v64) = 5;
        uint64_t v65 = 1;
        uint64_t v18 = &v64;
        unint64_t v19 = (char *)v68;
        if (v17 >= v70)
        {
          unint64_t v48 = v17 + 1;
          BOOL v49 = (char *)v68 + 24 * v17 > (char *)&v64;
          if (v68 <= &v64 && v49)
          {
            int64_t v54 = (char *)&v64 - (unsigned char *)v68;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v48, 24);
            unint64_t v19 = (char *)v68;
            uint64_t v18 = (const void ***)((char *)v68 + v54);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v48, 24);
            uint64_t v18 = &v64;
            unint64_t v19 = (char *)v68;
          }
        }
        unint64_t v20 = &v19[24 * v69];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)unint64_t v20 = v21;
        uint64_t v22 = ++v69;
        if (v67[0])
        {
          LODWORD(v64) = 3;
          uint64_t v65 = (uint64_t)" must be 0D tensor of mps native type values or static-shape defined tensor with shape equal to"
                         " [1] or unranked tensor of mps native type values, but got ";
          uint64_t v66 = 154;
          uint64_t v23 = &v64;
          long long v24 = (char *)v68;
          if (v22 >= v70)
          {
            unint64_t v50 = v22 + 1;
            BOOL v51 = (char *)v68 + 24 * v22 > (char *)&v64;
            if (v68 <= &v64 && v51)
            {
              int64_t v55 = (char *)&v64 - (unsigned char *)v68;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v50, 24);
              long long v24 = (char *)v68;
              uint64_t v23 = (const void ***)((char *)v68 + v55);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v50, 24);
              uint64_t v23 = &v64;
              long long v24 = (char *)v68;
            }
          }
          uint64_t v25 = &v24[24 * v69];
          long long v26 = *(_OWORD *)v23;
          *((void *)v25 + 2) = v23[2];
          *(_OWORD *)uint64_t v25 = v26;
          ++v69;
          if (v67[0])
          {
            uint64_t v27 = &v64;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v64, (uint64_t)v3);
            unint64_t v28 = (char *)v68;
            if (v69 >= v70)
            {
              unint64_t v52 = v69 + 1;
              if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
              {
                int64_t v56 = (char *)&v64 - (unsigned char *)v68;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v52, 24);
                unint64_t v28 = (char *)v68;
                uint64_t v27 = (const void ***)((char *)v68 + v56);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v52, 24);
                uint64_t v27 = &v64;
                unint64_t v28 = (char *)v68;
              }
            }
            long long v29 = &v28[24 * v69];
            long long v30 = *(_OWORD *)v27;
            *((void *)v29 + 2) = v27[2];
            *(_OWORD *)long long v29 = v30;
            ++v69;
          }
        }
      }
    }
    char v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v67);
    if (v67[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v67);
    }
    if (v76)
    {
      unsigned int v32 = (void **)__p;
      if (__p)
      {
        uint64_t v33 = v75;
        long long v34 = __p;
        if (v75 != __p)
        {
          do
            uint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
          while (v33 != v32);
          long long v34 = __p;
        }
        uint64_t v75 = v32;
        operator delete(v34);
      }
      uint64_t v35 = v72;
      if (v72)
      {
        uint64_t v36 = v73;
        unint64_t v37 = v72;
        if (v73 != v72)
        {
          do
          {
            unint64_t v39 = (void *)*--v36;
            unint64_t v38 = v39;
            *uint64_t v36 = 0;
            if (v39) {
              operator delete[](v38);
            }
          }
          while (v36 != v35);
          unint64_t v37 = v72;
        }
        unsigned int v73 = v35;
        operator delete(v37);
      }
      if (v68 != v71) {
        free(v68);
      }
    }
    if (!v31) {
      return 0;
    }
  }
LABEL_68:
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 2u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(void *)(*(void *)((*this)[9] + 120) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 3u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v41 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v41 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v41, 0);
  return mlir::tensor::__mlir_ods_local_type_constraint_TensorOps0(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::LPNormOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.lp_norm", 11, v2, v3, 0, 0);
  *uint64_t v4 = &unk_1EC983510;
  v4[12] = mlir::mps::LPNormOp::canonicalize;
  uint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::mps::LSTMGradientOp::getAsmResultNames(uint64_t *a1, void (*a2)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a3)
{
  if (*(_DWORD *)(*a1 + 36)) {
    uint64_t v5 = *a1 - 16;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0);
  a2(a3, NextResultAtOffset, "gradient_output_sequence", 24);
  if (*(_DWORD *)(*a1 + 36)) {
    uint64_t v7 = *a1 - 16;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 1);
  uint64_t v9 = mlir::detail::OpResultImpl::getNextResultAtOffset(v8, 0);
  a2(a3, v9, "gradient_recurrent_weight", 25);
  if (*(_DWORD *)(*a1 + 36)) {
    uint64_t v10 = *a1 - 16;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 2);
  uint64_t v12 = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
  a2(a3, v12, "gradient_input_state", 20);
  if (*(_DWORD *)(*a1 + 36)) {
    uint64_t v13 = *a1 - 16;
  }
  else {
    uint64_t v13 = 0;
  }
  uint64_t v14 = mlir::detail::OpResultImpl::getNextResultAtOffset(v13, 3);
  uint64_t v15 = mlir::detail::OpResultImpl::getNextResultAtOffset(v14, 0);
  a2(a3, v15, "gradient_input_cell", 19);
  uint64_t v16 = *a1;
  int v17 = *(_DWORD *)(*a1 + 36);
  uint64_t v18 = v16 - 16;
  if (v17) {
    uint64_t v19 = v18;
  }
  else {
    uint64_t v19 = 0;
  }
  uint64_t result = mlir::detail::OpResultImpl::getNextResultAtOffset(v19, 4);
  if (v17 != 4)
  {
    uint64_t v21 = mlir::detail::OpResultImpl::getNextResultAtOffset(result, 0);
    return ((uint64_t (*)(uint64_t, uint64_t, const char *, uint64_t))a2)(a3, v21, "gradient_peephole", 17);
  }
  return result;
}

uint64_t mlir::mps::LSTMGradientOp::getODSResults(mlir::mps::LSTMGradientOp *this, unsigned int a2)
{
  if (a2)
  {
    if (a2 >= 8)
    {
      int32x4_t v4 = (int32x4_t)xmmword_1810FFF10;
      unsigned int v3 = a2 & 0xFFFFFFF8;
      int32x4_t v5 = 0uLL;
      v6.i64[0] = 0x400000004;
      v6.i64[1] = 0x400000004;
      v7.i64[0] = 0x800000008;
      v7.i64[1] = 0x800000008;
      unsigned int v8 = a2 & 0xFFFFFFF8;
      int32x4_t v9 = 0uLL;
      do
      {
        int32x4_t v5 = vsubq_s32(v5, vceqq_s32(v4, v6));
        int32x4_t v9 = vsubq_s32(v9, vceqzq_s32(v4));
        int32x4_t v4 = vaddq_s32(v4, v7);
        v8 -= 8;
      }
      while (v8);
      int v2 = vaddvq_s32(vaddq_s32(v9, v5));
      if (v3 == a2) {
        goto LABEL_11;
      }
    }
    else
    {
      int v2 = 0;
      unsigned int v3 = 0;
    }
    do
    {
      if (v3 == 4) {
        ++v2;
      }
      ++v3;
    }
    while (a2 != v3);
  }
  else
  {
    int v2 = 0;
  }
LABEL_11:
  int v10 = *(_DWORD *)(*(void *)this + 36);
  if (v10) {
    uint64_t result = *(void *)this - 16;
  }
  else {
    uint64_t result = 0;
  }
  if (a2 + (v10 - 5) * v2) {
    return mlir::detail::OpResultImpl::getNextResultAtOffset(result, a2 + (v10 - 5) * v2);
  }
  return result;
}

uint64_t mlir::mps::LSTMGradientOp::getCellClip(mlir::mps::LSTMGradientOp *this)
{
  unint64_t v1 = *(unsigned int *)(*(void *)this + 44);
  int v2 = (_DWORD *)(*(void *)this + 16 * ((v1 >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    int v2 = 0;
  }
  int v3 = v2[20];
  if ((v1 & 0x800000) != 0)
  {
    uint64_t v4 = *(void *)(*(void *)this + 72);
    if (v3) {
      return *(void *)(v4
    }
                       + 32 * (v2[19] + v2[18] + v2[17] + v2[16] + v2[15] + v2[14] + v2[13] + v2[12])
                       + 24);
  }
  else
  {
    uint64_t v4 = 0;
    if (v3) {
      return *(void *)(v4
    }
                       + 32 * (v2[19] + v2[18] + v2[17] + v2[16] + v2[15] + v2[14] + v2[13] + v2[12])
                       + 24);
  }
  return 0;
}

uint64_t mlir::mps::LSTMGradientOp::getGradientInputCell(mlir::mps::LSTMGradientOp *this)
{
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v1 = *(void *)this - 16;
  }
  else {
    uint64_t v1 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v1, 3);

  return mlir::detail::OpResultImpl::getNextResultAtOffset(NextResultAtOffset, 0);
}

uint64_t mlir::mps::LSTMGradientOp::getGradientPeephole(mlir::mps::LSTMGradientOp *this)
{
  int v1 = *(_DWORD *)(*(void *)this + 36);
  if (v1) {
    uint64_t v2 = *(void *)this - 16;
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 4);
  uint64_t v4 = 0;
  if (v1 != 4) {
    return mlir::detail::OpResultImpl::getNextResultAtOffset(NextResultAtOffset, 0);
  }
  return v4;
}

BOOL mlir::mps::LSTMGradientOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v70 = v6;
  if (!v6)
  {
    a3(v74, a4);
    if (v74[0])
    {
      LODWORD(v71) = 3;
      int64_t v72 = "expected DictionaryAttr to set properties";
      uint64_t v73 = 41;
      long long v26 = &v71;
      uint64_t v27 = (char *)v75;
      if (v76 >= v77)
      {
        unint64_t v60 = v76 + 1;
        if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
        {
          int64_t v65 = (char *)&v71 - (unsigned char *)v75;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v60, 24);
          uint64_t v27 = (char *)v75;
          long long v26 = (uint64_t *)((char *)v75 + v65);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v60, 24);
          long long v26 = &v71;
          uint64_t v27 = (char *)v75;
        }
      }
      unint64_t v28 = &v27[24 * v76];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)unint64_t v28 = v29;
      ++v76;
      if (v74[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
      }
    }
    if (!v83) {
      return 0;
    }
    long long v30 = (void **)__p;
    if (__p)
    {
      char v31 = v82;
      unsigned int v32 = __p;
      if (v82 != __p)
      {
        do
          char v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unsigned int v32 = __p;
      }
      uint64_t v82 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v79;
    if (!v79) {
      goto LABEL_64;
    }
    uint64_t v33 = v80;
    uint64_t v23 = v79;
    if (v80 == v79)
    {
LABEL_63:
      char v80 = v21;
      operator delete(v23);
LABEL_64:
      if (v75 != v78) {
        free(v75);
      }
      return 0;
    }
    do
    {
      uint64_t v35 = (void *)*--v33;
      long long v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
LABEL_62:
    uint64_t v23 = v79;
    goto LABEL_63;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v70, "cell_activation", 0xFuLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v74, a4);
      if (v74[0])
      {
        LODWORD(v71) = 3;
        uint64_t v73 = 60;
        int v10 = &v71;
        uint64_t v11 = (char *)v75;
        if (v76 >= v77)
        {
          unint64_t v61 = v76 + 1;
          if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
          {
            int64_t v66 = (char *)&v71 - (unsigned char *)v75;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v61, 24);
            uint64_t v11 = (char *)v75;
            int v10 = (uint64_t *)((char *)v75 + v66);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v61, 24);
            int v10 = &v71;
            uint64_t v11 = (char *)v75;
          }
        }
        uint64_t v12 = &v11[24 * v76];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = v10[2];
        *(_OWORD *)uint64_t v12 = v13;
        ++v76;
        if (v74[0])
        {
          uint64_t v14 = &v71;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v71, v9);
          uint64_t v15 = (char *)v75;
          if (v76 >= v77)
          {
            unint64_t v62 = v76 + 1;
            if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
            {
              int64_t v67 = (char *)&v71 - (unsigned char *)v75;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v62, 24);
              uint64_t v15 = (char *)v75;
              uint64_t v14 = (uint64_t *)((char *)v75 + v67);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v62, 24);
              uint64_t v14 = &v71;
              uint64_t v15 = (char *)v75;
            }
          }
          uint64_t v16 = &v15[24 * v76];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = v14[2];
          *(_OWORD *)uint64_t v16 = v17;
          ++v76;
          if (v74[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
          }
        }
      }
      if (!v83) {
        return 0;
      }
      uint64_t v18 = (void **)__p;
      if (__p)
      {
        uint64_t v19 = v82;
        unint64_t v20 = __p;
        if (v82 != __p)
        {
          do
            uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          unint64_t v20 = __p;
        }
        uint64_t v82 = v18;
        operator delete(v20);
      }
      uint64_t v21 = v79;
      if (!v79) {
        goto LABEL_64;
      }
      uint64_t v22 = v80;
      uint64_t v23 = v79;
      if (v80 == v79) {
        goto LABEL_63;
      }
      do
      {
        uint64_t v25 = (void *)*--v22;
        long long v24 = v25;
        *uint64_t v22 = 0;
        if (v25) {
          operator delete[](v24);
        }
      }
      while (v22 != v21);
      goto LABEL_62;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v70, "fgate_activation", 0x10uLL);
  if (v36)
  {
    uint64_t v37 = v36;
    if (*(_UNKNOWN **)(*(void *)v36 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v74, a4);
      if (v74[0])
      {
        LODWORD(v71) = 3;
        uint64_t v73 = 61;
        unint64_t v38 = &v71;
        unint64_t v39 = (char *)v75;
        if (v76 >= v77)
        {
          unint64_t v63 = v76 + 1;
          if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
          {
            int64_t v68 = (char *)&v71 - (unsigned char *)v75;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v63, 24);
            unint64_t v39 = (char *)v75;
            unint64_t v38 = (uint64_t *)((char *)v75 + v68);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v63, 24);
            unint64_t v38 = &v71;
            unint64_t v39 = (char *)v75;
          }
        }
        uint64_t v40 = &v39[24 * v76];
        long long v41 = *(_OWORD *)v38;
        *((void *)v40 + 2) = v38[2];
        *(_OWORD *)uint64_t v40 = v41;
        ++v76;
        if (v74[0])
        {
          int64_t v42 = &v71;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v71, v37);
          uint64_t v43 = (char *)v75;
          if (v76 >= v77)
          {
            unint64_t v64 = v76 + 1;
            if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
            {
              int64_t v69 = (char *)&v71 - (unsigned char *)v75;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v64, 24);
              uint64_t v43 = (char *)v75;
              int64_t v42 = (uint64_t *)((char *)v75 + v69);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v64, 24);
              int64_t v42 = &v71;
              uint64_t v43 = (char *)v75;
            }
          }
          uint64_t v44 = &v43[24 * v76];
          long long v45 = *(_OWORD *)v42;
          *((void *)v44 + 2) = v42[2];
          *(_OWORD *)uint64_t v44 = v45;
          ++v76;
          if (v74[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
          }
        }
      }
      if (!v83) {
        return 0;
      }
      uint64_t v46 = (void **)__p;
      if (__p)
      {
        unint64_t v47 = v82;
        unint64_t v48 = __p;
        if (v82 != __p)
        {
          do
            unint64_t v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
          while (v47 != v46);
          unint64_t v48 = __p;
        }
        uint64_t v82 = v46;
        operator delete(v48);
      }
      uint64_t v21 = v79;
      if (!v79) {
        goto LABEL_64;
      }
      BOOL v49 = v80;
      uint64_t v23 = v79;
      if (v80 == v79) {
        goto LABEL_63;
      }
      do
      {
        BOOL v51 = (void *)*--v49;
        unint64_t v50 = v51;
        void *v49 = 0;
        if (v51) {
          operator delete[](v50);
        }
      }
      while (v49 != v21);
      goto LABEL_62;
    }
    a1[1] = v36;
  }
  uint64_t v52 = mlir::DictionaryAttr::get((uint64_t)&v70, "gate_layout", 0xBuLL);
  uint64_t v71 = v52;
  if (v52)
  {
    if (*(_UNKNOWN **)(*(void *)v52 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id)
    {
      a3(v74, a4);
LABEL_83:
      mlir::InFlightDiagnostic::append<mlir::Attribute>(v53, &v71);
LABEL_84:
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v74);
      return 0;
    }
    a1[2] = v52;
  }
  uint64_t v54 = mlir::DictionaryAttr::get((uint64_t)&v70, "igate_activation", 0x10uLL);
  uint64_t v71 = v54;
  if (v54)
  {
    if (*(_UNKNOWN **)(*(void *)v54 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v74, a4);
LABEL_82:
      uint64_t v53 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v74, v55);
      goto LABEL_83;
    }
    a1[3] = v54;
  }
  uint64_t v56 = mlir::DictionaryAttr::get((uint64_t)&v70, "ogate_activation", 0x10uLL);
  uint64_t v71 = v56;
  if (v56)
  {
    if (*(_UNKNOWN **)(*(void *)v56 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v74, a4);
      goto LABEL_82;
    }
    a1[4] = v56;
  }
  uint64_t v57 = mlir::DictionaryAttr::get((uint64_t)&v70, "zgate_activation", 0x10uLL);
  uint64_t v71 = v57;
  if (v57)
  {
    if (*(_UNKNOWN **)(*(void *)v57 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v74, a4);
      goto LABEL_82;
    }
    a1[5] = v57;
  }
  __int16 v59 = (void *)mlir::DictionaryAttr::get((uint64_t)&v70, "operandSegmentSizes", 0x13uLL);
  if (!v59)
  {
    __int16 v59 = (void *)mlir::DictionaryAttr::get((uint64_t)&v70, "operand_segment_sizes", 0x15uLL);
    if (!v59)
    {
      a3(v74, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v74, "expected key entry for operandSegmentSizes in DictionaryAttr to set Properties.");
      goto LABEL_84;
    }
  }
  return mlir::convertFromAttribute(a1 + 6, (const char *)0xA, v59, a3, a4) != 0;
}

uint64_t mlir::mps::LSTMGradientOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v53[6] = *MEMORY[0x1E4F143B8];
  unint64_t v50 = a1;
  BOOL v51 = v53;
  uint64_t v52 = 0x300000000;
  if (*a2)
  {
    uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v50, (uint64_t)"cell_activation", 15, *a2);
    uint64_t v6 = v5;
    unsigned int v7 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      unsigned int v7 = v52;
    }
    uint64_t v8 = (uint64_t *)((char *)v51 + 16 * v7);
    uint64_t *v8 = NamedAttr;
    v8[1] = v6;
    LODWORD(v52) = v52 + 1;
  }
  uint64_t v9 = a2[1];
  if (v9)
  {
    uint64_t v10 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"fgate_activation", 16, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      unsigned int v13 = v52;
    }
    uint64_t v14 = (uint64_t *)((char *)v51 + 16 * v13);
    *uint64_t v14 = v10;
    v14[1] = v12;
    LODWORD(v52) = v52 + 1;
  }
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"gate_layout", 11, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      unsigned int v19 = v52;
    }
    unint64_t v20 = (uint64_t *)((char *)v51 + 16 * v19);
    *unint64_t v20 = v16;
    v20[1] = v18;
    LODWORD(v52) = v52 + 1;
  }
  uint64_t v21 = a2[3];
  if (v21)
  {
    uint64_t v22 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"igate_activation", 16, v21);
    uint64_t v24 = v23;
    unsigned int v25 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      unsigned int v25 = v52;
    }
    long long v26 = (uint64_t *)((char *)v51 + 16 * v25);
    *long long v26 = v22;
    v26[1] = v24;
    LODWORD(v52) = v52 + 1;
  }
  uint64_t v27 = a2[4];
  if (v27)
  {
    uint64_t v28 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"ogate_activation", 16, v27);
    uint64_t v30 = v29;
    unsigned int v31 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      unsigned int v31 = v52;
    }
    unsigned int v32 = (uint64_t *)((char *)v51 + 16 * v31);
    *unsigned int v32 = v28;
    v32[1] = v30;
    LODWORD(v52) = v52 + 1;
  }
  uint64_t v33 = a2[5];
  if (v33)
  {
    uint64_t v34 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"zgate_activation", 16, v33);
    uint64_t v36 = v35;
    unsigned int v37 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      unsigned int v37 = v52;
    }
    unint64_t v38 = (uint64_t *)((char *)v51 + 16 * v37);
    uint64_t *v38 = v34;
    v38[1] = v36;
    LODWORD(v52) = v52 + 1;
  }
  uint64_t v39 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 6), 10);
  uint64_t v40 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"operandSegmentSizes", 19, v39);
  uint64_t v42 = v41;
  unsigned int v43 = v52;
  if (v52 >= HIDWORD(v52))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
    unsigned int v43 = v52;
  }
  uint64_t v44 = (uint64_t *)((char *)v51 + 16 * v43);
  uint64_t *v44 = v40;
  v44[1] = v42;
  BOOL v45 = __CFADD__(v52, 1);
  uint64_t v46 = (v52 + 1);
  LODWORD(v52) = v52 + 1;
  if (v45)
  {
    uint64_t DictionaryAttr = 0;
    unint64_t v48 = v51;
    if (v51 == v53) {
      return DictionaryAttr;
    }
    goto LABEL_32;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v50, (uint64_t *)v51, v46);
  unint64_t v48 = v51;
  if (v51 != v53) {
LABEL_32:
  }
    free(v48);
  return DictionaryAttr;
}

unint64_t mlir::mps::LSTMGradientOp::computePropertiesHash(unint64_t *a1)
{
  uint64_t v101 = *MEMORY[0x1E4F143B8];
  unint64_t v1 = *a1;
  unint64_t v2 = 0x1E8EB8000uLL;
  {
    unsigned int v76 = a1;
    unint64_t v83 = v1;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v42 = v41;
    a1 = v76;
    unint64_t v1 = v83;
    if (v42)
    {
      unint64_t v43 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v43 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v43;
      a1 = v76;
      unint64_t v1 = v83;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  uint64_t v3 = *(void *)(v2 + 3024);
  unint64_t v4 = a1[1];
  {
    unsigned int v77 = a1;
    unint64_t v84 = v1;
    unint64_t v64 = v4;
    uint64_t v69 = v3;
    unint64_t v4 = v64;
    uint64_t v3 = v69;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v45 = v44;
    a1 = v77;
    unint64_t v1 = v84;
    if (v45)
    {
      unint64_t v46 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v46 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v46;
      unint64_t v4 = v64;
      uint64_t v3 = v69;
      a1 = v77;
      unint64_t v1 = v84;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v5 = HIDWORD(v4);
  unint64_t v6 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v4) ^ HIDWORD(v4));
  unint64_t v96 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) ^ ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) >> 47));
  unint64_t v7 = a1[2];
  {
    uint64_t v78 = a1;
    unint64_t v85 = v1;
    unint64_t v65 = v7;
    uint64_t v70 = v3;
    unint64_t v7 = v65;
    uint64_t v3 = v70;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v48 = v47;
    a1 = v78;
    unint64_t v1 = v85;
    if (v48)
    {
      unint64_t v49 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v49 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v49;
      unint64_t v7 = v65;
      uint64_t v3 = v70;
      a1 = v78;
      unint64_t v1 = v85;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v8 = HIDWORD(v7);
  unint64_t v9 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v7) ^ HIDWORD(v7));
  unint64_t v95 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
  unint64_t v10 = a1[3];
  {
    unint64_t v79 = a1;
    unint64_t v86 = v1;
    unint64_t v66 = v10;
    uint64_t v71 = v3;
    unint64_t v10 = v66;
    uint64_t v3 = v71;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v51 = v50;
    a1 = v79;
    unint64_t v1 = v86;
    if (v51)
    {
      unint64_t v52 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v52 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v52;
      unint64_t v10 = v66;
      uint64_t v3 = v71;
      a1 = v79;
      unint64_t v1 = v86;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v11 = HIDWORD(v10);
  unint64_t v12 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v10) ^ HIDWORD(v10));
  unint64_t v94 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v11 ^ (v12 >> 47) ^ v12)) ^ ((0x9DDFEA08EB382D69 * (v11 ^ (v12 >> 47) ^ v12)) >> 47));
  unint64_t v13 = a1[4];
  {
    char v80 = a1;
    unint64_t v87 = v1;
    unint64_t v67 = v13;
    uint64_t v72 = v3;
    unint64_t v13 = v67;
    uint64_t v3 = v72;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v54 = v53;
    a1 = v80;
    unint64_t v1 = v87;
    if (v54)
    {
      unint64_t v55 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v55 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v55;
      unint64_t v13 = v67;
      uint64_t v3 = v72;
      a1 = v80;
      unint64_t v1 = v87;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v14 = HIDWORD(v13);
  unint64_t v15 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v13) ^ HIDWORD(v13));
  unint64_t v93 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v14 ^ (v15 >> 47) ^ v15)) ^ ((0x9DDFEA08EB382D69 * (v14 ^ (v15 >> 47) ^ v15)) >> 47));
  unint64_t v16 = a1[5];
  {
    uint64_t v81 = a1;
    unint64_t v88 = v1;
    unint64_t v68 = v16;
    uint64_t v73 = v3;
    unint64_t v16 = v68;
    uint64_t v3 = v73;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v57 = v56;
    a1 = v81;
    unint64_t v1 = v88;
    if (v57)
    {
      unint64_t v58 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v58 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v58;
      unint64_t v16 = v68;
      uint64_t v3 = v73;
      a1 = v81;
      unint64_t v1 = v88;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v17 = HIDWORD(v16);
  unint64_t v18 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v16) ^ HIDWORD(v16));
  unint64_t v92 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v17 ^ (v18 >> 47) ^ v18)) ^ ((0x9DDFEA08EB382D69 * (v17 ^ (v18 >> 47) ^ v18)) >> 47));
  {
    uint64_t v82 = a1;
    unint64_t v89 = v1;
    uint64_t v74 = v3;
    unint64_t v1 = v89;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v60 = v59;
    uint64_t v3 = v74;
    a1 = v82;
    if (v60)
    {
      unint64_t v61 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v61 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v61;
      uint64_t v3 = v74;
      a1 = v82;
      unint64_t v1 = v89;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v19 = a1[7];
  unint64_t v20 = a1[8];
  unint64_t v21 = a1[9];
  uint64_t v22 = a1[6] - 0x3C5A37A36834CED9 * v21 - 0x6E18B188484051E8;
  uint64_t v23 = __ROR8__(v22 + v21, 52);
  unint64_t v24 = v22 + v19;
  uint64_t v25 = __ROR8__(v24, 7);
  unint64_t v26 = v24 + v20;
  uint64_t v27 = v25 + __ROR8__(a1[6] - 0x3C5A37A36834CED9 * v21 - 0x6E18B188484051E8, 37) + v23;
  unint64_t v28 = v20 + v19;
  unint64_t v29 = a1[10];
  uint64_t v30 = __ROR8__(v28 + v29, 52);
  uint64_t v31 = v27 + __ROR8__(v26, 31);
  uint64_t v32 = __ROR8__(v28, 37);
  unint64_t v33 = v28 + v20;
  uint64_t v34 = __ROR8__(v33, 7);
  unint64_t v35 = v33 + v21;
  unint64_t v36 = v26 + v21 + v32 + v30 + v34 + __ROR8__(v35, 31);
  unint64_t v37 = ((0xC3A5C85C97CB3127
        * ((0xC3A5C85C97CB3127 * (v35 + v29 + v31) - 0x651E95C4D06FBFB1 * v36) ^ ((0xC3A5C85C97CB3127
                                                                                     * (v35 + v29 + v31)
                                                                                     - 0x651E95C4D06FBFB1 * v36) >> 47))) ^ *(void *)(v2 + 3024))
      + v31;
  unint64_t v91 = 0x9AE16A3B2F90404FLL * (v37 ^ (v37 >> 47));
  uint64_t v99 = 0;
  memset(v98, 0, sizeof(v98));
  memset(v97, 0, sizeof(v97));
  {
    unint64_t v90 = v1;
    uint64_t v75 = v3;
    uint64_t v3 = v75;
    unint64_t v1 = v90;
    unint64_t v2 = 0x1E8EB8000uLL;
    if (v62)
    {
      unint64_t v63 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v63 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v63;
      uint64_t v3 = v75;
      unint64_t v1 = v90;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v38 = HIDWORD(v1);
  unint64_t v39 = 0x9DDFEA08EB382D69 * ((v3 + 8 * v1) ^ HIDWORD(v1));
  uint64_t v100 = *(void *)(v2 + 3024);
  *(void *)&v97[0] = 0x9DDFEA08EB382D69
                     * ((0x9DDFEA08EB382D69 * (v38 ^ (v39 >> 47) ^ v39)) ^ ((0x9DDFEA08EB382D69
                                                                             * (v38 ^ (v39 >> 47) ^ v39)) >> 47));
  return llvm::hashing::detail::hash_combine_recursive_helper::combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>((llvm::hashing::detail::hash_combine_recursive_helper *)v97, 0, (void *)v97 + 1, (char *)v98, (uint64_t *)&v96, (uint64_t *)&v95, (uint64_t *)&v94, (uint64_t *)&v93, (uint64_t *)&v92, (uint64_t *)&v91);
}

uint64_t mlir::mps::LSTMGradientOp::getInherentAttr(mlir::MLIRContext *a1, void *a2, char *__s1, size_t __n)
{
  uint64_t result = 0;
  switch(__n)
  {
    case 0xBuLL:
      if (memcmp(__s1, "gate_layout", __n)) {
        goto LABEL_23;
      }
      return a2[2];
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x14uLL:
      goto LABEL_23;
    case 0xFuLL:
      if (*(void *)__s1 != 0x7463615F6C6C6563 || *(void *)(__s1 + 7) != 0x6E6F697461766974) {
        goto LABEL_23;
      }
      return *a2;
    case 0x10uLL:
      if (!memcmp(__s1, "fgate_activation", __n))
      {
        uint64_t result = a2[1];
      }
      else if (!memcmp(__s1, "igate_activation", __n))
      {
        uint64_t result = a2[3];
      }
      else if (*(void *)__s1 == 0x63615F657461676FLL && *((void *)__s1 + 1) == 0x6E6F697461766974)
      {
        uint64_t result = a2[4];
      }
      else if (*(void *)__s1 == 0x63615F657461677ALL && *((void *)__s1 + 1) == 0x6E6F697461766974)
      {
        uint64_t result = a2[5];
      }
      else
      {
LABEL_23:
        uint64_t result = 0;
      }
      break;
    case 0x13uLL:
      if (memcmp(__s1, "operandSegmentSizes", __n)) {
        goto LABEL_23;
      }
      goto LABEL_25;
    case 0x15uLL:
      if (memcmp(__s1, "operand_segment_sizes", __n)) {
        goto LABEL_23;
      }
LABEL_25:
      uint64_t result = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 6), 10);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t mlir::mps::LSTMGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, void *a4)
{
  unint64_t v7 = (void *)result;
  switch(__n)
  {
    case 0xBuLL:
      uint64_t result = memcmp(__s1, "gate_layout", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id) {
            unint64_t v15 = a4;
          }
          else {
            unint64_t v15 = 0;
          }
          v7[2] = v15;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    case 0xFuLL:
      if (*(void *)__s1 == 0x7463615F6C6C6563 && *(void *)(__s1 + 7) == 0x6E6F697461766974)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
            unint64_t v9 = a4;
          }
          else {
            unint64_t v9 = 0;
          }
          *(void *)uint64_t result = v9;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "fgate_activation", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "igate_activation", __n);
        if (result)
        {
          if (*(void *)__s1 == 0x63615F657461676FLL && *((void *)__s1 + 1) == 0x6E6F697461766974)
          {
            if (a4)
            {
              if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
                unint64_t v18 = a4;
              }
              else {
                unint64_t v18 = 0;
              }
              uint64_t v7[4] = v18;
            }
            else
            {
              uint64_t v7[4] = 0;
            }
          }
          else if (*(void *)__s1 == 0x63615F657461677ALL && *((void *)__s1 + 1) == 0x6E6F697461766974)
          {
            if (a4)
            {
              if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
                unint64_t v12 = a4;
              }
              else {
                unint64_t v12 = 0;
              }
              v7[5] = v12;
            }
            else
            {
              v7[5] = 0;
            }
          }
        }
        else if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
            unint64_t v17 = a4;
          }
          else {
            unint64_t v17 = 0;
          }
          v7[3] = v17;
        }
        else
        {
          v7[3] = 0;
        }
      }
      else if (a4)
      {
        if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
          unint64_t v16 = a4;
        }
        else {
          unint64_t v16 = 0;
        }
        v7[1] = v16;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x13uLL:
      uint64_t result = memcmp(__s1, "operandSegmentSizes", __n);
      if (!result) {
        goto LABEL_33;
      }
      break;
    case 0x15uLL:
      uint64_t result = memcmp(__s1, "operand_segment_sizes", __n);
      if (!result)
      {
LABEL_33:
        if (a4)
        {
          uint64_t result = mlir::detail::DenseArrayAttrImpl<int>::classof(a4);
          unint64_t v13 = result ? a4 : 0;
          unint64_t v19 = v13;
          if (result)
          {
            uint64_t result = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v19);
            if (result == 10)
            {
              uint64_t result = mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v19);
              if (v14) {
                uint64_t result = (uint64_t)memmove(v7 + 6, (const void *)result, 4 * v14);
              }
            }
          }
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::LSTMGradientOp::populateInherentAttrs(mlir::MLIRContext *a1, uint64_t *a2, uint64_t a3)
{
  if (*a2) {
    mlir::NamedAttrList::append(a3, (uint64_t)"cell_activation", 15, *a2);
  }
  uint64_t v6 = a2[1];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"fgate_activation", 16, v6);
  }
  uint64_t v7 = a2[2];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"gate_layout", 11, v7);
  }
  uint64_t v8 = a2[3];
  if (v8) {
    mlir::NamedAttrList::append(a3, (uint64_t)"igate_activation", 16, v8);
  }
  uint64_t v9 = a2[4];
  if (v9) {
    mlir::NamedAttrList::append(a3, (uint64_t)"ogate_activation", 16, v9);
  }
  uint64_t v10 = a2[5];
  if (v10) {
    mlir::NamedAttrList::append(a3, (uint64_t)"zgate_activation", 16, v10);
  }
  uint64_t v11 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 6), 10);

  mlir::NamedAttrList::append(a3, (uint64_t)"operandSegmentSizes", 19, v11);
}

BOOL mlir::mps::LSTMGradientOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v8, (const void **)"cell_activation", (const char *)0xF, a3, a4))
  {
    uint64_t v9 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v9, (const void **)"fgate_activation", (const char *)0x10, a3, a4))
    {
      uint64_t v10 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps30(v10, (const void **)"gate_layout", (const char *)0xB, a3, a4))
      {
        uint64_t v11 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 24));
        if (!v11
          || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v11, (const void **)"igate_activation", (const char *)0x10, a3, a4))
        {
          uint64_t v12 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v12, (const void **)"ogate_activation", (const char *)0x10, a3, a4))
          {
            uint64_t v13 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v13, (const void **)"zgate_activation", (const char *)0x10, a3, a4))
            {
              return 1;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps30(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    uint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    uint64_t v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = (char *)v35;
        uint64_t v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        uint64_t v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      unint64_t v29 = a2;
      uint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        uint64_t v30 = "' failed to satisfy constraint: valid LSTM gate layout";
        uint64_t v31 = 54;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        uint64_t v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)uint64_t v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    unint64_t v16 = (void **)__p;
    if (__p)
    {
      unint64_t v17 = v42;
      unint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          unint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        unint64_t v18 = __p;
      }
      int v42 = v16;
      operator delete(v18);
    }
    unint64_t v19 = v39;
    if (v39)
    {
      unint64_t v20 = v40;
      unint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = (void *)*--v20;
          uint64_t v22 = v23;
          *unint64_t v20 = 0;
          if (v23) {
            operator delete[](v22);
          }
        }
        while (v20 != v19);
        unint64_t v21 = v39;
      }
      uint64_t v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}