uint64_t deleteDeadness(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;
  int v7;
  void *v8;
  mlir::Block *v9;
  unsigned int v10;
  unsigned char *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned char *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  mlir::GenericProgramPoint **v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  unint64_t v23;
  void *v24;
  void *v25;
  unint64_t v26;
  unint64_t *v27;
  void *v28;
  unint64_t v29;
  uint64_t Values;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  unint64_t v34;
  void *v35;
  void *v36;
  unint64_t v37;
  unint64_t *v38;
  void *v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unsigned int v50;
  int v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unsigned int v56;
  uint64_t v57;
  int v58;
  unsigned int v59;
  unint64_t v60;
  mlir::GenericProgramPoint *v61;
  mlir::GenericProgramPoint *v62;
  mlir::GenericProgramPoint *v63;
  mlir::GenericProgramPoint *v64;
  unsigned int *v65;
  unsigned int *v66;
  int v67;
  uint64_t v68;
  int v69;
  unsigned int v70;
  unsigned int *v71;
  unint64_t v72;
  unint64_t v73;
  int v74;
  unsigned int v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t j;
  void **NextResultAtOffset;
  void *v80;
  void *v81;
  unint64_t v82;
  unint64_t v83;
  const char *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  unint64_t v89;
  unint64_t v90;
  const char *v91;
  unint64_t v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  void *i;
  uint64_t v97;
  void *v99;
  void *v100;
  mlir::GenericProgramPoint **v102;
  int v103;
  BOOL v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  void *v108;
  void *v109;
  const void *v110;
  void *v111;
  uint64_t v112;
  unsigned char v113[320];
  mlir::Block *v114;
  void *v115;
  const void *v116;
  void *__dst;
  uint64_t v118;
  unsigned char v119[320];
  void *v120;
  void *v121;
  void *__src;
  unsigned int v123;
  uint64_t v124;
  void *v125;
  void *v126;
  void *v127;
  unsigned int v128;
  uint64_t v129;
  const char *v130;
  unint64_t v131;
  int v132;
  void *v133;
  void v134[5];

  v134[3] = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    v5 = a2;
    v6 = a1;
    v7 = 0;
    v99 = &a2[3 * a3];
    while ((void *)*v5 == v5)
    {
LABEL_3:
      v5 += 3;
      if (v5 == v99) {
        return v7 & 1;
      }
    }
    v8 = (void *)v5[1];
    v100 = v5;
    v104 = v8 != v5 && v8[1] == (void)v5;
    if (v8) {
      v9 = (mlir::Block *)(v8 - 1);
    }
    else {
      v9 = 0;
    }
    v114 = v9;
    llvm::post_order<mlir::Block *>(&v114, &v120);
    llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v114, &v116, (const llvm::SmallPtrSetImplBase *)&v120);
    __dst = v119;
    v118 = 0x800000000;
    v10 = v123;
    if (!v123)
    {
LABEL_17:
      llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v108, &v110, (const llvm::SmallPtrSetImplBase *)&v125);
      v111 = v113;
      v112 = 0x800000000;
      v13 = v128;
      if (!v128) {
        goto LABEL_24;
      }
      v14 = v113;
      v15 = v128;
      if (v128 >= 9uLL)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v111, v113, v128, 40);
        v15 = v128;
        if (!v128)
        {
LABEL_22:
          LODWORD(v112) = v13;
          while (1)
          {
LABEL_24:
            if (v118 == v13)
            {
              if (!v13)
              {
LABEL_142:
                if (v111 != v113) {
                  free(v111);
                }
                v5 = v100;
                if (v109 != v108) {
                  free(v109);
                }
                if (__dst != v119) {
                  free(__dst);
                }
                if (v115 != v114) {
                  free(v115);
                }
                if (v127 != &v129) {
                  free(v127);
                }
                if (v126 != v125) {
                  free(v126);
                }
                if (__src != &v124) {
                  free(__src);
                }
                if (v121 != v120) {
                  free(v121);
                }
                for (i = *(void **)(v100[1] + 8); i != v100; i = (void *)i[1])
                {
                  if (i) {
                    v97 = (uint64_t)(i - 1);
                  }
                  else {
                    v97 = 0;
                  }
                  v120 = (void *)a4;
                }
                goto LABEL_3;
              }
              v16 = v111;
              v17 = __dst;
              while (*v17 == *v16 && v17[1] == v16[1] && v17[2] == v16[2] && v17[3] == v16[3] && v17[4] == v16[4])
              {
                v17 += 5;
                v16 += 5;
                if (v17 == (void *)((char *)__dst + 40 * v13)) {
                  goto LABEL_142;
                }
              }
            }
            v18 = (mlir::GenericProgramPoint **)*((void *)__dst + 5 * v118 - 5);
            if (!v104) {
              break;
            }
LABEL_93:
            v63 = v18[4];
            v62 = (mlir::GenericProgramPoint *)(v18 + 4);
            v61 = v63;
            if (v63 != v62)
            {
              do
              {
                while (1)
                {
                  v64 = *(mlir::GenericProgramPoint **)v61;
                  mlir::GenericProgramPoint::~GenericProgramPoint(v61);
                  v66 = v65;
                  v67 = *(_DWORD *)(a4 + 48);
                  if (v67) {
                    break;
                  }
LABEL_108:
                  v76 = v65[9];
                  if (v76) {
                    v77 = (uint64_t)(v65 - 4);
                  }
                  else {
                    v77 = 0;
                  }
                  if (v76)
                  {
                    for (j = 0; j != v76; ++j)
                    {
                      NextResultAtOffset = (void **)mlir::detail::OpResultImpl::getNextResultAtOffset(v77, j);
                      while (1)
                      {
                        v80 = *NextResultAtOffset;
                        if (!*NextResultAtOffset) {
                          break;
                        }
                        v81 = (void *)v80[1];
                        if (v81)
                        {
                          *v81 = *v80;
                          if (*v80) {
                            *(void *)(*v80 + 8) = v80[1];
                          }
                        }
                        *v80 = 0;
                        v80[1] = 0;
                        v80[3] = 0;
                      }
                    }
                  }
                  (*(void (**)(uint64_t, unsigned int *))(*(void *)v6 + 40))(v6, v66);
                  v7 = 1;
                  v61 = v64;
                  if (v64 == v62) {
                    goto LABEL_94;
                  }
                }
                v68 = *(void *)(a4 + 32);
                v69 = v67 - 1;
                v70 = ((v65 >> 4) ^ (v65 >> 9)) & v69;
                v71 = *(unsigned int **)(v68 + 8 * v70);
                if (v71 != v65)
                {
                  v74 = 1;
                  while (v71 != (unsigned int *)-4096)
                  {
                    v75 = v70 + v74++;
                    v70 = v75 & v69;
                    v71 = *(unsigned int **)(v68 + 8 * v70);
                    if (v71 == v65) {
                      goto LABEL_99;
                    }
                  }
                  goto LABEL_108;
                }
LABEL_99:
                v72 = v65[11];
                if ((v72 & 0x7FFFFF) != 0) {
                  v73 = (((unint64_t)&v65[4 * ((v72 >> 23) & 1) + 17] + ((v72 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
                }
                      + 32 * v65[10];
                else {
                  v73 = 0;
                }
                v7 |= deleteDeadness(v6, v73) != 0;
                v61 = v64;
              }
              while (v64 != v62);
            }
LABEL_94:
            LODWORD(v118) = v118 - 1;
            if (v118) {
              llvm::po_iterator<mlir::Block *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Block *>>::traverseChild((llvm::SmallPtrSetImplBase *)&v114);
            }
            v13 = v112;
          }
          v102 = (mlir::GenericProgramPoint **)*((void *)__dst + 5 * v118 - 5);
          mlir::Block::getTerminator(v18);
          v105 = v19;
          v20 = *(void *)(v19 + 48);
          v21 = *(void **)(v20 + 16);
          if (v21 == &mlir::detail::TypeIDResolver<void,void>::id) {
            v22 = 0;
          }
          else {
            v22 = *(void *)(v19 + 48);
          }
          v103 = v7;
          if (v21 == &mlir::detail::TypeIDResolver<void,void>::id)
          {
            v130 = *(const char **)(v20 + 8);
            Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v130);
            if (!Values
              || (Values = mlir::Dialect::getRegisteredInterfaceForOp<mlir::BranchOpInterface>(Values, v20)) == 0)
            {
LABEL_52:
              v106 = 0;
              v107 = Values;
LABEL_92:
              v6 = a1;
              v18 = v102;
              v7 = v103;
              goto LABEL_93;
            }
          }
          else
          {
            {
              v130 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BranchOpInterface]";
              v131 = 73;
              v82 = llvm::StringRef::find((uint64_t *)&v130, "DesiredTypeName = ", 0x12uLL, 0);
              if (v131 >= v82) {
                v83 = v82;
              }
              else {
                v83 = v131;
              }
              v84 = &v130[v83];
              v85 = v131 - v83;
              v86 = 18;
              if (v85 < 0x12) {
                v86 = v85;
              }
              v87 = v85 - v86;
              if (v87 >= v87 - 1) {
                v88 = v87 - 1;
              }
              else {
                v88 = v87;
              }
              mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v84[v86], v88);
            }
            v23 = *(unsigned int *)((v22 | v20 & 0xFFFFFFFFFFFFFF00) + 0x28);
            if (!v23) {
              goto LABEL_168;
            }
            v24 = *(void **)((v22 | v20 & 0xFFFFFFFFFFFFFF00) + 0x20);
            v25 = &v24[2 * v23];
            do
            {
              v26 = v23 >> 1;
              v27 = &v24[2 * (v23 >> 1)];
              v29 = *v27;
              v28 = v27 + 2;
              v23 += ~(v23 >> 1);
              if (v29 < mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id) {
                v24 = v28;
              }
              else {
                v23 = v26;
              }
            }
            while (v23);
            if (v24 == v25
              || *v24 != mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id
              || !v24[1])
            {
LABEL_168:
              Values = mlir::Dialect::getRegisteredInterfaceForOp<mlir::BranchOpInterface>(*(void *)((v22 | v20 & 0xFFFFFFFFFFFFFF00) + 0x18), *(void *)(v105 + 48));
              if (!Values) {
                goto LABEL_52;
              }
            }
          }
          v31 = *(void *)(v105 + 48);
          v32 = *(void **)(v31 + 16);
          if (v32 == &mlir::detail::TypeIDResolver<void,void>::id) {
            v33 = 0;
          }
          else {
            v33 = *(void *)(v105 + 48);
          }
          if (v32 == &mlir::detail::TypeIDResolver<void,void>::id)
          {
            v130 = *(const char **)(v31 + 8);
            v41 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v130);
            if (v41)
            {
              v42 = v31;
              goto LABEL_70;
            }
          }
          else
          {
            {
              v130 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BranchOpInterface]";
              v131 = 73;
              v89 = llvm::StringRef::find((uint64_t *)&v130, "DesiredTypeName = ", 0x12uLL, 0);
              if (v131 >= v89) {
                v90 = v89;
              }
              else {
                v90 = v131;
              }
              v91 = &v130[v90];
              v92 = v131 - v90;
              v93 = 18;
              if (v92 < 0x12) {
                v93 = v92;
              }
              v94 = v92 - v93;
              if (v94 >= v94 - 1) {
                v95 = v94 - 1;
              }
              else {
                v95 = v94;
              }
              mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v91[v93], v95);
            }
            v34 = *(unsigned int *)((v33 | v31 & 0xFFFFFFFFFFFFFF00) + 0x28);
            if (!v34) {
              goto LABEL_67;
            }
            v35 = *(void **)((v33 | v31 & 0xFFFFFFFFFFFFFF00) + 0x20);
            v36 = &v35[2 * v34];
            do
            {
              v37 = v34 >> 1;
              v38 = &v35[2 * (v34 >> 1)];
              v40 = *v38;
              v39 = v38 + 2;
              v34 += ~(v34 >> 1);
              if (v40 < mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id) {
                v35 = v39;
              }
              else {
                v34 = v37;
              }
            }
            while (v34);
            if (v35 == v36
              || *v35 != mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id
              || (v41 = v35[1]) == 0)
            {
LABEL_67:
              v41 = *(void *)((v33 | v31 & 0xFFFFFFFFFFFFFF00) + 0x18);
              v42 = *(void *)(v105 + 48);
LABEL_70:
              v41 = mlir::Dialect::getRegisteredInterfaceForOp<mlir::BranchOpInterface>(v41, v42);
            }
          }
          v106 = v105;
          v107 = v41;
          if (v105)
          {
            v43 = *(unsigned int *)(v105 + 40);
            if (v43)
            {
              v44 = 0;
              while (1)
              {
                v45 = v43;
                v46 = (v43 + ~v44);
                mlir::BranchOpInterface::getSuccessorOperands((mlir::BranchOpInterface *)&v106, v46);
                v47 = (v132 + v130);
                if (v132 + v130) {
                  break;
                }
LABEL_90:
                if (v133 != v134) {
                  free(v133);
                }
                ++v44;
                v43 = v45;
                if (v44 == v45) {
                  goto LABEL_92;
                }
              }
              v48 = 0;
              v49 = *(void *)(((v105
                                + 64
                                + 16 * (((unint64_t)*(unsigned int *)(v105 + 44) >> 23) & 1)
                                + (((unint64_t)*(unsigned int *)(v105 + 44) >> 21) & 0x7F8)
                                + 7) & 0xFFFFFFFFFFFFFFF8)
                              + 32 * v46
                              + 24);
              while (2)
              {
                v50 = v47 + ~v48;
                v51 = *(_DWORD *)(a4 + 24);
                if (v51)
                {
                  v52 = *(void *)(*(void *)(v49 + 48) + 8 * v50);
                  v53 = *(void *)(a4 + 8);
                  {
                    v60 = llvm::hashing::detail::fixed_seed_override;
                    if (!llvm::hashing::detail::fixed_seed_override) {
                      v60 = 0xFF51AFD7ED558CCDLL;
                    }
                    llvm::hashing::detail::get_execution_seed(void)::seed = v60;
                  }
                  v54 = 0x9DDFEA08EB382D69
                      * ((llvm::hashing::detail::get_execution_seed(void)::seed + 8 * v52) ^ HIDWORD(v52));
                  v55 = 0x9DDFEA08EB382D69 * (HIDWORD(v52) ^ (v54 >> 47) ^ v54);
                  v56 = (-348639895 * ((v55 >> 47) ^ v55)) & (v51 - 1);
                  v57 = *(void *)(v53 + 8 * v56);
                  if (v52 != v57)
                  {
                    v58 = 1;
                    while (v57 != -4096)
                    {
                      v59 = v56 + v58++;
                      v56 = v59 & (v51 - 1);
                      v57 = *(void *)(v53 + 8 * v56);
                      if (v52 == v57) {
                        goto LABEL_78;
                      }
                    }
                    goto LABEL_77;
                  }
                }
                else
                {
LABEL_77:
                  mlir::MutableOperandRange::erase((mlir::MutableOperandRange *)&v131, v50 - v130, 1u);
                }
LABEL_78:
                if (++v48 == v47) {
                  goto LABEL_90;
                }
                continue;
              }
            }
          }
          goto LABEL_92;
        }
        v14 = v111;
      }
      memcpy(v14, v127, 40 * v15);
      goto LABEL_22;
    }
    v11 = v119;
    v12 = v123;
    if (v123 >= 9uLL)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v119, v123, 40);
      v12 = v123;
      if (!v123)
      {
LABEL_16:
        LODWORD(v118) = v10;
        goto LABEL_17;
      }
      v11 = __dst;
    }
    memcpy(v11, __src, 40 * v12);
    goto LABEL_16;
  }
  LOBYTE(v7) = 0;
  return v7 & 1;
}

void mlir::simplifyRegions(uint64_t a1, void *a2, unint64_t a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  mlir::eraseUnreachableBlocks(a1, (uint64_t)a2, a3);
  v8[1] = 0;
  uint64_t v9 = 0;
  int v10 = 0;
  uint64_t v12 = 0;
  v11 = 0;
  unsigned int v13 = 0;
  if (a3)
  {
    do
    {
      LOBYTE(v8[0]) = 0;
      uint64_t v6 = 24 * a3;
      v7 = a2;
      do
      {
        propagateLiveness(v7, (int64x2_t *)v8);
        v7 += 3;
        v6 -= 24;
      }
      while (v6);
    }
    while (LOBYTE(v8[0]));
  }
  else
  {
    LOBYTE(v8[0]) = 0;
  }
  deleteDeadness(a1, a2, a3, (uint64_t)v8);
  llvm::deallocate_buffer(v11, (void *)(8 * v13));
}

void llvm::post_order<mlir::Block *>(mlir::Block **a1@<X0>, void *a2@<X8>)
{
  v13[40] = *MEMORY[0x1E4F143B8];
  llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>::po_iterator((uint64_t)&v10, *a1);
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  v7[0] = 0;
  memset(v6, 0, sizeof(v6));
  v3 = (char *)v6 + 8;
  v4 = (char *)v6 + 8;
  uint64_t v5 = 8;
  v7[1] = (char *)v8 + 8;
  DWORD1(v8[0]) = 8;
  llvm::make_range<llvm::po_iterator<mlir::Block *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Block *>>>((uint64_t)&v10, (uint64_t)&v3, a2);
  if (v7[1] != (char *)v8 + 8) {
    free(v7[1]);
  }
  if (v4 != v3) {
    free(v4);
  }
  if (v12 != v13) {
    free(v12);
  }
  if (v11 != v10) {
    free(v11);
  }
}

unint64_t processValue(unint64_t result, int64x2_t *a2)
{
  v2 = *(void **)result;
  if (!*(void *)result) {
    return result;
  }
  v4 = (mlir::detail::OpResultImpl *)result;
  uint64_t v5 = &a2->i64[1];
  uint64_t v6 = a2 + 2;
  while (1)
  {
    uint64_t v7 = v2[2];
    unint64_t OperandNumber = mlir::OpOperand::getOperandNumber((unint64_t)v2);
    result = mlir::OperationName::hasTrait<mlir::OpTrait::IsTerminator>((void *)(v7 + 48));
    if (!result
      || (result = llvm::DefaultDoCastIfPossible<mlir::BranchOpInterface,mlir::Operation *,llvm::CastInfo<mlir::BranchOpInterface,mlir::Operation *,void>>::doCastIfPossible(v7),
          v21[0] = (void *)result,
          v21[1] = v9,
          !result)
      || (result = mlir::BranchOpInterface::getSuccessorBlockArgument((mlir::BranchOpInterface *)v21, OperandNumber),
          !v10)
      || (unint64_t v20 = result,
          Owner = 0,
          result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>,mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::LookupBucketFor<mlir::Value>(v5, &v20, &Owner), result))
    {
      __int32 v11 = a2[3].i32[0];
      if (v11) {
        break;
      }
    }
LABEL_13:
    v2 = (void *)*v2;
    if (!v2) {
      return result;
    }
  }
  uint64_t v12 = v2[2];
  uint64_t v13 = a2[2].i64[0];
  __int32 v14 = v11 - 1;
  unsigned int v15 = ((v12 >> 4) ^ (v12 >> 9)) & v14;
  uint64_t v16 = *(void *)(v13 + 8 * v15);
  if (v16 != v12)
  {
    int v17 = 1;
    while (v16 != -4096)
    {
      unsigned int v18 = v15 + v17++;
      unsigned int v15 = v18 & v14;
      uint64_t v16 = *(void *)(v13 + 8 * v15);
      if (v16 == v12) {
        goto LABEL_15;
      }
    }
    goto LABEL_13;
  }
LABEL_15:
  if (!v4 || (*((void *)v4 + 1) & 7) == 7)
  {
    Owner = v4;
    v21[0] = 0;
    result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>,mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::LookupBucketFor<mlir::Value>(v5, (unint64_t *)&Owner, v21);
    if (result)
    {
      char v19 = 0;
    }
    else
    {
      result = (unint64_t)llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>,mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)v5, (uint64_t)&Owner, (unint64_t *)&Owner, v21[0]);
      *(void *)result = Owner;
      char v19 = 1;
    }
  }
  else
  {
    Owner = (mlir::detail::OpResultImpl *)mlir::detail::OpResultImpl::getOwner(v4);
    result = (unint64_t)llvm::DenseMapBase<llvm::DenseMap<mlir::Block *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseSetPair<mlir::Block *>>,mlir::Block *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseSetPair<mlir::Block *>>::try_emplace<llvm::detail::DenseSetEmpty&>(v6, (uint64_t *)&Owner, (uint64_t)v21);
    char v19 = v22;
  }
  a2->i8[0] |= v19;
  return result;
}

uint64_t llvm::function_ref<BOOL ()(mlir::BlockArgument)>::callback_fn<deleteDeadness(mlir::RewriterBase &,llvm::MutableArrayRef<mlir::Region>,anonymous namespace'::LiveMap &)::$_0>(uint64_t *a1, unint64_t a2)
{
  uint64_t v2 = *a1;
  unint64_t v4 = a2;
  uint64_t v5 = 0;
  return llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>,mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::LookupBucketFor<mlir::Value>((uint64_t *)(v2 + 8), &v4, &v5) ^ 1;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>,llvm::DenseMapInfo<mlir::SuccessorRange,void>,llvm::detail::DenseMapPair<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>>>,mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>,llvm::DenseMapInfo<mlir::SuccessorRange,void>,llvm::detail::DenseMapPair<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>>>::LookupBucketFor<mlir::SuccessorRange>(uint64_t *a1, uint64_t *a2, void *a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v6 = *a1;
    int v7 = llvm::hashing::detail::hash_combine_range_impl<llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator>(*a2, 0, *a2, a2[1]);
    int v8 = v4 - 1;
    unsigned int v9 = (v4 - 1) & v7;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    if (v10)
    {
      if (v11 == -8192)
      {
        uint64_t v12 = 0;
        int v13 = 1;
        __int32 v14 = (void *)(v6 + 40 * v9);
        uint64_t v15 = *v14;
        if (*v14 == -4096) {
          goto LABEL_11;
        }
LABEL_5:
        if (v15 != -8192)
        {
          if (v10 != v14[1]) {
            goto LABEL_11;
          }
          uint64_t v16 = (void *)(v15 + 24);
          uint64_t v17 = -8168;
          uint64_t v18 = a2[1];
          while (*(void *)v17 == *v16)
          {
            v16 += 4;
            v17 += 32;
            if (!--v18) {
              goto LABEL_33;
            }
          }
LABEL_11:
          while (v15 != -4096)
          {
            if (v12) {
              BOOL v19 = 0;
            }
            else {
              BOOL v19 = v15 == -8192;
            }
            if (v19) {
              uint64_t v12 = v14;
            }
            unsigned int v20 = v9 + v13++;
            unsigned int v9 = v20 & v8;
            __int32 v14 = (void *)(v6 + 40 * v9);
            uint64_t v15 = *v14;
            if (*v14 != -4096) {
              goto LABEL_5;
            }
          }
LABEL_86:
          uint64_t result = 0;
          if (v12) {
            __int32 v14 = v12;
          }
          *a3 = v14;
          return result;
        }
      }
      else
      {
        if (v11 != -4096)
        {
          uint64_t v12 = 0;
          v37 = (void *)(v11 + 24);
          int v38 = 1;
          __int32 v14 = (void *)(v6 + 40 * v9);
          uint64_t v39 = *v14;
          if ((*v14 | 0x1000) == 0xFFFFFFFFFFFFF000) {
            goto LABEL_68;
          }
LABEL_63:
          if (v10 != v14[1]) {
            goto LABEL_68;
          }
          v40 = (void *)(v39 + 24);
          v41 = v37;
          uint64_t v42 = a2[1];
          while (*v41 == *v40)
          {
            v40 += 4;
            v41 += 4;
            uint64_t result = 1;
            if (!--v42) {
              goto LABEL_20;
            }
          }
LABEL_68:
          while (v39 != -4096)
          {
            if (v12) {
              BOOL v43 = 0;
            }
            else {
              BOOL v43 = v39 == -8192;
            }
            if (v43) {
              uint64_t v12 = v14;
            }
            unsigned int v44 = v9 + v38++;
            unsigned int v9 = v44 & v8;
            __int32 v14 = (void *)(v6 + 40 * v9);
            uint64_t v39 = *v14;
            if ((*v14 | 0x1000) != 0xFFFFFFFFFFFFF000) {
              goto LABEL_63;
            }
          }
          goto LABEL_86;
        }
        uint64_t v12 = 0;
        int v26 = 1;
        __int32 v14 = (void *)(v6 + 40 * v9);
        uint64_t v27 = *v14;
        if (*v14 == -8192) {
          goto LABEL_42;
        }
LABEL_36:
        if (v27 != -4096)
        {
          if (v10 != v14[1]) {
            goto LABEL_42;
          }
          v28 = (void *)(v27 + 24);
          uint64_t v29 = -4072;
          uint64_t v30 = a2[1];
          while (*(void *)v29 == *v28)
          {
            v28 += 4;
            v29 += 32;
            uint64_t result = 1;
            if (!--v30) {
              goto LABEL_20;
            }
          }
LABEL_42:
          while (v27 != -4096)
          {
            if (v12) {
              BOOL v31 = 0;
            }
            else {
              BOOL v31 = v27 == -8192;
            }
            if (v31) {
              uint64_t v12 = v14;
            }
            unsigned int v32 = v9 + v26++;
            unsigned int v9 = v32 & v8;
            __int32 v14 = (void *)(v6 + 40 * v9);
            uint64_t v27 = *v14;
            if (*v14 != -8192) {
              goto LABEL_36;
            }
          }
          goto LABEL_86;
        }
      }
    }
    else if (v11 == -8192)
    {
      uint64_t v12 = 0;
      int v22 = 1;
      __int32 v14 = (void *)(v6 + 40 * v9);
      uint64_t v23 = *v14;
      if (*v14 == -4096) {
        goto LABEL_25;
      }
LABEL_23:
      if (v23 != -8192 && v14[1])
      {
LABEL_25:
        while (v23 != -4096)
        {
          if (v12) {
            BOOL v24 = 0;
          }
          else {
            BOOL v24 = v23 == -8192;
          }
          if (v24) {
            uint64_t v12 = v14;
          }
          unsigned int v25 = v9 + v22++;
          unsigned int v9 = v25 & v8;
          __int32 v14 = (void *)(v6 + 40 * v9);
          uint64_t v23 = *v14;
          if (*v14 != -4096) {
            goto LABEL_23;
          }
        }
        goto LABEL_86;
      }
    }
    else if (v11 == -4096)
    {
      uint64_t v12 = 0;
      int v33 = 1;
      __int32 v14 = (void *)(v6 + 40 * v9);
      uint64_t v34 = *v14;
      if (*v14 == -8192) {
        goto LABEL_54;
      }
LABEL_52:
      if (v34 != -4096 && v14[1])
      {
LABEL_54:
        while (v34 != -4096)
        {
          if (v12) {
            BOOL v35 = 0;
          }
          else {
            BOOL v35 = v34 == -8192;
          }
          if (v35) {
            uint64_t v12 = v14;
          }
          unsigned int v36 = v9 + v33++;
          unsigned int v9 = v36 & v8;
          __int32 v14 = (void *)(v6 + 40 * v9);
          uint64_t v34 = *v14;
          if (*v14 != -8192) {
            goto LABEL_52;
          }
        }
        goto LABEL_86;
      }
    }
    else
    {
      uint64_t v12 = 0;
      int v45 = 1;
      __int32 v14 = (void *)(v6 + 40 * v9);
      uint64_t v46 = *v14;
      if ((*v14 | 0x1000) == 0xFFFFFFFFFFFFF000) {
        goto LABEL_78;
      }
LABEL_77:
      if (v14[1])
      {
LABEL_78:
        while (v46 != -4096)
        {
          if (v12) {
            BOOL v47 = 0;
          }
          else {
            BOOL v47 = v46 == -8192;
          }
          if (v47) {
            uint64_t v12 = v14;
          }
          unsigned int v48 = v9 + v45++;
          unsigned int v9 = v48 & v8;
          __int32 v14 = (void *)(v6 + 40 * v9);
          uint64_t v46 = *v14;
          if ((*v14 | 0x1000) != 0xFFFFFFFFFFFFF000) {
            goto LABEL_77;
          }
        }
        goto LABEL_86;
      }
    }
LABEL_33:
    uint64_t result = 1;
    *a3 = v14;
    return result;
  }
  __int32 v14 = 0;
  uint64_t result = 0;
LABEL_20:
  *a3 = v14;
  return result;
}

unint64_t llvm::hashing::detail::hash_combine_range_impl<llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v94[1] = *MEMORY[0x1E4F143B8];
  {
    uint64_t v82 = a1;
    uint64_t v83 = a4;
    uint64_t v84 = a3;
    uint64_t v85 = a2;
    a2 = v85;
    a3 = v84;
    a4 = v83;
    int v87 = v86;
    a1 = v82;
    if (v87)
    {
      unint64_t v88 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v88 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v88;
      a2 = v85;
      a1 = v82;
      a3 = v84;
      a4 = v83;
    }
  }
  if (a1 == a3)
  {
    if (a2 == a4)
    {
      unint64_t v13 = 0;
    }
    else
    {
      *(void *)&long long v90 = *(void *)(a1 + 32 * a2 + 24);
      if (a2 + 1 == a4)
      {
        unint64_t v13 = 8;
        ++a2;
      }
      else
      {
        *((void *)&v90 + 1) = *(void *)(a1 + 32 * (a2 + 1) + 24);
        if (a2 + 2 == a4)
        {
          unint64_t v13 = 16;
          a2 += 2;
        }
        else
        {
          *(void *)&long long v91 = *(void *)(a1 + 32 * (a2 + 2) + 24);
          if (a2 + 3 == a4)
          {
            unint64_t v13 = 24;
            a2 += 3;
          }
          else
          {
            *((void *)&v91 + 1) = *(void *)(a1 + 32 * (a2 + 3) + 24);
            if (a2 + 4 == a4)
            {
              unint64_t v13 = 32;
              a2 += 4;
            }
            else
            {
              *(void *)&long long v92 = *(void *)(a1 + 32 * (a2 + 4) + 24);
              if (a2 + 5 == a4)
              {
                unint64_t v13 = 40;
                a2 += 5;
              }
              else
              {
                *((void *)&v92 + 1) = *(void *)(a1 + 32 * (a2 + 5) + 24);
                if (a2 + 6 == a4)
                {
                  unint64_t v13 = 48;
                  a2 += 6;
                }
                else
                {
                  *(void *)&long long v93 = *(void *)(a1 + 32 * (a2 + 6) + 24);
                  if (a2 + 7 == a4)
                  {
                    unint64_t v13 = 56;
                    a2 += 7;
                  }
                  else
                  {
                    *((void *)&v93 + 1) = *(void *)(a1 + 32 * (a2 + 7) + 24);
                    a2 += 8;
                    unint64_t v13 = 64;
                  }
                }
              }
            }
          }
        }
      }
    }
    if (a2 == a4) {
      return llvm::hashing::detail::hash_short((llvm::hashing::detail *)&v90, v13, llvm::hashing::detail::get_execution_seed(void)::seed);
    }
    uint64_t v6 = *((void *)&v90 + 1);
    uint64_t v5 = v90;
    uint64_t v8 = *((void *)&v91 + 1);
    uint64_t v7 = v91;
    uint64_t v10 = *((void *)&v92 + 1);
    uint64_t v9 = v92;
    uint64_t v12 = *((void *)&v93 + 1);
    uint64_t v11 = v93;
  }
  else
  {
    int v4 = (void *)(a1 + 32 * a2);
    uint64_t v5 = v4[3];
    *(void *)&long long v90 = v5;
    uint64_t v6 = v4[7];
    *((void *)&v90 + 1) = v6;
    uint64_t v7 = v4[11];
    *(void *)&long long v91 = v7;
    uint64_t v8 = v4[15];
    *((void *)&v91 + 1) = v8;
    uint64_t v9 = v4[19];
    *(void *)&long long v92 = v9;
    uint64_t v10 = v4[23];
    *((void *)&v92 + 1) = v10;
    uint64_t v11 = v4[27];
    *(void *)&long long v93 = v11;
    uint64_t v12 = v4[31];
    *((void *)&v93 + 1) = v12;
    a2 += 8;
  }
  unint64_t v15 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (llvm::hashing::detail::get_execution_seed(void)::seed ^ 0xB492B66FBE98F273)) ^ ((0x9DDFEA08EB382D69 * (llvm::hashing::detail::get_execution_seed(void)::seed ^ 0xB492B66FBE98F273)) >> 47) ^ 0xB492B66FBE98F273);
  uint64_t v16 = __ROR8__(llvm::hashing::detail::get_execution_seed(void)::seed ^ 0xB492B66FBE98F273, 49);
  unint64_t v17 = llvm::hashing::detail::get_execution_seed(void)::seed ^ ((unint64_t)llvm::hashing::detail::get_execution_seed(void)::seed >> 47);
  unint64_t v18 = 0x9DDFEA08EB382D69
      * (llvm::hashing::detail::get_execution_seed(void)::seed ^ (((0x9DDFEA08EB382D69
                                                                  * (v17 ^ (0xB492B66FBE98F273
                                                                          * llvm::hashing::detail::get_execution_seed(void)::seed))) ^ llvm::hashing::detail::get_execution_seed(void)::seed) >> 47) ^ (0x9DDFEA08EB382D69 * (v17 ^ (0xB492B66FBE98F273 * llvm::hashing::detail::get_execution_seed(void)::seed))));
  unint64_t v19 = 0x9DDFEA08EB382D69 * (v18 ^ (v18 >> 47));
  unint64_t v20 = (0xB492B66FBE98F273 * __ROR8__(v16 + llvm::hashing::detail::get_execution_seed(void)::seed + v6, 37)) ^ v19;
  unint64_t v21 = v10
      + v16
      - 0x4B6D499041670D8DLL
      * __ROR8__(v11+ llvm::hashing::detail::get_execution_seed(void)::seed- 0x4B6D499041670D8DLL * llvm::hashing::detail::get_execution_seed(void)::seed, 42);
  unint64_t v22 = 0xB492B66FBE98F273 * __ROR8__(v17 - 0x622015F714C7D297 * (v15 ^ (v15 >> 47)), 33);
  uint64_t v23 = v5 - 0x6D8ED9027DD26057 * llvm::hashing::detail::get_execution_seed(void)::seed;
  uint64_t v24 = v23 + v6 + v7;
  uint64_t v25 = __ROR8__(v24, 44) + v23 + __ROR8__(v20 + v17 + v23 + v8, 21);
  uint64_t v26 = v24 + v8;
  uint64_t v27 = v21 + v7;
  unint64_t v28 = v19 + v9 + v22;
  unint64_t v29 = v10 + v11 + v28;
  unint64_t v30 = __ROR8__(v29, 44) + v28 + __ROR8__(v27 + v12 + v28, 21);
  unint64_t v31 = v29 + v12;
  if (a1 != a3 || a2 != a4)
  {
    v89 = (char *)&v91 + 8;
    unint64_t v32 = 64;
    while (1)
    {
      if (a1 == a3 && a2 == a4)
      {
        uint64_t v36 = 0;
        a2 = a4;
      }
      else
      {
        *(void *)&long long v90 = *(void *)(a1 + 32 * a2 + 24);
        uint64_t v37 = a2 + 1;
        if (a1 == a3 && v37 == a4)
        {
          uint64_t v38 = 0;
          uint64_t v36 = 8;
          ++a2;
          uint64_t v39 = (char *)&v90 + 8;
        }
        else
        {
          *((void *)&v90 + 1) = *(void *)(a1 + 32 * v37 + 24);
          uint64_t v40 = a2 + 2;
          if (a1 == a3 && v40 == a4)
          {
            uint64_t v38 = 8;
            uint64_t v36 = 16;
            a2 += 2;
            uint64_t v39 = (char *)&v91;
          }
          else
          {
            *(void *)&long long v91 = *(void *)(a1 + 32 * v40 + 24);
            uint64_t v41 = a2 + 3;
            if (a1 == a3 && v41 == a4)
            {
              uint64_t v38 = 16;
              uint64_t v36 = 24;
              a2 += 3;
              uint64_t v39 = v89;
            }
            else
            {
              *((void *)&v91 + 1) = *(void *)(a1 + 32 * v41 + 24);
              uint64_t v42 = a2 + 4;
              if (a1 == a3 && v42 == a4)
              {
                uint64_t v38 = 24;
                uint64_t v36 = 32;
                a2 += 4;
                uint64_t v39 = (char *)&v92;
              }
              else
              {
                *(void *)&long long v92 = *(void *)(a1 + 32 * v42 + 24);
                uint64_t v43 = a2 + 5;
                if (a1 == a3 && v43 == a4)
                {
                  uint64_t v38 = 32;
                  uint64_t v36 = 40;
                  a2 += 5;
                  uint64_t v39 = (char *)&v92 + 8;
                }
                else
                {
                  *((void *)&v92 + 1) = *(void *)(a1 + 32 * v43 + 24);
                  uint64_t v44 = a2 + 6;
                  if (a1 == a3 && v44 == a4)
                  {
                    uint64_t v38 = 40;
                    uint64_t v36 = 48;
                    a2 += 6;
                    uint64_t v39 = (char *)&v93;
                  }
                  else
                  {
                    *(void *)&long long v93 = *(void *)(a1 + 32 * v44 + 24);
                    uint64_t v45 = a2 + 7;
                    if (a1 == a3 && v45 == a4)
                    {
                      uint64_t v38 = 48;
                      uint64_t v36 = 56;
                      a2 += 7;
                      uint64_t v39 = (char *)&v93 + 8;
                    }
                    else
                    {
                      *((void *)&v93 + 1) = *(void *)(a1 + 32 * v45 + 24);
                      a2 += 8;
                      uint64_t v38 = 56;
                      uint64_t v36 = 64;
                      uint64_t v39 = (char *)v94;
                    }
                  }
                }
              }
            }
          }
        }
        if ((v36 & 0x38) == 0) {
          goto LABEL_82;
        }
        uint64_t v46 = 56 - v38;
        uint64_t v47 = v36;
        if (v36 != 56 - v38)
        {
          do
          {
            uint64_t v54 = v47;
            uint64_t v47 = v46;
            uint64_t v46 = v54 % v46;
          }
          while (v46);
          if (v47)
          {
            v55 = (long long *)((char *)&v90 + v47);
            do
            {
              char v57 = *((unsigned char *)v55 - 1);
              v55 = (long long *)((char *)v55 - 1);
              char v56 = v57;
              v58 = (long long *)((char *)v55 + v36);
              v59 = v55;
              do
              {
                v60 = v59;
                v59 = v58;
                *(unsigned char *)v60 = *(unsigned char *)v58;
                BOOL v61 = v36 < (char *)v94 - (char *)v58;
                v62 = (char *)&v90 + v36 - ((char *)v94 - (char *)v58);
                v58 = (long long *)((char *)v58 + v36);
                if (!v61) {
                  v58 = (long long *)v62;
                }
              }
              while (v58 != v55);
              *(unsigned char *)v59 = v56;
            }
            while (v55 != &v90);
          }
          goto LABEL_82;
        }
        unint64_t v48 = v38 | 7;
        if (55 - v38 < (v38 | 7uLL)) {
          unint64_t v48 = 55 - v38;
        }
        v49 = (char *)&v90;
        if (&v90 < (long long *)((char *)&v90 + v38 + v48 + 9))
        {
          uint64_t v50 = v36;
          if (v39 < (char *)&v90 + v48 + 1) {
            goto LABEL_60;
          }
        }
        if (v48 >= 0x1F)
        {
          unint64_t v64 = v48 + 1;
          uint64_t v63 = (v48 + 1) & 0x60;
          v65 = (long long *)((char *)&v90 + v36);
          long long v66 = v90;
          long long v67 = v91;
          long long v68 = *(long long *)((char *)&v90 + v36 + 16);
          long long v90 = *(long long *)((char *)&v90 + v36);
          long long v91 = v68;
          _OWORD *v65 = v66;
          v65[1] = v67;
          if (v63 != 32)
          {
            v69 = (long long *)((char *)&v92 + v36);
            long long v70 = v92;
            long long v71 = v93;
            long long v72 = *(long long *)((char *)&v92 + v36 + 16);
            long long v92 = *(long long *)((char *)&v92 + v36);
            long long v93 = v72;
            _OWORD *v69 = v70;
            v69[1] = v71;
          }
          if (v64 == v63) {
            goto LABEL_82;
          }
          if ((v64 & 0x18) == 0)
          {
            v49 = (char *)&v90 + v63;
            uint64_t v50 = v36 + v63;
LABEL_60:
            v51 = v49 + 1;
            do
            {
              char v52 = *(v51 - 1);
              *(v51 - 1) = *((unsigned char *)&v90 + v50);
              *((unsigned char *)&v90 + v50) = v52;
              if (v51 == v39) {
                break;
              }
              ++v51;
            }
            while (v50++ != 63);
            goto LABEL_82;
          }
        }
        else
        {
          uint64_t v63 = 0;
        }
        v73 = (uint64_t *)((char *)&v90 + v63);
        uint64_t v74 = v48 - v63 + 1;
        do
        {
          uint64_t v75 = *v73;
          uint64_t *v73 = v73[(unint64_t)v36 / 8];
          v73[(unint64_t)v36 / 8] = v75;
          ++v73;
          v74 -= 8;
        }
        while (v74);
      }
LABEL_82:
      unint64_t v76 = v21 + v26 + v22 + *((void *)&v90 + 1);
      unint64_t v21 = *((void *)&v92 + 1) + v26 - 0x4B6D499041670D8DLL * __ROR8__(v21 + v25 + v93, 42);
      unint64_t v77 = v20 + v31;
      uint64_t v78 = v90 - 0x4B6D499041670D8DLL * v25;
      uint64_t v79 = v78 + *((void *)&v90 + 1) + v91;
      unint64_t v20 = (0xB492B66FBE98F273 * __ROR8__(v76, 37)) ^ v30;
      uint64_t v25 = __ROR8__(v79, 44) + v78 + __ROR8__(v20 + v31 + v78 + *((void *)&v91 + 1), 21);
      unint64_t v22 = 0xB492B66FBE98F273 * __ROR8__(v77, 33);
      unint64_t v80 = v22 + v30 + v92;
      unint64_t v81 = *((void *)&v92 + 1) + v93 + v80;
      uint64_t v26 = v79 + *((void *)&v91 + 1);
      unint64_t v30 = __ROR8__(v21 + v91 + v80 + *((void *)&v93 + 1), 21) + v80 + __ROR8__(v81, 44);
      unint64_t v31 = v81 + *((void *)&v93 + 1);
      v32 += v36;
      if (a1 == a3 && a2 == a4) {
        goto LABEL_27;
      }
    }
  }
  unint64_t v32 = 64;
LABEL_27:
  unint64_t v33 = 0x9DDFEA08EB382D69
      * (v30 ^ ((0x9DDFEA08EB382D69 * (v25 ^ v30)) >> 47) ^ (0x9DDFEA08EB382D69 * (v25 ^ v30)));
  uint64_t v34 = v22 - 0x4B6D499041670D8DLL * (v32 ^ (v32 >> 47)) - 0x622015F714C7D297 * (v33 ^ (v33 >> 47));
  unint64_t v35 = 0x9DDFEA08EB382D69
      * (v34 ^ (v20
              - 0x4B6D499041670D8DLL * (v21 ^ (v21 >> 47))
              - 0x622015F714C7D297
              * ((0x9DDFEA08EB382D69
                * (v31 ^ ((0x9DDFEA08EB382D69 * (v26 ^ v31)) >> 47) ^ (0x9DDFEA08EB382D69 * (v26 ^ v31)))) ^ ((0x9DDFEA08EB382D69 * (v31 ^ ((0x9DDFEA08EB382D69 * (v26 ^ v31)) >> 47) ^ (0x9DDFEA08EB382D69 * (v26 ^ v31)))) >> 47))));
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v34 ^ (v35 >> 47) ^ v35)) ^ ((0x9DDFEA08EB382D69 * (v34 ^ (v35 >> 47) ^ v35)) >> 47));
}

_OWORD *llvm::DenseMap<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>,llvm::DenseMapInfo<mlir::SuccessorRange,void>,llvm::detail::DenseMapPair<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = llvm::allocate_buffer(40 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    uint64_t v10 = 40 * v3;
    llvm::DenseMapBase<llvm::DenseMap<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>,llvm::DenseMapInfo<mlir::SuccessorRange,void>,llvm::detail::DenseMapPair<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>>>,mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>,llvm::DenseMapInfo<mlir::SuccessorRange,void>,llvm::detail::DenseMapPair<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>>>::moveFromOldBuckets(a1, (uint64_t)v4, (uint64_t)v4 + v10);
    llvm::deallocate_buffer(v4, (void *)v10);
  }
  *(void *)(a1 + 8) = 0;
  unsigned int v11 = *(_DWORD *)(a1 + 16);
  if (v11)
  {
    unint64_t v12 = 40 * v11 - 40;
    if (v12 < 0x28)
    {
      unint64_t v13 = result;
LABEL_14:
      unint64_t v17 = (_OWORD *)((char *)result + 40 * v11);
      do
      {
        *unint64_t v13 = xmmword_181100030;
        unint64_t v13 = (_OWORD *)((char *)v13 + 40);
      }
      while (v13 != v17);
      return result;
    }
    unint64_t v14 = v12 / 0x28 + 1;
    unint64_t v13 = (_OWORD *)((char *)result + 40 * (v14 & 0xFFFFFFFFFFFFFFELL));
    uint64_t v15 = v14 & 0xFFFFFFFFFFFFFFELL;
    uint64_t v16 = result;
    do
    {
      *uint64_t v16 = xmmword_181100030;
      *(_OWORD *)((char *)v16 + 40) = xmmword_181100030;
      v16 += 5;
      v15 -= 2;
    }
    while (v15);
    if (v14 != (v14 & 0xFFFFFFFFFFFFFFELL)) {
      goto LABEL_14;
    }
  }
  return result;
}

void llvm::DenseMapBase<llvm::DenseMap<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>,llvm::DenseMapInfo<mlir::SuccessorRange,void>,llvm::detail::DenseMapPair<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>>>,mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>,llvm::DenseMapInfo<mlir::SuccessorRange,void>,llvm::detail::DenseMapPair<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>>>::moveFromOldBuckets(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  *(void *)(a1 + 8) = 0;
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (v6)
  {
    uint64_t v7 = *(void *)a1;
    unint64_t v8 = 40 * v6 - 40;
    if (v8 < 0x28)
    {
      uint64_t v9 = *(_OWORD **)a1;
LABEL_7:
      unint64_t v13 = (_OWORD *)(v7 + 40 * v6);
      do
      {
        *uint64_t v9 = xmmword_181100030;
        uint64_t v9 = (_OWORD *)((char *)v9 + 40);
      }
      while (v9 != v13);
      goto LABEL_9;
    }
    unint64_t v10 = v8 / 0x28 + 1;
    uint64_t v9 = (_OWORD *)(v7 + 40 * (v10 & 0xFFFFFFFFFFFFFFELL));
    uint64_t v11 = v10 & 0xFFFFFFFFFFFFFFELL;
    unint64_t v12 = *(_OWORD **)a1;
    do
    {
      *unint64_t v12 = xmmword_181100030;
      *(_OWORD *)((char *)v12 + 40) = xmmword_181100030;
      v12 += 5;
      v11 -= 2;
    }
    while (v11);
    if (v10 != (v10 & 0xFFFFFFFFFFFFFFELL)) {
      goto LABEL_7;
    }
  }
LABEL_9:
  if (a2 != a3)
  {
    do
    {
      if ((*(void *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        unint64_t v17 = 0;
        llvm::DenseMapBase<llvm::DenseMap<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>,llvm::DenseMapInfo<mlir::SuccessorRange,void>,llvm::detail::DenseMapPair<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>>>,mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>,llvm::DenseMapInfo<mlir::SuccessorRange,void>,llvm::detail::DenseMapPair<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>>>::LookupBucketFor<mlir::SuccessorRange>((uint64_t *)a1, (uint64_t *)v4, &v17);
        unint64_t v14 = v17;
        *unint64_t v17 = *(_OWORD *)v4;
        *((void *)v14 + 3) = 0x100000000;
        *((void *)v14 + 2) = v14 + 2;
        uint64_t v15 = (uint64_t)(v14 + 1);
        if (*(_DWORD *)(v4 + 24)) {
          llvm::SmallVectorImpl<llvm::SMLoc>::operator=(v15, v4 + 16);
        }
        ++*(_DWORD *)(a1 + 8);
        uint64_t v16 = *(void **)(v4 + 16);
        if ((void *)(v4 + 32) != v16) {
          free(v16);
        }
      }
      v4 += 40;
    }
    while (v4 != a3);
  }
}

uint64_t mlir::OperationEquivalence::ignoreValueEquivalence()
{
  return 1;
}

uint64_t llvm::function_ref<mlir::LogicalResult ()(mlir::Value,mlir::Value)>::callback_fn<mlir::LogicalResult ()(mlir::Value,mlir::Value)>(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  return a1(a2, a3);
}

uint64_t ableToUpdatePredOperands(mlir::Block *a1)
{
  v1 = *(void **)a1;
  if (*(void *)a1)
  {
    while (1)
    {
      uint64_t v3 = (mlir::GenericProgramPoint **)mlir::PredecessorIterator::unwrap((uint64_t)v1);
      mlir::Block::getTerminator(v3);
      uint64_t v5 = *(void *)(v4 + 48);
      unsigned int v6 = *(void **)(v5 + 16);
      BOOL v7 = v6 == &mlir::detail::TypeIDResolver<void,void>::id;
      uint64_t v8 = v6 == &mlir::detail::TypeIDResolver<void,void>::id ? 0 : *(void *)(v4 + 48);
      if (v7) {
        break;
      }
      uint64_t v9 = v4;
      unint64_t v10 = v8 | v5 & 0xFFFFFFFFFFFFFF00;
      if (!mlir::detail::InterfaceMap::lookup<mlir::BranchOpInterface>(v10 + 32))
      {
        uint64_t result = *(void *)(v10 + 24);
        uint64_t v11 = *(void *)(v9 + 48);
LABEL_3:
        uint64_t result = mlir::Dialect::getRegisteredInterfaceForOp<mlir::BranchOpInterface>(result, v11);
        if (!result) {
          return result;
        }
      }
      v1 = (void *)*v1;
      if (!v1) {
        return 1;
      }
    }
    uint64_t v12 = *(void *)(v5 + 8);
    uint64_t result = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v12);
    if (!result) {
      return result;
    }
    uint64_t v11 = v5;
    goto LABEL_3;
  }
  return 1;
}

void anonymous namespace'::BlockMergeCluster::merge(mlir::RewriterBase &)::$_0::operator()(void **a1, mlir::BlockOperand *a2, unsigned int a3)
{
  v23[3] = *MEMORY[0x1E4F143B8];
  unint64_t v17 = (mlir::BlockOperand **)a2;
  for (i = mlir::PredecessorIterator::unwrap; a2; unint64_t v17 = (mlir::BlockOperand **)a2)
  {
    uint64_t v5 = (mlir::GenericProgramPoint **)i((uint64_t)a2);
    mlir::Block::getTerminator(v5);
    uint64_t v7 = Values;
    if (Values)
    {
      uint64_t v8 = *(void *)(Values + 48);
      uint64_t v9 = *(void **)(v8 + 16);
      BOOL v10 = v9 == &mlir::detail::TypeIDResolver<void,void>::id;
      if (v9 == &mlir::detail::TypeIDResolver<void,void>::id) {
        uint64_t v11 = 0;
      }
      else {
        uint64_t v11 = *(void *)(Values + 48);
      }
      if (v10)
      {
        uint64_t v20 = *(void *)(v8 + 8);
        uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v20);
        if (Values)
        {
          uint64_t v13 = v8;
          goto LABEL_13;
        }
      }
      else
      {
        unint64_t v12 = v11 | v8 & 0xFFFFFFFFFFFFFF00;
        uint64_t Values = mlir::detail::InterfaceMap::lookup<mlir::BranchOpInterface>(v12 + 32);
        if (!Values)
        {
          uint64_t Values = *(void *)(v12 + 24);
          uint64_t v13 = *(void *)(v7 + 48);
LABEL_13:
          uint64_t Values = mlir::Dialect::getRegisteredInterfaceForOp<mlir::BranchOpInterface>(Values, v13);
        }
      }
    }
    v16[0] = v7;
    v16[1] = Values;
    unint64_t SuccessorIndex = mlir::PredecessorIterator::getSuccessorIndex((mlir::BlockOperand **)&v17);
    mlir::BranchOpInterface::getSuccessorOperands((mlir::BranchOpInterface *)v16, SuccessorIndex);
    uint64_t v15 = **a1 + 80 * a3;
    mlir::ValueRange::ValueRange(v19, *(void *)v15, *(unsigned int *)(v15 + 8));
    mlir::MutableOperandRange::append((uint64_t)&v21, v19[0], v19[1]);
    if (v22 != v23) {
      free(v22);
    }
    a2 = *v17;
  }
}

void llvm::SmallVectorImpl<llvm::SmallVector<mlir::Value,8u>>::assign(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (*(unsigned int *)(a1 + 12) < a2)
  {
    llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::Value,8u>,false>::growAndAssign(a1, a2, a3);
    return;
  }
  unint64_t v6 = *(unsigned int *)(a1 + 8);
  if (v6 >= a2) {
    unint64_t v7 = a2;
  }
  else {
    unint64_t v7 = *(unsigned int *)(a1 + 8);
  }
  if (v7)
  {
    uint64_t v8 = *(void *)a1;
    while (1)
    {
      if (v8 == a3) {
        goto LABEL_11;
      }
      unint64_t v9 = *(unsigned int *)(a3 + 8);
      uint64_t v10 = *(unsigned int *)(v8 + 8);
      if (v10 >= v9)
      {
        if (v9) {
          memmove(*(void **)v8, *(const void **)a3, 8 * v9);
        }
        goto LABEL_10;
      }
      if (*(_DWORD *)(v8 + 12) >= v9)
      {
        if (v10)
        {
          memmove(*(void **)v8, *(const void **)a3, 8 * v10);
          uint64_t v11 = *(unsigned int *)(a3 + 8);
          if (v10 != v11) {
            goto LABEL_23;
          }
        }
        else
        {
          uint64_t v10 = 0;
          uint64_t v11 = *(unsigned int *)(a3 + 8);
          if (*(_DWORD *)(a3 + 8)) {
LABEL_23:
          }
            memcpy((void *)(*(void *)v8 + 8 * v10), (const void *)(*(void *)a3 + 8 * v10), *(void *)a3 + 8 * v11 - (*(void *)a3 + 8 * v10));
        }
      }
      else
      {
        *(_DWORD *)(v8 + 8) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v8, (void *)(v8 + 16), v9, 8);
        uint64_t v10 = 0;
        uint64_t v11 = *(unsigned int *)(a3 + 8);
        if (*(_DWORD *)(a3 + 8)) {
          goto LABEL_23;
        }
      }
LABEL_10:
      *(_DWORD *)(v8 + 8) = v9;
LABEL_11:
      v8 += 80;
      if (!--v7)
      {
        unint64_t v6 = *(unsigned int *)(a1 + 8);
        break;
      }
    }
  }
  unint64_t v12 = v6 - a2;
  if (v6 < a2)
  {
    uint64_t v13 = (void *)(*(void *)a1 + 80 * v6);
    while (1)
    {
      uint64_t v16 = v13 + 2;
      *uint64_t v13 = v13 + 2;
      v13[1] = 0x800000000;
      if (v13 == (void *)a3) {
        goto LABEL_30;
      }
      unint64_t v17 = *(unsigned int *)(a3 + 8);
      if (!*(_DWORD *)(a3 + 8)) {
        goto LABEL_30;
      }
      if (v17 < 9)
      {
        uint64_t v14 = *(unsigned int *)(a3 + 8);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v13, v13 + 2, *(unsigned int *)(a3 + 8), 8);
        uint64_t v14 = *(unsigned int *)(a3 + 8);
        if (!v14) {
          goto LABEL_29;
        }
        uint64_t v16 = (void *)*v13;
      }
      memcpy(v16, *(const void **)a3, 8 * v14);
LABEL_29:
      *((_DWORD *)v13 + 2) = v17;
LABEL_30:
      v13 += 10;
      if (__CFADD__(v12++, 1)) {
        goto LABEL_41;
      }
    }
  }
  if (v6 > a2)
  {
    uint64_t v18 = 80 * v6;
    unint64_t v19 = (void **)(v18 + *(void *)a1 - 80);
    unint64_t v20 = 80 * a2 - v18;
    do
    {
      if (v19 + 2 != *v19) {
        free(*v19);
      }
      v19 -= 10;
      v20 += 80;
    }
    while (v20);
  }
LABEL_41:
  *(_DWORD *)(a1 + 8) = a2;
}

void llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::Value,8u>,false>::growAndAssign(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v19 = 0;
  unint64_t v6 = (char *)(a1 + 16);
  unint64_t v7 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), a2, 80, &v19);
  uint64_t v8 = v7;
  if (a2)
  {
    unint64_t v9 = v7;
    for (unint64_t i = a2; i; --i)
    {
      unint64_t v12 = v9 + 2;
      *unint64_t v9 = v9 + 2;
      v9[1] = 0x800000000;
      if (v9 == (void *)a3) {
        goto LABEL_6;
      }
      unint64_t v13 = *(unsigned int *)(a3 + 8);
      if (!*(_DWORD *)(a3 + 8)) {
        goto LABEL_6;
      }
      if (v13 < 9)
      {
        uint64_t v11 = *(unsigned int *)(a3 + 8);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v9, v9 + 2, *(unsigned int *)(a3 + 8), 8);
        uint64_t v11 = *(unsigned int *)(a3 + 8);
        if (!v11) {
          goto LABEL_5;
        }
        unint64_t v12 = (void *)*v9;
      }
      memcpy(v12, *(const void **)a3, 8 * v11);
LABEL_5:
      *((_DWORD *)v9 + 2) = v13;
LABEL_6:
      v9 += 10;
    }
  }
  uint64_t v14 = *(char **)a1;
  uint64_t v15 = *(unsigned int *)(a1 + 8);
  if (v15)
  {
    uint64_t v16 = 80 * v15;
    do
    {
      unint64_t v17 = *(char **)&v14[v16 - 80];
      if (&v14[v16 - 64] != v17) {
        free(v17);
      }
      v16 -= 80;
    }
    while (v16);
    uint64_t v14 = *(char **)a1;
  }
  int v18 = v19;
  if (v14 != v6) {
    free(v14);
  }
  *(void *)a1 = v8;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = v18;
}

void *llvm::df_iterator<mlir::Block *,llvm::df_iterator_default_set<mlir::Block *,16u>,true,llvm::GraphTraits<mlir::Block *>>::df_iterator(void *a1, void *a2, llvm::SmallPtrSetImplBase *this)
{
  a1[1] = 0;
  uint64_t v5 = a1 + 1;
  *a1 = this;
  a1[2] = 0;
  a1[3] = 0;
  uint64_t v6 = *((void *)this + 1);
  if (v6 != *(void *)this) {
    goto LABEL_2;
  }
  uint64_t v11 = *((unsigned int *)this + 5);
  if (!v11)
  {
LABEL_22:
    if (v11 < *((_DWORD *)this + 4))
    {
      *((_DWORD *)this + 5) = v11 + 1;
      *(void *)(v6 + 8 * v11) = a2;
LABEL_3:
      unint64_t v9 = (unsigned char *)a1[2];
      unint64_t v8 = a1[3];
      if ((unint64_t)v9 >= v8)
      {
        uint64_t v15 = (unsigned char *)*v5;
        uint64_t v16 = (uint64_t)&v9[-*v5] >> 5;
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 59) {
          abort();
        }
        uint64_t v18 = v8 - (void)v15;
        if (v18 >> 4 > v17) {
          unint64_t v17 = v18 >> 4;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v19 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          if (v19 >> 59) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          unint64_t v20 = (char *)operator new(32 * v19);
        }
        else
        {
          unint64_t v20 = 0;
        }
        uint64_t v21 = &v20[32 * v16];
        *(void *)uint64_t v21 = a2;
        v21[8] = 0;
        v21[24] = 0;
        uint64_t v10 = v21 + 32;
        if (v9 != v15)
        {
          do
          {
            long long v22 = *((_OWORD *)v9 - 1);
            *((_OWORD *)v21 - 2) = *((_OWORD *)v9 - 2);
            *((_OWORD *)v21 - 1) = v22;
            v21 -= 32;
            v9 -= 32;
          }
          while (v9 != v15);
          unint64_t v9 = (unsigned char *)*v5;
        }
        a1[1] = v21;
        a1[2] = v10;
        a1[3] = &v20[32 * v19];
        if (v9) {
          operator delete(v9);
        }
      }
      else
      {
        *(void *)unint64_t v9 = a2;
        v9[8] = 0;
        uint64_t v10 = v9 + 32;
        v9[24] = 0;
      }
      a1[2] = v10;
      return a1;
    }
LABEL_2:
    llvm::SmallPtrSetImplBase::insert_imp_big(this, a2);
    if (!v7) {
      return a1;
    }
    goto LABEL_3;
  }
  unint64_t v12 = 0;
  uint64_t v13 = 8 * v11;
  uint64_t v14 = (void *)*((void *)this + 1);
  while ((void *)*v14 != a2)
  {
    if (*v14 == -2) {
      unint64_t v12 = v14;
    }
    ++v14;
    v13 -= 8;
    if (!v13)
    {
      if (!v12) {
        goto LABEL_22;
      }
      *unint64_t v12 = a2;
      --*((_DWORD *)this + 6);
      goto LABEL_3;
    }
  }
  return a1;
}

void llvm::df_iterator<mlir::Block *,llvm::df_iterator_default_set<mlir::Block *,16u>,true,llvm::GraphTraits<mlir::Block *>>::toNext(llvm::SmallPtrSetImplBase **a1)
{
  uint64_t v2 = (uint64_t)a1[2];
  while (2)
  {
    uint64_t v3 = *(mlir::Block **)(v2 - 32);
    if (!*(unsigned char *)(v2 - 8))
    {
      mlir::SuccessorRange::SuccessorRange((mlir::SuccessorRange *)v28, *(mlir::Block **)(v2 - 32));
      *(void *)(v2 - 24) = v28[0];
      *(void *)(v2 - 16) = 0;
      *(unsigned char *)(v2 - 8) = 1;
    }
    while (1)
    {
      mlir::SuccessorRange::SuccessorRange((mlir::SuccessorRange *)v28, v3);
      uint64_t v6 = *(void *)(v2 - 24);
      uint64_t v7 = *(void *)(v2 - 16);
      if (v6 == v28[0] && v7 == v28[1]) {
        break;
      }
      *(void *)(v2 - 16) = v7 + 1;
      unint64_t v9 = *(const void **)(v6 + 32 * v7 + 24);
      uint64_t v10 = *a1;
      uint64_t v11 = *((void *)*a1 + 1);
      if (v11 != *(void *)*a1) {
        goto LABEL_4;
      }
      uint64_t v12 = *((unsigned int *)v10 + 5);
      if (v12)
      {
        uint64_t v13 = 0;
        uint64_t v14 = 8 * v12;
        uint64_t v15 = (void *)*((void *)*a1 + 1);
        do
        {
          if ((const void *)*v15 == v9)
          {
            int v5 = 0;
            goto LABEL_5;
          }
          if (*v15 == -2) {
            uint64_t v13 = v15;
          }
          ++v15;
          v14 -= 8;
        }
        while (v14);
        if (!v13) {
          goto LABEL_19;
        }
        *uint64_t v13 = v9;
        --*((_DWORD *)v10 + 6);
        int v5 = 1;
        goto LABEL_5;
      }
LABEL_19:
      if (v12 < *((_DWORD *)v10 + 4))
      {
        *((_DWORD *)v10 + 5) = v12 + 1;
        *(void *)(v11 + 8 * v12) = v9;
        int v5 = 1;
      }
      else
      {
LABEL_4:
        llvm::SmallPtrSetImplBase::insert_imp_big(v10, v9);
        int v5 = v4;
      }
LABEL_5:
      if (v5)
      {
        uint64_t v18 = a1[2];
        unint64_t v17 = (unint64_t)a1[3];
        if ((unint64_t)v18 >= v17)
        {
          unint64_t v20 = a1[1];
          uint64_t v21 = (v18 - v20) >> 5;
          unint64_t v22 = v21 + 1;
          if ((unint64_t)(v21 + 1) >> 59) {
            abort();
          }
          uint64_t v23 = v17 - (void)v20;
          if (v23 >> 4 > v22) {
            unint64_t v22 = v23 >> 4;
          }
          if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v24 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v24 = v22;
          }
          if (v24)
          {
            if (v24 >> 59) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            uint64_t v25 = (char *)operator new(32 * v24);
          }
          else
          {
            uint64_t v25 = 0;
          }
          uint64_t v26 = &v25[32 * v21];
          *(void *)uint64_t v26 = v9;
          v26[8] = 0;
          v26[24] = 0;
          unint64_t v19 = (llvm::SmallPtrSetImplBase *)(v26 + 32);
          if (v18 != v20)
          {
            do
            {
              long long v27 = *((_OWORD *)v18 - 1);
              *((_OWORD *)v26 - 2) = *((_OWORD *)v18 - 2);
              *((_OWORD *)v26 - 1) = v27;
              v26 -= 32;
              uint64_t v18 = (llvm::SmallPtrSetImplBase *)((char *)v18 - 32);
            }
            while (v18 != v20);
            uint64_t v18 = a1[1];
          }
          a1[1] = (llvm::SmallPtrSetImplBase *)v26;
          a1[2] = v19;
          a1[3] = (llvm::SmallPtrSetImplBase *)&v25[32 * v24];
          if (v18) {
            operator delete(v18);
          }
        }
        else
        {
          *(void *)uint64_t v18 = v9;
          *((unsigned char *)v18 + 8) = 0;
          unint64_t v19 = (llvm::SmallPtrSetImplBase *)((char *)v18 + 32);
          *((unsigned char *)v18 + 24) = 0;
        }
        a1[2] = v19;
        return;
      }
    }
    uint64_t v16 = a1[1];
    uint64_t v2 = (uint64_t)a1[2] - 32;
    a1[2] = (llvm::SmallPtrSetImplBase *)v2;
    if (v16 != (llvm::SmallPtrSetImplBase *)v2) {
      continue;
    }
    break;
  }
}

uint64_t mlir::OffsetSizeAndStrideOpInterface::getMixedOffsets(mlir::OffsetSizeAndStrideOpInterface *this)
{
  return (*(uint64_t (**)(void, void))(*((void *)this + 1) + 64))(*((void *)this + 1), *(void *)this);
}

uint64_t mlir::OffsetSizeAndStrideOpInterface::getMixedSizes(mlir::OffsetSizeAndStrideOpInterface *this)
{
  return (*(uint64_t (**)(void, void))(*((void *)this + 1) + 72))(*((void *)this + 1), *(void *)this);
}

uint64_t mlir::OffsetSizeAndStrideOpInterface::getMixedStrides(mlir::OffsetSizeAndStrideOpInterface *this)
{
  return (*(uint64_t (**)(void, void))(*((void *)this + 1) + 80))(*((void *)this + 1), *(void *)this);
}

uint64_t mlir::OffsetSizeAndStrideOpInterface::getDynamicSize(mlir::OffsetSizeAndStrideOpInterface *this, uint64_t a2)
{
  return (*(uint64_t (**)(void, void, uint64_t))(*((void *)this + 1) + 168))(*((void *)this + 1), *(void *)this, a2);
}

uint64_t mlir::verifyListOfOperandsOrIntegers(uint64_t *a1, const void **a2, const char *a3, unsigned int a4, int64x2_t *a5, const char *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v105 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = (const char *)a4;
  if (a6 == (const char *)a4)
  {
    if (!a6)
    {
      unsigned int v13 = 0;
      goto LABEL_36;
    }
    unint64_t v12 = (unint64_t)(a6 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v12 >= 3)
    {
      unint64_t v42 = v12 + 1;
      uint64_t v43 = (v12 + 1) & 0x3FFFFFFFFFFFFFFCLL;
      uint64_t v14 = &a5->i64[v43];
      uint64_t v44 = a5 + 1;
      int64x2_t v45 = 0uLL;
      int64x2_t v46 = vdupq_n_s64(0x8000000000000000);
      uint64_t v47 = v43;
      int64x2_t v48 = 0uLL;
      do
      {
        int64x2_t v45 = vsubq_s64(v45, vceqq_s64(v44[-1], v46));
        int64x2_t v48 = vsubq_s64(v48, vceqq_s64(*v44, v46));
        v44 += 2;
        v47 -= 4;
      }
      while (v47);
      unsigned int v13 = vaddvq_s64(vaddq_s64(v48, v45));
      if (v42 == v43) {
        goto LABEL_36;
      }
    }
    else
    {
      unsigned int v13 = 0;
      uint64_t v14 = (uint64_t *)a5;
    }
    do
    {
      uint64_t v49 = *v14++;
      if (v49 == 0x8000000000000000) {
        ++v13;
      }
    }
    while (v14 != (uint64_t *)((char *)a5 + 8 * (void)a6));
LABEL_36:
    uint64_t v50 = (const char *)v13;
    if (a8 == v13) {
      return 1;
    }
    v88[0] = "expected ";
    __int16 v89 = 259;
    mlir::Operation::emitError(a1, (uint64_t)v88, (uint64_t)&v94);
    if (v94)
    {
      LODWORD(v90) = 5;
      long long v91 = v50;
      v51 = &v90;
      char v52 = (char *)v96;
      if (v97 >= v98)
      {
        unint64_t v74 = v97 + 1;
        if (v96 <= &v90 && (char *)v96 + 24 * v97 > (char *)&v90)
        {
          int64_t v83 = (char *)&v90 - (unsigned char *)v96;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v74, 24);
          char v52 = (char *)v96;
          v51 = (const void ***)((char *)v96 + v83);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v74, 24);
          v51 = &v90;
          char v52 = (char *)v96;
        }
      }
      v53 = &v52[24 * v97];
      long long v54 = *(_OWORD *)v51;
      *((void *)v53 + 2) = v51[2];
      *(_OWORD *)v53 = v54;
      uint64_t v55 = ++v97;
      if (v94)
      {
        LODWORD(v90) = 3;
        long long v91 = " dynamic ";
        uint64_t v92 = 9;
        char v56 = &v90;
        char v57 = (char *)v96;
        if (v55 >= v98)
        {
          unint64_t v75 = v55 + 1;
          BOOL v76 = (char *)v96 + 24 * v55 > (char *)&v90;
          if (v96 <= &v90 && v76)
          {
            int64_t v84 = (char *)&v90 - (unsigned char *)v96;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v75, 24);
            char v57 = (char *)v96;
            char v56 = (const void ***)((char *)v96 + v84);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v75, 24);
            char v56 = &v90;
            char v57 = (char *)v96;
          }
        }
        v58 = &v57[24 * v97];
        long long v59 = *(_OWORD *)v56;
        *((void *)v58 + 2) = v56[2];
        *(_OWORD *)v58 = v59;
        ++v97;
        if (v94)
        {
          __int16 v93 = 261;
          long long v90 = a2;
          long long v91 = a3;
          mlir::Diagnostic::operator<<((uint64_t)v95, &v90);
          if (v94)
          {
            LODWORD(v90) = 3;
            long long v91 = " values";
            uint64_t v92 = 7;
            v60 = &v90;
            BOOL v61 = (char *)v96;
            if (v97 >= v98)
            {
              unint64_t v80 = v97 + 1;
              if (v96 <= &v90 && (char *)v96 + 24 * v97 > (char *)&v90)
              {
                int64_t v87 = (char *)&v90 - (unsigned char *)v96;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v80, 24);
                BOOL v61 = (char *)v96;
                v60 = (const void ***)((char *)v96 + v87);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v80, 24);
                v60 = &v90;
                BOOL v61 = (char *)v96;
              }
            }
            v62 = &v61[24 * v97];
            long long v63 = *(_OWORD *)v60;
            *((void *)v62 + 2) = v60[2];
            *(_OWORD *)v62 = v63;
            ++v97;
          }
        }
      }
    }
    uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v94);
    if (v94) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v94);
    }
    if (v104)
    {
      unint64_t v64 = (void **)__p;
      if (__p)
      {
        v65 = v103;
        long long v66 = __p;
        if (v103 != __p)
        {
          do
            v65 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v65 - 1);
          while (v65 != v64);
          long long v66 = __p;
        }
        v103 = v64;
        operator delete(v66);
      }
      uint64_t v37 = v100;
      if (!v100) {
        goto LABEL_62;
      }
      long long v67 = v101;
      uint64_t v39 = v100;
      if (v101 == v100)
      {
LABEL_61:
        v101 = v37;
        operator delete(v39);
LABEL_62:
        if (v96 != v99) {
          free(v96);
        }
        return v33;
      }
      do
      {
        v69 = (void *)*--v67;
        long long v68 = v69;
        *long long v67 = 0;
        if (v69) {
          operator delete[](v68);
        }
      }
      while (v67 != v37);
LABEL_60:
      uint64_t v39 = v100;
      goto LABEL_61;
    }
    return v33;
  }
  v88[0] = "expected ";
  __int16 v89 = 259;
  mlir::Operation::emitError(a1, (uint64_t)v88, (uint64_t)&v94);
  if (v94)
  {
    LODWORD(v90) = 5;
    long long v91 = v11;
    uint64_t v15 = &v90;
    uint64_t v16 = (char *)v96;
    if (v97 >= v98)
    {
      unint64_t v71 = v97 + 1;
      if (v96 <= &v90 && (char *)v96 + 24 * v97 > (char *)&v90)
      {
        int64_t v81 = (char *)&v90 - (unsigned char *)v96;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v71, 24);
        uint64_t v16 = (char *)v96;
        uint64_t v15 = (const void ***)((char *)v96 + v81);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v71, 24);
        uint64_t v15 = &v90;
        uint64_t v16 = (char *)v96;
      }
    }
    unint64_t v17 = &v16[24 * v97];
    long long v18 = *(_OWORD *)v15;
    *((void *)v17 + 2) = v15[2];
    *(_OWORD *)unint64_t v17 = v18;
    uint64_t v19 = ++v97;
    if (v94)
    {
      LODWORD(v90) = 3;
      long long v91 = " ";
      uint64_t v92 = 1;
      unint64_t v20 = &v90;
      uint64_t v21 = (char *)v96;
      if (v19 >= v98)
      {
        unint64_t v72 = v19 + 1;
        BOOL v73 = (char *)v96 + 24 * v19 > (char *)&v90;
        if (v96 <= &v90 && v73)
        {
          int64_t v82 = (char *)&v90 - (unsigned char *)v96;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v72, 24);
          uint64_t v21 = (char *)v96;
          unint64_t v20 = (const void ***)((char *)v96 + v82);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v72, 24);
          unint64_t v20 = &v90;
          uint64_t v21 = (char *)v96;
        }
      }
      unint64_t v22 = &v21[24 * v97];
      long long v23 = *(_OWORD *)v20;
      *((void *)v22 + 2) = v20[2];
      *(_OWORD *)unint64_t v22 = v23;
      ++v97;
      if (v94)
      {
        __int16 v93 = 261;
        long long v90 = a2;
        long long v91 = a3;
        mlir::Diagnostic::operator<<((uint64_t)v95, &v90);
        if (v94)
        {
          LODWORD(v90) = 3;
          long long v91 = " values, got ";
          uint64_t v92 = 13;
          unint64_t v24 = &v90;
          uint64_t v25 = (char *)v96;
          if (v97 >= v98)
          {
            unint64_t v77 = v97 + 1;
            if (v96 <= &v90 && (char *)v96 + 24 * v97 > (char *)&v90)
            {
              int64_t v85 = (char *)&v90 - (unsigned char *)v96;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v77, 24);
              uint64_t v25 = (char *)v96;
              unint64_t v24 = (const void ***)((char *)v96 + v85);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v77, 24);
              unint64_t v24 = &v90;
              uint64_t v25 = (char *)v96;
            }
          }
          uint64_t v26 = &v25[24 * v97];
          long long v27 = *(_OWORD *)v24;
          *((void *)v26 + 2) = v24[2];
          *(_OWORD *)uint64_t v26 = v27;
          uint64_t v28 = ++v97;
          if (v94)
          {
            LODWORD(v90) = 5;
            long long v91 = a6;
            unint64_t v29 = &v90;
            unint64_t v30 = (char *)v96;
            if (v28 >= v98)
            {
              unint64_t v78 = v28 + 1;
              BOOL v79 = (char *)v96 + 24 * v28 > (char *)&v90;
              if (v96 <= &v90 && v79)
              {
                int64_t v86 = (char *)&v90 - (unsigned char *)v96;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v78, 24);
                unint64_t v30 = (char *)v96;
                unint64_t v29 = (const void ***)((char *)v96 + v86);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v78, 24);
                unint64_t v29 = &v90;
                unint64_t v30 = (char *)v96;
              }
            }
            unint64_t v31 = &v30[24 * v97];
            long long v32 = *(_OWORD *)v29;
            *((void *)v31 + 2) = v29[2];
            *(_OWORD *)unint64_t v31 = v32;
            ++v97;
          }
        }
      }
    }
  }
  uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v94);
  if (v94) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v94);
  }
  if (v104)
  {
    uint64_t v34 = (void **)__p;
    if (__p)
    {
      unint64_t v35 = v103;
      uint64_t v36 = __p;
      if (v103 != __p)
      {
        do
          unint64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        uint64_t v36 = __p;
      }
      v103 = v34;
      operator delete(v36);
    }
    uint64_t v37 = v100;
    if (!v100) {
      goto LABEL_62;
    }
    uint64_t v38 = v101;
    uint64_t v39 = v100;
    if (v101 == v100) {
      goto LABEL_61;
    }
    do
    {
      uint64_t v41 = (void *)*--v38;
      uint64_t v40 = v41;
      *uint64_t v38 = 0;
      if (v41) {
        operator delete[](v40);
      }
    }
    while (v38 != v37);
    goto LABEL_60;
  }
  return v33;
}

uint64_t mlir::detail::verifyOffsetSizeAndStrideOp(uint64_t *a1, uint64_t a2)
{
  uint64_t v158 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t *))(a2 + 8))(a2, a1);
  unsigned int v6 = v5;
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t *))(a2 + 64))(&v139, a2, a1);
  if (v140 == 1 && v4 == 1)
  {
    BOOL v9 = 0;
  }
  else
  {
    (*(void (**)(char **__return_ptr, uint64_t, uint64_t *))(a2 + 64))(&v154, a2, a1);
    unsigned int v8 = v155;
    (*(void (**)(void **__return_ptr, uint64_t, uint64_t *))(a2 + 72))(&v151, a2, a1);
    BOOL v9 = v8 != v152;
    if (v151 != v153) {
      free(v151);
    }
    if (v154 != v156) {
      free(v154);
    }
  }
  if (v139 != &v141) {
    free(v139);
  }
  if (v9)
  {
    v131[0] = "expected mixed offsets rank to match mixed sizes rank (";
    __int16 v132 = 259;
    mlir::Operation::emitError(a1, (uint64_t)v131, (uint64_t)&v139);
    (*(void (**)(char **__return_ptr, uint64_t, uint64_t *))(a2 + 64))(&v154, a2, a1);
    if (v139)
    {
      LODWORD(v151) = 5;
      unint64_t v152 = v155;
      uint64_t v10 = (char *)&v151;
      uint64_t v11 = (char *)v142;
      if (v143 >= v144)
      {
        unint64_t v107 = v143 + 1;
        if (v142 <= &v151 && (char *)v142 + 24 * v143 > (char *)&v151)
        {
          int64_t v121 = (char *)&v151 - (unsigned char *)v142;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v107, 24);
          uint64_t v11 = (char *)v142;
          uint64_t v10 = (char *)v142 + v121;
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v107, 24);
          uint64_t v10 = (char *)&v151;
          uint64_t v11 = (char *)v142;
        }
      }
      unint64_t v12 = &v11[24 * v143];
      long long v13 = *(_OWORD *)v10;
      *((void *)v12 + 2) = *((void *)v10 + 2);
      *(_OWORD *)unint64_t v12 = v13;
      uint64_t v14 = ++v143;
      if (v139)
      {
        LODWORD(v151) = 3;
        unint64_t v152 = (unint64_t)" vs ";
        v153[0] = 4;
        uint64_t v15 = (char *)&v151;
        uint64_t v16 = (char *)v142;
        if (v14 >= v144)
        {
          unint64_t v109 = v14 + 1;
          BOOL v110 = (char *)v142 + 24 * v14 > (char *)&v151;
          if (v142 <= &v151 && v110)
          {
            int64_t v123 = (char *)&v151 - (unsigned char *)v142;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v109, 24);
            uint64_t v16 = (char *)v142;
            uint64_t v15 = (char *)v142 + v123;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v109, 24);
            uint64_t v15 = (char *)&v151;
            uint64_t v16 = (char *)v142;
          }
        }
        unint64_t v17 = &v16[24 * v143];
        long long v18 = *(_OWORD *)v15;
        *((void *)v17 + 2) = *((void *)v15 + 2);
        *(_OWORD *)unint64_t v17 = v18;
        ++v143;
      }
    }
    (*(void (**)(void **__return_ptr, uint64_t, uint64_t *))(a2 + 72))(&v151, a2, a1);
    if (v139)
    {
      int v133 = 5;
      unint64_t v134 = v152;
      uint64_t v19 = &v133;
      unint64_t v20 = (char *)v142;
      if (v143 >= v144)
      {
        unint64_t v108 = v143 + 1;
        if (v142 <= &v133 && (char *)v142 + 24 * v143 > (char *)&v133)
        {
          int64_t v122 = (char *)&v133 - (unsigned char *)v142;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v108, 24);
          unint64_t v20 = (char *)v142;
          uint64_t v19 = (int *)((char *)v142 + v122);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v108, 24);
          uint64_t v19 = &v133;
          unint64_t v20 = (char *)v142;
        }
      }
      uint64_t v21 = &v20[24 * v143];
      long long v22 = *(_OWORD *)v19;
      *((void *)v21 + 2) = *((void *)v19 + 2);
      *(_OWORD *)uint64_t v21 = v22;
      uint64_t v23 = ++v143;
      if (v139)
      {
        int v133 = 3;
        unint64_t v134 = (unint64_t)") so the rank of the result type is well-formed.";
        uint64_t v135 = 48;
        unint64_t v24 = &v133;
        uint64_t v25 = (char *)v142;
        if (v23 >= v144)
        {
          unint64_t v111 = v23 + 1;
          BOOL v112 = (char *)v142 + 24 * v23 > (char *)&v133;
          if (v142 <= &v133 && v112)
          {
            int64_t v124 = (char *)&v133 - (unsigned char *)v142;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v111, 24);
            uint64_t v25 = (char *)v142;
            unint64_t v24 = (int *)((char *)v142 + v124);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v111, 24);
            unint64_t v24 = &v133;
            uint64_t v25 = (char *)v142;
          }
        }
        uint64_t v26 = &v25[24 * v143];
        long long v27 = *(_OWORD *)v24;
        *((void *)v26 + 2) = *((void *)v24 + 2);
        *(_OWORD *)uint64_t v26 = v27;
        ++v143;
      }
    }
    uint64_t v28 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
    if (v151 != v153) {
      free(v151);
    }
    if (v154 != v156) {
      free(v154);
    }
    if (v139) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v139);
    }
    if (v150)
    {
      unint64_t v29 = (void **)__p;
      if (__p)
      {
        unint64_t v30 = v149;
        unint64_t v31 = __p;
        if (v149 != __p)
        {
          do
            unint64_t v30 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v30 - 1);
          while (v30 != v29);
          unint64_t v31 = __p;
        }
        v149 = v29;
        operator delete(v31);
      }
      long long v32 = v146;
      if (!v146) {
        goto LABEL_124;
      }
      uint64_t v33 = v147;
      uint64_t v34 = v146;
      if (v147 == v146)
      {
LABEL_123:
        v147 = v32;
        operator delete(v34);
LABEL_124:
        if (v142 != v145) {
          free(v142);
        }
        return v28;
      }
      do
      {
        uint64_t v36 = (void *)*--v33;
        unint64_t v35 = v36;
        *uint64_t v33 = 0;
        if (v36) {
          operator delete[](v35);
        }
      }
      while (v33 != v32);
LABEL_122:
      uint64_t v34 = v146;
      goto LABEL_123;
    }
  }
  else
  {
    (*(void (**)(void **__return_ptr, uint64_t, uint64_t *))(a2 + 72))(&v139, a2, a1);
    int v37 = v140;
    (*(void (**)(char **__return_ptr, uint64_t, uint64_t *))(a2 + 80))(&v154, a2, a1);
    unsigned int v38 = v155;
    if (v154 != v156) {
      free(v154);
    }
    if (v139 != &v141) {
      free(v139);
    }
    if (v37 == v38)
    {
      uint64_t v39 = (int64x2_t *)(*(uint64_t (**)(uint64_t, uint64_t *))(a2 + 40))(a2, a1);
      uint64_t v41 = v40;
      uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t *))(a2 + 16))(a2, a1);
      mlir::ValueRange::ValueRange(v138, v42, v43);
      if (!mlir::verifyListOfOperandsOrIntegers(a1, (const void **)"offset", (const char *)6, v4, v39, v41, v138[0], v138[1]))return 0; {
      uint64_t v44 = (int64x2_t *)(*(uint64_t (**)(uint64_t, uint64_t *))(a2 + 48))(a2, a1);
      }
      int64x2_t v46 = v45;
      uint64_t v47 = (*(uint64_t (**)(uint64_t, uint64_t *))(a2 + 24))(a2, a1);
      mlir::ValueRange::ValueRange(v137, v47, v48);
      if (!mlir::verifyListOfOperandsOrIntegers(a1, (const void **)"size", (const char *)4, HIDWORD(v4), v44, v46, v137[0], v137[1]))return 0; {
      uint64_t v49 = (int64x2_t *)(*(uint64_t (**)(uint64_t, uint64_t *))(a2 + 56))(a2, a1);
      }
      v51 = v50;
      uint64_t v52 = (*(uint64_t (**)(uint64_t, uint64_t *))(a2 + 32))(a2, a1);
      mlir::ValueRange::ValueRange(v136, v52, v53);
      if (!mlir::verifyListOfOperandsOrIntegers(a1, (const void **)"stride", (const char *)6, v6, v49, v51, v136[0], v136[1]))return 0; {
      long long v54 = (const char **)(*(uint64_t (**)(uint64_t, uint64_t *))(a2 + 40))(a2, a1);
      }
      if (v55)
      {
        uint64_t v56 = 8 * v55;
        while (1)
        {
          char v57 = *v54;
          if ((unint64_t)*v54 >= 0x8000000000000001) {
            break;
          }
          ++v54;
          v56 -= 8;
          if (!v56) {
            goto LABEL_53;
          }
        }
        v154 = "expected offsets to be non-negative, but got ";
        __int16 v157 = 259;
        mlir::Operation::emitError(a1, (uint64_t)&v154, (uint64_t)&v139);
        if (v139)
        {
          LODWORD(v151) = 2;
          unint64_t v152 = (unint64_t)v57;
          int64_t v86 = (char *)&v151;
          int64_t v87 = (char *)v142;
          if (v143 >= v144)
          {
            unint64_t v119 = v143 + 1;
            if (v142 <= &v151 && (char *)v142 + 24 * v143 > (char *)&v151)
            {
              int64_t v129 = (char *)&v151 - (unsigned char *)v142;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v119, 24);
              int64_t v87 = (char *)v142;
              int64_t v86 = (char *)v142 + v129;
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v119, 24);
              int64_t v86 = (char *)&v151;
              int64_t v87 = (char *)v142;
            }
          }
          unint64_t v88 = &v87[24 * v143];
          long long v89 = *(_OWORD *)v86;
          *((void *)v88 + 2) = *((void *)v86 + 2);
          *(_OWORD *)unint64_t v88 = v89;
          ++v143;
        }
        uint64_t v28 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
        if (v139) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v139);
        }
        if (v150)
        {
          long long v90 = (void **)__p;
          if (__p)
          {
            long long v91 = v149;
            uint64_t v92 = __p;
            if (v149 != __p)
            {
              do
                long long v91 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v91 - 1);
              while (v91 != v90);
              uint64_t v92 = __p;
            }
            v149 = v90;
            operator delete(v92);
          }
          long long v32 = v146;
          if (!v146) {
            goto LABEL_124;
          }
          __int16 v93 = v147;
          uint64_t v34 = v146;
          if (v147 == v146) {
            goto LABEL_123;
          }
          do
          {
            v95 = (void *)*--v93;
            uint64_t v94 = v95;
            *__int16 v93 = 0;
            if (v95) {
              operator delete[](v94);
            }
          }
          while (v93 != v32);
          goto LABEL_122;
        }
      }
      else
      {
LABEL_53:
        v58 = (const char **)(*(uint64_t (**)(uint64_t, uint64_t *))(a2 + 48))(a2, a1);
        if (!v59) {
          return 1;
        }
        uint64_t v60 = 8 * v59;
        while (1)
        {
          BOOL v61 = *v58;
          if ((unint64_t)*v58 >= 0x8000000000000001) {
            break;
          }
          ++v58;
          uint64_t v28 = 1;
          v60 -= 8;
          if (!v60) {
            return v28;
          }
        }
        v154 = "expected sizes to be non-negative, but got ";
        __int16 v157 = 259;
        mlir::Operation::emitError(a1, (uint64_t)&v154, (uint64_t)&v139);
        if (v139)
        {
          LODWORD(v151) = 2;
          unint64_t v152 = (unint64_t)v61;
          v96 = (char *)&v151;
          unsigned int v97 = (char *)v142;
          if (v143 >= v144)
          {
            unint64_t v120 = v143 + 1;
            if (v142 <= &v151 && (char *)v142 + 24 * v143 > (char *)&v151)
            {
              int64_t v130 = (char *)&v151 - (unsigned char *)v142;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v120, 24);
              unsigned int v97 = (char *)v142;
              v96 = (char *)v142 + v130;
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v120, 24);
              v96 = (char *)&v151;
              unsigned int v97 = (char *)v142;
            }
          }
          unsigned int v98 = &v97[24 * v143];
          long long v99 = *(_OWORD *)v96;
          *((void *)v98 + 2) = *((void *)v96 + 2);
          *(_OWORD *)unsigned int v98 = v99;
          ++v143;
        }
        uint64_t v28 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
        if (v139) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v139);
        }
        if (v150)
        {
          v100 = (void **)__p;
          if (__p)
          {
            v101 = v149;
            v102 = __p;
            if (v149 != __p)
            {
              do
                v101 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v101 - 1);
              while (v101 != v100);
              v102 = __p;
            }
            v149 = v100;
            operator delete(v102);
          }
          long long v32 = v146;
          if (!v146) {
            goto LABEL_124;
          }
          v103 = v147;
          uint64_t v34 = v146;
          if (v147 == v146) {
            goto LABEL_123;
          }
          do
          {
            uint64_t v105 = (void *)*--v103;
            char v104 = v105;
            void *v103 = 0;
            if (v105) {
              operator delete[](v104);
            }
          }
          while (v103 != v32);
          goto LABEL_122;
        }
      }
    }
    else
    {
      v131[0] = "expected mixed sizes rank to match mixed strides rank (";
      __int16 v132 = 259;
      mlir::Operation::emitError(a1, (uint64_t)v131, (uint64_t)&v139);
      (*(void (**)(char **__return_ptr, uint64_t, uint64_t *))(a2 + 72))(&v154, a2, a1);
      if (v139)
      {
        LODWORD(v151) = 5;
        unint64_t v152 = v155;
        v62 = (char *)&v151;
        long long v63 = (char *)v142;
        if (v143 >= v144)
        {
          unint64_t v113 = v143 + 1;
          if (v142 <= &v151 && (char *)v142 + 24 * v143 > (char *)&v151)
          {
            int64_t v125 = (char *)&v151 - (unsigned char *)v142;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v113, 24);
            long long v63 = (char *)v142;
            v62 = (char *)v142 + v125;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v113, 24);
            v62 = (char *)&v151;
            long long v63 = (char *)v142;
          }
        }
        unint64_t v64 = &v63[24 * v143];
        long long v65 = *(_OWORD *)v62;
        *((void *)v64 + 2) = *((void *)v62 + 2);
        *(_OWORD *)unint64_t v64 = v65;
        uint64_t v66 = ++v143;
        if (v139)
        {
          LODWORD(v151) = 3;
          unint64_t v152 = (unint64_t)" vs ";
          v153[0] = 4;
          long long v67 = (char *)&v151;
          long long v68 = (char *)v142;
          if (v66 >= v144)
          {
            unint64_t v115 = v66 + 1;
            BOOL v116 = (char *)v142 + 24 * v66 > (char *)&v151;
            if (v142 <= &v151 && v116)
            {
              int64_t v127 = (char *)&v151 - (unsigned char *)v142;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v115, 24);
              long long v68 = (char *)v142;
              long long v67 = (char *)v142 + v127;
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v115, 24);
              long long v67 = (char *)&v151;
              long long v68 = (char *)v142;
            }
          }
          v69 = &v68[24 * v143];
          long long v70 = *(_OWORD *)v67;
          *((void *)v69 + 2) = *((void *)v67 + 2);
          *(_OWORD *)v69 = v70;
          ++v143;
        }
      }
      (*(void (**)(void **__return_ptr, uint64_t, uint64_t *))(a2 + 80))(&v151, a2, a1);
      if (v139)
      {
        int v133 = 5;
        unint64_t v134 = v152;
        unint64_t v71 = &v133;
        unint64_t v72 = (char *)v142;
        if (v143 >= v144)
        {
          unint64_t v114 = v143 + 1;
          if (v142 <= &v133 && (char *)v142 + 24 * v143 > (char *)&v133)
          {
            int64_t v126 = (char *)&v133 - (unsigned char *)v142;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v114, 24);
            unint64_t v72 = (char *)v142;
            unint64_t v71 = (int *)((char *)v142 + v126);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v114, 24);
            unint64_t v71 = &v133;
            unint64_t v72 = (char *)v142;
          }
        }
        BOOL v73 = &v72[24 * v143];
        long long v74 = *(_OWORD *)v71;
        *((void *)v73 + 2) = *((void *)v71 + 2);
        *(_OWORD *)BOOL v73 = v74;
        uint64_t v75 = ++v143;
        if (v139)
        {
          int v133 = 3;
          unint64_t v134 = (unint64_t)") so the rank of the result type is well-formed.";
          uint64_t v135 = 48;
          BOOL v76 = &v133;
          unint64_t v77 = (char *)v142;
          if (v75 >= v144)
          {
            unint64_t v117 = v75 + 1;
            BOOL v118 = (char *)v142 + 24 * v75 > (char *)&v133;
            if (v142 <= &v133 && v118)
            {
              int64_t v128 = (char *)&v133 - (unsigned char *)v142;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v117, 24);
              unint64_t v77 = (char *)v142;
              BOOL v76 = (int *)((char *)v142 + v128);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v117, 24);
              BOOL v76 = &v133;
              unint64_t v77 = (char *)v142;
            }
          }
          unint64_t v78 = &v77[24 * v143];
          long long v79 = *(_OWORD *)v76;
          *((void *)v78 + 2) = *((void *)v76 + 2);
          *(_OWORD *)unint64_t v78 = v79;
          ++v143;
        }
      }
      uint64_t v28 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
      if (v151 != v153) {
        free(v151);
      }
      if (v154 != v156) {
        free(v154);
      }
      if (v139) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v139);
      }
      if (v150)
      {
        unint64_t v80 = (void **)__p;
        if (__p)
        {
          int64_t v81 = v149;
          int64_t v82 = __p;
          if (v149 != __p)
          {
            do
              int64_t v81 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v81 - 1);
            while (v81 != v80);
            int64_t v82 = __p;
          }
          v149 = v80;
          operator delete(v82);
        }
        long long v32 = v146;
        if (!v146) {
          goto LABEL_124;
        }
        int64_t v83 = v147;
        uint64_t v34 = v146;
        if (v147 == v146) {
          goto LABEL_123;
        }
        do
        {
          int64_t v85 = (void *)*--v83;
          int64_t v84 = v85;
          *int64_t v83 = 0;
          if (v85) {
            operator delete[](v84);
          }
        }
        while (v83 != v32);
        goto LABEL_122;
      }
    }
  }
  return v28;
}

llvm::raw_ostream *mlir::printDynamicIndexList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  v31[2] = *MEMORY[0x1E4F143B8];
  v29[0] = a3;
  v29[1] = a4;
  v31[0] = a7;
  v31[1] = a8;
  v28[0] = a9;
  v28[1] = a10;
  char v14 = 8 * a11 - 8;
  unsigned int v15 = 0x7B3C5B28u >> v14;
  unsigned int v16 = 0x7D3E5D29u >> v14;
  unint64_t v17 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  long long v18 = (unsigned char *)*((void *)v17 + 4);
  if ((unint64_t)v18 >= *((void *)v17 + 3))
  {
    llvm::raw_ostream::write(v17, v15);
    if (a6)
    {
LABEL_3:
      uint64_t v27 = 0;
      v30[0] = v28;
      v30[1] = &v27;
      v30[2] = a1;
      v30[3] = v29;
      v30[4] = (char *)&v27 + 4;
      v30[5] = v31;
      mlir::printDynamicIndexList(mlir::OpAsmPrinter &,mlir::Operation *,mlir::OperandRange,llvm::ArrayRef<long long>,mlir::TypeRange,llvm::ArrayRef<BOOL>,mlir::AsmParser::Delimiter)::$_0::operator()((uint64_t)v30, *a5);
      if (a6 != 1)
      {
        uint64_t v19 = a5 + 1;
        uint64_t v20 = 8 * a6 - 8;
        do
        {
          while (1)
          {
            long long v22 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
            uint64_t v23 = (_WORD *)*((void *)v22 + 4);
            if (*((void *)v22 + 3) - (void)v23 <= 1uLL) {
              break;
            }
            *uint64_t v23 = 8236;
            *((void *)v22 + 4) += 2;
            unint64_t v21 = *v19++;
            mlir::printDynamicIndexList(mlir::OpAsmPrinter &,mlir::Operation *,mlir::OperandRange,llvm::ArrayRef<long long>,mlir::TypeRange,llvm::ArrayRef<BOOL>,mlir::AsmParser::Delimiter)::$_0::operator()((uint64_t)v30, v21);
            v20 -= 8;
            if (!v20) {
              goto LABEL_8;
            }
          }
          llvm::raw_ostream::write(v22, ", ", 2uLL);
          unint64_t v24 = *v19++;
          mlir::printDynamicIndexList(mlir::OpAsmPrinter &,mlir::Operation *,mlir::OperandRange,llvm::ArrayRef<long long>,mlir::TypeRange,llvm::ArrayRef<BOOL>,mlir::AsmParser::Delimiter)::$_0::operator()((uint64_t)v30, v24);
          v20 -= 8;
        }
        while (v20);
      }
LABEL_8:
      uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
      uint64_t v26 = (unsigned char *)*((void *)result + 4);
      if ((unint64_t)v26 >= *((void *)result + 3)) {
        return llvm::raw_ostream::write(result, v16);
      }
      goto LABEL_12;
    }
  }
  else
  {
    *((void *)v17 + 4) = v18 + 1;
    *long long v18 = v15;
    if (a6) {
      goto LABEL_3;
    }
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  uint64_t v26 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v26 < *((void *)result + 3))
  {
LABEL_12:
    *((void *)result + 4) = v26 + 1;
    *uint64_t v26 = v16;
    return result;
  }

  return llvm::raw_ostream::write(result, v16);
}

uint64_t mlir::parseDynamicIndexList(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v53[4] = *MEMORY[0x1E4F143B8];
  uint64_t v37 = a5;
  v51 = v53;
  uint64_t v52 = 0x400000000;
  long long v35 = xmmword_1810FF9E0;
  uint64_t v29 = a1;
  unint64_t v30 = &v34;
  uint64_t v31 = a2;
  long long v32 = (void **)&v51;
  uint64_t v33 = &v37;
  uint64_t v34 = &v36;
  if ((*(unsigned __int8 (**)(void))(*(void *)a1 + 360))())
  {
    unsigned int v8 = (mlir::MLIRContext **)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
    *a3 = mlir::Builder::getDenseI64ArrayAttr(v8, (uint64_t)v51, v52);
    BOOL v9 = (mlir::MLIRContext **)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
    *a4 = mlir::Builder::getDenseBoolArrayAttr(v9, (uint64_t)v34, v35);
    uint64_t v10 = 1;
  }
  else
  {
    uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    __int16 v28 = 257;
    (*(void (**)(void *__return_ptr, uint64_t, uint64_t, char *))(*(void *)a1 + 24))(v41, a1, v12, v27);
    if (v41[0])
    {
      int v38 = 3;
      uint64_t v39 = "expected SSA value or integer";
      uint64_t v40 = 29;
      long long v13 = &v38;
      char v14 = (char *)v42;
      if (v43 >= v44)
      {
        unint64_t v25 = v43 + 1;
        if (v42 <= &v38 && (char *)v42 + 24 * v43 > (char *)&v38)
        {
          int64_t v26 = (char *)&v38 - (unsigned char *)v42;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v42, v45, v25, 24);
          char v14 = (char *)v42;
          long long v13 = (int *)((char *)v42 + v26);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v42, v45, v25, 24);
          long long v13 = &v38;
          char v14 = (char *)v42;
        }
      }
      unsigned int v15 = &v14[24 * v43];
      long long v16 = *(_OWORD *)v13;
      *((void *)v15 + 2) = *((void *)v13 + 2);
      *(_OWORD *)unsigned int v15 = v16;
      ++v43;
    }
    uint64_t v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
    if (v41[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
    }
    if (v50)
    {
      unint64_t v17 = (void **)__p;
      if (__p)
      {
        long long v18 = v49;
        uint64_t v19 = __p;
        if (v49 != __p)
        {
          do
            long long v18 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v18 - 1);
          while (v18 != v17);
          uint64_t v19 = __p;
        }
        uint64_t v49 = v17;
        operator delete(v19);
      }
      uint64_t v20 = v46;
      if (v46)
      {
        unint64_t v21 = v47;
        long long v22 = v46;
        if (v47 != v46)
        {
          do
          {
            unint64_t v24 = (void *)*--v21;
            uint64_t v23 = v24;
            *unint64_t v21 = 0;
            if (v24) {
              operator delete[](v23);
            }
          }
          while (v21 != v20);
          long long v22 = v46;
        }
        uint64_t v47 = v20;
        operator delete(v22);
      }
      if (v42 != v45) {
        free(v42);
      }
    }
  }
  if (v34 != &v36) {
    free(v34);
  }
  if (v51 != v53) {
    free(v51);
  }
  return v10;
}

uint64_t mlir::detail::sameOffsetsSizesAndStrides(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, void, void), uint64_t a6)
{
  v66[4] = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t, uint64_t))(a2 + 40))(a2, a1);
  uint64_t v12 = v11;
  (*(void (**)(uint64_t, uint64_t))(a4 + 40))(a4, a3);
  if (v12 != v13) {
    return 0;
  }
  (*(void (**)(uint64_t, uint64_t))(a2 + 48))(a2, a1);
  uint64_t v15 = v14;
  (*(void (**)(uint64_t, uint64_t))(a4 + 48))(a4, a3);
  if (v15 != v16) {
    return 0;
  }
  (*(void (**)(uint64_t, uint64_t))(a2 + 56))(a2, a1);
  uint64_t v18 = v17;
  (*(void (**)(uint64_t, uint64_t))(a4 + 56))(a4, a3);
  if (v18 != v19) {
    return 0;
  }
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(a2 + 64))(&__src, a2, a1);
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(a4 + 64))(&v55, a4, a3);
  __dst = v63;
  uint64_t v62 = 0x400000000;
  int v20 = v59;
  if (v59)
  {
    if (__src == v60)
    {
      unsigned int v21 = v59;
      if (v59 < 5
        || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v63, v59, 8), (unsigned int v21 = v59) != 0))
      {
        memcpy(__dst, __src, 8 * v21);
      }
      LODWORD(v62) = v20;
    }
    else
    {
      __dst = __src;
      uint64_t v62 = v59;
      __src = v60;
      HIDWORD(v59) = 0;
    }
    LODWORD(v59) = 0;
  }
  unint64_t v64 = v66;
  uint64_t v65 = 0x400000000;
  int v22 = v56;
  uint64_t v23 = v55;
  if (v56)
  {
    if (v55 != v57)
    {
      unint64_t v64 = v55;
      uint64_t v65 = v56;
      uint64_t v55 = v57;
      HIDWORD(v56) = 0;
      uint64_t v23 = v57;
LABEL_21:
      LODWORD(v56) = 0;
      goto LABEL_22;
    }
    if (v56 < 5)
    {
      uint64_t v24 = v56;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v66, v56, 8);
      uint64_t v24 = v56;
      uint64_t v23 = v55;
      if (!v56) {
        goto LABEL_20;
      }
    }
    memcpy(v64, v23, 8 * v24);
    uint64_t v23 = v55;
LABEL_20:
    LODWORD(v65) = v22;
    goto LABEL_21;
  }
LABEL_22:
  if (v23 != v57) {
    free(v23);
  }
  if (__src != v60) {
    free(__src);
  }
  unint64_t v25 = v64;
  int v26 = 1;
  if (v62 && v65)
  {
    uint64_t v27 = __dst;
    uint64_t v28 = 8 * v65 - 8;
    uint64_t v29 = 8 * v62 - 8;
    do
    {
      int v26 = a5(a6, *v27, *v25);
      if (!v26) {
        break;
      }
      if (!v29) {
        break;
      }
      ++v27;
      ++v25;
      uint64_t v30 = v28;
      v28 -= 8;
      v29 -= 8;
    }
    while (v30);
    unint64_t v25 = v64;
  }
  if (v25 != v66) {
    free(v25);
  }
  if (__dst != v63) {
    free(__dst);
  }
  if (!v26) {
    return 0;
  }
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(a2 + 72))(&__src, a2, a1);
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(a4 + 72))(&v55, a4, a3);
  __dst = v63;
  uint64_t v62 = 0x400000000;
  int v31 = v59;
  if (v59)
  {
    if (__src == v60)
    {
      unsigned int v32 = v59;
      if (v59 < 5
        || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v63, v59, 8), (unsigned int v32 = v59) != 0))
      {
        memcpy(__dst, __src, 8 * v32);
      }
      LODWORD(v62) = v31;
    }
    else
    {
      __dst = __src;
      uint64_t v62 = v59;
      __src = v60;
      HIDWORD(v59) = 0;
    }
    LODWORD(v59) = 0;
  }
  unint64_t v64 = v66;
  uint64_t v65 = 0x400000000;
  int v33 = v56;
  uint64_t v34 = v55;
  if (v56)
  {
    if (v55 != v57)
    {
      unint64_t v64 = v55;
      uint64_t v65 = v56;
      uint64_t v55 = v57;
      HIDWORD(v56) = 0;
      uint64_t v34 = v57;
LABEL_55:
      LODWORD(v56) = 0;
      goto LABEL_56;
    }
    if (v56 < 5)
    {
      uint64_t v35 = v56;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v66, v56, 8);
      uint64_t v35 = v56;
      uint64_t v34 = v55;
      if (!v56) {
        goto LABEL_54;
      }
    }
    memcpy(v64, v34, 8 * v35);
    uint64_t v34 = v55;
LABEL_54:
    LODWORD(v65) = v33;
    goto LABEL_55;
  }
LABEL_56:
  if (v34 != v57) {
    free(v34);
  }
  if (__src != v60) {
    free(__src);
  }
  uint64_t v36 = v64;
  int v37 = 1;
  if (v62 && v65)
  {
    int v38 = __dst;
    uint64_t v39 = 8 * v65 - 8;
    uint64_t v40 = 8 * v62 - 8;
    do
    {
      int v37 = a5(a6, *v38, *v36);
      if (!v37) {
        break;
      }
      if (!v40) {
        break;
      }
      ++v38;
      ++v36;
      uint64_t v41 = v39;
      v39 -= 8;
      v40 -= 8;
    }
    while (v41);
    uint64_t v36 = v64;
  }
  if (v36 != v66) {
    free(v36);
  }
  if (__dst != v63) {
    free(__dst);
  }
  if (!v37) {
    return 0;
  }
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(a2 + 80))(&__src, a2, a1);
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(a4 + 80))(&v55, a4, a3);
  __dst = v63;
  uint64_t v62 = 0x400000000;
  int v42 = v59;
  if (v59)
  {
    if (__src == v60)
    {
      unsigned int v45 = v59;
      if (v59 < 5
        || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v63, v59, 8), (unsigned int v45 = v59) != 0))
      {
        memcpy(__dst, __src, 8 * v45);
      }
      LODWORD(v62) = v42;
    }
    else
    {
      __dst = __src;
      uint64_t v62 = v59;
      __src = v60;
      HIDWORD(v59) = 0;
    }
    LODWORD(v59) = 0;
  }
  unint64_t v64 = v66;
  uint64_t v65 = 0x400000000;
  int v46 = v56;
  uint64_t v47 = v55;
  if (!v56) {
    goto LABEL_92;
  }
  if (v55 == v57)
  {
    if (v56 < 5)
    {
      uint64_t v48 = v56;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v66, v56, 8);
      uint64_t v48 = v56;
      uint64_t v47 = v55;
      if (!v56) {
        goto LABEL_90;
      }
    }
    memcpy(v64, v47, 8 * v48);
    uint64_t v47 = v55;
LABEL_90:
    LODWORD(v65) = v46;
    goto LABEL_91;
  }
  unint64_t v64 = v55;
  uint64_t v65 = v56;
  uint64_t v55 = v57;
  HIDWORD(v56) = 0;
  uint64_t v47 = v57;
LABEL_91:
  LODWORD(v56) = 0;
LABEL_92:
  if (v47 != v57) {
    free(v47);
  }
  if (__src != v60) {
    free(__src);
  }
  uint64_t v49 = v64;
  uint64_t v43 = 1;
  if (v62 && v65)
  {
    char v50 = __dst;
    uint64_t v51 = 8 * v62 - 8;
    uint64_t v52 = 8 * v65 - 8;
    do
    {
      uint64_t v43 = a5(a6, *v50, *v49);
      if (!v43) {
        break;
      }
      if (!v51) {
        break;
      }
      ++v50;
      ++v49;
      v51 -= 8;
      uint64_t v53 = v52;
      v52 -= 8;
    }
    while (v53);
    uint64_t v49 = v64;
  }
  if (v49 != v66) {
    free(v49);
  }
  if (__dst != v63) {
    free(__dst);
  }
  return v43;
}

uint64_t mlir::detail::getNumDynamicEntriesUpToIdx(int64x2_t *a1, uint64_t a2, unsigned int a3)
{
  if (!a3) {
    return 0;
  }
  unint64_t v3 = (a3 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (v3 < 7)
  {
    LODWORD(v4) = 0;
    unsigned int v5 = (uint64_t *)a1;
    do
    {
LABEL_8:
      uint64_t v18 = *v5++;
      if (v18 == 0x8000000000000000) {
        uint64_t v4 = (v4 + 1);
      }
      else {
        uint64_t v4 = v4;
      }
    }
    while (v5 != (uint64_t *)((char *)a1 + 8 * a3));
    return v4;
  }
  unint64_t v7 = v3 + 1;
  uint64_t v8 = (v3 + 1) & 0x3FFFFFFFFFFFFFF8;
  unsigned int v5 = &a1->i64[v8];
  BOOL v9 = a1 + 2;
  int32x4_t v10 = 0uLL;
  int64x2_t v11 = vdupq_n_s64(0x8000000000000000);
  uint64_t v12 = v8;
  int32x4_t v13 = 0uLL;
  do
  {
    int64x2_t v14 = v9[-2];
    int64x2_t v15 = v9[-1];
    int64x2_t v16 = *v9;
    int64x2_t v17 = v9[1];
    v9 += 4;
    int32x4_t v10 = vsubq_s32(v10, vuzp1q_s32((int32x4_t)vceqq_s64(v14, v11), (int32x4_t)vceqq_s64(v15, v11)));
    int32x4_t v13 = vsubq_s32(v13, vuzp1q_s32((int32x4_t)vceqq_s64(v16, v11), (int32x4_t)vceqq_s64(v17, v11)));
    v12 -= 8;
  }
  while (v12);
  uint64_t v4 = vaddvq_s32(vaddq_s32(v13, v10));
  if (v7 != v8) {
    goto LABEL_8;
  }
  return v4;
}

llvm::raw_ostream *mlir::printDynamicIndexList(mlir::OpAsmPrinter &,mlir::Operation *,mlir::OperandRange,llvm::ArrayRef<long long>,mlir::TypeRange,llvm::ArrayRef<BOOL>,mlir::AsmParser::Delimiter)::$_0::operator()(uint64_t a1, unint64_t a2)
{
  if (!*(void *)(*(void *)a1 + 8) || !*(unsigned char *)(**(void **)a1 + **(unsigned int **)(a1 + 8)))
  {
LABEL_5:
    uint64_t v6 = *(void *)(a1 + 16);
    if (a2 == 0x8000000000000000) {
      goto LABEL_6;
    }
LABEL_10:
    int64x2_t v11 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)v6 + 16))(v6);
    uint64_t result = llvm::raw_ostream::operator<<(v11, a2);
    uint64_t v12 = *(void **)a1;
    if (!*(void *)(*(void *)a1 + 8)) {
      goto LABEL_19;
    }
    goto LABEL_15;
  }
  uint64_t v4 = (llvm::raw_ostream *)(*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) != v5)
  {
    *unsigned int v5 = 91;
    ++*((void *)v4 + 4);
    goto LABEL_5;
  }
  llvm::raw_ostream::write(v4, "[", 1uLL);
  uint64_t v6 = *(void *)(a1 + 16);
  if (a2 != 0x8000000000000000) {
    goto LABEL_10;
  }
LABEL_6:
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t, void))(*(void *)v6 + 160))(v6, *(void *)(**(void **)(a1 + 24) + 32 * **(unsigned int **)(a1 + 32) + 24));
  if (*(void *)(*(void *)(a1 + 40) + 8))
  {
    uint64_t v8 = *(void *)(a1 + 16);
    BOOL v9 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)v8 + 16))(v8);
    uint64_t v10 = *((void *)v9 + 4);
    if ((unint64_t)(*((void *)v9 + 3) - v10) > 2)
    {
      *(unsigned char *)(v10 + 2) = 32;
      *(_WORD *)uint64_t v10 = 14880;
      *((void *)v9 + 4) += 3;
    }
    else
    {
      llvm::raw_ostream::write(v9, " : ", 3uLL);
    }
    unint64_t v13 = mlir::TypeRange::dereference_iterator(**(void **)(a1 + 40), **(unsigned int **)(a1 + 32));
    uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v8 + 32))(v8, v13);
  }
  ++**(_DWORD **)(a1 + 32);
  uint64_t v12 = *(void **)a1;
  if (*(void *)(*(void *)a1 + 8))
  {
LABEL_15:
    if (*(unsigned char *)(*v12 + **(unsigned int **)(a1 + 8)))
    {
      uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
      int64x2_t v14 = (unsigned char *)*((void *)result + 4);
      if (*((unsigned char **)result + 3) == v14)
      {
        uint64_t result = llvm::raw_ostream::write(result, "]", 1uLL);
      }
      else
      {
        *int64x2_t v14 = 93;
        ++*((void *)result + 4);
      }
    }
  }
LABEL_19:
  ++**(_DWORD **)(a1 + 8);
  return result;
}

BOOL llvm::function_ref<mlir::ParseResult ()(void)>::callback_fn<mlir::parseDynamicIndexList(mlir::OpAsmParser &,llvm::SmallVectorImpl<mlir::OpAsmParser::UnresolvedOperand> &,mlir::detail::DenseArrayAttrImpl<long long> &,mlir::detail::DenseArrayAttrImpl<BOOL> &,llvm::SmallVectorImpl<mlir::Type> *,mlir::AsmParser::Delimiter)::$_0>(uint64_t *a1)
{
  memset(v28, 0, 24);
  unsigned __int16 v2 = (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)*a1 + 680))(*a1, v28, 1);
  unint64_t v3 = (void *)a1[1];
  char v4 = (*(uint64_t (**)(void))(*(void *)*a1 + 304))();
  uint64_t v5 = v3[1];
  if ((unint64_t)(v5 + 1) > v3[2])
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)v3, v3 + 3, v5 + 1, 1);
    uint64_t v5 = v3[1];
  }
  *(unsigned char *)(*v3 + v5) = v4 != 0;
  ++v3[1];
  if (v2 < 0x100u || v2 == 0)
  {
    uint64_t v27 = 0;
    if (!mlir::AsmParser::parseInteger<long long>(*a1, &v27)) {
      return 0;
    }
    uint64_t v7 = a1[3];
    uint64_t v8 = v27;
    uint64_t v9 = *(unsigned int *)(v7 + 8);
    if (v9 >= *(_DWORD *)(v7 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1[3], (void *)(v7 + 16), v9 + 1, 8);
      LODWORD(v9) = *(_DWORD *)(v7 + 8);
    }
    *(void *)(*(void *)v7 + 8 * v9) = v8;
    ++*(_DWORD *)(v7 + 8);
  }
  else
  {
    uint64_t v10 = a1[2];
    uint64_t v11 = *(unsigned int *)(v10 + 8);
    unint64_t v12 = *(void *)v10;
    unint64_t v13 = (char *)v28;
    if (v11 >= *(_DWORD *)(v10 + 12))
    {
      unint64_t v24 = v11 + 1;
      BOOL v25 = v12 + 32 * v11 > (unint64_t)v28;
      if (v12 <= (unint64_t)v28 && v25)
      {
        int v26 = (char *)v28 - v12;
        llvm::SmallVectorBase<unsigned int>::grow_pod(a1[2], (void *)(v10 + 16), v24, 32);
        unint64_t v12 = *(void *)v10;
        unint64_t v13 = &v26[*(void *)v10];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a1[2], (void *)(v10 + 16), v24, 32);
        unint64_t v12 = *(void *)v10;
        unint64_t v13 = (char *)v28;
      }
    }
    int64x2_t v14 = (_OWORD *)(v12 + 32 * *(unsigned int *)(v10 + 8));
    long long v15 = *((_OWORD *)v13 + 1);
    *int64x2_t v14 = *(_OWORD *)v13;
    v14[1] = v15;
    ++*(_DWORD *)(v10 + 8);
    uint64_t v16 = a1[3];
    uint64_t v17 = *(unsigned int *)(v16 + 8);
    if (v17 >= *(_DWORD *)(v16 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1[3], (void *)(v16 + 16), v17 + 1, 8);
      LODWORD(v17) = *(_DWORD *)(v16 + 8);
    }
    *(void *)(*(void *)v16 + 8 * v17) = 0x8000000000000000;
    ++*(_DWORD *)(v16 + 8);
    uint64_t v18 = *(void *)a1[4];
    if (v18)
    {
      uint64_t v19 = *a1;
      uint64_t v20 = *(unsigned int *)(v18 + 8);
      if (v20 >= *(_DWORD *)(v18 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v18, (void *)(v18 + 16), v20 + 1, 8);
        *(void *)(*(void *)v18 + 8 * *(unsigned int *)(v18 + 8)) = 0;
        LODWORD(v20) = *(_DWORD *)(v18 + 8);
        uint64_t v21 = *(void *)v18;
      }
      else
      {
        uint64_t v21 = *(void *)v18;
        *(void *)(*(void *)v18 + 8 * v20) = 0;
      }
      unsigned int v22 = v20 + 1;
      *(_DWORD *)(v18 + 8) = v22;
      if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(void *)v19 + 544))(v19, v21 + 8 * v22 - 8)) {
        return 0;
      }
    }
  }
  return !*(unsigned char *)(*(void *)a1[1] + *(void *)(a1[1] + 8) - 1)
      || (*(unsigned __int8 (**)(uint64_t))(*(void *)*a1 + 320))(*a1);
}

uint64_t mlir::mps::createConvertF32ToF16Pass@<X0>(void *a1@<X8>)
{
  unint64_t v3 = (char *)operator new(0x1A8uLL);
  *((void *)v3 + 2) = "builtin.module";
  *((void *)v3 + 3) = 14;
  v3[32] = 1;
  v3[40] = 0;
  v3[120] = 0;
  *((_OWORD *)v3 + 8) = 0u;
  *((_OWORD *)v3 + 9) = 0u;
  *((_OWORD *)v3 + 10) = 0u;
  *((void *)v3 + 22) = 0;
  *((void *)v3 + 23) = v3 + 200;
  *((void *)v3 + 24) = 0x400000000;
  *((void *)v3 + 29) = v3 + 248;
  *((void *)v3 + 30) = 0x400000000;
  *((void *)v3 + 35) = 0;
  *((void *)v3 + 36) = 0;
  *((void *)v3 + 37) = 0x1000000000;
  *((_OWORD *)v3 + 19) = 0u;
  *((_OWORD *)v3 + 20) = 0u;
  *(_OWORD *)(v3 + 330) = 0u;
  *(void *)unint64_t v3 = &unk_1EC9A7798;
  *((_WORD *)v3 + 173) = 1;
  char v4 = (llvm::APFloatBase *)llvm::APFloatBase::IEEEhalf((llvm::APFloatBase *)v3);
  uint64_t v5 = (llvm::APFloatBase *)llvm::APFloatBase::PPCDoubleDouble(v4);
  if (v5 == v4) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat((void *)v3 + 45, (uint64_t)v4);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)(v3 + 360), (uint64_t)v4);
  }
  uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v3 + 360);
  if (v5 == *((llvm::APFloatBase **)v3 + 45)) {
    llvm::detail::DoubleAPFloat::makeLargest(v6, 0);
  }
  else {
    llvm::detail::IEEEFloat::makeLargest(v6, 0);
  }
  uint64_t v7 = v3 + 392;
  if (v5 == v4) {
    uint64_t v8 = (llvm::detail::DoubleAPFloat *)llvm::detail::DoubleAPFloat::DoubleAPFloat(v7, (uint64_t)v4);
  }
  else {
    uint64_t v8 = (llvm::detail::DoubleAPFloat *)llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v7, (uint64_t)v4);
  }
  if (v5 == *(llvm::APFloatBase **)v8) {
    llvm::detail::DoubleAPFloat::makeLargest(v8, 1);
  }
  else {
    Largest = (llvm::APFloatBase *)llvm::detail::IEEEFloat::makeLargest(v8, 1);
  }
  uint64_t v10 = llvm::APFloatBase::IEEEsingle(Largest);
  *((_DWORD *)v3 + 104) = llvm::APFloat::convert((uint64_t)(v3 + 352), v10, v3[346], v3 + 347);
  uint64_t result = llvm::APFloat::convert((uint64_t)(v3 + 384), v10, v3[346], v3 + 347);
  *((_DWORD *)v3 + 105) = result;
  *a1 = v3;
  return result;
}

void mlir::anonymous namespace'::ConvertF32ToF16Pass::~ConvertF32ToF16Pass(mlir::_anonymous_namespace_::ConvertF32ToF16Pass *this)
{
  *(void *)this = &unk_1EC9A7798;
  unsigned __int16 v2 = (mlir::_anonymous_namespace_::ConvertF32ToF16Pass *)((char *)this + 392);
  unint64_t v3 = (void *)*((void *)this + 49);
  char v4 = llvm::APFloatBase::PPCDoubleDouble(this);
  if (v4 == v3) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat(v2);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat(v2);
  }
  uint64_t v5 = (mlir::_anonymous_namespace_::ConvertF32ToF16Pass *)((char *)this + 360);
  if (v4 == *((void **)this + 45)) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat(v5);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat(v5);
  }

  mlir::Pass::~Pass(this);
}

{
  llvm::detail::DoubleAPFloat *v2;
  void *v3;
  void *v4;
  llvm::detail::DoubleAPFloat *v5;
  void *v6;
  uint64_t vars8;

  *(void *)this = &unk_1EC9A7798;
  unsigned __int16 v2 = (mlir::_anonymous_namespace_::ConvertF32ToF16Pass *)((char *)this + 392);
  unint64_t v3 = (void *)*((void *)this + 49);
  char v4 = llvm::APFloatBase::PPCDoubleDouble(this);
  if (v4 == v3) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat(v2);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat(v2);
  }
  uint64_t v5 = (mlir::_anonymous_namespace_::ConvertF32ToF16Pass *)((char *)this + 360);
  if (v4 == *((void **)this + 45)) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat(v5);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat(v5);
  }
  mlir::Pass::~Pass(this);

  operator delete(v6);
}

const char *mlir::PassWrapper<mlir::anonymous namespace'::ConvertF32ToF16Pass,mlir::OperationPass<mlir::ModuleOp>>::getName()
{
  uint64_t v5 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertF32ToF16Pass]";
  unint64_t v6 = 98;
  unint64_t v0 = llvm::StringRef::find((uint64_t *)&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0) {
    unint64_t v1 = v0;
  }
  else {
    unint64_t v1 = v6;
  }
  unsigned __int16 v2 = &v5[v1];
  if (v6 - v1 >= 0x12) {
    uint64_t v3 = 18;
  }
  else {
    uint64_t v3 = v6 - v1;
  }
  return &v2[v3];
}

const char *mlir::anonymous namespace'::ConvertF32ToF16Pass::getArgument(mlir::_anonymous_namespace_::ConvertF32ToF16Pass *this)
{
  return "vin-f32-to-f16";
}

const char *mlir::anonymous namespace'::ConvertF32ToF16Pass::getDescription(mlir::_anonymous_namespace_::ConvertF32ToF16Pass *this)
{
  return "Convert fp32 tensors to fp16.";
}

mlir::GenericProgramPoint *mlir::anonymous namespace'::ConvertDataTypePassBase<mlir::anonymous namespace'::ConvertF32ToF16Pass>::runOnOperation(void *a1)
{
  unint64_t v14 = 0;
  uint64_t result = (mlir::GenericProgramPoint *)(*(uint64_t (**)(void *))(*a1 + 112))(a1);
  uint64_t v3 = a1[5];
  if ((_BYTE)result)
  {
    v13[0] = a1;
    v13[1] = &v14;
    if (v14)
    {
      char v4 = (llvm::raw_ostream *)llvm::errs(result);
      uint64_t v5 = v4;
      unint64_t v6 = (void *)*((void *)v4 + 4);
      if (*((void *)v4 + 3) - (void)v6 > 0x25uLL)
      {
        qmemcpy(v6, "WARNING: Data Type Conversion in pass ", 38);
        *((void *)v4 + 4) += 38;
      }
      else
      {
        uint64_t v5 = llvm::raw_ostream::write(v4, "WARNING: Data Type Conversion in pass ", 0x26uLL);
      }
      uint64_t v8 = (const void *)(*(uint64_t (**)(void *))(*a1 + 32))(a1);
      size_t v9 = v7;
      uint64_t v10 = (void *)*((void *)v5 + 4);
      if (v7 <= *((void *)v5 + 3) - (void)v10)
      {
        if (v7)
        {
          memcpy(v10, v8, v7);
          uint64_t v10 = (void *)(*((void *)v5 + 4) + v9);
          *((void *)v5 + 4) = v10;
        }
      }
      else
      {
        uint64_t v5 = llvm::raw_ostream::write(v5, (const char *)v8, v7);
        uint64_t v10 = (void *)*((void *)v5 + 4);
      }
      if (*((void *)v5 + 3) - (void)v10 > 0xCuLL)
      {
        qmemcpy(v10, " encountered ", 13);
        *((void *)v5 + 4) += 13;
      }
      else
      {
        uint64_t v5 = llvm::raw_ostream::write(v5, " encountered ", 0xDuLL);
      }
      uint64_t result = llvm::raw_ostream::operator<<(v5, v14);
      uint64_t v11 = (void *)*((void *)result + 4);
      if (*((void *)result + 3) - (void)v11 > 0x24uLL)
      {
        qmemcpy(v11, " instances of overflow and have been ", 37);
        unint64_t v12 = (void *)(*((void *)result + 4) + 37);
        *((void *)result + 4) = v12;
      }
      else
      {
        uint64_t result = llvm::raw_ostream::write(result, " instances of overflow and have been ", 0x25uLL);
        unint64_t v12 = (void *)*((void *)result + 4);
      }
      if (*((void *)result + 3) - (void)v12 > 0x21uLL)
      {
        qmemcpy(v12, "clamped to fit the target ranges.\n", 34);
        *((void *)result + 4) += 34;
      }
      else
      {
        return llvm::raw_ostream::write(result, "clamped to fit the target ranges.\n", 0x22uLL);
      }
    }
  }
  else
  {
    a1[5] = v3 | 4;
  }
  return result;
}

llvm::detail::DoubleAPFloat *mlir::PassWrapper<mlir::anonymous namespace'::ConvertF32ToF16Pass,mlir::OperationPass<mlir::ModuleOp>>::clonePass@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  char v4 = operator new(0x1A8uLL);
  uint64_t v5 = *(void *)(a1 + 8);
  v4[1] = *(_OWORD *)(a1 + 16);
  *((void *)v4 + 4) = *(void *)(a1 + 32);
  *((void *)v4 + 1) = v5;
  *((unsigned char *)v4 + 40) = 0;
  *((unsigned char *)v4 + 120) = 0;
  v4[8] = 0u;
  v4[9] = 0u;
  v4[10] = 0u;
  *((void *)v4 + 22) = 0;
  *((void *)v4 + 23) = (char *)v4 + 200;
  *((void *)v4 + 24) = 0x400000000;
  *((void *)v4 + 29) = (char *)v4 + 248;
  *((void *)v4 + 30) = 0x400000000;
  *((void *)v4 + 35) = 0;
  *((void *)v4 + 36) = 0;
  *((_DWORD *)v4 + 74) = 0;
  *((_DWORD *)v4 + 75) = 16;
  v4[19] = 0u;
  v4[20] = 0u;
  *((void *)v4 + 42) = 0;
  *((_DWORD *)v4 + 86) = *(_DWORD *)(a1 + 344);
  *(void *)char v4 = &unk_1EC9A7798;
  unint64_t v6 = (llvm::detail::DoubleAPFloat *)((char *)v4 + 360);
  size_t v7 = *(void **)(a1 + 360);
  uint64_t v8 = llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)v4);
  if (v8 == v7) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v6, (const llvm::detail::DoubleAPFloat *)(a1 + 360));
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat(v6, (const llvm::detail::IEEEFloat *)(a1 + 360));
  }
  size_t v9 = (llvm::detail::DoubleAPFloat *)((char *)v4 + 392);
  uint64_t v10 = (const llvm::detail::DoubleAPFloat *)(a1 + 392);
  if (v8 == *(void **)(a1 + 392)) {
    uint64_t result = llvm::detail::DoubleAPFloat::DoubleAPFloat(v9, v10);
  }
  else {
    uint64_t result = (llvm::detail::DoubleAPFloat *)llvm::detail::IEEEFloat::IEEEFloat(v9, v10);
  }
  *((void *)v4 + 52) = *(void *)(a1 + 416);
  *a2 = v4;
  return result;
}

BOOL mlir::anonymous namespace'::ConvertF32ToF16Pass::isTypeConvertable(mlir::_anonymous_namespace_::ConvertF32ToF16Pass *this, const mlir::Type *a2)
{
  return mlir::Type::isF32(a2);
}

uint64_t mlir::anonymous namespace'::ConvertF32ToF16Pass::getConvertType(mlir::_anonymous_namespace_::ConvertF32ToF16Pass *this, mlir::Operation *a2, const mlir::Type *a3)
{
  mlir::Type::isF32(a3);
  Context = (mlir::Float16Type *)mlir::Attribute::getContext((mlir::Operation *)((char *)a2 + 24));

  return mlir::Float16Type::get(Context, v5);
}

BOOL mlir::anonymous namespace'::ConvertF32ToF16Pass::isValidConversion(mlir::_anonymous_namespace_::ConvertF32ToF16Pass *this)
{
  if (*((_DWORD *)this + 104)) {
    BOOL v1 = (*((_DWORD *)this + 104) & 0x10) == 0;
  }
  else {
    BOOL v1 = 0;
  }
  BOOL result = 0;
  if (!v1 && (!*((_DWORD *)this + 105) || (*((_DWORD *)this + 105) & 0x10) != 0)) {
    return 1;
  }
  return result;
}

uint64_t *mlir::anonymous namespace'::ConvertDataTypePassBase<mlir::anonymous namespace'::ConvertF32ToF16Pass>::convertElementsAttrRawData(int a1, mlir::CallOpInterface *this, mlir::MemoryMapperInterface *a3)
{
  v72[0] = mlir::CallOpInterface::getArgOperands(this);
  v72[1] = v5;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v72);
  uint64_t v74 = mlir::MemoryMapperInterface::getOperandRange(a3);
  mlir::mps::CPUNDArray::CPUNDArray(v72, *(void *)this, *((void *)this + 1));
  uint64_t v6 = *(void *)a3;
  uint64_t v7 = *((void *)a3 + 1);
  uint64_t v8 = mlir::MemoryMapperInterface::getOperandRange(this);
  mlir::mps::CPUNDArray::CPUNDArray(v70, v6, v7, v8);
  if (mlir::MemoryMapperInterface::getOperandRange(this))
  {
    uint64_t NumElements = 1;
  }
  else
  {
    ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr(a3);
    uint64_t NumElements = mlir::ShapedType::getNumElements(ArgAttrsAttr, v11);
  }
  if (!mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
    && !mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 64)
    || !mlir::Type::isSignedInteger((mlir::Type *)&v74, 32) && !mlir::Type::isSignlessInteger((mlir::Type *)&v74, 32))
  {
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
      && mlir::Type::isUnsignedInteger((mlir::Type *)&v74, 32))
    {
      if (NumElements < 1) {
        goto LABEL_36;
      }
      long long v15 = v73;
      uint64_t v16 = v71;
      if ((unint64_t)NumElements >= 8)
      {
        uint64_t v17 = NumElements & 0x7FFFFFFFFFFFFFF8;
        uint64_t v48 = v73 + 2;
        uint64_t v49 = v71 + 1;
        unint64_t v50 = NumElements & 0xFFFFFFFFFFFFFFF8;
        do
        {
          int32x4_t v52 = v48[-2];
          int32x4_t v51 = v48[-1];
          int32x4_t v54 = *v48;
          int32x4_t v53 = v48[1];
          v48 += 4;
          v49[-1] = vuzp1q_s32(v52, v51);
          int32x4_t *v49 = vuzp1q_s32(v54, v53);
          v49 += 2;
          v50 -= 8;
        }
        while (v50);
        if (NumElements == v17) {
          goto LABEL_36;
        }
      }
      else
      {
        uint64_t v17 = 0;
      }
      uint64_t v55 = NumElements - v17;
      uint64_t v56 = &v16->i32[v17];
      char v57 = &v15->i64[v17];
      do
      {
        uint64_t v58 = *v57++;
        *v56++ = v58;
        --v55;
      }
      while (v55);
      goto LABEL_36;
    }
    mlir::Type::isF32((mlir::Type *)&OperandRange);
    mlir::Type::isF16((mlir::Type *)&v74);
    if (NumElements < 1) {
      goto LABEL_36;
    }
    uint64_t v18 = v73;
    uint64_t v19 = v71;
    if ((unint64_t)NumElements >= 0x10)
    {
      uint64_t v20 = NumElements & 0x7FFFFFFFFFFFFFF0;
      unsigned int v32 = (float32x4_t *)&v73[2];
      int v33 = (float16x8_t *)&v71[1];
      unint64_t v34 = NumElements & 0xFFFFFFFFFFFFFFF0;
      do
      {
        float32x4_t v36 = v32[-2];
        float32x4_t v35 = v32[-1];
        float32x4_t v38 = *v32;
        float32x4_t v37 = v32[1];
        v32 += 4;
        v33[-1] = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v36), v35);
        *int v33 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v38), v37);
        v33 += 2;
        v34 -= 16;
      }
      while (v34);
      if (NumElements == v20) {
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v20 = 0;
    }
    uint64_t v39 = NumElements - v20;
    uint64_t v40 = &v19->i16[v20];
    uint64_t v41 = &v18->i32[v20];
    do
    {
      int v42 = *v41++;
      _S0 = v42;
      __asm { FCVT            H0, S0 }
      *v40++ = _S0;
      --v39;
    }
    while (v39);
    goto LABEL_36;
  }
  if (NumElements < 1) {
    goto LABEL_36;
  }
  unint64_t v12 = v73;
  unint64_t v13 = v71;
  if ((unint64_t)NumElements < 8)
  {
    uint64_t v14 = 0;
LABEL_22:
    uint64_t v28 = NumElements - v14;
    uint64_t v29 = &v13->i32[v14];
    uint64_t v30 = &v12->i64[v14];
    do
    {
      uint64_t v31 = *v30++;
      *v29++ = v31;
      --v28;
    }
    while (v28);
    goto LABEL_36;
  }
  uint64_t v14 = NumElements & 0x7FFFFFFFFFFFFFF8;
  uint64_t v21 = v73 + 2;
  unsigned int v22 = v71 + 1;
  unint64_t v23 = NumElements & 0xFFFFFFFFFFFFFFF8;
  do
  {
    int32x4_t v25 = v21[-2];
    int32x4_t v24 = v21[-1];
    int32x4_t v27 = *v21;
    int32x4_t v26 = v21[1];
    v21 += 4;
    v22[-1] = vuzp1q_s32(v25, v24);
    *unsigned int v22 = vuzp1q_s32(v27, v26);
    v22 += 2;
    v23 -= 8;
  }
  while (v23);
  if (NumElements != v14) {
    goto LABEL_22;
  }
LABEL_36:
  ElementsAttr = mlir::mps::CPUNDArray::getElementsAttr((mlir::mps::CPUNDArray *)v70, 1, 0);
  uint64_t v60 = ElementsAttr;
  if (ElementsAttr)
  {
    if (mlir::DenseElementsAttr::classof((uint64_t)ElementsAttr))
    {
      uint64_t v61 = *v60;
      unint64_t v62 = mlir::TypeID::get<mlir::ElementsAttr>();
      unint64_t v63 = *(unsigned int *)(v61 + 16);
      if (v63)
      {
        unint64_t v64 = *(void **)(v61 + 8);
        do
        {
          unint64_t v65 = v63 >> 1;
          uint64_t v66 = &v64[2 * (v63 >> 1)];
          unint64_t v68 = *v66;
          long long v67 = v66 + 2;
          v63 += ~(v63 >> 1);
          if (v68 < v62) {
            unint64_t v64 = v67;
          }
          else {
            unint64_t v63 = v65;
          }
        }
        while (v63);
      }
    }
    else
    {
      uint64_t v60 = 0;
    }
  }
  mlir::mps::CPUNDArray::~CPUNDArray((mlir::mps::CPUNDArray *)v70);
  mlir::mps::CPUNDArray::~CPUNDArray((mlir::mps::CPUNDArray *)v72);
  return v60;
}

void *mlir::anonymous namespace'::ConvertDataTypePassBase<mlir::anonymous namespace'::ConvertF32ToF16Pass>::mapIntValueWithOverflowCounts@<X0>(uint64_t a1@<X1>, llvm::APInt *a2@<X8>)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  *((_DWORD *)a2 + 2) = v2;
  if (v2 > 0x40) {
    return llvm::APInt::initSlowCase(a2, (const void **)a1);
  }
  *(void *)a2 = *(void *)a1;
  return result;
}

void mlir::anonymous namespace'::ConvertF32ToF16Pass::mapFloatValueWithOverflowCounts(mlir::_anonymous_namespace_::ConvertF32ToF16Pass *this@<X0>, const llvm::APFloat *a2@<X1>, unint64_t *a3@<X2>, llvm::APInt *a4@<X8>)
{
  uint64_t v7 = (const llvm::APFloat *)((char *)a2 + 8);
  uint64_t v8 = (void *)*((void *)a2 + 1);
  size_t v9 = llvm::APFloatBase::PPCDoubleDouble(this);
  uint64_t v10 = (mlir::_anonymous_namespace_::ConvertF32ToF16Pass *)((char *)this + 360);
  if (v9 == v8)
  {
    if (llvm::detail::DoubleAPFloat::compare(v7, (mlir::_anonymous_namespace_::ConvertF32ToF16Pass *)((char *)this + 360)) == 2)goto LABEL_10; {
  }
    }
  else if (llvm::detail::IEEEFloat::compare(v7, (mlir::_anonymous_namespace_::ConvertF32ToF16Pass *)((char *)this + 360)) == 2)
  {
    goto LABEL_10;
  }
  uint64_t v10 = (mlir::_anonymous_namespace_::ConvertF32ToF16Pass *)((char *)this + 392);
  uint64_t v11 = (mlir::_anonymous_namespace_::ConvertF32ToF16Pass *)((char *)this + 392);
  if (v9 == *(void **)v7)
  {
    if (llvm::detail::DoubleAPFloat::compare(v7, v11)) {
      goto LABEL_7;
    }
LABEL_10:
    ++*a3;
    if (v9 != *(void **)v10)
    {
      uint64_t v12 = (uint64_t)a4;
      unint64_t v13 = v10;
      goto LABEL_12;
    }
    uint64_t v14 = a4;
    long long v15 = v10;
    goto LABEL_17;
  }
  if (!llvm::detail::IEEEFloat::compare(v7, v11)) {
    goto LABEL_10;
  }
LABEL_7:
  if (v9 != *(void **)v7)
  {
    uint64_t v12 = (uint64_t)a4;
    unint64_t v13 = v7;
LABEL_12:
    llvm::detail::IEEEFloat::bitcastToAPInt(v13, v12);
    return;
  }
  uint64_t v14 = a4;
  long long v15 = v7;
LABEL_17:

  llvm::detail::DoubleAPFloat::bitcastToAPInt(v15, v14);
}

uint64_t mlir::anonymous namespace'::ConvertDataTypePassBase<mlir::anonymous namespace'::ConvertF32ToF16Pass>::convertElementsAttr(uint64_t a1, uint64_t a2, mlir::CallOpInterface *this, mlir::CallOpInterface *a4, uint64_t *a5, uint64_t a6, int a7)
{
  uint64_t ArgOperands = mlir::CallOpInterface::getArgOperands(this);
  p_uint64_t OperandRange = v14;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&ArgOperands);
  if (!(*(unsigned int (**)(uint64_t, uint64_t *))(*(void *)a1 + 96))(a1, &OperandRange)) {
    return 0;
  }
  if (!a6)
  {
    *(_OWORD *)a4 = *(_OWORD *)this;
    if (!a7) {
      return a6;
    }
    goto LABEL_28;
  }
  uint64_t v15 = *(void *)this;
  if (mlir::DenseElementsAttr::classof(v15)) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t v58 = v16;
  if (*(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
  {
    uint64_t ArgOperands = a1;
    p_uint64_t OperandRange = &OperandRange;
    char v57 = a5;
    uint64_t v18 = v28;
    if (v28)
    {
      uint64_t v29 = *v28;
      unint64_t v20 = mlir::TypeID::get<mlir::ElementsAttr>();
      unint64_t v30 = *(unsigned int *)(v29 + 16);
      if (v30)
      {
        unsigned int v22 = *(void **)(v29 + 8);
        unint64_t v23 = &v22[2 * v30];
        do
        {
          unint64_t v31 = v30 >> 1;
          unsigned int v32 = &v22[2 * (v30 >> 1)];
          unint64_t v34 = *v32;
          int v33 = v32 + 2;
          v30 += ~(v30 >> 1);
          if (v34 < v20) {
            unsigned int v22 = v33;
          }
          else {
            unint64_t v30 = v31;
          }
        }
        while (v30);
        goto LABEL_25;
      }
    }
LABEL_27:
    *(void *)a4 = v18;
    *((void *)a4 + 1) = 0;
    if (!a7) {
      return a6;
    }
    goto LABEL_28;
  }
  uint64_t ArgOperands = a1;
  p_uint64_t OperandRange = a5;
  uint64_t v18 = v17;
  if (!v17) {
    goto LABEL_27;
  }
  uint64_t v19 = *v17;
  unint64_t v20 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v21 = *(unsigned int *)(v19 + 16);
  if (!v21) {
    goto LABEL_27;
  }
  unsigned int v22 = *(void **)(v19 + 8);
  unint64_t v23 = &v22[2 * v21];
  do
  {
    unint64_t v24 = v21 >> 1;
    int32x4_t v25 = &v22[2 * (v21 >> 1)];
    unint64_t v27 = *v25;
    int32x4_t v26 = v25 + 2;
    v21 += ~(v21 >> 1);
    if (v27 < v20) {
      unsigned int v22 = v26;
    }
    else {
      unint64_t v21 = v24;
    }
  }
  while (v21);
LABEL_25:
  if (v22 == v23 || *v22 != v20) {
    goto LABEL_27;
  }
  uint64_t v54 = v22[1];
  *(void *)a4 = v18;
  *((void *)a4 + 1) = v54;
  if (!a7) {
    return a6;
  }
LABEL_28:
  if ((*(unsigned int (**)(uint64_t, uint64_t *))(*(void *)a1 + 96))(a1, &OperandRange))
  {
    uint64_t ArgOperands = mlir::CallOpInterface::getArgOperands(a4);
    p_uint64_t OperandRange = v35;
    uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    uint64_t v38 = v37;
    uint64_t v39 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(*(void *)a1 + 104))(a1, a2, &OperandRange);
    uint64_t v40 = (void *)mlir::RankedTensorType::get(ArgAttrsAttr, v38, v39, 0);
    uint64_t v41 = v40;
    if (!v40) {
      goto LABEL_38;
    }
    uint64_t v42 = *v40;
    unint64_t v43 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v44 = *(unsigned int *)(v42 + 16);
    if (!v44) {
      goto LABEL_38;
    }
    unsigned int v45 = *(void **)(v42 + 8);
    int v46 = &v45[2 * v44];
    do
    {
      unint64_t v47 = v44 >> 1;
      uint64_t v48 = &v45[2 * (v44 >> 1)];
      unint64_t v50 = *v48;
      uint64_t v49 = v48 + 2;
      v44 += ~(v44 >> 1);
      if (v50 < v43) {
        unsigned int v45 = v49;
      }
      else {
        unint64_t v44 = v47;
      }
    }
    while (v44);
    if (v45 != v46 && *v45 == v43) {
      int32x4_t v51 = (uint64_t *)v45[1];
    }
    else {
LABEL_38:
    }
      int32x4_t v51 = 0;
    uint64_t ArgOperands = (uint64_t)v41;
    p_uint64_t OperandRange = v51;
    *(void *)a4 = (*(uint64_t (**)(uint64_t, mlir::CallOpInterface *, uint64_t *))(*(void *)a1 + 120))(a1, a4, &ArgOperands);
    *((void *)a4 + 1) = v52;
    return 1;
  }
  return a6;
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<mlir::anonymous namespace'::ConvertDataTypePassBase<mlir::anonymous namespace'::ConvertF32ToF16Pass>::runOnOperation(void)::{lambda(mlir::Operation *)#1}>(uint64_t a1, uint64_t a2)
{
  uint64_t v132 = *MEMORY[0x1E4F143B8];
  char v4 = *(unsigned __int8 **)a1;
  if (!*(unsigned char *)(a2 + 47) || (mlir::Operation::getInherentAttr(a2, (uint64_t)"name", 4), !v5)) {
    mlir::DictionaryAttr::get(a2 + 56, "name", 4uLL);
  }
  if (*(_UNKNOWN **)(*(void *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::func::FuncOp,void>::id) {
    uint64_t v6 = (unsigned int *)a2;
  }
  else {
    uint64_t v6 = 0;
  }
  unint64_t v120 = v6;
  if (v6)
  {
    uint64_t FunctionType = mlir::func::FuncOp::getFunctionType((mlir::func::FuncOp *)&v120);
    *(void *)&long long v129 = v130;
    *((void *)&v129 + 1) = 0x100000000;
    Value = &v128;
    uint64_t v127 = 0x100000000;
    uint64_t Inputs = mlir::FunctionType::getInputs((mlir::FunctionType *)&FunctionType);
    if (v8)
    {
      size_t v9 = (void **)Inputs;
      uint64_t v10 = (void **)(Inputs + 8 * v8);
      do
      {
        uint64_t v11 = *v9;
        if (!*v9) {
          goto LABEL_19;
        }
        uint64_t v12 = *v11;
        unint64_t v13 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v14 = *(unsigned int *)(v12 + 16);
        if (!v14) {
          goto LABEL_19;
        }
        uint64_t v15 = *(void **)(v12 + 8);
        uint64_t v16 = &v15[2 * v14];
        do
        {
          unint64_t v17 = v14 >> 1;
          uint64_t v18 = &v15[2 * (v14 >> 1)];
          unint64_t v20 = *v18;
          uint64_t v19 = v18 + 2;
          v14 += ~(v14 >> 1);
          if (v20 < v13) {
            uint64_t v15 = v19;
          }
          else {
            unint64_t v14 = v17;
          }
        }
        while (v14);
        if (v15 != v16 && *v15 == v13) {
          uint64_t v21 = v15[1];
        }
        else {
LABEL_19:
        }
          uint64_t v21 = 0;
        int64_t v124 = v11;
        uint64_t v125 = v21;
        *(void *)&long long v121 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v124);
        if ((*(unsigned int (**)(unsigned __int8 *, long long *))(*(void *)v4 + 96))(v4, &v121))
        {
          v123[0] = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v124);
          uint64_t v22 = (*(uint64_t (**)(unsigned __int8 *, uint64_t, unint64_t *))(*(void *)v4 + 104))(v4, a2, v123);
          LOBYTE(v121) = 0;
          LOBYTE(v122[0]) = 0;
          uint64_t v23 = mlir::ShapedType::cloneWith((uint64_t *)&v124, &v121, v22);
        }
        else
        {
          uint64_t v23 = (uint64_t)v124;
        }
        uint64_t v24 = DWORD2(v129);
        if (DWORD2(v129) >= (unint64_t)HIDWORD(v129))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v129, v130, DWORD2(v129) + 1, 8);
          uint64_t v24 = DWORD2(v129);
        }
        *(void *)(v129 + 8 * v24) = v23;
        ++DWORD2(v129);
        ++v9;
      }
      while (v9 != v10);
    }
    uint64_t Results = mlir::FunctionType::getResults((mlir::FunctionType *)&FunctionType);
    if (v26)
    {
      unint64_t v27 = (void **)Results;
      uint64_t v28 = (void **)(Results + 8 * v26);
      do
      {
        uint64_t v29 = *v27;
        if (!*v27) {
          goto LABEL_39;
        }
        uint64_t v30 = *v29;
        unint64_t v31 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v32 = *(unsigned int *)(v30 + 16);
        if (!v32) {
          goto LABEL_39;
        }
        int v33 = *(void **)(v30 + 8);
        unint64_t v34 = &v33[2 * v32];
        do
        {
          unint64_t v35 = v32 >> 1;
          float32x4_t v36 = &v33[2 * (v32 >> 1)];
          unint64_t v38 = *v36;
          uint64_t v37 = v36 + 2;
          v32 += ~(v32 >> 1);
          if (v38 < v31) {
            int v33 = v37;
          }
          else {
            unint64_t v32 = v35;
          }
        }
        while (v32);
        if (v33 != v34 && *v33 == v31) {
          uint64_t v39 = v33[1];
        }
        else {
LABEL_39:
        }
          uint64_t v39 = 0;
        int64_t v124 = v29;
        uint64_t v125 = v39;
        *(void *)&long long v121 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v124);
        if ((*(unsigned int (**)(unsigned __int8 *, long long *))(*(void *)v4 + 96))(v4, &v121))
        {
          v123[0] = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v124);
          uint64_t v40 = (*(uint64_t (**)(unsigned __int8 *, uint64_t, unint64_t *))(*(void *)v4 + 104))(v4, a2, v123);
          LOBYTE(v121) = 0;
          LOBYTE(v122[0]) = 0;
          uint64_t v41 = mlir::ShapedType::cloneWith((uint64_t *)&v124, &v121, v40);
        }
        else
        {
          uint64_t v41 = (uint64_t)v124;
        }
        uint64_t v42 = v127;
        if (v127 >= (unint64_t)HIDWORD(v127))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&Value, &v128, v127 + 1, 8);
          uint64_t v42 = v127;
        }
        *((void *)Value + v42) = v41;
        LODWORD(v127) = v127 + 1;
        ++v27;
      }
      while (v27 != v28);
    }
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v120 + 6));
    mlir::ValueRange::ValueRange((unint64_t *)&v124, v129, DWORD2(v129));
    mlir::ValueRange::ValueRange(v123, (uint64_t)Value, v127);
    uint64_t v44 = mlir::FunctionType::get(Context, (uint64_t)v124, v125, v123[0], v123[1]);
    unsigned int v45 = v120;
    if (v120) {
      uint64_t InterfaceFor = mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)v120);
    }
    else {
      uint64_t InterfaceFor = 0;
    }
    mlir::function_interface_impl::setFunctionType((uint64_t)v45, InterfaceFor, v44);
    unint64_t v96 = v120[11];
    if ((v96 & 0x7FFFFF) != 0) {
      unsigned int v97 = (void *)((((unint64_t)&v120[4 * ((v96 >> 23) & 1) + 17] + ((v96 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
    }
                     + 32 * v120[10]);
    else {
      unsigned int v97 = 0;
    }
    if ((void *)*v97 != v97)
    {
      uint64_t v98 = v97[1];
      uint64_t v99 = v98 ? v98 - 8 : 0;
      v100 = *(uint64_t **)(v99 + 48);
      for (unint64_t i = *(uint64_t **)(v99 + 56); v100 != i; ++v100)
      {
        uint64_t v104 = *v100;
        uint64_t v105 = (uint64_t *)(*(void *)(*v100 + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!v105) {
          goto LABEL_128;
        }
        uint64_t v106 = *v105;
        unint64_t v107 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v108 = *(unsigned int *)(v106 + 16);
        if (!v108) {
          goto LABEL_128;
        }
        unint64_t v109 = *(void **)(v106 + 8);
        BOOL v110 = &v109[2 * v108];
        do
        {
          unint64_t v111 = v108 >> 1;
          BOOL v112 = &v109[2 * (v108 >> 1)];
          unint64_t v114 = *v112;
          unint64_t v113 = v112 + 2;
          v108 += ~(v108 >> 1);
          if (v114 < v107) {
            unint64_t v109 = v113;
          }
          else {
            unint64_t v108 = v111;
          }
        }
        while (v108);
        if (v109 != v110 && *v109 == v107) {
          uint64_t v115 = v109[1];
        }
        else {
LABEL_128:
        }
          uint64_t v115 = 0;
        v118[0] = (uint64_t)v105;
        v118[1] = v115;
        *(void *)&long long v121 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
        if ((*(unsigned int (**)(unsigned __int8 *, long long *))(*(void *)v4 + 96))(v4, &v121))
        {
          uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
          uint64_t v116 = (*(uint64_t (**)(unsigned __int8 *, uint64_t, uint64_t *))(*(void *)v4 + 104))(v4, a2, &OperandRange);
          LOBYTE(v121) = 0;
          LOBYTE(v122[0]) = 0;
          *(void *)(v104 + 8) = *(void *)(v104 + 8) & 7 | mlir::ShapedType::cloneWith(v118, &v121, v116);
        }
      }
    }
    if (Value != &v128) {
      free(Value);
    }
    v95 = (void *)v129;
    if ((unsigned char *)v129 == v130) {
      goto LABEL_111;
    }
LABEL_110:
    free(v95);
    goto LABEL_111;
  }
  unint64_t v47 = (uint64_t *)v122;
  *(void *)&long long v121 = v122;
  v122[0] = xmmword_1E4FC0110;
  v122[1] = *(_OWORD *)&off_1E4FC0120;
  v122[2] = xmmword_1E4FC0130;
  *((void *)&v121 + 1) = 0x300000003;
  uint64_t v48 = (mlir::Attribute *)(a2 + 24);
  do
  {
    uint64_t v54 = (const void *)*v47;
    size_t v53 = v47[1];
    if (!*(unsigned char *)(a2 + 47) || (uint64_t InherentAttr = mlir::Operation::getInherentAttr(a2, *v47, v47[1]), !v56)) {
      uint64_t InherentAttr = mlir::DictionaryAttr::get(a2 + 56, v54, v53);
    }
    if (InherentAttr)
    {
      char v57 = *(void **)(*(void *)InherentAttr + 136);
      BOOL v58 = v57 == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id;
      uint64_t v59 = v57 == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id ? InherentAttr : 0;
      int64_t v124 = (void *)v59;
      if (v58)
      {
        *(void *)&long long v129 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v124);
        if ((*(unsigned int (**)(unsigned __int8 *, long long *))(*(void *)v4 + 96))(v4, &v129))
        {
          Value = (void *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v124);
          uint64_t v49 = (*(uint64_t (**)(unsigned __int8 *, uint64_t, void **))(*(void *)v4 + 104))(v4, a2, &Value);
          uint64_t v50 = mlir::TypeAttr::get(v49);
LABEL_52:
          int32x4_t v51 = (mlir::StringAttr *)mlir::Attribute::getContext(v48);
          __int16 v131 = 261;
          *(void *)&long long v129 = v54;
          *((void *)&v129 + 1) = v53;
          uint64_t v52 = mlir::StringAttr::get(v51, (mlir::MLIRContext *)&v129);
          mlir::Operation::setAttr(a2, v52, v50);
          goto LABEL_53;
        }
        uint64_t v60 = (void *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v124);
        *(void *)&long long v129 = mlir::getElementTypeOrSelf(v60);
        if ((*(unsigned int (**)(unsigned __int8 *, long long *))(*(void *)v4 + 96))(v4, &v129))
        {
          uint64_t v61 = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v124);
          unint64_t v62 = v61;
          if (!v61) {
            goto LABEL_74;
          }
          uint64_t v63 = *v61;
          unint64_t v64 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v65 = *(unsigned int *)(v63 + 16);
          if (!v65) {
            goto LABEL_74;
          }
          uint64_t v66 = *(void **)(v63 + 8);
          long long v67 = &v66[2 * v65];
          do
          {
            unint64_t v68 = v65 >> 1;
            v69 = &v66[2 * (v65 >> 1)];
            unint64_t v71 = *v69;
            long long v70 = v69 + 2;
            v65 += ~(v65 >> 1);
            if (v71 < v64) {
              uint64_t v66 = v70;
            }
            else {
              unint64_t v65 = v68;
            }
          }
          while (v65);
          if (v66 != v67 && *v66 == v64) {
            uint64_t v72 = v66[1];
          }
          else {
LABEL_74:
          }
            uint64_t v72 = 0;
          Value = v62;
          uint64_t v127 = v72;
          uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&Value);
          uint64_t v75 = v74;
          BOOL v76 = (void *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v124);
          v123[0] = mlir::getElementTypeOrSelf(v76);
          uint64_t v77 = (*(uint64_t (**)(unsigned __int8 *, uint64_t, unint64_t *))(*(void *)v4 + 104))(v4, a2, v123);
          uint64_t v78 = mlir::RankedTensorType::get(ArgAttrsAttr, v75, v77, 0);
          uint64_t v50 = mlir::TypeAttr::get(v78);
          uint64_t v48 = (mlir::Attribute *)(a2 + 24);
          goto LABEL_52;
        }
      }
    }
LABEL_53:
    v47 += 2;
  }
  while (v47 != (uint64_t *)v123);
  uint64_t v79 = *(unsigned int *)(a2 + 36);
  if (v79) {
    uint64_t v80 = a2 - 16;
  }
  else {
    uint64_t v80 = 0;
  }
  if (v79)
  {
    for (uint64_t j = 0; j != v79; ++j)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v80, j);
      int64_t v83 = (uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v83) {
        goto LABEL_92;
      }
      uint64_t v84 = *v83;
      unint64_t v85 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v86 = *(unsigned int *)(v84 + 16);
      if (!v86) {
        goto LABEL_92;
      }
      int64_t v87 = *(void **)(v84 + 8);
      unint64_t v88 = &v87[2 * v86];
      do
      {
        unint64_t v89 = v86 >> 1;
        long long v90 = &v87[2 * (v86 >> 1)];
        unint64_t v92 = *v90;
        long long v91 = v90 + 2;
        v86 += ~(v86 >> 1);
        if (v92 < v85) {
          int64_t v87 = v91;
        }
        else {
          unint64_t v86 = v89;
        }
      }
      while (v86);
      if (v87 != v88 && *v87 == v85) {
        uint64_t v93 = v87[1];
      }
      else {
LABEL_92:
      }
        uint64_t v93 = 0;
      Value = v83;
      uint64_t v127 = v93;
      int64_t v124 = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value);
      if ((*(unsigned int (**)(unsigned __int8 *, void **))(*(void *)v4 + 96))(v4, &v124))
      {
        uint64_t v94 = (*(uint64_t (**)(unsigned __int8 *, uint64_t, void **))(*(void *)v4 + 104))(v4, a2, &v124);
        LOBYTE(v129) = 0;
        v130[0] = 0;
        *(void *)(NextResultAtOffset + 8) = *(void *)(NextResultAtOffset + 8) & 7 | mlir::ShapedType::cloneWith((uint64_t *)&Value, &v129, v94);
      }
    }
  }
  v95 = (void *)v121;
  if ((_OWORD *)v121 != v122) {
    goto LABEL_110;
  }
LABEL_111:
  if (*(_UNKNOWN **)(*(void *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id) {
    v102 = (void *)a2;
  }
  else {
    v102 = 0;
  }
  Value = v102;
  if (v102)
  {
    long long v121 = 0uLL;
    *(void *)&long long v129 = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&Value);
    *((void *)&v129 + 1) = v103;
    if ((*(unsigned __int8 (**)(unsigned __int8 *, uint64_t, long long *, long long *, void, void, void))(*(void *)v4 + 144))(v4, a2, &v129, &v121, *(void *)(a1 + 8), v4[344], v4[345]))
    {
      mlir::mps::ConstantOp::updateValue((uint64_t *)&Value, (void *)v121);
    }
  }
}

uint64_t llvm::function_ref<llvm::APInt ()(llvm::APInt const&)>::callback_fn<mlir::anonymous namespace'::ConvertDataTypePassBase<mlir::anonymous namespace'::ConvertF32ToF16Pass>::convertElementsAttr(mlir::Operation *,mlir::ElementsAttr const&,mlir::ElementsAttr&,unsigned long &,BOOL,BOOL)::{lambda(llvm::APInt const&)#1}>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  BOOL isUnsignedInteger = mlir::Type::isUnsignedInteger((mlir::Type *)a1[1]);
  uint64_t v6 = a1[2];
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, BOOL, uint64_t))(*(void *)v4 + 128);

  return v7(v4, a2, isUnsignedInteger, v6);
}

uint64_t llvm::function_ref<llvm::APInt ()(llvm::APFloat const&)>::callback_fn<mlir::anonymous namespace'::ConvertDataTypePassBase<mlir::anonymous namespace'::ConvertF32ToF16Pass>::convertElementsAttr(mlir::Operation *,mlir::ElementsAttr const&,mlir::ElementsAttr&,unsigned long &,BOOL,BOOL)::{lambda(llvm::APFloat const&)#1}>(void *a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, void))(*(void *)*a1 + 136))(*a1, a2, a1[1]);
}

void mlir::MPSToANECOpCreator::MPSToANECOpCreator(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, int a6, char a7, char a8, char a9, char a10, char a11, unsigned int a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  uint64_t v36 = a15;
  uint64_t v37 = a16;
  int v35 = a3;
  char v34 = a4;
  char v33 = a10;
  char v32 = a11;
  uint64_t v22 = (mlir::MPSToANECTypeConverter *)operator new(0x218uLL);
  uint64_t v23 = mlir::MPSToANECTypeConverter::MPSToANECTypeConverter(v22);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = v23;
  *(void *)(a1 + 8) = &unk_1EC9AA748;
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 40) = a1 + 56;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)(a1 + 96) = 0x1000000000;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0x2800000000;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = a2;
  *(void *)(a1 + 168) = a2;
  *(unsigned char *)(a1 + 200) = 1;
  uint64_t v24 = (_OWORD *)(a1 + 200);
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(_OWORD *)(a1 + 204) = 0u;
  *(_OWORD *)(a1 + 220) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(void *)(a1 + 248) = 978433816;
  *(unsigned char *)(a1 + 256) = 0;
  *(unsigned char *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = 0;
  uint64_t v41 = a2;
  *(_OWORD *)__p = 0u;
  *(_OWORD *)unint64_t v43 = 0u;
  uint64_t v44 = &v46;
  uint64_t v45 = 0x600000000;
  unint64_t v47 = 0;
  uint64_t v48 = 0;
  int v49 = 0;
  uint64_t v50 = 0;
  uint64_t v51 = 0;
  uint64_t v52 = 0x2800000000;
  size_t v53 = 0;
  uint64_t v54 = 0;
  uint64_t v55 = 0x2800000000;
  mlir::populateMPSToANECConversionPatterns(a3, a4, &v41, (uint64_t)v22);
  *(void *)&v39[0] = "func";
  *((void *)&v39[0] + 1) = 4;
  mlir::ConversionTarget::setDialectAction((uint64_t *)(a1 + 8), (uint64_t)v39, 1, 2);
  *(void *)&v39[0] = "memref";
  *((void *)&v39[0] + 1) = 6;
  mlir::ConversionTarget::setDialectAction((uint64_t *)(a1 + 8), (uint64_t)v39, 1, 2);
  *(void *)&v39[0] = "mps";
  *((void *)&v39[0] + 1) = 3;
  mlir::ConversionTarget::setDialectAction((uint64_t *)(a1 + 8), (uint64_t)v39, 1, 2);
  *(void *)&v39[0] = "mpsx";
  *((void *)&v39[0] + 1) = 4;
  v38[1] = (void *)0x200000000;
  mlir::ConversionTarget::setDialectAction((uint64_t *)(a1 + 8), (uint64_t)v39, 1, 2);
  v38[0] = &unk_1EC9D1670;
  *((void *)&v39[0] + 1) = v38;
  mlir::OperationName::OperationName(v30, "mps.constant", 12, *(void *)(a1 + 160));
  uint64_t v25 = v30[0];
  mlir::ConversionTarget::setOpAction(a1 + 8, v30[0], 1);
  mlir::ConversionTarget::setLegalityCallback(a1 + 8, v25, v38);
  if (*((void ***)&v39[0] + 1) == v38)
  {
    (*((void (**)(void **))v38[0] + 4))(v38);
    if (!a6) {
      goto LABEL_10;
    }
  }
  else
  {
    if (*((void *)&v39[0] + 1)) {
      (*(void (**)(void))(**((void **)&v39[0] + 1) + 40))();
    }
    if (!a6)
    {
LABEL_10:
      uint64_t v28 = *(void *)a1;
      *(_OWORD *)unint64_t v38 = xmmword_1E4FC0140;
      v39[0] = *(_OWORD *)&off_1E4FC0150;
      v30[0] = (uint64_t)v38;
      v30[1] = 2;
      uint64_t v31 = a1 + 200;
      std::make_unique[abi:nn180100]<mlir::ANECRegionOpCreator,mlir::OpBuilder &,mlir::ConversionTarget &,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family &,mlir::DeviceInfo *,llvm::ArrayRef<llvm::StringRef>,long long &,long long &,BOOL &,BOOL &,llvm::StringRef&,BOOL &>(a1 + 168, a1 + 8, (uint64_t)&v41, v28, (unsigned int *)&v35, &v31, v30, &a13, &a14);
    }
  }
  mlir::getDeviceInfo(v35, a12, (uint64_t)v38);
  long long v26 = v39[0];
  *uint64_t v24 = *(_OWORD *)v38;
  *(_OWORD *)(a1 + 216) = v26;
  *(_OWORD *)(a1 + 232) = v39[1];
  *(void *)(a1 + 248) = v40;
  int v27 = *(unsigned __int8 *)(a1 + 272);
  *(void *)(a1 + 256) = 0;
  if (!v27) {
    *(unsigned char *)(a1 + 272) = 1;
  }
  *(unsigned char *)(a1 + 256) = a7;
  *(unsigned char *)(a1 + 257) = a8;
  *(unsigned char *)(a1 + 258) = a9;
  *(void *)(a1 + 264) = v24;
  goto LABEL_10;
}

void std::make_unique[abi:nn180100]<mlir::ANECRegionOpCreator,mlir::OpBuilder &,mlir::ConversionTarget &,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family &,mlir::DeviceInfo *,llvm::ArrayRef<llvm::StringRef>,long long &,long long &,BOOL &,BOOL &,llvm::StringRef&,BOOL &>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  unint64_t v14 = operator new(0x168uLL);
  long long v15 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)__p = *(_OWORD *)a3;
  long long v22 = v15;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  uint64_t v16 = *(mlir::Operation **)(a3 + 32);
  *(void *)(a3 + 24) = 0;
  *(void *)(a3 + 32) = 0;
  uint64_t v23 = v16;
  v24[0] = &v25;
  v24[1] = (void *)0x600000000;
  if (*(_DWORD *)(a3 + 48)) {
    llvm::SmallVectorImpl<std::unique_ptr<mlir::PDLPatternConfigSet>>::operator=((uint64_t)v24, a3 + 40);
  }
  long long v26 = *(llvm **)(a3 + 104);
  uint64_t v27 = *(void *)(a3 + 112);
  *(void *)(a3 + 104) = 0;
  *(void *)(a3 + 112) = 0;
  int v28 = *(_DWORD *)(a3 + 120);
  *(_DWORD *)(a3 + 120) = 0;
  uint64_t v29 = *(void **)(a3 + 128);
  long long v30 = *(_OWORD *)(a3 + 136);
  *(void *)(a3 + 128) = 0;
  *(void *)(a3 + 136) = 0;
  *(_DWORD *)(a3 + 144) = 0;
  uint64_t v31 = *(void **)(a3 + 152);
  long long v32 = *(_OWORD *)(a3 + 160);
  *(void *)(a3 + 152) = 0;
  *(void *)(a3 + 160) = 0;
  *(_DWORD *)(a3 + 168) = 0;
  mlir::ANECRegionOpCreator::ANECRegionOpCreator((uint64_t)v14, a1, a2, (uint64_t)__p, a4, *a5, *a6, v13, *a7, a7[1], *a8, *a9);
}

void mlir::MPSToANECOpCreator::MPSToANECOpCreator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 32);
  uint64_t v3 = a3 + 32;
  uint64_t v4 = v5;
  int v6 = *(char *)(v3 + 23);
  BOOL v7 = v6 < 0;
  if (v6 >= 0) {
    uint64_t v4 = v3;
  }
  uint64_t v8 = *(unsigned __int8 *)(v3 + 23);
  if (v7) {
    uint64_t v8 = *(void *)(v3 + 8);
  }
  mlir::MPSToANECOpCreator::MPSToANECOpCreator(a1, a2, *(unsigned int *)(v3 + 24), *(unsigned char *)(v3 + 28), 0, *(unsigned __int8 *)(v3 - 31), *(unsigned char *)(v3 - 30), *(unsigned char *)(v3 - 29), *(unsigned char *)(v3 - 28), 0, *(unsigned char *)(v3 - 27), *(void *)(v3 - 24), *(void *)(v3 - 16), *(void *)(v3 - 8), v4, v8);
}

uint64_t mlir::createMPSToANECPass@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (char *)operator new(0xE88uLL);
  *(void *)uint64_t v5 = &unk_1EC9AA388;
  *(_DWORD *)(v5 + 472) = *(_DWORD *)(a1 + 56);
  uint64_t v6 = *(void *)(v5 + 936);
  if (!v6) {
    goto LABEL_15;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 48))(v6, a1 + 56);
  *((void *)v4 + 318) = *(void *)(a1 + 16);
  uint64_t v7 = *((void *)v4 + 326);
  if (!v7) {
    goto LABEL_15;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 48))(v7, a1 + 16);
  *((void *)v4 + 345) = *(void *)(a1 + 24);
  uint64_t v8 = *((void *)v4 + 353);
  if (!v8) {
    goto LABEL_15;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 48))(v8, a1 + 24);
  v4[1088] = *(unsigned char *)(a1 + 5);
  uint64_t v9 = *((void *)v4 + 143);
  if (!v9) {
    goto LABEL_15;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v9 + 48))(v9, a1 + 5);
  v4[1296] = *(unsigned char *)a1;
  uint64_t v10 = *((void *)v4 + 169);
  if (!v10) {
    goto LABEL_15;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 48))(v10, a1);
  v4[1504] = *(unsigned char *)(a1 + 1);
  uint64_t v11 = *((void *)v4 + 195);
  if (!v11) {
    goto LABEL_15;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v11 + 48))(v11, a1 + 1);
  v4[1920] = *(unsigned char *)(a1 + 2);
  uint64_t v12 = *((void *)v4 + 247);
  if (!v12) {
    goto LABEL_15;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 48))(v12, a1 + 2);
  v4[1712] = *(unsigned char *)(a1 + 3);
  uint64_t v13 = *((void *)v4 + 221);
  if (!v13) {
    goto LABEL_15;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v13 + 48))(v13, a1 + 3);
  v4[2128] = *(unsigned char *)(a1 + 4);
  uint64_t v14 = *((void *)v4 + 273);
  if (!v14) {
    goto LABEL_15;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v14 + 48))(v14, a1 + 4);
  int v15 = *(_DWORD *)(a1 + 8);
  *((_DWORD *)v4 + 744) = v15;
  int v24 = v15;
  uint64_t v16 = *((void *)v4 + 379);
  if (!v16) {
    goto LABEL_15;
  }
  (*(void (**)(uint64_t, int *))(*(void *)v16 + 48))(v16, &v24);
  v4[3184] = *(unsigned char *)(a1 + 6);
  uint64_t v17 = *((void *)v4 + 405);
  if (!v17) {
    goto LABEL_15;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v17 + 48))(v17, a1 + 6);
  std::string::operator=((std::string *)(v4 + 3392), (const std::string *)(a1 + 32));
  uint64_t v18 = *((void *)v4 + 436);
  if (!v18) {
    goto LABEL_15;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v18 + 48))(v18, a1 + 32);
  char v20 = *(unsigned char *)(a1 + 60);
  uint64_t v19 = a1 + 60;
  v4[3640] = v20;
  uint64_t v21 = *((void *)v4 + 462);
  if (v21)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v21 + 48))(v21, v19);
    *a2 = v4;
  }
  else
  {
LABEL_15:
    uint64_t v23 = std::__throw_bad_function_call[abi:nn180100]();
    return mlir::createMPSPlacementPass(v23);
  }
  return result;
}

mlir::MPSToANECTypeConverter *mlir::createMPSPlacementPass@<X0>(int a1@<W0>, int a2@<W1>, uint64_t a3@<X2>, char a4@<W3>, void *a5@<X8>)
{
  uint64_t v10 = operator new(0x978uLL);
  int v20 = a1;
  uint64_t v19 = a3;
  char v18 = a4;
  *(void *)uint64_t v11 = &unk_1EC9A5578;
  *(_DWORD *)(v11 + 472) = a1;
  uint64_t v12 = *(void *)(v11 + 936);
  if (!v12) {
    goto LABEL_6;
  }
  (*(void (**)(uint64_t, int *))(*(void *)v12 + 48))(v12, &v20);
  v10[376] = a2;
  int v21 = a2;
  uint64_t v13 = *((void *)v10 + 195);
  if (!v13) {
    goto LABEL_6;
  }
  (*(void (**)(uint64_t, int *))(*(void *)v13 + 48))(v13, &v21);
  *((void *)v10 + 292) = a3;
  uint64_t v14 = *((void *)v10 + 300);
  if (v14
    && ((*(void (**)(uint64_t, uint64_t *))(*(void *)v14 + 48))(v14, &v19),
        *((unsigned char *)v10 + 1296) = a4,
        (uint64_t v15 = *((void *)v10 + 169)) != 0))
  {
    uint64_t result = (mlir::MPSToANECTypeConverter *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v15 + 48))(v15, &v18);
    *a5 = v10;
  }
  else
  {
LABEL_6:
    uint64_t v17 = (mlir::MPSToANECTypeConverter *)std::__throw_bad_function_call[abi:nn180100]();
    return mlir::MPSToANECTypeConverter::MPSToANECTypeConverter(v17);
  }
  return result;
}

mlir::MPSToANECTypeConverter *mlir::MPSToANECTypeConverter::MPSToANECTypeConverter(mlir::MPSToANECTypeConverter *this)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 504) = 0u;
  *(_OWORD *)((char *)this + 520) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *(_OWORD *)((char *)this + 488) = 0u;
  *(_OWORD *)((char *)this + 440) = 0u;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  unsigned int v2 = (char *)this + 232;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(void *)this = &unk_1EC9AA670;
  *((void *)this + 1) = (char *)this + 24;
  *((void *)this + 2) = 0x400000000;
  *((void *)this + 19) = (char *)this + 168;
  *((_DWORD *)this + 41) = 2;
  *((void *)this + 29) = (char *)this + 248;
  *((_DWORD *)this + 61) = 2;
  *((void *)this + 39) = (char *)this + 328;
  *((_DWORD *)this + 81) = 2;
  *((void *)this + 49) = (char *)this + 408;
  *((_DWORD *)this + 101) = 2;
  *((void *)this + 59) = 0;
  *((void *)this + 60) = 0;
  *((_DWORD *)this + 122) = 0;
  *((void *)this + 62) = 0;
  *((void *)this + 63) = 0;
  *((_DWORD *)this + 128) = 0;
  llvm::sys::RWMutexImpl::RWMutexImpl((mlir::MPSToANECTypeConverter *)((char *)this + 520));
  *((void *)this + 66) = 0;
  *(void *)this = &unk_1EC9AAE58;
  uint64_t v6 = (void (**)(void **))&unk_1EC9CFC40;
  uint64_t v7 = mlir::MPSToANECTypeConverter::canonicalizeType;
  uint64_t v8 = (void **)&v6;
  mlir::TypeConverter::registerConversion((unsigned int *)this, (uint64_t)&v6);
  if (v8 == (void **)&v6)
  {
    v6[4]((void **)&v6);
  }
  else if (v8)
  {
    (*((void (**)(void))*v8 + 5))();
  }
  uint64_t v6 = (void (**)(void **))&unk_1EC9CFBF8;
  uint64_t v7 = mlir::MPSToANECTypeConverter::tensorToMemRef;
  uint64_t v8 = (void **)&v6;
  mlir::TypeConverter::registerConversion((unsigned int *)this, (uint64_t)&v6);
  if (v8 == (void **)&v6)
  {
    v6[4]((void **)&v6);
  }
  else if (v8)
  {
    (*((void (**)(void))*v8 + 5))();
  }
  uint64_t v6 = (void (**)(void **))&unk_1EC9CFCD0;
  uint64_t v7 = mlir::MPSToANECTypeConverter::materializeTypeChange;
  uint64_t v8 = (void **)&v6;
  uint64_t v3 = *((unsigned int *)this + 60);
  if (v3 >= *((_DWORD *)this + 61))
  {
    llvm::SmallVectorTemplateBase<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>,false>::growAndEmplaceBack<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>>((uint64_t)v2, (uint64_t)&v6);
  }
  else
  {
    *(void *)(*((void *)this + 29) + 32 * v3 + 24) = *((void *)this + 29) + 32 * v3;
    (*((void (**)(void **))*v8 + 3))(v8);
    ++*((_DWORD *)this + 60);
  }
  if (v8 == (void **)&v6)
  {
    v6[4]((void **)&v6);
  }
  else if (v8)
  {
    (*((void (**)(void))*v8 + 5))();
  }
  uint64_t v6 = (void (**)(void **))&unk_1EC9CFCD0;
  uint64_t v7 = mlir::MPSToANECTypeConverter::materializeTypeChangeWithPromotion;
  uint64_t v8 = (void **)&v6;
  uint64_t v4 = *((unsigned int *)this + 80);
  if (v4 >= *((_DWORD *)this + 81))
  {
    llvm::SmallVectorTemplateBase<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>,false>::growAndEmplaceBack<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>>((uint64_t)this + 312, (uint64_t)&v6);
  }
  else
  {
    *(void *)(*((void *)this + 39) + 32 * v4 + 24) = *((void *)this + 39) + 32 * v4;
    (*((void (**)(void **))*v8 + 3))(v8);
    ++*((_DWORD *)this + 80);
  }
  if (v8 == (void **)&v6)
  {
    v6[4]((void **)&v6);
  }
  else if (v8)
  {
    (*((void (**)(void))*v8 + 5))();
  }
  return this;
}

uint64_t mlir::MPSToANECTypeConverter::canonicalizeType(uint64_t a1)
{
  if (*(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id) {
    return mlir::MPSToANECTypeConverter::canonicalizeIntegerType(a1);
  }
  return a1;
}

uint64_t mlir::MPSToANECTypeConverter::tensorToMemRef(uint64_t a1)
{
  uint64_t v21 = a1;
  uint64_t ElementType = mlir::TensorType::getElementType((mlir::TensorType *)&v21);
  uint64_t v2 = ElementType;
  if (*(_UNKNOWN **)(*(void *)ElementType + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id) {
    uint64_t v2 = mlir::MPSToANECTypeConverter::canonicalizeIntegerType(ElementType);
  }
  if (!mlir::TensorType::hasRank((mlir::TensorType *)&v21)) {
    return mlir::UnrankedMemRefType::get(v2, 0);
  }
  LOBYTE(v22[0]) = 0;
  char v23 = 0;
  uint64_t v3 = (uint64_t *)mlir::TensorType::cloneWith((uint64_t)&v21, (uint64_t)v22, v2);
  uint64_t v4 = (uint64_t)v3;
  if (!v3) {
    goto LABEL_13;
  }
  uint64_t v5 = *v3;
  unint64_t v6 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v7 = *(unsigned int *)(v5 + 16);
  if (!v7) {
    goto LABEL_13;
  }
  uint64_t v8 = *(void **)(v5 + 8);
  uint64_t v9 = &v8[2 * v7];
  do
  {
    unint64_t v10 = v7 >> 1;
    uint64_t v11 = &v8[2 * (v7 >> 1)];
    unint64_t v13 = *v11;
    uint64_t v12 = v11 + 2;
    v7 += ~(v7 >> 1);
    if (v13 < v6) {
      uint64_t v8 = v12;
    }
    else {
      unint64_t v7 = v10;
    }
  }
  while (v7);
  if (v8 != v9 && *v8 == v6) {
    uint64_t v14 = v8[1];
  }
  else {
LABEL_13:
  }
    uint64_t v14 = 0;
  v22[0] = mlir::getRankPromotionTypeForANE(v4, v14);
  v22[1] = v15;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v22);
  char v18 = v17;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v22);
  return mlir::MemRefType::get(ArgAttrsAttr, v18, OperandRange, 0, 0, 0);
}

char *mlir::MPSToANECTypeConverter::materializeTypeChange(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v10[2] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = a2;
  v10[0] = a3;
  v10[1] = a4;
  uint64_t v8 = mlir::ValueRange::dereference_iterator(v10, 0);
  return (char *)mlir::OpBuilder::create<mlir::anec::UnrealizedConversionCast,mlir::Type &,mlir::Value>(a1, a5, &v9, &v8)- 16;
}

char *mlir::MPSToANECTypeConverter::materializeTypeChangeWithPromotion(mlir::OpBuilder *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = (uint64_t)a2;
  v21[2] = *MEMORY[0x1E4F143B8];
  v21[0] = a3;
  v21[1] = a4;
  if (a2)
  {
    uint64_t v8 = *a2;
    unint64_t v9 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v10 = *(unsigned int *)(v8 + 16);
    if (!v10) {
      goto LABEL_10;
    }
    uint64_t v11 = *(void **)(v8 + 8);
    uint64_t v12 = &v11[2 * v10];
    do
    {
      unint64_t v13 = v10 >> 1;
      uint64_t v14 = &v11[2 * (v10 >> 1)];
      unint64_t v16 = *v14;
      uint64_t v15 = v14 + 2;
      v10 += ~(v10 >> 1);
      if (v16 < v9) {
        uint64_t v11 = v15;
      }
      else {
        unint64_t v10 = v13;
      }
    }
    while (v10);
    if (v11 != v12 && *v11 == v9) {
      a2 = (uint64_t *)v11[1];
    }
    else {
LABEL_10:
    }
      a2 = 0;
  }
  v20[0] = mlir::getRankPromotionTypeForANE(v6, (uint64_t)a2);
  v20[1] = v17;
  uint64_t v19 = mlir::ValueRange::dereference_iterator(v21, 0);
  return (char *)mlir::OpBuilder::create<mlir::anec::UnrealizedConversionCast,mlir::Type &,mlir::Value>(a1, a5, v20, &v19)- 16;
}

void mlir::MPSToANECTypeConverter::~MPSToANECTypeConverter(pthread_rwlock_t **this)
{
}

void sub_1807D58D8(void *__p)
{
  operator delete(__p);
}

uint64_t mlir::MPSToANECTypeConverter::canonicalizeIntegerType(uint64_t a1)
{
  uint64_t v5 = a1;
  if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&v5) > 7)
  {
    if (mlir::IntegerType::getSignedness((mlir::IntegerType *)&v5)) {
      return v5;
    }
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v5);
    unsigned int Width = mlir::IntegerType::getWidth((mlir::IntegerType *)&v5);
    uint64_t v1 = Context;
  }
  else
  {
    uint64_t v1 = mlir::Attribute::getContext((mlir::Attribute *)&v5);
    unsigned int Width = 8;
  }
  return mlir::IntegerType::get(v1, Width, 1u);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::UnrealizedConversionCast,mlir::Type &,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.unrealized_conversion_cast", (const unsigned __int8 *)0x1F, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    v17[2] = (uint64_t)"anec.unrealized_conversion_cast";
    v17[3] = 31;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Broadcast::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::UnrealizedConversionCast,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

unsigned char *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps10ConstantOpEZNS2_18MPSToANECOpCreatorC1EPNS2_11MLIRContextENS2_4anec6FamilyEbbbbbbbbjxxN4llvm9StringRefEE3__0EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSG_EUlSI_E_NS_9allocatorISM_EEFNS_8optionalIbEESI_EE7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  *(void *)uint64_t result = &unk_1EC9D1670;
  result[8] = *(unsigned char *)(a1 + 8);
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps10ConstantOpEZNS2_18MPSToANECOpCreatorC1EPNS2_11MLIRContextENS2_4anec6FamilyEbbbbbbbbjxxN4llvm9StringRefEE3__0EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSG_EUlSI_E_NS_9allocatorISM_EEFNS_8optionalIbEESI_EE7__cloneEPNS0_6__baseISR_EE(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EC9D1670;
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(result + 8);
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps10ConstantOpEZNS2_18MPSToANECOpCreatorC1EPNS2_11MLIRContextENS2_4anec6FamilyEbbbbbbbbjxxN4llvm9StringRefEE3__0EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSG_EUlSI_E_NS_9allocatorISM_EEFNS_8optionalIbEESI_EEclEOSI_(uint64_t a1, void *a2)
{
  unint64_t v2 = *(void *)(*a2 - 8) & 0xFFFFFFFFFFFFFFF8;
  if (*(_UNKNOWN **)(*(void *)v2 + 136) != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id) {
    unint64_t v2 = 0;
  }
  unint64_t v5 = v2;
  if (v2)
  {
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v5);
    LODWORD(v2) = v3 > 3;
  }
  return v2 | 0x100;
}

void mlir::ANECRegionOpCreator::ANECRegionOpCreator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = a11;
  *(void *)(a1 + 24) = a12;
  *(unsigned char *)(a1 + 32) = 0;
  *(void *)a1 = &unk_1EC9AAC18;
  mlir::ConversionTarget::ConversionTarget(a1 + 40);
}

uint64_t sub_1807D5C14(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
  *(void *)(v32 + 200) = v34;
  mlir::FrozenRewritePatternSet::FrozenRewritePatternSet(v32 + 208, v37, 0, 0, 0, 0);
  unsigned int v40 = 0;
  *(void *)(v32 + 232) = v32 + 248;
  *(void *)(v32 + 224) = &unk_1EC9C7048;
  *(void *)(v32 + 240) = 0x400000000;
  if ((unint64_t)(16 * v38) >= 0x41)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v32 + 232, (void *)(v32 + 248), (16 * v38) >> 4, 16);
    unsigned int v40 = *(_DWORD *)(v32 + 240);
  }
  size_t v41 = *(void *)(v39 + 64);
  char v42 = *(unsigned char *)(v39 + 48);
  char v43 = *(unsigned char *)(v39 + 49);
  if (v38)
  {
    memcpy((void *)(*(void *)(v32 + 232) + 16 * v40), *(const void **)(v39 + 16), 16 * v38);
    unsigned int v40 = *(_DWORD *)(v32 + 240);
  }
  *(_DWORD *)(v32 + 240) = v40 + v38;
  *(_DWORD *)(v32 + 312) = v35;
  *(unsigned char *)(v32 + 316) = v42;
  *(unsigned char *)(v32 + 317) = v43;
  *(void *)(v32 + 320) = v36;
  if (v41 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  char v44 = *(unsigned char *)(v39 + 72);
  if (v41 >= 0x17)
  {
    uint64_t v46 = (v41 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v41 | 7) != 0x17) {
      uint64_t v46 = v41 | 7;
    }
    uint64_t v47 = v46 + 1;
    uint64_t v45 = operator new(v46 + 1);
    *(void *)(v32 + 336) = v41;
    *(void *)(v32 + 344) = v47 | 0x8000000000000000;
    *(void *)(v32 + 328) = v45;
    goto LABEL_12;
  }
  uint64_t v45 = (void *)(v32 + 328);
  *(unsigned char *)(v32 + 351) = v41;
  if (v41) {
LABEL_12:
  }
    memmove(v45, *(const void **)(v39 + 56), v41);
  *((unsigned char *)v45 + v41) = 0;
  *(unsigned char *)(v32 + 352) = v44;
  int v49 = (void (**)(void **))&unk_1EC9D16B8;
  int v50 = v35;
  uint64_t v51 = (void **)&v49;
  uint64_t v52 = v54;
  v54[0] = "anec";
  v54[1] = 4;
  uint64_t v53 = 0x200000001;
  mlir::ConversionTarget::setDialectAction(v33, (uint64_t)v54, 1, 1);
  mlir::ConversionTarget::setLegalityCallback((uint64_t)v33, (uint64_t)v52, v53, &v49);
  if (v52 != v54) {
    free(v52);
  }
  if (v51 == (void **)&v49)
  {
    v49[4]((void **)&v49);
  }
  else if (v51)
  {
    (*((void (**)(void))*v51 + 5))();
  }
  uint64_t v52 = v34;
  mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A12,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::ArrayRef<llvm::StringRef>,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A12)#1}>((uint64_t)v33, (uint64_t *)&v52);
  uint64_t v52 = v34;
  mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A13,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::ArrayRef<llvm::StringRef>,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A13)#1}>((uint64_t)v33, (uint64_t *)&v52);
  uint64_t v52 = v34;
  mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A14,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::ArrayRef<llvm::StringRef>,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A14)#1}>((uint64_t)v33, (uint64_t *)&v52);
  uint64_t v52 = v34;
  mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A15,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::ArrayRef<llvm::StringRef>,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A15)#1}>((uint64_t)v33, (uint64_t *)&v52);
  uint64_t v52 = v34;
  mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A16,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::ArrayRef<llvm::StringRef>,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A16)#1}>((uint64_t)v33, (uint64_t *)&v52);
  uint64_t v52 = v34;
  mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A17,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::ArrayRef<llvm::StringRef>,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A17)#1}>((uint64_t)v33, (uint64_t *)&v52);
  uint64_t v52 = v34;
  mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A11Legacy,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::ArrayRef<llvm::StringRef>,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A11Legacy)#1}>((uint64_t)v33, (uint64_t *)&v52);
  uint64_t v52 = v34;
  mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::RegionReturn,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::ArrayRef<llvm::StringRef>,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::RegionReturn)#1}>((uint64_t)v33, (uint64_t *)&v52);
  mlir::OperationName::OperationName(&v52, "anec.unrealized_conversion_cast", 31, *(void *)(v32 + 192));
  mlir::ConversionTarget::setOpAction((uint64_t)v33, (uint64_t)v52, 2);
  return v32;
}

uint64_t mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A12,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::ArrayRef<llvm::StringRef>,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A12)#1}>(uint64_t a1, uint64_t *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a2;
  v7[0] = &unk_1EC9D1700;
  v7[1] = v3;
  uint64_t v8 = v7;
  mlir::OperationName::OperationName(&v6, "anec.A12", 8, *(void *)(a1 + 152));
  uint64_t v4 = v6;
  mlir::ConversionTarget::setOpAction(a1, v6, 1);
  mlir::ConversionTarget::setLegalityCallback(a1, v4, v7);
  uint64_t result = (uint64_t)v8;
  if (v8 == v7) {
    return (*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (*(uint64_t (**)(void))(*v8 + 40))();
  }
  return result;
}

uint64_t mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A13,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::ArrayRef<llvm::StringRef>,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A13)#1}>(uint64_t a1, uint64_t *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a2;
  v7[0] = &unk_1EC9D1748;
  v7[1] = v3;
  uint64_t v8 = v7;
  mlir::OperationName::OperationName(&v6, "anec.A13", 8, *(void *)(a1 + 152));
  uint64_t v4 = v6;
  mlir::ConversionTarget::setOpAction(a1, v6, 1);
  mlir::ConversionTarget::setLegalityCallback(a1, v4, v7);
  uint64_t result = (uint64_t)v8;
  if (v8 == v7) {
    return (*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (*(uint64_t (**)(void))(*v8 + 40))();
  }
  return result;
}

uint64_t mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A14,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::ArrayRef<llvm::StringRef>,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A14)#1}>(uint64_t a1, uint64_t *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a2;
  v7[0] = &unk_1EC9D1790;
  v7[1] = v3;
  uint64_t v8 = v7;
  mlir::OperationName::OperationName(&v6, "anec.A14", 8, *(void *)(a1 + 152));
  uint64_t v4 = v6;
  mlir::ConversionTarget::setOpAction(a1, v6, 1);
  mlir::ConversionTarget::setLegalityCallback(a1, v4, v7);
  uint64_t result = (uint64_t)v8;
  if (v8 == v7) {
    return (*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (*(uint64_t (**)(void))(*v8 + 40))();
  }
  return result;
}

uint64_t mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A15,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::ArrayRef<llvm::StringRef>,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A15)#1}>(uint64_t a1, uint64_t *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a2;
  v7[0] = &unk_1EC9D17D8;
  v7[1] = v3;
  uint64_t v8 = v7;
  mlir::OperationName::OperationName(&v6, "anec.A15", 8, *(void *)(a1 + 152));
  uint64_t v4 = v6;
  mlir::ConversionTarget::setOpAction(a1, v6, 1);
  mlir::ConversionTarget::setLegalityCallback(a1, v4, v7);
  uint64_t result = (uint64_t)v8;
  if (v8 == v7) {
    return (*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (*(uint64_t (**)(void))(*v8 + 40))();
  }
  return result;
}

uint64_t mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A16,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::ArrayRef<llvm::StringRef>,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A16)#1}>(uint64_t a1, uint64_t *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a2;
  v7[0] = &unk_1EC9D1820;
  v7[1] = v3;
  uint64_t v8 = v7;
  mlir::OperationName::OperationName(&v6, "anec.A16", 8, *(void *)(a1 + 152));
  uint64_t v4 = v6;
  mlir::ConversionTarget::setOpAction(a1, v6, 1);
  mlir::ConversionTarget::setLegalityCallback(a1, v4, v7);
  uint64_t result = (uint64_t)v8;
  if (v8 == v7) {
    return (*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (*(uint64_t (**)(void))(*v8 + 40))();
  }
  return result;
}

uint64_t mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A17,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::ArrayRef<llvm::StringRef>,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A17)#1}>(uint64_t a1, uint64_t *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a2;
  v7[0] = &unk_1EC9D1868;
  v7[1] = v3;
  uint64_t v8 = v7;
  mlir::OperationName::OperationName(&v6, "anec.A17", 8, *(void *)(a1 + 152));
  uint64_t v4 = v6;
  mlir::ConversionTarget::setOpAction(a1, v6, 1);
  mlir::ConversionTarget::setLegalityCallback(a1, v4, v7);
  uint64_t result = (uint64_t)v8;
  if (v8 == v7) {
    return (*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (*(uint64_t (**)(void))(*v8 + 40))();
  }
  return result;
}

uint64_t mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A11Legacy,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::ArrayRef<llvm::StringRef>,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A11Legacy)#1}>(uint64_t a1, uint64_t *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a2;
  v7[0] = &unk_1EC9D18B0;
  v7[1] = v3;
  uint64_t v8 = v7;
  mlir::OperationName::OperationName(&v6, "anec.A11Legacy", 14, *(void *)(a1 + 152));
  uint64_t v4 = v6;
  mlir::ConversionTarget::setOpAction(a1, v6, 1);
  mlir::ConversionTarget::setLegalityCallback(a1, v4, v7);
  uint64_t result = (uint64_t)v8;
  if (v8 == v7) {
    return (*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (*(uint64_t (**)(void))(*v8 + 40))();
  }
  return result;
}

uint64_t mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::RegionReturn,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::ArrayRef<llvm::StringRef>,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::RegionReturn)#1}>(uint64_t a1, uint64_t *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a2;
  v7[0] = &unk_1EC9D18F8;
  v7[1] = v3;
  uint64_t v8 = v7;
  mlir::OperationName::OperationName(&v6, "anec.region_return", 18, *(void *)(a1 + 152));
  uint64_t v4 = v6;
  mlir::ConversionTarget::setOpAction(a1, v6, 1);
  mlir::ConversionTarget::setLegalityCallback(a1, v4, v7);
  uint64_t result = (uint64_t)v8;
  if (v8 == v7) {
    return (*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (*(uint64_t (**)(void))(*v8 + 40))();
  }
  return result;
}

_DWORD *std::__function::__func<mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::ArrayRef<llvm::StringRef>,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::Operation *)#1},std::allocator<mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::ArrayRef<llvm::StringRef>,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::Operation *)#1}>,std::optional<BOOL> ()(mlir::Operation *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  *(void *)uint64_t result = &unk_1EC9D16B8;
  result[2] = *(_DWORD *)(a1 + 8);
  return result;
}

uint64_t std::__function::__func<mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::ArrayRef<llvm::StringRef>,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::Operation *)#1},std::allocator<mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::ArrayRef<llvm::StringRef>,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::Operation *)#1}>,std::optional<BOOL> ()(mlir::Operation *)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EC9D16B8;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(result + 8);
  return result;
}

uint64_t std::__function::__func<mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::ArrayRef<llvm::StringRef>,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::Operation *)#1},std::allocator<mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::ArrayRef<llvm::StringRef>,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::Operation *)#1}>,std::optional<BOOL> ()(mlir::Operation *)>::operator()(uint64_t a1, uint64_t *a2)
{
  return mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::ArrayRef<llvm::StringRef>,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::Operation *)#1}::operator()((int *)(a1 + 8), *a2) | 0x100u;
}

BOOL mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::ArrayRef<llvm::StringRef>,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::Operation *)#1}::operator()(int *a1, uint64_t a2)
{
  uint64_t v4 = mlir::TypeID::get<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>>();
  if ((*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 32))(*(void *)(a2 + 48), v4)) {
    return 1;
  }
  if (!mlir::verifyCompatibleTypesWithANE(a2, *a1, 1, 1)) {
    return 0;
  }
  uint64_t v6 = mlir::TypeID::get<mlir::anec::VerifyAttributesWithFamilyInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::VerifyAttributesWithFamilyInterface::Trait>(void)::Empty>>();
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 48) + 32))(*(void *)(a2 + 48), v6))
  {
    v14[0] = a2;
    v14[1] = mlir::OpInterface<mlir::anec::VerifyAttributesWithFamilyInterface,mlir::anec::detail::VerifyAttributesWithFamilyInterfaceInterfaceTraits>::getInterfaceFor(a2);
    if (!mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v14, *a1))return 0; {
  }
    }
  uint64_t v7 = mlir::TypeID::get<mlir::OpTrait::anec::SupportConstantOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::SupportConstantOperands>(void)::Empty>>();
  if (((*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 32))(*(void *)(a2 + 48), v7) & 1) == 0)
  {
    uint64_t v8 = mlir::TypeID::get<mlir::OpTrait::anec::ConstantFoldable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::ConstantFoldable>(void)::Empty>>();
    if (((*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 32))(*(void *)(a2 + 48), v8) & 1) == 0
      && (*(unsigned char *)(a2 + 46) & 0x80) != 0)
    {
      uint64_t v9 = *(unsigned int *)(a2 + 68);
      if (v9)
      {
        for (unint64_t i = (void *)(*(void *)(a2 + 72) + 24); ; i += 4)
        {
          v14[0] = *i;
          uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v14);
          if (!DefiningOp) {
            break;
          }
          uint64_t v12 = DefiningOp;
          uint64_t v13 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
          if (((*(uint64_t (**)(void, uint64_t))(**(void **)(v12 + 48) + 32))(*(void *)(v12 + 48), v13) & 1) == 0)break; {
          BOOL result = 0;
          }
          if (!--v9) {
            return result;
          }
        }
      }
    }
  }
  return mlir::anec::isCompatibleWithFamily(a2, *a1);
}

uint64_t mlir::OpInterface<mlir::anec::VerifyAttributesWithFamilyInterface,mlir::anec::detail::VerifyAttributesWithFamilyInterfaceInterfaceTraits>::getInterfaceFor(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  unint64_t v2 = *(void **)(v1 + 16);
  BOOL v3 = v2 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 48);
  }
  if (v3)
  {
    uint64_t v22 = *(void *)(v1 + 8);
    uint64_t result = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v22);
    if (result)
    {
      uint64_t v20 = result;
      uint64_t v21 = mlir::TypeID::get<mlir::anec::VerifyAttributesWithFamilyInterface>();
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v20 + 104))(v20, v21, v1);
    }
  }
  else
  {
    unint64_t v6 = v4 | v1 & 0xFFFFFFFFFFFFFF00;
    unint64_t v7 = mlir::TypeID::get<mlir::anec::VerifyAttributesWithFamilyInterface>();
    unint64_t v8 = *(unsigned int *)(v6 + 40);
    if (!v8) {
      goto LABEL_14;
    }
    uint64_t v9 = *(void **)(v6 + 32);
    char v10 = &v9[2 * v8];
    do
    {
      unint64_t v11 = v8 >> 1;
      uint64_t v12 = &v9[2 * (v8 >> 1)];
      unint64_t v14 = *v12;
      uint64_t v13 = v12 + 2;
      v8 += ~(v8 >> 1);
      if (v14 < v7) {
        uint64_t v9 = v13;
      }
      else {
        unint64_t v8 = v11;
      }
    }
    while (v8);
    if (v9 == v10 || *v9 != v7 || (uint64_t result = v9[1]) == 0)
    {
LABEL_14:
      uint64_t v16 = *(void *)(v6 + 24);
      uint64_t v17 = *(void *)(a1 + 48);
      uint64_t v18 = mlir::TypeID::get<mlir::anec::VerifyAttributesWithFamilyInterface>();
      uint64_t v19 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v16 + 104);
      return v19(v16, v18, v17);
    }
  }
  return result;
}

void *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A12EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm8ArrayRefINSJ_9StringRefEEExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOST_EUlSV_E_NS_9allocatorISZ_EEFNS_8optionalIbEESV_EE7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EC9D1700;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A12EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm8ArrayRefINSJ_9StringRefEEExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOST_EUlSV_E_NS_9allocatorISZ_EEFNS_8optionalIbEESV_EE7__cloneEPNS0_6__baseIS14_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EC9D1700;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A12EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm8ArrayRefINSJ_9StringRefEEExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOST_EUlSV_E_NS_9allocatorISZ_EEFNS_8optionalIbEESV_EEclEOSV_(uint64_t a1, mlir::Operation **a2)
{
  unint64_t v5 = *a2;
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
  return mlir::TypeConverter::isSignatureLegal(v2, FunctionType) | 0x100u;
}

void *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A13EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm8ArrayRefINSJ_9StringRefEEExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOST_EUlSV_E_NS_9allocatorISZ_EEFNS_8optionalIbEESV_EE7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EC9D1748;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A13EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm8ArrayRefINSJ_9StringRefEEExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOST_EUlSV_E_NS_9allocatorISZ_EEFNS_8optionalIbEESV_EE7__cloneEPNS0_6__baseIS14_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EC9D1748;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A13EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm8ArrayRefINSJ_9StringRefEEExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOST_EUlSV_E_NS_9allocatorISZ_EEFNS_8optionalIbEESV_EEclEOSV_(uint64_t a1, mlir::Operation **a2)
{
  unint64_t v5 = *a2;
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
  return mlir::TypeConverter::isSignatureLegal(v2, FunctionType) | 0x100u;
}

void *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A14EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm8ArrayRefINSJ_9StringRefEEExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOST_EUlSV_E_NS_9allocatorISZ_EEFNS_8optionalIbEESV_EE7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EC9D1790;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A14EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm8ArrayRefINSJ_9StringRefEEExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOST_EUlSV_E_NS_9allocatorISZ_EEFNS_8optionalIbEESV_EE7__cloneEPNS0_6__baseIS14_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EC9D1790;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A14EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm8ArrayRefINSJ_9StringRefEEExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOST_EUlSV_E_NS_9allocatorISZ_EEFNS_8optionalIbEESV_EEclEOSV_(uint64_t a1, mlir::Operation **a2)
{
  unint64_t v5 = *a2;
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
  return mlir::TypeConverter::isSignatureLegal(v2, FunctionType) | 0x100u;
}

void *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A15EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm8ArrayRefINSJ_9StringRefEEExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOST_EUlSV_E_NS_9allocatorISZ_EEFNS_8optionalIbEESV_EE7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EC9D17D8;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A15EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm8ArrayRefINSJ_9StringRefEEExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOST_EUlSV_E_NS_9allocatorISZ_EEFNS_8optionalIbEESV_EE7__cloneEPNS0_6__baseIS14_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EC9D17D8;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A15EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm8ArrayRefINSJ_9StringRefEEExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOST_EUlSV_E_NS_9allocatorISZ_EEFNS_8optionalIbEESV_EEclEOSV_(uint64_t a1, mlir::Operation **a2)
{
  unint64_t v5 = *a2;
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
  return mlir::TypeConverter::isSignatureLegal(v2, FunctionType) | 0x100u;
}

void *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A16EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm8ArrayRefINSJ_9StringRefEEExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOST_EUlSV_E_NS_9allocatorISZ_EEFNS_8optionalIbEESV_EE7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EC9D1820;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A16EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm8ArrayRefINSJ_9StringRefEEExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOST_EUlSV_E_NS_9allocatorISZ_EEFNS_8optionalIbEESV_EE7__cloneEPNS0_6__baseIS14_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EC9D1820;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A16EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm8ArrayRefINSJ_9StringRefEEExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOST_EUlSV_E_NS_9allocatorISZ_EEFNS_8optionalIbEESV_EEclEOSV_(uint64_t a1, mlir::Operation **a2)
{
  unint64_t v5 = *a2;
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
  return mlir::TypeConverter::isSignatureLegal(v2, FunctionType) | 0x100u;
}

void *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A17EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm8ArrayRefINSJ_9StringRefEEExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOST_EUlSV_E_NS_9allocatorISZ_EEFNS_8optionalIbEESV_EE7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EC9D1868;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A17EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm8ArrayRefINSJ_9StringRefEEExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOST_EUlSV_E_NS_9allocatorISZ_EEFNS_8optionalIbEESV_EE7__cloneEPNS0_6__baseIS14_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EC9D1868;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A17EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm8ArrayRefINSJ_9StringRefEEExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOST_EUlSV_E_NS_9allocatorISZ_EEFNS_8optionalIbEESV_EEclEOSV_(uint64_t a1, mlir::Operation **a2)
{
  unint64_t v5 = *a2;
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
  return mlir::TypeConverter::isSignatureLegal(v2, FunctionType) | 0x100u;
}

void *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec9A11LegacyEZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm8ArrayRefINSJ_9StringRefEEExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOST_EUlSV_E_NS_9allocatorISZ_EEFNS_8optionalIbEESV_EE7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EC9D18B0;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec9A11LegacyEZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm8ArrayRefINSJ_9StringRefEEExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOST_EUlSV_E_NS_9allocatorISZ_EEFNS_8optionalIbEESV_EE7__cloneEPNS0_6__baseIS14_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EC9D18B0;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec9A11LegacyEZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm8ArrayRefINSJ_9StringRefEEExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOST_EUlSV_E_NS_9allocatorISZ_EEFNS_8optionalIbEESV_EEclEOSV_(uint64_t a1, mlir::Operation **a2)
{
  unint64_t v5 = *a2;
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
  return mlir::TypeConverter::isSignatureLegal(v2, FunctionType) | 0x100u;
}

void *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec12RegionReturnEZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm8ArrayRefINSJ_9StringRefEEExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOST_EUlSV_E_NS_9allocatorISZ_EEFNS_8optionalIbEESV_EE7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EC9D18F8;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec12RegionReturnEZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm8ArrayRefINSJ_9StringRefEEExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOST_EUlSV_E_NS_9allocatorISZ_EEFNS_8optionalIbEESV_EE7__cloneEPNS0_6__baseIS14_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EC9D18F8;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec12RegionReturnEZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm8ArrayRefINSJ_9StringRefEEExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOST_EUlSV_E_NS_9allocatorISZ_EEFNS_8optionalIbEESV_EEclEOSV_(uint64_t a1, mlir::Operation **a2)
{
  return mlir::TypeConverter::isLegal(*(mlir::TypeConverter **)(a1 + 8), *a2) | 0x100u;
}

uint64_t mlir::MPSToANECBase<mlir::anonymous namespace'::MPSToANEC>::MPSToANECBase(uint64_t a1)
{
  v11[20] = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 16) = "builtin.module";
  *(void *)(a1 + 24) = 14;
  *(unsigned char *)(a1 + 32) = 1;
  *(unsigned char *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 120) = 0;
  uint64_t v2 = (void *)(a1 + 152);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = a1 + 200;
  *(void *)(a1 + 192) = 0x400000000;
  *(void *)(a1 + 232) = a1 + 248;
  *(void *)(a1 + 240) = 0x400000000;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 296) = 0x1000000000;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(void *)(a1 + 336) = 0;
  *(void *)a1 = &unk_1EC9AA428;
  uint64_t v3 = (void *)(a1 + 344);
  *(void *)&long long v9 = "The family to target for ANEC region formation (default A12).";
  *((void *)&v9 + 1) = 61;
  int v7 = 0;
  uint64_t v8 = (uint64_t)&v7;
  v10.n128_u64[0] = (unint64_t)v11;
  v10.n128_u64[1] = 0x400000000;
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v10, v11, 7uLL, 40);
  unsigned __int32 v4 = v10.n128_u32[2];
  unint64_t v5 = v10.n128_u64[0] + 40 * v10.n128_u32[2];
  *(void *)unint64_t v5 = "A12";
  *(void *)(v5 + 8) = 3;
  *(_DWORD *)(v5 + 16) = 0;
  *(void *)(v5 + 24) = "A12 family";
  *(void *)(v5 + 32) = 10;
  *(void *)(v5 + 40) = "A13";
  *(void *)(v5 + 48) = 3;
  *(_DWORD *)(v5 + 56) = 1;
  *(void *)(v5 + 64) = "A13 family";
  *(void *)(v5 + 72) = 10;
  *(void *)(v5 + 80) = "A14";
  *(void *)(v5 + 88) = 3;
  *(_DWORD *)(v5 + 96) = 2;
  *(void *)(v5 + 104) = "A14 family";
  *(void *)(v5 + 112) = 10;
  *(void *)(v5 + 120) = "A15";
  *(void *)(v5 + 128) = 3;
  *(_DWORD *)(v5 + 136) = 3;
  *(void *)(v5 + 144) = "A15 family";
  *(void *)(v5 + 152) = 10;
  *(void *)(v5 + 160) = "A16";
  *(void *)(v5 + 168) = 3;
  *(_DWORD *)(v5 + 176) = 4;
  *(void *)(v5 + 184) = "A16 family";
  *(void *)(v5 + 192) = 10;
  *(void *)(v5 + 200) = "A17";
  *(void *)(v5 + 208) = 3;
  *(_DWORD *)(v5 + 216) = 5;
  *(void *)(v5 + 224) = "A17 family";
  *(void *)(v5 + 232) = 10;
  *(void *)(v5 + 240) = "A11Legacy";
  *(void *)(v5 + 248) = 9;
  *(_DWORD *)(v5 + 256) = 6;
  *(void *)(v5 + 264) = "A11 Legacy family";
  *(void *)(v5 + 272) = 17;
  v10.n128_u32[2] = v4 + 7;
  mlir::detail::PassOptions::Option<mlir::anec::Family,mlir::detail::PassOptions::GenericOptionParser<mlir::anec::Family>>::Option<llvm::cl::desc,llvm::cl::initializer<mlir::anec::Family>,llvm::cl::ValuesClass>(v3, v2, (uint64_t)"target-family", 13, &v9, (_DWORD **)&v8, (uint64_t *)&v10);
  *(void *)(a1 + 344) = &unk_1EC9CAEE0;
  *(void *)(a1 + 944) = &unk_1EC9CAF60;
  if ((void *)v10.n128_u64[0] != v11) {
    free((void *)v10.n128_u64[0]);
  }
  v10.n128_u64[0] = (unint64_t)"If device hints cannot be followed then compilation has failed.";
  v10.n128_u64[1] = 63;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 960), v2, (uint64_t)"strict-hints", 12, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 960) = &unk_1EC9CB060;
  *(void *)(a1 + 1152) = &unk_1EC9CB0E0;
  v10.n128_u64[0] = (unint64_t)"If true, the ANEC macho procedure will follow the MPS host function name. If false"
                                      ", it will use the ANEC region symbol name instead.";
  v10.n128_u64[1] = 132;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 1168), v2, (uint64_t)"use-function-name-for-anec-procedure", 36, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 1168) = &unk_1EC9CB060;
  *(void *)(a1 + 1360) = &unk_1EC9CB0E0;
  v10.n128_u64[0] = (unint64_t)"If true, placement uses the cost model.";
  v10.n128_u64[1] = 39;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 1376), v2, (uint64_t)"use-cost-model", 14, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 1376) = &unk_1EC9CB060;
  *(void *)(a1 + 1568) = &unk_1EC9CB0E0;
  v10.n128_u64[0] = (unint64_t)"If true, everything will be placed on the host. (requires use-cost-model)";
  v10.n128_u64[1] = 73;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 1584), v2, (uint64_t)"force-host-placement", 20, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 1584) = &unk_1EC9CB060;
  *(void *)(a1 + 1776) = &unk_1EC9CB0E0;
  v10.n128_u64[0] = (unint64_t)"If true, everything will be placed on the ane if possible. (requires use-cost-model)";
  v10.n128_u64[1] = 84;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 1792), v2, (uint64_t)"force-ane-placement", 19, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 1792) = &unk_1EC9CB060;
  *(void *)(a1 + 1984) = &unk_1EC9CB0E0;
  v10.n128_u64[0] = (unint64_t)"If true, print the estimated cost of the resulting module (requires use-cost-model).";
  v10.n128_u64[1] = 84;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 2000), v2, (uint64_t)"print-estimated-cost", 20, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 2000) = &unk_1EC9CB060;
  *(void *)(a1 + 2192) = &unk_1EC9CB0E0;
  v10.n128_u64[0] = (unint64_t)"Insert instrumentation to enable performance recording.";
  v10.n128_u64[1] = 55;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 2208), v2, (uint64_t)"insert-instrumentation", 22, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 2208) = &unk_1EC9CB060;
  *(void *)(a1 + 2400) = &unk_1EC9CB0E0;
  v10.n128_u64[0] = (unint64_t)"The maximum number of mps operations that will be used to create an ANE region.";
  v10.n128_u64[1] = 79;
  uint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::Option<llvm::cl::desc,llvm::cl::initializer<long long>>((void *)(a1 + 2416), v2, (uint64_t)"ane-max-ops", 11, &v10, (void **)&v9);
  *(void *)(a1 + 2416) = &unk_1EC9CB1E0;
  *(void *)(a1 + 2616) = &unk_1EC9CB260;
  v10.n128_u64[0] = (unint64_t)"The maximum number of cumulative liveIns and liveOuts for an ANE region.";
  v10.n128_u64[1] = 72;
  uint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::Option<llvm::cl::desc,llvm::cl::initializer<long long>>((void *)(a1 + 2632), v2, (uint64_t)"ane-max-liveio", 14, &v10, (void **)&v9);
  *(void *)(a1 + 2632) = &unk_1EC9CB1E0;
  *(void *)(a1 + 2832) = &unk_1EC9CB260;
  v10.n128_u64[0] = (unint64_t)"The number of gpu cores.";
  v10.n128_u64[1] = 24;
  LODWORD(v8) = 1;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::initializer<int>>((void *)(a1 + 2848), v2, (uint64_t)"gpu-core-count", 14, &v10, (int **)&v9);
  *(void *)(a1 + 2848) = &unk_1EC9CB120;
  *(void *)(a1 + 3040) = &unk_1EC9CB1A0;
  v10.n128_u64[0] = (unint64_t)"If true, print a report of which ops failed to be placed on ANE.";
  v10.n128_u64[1] = 64;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 3056), v2, (uint64_t)"print-placement-report", 22, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 3056) = &unk_1EC9CB060;
  *(void *)(a1 + 3248) = &unk_1EC9CB0E0;
  v10.n128_u64[0] = (unint64_t)"Postfix appended to the name of the ANE regions created.";
  v10.n128_u64[1] = 56;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((void *)(a1 + 3264), v2, (uint64_t)"region-name-postfix", 19, &v10);
  *(void *)(a1 + 3264) = &unk_1EC9CAFA0;
  *(void *)(a1 + 3496) = &unk_1EC9CB020;
  v10.n128_u64[0] = (unint64_t)"If true, use GOC and quantimization patterns to optimzie the ANEC IR.";
  v10.n128_u64[1] = 69;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 3512), v2, (uint64_t)"legacy-quant-conversion", 23, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 3512) = &unk_1EC9CB060;
  *(void *)(a1 + 3704) = &unk_1EC9CB0E0;
  return a1;
}

void mlir::anonymous namespace'::MPSToANEC::~MPSToANEC(mlir::_anonymous_namespace_::MPSToANEC *this)
{
  *(void *)this = &unk_1EC9AA428;
  *((void *)this + 439) = &unk_1EC9A3F00;
  uint64_t v2 = (char *)this + 3672;
  uint64_t v3 = (char *)*((void *)this + 462);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  *((void *)this + 439) = &unk_1EC9A42A8;
  unsigned __int32 v4 = (void *)*((void *)this + 451);
  if (v4 != *((void **)this + 450)) {
    free(v4);
  }
  unint64_t v5 = (char *)*((void *)this + 447);
  if (v5 != (char *)this + 3592) {
    free(v5);
  }
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 3264);
  *((void *)this + 382) = &unk_1EC9A3F00;
  unint64_t v6 = (mlir::_anonymous_namespace_::MPSToANEC *)*((void *)this + 405);
  if (v6 == (mlir::_anonymous_namespace_::MPSToANEC *)((char *)this + 3216))
  {
    (*(void (**)(char *))(*((void *)this + 402) + 32))((char *)this + 3216);
  }
  else if (v6)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANEC *))(*(void *)v6 + 40))(v6);
  }
  *((void *)this + 382) = &unk_1EC9A42A8;
  int v7 = (void *)*((void *)this + 394);
  if (v7 != *((void **)this + 393)) {
    free(v7);
  }
  uint64_t v8 = (char *)*((void *)this + 390);
  if (v8 != (char *)this + 3136) {
    free(v8);
  }
  *((void *)this + 356) = &unk_1EC9A3FD0;
  long long v9 = (mlir::_anonymous_namespace_::MPSToANEC *)*((void *)this + 379);
  if (v9 == (mlir::_anonymous_namespace_::MPSToANEC *)((char *)this + 3008))
  {
    (*(void (**)(char *))(*((void *)this + 376) + 32))((char *)this + 3008);
  }
  else if (v9)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANEC *))(*(void *)v9 + 40))(v9);
  }
  *((void *)this + 356) = &unk_1EC9A42A8;
  __n128 v10 = (void *)*((void *)this + 368);
  if (v10 != *((void **)this + 367)) {
    free(v10);
  }
  unint64_t v11 = (char *)*((void *)this + 364);
  if (v11 != (char *)this + 2928) {
    free(v11);
  }
  *((void *)this + 329) = &unk_1EC9A4038;
  uint64_t v12 = (mlir::_anonymous_namespace_::MPSToANEC *)*((void *)this + 353);
  if (v12 == (mlir::_anonymous_namespace_::MPSToANEC *)((char *)this + 2800))
  {
    (*(void (**)(char *))(*((void *)this + 350) + 32))((char *)this + 2800);
  }
  else if (v12)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANEC *))(*(void *)v12 + 40))(v12);
  }
  *((void *)this + 329) = &unk_1EC9A42A8;
  uint64_t v13 = (void *)*((void *)this + 341);
  if (v13 != *((void **)this + 340)) {
    free(v13);
  }
  unint64_t v14 = (char *)*((void *)this + 337);
  if (v14 != (char *)this + 2712) {
    free(v14);
  }
  *((void *)this + 302) = &unk_1EC9A4038;
  uint64_t v15 = (mlir::_anonymous_namespace_::MPSToANEC *)*((void *)this + 326);
  if (v15 == (mlir::_anonymous_namespace_::MPSToANEC *)((char *)this + 2584))
  {
    (*(void (**)(char *))(*((void *)this + 323) + 32))((char *)this + 2584);
  }
  else if (v15)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANEC *))(*(void *)v15 + 40))(v15);
  }
  *((void *)this + 302) = &unk_1EC9A42A8;
  uint64_t v16 = (void *)*((void *)this + 314);
  if (v16 != *((void **)this + 313)) {
    free(v16);
  }
  uint64_t v17 = (char *)*((void *)this + 310);
  if (v17 != (char *)this + 2496) {
    free(v17);
  }
  *((void *)this + 276) = &unk_1EC9A3F00;
  uint64_t v18 = (mlir::_anonymous_namespace_::MPSToANEC *)*((void *)this + 299);
  if (v18 == (mlir::_anonymous_namespace_::MPSToANEC *)((char *)this + 2368))
  {
    (*(void (**)(char *))(*((void *)this + 296) + 32))((char *)this + 2368);
  }
  else if (v18)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANEC *))(*(void *)v18 + 40))(v18);
  }
  *((void *)this + 276) = &unk_1EC9A42A8;
  uint64_t v19 = (void *)*((void *)this + 288);
  if (v19 != *((void **)this + 287)) {
    free(v19);
  }
  uint64_t v20 = (char *)*((void *)this + 284);
  if (v20 != (char *)this + 2288) {
    free(v20);
  }
  *((void *)this + 250) = &unk_1EC9A3F00;
  uint64_t v21 = (mlir::_anonymous_namespace_::MPSToANEC *)*((void *)this + 273);
  if (v21 == (mlir::_anonymous_namespace_::MPSToANEC *)((char *)this + 2160))
  {
    (*(void (**)(char *))(*((void *)this + 270) + 32))((char *)this + 2160);
  }
  else if (v21)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANEC *))(*(void *)v21 + 40))(v21);
  }
  *((void *)this + 250) = &unk_1EC9A42A8;
  uint64_t v22 = (void *)*((void *)this + 262);
  if (v22 != *((void **)this + 261)) {
    free(v22);
  }
  char v23 = (char *)*((void *)this + 258);
  if (v23 != (char *)this + 2080) {
    free(v23);
  }
  *((void *)this + 224) = &unk_1EC9A3F00;
  int v24 = (mlir::_anonymous_namespace_::MPSToANEC *)*((void *)this + 247);
  if (v24 == (mlir::_anonymous_namespace_::MPSToANEC *)((char *)this + 1952))
  {
    (*(void (**)(char *))(*((void *)this + 244) + 32))((char *)this + 1952);
  }
  else if (v24)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANEC *))(*(void *)v24 + 40))(v24);
  }
  *((void *)this + 224) = &unk_1EC9A42A8;
  uint64_t v25 = (void *)*((void *)this + 236);
  if (v25 != *((void **)this + 235)) {
    free(v25);
  }
  long long v26 = (char *)*((void *)this + 232);
  if (v26 != (char *)this + 1872) {
    free(v26);
  }
  *((void *)this + 198) = &unk_1EC9A3F00;
  uint64_t v27 = (mlir::_anonymous_namespace_::MPSToANEC *)*((void *)this + 221);
  if (v27 == (mlir::_anonymous_namespace_::MPSToANEC *)((char *)this + 1744))
  {
    (*(void (**)(char *))(*((void *)this + 218) + 32))((char *)this + 1744);
  }
  else if (v27)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANEC *))(*(void *)v27 + 40))(v27);
  }
  *((void *)this + 198) = &unk_1EC9A42A8;
  int v28 = (void *)*((void *)this + 210);
  if (v28 != *((void **)this + 209)) {
    free(v28);
  }
  uint64_t v29 = (char *)*((void *)this + 206);
  if (v29 != (char *)this + 1664) {
    free(v29);
  }
  *((void *)this + 172) = &unk_1EC9A3F00;
  long long v30 = (mlir::_anonymous_namespace_::MPSToANEC *)*((void *)this + 195);
  if (v30 == (mlir::_anonymous_namespace_::MPSToANEC *)((char *)this + 1536))
  {
    (*(void (**)(char *))(*((void *)this + 192) + 32))((char *)this + 1536);
  }
  else if (v30)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANEC *))(*(void *)v30 + 40))(v30);
  }
  *((void *)this + 172) = &unk_1EC9A42A8;
  uint64_t v31 = (void *)*((void *)this + 184);
  if (v31 != *((void **)this + 183)) {
    free(v31);
  }
  uint64_t v32 = (char *)*((void *)this + 180);
  if (v32 != (char *)this + 1456) {
    free(v32);
  }
  *((void *)this + 146) = &unk_1EC9A3F00;
  uint64_t v33 = (mlir::_anonymous_namespace_::MPSToANEC *)*((void *)this + 169);
  if (v33 == (mlir::_anonymous_namespace_::MPSToANEC *)((char *)this + 1328))
  {
    (*(void (**)(char *))(*((void *)this + 166) + 32))((char *)this + 1328);
  }
  else if (v33)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANEC *))(*(void *)v33 + 40))(v33);
  }
  *((void *)this + 146) = &unk_1EC9A42A8;
  char v34 = (void *)*((void *)this + 158);
  if (v34 != *((void **)this + 157)) {
    free(v34);
  }
  int v35 = (char *)*((void *)this + 154);
  if (v35 != (char *)this + 1248) {
    free(v35);
  }
  *((void *)this + 120) = &unk_1EC9A3F00;
  uint64_t v36 = (mlir::_anonymous_namespace_::MPSToANEC *)*((void *)this + 143);
  if (v36 == (mlir::_anonymous_namespace_::MPSToANEC *)((char *)this + 1120))
  {
    (*(void (**)(char *))(*((void *)this + 140) + 32))((char *)this + 1120);
  }
  else if (v36)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANEC *))(*(void *)v36 + 40))(v36);
  }
  *((void *)this + 120) = &unk_1EC9A42A8;
  uint64_t v37 = (void *)*((void *)this + 132);
  if (v37 != *((void **)this + 131)) {
    free(v37);
  }
  uint64_t v38 = (char *)*((void *)this + 128);
  if (v38 != (char *)this + 1040) {
    free(v38);
  }
  mlir::detail::PassOptions::Option<mlir::anec::Family,mlir::detail::PassOptions::GenericOptionParser<mlir::anec::Family>>::~Option((void *)this + 43);

  mlir::Pass::~Pass(this);
}

{
  void *v1;
  uint64_t vars8;

  operator delete(v1);
}

const char *mlir::MPSToANECBase<mlir::anonymous namespace'::MPSToANEC>::getName()
{
  return "MPSToANEC";
}

void *mlir::MPSToANECBase<mlir::anonymous namespace'::MPSToANEC>::getDependentDialects(int a1, uint64_t **a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v4[0] = &unk_1EC9CF0D8;
  unint64_t v5 = v4;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::placement::PlacementDialect,void>::id, "placement", 9uLL, v4);
  if (v5 == v4)
  {
    (*(void (**)(void *))(v4[0] + 32))(v4);
  }
  else if (v5)
  {
    (*(void (**)(void))(*v5 + 40))();
  }
  v4[0] = &unk_1EC9CEF70;
  unint64_t v5 = v4;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::anec::ANECDialect,void>::id, "anec", 4uLL, v4);
  if (v5 == v4)
  {
    (*(void (**)(void *))(v4[0] + 32))(v4);
  }
  else if (v5)
  {
    (*(void (**)(void))(*v5 + 40))();
  }
  v4[0] = &unk_1EC9CEEE0;
  unint64_t v5 = v4;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::mps::MPSDialect,void>::id, "mps", 3uLL, v4);
  if (v5 == v4)
  {
    (*(void (**)(void *))(v4[0] + 32))(v4);
  }
  else if (v5)
  {
    (*(void (**)(void))(*v5 + 40))();
  }
  v4[0] = &unk_1EC9CF000;
  unint64_t v5 = v4;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::mpsx::MPSXDialect,void>::id, "mpsx", 4uLL, v4);
  if (v5 == v4)
  {
    (*(void (**)(void *))(v4[0] + 32))(v4);
  }
  else if (v5)
  {
    (*(void (**)(void))(*v5 + 40))();
  }
  v4[0] = &unk_1EC9CF048;
  unint64_t v5 = v4;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::memref::MemRefDialect,void>::id, "memref", 6uLL, v4);
  uint64_t result = v5;
  if (v5 == v4) {
    return (void *)(*(uint64_t (**)(void *))(v4[0] + 32))(v4);
  }
  if (v5) {
    return (void *)(*(uint64_t (**)(void))(*v5 + 40))();
  }
  return result;
}

const char *mlir::MPSToANECBase<mlir::anonymous namespace'::MPSToANEC>::getArgument()
{
  return "mps-to-anec";
}

const char *mlir::MPSToANECBase<mlir::anonymous namespace'::MPSToANEC>::getDescription()
{
  return "Convert mps ops to anec ops if possible and create regions for ane";
}

void mlir::anonymous namespace'::MPSToANEC::runOnOperation(mlir::_anonymous_namespace_::MPSToANEC *this)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)((*((void *)this + 5) & 0xFFFFFFFFFFFFFFF8) + 24));
  uint64_t v3 = (char *)this + 3392;
  uint64_t v4 = *((unsigned __int8 *)this + 3415);
  if ((v4 & 0x80u) != 0)
  {
    uint64_t v3 = (char *)*((void *)this + 424);
    uint64_t v4 = *((void *)this + 425);
  }
  mlir::MPSToANECOpCreator::MPSToANECOpCreator((uint64_t)v5, Context, *((unsigned int *)this + 118), *((unsigned char *)this + 3640), 0, *((unsigned __int8 *)this + 1504), *((unsigned char *)this + 1920), *((unsigned char *)this + 1712), *((unsigned char *)this + 2128), *((unsigned char *)this + 2336), *((unsigned char *)this + 1088), *((_DWORD *)this + 744), *((void *)this + 318), *((void *)this + 345), (uint64_t)v3, v4);
}

void sub_1807D8A28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  uint64_t v69 = a69;
  a69 = 0;
  if (v69) {
    (*(void (**)(uint64_t))(*(void *)v69 + 8))(v69);
  }
  mlir::ConversionTarget::~ConversionTarget((mlir::ConversionTarget *)&a35);
}

uint64_t sub_1807D8A64()
{
  uint64_t result = v1;
  if (v1) {
    return (*(uint64_t (**)())(*(void *)v1 + 8))();
  }
  return result;
}

void *mlir::MPSToANECBase<mlir::anonymous namespace'::MPSToANEC>::clonePass@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  v14[20] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (char *)operator new(0xE88uLL);
  uint64_t v5 = *(void *)(a1 + 8);
  *((_OWORD *)v4 + 1) = *(_OWORD *)(a1 + 16);
  *((void *)v4 + 4) = *(void *)(a1 + 32);
  *((void *)v4 + 1) = v5;
  v4[40] = 0;
  v4[120] = 0;
  uint64_t v6 = v4 + 152;
  *((_OWORD *)v4 + 8) = 0u;
  *((_OWORD *)v4 + 9) = 0u;
  *((_OWORD *)v4 + 10) = 0u;
  *((void *)v4 + 22) = 0;
  *((void *)v4 + 23) = v4 + 200;
  *((void *)v4 + 24) = 0x400000000;
  *((void *)v4 + 29) = v4 + 248;
  *((void *)v4 + 30) = 0x400000000;
  *((void *)v4 + 35) = 0;
  *((void *)v4 + 36) = 0;
  *((_DWORD *)v4 + 74) = 0;
  *((_DWORD *)v4 + 75) = 16;
  *((_OWORD *)v4 + 19) = 0u;
  *((_OWORD *)v4 + 20) = 0u;
  *((void *)v4 + 42) = 0;
  *(void *)uint64_t v4 = &unk_1EC9AA428;
  *(void *)&long long v12 = "The family to target for ANEC region formation (default A12).";
  *((void *)&v12 + 1) = 61;
  int v10 = 0;
  uint64_t v11 = (uint64_t)&v10;
  v13.n128_u64[0] = (unint64_t)v14;
  v13.n128_u64[1] = 0x400000000;
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v14, 7uLL, 40);
  unsigned __int32 v7 = v13.n128_u32[2];
  unint64_t v8 = v13.n128_u64[0] + 40 * v13.n128_u32[2];
  *(void *)unint64_t v8 = "A12";
  *(void *)(v8 + 8) = 3;
  *(_DWORD *)(v8 + 16) = 0;
  *(void *)(v8 + 24) = "A12 family";
  *(void *)(v8 + 32) = 10;
  *(void *)(v8 + 40) = "A13";
  *(void *)(v8 + 48) = 3;
  *(_DWORD *)(v8 + 56) = 1;
  *(void *)(v8 + 64) = "A13 family";
  *(void *)(v8 + 72) = 10;
  *(void *)(v8 + 80) = "A14";
  *(void *)(v8 + 88) = 3;
  *(_DWORD *)(v8 + 96) = 2;
  *(void *)(v8 + 104) = "A14 family";
  *(void *)(v8 + 112) = 10;
  *(void *)(v8 + 120) = "A15";
  *(void *)(v8 + 128) = 3;
  *(_DWORD *)(v8 + 136) = 3;
  *(void *)(v8 + 144) = "A15 family";
  *(void *)(v8 + 152) = 10;
  *(void *)(v8 + 160) = "A16";
  *(void *)(v8 + 168) = 3;
  *(_DWORD *)(v8 + 176) = 4;
  *(void *)(v8 + 184) = "A16 family";
  *(void *)(v8 + 192) = 10;
  *(void *)(v8 + 200) = "A17";
  *(void *)(v8 + 208) = 3;
  *(_DWORD *)(v8 + 216) = 5;
  *(void *)(v8 + 224) = "A17 family";
  *(void *)(v8 + 232) = 10;
  *(void *)(v8 + 240) = "A11Legacy";
  *(void *)(v8 + 248) = 9;
  *(_DWORD *)(v8 + 256) = 6;
  *(void *)(v8 + 264) = "A11 Legacy family";
  *(void *)(v8 + 272) = 17;
  v13.n128_u32[2] = v7 + 7;
  mlir::detail::PassOptions::Option<mlir::anec::Family,mlir::detail::PassOptions::GenericOptionParser<mlir::anec::Family>>::Option<llvm::cl::desc,llvm::cl::initializer<mlir::anec::Family>,llvm::cl::ValuesClass>((void *)v4 + 43, (void *)v4 + 19, (uint64_t)"target-family", 13, &v12, (_DWORD **)&v11, (uint64_t *)&v13);
  *((void *)v4 + 43) = &unk_1EC9CAEE0;
  *((void *)v4 + 118) = &unk_1EC9CAF60;
  if ((void *)v13.n128_u64[0] != v14) {
    free((void *)v13.n128_u64[0]);
  }
  v13.n128_u64[0] = (unint64_t)"If device hints cannot be followed then compilation has failed.";
  v13.n128_u64[1] = 63;
  LOBYTE(v11) = 0;
  *(void *)&long long v12 = &v11;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)v4 + 120, v6, (uint64_t)"strict-hints", 12, &v13, (unsigned char **)&v12);
  *((void *)v4 + 120) = &unk_1EC9CB060;
  *((void *)v4 + 144) = &unk_1EC9CB0E0;
  v13.n128_u64[0] = (unint64_t)"If true, the ANEC macho procedure will follow the MPS host function name. If false"
                                      ", it will use the ANEC region symbol name instead.";
  v13.n128_u64[1] = 132;
  LOBYTE(v11) = 0;
  *(void *)&long long v12 = &v11;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)v4 + 146, v6, (uint64_t)"use-function-name-for-anec-procedure", 36, &v13, (unsigned char **)&v12);
  *((void *)v4 + 146) = &unk_1EC9CB060;
  *((void *)v4 + 170) = &unk_1EC9CB0E0;
  v13.n128_u64[0] = (unint64_t)"If true, placement uses the cost model.";
  v13.n128_u64[1] = 39;
  LOBYTE(v11) = 0;
  *(void *)&long long v12 = &v11;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)v4 + 172, v6, (uint64_t)"use-cost-model", 14, &v13, (unsigned char **)&v12);
  *((void *)v4 + 172) = &unk_1EC9CB060;
  *((void *)v4 + 196) = &unk_1EC9CB0E0;
  v13.n128_u64[0] = (unint64_t)"If true, everything will be placed on the host. (requires use-cost-model)";
  v13.n128_u64[1] = 73;
  LOBYTE(v11) = 0;
  *(void *)&long long v12 = &v11;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)v4 + 198, v6, (uint64_t)"force-host-placement", 20, &v13, (unsigned char **)&v12);
  *((void *)v4 + 198) = &unk_1EC9CB060;
  *((void *)v4 + 222) = &unk_1EC9CB0E0;
  v13.n128_u64[0] = (unint64_t)"If true, everything will be placed on the ane if possible. (requires use-cost-model)";
  v13.n128_u64[1] = 84;
  LOBYTE(v11) = 0;
  *(void *)&long long v12 = &v11;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)v4 + 224, v6, (uint64_t)"force-ane-placement", 19, &v13, (unsigned char **)&v12);
  *((void *)v4 + 224) = &unk_1EC9CB060;
  *((void *)v4 + 248) = &unk_1EC9CB0E0;
  v13.n128_u64[0] = (unint64_t)"If true, print the estimated cost of the resulting module (requires use-cost-model).";
  v13.n128_u64[1] = 84;
  LOBYTE(v11) = 0;
  *(void *)&long long v12 = &v11;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)v4 + 250, v6, (uint64_t)"print-estimated-cost", 20, &v13, (unsigned char **)&v12);
  *((void *)v4 + 250) = &unk_1EC9CB060;
  *((void *)v4 + 274) = &unk_1EC9CB0E0;
  v13.n128_u64[0] = (unint64_t)"Insert instrumentation to enable performance recording.";
  v13.n128_u64[1] = 55;
  LOBYTE(v11) = 0;
  *(void *)&long long v12 = &v11;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)v4 + 276, v6, (uint64_t)"insert-instrumentation", 22, &v13, (unsigned char **)&v12);
  *((void *)v4 + 276) = &unk_1EC9CB060;
  *((void *)v4 + 300) = &unk_1EC9CB0E0;
  v13.n128_u64[0] = (unint64_t)"The maximum number of mps operations that will be used to create an ANE region.";
  v13.n128_u64[1] = 79;
  uint64_t v11 = 0x7FFFFFFFFFFFFFFFLL;
  *(void *)&long long v12 = &v11;
  mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::Option<llvm::cl::desc,llvm::cl::initializer<long long>>((void *)v4 + 302, v6, (uint64_t)"ane-max-ops", 11, &v13, (void **)&v12);
  *((void *)v4 + 302) = &unk_1EC9CB1E0;
  *((void *)v4 + 327) = &unk_1EC9CB260;
  v13.n128_u64[0] = (unint64_t)"The maximum number of cumulative liveIns and liveOuts for an ANE region.";
  v13.n128_u64[1] = 72;
  uint64_t v11 = 0x7FFFFFFFFFFFFFFFLL;
  *(void *)&long long v12 = &v11;
  mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::Option<llvm::cl::desc,llvm::cl::initializer<long long>>((void *)v4 + 329, v6, (uint64_t)"ane-max-liveio", 14, &v13, (void **)&v12);
  *((void *)v4 + 329) = &unk_1EC9CB1E0;
  *((void *)v4 + 354) = &unk_1EC9CB260;
  v13.n128_u64[0] = (unint64_t)"The number of gpu cores.";
  v13.n128_u64[1] = 24;
  LODWORD(v11) = 1;
  *(void *)&long long v12 = &v11;
  mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::initializer<int>>((void *)v4 + 356, v6, (uint64_t)"gpu-core-count", 14, &v13, (int **)&v12);
  *((void *)v4 + 356) = &unk_1EC9CB120;
  *((void *)v4 + 380) = &unk_1EC9CB1A0;
  v13.n128_u64[0] = (unint64_t)"If true, print a report of which ops failed to be placed on ANE.";
  v13.n128_u64[1] = 64;
  LOBYTE(v11) = 0;
  *(void *)&long long v12 = &v11;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)v4 + 382, v6, (uint64_t)"print-placement-report", 22, &v13, (unsigned char **)&v12);
  *((void *)v4 + 382) = &unk_1EC9CB060;
  *((void *)v4 + 406) = &unk_1EC9CB0E0;
  v13.n128_u64[0] = (unint64_t)"Postfix appended to the name of the ANE regions created.";
  v13.n128_u64[1] = 56;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((void *)v4 + 408, v6, (uint64_t)"region-name-postfix", 19, &v13);
  *((void *)v4 + 408) = &unk_1EC9CAFA0;
  *((void *)v4 + 437) = &unk_1EC9CB020;
  v13.n128_u64[0] = (unint64_t)"If true, use GOC and quantimization patterns to optimzie the ANEC IR.";
  v13.n128_u64[1] = 69;
  LOBYTE(v11) = 0;
  *(void *)&long long v12 = &v11;
  uint64_t result = mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)v4 + 439, v6, (uint64_t)"legacy-quant-conversion", 23, &v13, (unsigned char **)&v12);
  *((void *)v4 + 439) = &unk_1EC9CB060;
  *((void *)v4 + 463) = &unk_1EC9CB0E0;
  *(void *)uint64_t v4 = &unk_1EC9AA388;
  *a2 = v4;
  return result;
}

void *mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::Option<llvm::cl::desc,llvm::cl::initializer<long long>>(void *a1, void *a2, uint64_t a3, uint64_t a4, __n128 *a5, void **a6)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  v31[0] = a3;
  v31[1] = a4;
  v34[0] = a2;
  uint64_t v8 = llvm::cl::opt<long long,false,llvm::cl::parser<long long>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<long long>>((uint64_t)a1, (uint64_t)v31, v34, a5, a6);
  uint64_t v9 = v8 + 200;
  *(unsigned char *)(v8 + 208) = 0;
  *(void *)uint64_t v8 = &unk_1EC9CCF88;
  *(void *)(v8 + 200) = &unk_1EC9CD008;
  uint64_t v11 = (uint64_t *)a2[21];
  unint64_t v10 = a2[22];
  long long v12 = v11;
  if ((unint64_t)v11 >= v10)
  {
    unint64_t v14 = (uint64_t *)a2[20];
    uint64_t v15 = v11 - v14;
    unint64_t v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 61) {
      abort();
    }
    uint64_t v17 = v10 - (void)v14;
    if (v17 >> 2 > v16) {
      unint64_t v16 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v16;
    }
    if (v18)
    {
      if (v18 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v19 = (char *)operator new(8 * v18);
    }
    else
    {
      uint64_t v19 = 0;
    }
    uint64_t v20 = (uint64_t *)&v19[8 * v15];
    uint64_t v21 = &v19[8 * v18];
    *uint64_t v20 = v9;
    __n128 v13 = v20 + 1;
    if (v11 != v14)
    {
      unint64_t v22 = (char *)v11 - (char *)v14 - 8;
      if (v22 < 0x58) {
        goto LABEL_36;
      }
      if ((unint64_t)((char *)v14 - v19) < 0x20) {
        goto LABEL_36;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      long long v12 = &v11[v24 / 0xFFFFFFFFFFFFFFF8];
      uint64_t v20 = (uint64_t *)((char *)v20 - v24);
      uint64_t v25 = &v19[8 * v15 - 16];
      long long v26 = v11 - 2;
      uint64_t v27 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v28 = *(_OWORD *)v26;
        *((_OWORD *)v25 - 1) = *((_OWORD *)v26 - 1);
        *(_OWORD *)uint64_t v25 = v28;
        v25 -= 32;
        v26 -= 4;
        v27 -= 4;
      }
      while (v27);
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_36:
        do
        {
          uint64_t v29 = *--v12;
          *--uint64_t v20 = v29;
        }
        while (v12 != v14);
      }
      long long v12 = (uint64_t *)a2[20];
    }
    a2[20] = v20;
    a2[21] = v13;
    a2[22] = v21;
    if (v12) {
      operator delete(v12);
    }
  }
  else
  {
    uint64_t *v11 = v9;
    __n128 v13 = v11 + 1;
  }
  a2[21] = v13;
  v32[0] = &unk_1EC9CFAA8;
  v32[1] = a1;
  int v35 = v34;
  uint64_t v33 = v32;
  v34[0] = &unk_1EC9CFAA8;
  v34[1] = a1;
  std::__function::__value_func<void ()(long long const&)>::swap[abi:nn180100](v34, a1 + 21);
  if (v35 == v34)
  {
    (*((void (**)(const void **))v34[0] + 4))(v34);
  }
  else if (v35)
  {
    (*((void (**)(void))*v35 + 5))();
  }
  if (v33 == v32)
  {
    (*(void (**)(void *))(v32[0] + 32))(v32);
  }
  else if (v33)
  {
    (*(void (**)(void))(*v33 + 40))();
  }
  return a1;
}

uint64_t llvm::cl::opt<long long,false,llvm::cl::parser<long long>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<long long>>(uint64_t a1, uint64_t a2, const void **a3, __n128 *a4, void **a5)
{
  *(void *)a1 = &unk_1EC9A42A8;
  *(_WORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 10) &= 0x8000u;
  unint64_t v10 = (void *)(a1 + 80);
  *(void *)(a1 + 64) = a1 + 80;
  uint64_t v11 = a1 + 64;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_DWORD *)(a1 + 60) = 0;
  *(void *)(a1 + 72) = 0x100000000;
  *(void *)(a1 + 88) = a1 + 120;
  *(void *)(a1 + 96) = a1 + 120;
  *(void *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 112) = 0;
  GeneralCategory = llvm::cl::getGeneralCategory((llvm::cl *)a1);
  uint64_t v13 = *(unsigned int *)(a1 + 72);
  if (v13 >= *(_DWORD *)(a1 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v11, v10, v13 + 1, 8);
    LODWORD(v13) = *(_DWORD *)(a1 + 72);
  }
  *(void *)(*(void *)(a1 + 64) + 8 * v13) = GeneralCategory;
  ++*(_DWORD *)(a1 + 72);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(void *)(a1 + 136) = &unk_1EC9A3B20;
  *(void *)a1 = &unk_1EC9A4038;
  *(void *)(a1 + 160) = &unk_1EC9A44A0;
  *(void *)(a1 + 168) = &unk_1EC9CE768;
  *(void *)(a1 + 192) = a1 + 168;
  llvm::cl::apply<llvm::cl::opt<long long,false,llvm::cl::parser<long long>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<long long>>(a1, a2, a3, a4, a5);
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

__n128 llvm::cl::apply<llvm::cl::opt<long long,false,llvm::cl::parser<long long>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<long long>>(uint64_t a1, uint64_t a2, const void **a3, __n128 *a4, void **a5)
{
  llvm::cl::Option::setArgStr(a1, *(int8x16_t **)a2, *(const unsigned __int8 **)(a2 + 8));
  uint64_t v9 = *a3;
  uint64_t v10 = *(void *)(a1 + 96);
  if (v10 != *(void *)(a1 + 88))
  {
LABEL_2:
    llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)(a1 + 88), v9);
    goto LABEL_3;
  }
  uint64_t v13 = *(unsigned int *)(a1 + 108);
  if (!v13)
  {
LABEL_12:
    if (v13 < *(_DWORD *)(a1 + 104))
    {
      *(_DWORD *)(a1 + 108) = v13 + 1;
      *(void *)(v10 + 8 * v13) = v9;
      goto LABEL_3;
    }
    goto LABEL_2;
  }
  unint64_t v14 = 0;
  uint64_t v15 = 8 * v13;
  unint64_t v16 = *(void **)(a1 + 96);
  while ((const void *)*v16 != v9)
  {
    if (*v16 == -2) {
      unint64_t v14 = v16;
    }
    ++v16;
    v15 -= 8;
    if (!v15)
    {
      if (!v14) {
        goto LABEL_12;
      }
      *unint64_t v14 = v9;
      --*(_DWORD *)(a1 + 112);
      break;
    }
  }
LABEL_3:
  __n128 result = *a4;
  *(__n128 *)(a1 + 32) = *a4;
  long long v12 = *a5;
  *(void *)(a1 + 128) = **a5;
  *(unsigned char *)(a1 + 152) = 1;
  *(void *)(a1 + 144) = *v12;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIxN4llvm2cl6parserIxEEEC1IJNS7_4descENS7_11initializerIxEEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISN_EEFvRKxEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EC9CFAA8;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIxN4llvm2cl6parserIxEEEC1IJNS7_4descENS7_11initializerIxEEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISN_EEFvRKxEE7__cloneEPNS0_6__baseISS_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EC9CFAA8;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIxN4llvm2cl6parserIxEEEC1IJNS7_4descENS7_11initializerIxEEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISN_EEFvRKxEEclESR_(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 8) + 208) = 1;
  return result;
}

uint64_t _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorERZNS1_12_GLOBAL__N_19MPSToANEC14runOnOperationEvEUlNS1_4func6FuncOpEE_SF_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESP_E4typeES4_OT1_EUlS4_E_EES2_lS4_(void **a1, uint64_t a2)
{
  if (a2 && *(_UNKNOWN **)(*(void *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::func::FuncOp,void>::id)
  {
    uint64_t v3 = *a1;
    if (!*(unsigned char *)(a2 + 47) || (uint64_t InherentAttr = mlir::Operation::getInherentAttr(a2, (uint64_t)"io_info", 7), !v5)) {
      uint64_t InherentAttr = mlir::DictionaryAttr::get(a2 + 56, "io_info", 7uLL);
    }
    uint64_t v8 = InherentAttr;
    if (InherentAttr)
    {
      v7[0] = v3[1];
      v7[1] = &v8;
      v7[2] = *v3;
      uint64_t v9 = v7;
      mlir::detail::walk<mlir::ForwardIterator>((mlir::ForwardIterator *)a2, (mlir::Operation *)_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZZNS1_12_GLOBAL__N_19MPSToANEC14runOnOperationEvENKUlNS1_4func6FuncOpEE_clESE_EUlNS1_9placement10RegionCallEE_SH_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESQ_E4typeES3_OT1_EUlS3_E_EEvlS3_, (uint64_t)&v9, 1);
    }
  }
  return 1;
}

double _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZZNS1_12_GLOBAL__N_19MPSToANEC14runOnOperationEvENKUlNS1_4func6FuncOpEE_clESE_EUlNS1_9placement10RegionCallEE_SH_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESQ_E4typeES3_OT1_EUlS3_E_EEvlS3_(uint64_t *a1, mlir::Operation *a2)
{
  if (a2
    && *(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::placement::RegionCall,void>::id)
  {
    uint64_t v2 = *a1;
    long long v28 = a2;
    Callee = (char *)mlir::placement::RegionCall::getCallee(&v28);
    size_t v5 = v4;
    *(void *)&long long v27 = Callee;
    *((void *)&v27 + 1) = v4;
    uint64_t v6 = **(unsigned int ***)v2;
    uint64_t Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v6 + 6));
    __int16 v31 = 261;
    uint64_t v29 = Callee;
    uint64_t v30 = v5;
    uint64_t v8 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)&v29);
    uint64_t v9 = mlir::SymbolTable::lookupSymbolIn(v6, v8);
    uint64_t v10 = **(void **)(v2 + 8);
    uint64_t v11 = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v9 + 24));
    __int16 v31 = 261;
    uint64_t v29 = "io_info";
    uint64_t v30 = 7;
    uint64_t v12 = mlir::StringAttr::get(v11, (mlir::MLIRContext *)&v29);
    mlir::Operation::setAttr(v9, v12, v10);
    uint64_t v13 = *(void *)(v2 + 16);
    int v14 = *(_DWORD *)(v13 + 16);
    if (v14)
    {
      uint64_t v15 = *(void *)v13;
      unsigned int HashValue = llvm::DenseMapInfo<llvm::StringRef,void>::getHashValue(Callee, v5);
      unint64_t v18 = 0;
      int v19 = v14 - 1;
      for (int i = 1; ; ++i)
      {
        unsigned int v21 = HashValue & v19;
        uint64_t v22 = v15 + 16 * (HashValue & v19);
        uint64_t v23 = *(const void **)v22;
        if (*(void *)v22 == -2)
        {
          if (Callee == (char *)-2) {
            return result;
          }
        }
        else if (v23 == (const void *)-1)
        {
          if (Callee == (char *)-1) {
            return result;
          }
        }
        else if (v5 == *(void *)(v22 + 8) && (!v5 || !memcmp(Callee, *(const void **)v22, v5)))
        {
          return result;
        }
        if (v23 == (const void *)-1) {
          break;
        }
        if (v18) {
          BOOL v24 = 0;
        }
        else {
          BOOL v24 = v23 == (const void *)-2;
        }
        if (v24) {
          unint64_t v18 = (void *)(v15 + 16 * v21);
        }
        unsigned int HashValue = i + v21;
      }
      if (v18) {
        uint64_t v25 = v18;
      }
      else {
        uint64_t v25 = (void *)(v15 + 16 * v21);
      }
    }
    else
    {
      uint64_t v25 = 0;
    }
    long long v26 = llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>,llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>::InsertIntoBucketImpl<llvm::StringRef>(v13, (uint64_t)&v27, (uint64_t)&v27, v25);
    double result = *(double *)&v27;
    *(_OWORD *)long long v26 = v27;
  }
  return result;
}

uint64_t _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorERZNS1_12_GLOBAL__N_19MPSToANEC14runOnOperationEvEUlNS1_4func6FuncOpEE0_SF_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESP_E4typeES4_OT1_EUlS4_E_EES2_lS4_(uint64_t **a1, void *a2)
{
  if (a2 && *(_UNKNOWN **)(a2[6] + 16) == &mlir::detail::TypeIDResolver<mlir::func::FuncOp,void>::id)
  {
    uint64_t v3 = *a1;
    uint64_t Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 3));
    uint64_t SymbolName = mlir::SymbolTable::getSymbolName((mlir::SymbolTable *)a2, v5);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&SymbolName);
    __int16 v13 = 261;
    uint64_t SymbolName = AttrData;
    uint64_t v11 = v7;
    uint64_t v14 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)&SymbolName);
    char v9 = 0;
    uint64_t SymbolName = *v3;
    uint64_t v11 = &v14;
    uint64_t v12 = &v9;
    p_uint64_t SymbolName = &SymbolName;
    mlir::detail::walk<mlir::ForwardIterator>((mlir::ForwardIterator *)a2, (mlir::Operation *)_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZZNS1_12_GLOBAL__N_19MPSToANEC14runOnOperationEvENKUlNS1_4func6FuncOpEE0_clESE_EUlNS1_9placement10RegionCallEE_SH_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESQ_E4typeES3_OT1_EUlS3_E_EEvlS3_, (uint64_t)&p_SymbolName, 1);
  }
  return 1;
}

void _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZZNS1_12_GLOBAL__N_19MPSToANEC14runOnOperationEvENKUlNS1_4func6FuncOpEE0_clESE_EUlNS1_9placement10RegionCallEE_SH_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESQ_E4typeES3_OT1_EUlS3_E_EEvlS3_(uint64_t *a1, mlir::Operation *a2)
{
  if (a2)
  {
    if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::placement::RegionCall,void>::id)
    {
      uint64_t v2 = *a1;
      __int16 v13 = a2;
      uint64_t Callee = mlir::placement::RegionCall::getCallee(&v13);
      uint64_t v5 = v4;
      uint64_t v6 = **(unsigned int ***)v2;
      uint64_t Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v6 + 6));
      __int16 v16 = 261;
      uint64_t v14 = (const char *)Callee;
      uint64_t v15 = v5;
      uint64_t v8 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)&v14);
      uint64_t v9 = mlir::SymbolTable::lookupSymbolIn(v6, v8);
      uint64_t v10 = **(void **)(v2 + 8);
      uint64_t v11 = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v9 + 24));
      __int16 v16 = 261;
      uint64_t v14 = "procedure_name";
      uint64_t v15 = 14;
      uint64_t v12 = mlir::StringAttr::get(v11, (mlir::MLIRContext *)&v14);
      mlir::Operation::setAttr(v9, v12, v10);
      **(unsigned char **)(v2 + 16) = 1;
    }
  }
}

uint64_t mlir::MPSPlacementBase<mlir::anonymous namespace'::MPSPlacement>::MPSPlacementBase(uint64_t a1)
{
  v11[20] = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 16) = "builtin.module";
  *(void *)(a1 + 24) = 14;
  *(unsigned char *)(a1 + 32) = 1;
  *(unsigned char *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 120) = 0;
  uint64_t v2 = (void *)(a1 + 152);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = a1 + 200;
  *(void *)(a1 + 192) = 0x400000000;
  *(void *)(a1 + 232) = a1 + 248;
  *(void *)(a1 + 240) = 0x400000000;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 296) = 0x1000000000;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(void *)(a1 + 336) = 0;
  *(void *)a1 = &unk_1EC9AA798;
  uint64_t v3 = (void *)(a1 + 344);
  *(void *)&long long v9 = "The family to target for ANEC region formation (default A12).";
  *((void *)&v9 + 1) = 61;
  int v7 = 0;
  uint64_t v8 = &v7;
  v10.n128_u64[0] = (unint64_t)v11;
  v10.n128_u64[1] = 0x400000000;
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v10, v11, 7uLL, 40);
  unsigned __int32 v4 = v10.n128_u32[2];
  unint64_t v5 = v10.n128_u64[0] + 40 * v10.n128_u32[2];
  *(void *)unint64_t v5 = "A12";
  *(void *)(v5 + 8) = 3;
  *(_DWORD *)(v5 + 16) = 0;
  *(void *)(v5 + 24) = "A12 family";
  *(void *)(v5 + 32) = 10;
  *(void *)(v5 + 40) = "A13";
  *(void *)(v5 + 48) = 3;
  *(_DWORD *)(v5 + 56) = 1;
  *(void *)(v5 + 64) = "A13 family";
  *(void *)(v5 + 72) = 10;
  *(void *)(v5 + 80) = "A14";
  *(void *)(v5 + 88) = 3;
  *(_DWORD *)(v5 + 96) = 2;
  *(void *)(v5 + 104) = "A14 family";
  *(void *)(v5 + 112) = 10;
  *(void *)(v5 + 120) = "A15";
  *(void *)(v5 + 128) = 3;
  *(_DWORD *)(v5 + 136) = 3;
  *(void *)(v5 + 144) = "A15 family";
  *(void *)(v5 + 152) = 10;
  *(void *)(v5 + 160) = "A16";
  *(void *)(v5 + 168) = 3;
  *(_DWORD *)(v5 + 176) = 4;
  *(void *)(v5 + 184) = "A16 family";
  *(void *)(v5 + 192) = 10;
  *(void *)(v5 + 200) = "A17";
  *(void *)(v5 + 208) = 3;
  *(_DWORD *)(v5 + 216) = 5;
  *(void *)(v5 + 224) = "A17 family";
  *(void *)(v5 + 232) = 10;
  *(void *)(v5 + 240) = "A11Legacy";
  *(void *)(v5 + 248) = 9;
  *(_DWORD *)(v5 + 256) = 6;
  *(void *)(v5 + 264) = "A11 Legacy family";
  *(void *)(v5 + 272) = 17;
  v10.n128_u32[2] = v4 + 7;
  mlir::detail::PassOptions::Option<mlir::anec::Family,mlir::detail::PassOptions::GenericOptionParser<mlir::anec::Family>>::Option<llvm::cl::desc,llvm::cl::initializer<mlir::anec::Family>,llvm::cl::ValuesClass>(v3, v2, (uint64_t)"target-family", 13, &v9, &v8, (uint64_t *)&v10);
  *(void *)(a1 + 344) = &unk_1EC9CAEE0;
  *(void *)(a1 + 944) = &unk_1EC9CAF60;
  if ((void *)v10.n128_u64[0] != v11) {
    free((void *)v10.n128_u64[0]);
  }
  v10.n128_u64[0] = (unint64_t)"Insert instrumentation to enable performance recording.";
  v10.n128_u64[1] = 55;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 960), v2, (uint64_t)"insert-instrumentation", 22, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 960) = &unk_1EC9CB060;
  *(void *)(a1 + 1152) = &unk_1EC9CB0E0;
  v10.n128_u64[0] = (unint64_t)"If true the GPU is the host device, otherwise it is the CPU. Defaults to false.";
  v10.n128_u64[1] = 79;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 1168), v2, (uint64_t)"gpu-host", 8, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 1168) = &unk_1EC9CB060;
  *(void *)(a1 + 1360) = &unk_1EC9CB0E0;
  v10.n128_u64[0] = (unint64_t)"The number of gpu cores.";
  v10.n128_u64[1] = 24;
  LODWORD(v8) = 1;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::initializer<int>>((void *)(a1 + 1376), v2, (uint64_t)"gpu-core-count", 14, &v10, (int **)&v9);
  *(void *)(a1 + 1376) = &unk_1EC9CB120;
  *(void *)(a1 + 1568) = &unk_1EC9CB1A0;
  v10.n128_u64[0] = (unint64_t)"Number of thresholds for TA algorithm. Generally expect to use the default value.";
  v10.n128_u64[1] = 81;
  int v7 = 1;
  LODWORD(v8) = 25;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::initializer<int>,llvm::cl::OptionHidden>((void *)(a1 + 1584), v2, (uint64_t)"num-thresholds", 14, &v10, (int **)&v9, &v7);
  *(void *)(a1 + 1584) = &unk_1EC9CB120;
  *(void *)(a1 + 1776) = &unk_1EC9CB1A0;
  v10.n128_u64[0] = (unint64_t)"Number of steps for a single threshold for TA algorithm. Generally expect to use t"
                                      "he default value.";
  v10.n128_u64[1] = 99;
  int v7 = 1;
  LODWORD(v8) = 10;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::initializer<int>,llvm::cl::OptionHidden>((void *)(a1 + 1792), v2, (uint64_t)"num-steps", 9, &v10, (int **)&v9, &v7);
  *(void *)(a1 + 1792) = &unk_1EC9CB120;
  *(void *)(a1 + 1984) = &unk_1EC9CB1A0;
  v10.n128_u64[0] = (unint64_t)"Number of steps required for convergence. Generally expect to use the default value.";
  v10.n128_u64[1] = 84;
  int v7 = 1;
  LODWORD(v8) = 10;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::initializer<int>,llvm::cl::OptionHidden>((void *)(a1 + 2000), v2, (uint64_t)"convergence-threshold", 21, &v10, (int **)&v9, &v7);
  *(void *)(a1 + 2000) = &unk_1EC9CB120;
  *(void *)(a1 + 2192) = &unk_1EC9CB1A0;
  v10.n128_u64[0] = (unint64_t)"The seed to use for the RNG. This will ensure that the random numbers can be gener"
                                      "ated deterministically.";
  v10.n128_u64[1] = 105;
  int v7 = 1;
  LODWORD(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::Option<llvm::cl::desc,llvm::cl::initializer<int>,llvm::cl::OptionHidden>((void *)(a1 + 2208), v2, (uint64_t)"rng-seed", 8, &v10, (int **)&v9, &v7);
  *(void *)(a1 + 2208) = &unk_1EC9CB1E0;
  *(void *)(a1 + 2408) = &unk_1EC9CB260;
  return a1;
}

void mlir::anonymous namespace'::MPSPlacement::~MPSPlacement(mlir::_anonymous_namespace_::MPSPlacement *this)
{
  *(void *)this = &unk_1EC9AA798;
  *((void *)this + 276) = &unk_1EC9A4038;
  uint64_t v2 = (char *)this + 2376;
  uint64_t v3 = (char *)*((void *)this + 300);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  *((void *)this + 276) = &unk_1EC9A42A8;
  unsigned __int32 v4 = (void *)*((void *)this + 288);
  if (v4 != *((void **)this + 287)) {
    free(v4);
  }
  unint64_t v5 = (char *)*((void *)this + 284);
  if (v5 != (char *)this + 2288) {
    free(v5);
  }
  *((void *)this + 250) = &unk_1EC9A3FD0;
  uint64_t v6 = (mlir::_anonymous_namespace_::MPSPlacement *)*((void *)this + 273);
  if (v6 == (mlir::_anonymous_namespace_::MPSPlacement *)((char *)this + 2160))
  {
    (*(void (**)(char *))(*((void *)this + 270) + 32))((char *)this + 2160);
  }
  else if (v6)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSPlacement *))(*(void *)v6 + 40))(v6);
  }
  *((void *)this + 250) = &unk_1EC9A42A8;
  int v7 = (void *)*((void *)this + 262);
  if (v7 != *((void **)this + 261)) {
    free(v7);
  }
  uint64_t v8 = (char *)*((void *)this + 258);
  if (v8 != (char *)this + 2080) {
    free(v8);
  }
  *((void *)this + 224) = &unk_1EC9A3FD0;
  long long v9 = (mlir::_anonymous_namespace_::MPSPlacement *)*((void *)this + 247);
  if (v9 == (mlir::_anonymous_namespace_::MPSPlacement *)((char *)this + 1952))
  {
    (*(void (**)(char *))(*((void *)this + 244) + 32))((char *)this + 1952);
  }
  else if (v9)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSPlacement *))(*(void *)v9 + 40))(v9);
  }
  *((void *)this + 224) = &unk_1EC9A42A8;
  __n128 v10 = (void *)*((void *)this + 236);
  if (v10 != *((void **)this + 235)) {
    free(v10);
  }
  uint64_t v11 = (char *)*((void *)this + 232);
  if (v11 != (char *)this + 1872) {
    free(v11);
  }
  *((void *)this + 198) = &unk_1EC9A3FD0;
  uint64_t v12 = (mlir::_anonymous_namespace_::MPSPlacement *)*((void *)this + 221);
  if (v12 == (mlir::_anonymous_namespace_::MPSPlacement *)((char *)this + 1744))
  {
    (*(void (**)(char *))(*((void *)this + 218) + 32))((char *)this + 1744);
  }
  else if (v12)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSPlacement *))(*(void *)v12 + 40))(v12);
  }
  *((void *)this + 198) = &unk_1EC9A42A8;
  __int16 v13 = (void *)*((void *)this + 210);
  if (v13 != *((void **)this + 209)) {
    free(v13);
  }
  uint64_t v14 = (char *)*((void *)this + 206);
  if (v14 != (char *)this + 1664) {
    free(v14);
  }
  *((void *)this + 172) = &unk_1EC9A3FD0;
  uint64_t v15 = (mlir::_anonymous_namespace_::MPSPlacement *)*((void *)this + 195);
  if (v15 == (mlir::_anonymous_namespace_::MPSPlacement *)((char *)this + 1536))
  {
    (*(void (**)(char *))(*((void *)this + 192) + 32))((char *)this + 1536);
  }
  else if (v15)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSPlacement *))(*(void *)v15 + 40))(v15);
  }
  *((void *)this + 172) = &unk_1EC9A42A8;
  __int16 v16 = (void *)*((void *)this + 184);
  if (v16 != *((void **)this + 183)) {
    free(v16);
  }
  uint64_t v17 = (char *)*((void *)this + 180);
  if (v17 != (char *)this + 1456) {
    free(v17);
  }
  *((void *)this + 146) = &unk_1EC9A3F00;
  unint64_t v18 = (mlir::_anonymous_namespace_::MPSPlacement *)*((void *)this + 169);
  if (v18 == (mlir::_anonymous_namespace_::MPSPlacement *)((char *)this + 1328))
  {
    (*(void (**)(char *))(*((void *)this + 166) + 32))((char *)this + 1328);
  }
  else if (v18)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSPlacement *))(*(void *)v18 + 40))(v18);
  }
  *((void *)this + 146) = &unk_1EC9A42A8;
  int v19 = (void *)*((void *)this + 158);
  if (v19 != *((void **)this + 157)) {
    free(v19);
  }
  uint64_t v20 = (char *)*((void *)this + 154);
  if (v20 != (char *)this + 1248) {
    free(v20);
  }
  *((void *)this + 120) = &unk_1EC9A3F00;
  unsigned int v21 = (mlir::_anonymous_namespace_::MPSPlacement *)*((void *)this + 143);
  if (v21 == (mlir::_anonymous_namespace_::MPSPlacement *)((char *)this + 1120))
  {
    (*(void (**)(char *))(*((void *)this + 140) + 32))((char *)this + 1120);
  }
  else if (v21)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSPlacement *))(*(void *)v21 + 40))(v21);
  }
  *((void *)this + 120) = &unk_1EC9A42A8;
  uint64_t v22 = (void *)*((void *)this + 132);
  if (v22 != *((void **)this + 131)) {
    free(v22);
  }
  uint64_t v23 = (char *)*((void *)this + 128);
  if (v23 != (char *)this + 1040) {
    free(v23);
  }
  mlir::detail::PassOptions::Option<mlir::anec::Family,mlir::detail::PassOptions::GenericOptionParser<mlir::anec::Family>>::~Option((void *)this + 43);

  mlir::Pass::~Pass(this);
}

{
  void *v1;
  uint64_t vars8;

  operator delete(v1);
}

const char *mlir::MPSPlacementBase<mlir::anonymous namespace'::MPSPlacement>::getName()
{
  return "MPSPlacement";
}

void *mlir::MPSPlacementBase<mlir::anonymous namespace'::MPSPlacement>::getDependentDialects(int a1, uint64_t **a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v4[0] = &unk_1EC9CF0D8;
  unint64_t v5 = v4;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::placement::PlacementDialect,void>::id, "placement", 9uLL, v4);
  if (v5 == v4)
  {
    (*(void (**)(void *))(v4[0] + 32))(v4);
  }
  else if (v5)
  {
    (*(void (**)(void))(*v5 + 40))();
  }
  v4[0] = &unk_1EC9CEF70;
  unint64_t v5 = v4;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::anec::ANECDialect,void>::id, "anec", 4uLL, v4);
  if (v5 == v4)
  {
    (*(void (**)(void *))(v4[0] + 32))(v4);
  }
  else if (v5)
  {
    (*(void (**)(void))(*v5 + 40))();
  }
  v4[0] = &unk_1EC9CEEE0;
  unint64_t v5 = v4;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::mps::MPSDialect,void>::id, "mps", 3uLL, v4);
  if (v5 == v4)
  {
    (*(void (**)(void *))(v4[0] + 32))(v4);
  }
  else if (v5)
  {
    (*(void (**)(void))(*v5 + 40))();
  }
  v4[0] = &unk_1EC9CF048;
  unint64_t v5 = v4;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::memref::MemRefDialect,void>::id, "memref", 6uLL, v4);
  double result = v5;
  if (v5 == v4) {
    return (void *)(*(uint64_t (**)(void *))(v4[0] + 32))(v4);
  }
  if (v5) {
    return (void *)(*(uint64_t (**)(void))(*v5 + 40))();
  }
  return result;
}

const char *mlir::MPSPlacementBase<mlir::anonymous namespace'::MPSPlacement>::getArgument()
{
  return "mps-placement";
}

const char *mlir::MPSPlacementBase<mlir::anonymous namespace'::MPSPlacement>::getDescription()
{
  return "Place ops across the various IP available on the Apple SoC.";
}

void mlir::anonymous namespace'::MPSPlacement::runOnOperation(mlir::_anonymous_namespace_::MPSPlacement *this)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)((*((void *)this + 5) & 0xFFFFFFFFFFFFFFF8) + 24));
  long long __p = 0u;
  long long v61 = 0u;
  uint64_t v59 = Context;
  unint64_t v62 = &v64;
  uint64_t v63 = 0x600000000;
  uint64_t v66 = 0;
  unint64_t v65 = 0;
  int v67 = 0;
  uint64_t v69 = 0;
  unint64_t v68 = 0;
  uint64_t v70 = 0x2800000000;
  unint64_t v71 = 0;
  uint64_t v72 = 0;
  uint64_t v73 = 0x2800000000;
  mlir::MPSToANECTypeConverter::MPSToANECTypeConverter((mlir::MPSToANECTypeConverter *)v58);
  mlir::populateMPSToANECConversionPatterns(*((unsigned int *)this + 118), 1, &v59, (uint64_t)v58);
  uint64_t v3 = mlir::Attribute::getContext((mlir::Attribute *)((*((void *)this + 5) & 0xFFFFFFFFFFFFFFF8) + 24));
  v44[2] = 0;
  v44[0] = (uint64_t)&unk_1EC9AA748;
  v44[1] = 0;
  int v45 = 0;
  uint64_t v51 = 0;
  uint64_t v50 = 0;
  uint64_t v46 = v48;
  uint64_t v47 = 0;
  v48[1] = 0;
  v48[0] = 0;
  int v49 = 0;
  uint64_t v52 = 0x1000000000;
  uint64_t v53 = 0;
  uint64_t v54 = 0;
  uint64_t v55 = 0x2800000000;
  uint64_t v56 = 0;
  uint64_t v57 = v3;
  *((void *)&v39 + 1) = "func";
  uint64_t v40 = 4;
  mlir::ConversionTarget::setDialectAction(v44, (uint64_t)&v39 + 8, 1, 2);
  *((void *)&v39 + 1) = "memref";
  uint64_t v40 = 6;
  mlir::ConversionTarget::setDialectAction(v44, (uint64_t)&v39 + 8, 1, 2);
  uint64_t v38 = (char *)&v39 + 8;
  *((void *)&v39 + 1) = "mps";
  uint64_t v40 = 3;
  *(void *)&long long v39 = 0x200000001;
  mlir::ConversionTarget::setDialectAction(v44, (uint64_t)&v39 + 8, 1, 2);
  mlir::OperationName::OperationName(&v38, "anec.unrealized_conversion_cast", 31, v57);
  mlir::ConversionTarget::setOpAction((uint64_t)v44, (uint64_t)v38, 2);
  mlir::OperationName::OperationName(&v38, "placement.region_call", 21, v57);
  mlir::ConversionTarget::setOpAction((uint64_t)v44, (uint64_t)v38, 2);
  v42[0] = &unk_1EC9CED38;
  v42[1] = this;
  char v43 = v42;
  uint64_t v38 = (char *)&v39 + 8;
  *((void *)&v39 + 1) = "anec";
  uint64_t v40 = 4;
  *(void *)&long long v39 = 0x200000001;
  mlir::ConversionTarget::setDialectAction(v44, (uint64_t)&v39 + 8, 1, 1);
  mlir::ConversionTarget::setLegalityCallback((uint64_t)v44, (uint64_t)v38, v39, v42);
  if (v38 != (char *)&v39 + 8) {
    free(v38);
  }
  if (v43 == v42)
  {
    (*(void (**)(void *))(v42[0] + 32))(v42);
  }
  else if (v43)
  {
    (*(void (**)(void))(*v43 + 40))();
  }
  uint64_t v38 = &unk_1EC9CF178;
  LOBYTE(v39) = 0;
  uint64_t v40 = (uint64_t)&v38;
  mlir::OperationName::OperationName(&v22, "mps.constant", 12, v57);
  uint64_t v4 = (uint64_t)v22;
  mlir::ConversionTarget::setOpAction((uint64_t)v44, (uint64_t)v22, 1);
  mlir::ConversionTarget::setLegalityCallback((uint64_t)v44, v4, &v38);
  if ((void **)v40 == &v38)
  {
    (*((void (**)(void **))v38 + 4))(&v38);
  }
  else if (v40)
  {
    (*(void (**)(void))(*(void *)v40 + 40))();
  }
  mlir::FrozenRewritePatternSet::FrozenRewritePatternSet(&v14, &v59, 0, 0, 0, 0);
  int v5 = *((_DWORD *)this + 118);
  long long v6 = v14;
  long long v14 = 0uLL;
  uint64_t v38 = &unk_1EC9AA710;
  long long v39 = v6;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v40 = (uint64_t)v44;
  mlir::FrozenRewritePatternSet::~FrozenRewritePatternSet((mlir::FrozenRewritePatternSet *)&v22);
  uint64_t v38 = &unk_1EC9A73A8;
  mlir::MPSToANECTypeConverter::MPSToANECTypeConverter((mlir::MPSToANECTypeConverter *)v41);
  v41[134] = v5;
  mlir::FrozenRewritePatternSet::~FrozenRewritePatternSet((mlir::FrozenRewritePatternSet *)&v14);
  uint64_t v7 = mlir::Attribute::getContext((mlir::Attribute *)((*((void *)this + 5) & 0xFFFFFFFFFFFFFFF8) + 24));
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v22 = &unk_1EC9AA748;
  int v25 = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  long long v26 = v28;
  uint64_t v27 = 0;
  v28[0] = 0;
  v28[1] = 0;
  int v29 = 0;
  uint64_t v32 = 0x1000000000;
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  uint64_t v35 = 0x2800000000;
  uint64_t v36 = 0;
  uint64_t v37 = v7;
  unint64_t v18 = &v20;
  uint64_t v20 = "func";
  uint64_t v21 = 4;
  uint64_t v19 = 0x200000001;
  mlir::ConversionTarget::setDialectAction((uint64_t *)&v22, (uint64_t)&v20, 1, 2);
  if (v18 != &v20) {
    free(v18);
  }
  mlir::OperationName::OperationName(&v18, "placement.region_call", 21, v37);
  mlir::ConversionTarget::setOpAction((uint64_t)&v22, (uint64_t)v18, 2);
  mlir::OperationName::OperationName(&v18, "placement.tensor_to_memref", 26, v37);
  mlir::ConversionTarget::setOpAction((uint64_t)&v22, (uint64_t)v18, 2);
  unint64_t v18 = &v20;
  uint64_t v20 = "mps";
  uint64_t v21 = 3;
  uint64_t v19 = 0x200000001;
  mlir::ConversionTarget::setDialectAction((uint64_t *)&v22, (uint64_t)&v20, 1, 0);
  if (v18 != &v20) {
    free(v18);
  }
  mlir::FrozenRewritePatternSet::FrozenRewritePatternSet((mlir::FrozenRewritePatternSet *)&v10);
  long long v8 = v10;
  long long v10 = 0uLL;
  uint64_t v11 = &unk_1EC9AA710;
  long long v12 = v8;
  unint64_t v18 = 0;
  uint64_t v19 = 0;
  __int16 v13 = &v22;
  mlir::FrozenRewritePatternSet::~FrozenRewritePatternSet((mlir::FrozenRewritePatternSet *)&v18);
  uint64_t v11 = &unk_1EC9A7680;
  mlir::FrozenRewritePatternSet::~FrozenRewritePatternSet((mlir::FrozenRewritePatternSet *)&v10);
  mlir::getDeviceInfo(*((_DWORD *)this + 118), *((unsigned int *)this + 376), (uint64_t)&v18);
  LOBYTE(v18) = *((unsigned char *)this + 1296);
  uint64_t v15 = v17;
  v17[0] = &v38;
  uint64_t v16 = 0x200000001;
  if ((_BYTE)v18)
  {
    unint64_t v9 = 1;
  }
  else
  {
    v17[1] = &v11;
    unint64_t v9 = 2;
    LODWORD(v16) = 2;
  }
  if (!mlir::doPlacement((uint64_t *)(*((void *)this + 5) & 0xFFFFFFFFFFFFFFF8), *((unsigned int *)this + 428), *((unsigned int *)this + 480), *((unsigned int *)this + 532), (uint64_t)v17, v9))*((void *)this + 5) |= 4uLL; {
  if (v15 != v17)
  }
    free(v15);
  uint64_t v11 = &unk_1EC9AA710;
  mlir::FrozenRewritePatternSet::~FrozenRewritePatternSet((mlir::FrozenRewritePatternSet *)&v12);
  mlir::ConversionTarget::~ConversionTarget((mlir::ConversionTarget *)&v22);
}

void *mlir::MPSPlacementBase<mlir::anonymous namespace'::MPSPlacement>::clonePass@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  v14[20] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (char *)operator new(0x978uLL);
  uint64_t v5 = *(void *)(a1 + 8);
  *((_OWORD *)v4 + 1) = *(_OWORD *)(a1 + 16);
  *((void *)v4 + 4) = *(void *)(a1 + 32);
  *((void *)v4 + 1) = v5;
  v4[40] = 0;
  v4[120] = 0;
  long long v6 = v4 + 152;
  *((_OWORD *)v4 + 8) = 0u;
  *((_OWORD *)v4 + 9) = 0u;
  *((_OWORD *)v4 + 10) = 0u;
  *((void *)v4 + 22) = 0;
  *((void *)v4 + 23) = v4 + 200;
  *((void *)v4 + 24) = 0x400000000;
  *((void *)v4 + 29) = v4 + 248;
  *((void *)v4 + 30) = 0x400000000;
  *((void *)v4 + 35) = 0;
  *((void *)v4 + 36) = 0;
  *((_DWORD *)v4 + 74) = 0;
  *((_DWORD *)v4 + 75) = 16;
  *((_OWORD *)v4 + 19) = 0u;
  *((_OWORD *)v4 + 20) = 0u;
  *((void *)v4 + 42) = 0;
  *(void *)uint64_t v4 = &unk_1EC9AA798;
  *(void *)&long long v12 = "The family to target for ANEC region formation (default A12).";
  *((void *)&v12 + 1) = 61;
  int v10 = 0;
  uint64_t v11 = &v10;
  v13.n128_u64[0] = (unint64_t)v14;
  v13.n128_u64[1] = 0x400000000;
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v14, 7uLL, 40);
  unsigned __int32 v7 = v13.n128_u32[2];
  unint64_t v8 = v13.n128_u64[0] + 40 * v13.n128_u32[2];
  *(void *)unint64_t v8 = "A12";
  *(void *)(v8 + 8) = 3;
  *(_DWORD *)(v8 + 16) = 0;
  *(void *)(v8 + 24) = "A12 family";
  *(void *)(v8 + 32) = 10;
  *(void *)(v8 + 40) = "A13";
  *(void *)(v8 + 48) = 3;
  *(_DWORD *)(v8 + 56) = 1;
  *(void *)(v8 + 64) = "A13 family";
  *(void *)(v8 + 72) = 10;
  *(void *)(v8 + 80) = "A14";
  *(void *)(v8 + 88) = 3;
  *(_DWORD *)(v8 + 96) = 2;
  *(void *)(v8 + 104) = "A14 family";
  *(void *)(v8 + 112) = 10;
  *(void *)(v8 + 120) = "A15";
  *(void *)(v8 + 128) = 3;
  *(_DWORD *)(v8 + 136) = 3;
  *(void *)(v8 + 144) = "A15 family";
  *(void *)(v8 + 152) = 10;
  *(void *)(v8 + 160) = "A16";
  *(void *)(v8 + 168) = 3;
  *(_DWORD *)(v8 + 176) = 4;
  *(void *)(v8 + 184) = "A16 family";
  *(void *)(v8 + 192) = 10;
  *(void *)(v8 + 200) = "A17";
  *(void *)(v8 + 208) = 3;
  *(_DWORD *)(v8 + 216) = 5;
  *(void *)(v8 + 224) = "A17 family";
  *(void *)(v8 + 232) = 10;
  *(void *)(v8 + 240) = "A11Legacy";
  *(void *)(v8 + 248) = 9;
  *(_DWORD *)(v8 + 256) = 6;
  *(void *)(v8 + 264) = "A11 Legacy family";
  *(void *)(v8 + 272) = 17;
  v13.n128_u32[2] = v7 + 7;
  mlir::detail::PassOptions::Option<mlir::anec::Family,mlir::detail::PassOptions::GenericOptionParser<mlir::anec::Family>>::Option<llvm::cl::desc,llvm::cl::initializer<mlir::anec::Family>,llvm::cl::ValuesClass>((void *)v4 + 43, (void *)v4 + 19, (uint64_t)"target-family", 13, &v12, &v11, (uint64_t *)&v13);
  *((void *)v4 + 43) = &unk_1EC9CAEE0;
  *((void *)v4 + 118) = &unk_1EC9CAF60;
  if ((void *)v13.n128_u64[0] != v14) {
    free((void *)v13.n128_u64[0]);
  }
  v13.n128_u64[0] = (unint64_t)"Insert instrumentation to enable performance recording.";
  v13.n128_u64[1] = 55;
  LOBYTE(v11) = 0;
  *(void *)&long long v12 = &v11;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)v4 + 120, v6, (uint64_t)"insert-instrumentation", 22, &v13, (unsigned char **)&v12);
  *((void *)v4 + 120) = &unk_1EC9CB060;
  *((void *)v4 + 144) = &unk_1EC9CB0E0;
  v13.n128_u64[0] = (unint64_t)"If true the GPU is the host device, otherwise it is the CPU. Defaults to false.";
  v13.n128_u64[1] = 79;
  LOBYTE(v11) = 0;
  *(void *)&long long v12 = &v11;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)v4 + 146, v6, (uint64_t)"gpu-host", 8, &v13, (unsigned char **)&v12);
  *((void *)v4 + 146) = &unk_1EC9CB060;
  *((void *)v4 + 170) = &unk_1EC9CB0E0;
  v13.n128_u64[0] = (unint64_t)"The number of gpu cores.";
  v13.n128_u64[1] = 24;
  LODWORD(v11) = 1;
  *(void *)&long long v12 = &v11;
  mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::initializer<int>>((void *)v4 + 172, v6, (uint64_t)"gpu-core-count", 14, &v13, (int **)&v12);
  *((void *)v4 + 172) = &unk_1EC9CB120;
  *((void *)v4 + 196) = &unk_1EC9CB1A0;
  v13.n128_u64[0] = (unint64_t)"Number of thresholds for TA algorithm. Generally expect to use the default value.";
  v13.n128_u64[1] = 81;
  int v10 = 1;
  LODWORD(v11) = 25;
  *(void *)&long long v12 = &v11;
  mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::initializer<int>,llvm::cl::OptionHidden>((void *)v4 + 198, v6, (uint64_t)"num-thresholds", 14, &v13, (int **)&v12, &v10);
  *((void *)v4 + 198) = &unk_1EC9CB120;
  *((void *)v4 + 222) = &unk_1EC9CB1A0;
  v13.n128_u64[0] = (unint64_t)"Number of steps for a single threshold for TA algorithm. Generally expect to use t"
                                      "he default value.";
  v13.n128_u64[1] = 99;
  int v10 = 1;
  LODWORD(v11) = 10;
  *(void *)&long long v12 = &v11;
  mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::initializer<int>,llvm::cl::OptionHidden>((void *)v4 + 224, v6, (uint64_t)"num-steps", 9, &v13, (int **)&v12, &v10);
  *((void *)v4 + 224) = &unk_1EC9CB120;
  *((void *)v4 + 248) = &unk_1EC9CB1A0;
  v13.n128_u64[0] = (unint64_t)"Number of steps required for convergence. Generally expect to use the default value.";
  v13.n128_u64[1] = 84;
  int v10 = 1;
  LODWORD(v11) = 10;
  *(void *)&long long v12 = &v11;
  mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::initializer<int>,llvm::cl::OptionHidden>((void *)v4 + 250, v6, (uint64_t)"convergence-threshold", 21, &v13, (int **)&v12, &v10);
  *((void *)v4 + 250) = &unk_1EC9CB120;
  *((void *)v4 + 274) = &unk_1EC9CB1A0;
  v13.n128_u64[0] = (unint64_t)"The seed to use for the RNG. This will ensure that the random numbers can be gener"
                                      "ated deterministically.";
  v13.n128_u64[1] = 105;
  int v10 = 1;
  LODWORD(v11) = 0;
  *(void *)&long long v12 = &v11;
  double result = mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::Option<llvm::cl::desc,llvm::cl::initializer<int>,llvm::cl::OptionHidden>((void *)v4 + 276, v6, (uint64_t)"rng-seed", 8, &v13, (int **)&v12, &v10);
  *((void *)v4 + 276) = &unk_1EC9CB1E0;
  *((void *)v4 + 301) = &unk_1EC9CB260;
  *(void *)uint64_t v4 = &unk_1EC9A5578;
  *a2 = v4;
  return result;
}

void *mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::initializer<int>,llvm::cl::OptionHidden>(void *a1, void *a2, uint64_t a3, uint64_t a4, __n128 *a5, int **a6, _WORD *a7)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  v32[0] = a3;
  v32[1] = a4;
  v35[0] = a2;
  uint64_t v9 = llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>,llvm::cl::OptionHidden>((uint64_t)a1, (uint64_t)v32, v35, a5, a6, a7);
  uint64_t v10 = v9 + 192;
  *(unsigned char *)(v9 + 200) = 0;
  *(void *)uint64_t v9 = &unk_1EC9CCEC8;
  *(void *)(v9 + 192) = &unk_1EC9CCF48;
  long long v12 = (uint64_t *)a2[21];
  unint64_t v11 = a2[22];
  __n128 v13 = v12;
  if ((unint64_t)v12 >= v11)
  {
    uint64_t v15 = (uint64_t *)a2[20];
    uint64_t v16 = v12 - v15;
    unint64_t v17 = v16 + 1;
    if ((unint64_t)(v16 + 1) >> 61) {
      abort();
    }
    uint64_t v18 = v11 - (void)v15;
    if (v18 >> 2 > v17) {
      unint64_t v17 = v18 >> 2;
    }
    if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v19 = v17;
    }
    if (v19)
    {
      if (v19 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v20 = (char *)operator new(8 * v19);
    }
    else
    {
      uint64_t v20 = 0;
    }
    uint64_t v21 = (uint64_t *)&v20[8 * v16];
    uint64_t v22 = &v20[8 * v19];
    *uint64_t v21 = v10;
    long long v14 = v21 + 1;
    if (v12 != v15)
    {
      unint64_t v23 = (char *)v12 - (char *)v15 - 8;
      if (v23 < 0x58) {
        goto LABEL_36;
      }
      if ((unint64_t)((char *)v15 - v20) < 0x20) {
        goto LABEL_36;
      }
      uint64_t v24 = (v23 >> 3) + 1;
      uint64_t v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
      __n128 v13 = &v12[v25 / 0xFFFFFFFFFFFFFFF8];
      uint64_t v21 = (uint64_t *)((char *)v21 - v25);
      long long v26 = &v20[8 * v16 - 16];
      uint64_t v27 = v12 - 2;
      uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *((_OWORD *)v26 - 1) = *((_OWORD *)v27 - 1);
        *(_OWORD *)long long v26 = v29;
        v26 -= 32;
        v27 -= 4;
        v28 -= 4;
      }
      while (v28);
      if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_36:
        do
        {
          uint64_t v30 = *--v13;
          *--uint64_t v21 = v30;
        }
        while (v13 != v15);
      }
      __n128 v13 = (uint64_t *)a2[20];
    }
    a2[20] = v21;
    a2[21] = v14;
    a2[22] = v22;
    if (v13) {
      operator delete(v13);
    }
  }
  else
  {
    *long long v12 = v10;
    long long v14 = v12 + 1;
  }
  a2[21] = v14;
  v33[0] = &unk_1EC9CF9D0;
  v33[1] = a1;
  uint64_t v36 = v35;
  uint64_t v34 = v33;
  v35[0] = &unk_1EC9CF9D0;
  v35[1] = a1;
  std::__function::__value_func<void ()(unsigned int const&)>::swap[abi:nn180100](v35, a1 + 20);
  if (v36 == v35)
  {
    (*((void (**)(const void **))v35[0] + 4))(v35);
  }
  else if (v36)
  {
    (*((void (**)(void))*v36 + 5))();
  }
  if (v34 == v33)
  {
    (*(void (**)(void *))(v33[0] + 32))(v33);
  }
  else if (v34)
  {
    (*(void (**)(void))(*v34 + 40))();
  }
  return a1;
}

uint64_t llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>,llvm::cl::OptionHidden>(uint64_t a1, uint64_t a2, const void **a3, __n128 *a4, int **a5, _WORD *a6)
{
  *(void *)a1 = &unk_1EC9A42A8;
  *(_WORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 10) &= 0x8000u;
  long long v12 = (void *)(a1 + 80);
  *(void *)(a1 + 64) = a1 + 80;
  uint64_t v13 = a1 + 64;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_DWORD *)(a1 + 60) = 0;
  *(void *)(a1 + 72) = 0x100000000;
  *(void *)(a1 + 88) = a1 + 120;
  *(void *)(a1 + 96) = a1 + 120;
  *(void *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 112) = 0;
  GeneralCategory = llvm::cl::getGeneralCategory((llvm::cl *)a1);
  uint64_t v15 = *(unsigned int *)(a1 + 72);
  if (v15 >= *(_DWORD *)(a1 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v13, v12, v15 + 1, 8);
    LODWORD(v15) = *(_DWORD *)(a1 + 72);
  }
  *(void *)(*(void *)(a1 + 64) + 8 * v15) = GeneralCategory;
  ++*(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = &unk_1EC9A3B00;
  *(void *)(a1 + 144) = 0;
  *(void *)a1 = &unk_1EC9A3FD0;
  *(void *)(a1 + 152) = &unk_1EC9A4470;
  *(void *)(a1 + 160) = &unk_1EC9CE720;
  *(void *)(a1 + 184) = a1 + 160;
  llvm::cl::apply<llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>,llvm::cl::OptionHidden>(a1, a2, a3, a4, a5, a6);
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

__n128 llvm::cl::apply<llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>,llvm::cl::OptionHidden>(uint64_t a1, uint64_t a2, const void **a3, __n128 *a4, int **a5, _WORD *a6)
{
  llvm::cl::Option::setArgStr(a1, *(int8x16_t **)a2, *(const unsigned __int8 **)(a2 + 8));
  unint64_t v11 = *a3;
  uint64_t v12 = *(void *)(a1 + 96);
  if (v12 != *(void *)(a1 + 88))
  {
LABEL_2:
    llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)(a1 + 88), v11);
    goto LABEL_3;
  }
  uint64_t v15 = *(unsigned int *)(a1 + 108);
  if (!v15)
  {
LABEL_12:
    if (v15 < *(_DWORD *)(a1 + 104))
    {
      *(_DWORD *)(a1 + 108) = v15 + 1;
      *(void *)(v12 + 8 * v15) = v11;
      goto LABEL_3;
    }
    goto LABEL_2;
  }
  uint64_t v16 = 0;
  uint64_t v17 = 8 * v15;
  uint64_t v18 = *(void **)(a1 + 96);
  while ((const void *)*v18 != v11)
  {
    if (*v18 == -2) {
      uint64_t v16 = v18;
    }
    ++v18;
    v17 -= 8;
    if (!v17)
    {
      if (!v16) {
        goto LABEL_12;
      }
      *uint64_t v16 = v11;
      --*(_DWORD *)(a1 + 112);
      break;
    }
  }
LABEL_3:
  __n128 result = *a4;
  *(__n128 *)(a1 + 32) = *a4;
  int v14 = **a5;
  *(_DWORD *)(a1 + 128) = v14;
  *(unsigned char *)(a1 + 148) = 1;
  *(_DWORD *)(a1 + 144) = v14;
  *(_WORD *)(a1 + 10) = (32 * (*a6 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIjN4llvm2cl6parserIjEEEC1IJNS7_4descENS7_11initializerIiEENS7_12OptionHiddenEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISO_EEFvRKjEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EC9CF9D0;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIjN4llvm2cl6parserIjEEEC1IJNS7_4descENS7_11initializerIiEENS7_12OptionHiddenEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISO_EEFvRKjEE7__cloneEPNS0_6__baseIST_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EC9CF9D0;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIjN4llvm2cl6parserIjEEEC1IJNS7_4descENS7_11initializerIiEENS7_12OptionHiddenEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISO_EEFvRKjEEclESS_(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 8) + 200) = 1;
  return result;
}

void *mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::Option<llvm::cl::desc,llvm::cl::initializer<int>,llvm::cl::OptionHidden>(void *a1, void *a2, uint64_t a3, uint64_t a4, __n128 *a5, int **a6, _WORD *a7)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  v32[0] = a3;
  v32[1] = a4;
  v35[0] = a2;
  uint64_t v9 = llvm::cl::opt<long long,false,llvm::cl::parser<long long>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>,llvm::cl::OptionHidden>((uint64_t)a1, (uint64_t)v32, v35, a5, a6, a7);
  uint64_t v10 = v9 + 200;
  *(unsigned char *)(v9 + 208) = 0;
  *(void *)uint64_t v9 = &unk_1EC9CCF88;
  *(void *)(v9 + 200) = &unk_1EC9CD008;
  uint64_t v12 = (uint64_t *)a2[21];
  unint64_t v11 = a2[22];
  uint64_t v13 = v12;
  if ((unint64_t)v12 >= v11)
  {
    uint64_t v15 = (uint64_t *)a2[20];
    uint64_t v16 = v12 - v15;
    unint64_t v17 = v16 + 1;
    if ((unint64_t)(v16 + 1) >> 61) {
      abort();
    }
    uint64_t v18 = v11 - (void)v15;
    if (v18 >> 2 > v17) {
      unint64_t v17 = v18 >> 2;
    }
    if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v19 = v17;
    }
    if (v19)
    {
      if (v19 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v20 = (char *)operator new(8 * v19);
    }
    else
    {
      uint64_t v20 = 0;
    }
    uint64_t v21 = (uint64_t *)&v20[8 * v16];
    uint64_t v22 = &v20[8 * v19];
    *uint64_t v21 = v10;
    int v14 = v21 + 1;
    if (v12 != v15)
    {
      unint64_t v23 = (char *)v12 - (char *)v15 - 8;
      if (v23 < 0x58) {
        goto LABEL_36;
      }
      if ((unint64_t)((char *)v15 - v20) < 0x20) {
        goto LABEL_36;
      }
      uint64_t v24 = (v23 >> 3) + 1;
      uint64_t v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v13 = &v12[v25 / 0xFFFFFFFFFFFFFFF8];
      uint64_t v21 = (uint64_t *)((char *)v21 - v25);
      long long v26 = &v20[8 * v16 - 16];
      uint64_t v27 = v12 - 2;
      uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *((_OWORD *)v26 - 1) = *((_OWORD *)v27 - 1);
        *(_OWORD *)long long v26 = v29;
        v26 -= 32;
        v27 -= 4;
        v28 -= 4;
      }
      while (v28);
      if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_36:
        do
        {
          uint64_t v30 = *--v13;
          *--uint64_t v21 = v30;
        }
        while (v13 != v15);
      }
      uint64_t v13 = (uint64_t *)a2[20];
    }
    a2[20] = v21;
    a2[21] = v14;
    a2[22] = v22;
    if (v13) {
      operator delete(v13);
    }
  }
  else
  {
    *uint64_t v12 = v10;
    int v14 = v12 + 1;
  }
  a2[21] = v14;
  v33[0] = &unk_1EC9CFA60;
  v33[1] = a1;
  uint64_t v36 = v35;
  uint64_t v34 = v33;
  v35[0] = &unk_1EC9CFA60;
  v35[1] = a1;
  std::__function::__value_func<void ()(long long const&)>::swap[abi:nn180100](v35, a1 + 21);
  if (v36 == v35)
  {
    (*((void (**)(const void **))v35[0] + 4))(v35);
  }
  else if (v36)
  {
    (*((void (**)(void))*v36 + 5))();
  }
  if (v34 == v33)
  {
    (*(void (**)(void *))(v33[0] + 32))(v33);
  }
  else if (v34)
  {
    (*(void (**)(void))(*v34 + 40))();
  }
  return a1;
}

uint64_t llvm::cl::opt<long long,false,llvm::cl::parser<long long>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>,llvm::cl::OptionHidden>(uint64_t a1, uint64_t a2, const void **a3, __n128 *a4, int **a5, _WORD *a6)
{
  *(void *)a1 = &unk_1EC9A42A8;
  *(_WORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 10) &= 0x8000u;
  uint64_t v12 = (void *)(a1 + 80);
  *(void *)(a1 + 64) = a1 + 80;
  uint64_t v13 = a1 + 64;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_DWORD *)(a1 + 60) = 0;
  *(void *)(a1 + 72) = 0x100000000;
  *(void *)(a1 + 88) = a1 + 120;
  *(void *)(a1 + 96) = a1 + 120;
  *(void *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 112) = 0;
  GeneralCategory = llvm::cl::getGeneralCategory((llvm::cl *)a1);
  uint64_t v15 = *(unsigned int *)(a1 + 72);
  if (v15 >= *(_DWORD *)(a1 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v13, v12, v15 + 1, 8);
    LODWORD(v15) = *(_DWORD *)(a1 + 72);
  }
  *(void *)(*(void *)(a1 + 64) + 8 * v15) = GeneralCategory;
  ++*(_DWORD *)(a1 + 72);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(void *)(a1 + 136) = &unk_1EC9A3B20;
  *(void *)a1 = &unk_1EC9A4038;
  *(void *)(a1 + 160) = &unk_1EC9A44A0;
  *(void *)(a1 + 168) = &unk_1EC9CE768;
  *(void *)(a1 + 192) = a1 + 168;
  llvm::cl::apply<llvm::cl::opt<long long,false,llvm::cl::parser<long long>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>,llvm::cl::OptionHidden>(a1, a2, a3, a4, a5, a6);
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

__n128 llvm::cl::apply<llvm::cl::opt<long long,false,llvm::cl::parser<long long>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>,llvm::cl::OptionHidden>(uint64_t a1, uint64_t a2, const void **a3, __n128 *a4, int **a5, _WORD *a6)
{
  llvm::cl::Option::setArgStr(a1, *(int8x16_t **)a2, *(const unsigned __int8 **)(a2 + 8));
  unint64_t v11 = *a3;
  uint64_t v12 = *(void *)(a1 + 96);
  if (v12 != *(void *)(a1 + 88))
  {
LABEL_2:
    llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)(a1 + 88), v11);
    goto LABEL_3;
  }
  uint64_t v15 = *(unsigned int *)(a1 + 108);
  if (!v15)
  {
LABEL_12:
    if (v15 < *(_DWORD *)(a1 + 104))
    {
      *(_DWORD *)(a1 + 108) = v15 + 1;
      *(void *)(v12 + 8 * v15) = v11;
      goto LABEL_3;
    }
    goto LABEL_2;
  }
  uint64_t v16 = 0;
  uint64_t v17 = 8 * v15;
  uint64_t v18 = *(void **)(a1 + 96);
  while ((const void *)*v18 != v11)
  {
    if (*v18 == -2) {
      uint64_t v16 = v18;
    }
    ++v18;
    v17 -= 8;
    if (!v17)
    {
      if (!v16) {
        goto LABEL_12;
      }
      *uint64_t v16 = v11;
      --*(_DWORD *)(a1 + 112);
      break;
    }
  }
LABEL_3:
  __n128 result = *a4;
  *(__n128 *)(a1 + 32) = *a4;
  uint64_t v14 = **a5;
  *(void *)(a1 + 128) = v14;
  *(unsigned char *)(a1 + 152) = 1;
  *(void *)(a1 + 144) = v14;
  *(_WORD *)(a1 + 10) = (32 * (*a6 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIxN4llvm2cl6parserIxEEEC1IJNS7_4descENS7_11initializerIiEENS7_12OptionHiddenEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISO_EEFvRKxEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EC9CFA60;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIxN4llvm2cl6parserIxEEEC1IJNS7_4descENS7_11initializerIiEENS7_12OptionHiddenEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISO_EEFvRKxEE7__cloneEPNS0_6__baseIST_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EC9CFA60;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIxN4llvm2cl6parserIxEEEC1IJNS7_4descENS7_11initializerIiEENS7_12OptionHiddenEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISO_EEFvRKxEEclESS_(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 8) + 208) = 1;
  return result;
}

void *std::__function::__func<mlir::anonymous namespace'::MPSPlacement::runOnOperation(void)::{lambda(mlir::Operation *)#1},std::allocator<mlir::anonymous namespace'::MPSPlacement::runOnOperation(void)::{lambda(mlir::Operation *)#1}>,std::optional<BOOL> ()(mlir::Operation *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EC9CED38;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<mlir::anonymous namespace'::MPSPlacement::runOnOperation(void)::{lambda(mlir::Operation *)#1},std::allocator<mlir::anonymous namespace'::MPSPlacement::runOnOperation(void)::{lambda(mlir::Operation *)#1}>,std::optional<BOOL> ()(mlir::Operation *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EC9CED38;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<mlir::anonymous namespace'::MPSPlacement::runOnOperation(void)::{lambda(mlir::Operation *)#1},std::allocator<mlir::anonymous namespace'::MPSPlacement::runOnOperation(void)::{lambda(mlir::Operation *)#1}>,std::optional<BOOL> ()(mlir::Operation *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  BOOL v4 = mlir::verifyCompatibleTypesWithANE(*a2, *(_DWORD *)(v3 + 472), 1, 1);
  BOOL v5 = v4;
  uint64_t v6 = mlir::TypeID::get<mlir::anec::VerifyAttributesWithFamilyInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::VerifyAttributesWithFamilyInterface::Trait>(void)::Empty>>();
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(v2 + 48) + 32))(*(void *)(v2 + 48), v6))
  {
    BOOL v7 = v4;
    v9[0] = v2;
    v9[1] = mlir::OpInterface<mlir::anec::VerifyAttributesWithFamilyInterface,mlir::anec::detail::VerifyAttributesWithFamilyInterfaceInterfaceTraits>::getInterfaceFor(v2);
    if (mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v9, *(unsigned int *)(v3 + 472)))BOOL v5 = v7; {
    else
    }
      BOOL v5 = 0;
  }
  return (mlir::anec::isCompatibleWithFamily(v2, *(_DWORD *)(v3 + 472)) && v5) | 0x100u;
}

unsigned char *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps10ConstantOpEZNS2_12_GLOBAL__N_112MPSPlacement14runOnOperationEvEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSB_EUlSD_E_NS_9allocatorISH_EEFNS_8optionalIbEESD_EE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  *(void *)__n128 result = &unk_1EC9CF178;
  result[8] = *(unsigned char *)(a1 + 8);
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps10ConstantOpEZNS2_12_GLOBAL__N_112MPSPlacement14runOnOperationEvEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSB_EUlSD_E_NS_9allocatorISH_EEFNS_8optionalIbEESD_EE7__cloneEPNS0_6__baseISM_EE(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EC9CF178;
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(result + 8);
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps10ConstantOpEZNS2_12_GLOBAL__N_112MPSPlacement14runOnOperationEvEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSB_EUlSD_E_NS_9allocatorISH_EEFNS_8optionalIbEESD_EEclEOSD_(uint64_t a1, void *a2)
{
  unint64_t v2 = *(void *)(*a2 - 8) & 0xFFFFFFFFFFFFFFF8;
  if (*(_UNKNOWN **)(*(void *)v2 + 136) != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id) {
    unint64_t v2 = 0;
  }
  unint64_t v6 = v2;
  if (v2)
  {
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v6);
    if (v3)
    {
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v6);
      LODWORD(v2) = v4 > 3;
    }
    else
    {
      LODWORD(v2) = 1;
    }
  }
  return v2 | 0x100;
}

uint64_t mlir::anonymous namespace'::ANEDeviceInterface::getConvertedTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v15 = a2;
  uint64_t v16 = 0;
  if (a3)
  {
    uint64_t v7 = 0;
    uint64_t v8 = a1 + 32;
    uint64_t v9 = (void *)(a4 + 16);
    do
    {
      uint64_t v10 = mlir::ValueRange::dereference_iterator(&v15, v7);
      uint64_t v11 = mlir::TypeConverter::convertType(v8, (void *)(*(void *)(v10 + 8) & 0xFFFFFFFFFFFFFFF8));
      unint64_t v12 = *(unsigned int *)(a4 + 8);
      if (v12 >= *(unsigned int *)(a4 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a4, v9, v12 + 1, 8);
        unint64_t v12 = *(unsigned int *)(a4 + 8);
      }
      *(void *)(*(void *)a4 + 8 * v12) = v11;
      ++*(_DWORD *)(a4 + 8);
      uint64_t v7 = ++v16;
    }
    while (v15 != a2 || v7 != a3);
  }
  return 1;
}

uint64_t mlir::anonymous namespace'::ANEDeviceInterface::getConvertedType(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *a3 = mlir::TypeConverter::convertType(a1 + 32, (void *)(*(void *)(a2 + 8) & 0xFFFFFFFFFFFFFFF8));
  return 1;
}

mlir::GenericProgramPoint *mlir::anonymous namespace'::ANEDeviceInterface::materializeRegion(uint64_t a1, mlir::OpBuilder *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  v26[2] = *MEMORY[0x1E4F143B8];
  v22[0] = a4;
  v22[1] = a5;
  v26[0] = a7;
  v26[1] = a8;
  v25[0] = a9;
  v25[1] = a10;
  v24[0] = a11;
  v24[1] = a12;
  v23[0] = a13;
  v23[1] = a14;
  v21[0] = a15;
  v21[1] = a16;
  v20[0] = a17;
  v20[1] = a18;
  switch(*(_DWORD *)(a1 + 568))
  {
    case 1:
      uint64_t v18 = mlir::OpBuilder::create<mlir::anec::A13,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(a2, a3, (uint64_t)v22, a6, (uint64_t)v26, v25, (uint64_t)v24, v23, (uint64_t)v21, (uint64_t)v20);
      if (v18) {
        goto LABEL_15;
      }
      break;
    case 2:
      uint64_t v18 = mlir::OpBuilder::create<mlir::anec::A14,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(a2, a3, (uint64_t)v22, a6, (uint64_t)v26, v25, (uint64_t)v24, v23, (uint64_t)v21, (uint64_t)v20);
      if (v18) {
        goto LABEL_15;
      }
      break;
    case 3:
      uint64_t v18 = mlir::OpBuilder::create<mlir::anec::A15,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(a2, a3, (uint64_t)v22, a6, (uint64_t)v26, v25, (uint64_t)v24, v23, (uint64_t)v21, (uint64_t)v20);
      if (v18) {
        goto LABEL_15;
      }
      break;
    case 4:
      uint64_t v18 = mlir::OpBuilder::create<mlir::anec::A16,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(a2, a3, (uint64_t)v22, a6, (uint64_t)v26, v25, (uint64_t)v24, v23, (uint64_t)v21, (uint64_t)v20);
      if (v18) {
        goto LABEL_15;
      }
      break;
    case 5:
      uint64_t v18 = mlir::OpBuilder::create<mlir::anec::A17,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(a2, a3, (uint64_t)v22, a6, (uint64_t)v26, v25, (uint64_t)v24, v23, (uint64_t)v21, (uint64_t)v20);
      if (v18) {
        goto LABEL_15;
      }
      break;
    case 6:
      uint64_t v18 = mlir::OpBuilder::create<mlir::anec::A11Legacy,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(a2, a3, (uint64_t)v22, a6, (uint64_t)v26, v25, (uint64_t)v24, v23, (uint64_t)v21, (uint64_t)v20);
      if (v18) {
        goto LABEL_15;
      }
      break;
    default:
      uint64_t v18 = mlir::OpBuilder::create<mlir::anec::A12,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(a2, a3, (uint64_t)v22, a6, (uint64_t)v26, v25, (uint64_t)v24, v23, (uint64_t)v21, (uint64_t)v20);
      if (v18) {
LABEL_15:
      }
        mlir::OpInterface<mlir::FormableRegionOpInterface,mlir::detail::FormableRegionOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)v18);
      break;
  }
  return v18;
}

uint64_t mlir::anonymous namespace'::ANEDeviceInterface::materializeHostTypeConversion(uint64_t a1, mlir::UnknownLoc **a2, uint64_t a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  return mlir::materializeMPSToANECHostTypeConversion(a2, a3, a4, a5, a6, a7);
}

mlir::GenericProgramPoint *mlir::anonymous namespace'::ANEDeviceInterface::materializeCallOp(uint64_t a1, mlir::MLIRContext **a2, uint64_t a3, mlir::SymbolRefAttr *a4, uint64_t a5, uint64_t a6)
{
  void v9[2] = *MEMORY[0x1E4F143B8];
  v9[0] = a5;
  v9[1] = a6;
  uint64_t v8 = a4;
  int v7 = 1;
  return mlir::OpBuilder::create<mlir::placement::RegionCall,mlir::Operation *&,mlir::placement::RegionType,mlir::ValueRange &>(a2, a3, &v8, &v7, v9);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::A12,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t *a8, uint64_t a9, uint64_t a10)
{
  v30[38] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v25);
  uint64_t v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.A12", (const unsigned __int8 *)8, Context);
  if (!v20)
  {
    __int16 v29 = 1283;
    void v28[2] = (uint64_t)"anec.A12";
    v28[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v27 = 259;
    llvm::operator+(v28, (uint64_t *)&v26, (uint64_t)v30);
    llvm::report_fatal_error((llvm::Twine *)v30, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v19);
  mlir::anec::A11Legacy::build((uint64_t)a1, (uint64_t)v30, *(void **)a3, *(void *)(a3 + 8), a4, *(void **)a5, *(void *)(a5 + 8), v21, *a6, a6[1], *(void **)a7, *(void *)(a7 + 8), *a8, a8[1], *(mlir::Operation ***)a9, *(void *)(a9 + 8), *(void **)a10, *(void *)(a10 + 8));
  uint64_t v22 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v30);
  if (*(_UNKNOWN **)(*((void *)v22 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::A12,void>::id) {
    unint64_t v23 = v22;
  }
  else {
    unint64_t v23 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v23;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::A13,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t *a8, uint64_t a9, uint64_t a10)
{
  v30[38] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v25);
  uint64_t v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.A13", (const unsigned __int8 *)8, Context);
  if (!v20)
  {
    __int16 v29 = 1283;
    void v28[2] = (uint64_t)"anec.A13";
    v28[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v27 = 259;
    llvm::operator+(v28, (uint64_t *)&v26, (uint64_t)v30);
    llvm::report_fatal_error((llvm::Twine *)v30, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v19);
  mlir::anec::A11Legacy::build((uint64_t)a1, (uint64_t)v30, *(void **)a3, *(void *)(a3 + 8), a4, *(void **)a5, *(void *)(a5 + 8), v21, *a6, a6[1], *(void **)a7, *(void *)(a7 + 8), *a8, a8[1], *(mlir::Operation ***)a9, *(void *)(a9 + 8), *(void **)a10, *(void *)(a10 + 8));
  uint64_t v22 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v30);
  if (*(_UNKNOWN **)(*((void *)v22 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::A13,void>::id) {
    unint64_t v23 = v22;
  }
  else {
    unint64_t v23 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v23;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::A14,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t *a8, uint64_t a9, uint64_t a10)
{
  v30[38] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v25);
  uint64_t v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.A14", (const unsigned __int8 *)8, Context);
  if (!v20)
  {
    __int16 v29 = 1283;
    void v28[2] = (uint64_t)"anec.A14";
    v28[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v27 = 259;
    llvm::operator+(v28, (uint64_t *)&v26, (uint64_t)v30);
    llvm::report_fatal_error((llvm::Twine *)v30, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v19);
  mlir::anec::A11Legacy::build((uint64_t)a1, (uint64_t)v30, *(void **)a3, *(void *)(a3 + 8), a4, *(void **)a5, *(void *)(a5 + 8), v21, *a6, a6[1], *(void **)a7, *(void *)(a7 + 8), *a8, a8[1], *(mlir::Operation ***)a9, *(void *)(a9 + 8), *(void **)a10, *(void *)(a10 + 8));
  uint64_t v22 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v30);
  if (*(_UNKNOWN **)(*((void *)v22 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::A14,void>::id) {
    unint64_t v23 = v22;
  }
  else {
    unint64_t v23 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v23;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::A15,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t *a8, uint64_t a9, uint64_t a10)
{
  v30[38] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v25);
  uint64_t v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.A15", (const unsigned __int8 *)8, Context);
  if (!v20)
  {
    __int16 v29 = 1283;
    void v28[2] = (uint64_t)"anec.A15";
    v28[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v27 = 259;
    llvm::operator+(v28, (uint64_t *)&v26, (uint64_t)v30);
    llvm::report_fatal_error((llvm::Twine *)v30, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v19);
  mlir::anec::A11Legacy::build((uint64_t)a1, (uint64_t)v30, *(void **)a3, *(void *)(a3 + 8), a4, *(void **)a5, *(void *)(a5 + 8), v21, *a6, a6[1], *(void **)a7, *(void *)(a7 + 8), *a8, a8[1], *(mlir::Operation ***)a9, *(void *)(a9 + 8), *(void **)a10, *(void *)(a10 + 8));
  uint64_t v22 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v30);
  if (*(_UNKNOWN **)(*((void *)v22 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::A15,void>::id) {
    unint64_t v23 = v22;
  }
  else {
    unint64_t v23 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v23;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::A16,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t *a8, uint64_t a9, uint64_t a10)
{
  v30[38] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v25);
  uint64_t v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.A16", (const unsigned __int8 *)8, Context);
  if (!v20)
  {
    __int16 v29 = 1283;
    void v28[2] = (uint64_t)"anec.A16";
    v28[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v27 = 259;
    llvm::operator+(v28, (uint64_t *)&v26, (uint64_t)v30);
    llvm::report_fatal_error((llvm::Twine *)v30, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v19);
  mlir::anec::A11Legacy::build((uint64_t)a1, (uint64_t)v30, *(void **)a3, *(void *)(a3 + 8), a4, *(void **)a5, *(void *)(a5 + 8), v21, *a6, a6[1], *(void **)a7, *(void *)(a7 + 8), *a8, a8[1], *(mlir::Operation ***)a9, *(void *)(a9 + 8), *(void **)a10, *(void *)(a10 + 8));
  uint64_t v22 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v30);
  if (*(_UNKNOWN **)(*((void *)v22 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::A16,void>::id) {
    unint64_t v23 = v22;
  }
  else {
    unint64_t v23 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v23;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::A17,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t *a8, uint64_t a9, uint64_t a10)
{
  v30[38] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v25);
  uint64_t v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.A17", (const unsigned __int8 *)8, Context);
  if (!v20)
  {
    __int16 v29 = 1283;
    void v28[2] = (uint64_t)"anec.A17";
    v28[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v27 = 259;
    llvm::operator+(v28, (uint64_t *)&v26, (uint64_t)v30);
    llvm::report_fatal_error((llvm::Twine *)v30, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v19);
  mlir::anec::A11Legacy::build((uint64_t)a1, (uint64_t)v30, *(void **)a3, *(void *)(a3 + 8), a4, *(void **)a5, *(void *)(a5 + 8), v21, *a6, a6[1], *(void **)a7, *(void *)(a7 + 8), *a8, a8[1], *(mlir::Operation ***)a9, *(void *)(a9 + 8), *(void **)a10, *(void *)(a10 + 8));
  uint64_t v22 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v30);
  if (*(_UNKNOWN **)(*((void *)v22 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::A17,void>::id) {
    unint64_t v23 = v22;
  }
  else {
    unint64_t v23 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v23;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::A11Legacy,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t *a8, uint64_t a9, uint64_t a10)
{
  v30[38] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v25);
  uint64_t v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.A11Legacy", (const unsigned __int8 *)0xE, Context);
  if (!v20)
  {
    __int16 v29 = 1283;
    void v28[2] = (uint64_t)"anec.A11Legacy";
    v28[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v27 = 259;
    llvm::operator+(v28, (uint64_t *)&v26, (uint64_t)v30);
    llvm::report_fatal_error((llvm::Twine *)v30, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v19);
  mlir::anec::A11Legacy::build((uint64_t)a1, (uint64_t)v30, *(void **)a3, *(void *)(a3 + 8), a4, *(void **)a5, *(void *)(a5 + 8), v21, *a6, a6[1], *(void **)a7, *(void *)(a7 + 8), *a8, a8[1], *(mlir::Operation ***)a9, *(void *)(a9 + 8), *(void **)a10, *(void *)(a10 + 8));
  uint64_t v22 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v30);
  if (*(_UNKNOWN **)(*((void *)v22 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::A11Legacy,void>::id) {
    unint64_t v23 = v22;
  }
  else {
    unint64_t v23 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v23;
}

uint64_t mlir::anonymous namespace'::GPUDeviceInterface::getConvertedTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a2;
  uint64_t v14 = 0;
  if (a3)
  {
    uint64_t v7 = 0;
    uint64_t v8 = (void *)(a4 + 16);
    do
    {
      uint64_t v9 = *(void *)(mlir::ValueRange::dereference_iterator(&v13, v7) + 8);
      unint64_t v10 = *(unsigned int *)(a4 + 8);
      if (v10 >= *(unsigned int *)(a4 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a4, v8, v10 + 1, 8);
        unint64_t v10 = *(unsigned int *)(a4 + 8);
      }
      *(void *)(*(void *)a4 + 8 * v10) = v9 & 0xFFFFFFFFFFFFFFF8;
      ++*(_DWORD *)(a4 + 8);
      uint64_t v7 = ++v14;
    }
    while (v13 != a2 || v7 != a3);
  }
  return 1;
}

uint64_t mlir::anonymous namespace'::GPUDeviceInterface::getConvertedType(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  *a3 = *(void *)(a2 + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

mlir::GenericProgramPoint *mlir::anonymous namespace'::GPUDeviceInterface::materializeRegion(uint64_t a1, mlir::OpBuilder *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  v27[2] = *MEMORY[0x1E4F143B8];
  v23[0] = a4;
  v23[1] = a5;
  v27[0] = a7;
  v27[1] = a8;
  v26[0] = a9;
  v26[1] = a10;
  v25[0] = a11;
  v25[1] = a12;
  v24[0] = a13;
  v24[1] = a14;
  v22[0] = a15;
  v22[1] = a16;
  v21[0] = a17;
  v21[1] = a18;
  uint64_t v18 = mlir::OpBuilder::create<mlir::mpsx::GPUOp,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(a2, a3, (uint64_t)v23, a6, (uint64_t)v27, v26, (uint64_t)v25, v24, (uint64_t)v22, (uint64_t)v21);
  uint64_t v19 = v18;
  if (v18) {
    mlir::OpInterface<mlir::FormableRegionOpInterface,mlir::detail::FormableRegionOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)v18);
  }
  return v19;
}

uint64_t mlir::anonymous namespace'::GPUDeviceInterface::materializeHostTypeConversion(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  unint64_t v12 = a4;
  uint64_t v13 = 0;
  char v9 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>(a7, &v12, &v13);
  unint64_t v10 = v13;
  if ((v9 & 1) == 0)
  {
    unint64_t v10 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)a7, (uint64_t)&v12, &v12, v13);
    *unint64_t v10 = v12;
    v10[1] = 0;
  }
  v10[1] = a4;
  return 1;
}

mlir::GenericProgramPoint *mlir::anonymous namespace'::GPUDeviceInterface::materializeCallOp(uint64_t a1, mlir::MLIRContext **a2, uint64_t a3, mlir::SymbolRefAttr *a4, uint64_t a5, uint64_t a6)
{
  void v9[2] = *MEMORY[0x1E4F143B8];
  v9[0] = a5;
  v9[1] = a6;
  uint64_t v8 = a4;
  int v7 = 0;
  return mlir::OpBuilder::create<mlir::placement::RegionCall,mlir::Operation *&,mlir::placement::RegionType,mlir::ValueRange &>(a2, a3, &v8, &v7, v9);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mpsx::GPUOp,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t *a8, uint64_t a9, uint64_t a10)
{
  v30[38] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v25);
  uint64_t v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.gpu", (const unsigned __int8 *)8, Context);
  if (!v20)
  {
    __int16 v29 = 1283;
    void v28[2] = (uint64_t)"mpsx.gpu";
    v28[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v27 = 259;
    llvm::operator+(v28, (uint64_t *)&v26, (uint64_t)v30);
    llvm::report_fatal_error((llvm::Twine *)v30, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v19);
  mlir::mpsx::ANEOp::build((uint64_t)a1, (uint64_t)v30, *(void **)a3, *(void *)(a3 + 8), a4, *(void **)a5, *(void *)(a5 + 8), v21, *a6, a6[1], *(void **)a7, *(void *)(a7 + 8), *a8, a8[1], *(mlir::Operation ***)a9, *(void *)(a9 + 8), *(void **)a10, *(void *)(a10 + 8));
  uint64_t v22 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v30);
  if (*(_UNKNOWN **)(*((void *)v22 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::GPUOp,void>::id) {
    unint64_t v23 = v22;
  }
  else {
    unint64_t v23 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v23;
}

BOOL mlir::verifyANECompatibleElementType(void *a1)
{
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(a1);
  uint64_t v3 = ElementTypeOrSelf;
  if (ElementTypeOrSelf
    && *(_UNKNOWN **)(*(void *)ElementTypeOrSelf + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
  {
    uint64_t v3 = mlir::MPSToANECTypeConverter::canonicalizeIntegerType(ElementTypeOrSelf);
  }
  return mlir::Type::isF16((mlir::Type *)&v3)
      || mlir::Type::isSignedInteger((mlir::Type *)&v3, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&v3, 8);
}

uint64_t *mlir::verifyANECompatibleType(uint64_t *a1, int a2)
{
  __n128 result = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible(a1);
  v8[0] = result;
  v8[1] = v5;
  if (result)
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v8);
    if (a2 <= 1 && v6 == 5)
    {
      return 0;
    }
    else
    {
      uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(a1);
      uint64_t v9 = ElementTypeOrSelf;
      if (ElementTypeOrSelf
        && *(_UNKNOWN **)(*(void *)ElementTypeOrSelf + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
      {
        uint64_t v9 = mlir::MPSToANECTypeConverter::canonicalizeIntegerType(ElementTypeOrSelf);
      }
      if (mlir::Type::isF16((mlir::Type *)&v9) || mlir::Type::isSignedInteger((mlir::Type *)&v9, 8)) {
        return (uint64_t *)1;
      }
      else {
        return (uint64_t *)mlir::Type::isUnsignedInteger((mlir::Type *)&v9, 8);
      }
    }
  }
  return result;
}

BOOL mlir::verifyCompatibleTypesWithANE(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t v8 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48), v8)) {
    return *(void *)(*(void *)mlir::getElementTypeOrSelf(a1 - 16) + 136) != (void)&mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id;
  }
  if (a3 && (*(unsigned char *)(a1 + 46) & 0x80) != 0 && (uint64_t v10 = *(unsigned int *)(a1 + 68), v10))
  {
    uint64_t v11 = (uint64_t *)(*(void *)(a1 + 72) + 24);
    while (1)
    {
      uint64_t v12 = *v11;
      uint64_t v20 = *v11;
      uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v20);
      if (!DefiningOp
        || (uint64_t v14 = DefiningOp,
            uint64_t v15 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
            !(*(unsigned int (**)(void, uint64_t))(**(void **)(v14 + 48) + 32))(*(void *)(v14 + 48), v15))|| *(_UNKNOWN **)(*(void *)mlir::getElementTypeOrSelf(v12) + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
      {
        if (!mlir::verifyANECompatibleType((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8), a2))break; {
      }
        }
      v11 += 4;
      if (!--v10) {
        goto LABEL_13;
      }
    }
  }
  else
  {
LABEL_13:
    if (!a4) {
      return 1;
    }
    uint64_t v16 = *(unsigned int *)(a1 + 36);
    uint64_t v17 = v16 ? a1 - 16 : 0;
    if (!v16) {
      return 1;
    }
    uint64_t v18 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v17, v18);
      if (!mlir::verifyANECompatibleType((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), a2))break; {
      if (v16 == ++v18)
      }
        return 1;
    }
  }
  return 0;
}

uint64_t mlir::materializeMPSToANECHostTypeConversion(mlir::UnknownLoc **a1, uint64_t a2, void *a3, void *a4, void *a5, uint64_t a6)
{
  v105[1] = a5;
  uint64_t v106 = (uint64_t)a3;
  v105[0] = a4;
  int v7 = (void *)(a3[1] & 0xFFFFFFFFFFFFFFF8);
  if (a4 == v7)
  {
    RawStringData = a3;
    v104[0] = 0;
    char v47 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)a6, (unint64_t *)&RawStringData, v104);
    uint64_t v48 = v104[0];
    if ((v47 & 1) == 0)
    {
      uint64_t v48 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>(a6, (uint64_t)&RawStringData, (unint64_t *)&RawStringData, v104[0]);
      *uint64_t v48 = RawStringData;
      v48[1] = 0;
    }
    v48[1] = a3;
  }
  else
  {
    if (!v7) {
      goto LABEL_11;
    }
    uint64_t v10 = *v7;
    unint64_t v11 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v12 = *(unsigned int *)(v10 + 16);
    if (!v12) {
      goto LABEL_11;
    }
    uint64_t v13 = *(void **)(v10 + 8);
    uint64_t v14 = &v13[2 * v12];
    do
    {
      unint64_t v15 = v12 >> 1;
      uint64_t v16 = &v13[2 * (v12 >> 1)];
      unint64_t v18 = *v16;
      uint64_t v17 = v16 + 2;
      v12 += ~(v12 >> 1);
      if (v18 < v11) {
        uint64_t v13 = v17;
      }
      else {
        unint64_t v12 = v15;
      }
    }
    while (v12);
    if (v13 != v14 && *v13 == v11) {
      uint64_t v19 = (void *)v13[1];
    }
    else {
LABEL_11:
    }
      uint64_t v19 = 0;
    v104[0] = v7;
    v104[1] = v19;
    uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v105);
    uint64_t v22 = v21;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
    uint64_t v24 = mlir::RankedTensorType::get(ArgAttrsAttr, v22, OperandRange, 0);
    uint64_t v103 = 0;
    uint64_t v25 = v105[0];
    long long v26 = *(void **)(*v105[0] + 136);
    if (v26 != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id) {
      uint64_t v25 = 0;
    }
    unint64_t v107 = v25;
    if (v26 == &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
    {
      Value = (void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v107);
      __int16 v29 = v28;
      uint64_t v30 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
      RawStringData = (void *)mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&v107);
      uint64_t v102 = v31;
      unint64_t canMapOperands = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&RawStringData);
      uint64_t MemorySpace = mlir::MemRefType::getMemorySpace((mlir::MemRefType *)&v107);
      uint64_t v103 = mlir::MemRefType::get(Value, v29, v30, canMapOperands, MemorySpace);
    }
    uint64_t v34 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v104);
    uint64_t v35 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
    uint64_t v36 = *(void **)(*v105[0] + 136);
    if (v36 == &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
    {
      int v49 = *(void **)(*v104[0] + 136);
      if (v49 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
      {
        uint64_t v66 = (void *)v106;
        uint64_t v67 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
        RawStringData = v66;
        unint64_t v107 = (void *)v67;
        if (v34 != v35) {
          uint64_t v66 = (void *)((char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16);
        }
        v100 = (char *)v66;
        unint64_t v68 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v104);
        uint64_t v70 = v69;
        unint64_t v71 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v105);
        if (v70 != v72 || memcmp(v68, v71, 8 * v70))
        {
          uint64_t v73 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
          RawStringData = v66;
          unint64_t v107 = (void *)v73;
          if (v34 != v35) {
            uint64_t v66 = (void *)((char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16);
          }
          unint64_t v107 = v66;
          RawStringData = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v105);
          uint64_t v102 = v74;
          v100 = (char *)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::ArrayRef<long long>>((mlir::Builder *)a1, a2, (uint64_t *)&v107, (uint64_t)&RawStringData)- 16;
        }
        int v45 = (char *)mlir::OpBuilder::create<mlir::placement::TensorToMemref,mlir::Value &>(a1, a2, &v100) - 16;
        unint64_t v107 = (void *)v106;
LABEL_65:
        RawStringData = 0;
        char v87 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)a6, (unint64_t *)&v107, &RawStringData);
        unint64_t v88 = RawStringData;
        if ((v87 & 1) == 0)
        {
          unint64_t v88 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>(a6, (uint64_t)&v107, (unint64_t *)&v107, RawStringData);
          *unint64_t v88 = v107;
          v88[1] = 0;
        }
        v88[1] = v45;
        return 1;
      }
      if (v49 == &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
      {
        uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v106);
        if (DefiningOp
          && ((uint64_t v51 = *(void **)(*(void *)(DefiningOp + 48) + 16),
               BOOL v52 = v51 == &mlir::detail::TypeIDResolver<mlir::placement::TensorToMemref,void>::id,
               v51 != &mlir::detail::TypeIDResolver<mlir::placement::TensorToMemref,void>::id)
            ? (uint64_t v53 = 0)
            : (uint64_t v53 = (char *)DefiningOp),
              v100 = v53,
              v52))
        {
          Input = (void *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v100);
          uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v105[0]);
          RawStringData = Input;
          unint64_t v107 = (void *)ElementTypeOrSelf;
          if (v34 != v35) {
            Input = (void *)((char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16);
          }
          RawStringData = Input;
          long long v91 = (char *)mlir::OpBuilder::create<mlir::placement::TensorToMemref,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)a1, a2, (uint64_t)&v103, (uint64_t)&RawStringData)- 16;
          unint64_t v107 = (void *)v106;
          RawStringData = 0;
          char v92 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)a6, (unint64_t *)&v107, &RawStringData);
          uint64_t v93 = RawStringData;
          if ((v92 & 1) == 0)
          {
            uint64_t v93 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>(a6, (uint64_t)&v107, (unint64_t *)&v107, RawStringData);
            *uint64_t v93 = v107;
            v93[1] = 0;
          }
          v93[1] = v91;
        }
        else
        {
          uint64_t v54 = *(void **)v106;
          if (*(void *)v106)
          {
            if (!*v54)
            {
              uint64_t v55 = v54[2];
              if (v55)
              {
                if (*(_UNKNOWN **)(*(void *)(v55 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::placement::HostTypeCast,void>::id)
                {
                  uint64_t v56 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v104);
                  uint64_t v58 = v57;
                  uint64_t v59 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
                  uint64_t v60 = mlir::RankedTensorType::get(v56, v58, v59, 0);
                  long long v61 = (char *)mlir::OpBuilder::create<mlir::placement::MemrefToTensor,mlir::Value &>(a1, a2, &v106)
                      - 16;
                  if (v60 != v24)
                  {
                    uint64_t v62 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
                    RawStringData = v61;
                    unint64_t v107 = (void *)v62;
                    if (v34 != v35) {
                      long long v61 = (char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16;
                    }
                    unint64_t v107 = v61;
                    RawStringData = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v105);
                    uint64_t v102 = v63;
                    long long v61 = (char *)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::ArrayRef<long long>>((mlir::Builder *)a1, a2, (uint64_t *)&v107, (uint64_t)&RawStringData)- 16;
                  }
                  unint64_t v64 = v106;
                  uint64_t v65 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
                  RawStringData = v61;
                  unint64_t v107 = (void *)v65;
                  if (v34 != v35) {
                    long long v61 = (char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16;
                  }
                  mlir::IRMapping::map((uint64_t *)a6, v64, (uint64_t)v61);
                }
              }
            }
          }
        }
        uint64_t v94 = v106;
        unint64_t v107 = (void *)v106;
        RawStringData = 0;
        v95 = (void *)v106;
        if (llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)a6, (unint64_t *)&v107, &RawStringData))
        {
          v95 = (void *)v94;
          if (RawStringData != (void *)(*(void *)a6 + 16 * *(unsigned int *)(a6 + 16))) {
            v95 = (void *)RawStringData[1];
          }
        }
        uint64_t v96 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
        RawStringData = v95;
        unint64_t v107 = (void *)v96;
        if (v34 != v35) {
          v95 = (void *)((char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16);
        }
        unint64_t v107 = (void *)v94;
        RawStringData = 0;
        char v97 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)a6, (unint64_t *)&v107, &RawStringData);
        uint64_t v98 = RawStringData;
        if ((v97 & 1) == 0)
        {
          uint64_t v98 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>(a6, (uint64_t)&v107, (unint64_t *)&v107, RawStringData);
          *uint64_t v98 = v107;
          v98[1] = 0;
        }
        v98[1] = v95;
      }
    }
    else
    {
      if (v36 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
        return 1;
      }
      if (*(_UNKNOWN **)(*(void *)(*(void *)(v106 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
      {
        if (*(_UNKNOWN **)(*v104[0] + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
          return 1;
        }
        uint64_t v37 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v104);
        uint64_t v39 = v38;
        uint64_t v40 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
        uint64_t v41 = mlir::RankedTensorType::get(v37, v39, v40, 0);
        char v42 = (void *)v106;
        if (v41 == v24)
        {
          int v45 = (char *)v106;
        }
        else
        {
          uint64_t v43 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
          RawStringData = v42;
          unint64_t v107 = (void *)v43;
          if (v34 != v35) {
            char v42 = (void *)((char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16);
          }
          unint64_t v107 = v42;
          RawStringData = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v105);
          uint64_t v102 = v44;
          int v45 = (char *)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::ArrayRef<long long>>((mlir::Builder *)a1, a2, (uint64_t *)&v107, (uint64_t)&RawStringData)- 16;
          char v42 = (void *)v106;
        }
        unint64_t v107 = v42;
        goto LABEL_65;
      }
      uint64_t v75 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v104);
      uint64_t v77 = v76;
      uint64_t v78 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
      uint64_t v79 = mlir::RankedTensorType::get(v75, v77, v78, 0);
      uint64_t v80 = (char *)mlir::OpBuilder::create<mlir::placement::MemrefToTensor,mlir::Value &>(a1, a2, &v106) - 16;
      if (v79 != v24)
      {
        uint64_t v81 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
        RawStringData = v80;
        unint64_t v107 = (void *)v81;
        if (v34 != v35) {
          uint64_t v80 = (char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16;
        }
        unint64_t v107 = v80;
        RawStringData = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v105);
        uint64_t v102 = v82;
        uint64_t v80 = (char *)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::ArrayRef<long long>>((mlir::Builder *)a1, a2, (uint64_t *)&v107, (uint64_t)&RawStringData)- 16;
      }
      uint64_t v83 = v106;
      uint64_t v84 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
      RawStringData = v80;
      unint64_t v107 = (void *)v84;
      if (v34 != v35) {
        uint64_t v80 = (char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16;
      }
      unint64_t v107 = (void *)v83;
      RawStringData = 0;
      char v85 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)a6, (unint64_t *)&v107, &RawStringData);
      unint64_t v86 = RawStringData;
      if ((v85 & 1) == 0)
      {
        unint64_t v86 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>(a6, (uint64_t)&v107, (unint64_t *)&v107, RawStringData);
        *unint64_t v86 = v107;
        v86[1] = 0;
      }
      v86[1] = v80;
    }
  }
  return 1;
}

uint64_t mlir::IRMapping::map(uint64_t *a1, unint64_t a2, uint64_t a3)
{
  unint64_t v7 = a2;
  uint64_t v8 = 0;
  uint64_t result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>(a1, &v7, &v8);
  uint64_t v6 = v8;
  if ((result & 1) == 0)
  {
    uint64_t result = (uint64_t)llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)a1, (uint64_t)&v7, &v7, v8);
    uint64_t v6 = (void *)result;
    *(void *)uint64_t result = v7;
    *(void *)(result + 8) = 0;
  }
  v6[1] = a3;
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::placement::TensorToMemref,mlir::Value &>(mlir::UnknownLoc **a1, uint64_t a2, void *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"placement.tensor_to_memref", (const unsigned __int8 *)0x1A, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"placement.tensor_to_memref";
    v15[3] = 26;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::placement::TensorToMemref::build(a1, (uint64_t)v17, a3, 1, 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::placement::TensorToMemref,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::placement::TensorToMemref,mlir::MemRefType &,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v20[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"placement.tensor_to_memref", (const unsigned __int8 *)0x1A, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"placement.tensor_to_memref";
    v17[3] = 26;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, a3, 1uLL);
  mlir::anec::GOC::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], a4, 1, 0, 0);
  unint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::placement::TensorToMemref,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

uint64_t mlir::getMPSVersionFromANEC@<X0>(uint64_t a1@<X8>)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 24) = 0;
  uint64_t result = ANECGetMPSDialectSupportedVersion();
  if (!result)
  {
    *(void *)a1 = &unk_1EC9CA678;
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)(a1 + 16) = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return result;
}

void mlir::populateMPSToANECConversionPatterns(uint64_t a1, char a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  int v7 = a1;
  v609[0] = *MEMORY[0x1E4F143B8];
  _ZN4mlir12_GLOBAL__N_120addPatternsForTargetIJNS0_14ConvertBiasAddENS0_15ConvertConstantENS0_17ConvertCropResizeENS0_22ConvertDepthwiseConv3DENS0_31ConvertElementwiseBinaryA14PlusINS_3mps5AddOpENS_4anec14ElementwiseAddELNS9_6FamilyE2EEENS6_INS7_10MultiplyOpENS9_15ElementwiseMultELSB_2EEENS6_INS7_10SubtractOpENS9_14ElementwiseSubELSB_2EEENS6_INS7_9MaximumOpENS9_14ElementwiseMaxELSB_2EEENS6_INS7_9MinimumOpENS9_14ElementwiseMinELSB_2EEENS6_INS7_7PowerOpENS9_16ElementwisePowerELSB_2EEENS0_32ConvertElementwiseBinaryA14MinusIS8_SA_LSB_1EEENSS_ISD_SE_LSB_1EEENSS_ISG_SH_LSB_1EEENSS_ISJ_SK_LSB_1EEENSS_ISM_SN_LSB_1EEENSS_ISP_SQ_LSB_1EEENSS_IS8_SA_LSB_0EEENSS_ISD_SE_LSB_0EEENSS_ISG_SH_LSB_0EEENSS_ISJ_SK_LSB_0EEENSS_ISM_SN_LSB_0EEENSS_ISP_SQ_LSB_0EEENS0_23ConvertElementwiseUnaryINS7_10AbsoluteOpENS9_14ElementwiseAbsEEENS0_15ConvertExponentENS0_16ConvertLogarithmENS0_13ConvertSelectENS0_16ConvertFlatten2DENS0_13ConvertDivideILSB_0EEENS1D_ILSB_1EEENS1D_ILSB_2EEENS1D_ILSB_3EEENS1D_ILSB_4EEENS1D_ILSB_5EEENS1D_ILSB_6EEENS0_18ConvertFloorDivideILSB_0EEENS1L_ILSB_1EEENS1L_ILSB_2EEENS1L_ILSB_3EEENS1L_ILSB_4EEENS1L_ILSB_5EEENS1L_ILSB_6EEENS0_13ConvertMatMulILSB_0EEENS1T_ILSB_1EEENS1T_ILSB_2EEENS1T_ILSB_3EEENS1T_ILSB_4EEENS1T_ILSB_5EEENS1T_ILSB_6EEENS15_INS7_9DegammaOpENS9_7DegammaEEENS15_INS7_7DiracOpENS9_5DiracEEENS15_INS7_6GeluOpENS9_4GeluEEENS15_INS7_6ReluOpENS9_4ReluEEENS15_INS7_7RoundOpENS9_12RoundNearestEEENS15_INS7_9SigmoidOpENS9_20HighPrecisionSigmoidEEENS15_INS7_8SquareOpENS9_17ElementwiseSquareEEENS15_INS7_12SquareRootOpENS9_4SqrtEEENS15_INS7_7SwishOpENS9_5SwishEEENS15_INS7_6TanhOpENS9_4TanhEEENS0_20ConvertBinaryCompareINS7_9EqualToOpENS9_16ElementwiseEqualEEENS0_26ConvertBinaryCompareToZeroIS2W_NS9_20ElementwiseEqualZeroEEENS2V_INS7_12NotEqualToOpENS9_19ElementwiseNotEqualEEENS2Z_IS32_NS9_23ElementwiseNotEqualZeroEEENS2V_INS7_13GreaterThanOpENS9_22ElementwiseGreaterThanEEENS2Z_IS37_NS9_26ElementwiseGreaterThanZeroEEENS2V_INS7_22GreaterThanOrEqualToOpENS9_27ElementwiseGreaterThanEqualEEENS2Z_IS3C_NS9_31ElementwiseGreaterThanEqualZeroEEENS2V_INS7_10LessThanOpENS9_19ElementwiseLessThanEEENS2Z_IS3H_NS9_23ElementwiseLessThanZeroEEENS2V_INS7_19LessThanOrEqualToOpENS9_24ElementwiseLessThanEqualEEENS2Z_IS3M_NS9_28ElementwiseLessThanEqualZeroEEENS15_INS7_5NotOpES30_EENS0_11ConvertPoolINS7_9PoolAvgOpENS9_11AveragePoolEEENS3T_INS7_12PoolL2NormOpENS9_10L2NormPoolEEENS3T_INS7_9PoolMaxOpENS9_7MaxPoolEEENS0_14ConvertStencilENS15_INS7_6CeilOpENS9_4CeilEEENS15_INS7_5ErfOpENS9_3ErfEEENS15_INS7_15ExponentBase2OpENS9_4Exp2EEENS15_INS7_7FloorOpENS9_5FloorEEENS15_INS7_6SignOpENS9_4SignEEENS15_INS7_10TruncateOpENS9_5TruncEEENS0_23ConvertReductionA14PlusINS7_14ReductionMaxOpENS9_9ReduceMaxELSB_2EEENS4M_INS7_15ReductionMeanOpENS9_9ReduceAvgELSB_2EEENS4M_INS7_14ReductionMinOpENS9_9ReduceMinELSB_2EEENS4M_INS7_14ReductionSumOpENS9_9ReduceSumELSB_2EEENS0_24ConvertReductionA14MinusIS4N_S4O_LSB_1EEENS4Z_IS4Q_S4R_LSB_1EEENS4Z_IS4T_S4U_LSB_1EEENS4Z_IS4W_S4X_LSB_1EEENS4Z_IS4N_S4O_LSB_0EEENS4Z_IS4Q_S4R_LSB_0EEENS4Z_IS4T_S4U_LSB_0EEENS4Z_IS4W_S4X_LSB_0EEENS0_14ConvertReshapeILSB_0EEENS58_ILSB_1EEENS58_ILSB_2EEENS58_ILSB_3EEENS58_ILSB_4EEENS58_ILSB_5EEENS58_ILSB_6EEENS0_17ConvertExpandDimsILSB_0EEENS5G_ILSB_1EEENS5G_ILSB_2EEENS5G_ILSB_3EEENS5G_ILSB_4EEENS5G_ILSB_5EEENS5G_ILSB_6EEENS0_14ConvertSqueezeILSB_0EEENS5O_ILSB_1EEENS5O_ILSB_2EEENS5O_ILSB_3EEENS5O_ILSB_4EEENS5O_ILSB_5EEENS5O_ILSB_6EEENS0_11ConvertCastENS0_14ConvertSoftmaxENS0_13ConvertConcatENS0_12ConvertSplitENS0_13ConvertResizeILSB_0EEENS60_ILSB_1EEENS60_ILSB_2EEENS60_ILSB_3EEENS60_ILSB_4EEENS60_ILSB_5EEENS60_ILSB_6EEENS0_19ConvertInstanceNormENS0_14ConvertPermuteENS0_15ConvertGatherNDENS0_13ConvertGatherENS0_21ConvertDepthToSpace2DINS9_12PixelShuffleEEENS6C_INS9_14ChannelToSpaceEEENS0_21ConvertSpaceToDepth2DINS9_14PixelUnshuffleEEENS6H_INS9_14SpaceToChannelEEENS0_19ConvertBatchToSpaceINS7_14BatchToSpaceOpENS9_12BatchToSpaceEEENS6M_INS7_14SpaceToBatchOpENS9_12SpaceToBatchEEENS0_16ConvertTransposeILSB_0EEENS6T_ILSB_1EEENS6T_ILSB_2EEENS6T_ILSB_3EEENS6T_ILSB_4EEENS6T_ILSB_5EEENS6T_ILSB_6EEENS0_16ConvertBroadcastILSB_0EEENS71_ILSB_1EEENS71_ILSB_2EEENS71_ILSB_3EEENS71_ILSB_4EEENS71_ILSB_5EEENS71_ILSB_6EEENS0_14ConvertPaddingILSB_0EEENS79_ILSB_1EEENS79_ILSB_2EEENS79_ILSB_3EEENS79_ILSB_4EEENS79_ILSB_5EEENS79_ILSB_6EEENS0_12ConvertSliceILSB_0EEENS7H_ILSB_1EEENS7H_ILSB_2EEENS7H_ILSB_3EEENS7H_ILSB_4EEENS7H_ILSB_5EEENS7H_ILSB_6EEENS0_19ConvertStridedSliceILSB_0EEENS7P_ILSB_1EEENS7P_ILSB_2EEENS7P_ILSB_3EEENS7P_ILSB_4EEENS7P_ILSB_5EEENS7P_ILSB_6EEENS0_11ConvertCropILSB_0EEENS7X_ILSB_1EEENS7X_ILSB_2EEENS7X_ILSB_3EEENS7X_ILSB_4EEENS7X_ILSB_5EEENS7X_ILSB_6EEENS15_INS7_5CosOpENS9_3CosEEENS15_INS7_5SinOpENS9_3SinEEENS0_13FoldOperationINS7_10IdentityOpEEENS0_20ConvertNormalizationENS0_24ConvertReductionVarianceENS0_19ConvertReductionArgINS7_17ReductionArgMinOpELSB_0EEENS8G_IS8H_LSB_1EEENS8G_IS8H_LSB_2EEENS8G_IS8H_LSB_3EEENS8G_IS8H_LSB_4EEENS8G_IS8H_LSB_5EEENS8G_IS8H_LSB_6EEENS8G_INS7_17ReductionArgMaxOpELSB_0EEENS8G_IS8P_LSB_1EEENS8G_IS8P_LSB_2EEENS8G_IS8P_LSB_3EEENS8G_IS8P_LSB_4EEENS8G_IS8P_LSB_5EEENS8G_IS8P_LSB_6EEENS0_14ConvertSignBitENS0_11ConvertTileEEEEvSB_RNS_17RewritePatternSetERNS_13TypeConverterE(a1, a3, a4);
  mlir::populateFunctionOpInterfaceTypeConversionPattern((uint64_t)"anec.A12", 8, a3, v4);
  mlir::populateFunctionOpInterfaceTypeConversionPattern((uint64_t)"anec.A13", 8, a3, v4);
  mlir::populateFunctionOpInterfaceTypeConversionPattern((uint64_t)"anec.A14", 8, a3, v4);
  mlir::populateFunctionOpInterfaceTypeConversionPattern((uint64_t)"anec.A15", 8, a3, v4);
  mlir::populateFunctionOpInterfaceTypeConversionPattern((uint64_t)"anec.A16", 8, a3, v4);
  mlir::populateFunctionOpInterfaceTypeConversionPattern((uint64_t)"anec.A17", 8, a3, v4);
  mlir::populateFunctionOpInterfaceTypeConversionPattern((uint64_t)"anec.A11Legacy", 14, a3, v4);
  uint64_t v8 = *a3;
  uint64_t v9 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v595, 1);
  mlir::Pattern::Pattern((uint64_t)(v9 + 1), (uint64_t)"anec.region_return", 18, (__int16)v595, v8, 0, 0);
  v9[12] = v4;
  *uint64_t v9 = &unk_1EC9A9B40;
  if (!v9[9])
  {
    v595 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::RegionReturnTypeConversion]";
    v596[0] = (void *)105;
    char v10 = (char *)llvm::StringRef::find((uint64_t *)&v595, "DesiredTypeName = ", 0x12uLL, 0);
    if (v596[0] >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = (char *)v596[0];
    }
    uint64_t v12 = &v11[(void)v595];
    uint64_t v13 = (char *)((char *)v596[0] - (char *)v11);
    if ((void *)((char *)v596[0] - (char *)v11) >= (void *)0x12) {
      uint64_t v14 = 18;
    }
    else {
      uint64_t v14 = (char *)v596[0] - (char *)v11;
    }
    unint64_t v15 = &v12[v14];
    unint64_t v16 = (unint64_t)&v13[-v14];
    if (v16 >= v16 - 1) {
      --v16;
    }
    v9[8] = v15;
    v9[9] = v16;
  }
  unint64_t v17 = *((unsigned int *)v9 + 22);
  if (v17 > *((_DWORD *)v9 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v9 + 10), v9 + 12, v17, 16);
    LODWORD(v17) = *((_DWORD *)v9 + 22);
  }
  *((_DWORD *)v9 + 22) = v17;
  uint64_t v19 = (char *)a3[2];
  unint64_t v18 = a3[3];
  uint64_t v591 = v4;
  int v590 = v7;
  if ((unint64_t)v19 < v18)
  {
    *(void *)uint64_t v19 = v9;
    uint64_t v20 = v19 + 8;
    goto LABEL_41;
  }
  uint64_t v21 = (char *)a3[1];
  uint64_t v22 = (v19 - v21) >> 3;
  unint64_t v23 = v22 + 1;
  if ((unint64_t)(v22 + 1) >> 61) {
    goto LABEL_763;
  }
  uint64_t v24 = v18 - (void)v21;
  if (v24 >> 2 > v23) {
    unint64_t v23 = v24 >> 2;
  }
  if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v25 = v23;
  }
  if (v25)
  {
    if (v25 >> 61) {
      goto LABEL_764;
    }
    long long v26 = (char *)operator new(8 * v25);
  }
  else
  {
    long long v26 = 0;
  }
  __int16 v27 = &v26[8 * v22];
  uint64_t v28 = &v26[8 * v25];
  *(void *)__int16 v27 = v9;
  uint64_t v20 = v27 + 8;
  if (v19 == v21)
  {
    a3[1] = (uint64_t)v27;
    a3[2] = (uint64_t)v20;
    a3[3] = (uint64_t)v28;
    uint64_t v4 = v591;
    int v7 = v590;
    goto LABEL_39;
  }
  unint64_t v29 = v19 - v21 - 8;
  uint64_t v4 = v591;
  if (v29 < 0x78
    || &v19[-(v29 & 0xFFFFFFFFFFFFFFF8) - 8] < v27 && &v26[v19 - v21 - (v29 & 0xFFFFFFFFFFFFFFF8) - 8] < v19)
  {
    goto LABEL_767;
  }
  uint64_t v30 = (v29 >> 3) + 1;
  uint64_t v31 = 8 * (v30 & 0x3FFFFFFFFFFFFFFCLL);
  uint64_t v32 = &v19[-v31];
  v27 -= v31;
  uint64_t v33 = &v26[8 * v22 - 16];
  uint64_t v34 = v19 - 16;
  uint64_t v35 = v30 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v37 = *((_OWORD *)v34 - 1);
    long long v36 = *(_OWORD *)v34;
    *((_OWORD *)v34 - 1) = 0uLL;
    *(_OWORD *)uint64_t v34 = 0uLL;
    *((_OWORD *)v33 - 1) = v37;
    *(_OWORD *)uint64_t v33 = v36;
    v33 -= 32;
    v34 -= 32;
    v35 -= 4;
  }
  while (v35);
  uint64_t v19 = v32;
  if (v30 != (v30 & 0x3FFFFFFFFFFFFFFCLL))
  {
LABEL_767:
    do
    {
      uint64_t v38 = *((void *)v19 - 1);
      v19 -= 8;
      *(void *)uint64_t v19 = 0;
      *((void *)v27 - 1) = v38;
      v27 -= 8;
    }
    while (v19 != v21);
  }
  uint64_t v19 = (char *)a3[1];
  uint64_t v39 = (char *)a3[2];
  a3[1] = (uint64_t)v27;
  a3[2] = (uint64_t)v20;
  a3[3] = (uint64_t)v28;
  if (v39 != v19)
  {
    int v7 = v590;
    do
    {
      uint64_t v41 = *((void *)v39 - 1);
      v39 -= 8;
      uint64_t v40 = v41;
      *(void *)uint64_t v39 = 0;
      if (v41) {
        (*(void (**)(uint64_t))(*(void *)v40 + 8))(v40);
      }
    }
    while (v39 != v19);
LABEL_39:
    if (!v19) {
      goto LABEL_41;
    }
    goto LABEL_40;
  }
  int v7 = v590;
  if (v19) {
LABEL_40:
  }
    operator delete(v19);
LABEL_41:
  a3[2] = (uint64_t)v20;
  char v608 = 5;
  LODWORD(v606) = 1;
  strcpy((char *)v607, "slope");
  char v42 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)&v595, 0.0);
  uint64_t v43 = llvm::APFloatBase::IEEEdouble(v42);
  llvm::APFloat::Storage::Storage(v605, &v595, v43);
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v595);
  uint64_t v44 = (llvm::APFloatBase *)std::pair<llvm::APFloat,std::string>::pair[abi:nn180100]<llvm::APFloat,char const(&)[7],0>((uint64_t)&v595, (uint64_t)&p_p, "offset");
  v588 = v43;
  if (v7 < 0) {
    goto LABEL_86;
  }
  uint64_t v45 = *a3;
  uint64_t v46 = (char *)operator new(0x170uLL);
  mlir::PatternBenefit::PatternBenefit(&v592, 1);
  mlir::Pattern::Pattern((uint64_t)(v46 + 8), (uint64_t)"mps.leaky_relu", 14, (__int16)v592, v45, 0, 0);
  *((void *)v46 + 12) = v4;
  *(void *)uint64_t v46 = &unk_1EC9A8790;
  v592 = (const char *)&v606;
  v594 = v609;
  llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::DenseMap<std::pair<unsigned int,std::string> const*>((uint64_t)(v46 + 104), (uint64_t *)&v592, (uint64_t *)&v594);
  *((void *)v46 + 16) = v46 + 144;
  *((void *)v46 + 17) = 0x400000000;
  llvm::SmallVectorImpl<std::pair<llvm::APFloat,std::string>>::append<std::pair<llvm::APFloat,std::string> const*,void>((unsigned int *)v46 + 32, (uint64_t)&v595, (uint64_t)v600);
  if (!*((void *)v46 + 9))
  {
    v592 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertElementwiseUnary<mlir::m"
           "ps::LeakyReluOp, mlir::anec::LeakyRelu>]";
    unint64_t v593 = 149;
    uint64_t v44 = (llvm::APFloatBase *)llvm::StringRef::find((uint64_t *)&v592, "DesiredTypeName = ", 0x12uLL, 0);
    if (v593 >= (unint64_t)v44) {
      unint64_t v47 = (unint64_t)v44;
    }
    else {
      unint64_t v47 = v593;
    }
    uint64_t v48 = &v592[v47];
    unint64_t v49 = v593 - v47;
    if (v593 - v47 >= 0x12) {
      uint64_t v50 = 18;
    }
    else {
      uint64_t v50 = v593 - v47;
    }
    uint64_t v51 = &v48[v50];
    unint64_t v52 = v49 - v50;
    if (v52 >= v52 - 1) {
      --v52;
    }
    *((void *)v46 + 8) = v51;
    *((void *)v46 + 9) = v52;
  }
  unint64_t v53 = *((unsigned int *)v46 + 22);
  if (v53 > *((_DWORD *)v46 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v46 + 80), v46 + 96, v53, 16);
    LODWORD(v53) = *((_DWORD *)v46 + 22);
  }
  *((_DWORD *)v46 + 22) = v53;
  uint64_t v55 = (char *)a3[2];
  unint64_t v54 = a3[3];
  if ((unint64_t)v55 >= v54)
  {
    uint64_t v57 = (char *)a3[1];
    uint64_t v58 = (v55 - v57) >> 3;
    unint64_t v59 = v58 + 1;
    if ((unint64_t)(v58 + 1) >> 61) {
      goto LABEL_763;
    }
    uint64_t v60 = v54 - (void)v57;
    if (v60 >> 2 > v59) {
      unint64_t v59 = v60 >> 2;
    }
    if ((unint64_t)v60 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v61 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v61 = v59;
    }
    if (v61)
    {
      if (v61 >> 61) {
        goto LABEL_764;
      }
      uint64_t v44 = (llvm::APFloatBase *)operator new(8 * v61);
    }
    else
    {
      uint64_t v44 = 0;
    }
    uint64_t v62 = (void *)((char *)v44 + 8 * v58);
    uint64_t v63 = (char *)v44 + 8 * v61;
    void *v62 = v46;
    uint64_t v56 = v62 + 1;
    if (v55 == v57)
    {
      a3[1] = (uint64_t)v62;
      a3[2] = (uint64_t)v56;
      a3[3] = (uint64_t)v63;
      uint64_t v4 = v591;
    }
    else
    {
      unint64_t v64 = v55 - v57 - 8;
      uint64_t v4 = v591;
      if (v64 < 0x78
        || &v55[-(v64 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v62
        && (char *)v44 + v55 - v57 - (v64 & 0xFFFFFFFFFFFFFFF8) - 8 < v55)
      {
        goto LABEL_768;
      }
      uint64_t v65 = (v64 >> 3) + 1;
      uint64_t v66 = 8 * (v65 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v67 = &v55[-v66];
      uint64_t v62 = (void *)((char *)v62 - v66);
      unint64_t v68 = (_OWORD *)((char *)v44 + 8 * v58 - 16);
      uint64_t v69 = v55 - 16;
      uint64_t v70 = v65 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v72 = *((_OWORD *)v69 - 1);
        long long v71 = *(_OWORD *)v69;
        *((_OWORD *)v69 - 1) = 0uLL;
        *(_OWORD *)uint64_t v69 = 0uLL;
        *(v68 - 1) = v72;
        *unint64_t v68 = v71;
        v68 -= 2;
        v69 -= 32;
        v70 -= 4;
      }
      while (v70);
      uint64_t v55 = v67;
      if (v65 != (v65 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_768:
        do
        {
          uint64_t v73 = *((void *)v55 - 1);
          v55 -= 8;
          *(void *)uint64_t v55 = 0;
          *--uint64_t v62 = v73;
        }
        while (v55 != v57);
      }
      uint64_t v55 = (char *)a3[1];
      uint64_t v74 = (char *)a3[2];
      a3[1] = (uint64_t)v62;
      a3[2] = (uint64_t)v56;
      a3[3] = (uint64_t)v63;
      if (v74 != v55)
      {
        int v7 = v590;
        do
        {
          uint64_t v75 = (llvm::APFloatBase *)*((void *)v74 - 1);
          v74 -= 8;
          uint64_t v44 = v75;
          *(void *)uint64_t v74 = 0;
          if (v75) {
            uint64_t v44 = (llvm::APFloatBase *)(*(uint64_t (**)(llvm::APFloatBase *))(*(void *)v44 + 8))(v44);
          }
        }
        while (v74 != v55);
        goto LABEL_83;
      }
    }
    int v7 = v590;
LABEL_83:
    if (v55) {
      operator delete(v55);
    }
    goto LABEL_85;
  }
  *(void *)uint64_t v55 = v46;
  uint64_t v56 = v55 + 8;
LABEL_85:
  a3[2] = (uint64_t)v56;
LABEL_86:
  if (SHIBYTE(v599[1]) < 0) {
    operator delete(__p);
  }
  uint64_t v76 = v596[0];
  uint64_t v77 = llvm::APFloatBase::PPCDoubleDouble(v44);
  if (v77 == v76) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v596);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v596);
  }
  if (v77 != (void *)v605[0])
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v605);
    if ((v608 & 0x80000000) == 0) {
      goto LABEL_94;
    }
    goto LABEL_93;
  }
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v605);
  if (v608 < 0) {
LABEL_93:
  }
    operator delete(v607[0]);
LABEL_94:
  LODWORD(v595) = 1;
  char v597 = 9;
  strcpy((char *)v596, "min_value");
  LODWORD(__p) = 2;
  char v601 = 9;
  strcpy((char *)v599, "max_value");
  char v589 = a2;
  if (v7 < 0) {
    goto LABEL_141;
  }
  uint64_t v78 = *a3;
  uint64_t v79 = operator new(0x170uLL);
  mlir::PatternBenefit::PatternBenefit(&v606, 1);
  mlir::Pattern::Pattern((uint64_t)(v79 + 1), (uint64_t)"mps.clamp", 9, (__int16)v606, v78, 0, 0);
  v79[12] = v4;
  *uint64_t v79 = &unk_1EC9A8E20;
  v606 = (const char *)&v595;
  p_p = (const char *)v602;
  llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::DenseMap<std::pair<unsigned int,std::string> const*>((uint64_t)(v79 + 13), (uint64_t *)&v606, (uint64_t *)&p_p);
  v79[16] = v79 + 18;
  v79[17] = 0x400000000;
  if (!v79[9])
  {
    v606 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertElementwiseUnary<mlir::m"
           "ps::ClampOp, mlir::anec::ClampedRelu>]";
    v607[0] = (void *)147;
    uint64_t v80 = (char *)llvm::StringRef::find((uint64_t *)&v606, "DesiredTypeName = ", 0x12uLL, 0);
    if (v607[0] >= v80) {
      uint64_t v81 = v80;
    }
    else {
      uint64_t v81 = (char *)v607[0];
    }
    uint64_t v82 = &v81[(void)v606];
    uint64_t v83 = (char *)((char *)v607[0] - (char *)v81);
    if ((void *)((char *)v607[0] - (char *)v81) >= (void *)0x12) {
      uint64_t v84 = 18;
    }
    else {
      uint64_t v84 = (char *)v607[0] - (char *)v81;
    }
    char v85 = &v82[v84];
    unint64_t v86 = (unint64_t)&v83[-v84];
    if (v86 >= v86 - 1) {
      --v86;
    }
    v79[8] = v85;
    v79[9] = v86;
  }
  unint64_t v87 = *((unsigned int *)v79 + 22);
  if (v87 > *((_DWORD *)v79 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v79 + 10), v79 + 12, v87, 16);
    LODWORD(v87) = *((_DWORD *)v79 + 22);
  }
  *((_DWORD *)v79 + 22) = v87;
  unint64_t v89 = (char *)a3[2];
  unint64_t v88 = a3[3];
  if ((unint64_t)v89 < v88)
  {
    *(void *)unint64_t v89 = v79;
    long long v90 = v89 + 8;
    goto LABEL_140;
  }
  long long v91 = (char *)a3[1];
  uint64_t v92 = (v89 - v91) >> 3;
  unint64_t v93 = v92 + 1;
  if ((unint64_t)(v92 + 1) >> 61) {
    goto LABEL_763;
  }
  uint64_t v94 = v88 - (void)v91;
  if (v94 >> 2 > v93) {
    unint64_t v93 = v94 >> 2;
  }
  if ((unint64_t)v94 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v95 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v95 = v93;
  }
  if (v95)
  {
    if (v95 >> 61) {
      goto LABEL_764;
    }
    uint64_t v96 = (char *)operator new(8 * v95);
  }
  else
  {
    uint64_t v96 = 0;
  }
  char v97 = &v96[8 * v92];
  uint64_t v98 = &v96[8 * v95];
  *(void *)char v97 = v79;
  long long v90 = v97 + 8;
  if (v89 == v91)
  {
    a3[1] = (uint64_t)v97;
    a3[2] = (uint64_t)v90;
    a3[3] = (uint64_t)v98;
    a2 = v589;
    goto LABEL_138;
  }
  unint64_t v99 = v89 - v91 - 8;
  if (v99 < 0x78
    || &v89[-(v99 & 0xFFFFFFFFFFFFFFF8) - 8] < v97 && &v96[v89 - v91 - (v99 & 0xFFFFFFFFFFFFFFF8) - 8] < v89)
  {
    goto LABEL_769;
  }
  uint64_t v100 = (v99 >> 3) + 1;
  uint64_t v101 = 8 * (v100 & 0x3FFFFFFFFFFFFFFCLL);
  uint64_t v102 = &v89[-v101];
  v97 -= v101;
  uint64_t v103 = &v96[8 * v92 - 16];
  uint64_t v104 = v89 - 16;
  uint64_t v105 = v100 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v107 = *((_OWORD *)v104 - 1);
    long long v106 = *(_OWORD *)v104;
    *((_OWORD *)v104 - 1) = 0uLL;
    *(_OWORD *)uint64_t v104 = 0uLL;
    *((_OWORD *)v103 - 1) = v107;
    *(_OWORD *)uint64_t v103 = v106;
    v103 -= 32;
    v104 -= 32;
    v105 -= 4;
  }
  while (v105);
  unint64_t v89 = v102;
  if (v100 != (v100 & 0x3FFFFFFFFFFFFFFCLL))
  {
LABEL_769:
    do
    {
      uint64_t v108 = *((void *)v89 - 1);
      v89 -= 8;
      *(void *)unint64_t v89 = 0;
      *((void *)v97 - 1) = v108;
      v97 -= 8;
    }
    while (v89 != v91);
  }
  unint64_t v89 = (char *)a3[1];
  unint64_t v109 = (char *)a3[2];
  a3[1] = (uint64_t)v97;
  a3[2] = (uint64_t)v90;
  a3[3] = (uint64_t)v98;
  if (v109 == v89)
  {
    a2 = v589;
    uint64_t v4 = v591;
LABEL_138:
    int v7 = v590;
    if (!v89) {
      goto LABEL_140;
    }
    goto LABEL_139;
  }
  a2 = v589;
  int v7 = v590;
  do
  {
    uint64_t v111 = *((void *)v109 - 1);
    v109 -= 8;
    uint64_t v110 = v111;
    *(void *)unint64_t v109 = 0;
    if (v111) {
      (*(void (**)(uint64_t))(*(void *)v110 + 8))(v110);
    }
  }
  while (v109 != v89);
  uint64_t v4 = v591;
  if (v89) {
LABEL_139:
  }
    operator delete(v89);
LABEL_140:
  a3[2] = (uint64_t)v90;
  if ((v601 & 0x80000000) == 0)
  {
LABEL_141:
    if ((v597 & 0x80000000) == 0) {
      goto LABEL_143;
    }
    goto LABEL_142;
  }
  operator delete(v599[0]);
  if (v597 < 0) {
LABEL_142:
  }
    operator delete(v596[0]);
LABEL_143:
  LODWORD(v595) = 1;
  char v597 = 9;
  strcpy((char *)v596, "max_value");
  char v601 = 5;
  LODWORD(__p) = 2;
  strcpy((char *)v599, "slope");
  if (v7 < 0) {
    goto LABEL_190;
  }
  uint64_t v112 = *a3;
  unint64_t v113 = operator new(0x170uLL);
  mlir::PatternBenefit::PatternBenefit(&v606, 1);
  mlir::Pattern::Pattern((uint64_t)(v113 + 1), (uint64_t)"mps.n_relu", 10, (__int16)v606, v112, 0, 0);
  v113[12] = v4;
  *unint64_t v113 = &unk_1EC9A8F70;
  v606 = (const char *)&v595;
  p_p = (const char *)v602;
  llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::DenseMap<std::pair<unsigned int,std::string> const*>((uint64_t)(v113 + 13), (uint64_t *)&v606, (uint64_t *)&p_p);
  v113[16] = v113 + 18;
  v113[17] = 0x400000000;
  if (!v113[9])
  {
    v606 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertElementwiseUnary<mlir::m"
           "ps::NReluOp, mlir::anec::NRelu>]";
    v607[0] = (void *)141;
    unint64_t v114 = (char *)llvm::StringRef::find((uint64_t *)&v606, "DesiredTypeName = ", 0x12uLL, 0);
    if (v607[0] >= v114) {
      uint64_t v115 = v114;
    }
    else {
      uint64_t v115 = (char *)v607[0];
    }
    uint64_t v116 = &v115[(void)v606];
    unint64_t v117 = (char *)((char *)v607[0] - (char *)v115);
    if ((void *)((char *)v607[0] - (char *)v115) >= (void *)0x12) {
      uint64_t v118 = 18;
    }
    else {
      uint64_t v118 = (char *)v607[0] - (char *)v115;
    }
    unint64_t v119 = &v116[v118];
    unint64_t v120 = (unint64_t)&v117[-v118];
    if (v120 >= v120 - 1) {
      --v120;
    }
    v113[8] = v119;
    v113[9] = v120;
  }
  unint64_t v121 = *((unsigned int *)v113 + 22);
  if (v121 > *((_DWORD *)v113 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v113 + 10), v113 + 12, v121, 16);
    LODWORD(v121) = *((_DWORD *)v113 + 22);
  }
  *((_DWORD *)v113 + 22) = v121;
  int64_t v123 = (char *)a3[2];
  unint64_t v122 = a3[3];
  if ((unint64_t)v123 < v122)
  {
    *(void *)int64_t v123 = v113;
    int64_t v124 = v123 + 8;
    goto LABEL_189;
  }
  uint64_t v125 = (char *)a3[1];
  uint64_t v126 = (v123 - v125) >> 3;
  unint64_t v127 = v126 + 1;
  if ((unint64_t)(v126 + 1) >> 61) {
    goto LABEL_763;
  }
  uint64_t v128 = v122 - (void)v125;
  if (v128 >> 2 > v127) {
    unint64_t v127 = v128 >> 2;
  }
  if ((unint64_t)v128 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v129 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v129 = v127;
  }
  if (v129)
  {
    if (v129 >> 61) {
      goto LABEL_764;
    }
    int64_t v130 = (char *)operator new(8 * v129);
  }
  else
  {
    int64_t v130 = 0;
  }
  __int16 v131 = &v130[8 * v126];
  uint64_t v132 = &v130[8 * v129];
  *(void *)__int16 v131 = v113;
  int64_t v124 = v131 + 8;
  if (v123 == v125)
  {
    a3[1] = (uint64_t)v131;
    a3[2] = (uint64_t)v124;
    a3[3] = (uint64_t)v132;
    goto LABEL_187;
  }
  unint64_t v133 = v123 - v125 - 8;
  if (v133 < 0x78
    || &v123[-(v133 & 0xFFFFFFFFFFFFFFF8) - 8] < v131 && &v130[v123 - v125 - (v133 & 0xFFFFFFFFFFFFFFF8) - 8] < v123)
  {
    goto LABEL_770;
  }
  uint64_t v134 = (v133 >> 3) + 1;
  uint64_t v135 = 8 * (v134 & 0x3FFFFFFFFFFFFFFCLL);
  v136 = &v123[-v135];
  v131 -= v135;
  v137 = &v130[8 * v126 - 16];
  v138 = v123 - 16;
  uint64_t v139 = v134 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v141 = *((_OWORD *)v138 - 1);
    long long v140 = *(_OWORD *)v138;
    *((_OWORD *)v138 - 1) = 0uLL;
    *(_OWORD *)v138 = 0uLL;
    *((_OWORD *)v137 - 1) = v141;
    *(_OWORD *)v137 = v140;
    v137 -= 32;
    v138 -= 32;
    v139 -= 4;
  }
  while (v139);
  int64_t v123 = v136;
  if (v134 != (v134 & 0x3FFFFFFFFFFFFFFCLL))
  {
LABEL_770:
    do
    {
      uint64_t v142 = *((void *)v123 - 1);
      v123 -= 8;
      *(void *)int64_t v123 = 0;
      *((void *)v131 - 1) = v142;
      v131 -= 8;
    }
    while (v123 != v125);
  }
  int64_t v123 = (char *)a3[1];
  unsigned int v143 = (char *)a3[2];
  a3[1] = (uint64_t)v131;
  a3[2] = (uint64_t)v124;
  a3[3] = (uint64_t)v132;
  if (v143 == v123)
  {
    uint64_t v4 = v591;
LABEL_187:
    int v7 = v590;
    if (!v123) {
      goto LABEL_189;
    }
    goto LABEL_188;
  }
  int v7 = v590;
  do
  {
    uint64_t v145 = *((void *)v143 - 1);
    v143 -= 8;
    uint64_t v144 = v145;
    *(void *)unsigned int v143 = 0;
    if (v145) {
      (*(void (**)(uint64_t))(*(void *)v144 + 8))(v144);
    }
  }
  while (v143 != v123);
  uint64_t v4 = v591;
  if (v123) {
LABEL_188:
  }
    operator delete(v123);
LABEL_189:
  a3[2] = (uint64_t)v124;
  if ((v601 & 0x80000000) == 0)
  {
LABEL_190:
    if ((v597 & 0x80000000) == 0) {
      goto LABEL_192;
    }
    goto LABEL_191;
  }
  operator delete(v599[0]);
  if (v597 < 0) {
LABEL_191:
  }
    operator delete(v596[0]);
LABEL_192:
  uint64_t v146 = *a3;
  char v608 = 5;
  LODWORD(v606) = 1;
  strcpy((char *)v607, "slope");
  llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)&v595, 0.0);
  llvm::APFloat::Storage::Storage(v605, &v595, v43);
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v595);
  std::pair<llvm::APFloat,std::string>::pair[abi:nn180100]<llvm::APFloat,char const(&)[7],0>((uint64_t)&v595, (uint64_t)&p_p, "offset");
  v147 = (char *)operator new(0x170uLL);
  mlir::PatternBenefit::PatternBenefit(&v592, 1);
  mlir::Pattern::Pattern((uint64_t)(v147 + 8), (uint64_t)"mps.prelu", 9, (__int16)v592, v146, 0, 0);
  *((void *)v147 + 12) = v4;
  *(void *)v147 = &unk_1EC9A8FE0;
  v592 = (const char *)&v606;
  v594 = v609;
  llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::DenseMap<std::pair<unsigned int,std::string> const*>((uint64_t)(v147 + 104), (uint64_t *)&v592, (uint64_t *)&v594);
  *((void *)v147 + 16) = v147 + 144;
  *((void *)v147 + 17) = 0x400000000;
  llvm::SmallVectorImpl<std::pair<llvm::APFloat,std::string>>::append<std::pair<llvm::APFloat,std::string> const*,void>((unsigned int *)v147 + 32, (uint64_t)&v595, (uint64_t)v600);
  if (!*((void *)v147 + 9))
  {
    v592 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertElementwiseUnary<mlir::m"
           "ps::PReluOp, mlir::anec::LeakyRelu>]";
    unint64_t v593 = 145;
    unint64_t v148 = llvm::StringRef::find((uint64_t *)&v592, "DesiredTypeName = ", 0x12uLL, 0);
    if (v593 >= v148) {
      unint64_t v149 = v148;
    }
    else {
      unint64_t v149 = v593;
    }
    char v150 = &v592[v149];
    unint64_t v151 = v593 - v149;
    if (v593 - v149 >= 0x12) {
      uint64_t v152 = 18;
    }
    else {
      uint64_t v152 = v593 - v149;
    }
    v153 = &v150[v152];
    unint64_t v154 = v151 - v152;
    if (v154 >= v154 - 1) {
      --v154;
    }
    *((void *)v147 + 8) = v153;
    *((void *)v147 + 9) = v154;
  }
  unint64_t v155 = *((unsigned int *)v147 + 22);
  if (v155 > *((_DWORD *)v147 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v147 + 80), v147 + 96, v155, 16);
    LODWORD(v155) = *((_DWORD *)v147 + 22);
  }
  *((_DWORD *)v147 + 22) = v155;
  __int16 v157 = (char *)a3[2];
  unint64_t v156 = a3[3];
  if ((unint64_t)v157 < v156)
  {
    *(void *)__int16 v157 = v147;
    uint64_t v158 = v157 + 8;
    goto LABEL_237;
  }
  v159 = (char *)a3[1];
  uint64_t v160 = (v157 - v159) >> 3;
  unint64_t v161 = v160 + 1;
  if ((unint64_t)(v160 + 1) >> 61) {
    goto LABEL_763;
  }
  uint64_t v162 = v156 - (void)v159;
  if (v162 >> 2 > v161) {
    unint64_t v161 = v162 >> 2;
  }
  if ((unint64_t)v162 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v163 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v163 = v161;
  }
  if (v163)
  {
    if (v163 >> 61) {
      goto LABEL_764;
    }
    v164 = (char *)operator new(8 * v163);
  }
  else
  {
    v164 = 0;
  }
  v165 = &v164[8 * v160];
  v166 = &v164[8 * v163];
  *(void *)v165 = v147;
  uint64_t v158 = v165 + 8;
  if (v157 == v159)
  {
    a3[1] = (uint64_t)v165;
    a3[2] = (uint64_t)v158;
    a3[3] = (uint64_t)v166;
    a2 = v589;
    goto LABEL_235;
  }
  unint64_t v167 = v157 - v159 - 8;
  if (v167 < 0x78
    || &v157[-(v167 & 0xFFFFFFFFFFFFFFF8) - 8] < v165 && &v164[v157 - v159 - (v167 & 0xFFFFFFFFFFFFFFF8) - 8] < v157)
  {
    goto LABEL_771;
  }
  uint64_t v168 = (v167 >> 3) + 1;
  uint64_t v169 = 8 * (v168 & 0x3FFFFFFFFFFFFFFCLL);
  v170 = &v157[-v169];
  v165 -= v169;
  v171 = &v164[8 * v160 - 16];
  v172 = v157 - 16;
  uint64_t v173 = v168 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v175 = *((_OWORD *)v172 - 1);
    long long v174 = *(_OWORD *)v172;
    *((_OWORD *)v172 - 1) = 0uLL;
    *(_OWORD *)v172 = 0uLL;
    *((_OWORD *)v171 - 1) = v175;
    *(_OWORD *)v171 = v174;
    v171 -= 32;
    v172 -= 32;
    v173 -= 4;
  }
  while (v173);
  __int16 v157 = v170;
  if (v168 != (v168 & 0x3FFFFFFFFFFFFFFCLL))
  {
LABEL_771:
    do
    {
      uint64_t v176 = *((void *)v157 - 1);
      v157 -= 8;
      *(void *)__int16 v157 = 0;
      *((void *)v165 - 1) = v176;
      v165 -= 8;
    }
    while (v157 != v159);
  }
  __int16 v157 = (char *)a3[1];
  v177 = (char *)a3[2];
  a3[1] = (uint64_t)v165;
  a3[2] = (uint64_t)v158;
  a3[3] = (uint64_t)v166;
  if (v177 == v157)
  {
    a2 = v589;
    uint64_t v4 = v591;
LABEL_235:
    int v7 = v590;
    if (!v157) {
      goto LABEL_237;
    }
    goto LABEL_236;
  }
  a2 = v589;
  int v7 = v590;
  do
  {
    uint64_t v179 = *((void *)v177 - 1);
    v177 -= 8;
    uint64_t v178 = v179;
    *(void *)v177 = 0;
    if (v179) {
      (*(void (**)(uint64_t))(*(void *)v178 + 8))(v178);
    }
  }
  while (v177 != v157);
  uint64_t v4 = v591;
  if (v157) {
LABEL_236:
  }
    operator delete(v157);
LABEL_237:
  a3[2] = (uint64_t)v158;
  if (SHIBYTE(v599[1]) < 0) {
    operator delete(__p);
  }
  if (v77 == v596[0]) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v596);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v596);
  }
  if (v77 != (void *)v605[0])
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v605);
    if ((v608 & 0x80000000) == 0) {
      goto LABEL_245;
    }
    goto LABEL_244;
  }
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v605);
  if (v608 < 0) {
LABEL_244:
  }
    operator delete(v607[0]);
LABEL_245:
  llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)&v595, 6.0);
  llvm::APFloat::Storage::Storage(v607, &v595, v43);
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v595);
  std::pair<llvm::APFloat,std::string>::pair[abi:nn180100]<llvm::APFloat,char const(&)[7],0>((uint64_t)&v595, (uint64_t)&v606, "max_value");
  llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)&v592, 0.0);
  llvm::APFloat::Storage::Storage(v605, &v592, v43);
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v592);
  std::pair<llvm::APFloat,std::string>::pair[abi:nn180100]<llvm::APFloat,char const(&)[7],0>((uint64_t)v600, (uint64_t)&p_p, "slope");
  if (v7 < 0) {
    goto LABEL_290;
  }
  uint64_t v180 = *a3;
  v181 = (char *)operator new(0x170uLL);
  mlir::PatternBenefit::PatternBenefit(&v592, 1);
  mlir::Pattern::Pattern((uint64_t)(v181 + 8), (uint64_t)"mps.relu6", 9, (__int16)v592, v180, 0, 0);
  *((void *)v181 + 12) = v4;
  *(void *)v181 = &unk_1EC9A9050;
  v592 = 0;
  v594 = 0;
  llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::DenseMap<std::pair<unsigned int,std::string> const*>((uint64_t)(v181 + 104), (uint64_t *)&v592, (uint64_t *)&v594);
  *((void *)v181 + 16) = v181 + 144;
  *((void *)v181 + 17) = 0x400000000;
  llvm::SmallVectorImpl<std::pair<llvm::APFloat,std::string>>::append<std::pair<llvm::APFloat,std::string> const*,void>((unsigned int *)v181 + 32, (uint64_t)&v595, (uint64_t)&p_p);
  if (!*((void *)v181 + 9))
  {
    v592 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertElementwiseUnary<mlir::m"
           "ps::Relu6Op, mlir::anec::NRelu>]";
    unint64_t v593 = 141;
    unint64_t v182 = llvm::StringRef::find((uint64_t *)&v592, "DesiredTypeName = ", 0x12uLL, 0);
    if (v593 >= v182) {
      unint64_t v183 = v182;
    }
    else {
      unint64_t v183 = v593;
    }
    v184 = &v592[v183];
    unint64_t v185 = v593 - v183;
    if (v593 - v183 >= 0x12) {
      uint64_t v186 = 18;
    }
    else {
      uint64_t v186 = v593 - v183;
    }
    v187 = &v184[v186];
    unint64_t v188 = v185 - v186;
    if (v188 >= v188 - 1) {
      --v188;
    }
    *((void *)v181 + 8) = v187;
    *((void *)v181 + 9) = v188;
  }
  unint64_t v189 = *((unsigned int *)v181 + 22);
  if (v189 > *((_DWORD *)v181 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v181 + 80), v181 + 96, v189, 16);
    LODWORD(v189) = *((_DWORD *)v181 + 22);
  }
  *((_DWORD *)v181 + 22) = v189;
  v191 = (char *)a3[2];
  unint64_t v190 = a3[3];
  if ((unint64_t)v191 >= v190)
  {
    v193 = (char *)a3[1];
    uint64_t v194 = (v191 - v193) >> 3;
    unint64_t v195 = v194 + 1;
    if ((unint64_t)(v194 + 1) >> 61) {
      goto LABEL_763;
    }
    uint64_t v196 = v190 - (void)v193;
    if (v196 >> 2 > v195) {
      unint64_t v195 = v196 >> 2;
    }
    if ((unint64_t)v196 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v197 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v197 = v195;
    }
    if (v197)
    {
      if (v197 >> 61) {
        goto LABEL_764;
      }
      v198 = (char *)operator new(8 * v197);
    }
    else
    {
      v198 = 0;
    }
    v199 = &v198[8 * v194];
    v200 = &v198[8 * v197];
    *(void *)v199 = v181;
    v192 = v199 + 8;
    if (v191 == v193)
    {
      a3[1] = (uint64_t)v199;
      a3[2] = (uint64_t)v192;
      a3[3] = (uint64_t)v200;
      a2 = v589;
    }
    else
    {
      unint64_t v201 = v191 - v193 - 8;
      a2 = v589;
      if (v201 < 0x78
        || &v191[-(v201 & 0xFFFFFFFFFFFFFFF8) - 8] < v199
        && &v198[v191 - v193 - (v201 & 0xFFFFFFFFFFFFFFF8) - 8] < v191)
      {
        goto LABEL_772;
      }
      uint64_t v202 = (v201 >> 3) + 1;
      uint64_t v203 = 8 * (v202 & 0x3FFFFFFFFFFFFFFCLL);
      v204 = &v191[-v203];
      v199 -= v203;
      v205 = &v198[8 * v194 - 16];
      v206 = v191 - 16;
      uint64_t v207 = v202 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v209 = *((_OWORD *)v206 - 1);
        long long v208 = *(_OWORD *)v206;
        *((_OWORD *)v206 - 1) = 0uLL;
        *(_OWORD *)v206 = 0uLL;
        *((_OWORD *)v205 - 1) = v209;
        *(_OWORD *)v205 = v208;
        v205 -= 32;
        v206 -= 32;
        v207 -= 4;
      }
      while (v207);
      v191 = v204;
      if (v202 != (v202 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_772:
        do
        {
          uint64_t v210 = *((void *)v191 - 1);
          v191 -= 8;
          *(void *)v191 = 0;
          *((void *)v199 - 1) = v210;
          v199 -= 8;
        }
        while (v191 != v193);
      }
      v191 = (char *)a3[1];
      v211 = (char *)a3[2];
      a3[1] = (uint64_t)v199;
      a3[2] = (uint64_t)v192;
      a3[3] = (uint64_t)v200;
      if (v211 != v191)
      {
        int v7 = v590;
        uint64_t v43 = v588;
        do
        {
          uint64_t v213 = *((void *)v211 - 1);
          v211 -= 8;
          uint64_t v212 = v213;
          *(void *)v211 = 0;
          if (v213) {
            (*(void (**)(uint64_t))(*(void *)v212 + 8))(v212);
          }
        }
        while (v211 != v191);
        goto LABEL_287;
      }
    }
    int v7 = v590;
    uint64_t v43 = v588;
LABEL_287:
    uint64_t v4 = v591;
    if (v191) {
      operator delete(v191);
    }
    goto LABEL_289;
  }
  *(void *)v191 = v181;
  v192 = v191 + 8;
  a2 = v589;
LABEL_289:
  a3[2] = (uint64_t)v192;
LABEL_290:
  if (v603 < 0) {
    operator delete((void *)v602[3]);
  }
  if (v77 != (void *)v602[0])
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v602);
    if ((SHIBYTE(v599[1]) & 0x80000000) == 0) {
      goto LABEL_295;
    }
    goto LABEL_294;
  }
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v602);
  if (SHIBYTE(v599[1]) < 0) {
LABEL_294:
  }
    operator delete(__p);
LABEL_295:
  if (v77 == v596[0]) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v596);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v596);
  }
  if (v77 == (void *)v605[0]) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v605);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v605);
  }
  if (v77 == v607[0]) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v607);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v607);
  }
  llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)&v595, 0.0);
  llvm::APFloat::Storage::Storage(v607, &v595, v43);
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v595);
  std::pair<llvm::APFloat,std::string>::pair[abi:nn180100]<llvm::APFloat,char const(&)[7],0>((uint64_t)&v595, (uint64_t)&v606, "epsilon");
  if ((v7 & 0x80000000) == 0)
  {
    uint64_t v214 = *a3;
    v215 = (char *)operator new(0x170uLL);
    mlir::PatternBenefit::PatternBenefit(&p_p, 1);
    mlir::Pattern::Pattern((uint64_t)(v215 + 8), (uint64_t)"mps.reciprocal", 14, (__int16)p_p, v214, 0, 0);
    *((void *)v215 + 12) = v4;
    *(void *)v215 = &unk_1EC9A8800;
    p_p = 0;
    v592 = 0;
    llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::DenseMap<std::pair<unsigned int,std::string> const*>((uint64_t)(v215 + 104), (uint64_t *)&p_p, (uint64_t *)&v592);
    *((void *)v215 + 16) = v215 + 144;
    *((void *)v215 + 17) = 0x400000000;
    llvm::SmallVectorImpl<std::pair<llvm::APFloat,std::string>>::append<std::pair<llvm::APFloat,std::string> const*,void>((unsigned int *)v215 + 32, (uint64_t)&v595, (uint64_t)v600);
    if (!*((void *)v215 + 9))
    {
      p_p = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertElementwiseUnary<mlir::"
            "mps::ReciprocalOp, mlir::anec::Invert>]";
      v605[0] = 147;
      unint64_t v216 = llvm::StringRef::find((uint64_t *)&p_p, "DesiredTypeName = ", 0x12uLL, 0);
      if (v605[0] >= v216) {
        unint64_t v217 = v216;
      }
      else {
        unint64_t v217 = v605[0];
      }
      v218 = &p_p[v217];
      unint64_t v219 = v605[0] - v217;
      if (v605[0] - v217 >= 0x12) {
        uint64_t v220 = 18;
      }
      else {
        uint64_t v220 = v605[0] - v217;
      }
      v221 = &v218[v220];
      unint64_t v222 = v219 - v220;
      if (v222 >= v222 - 1) {
        --v222;
      }
      *((void *)v215 + 8) = v221;
      *((void *)v215 + 9) = v222;
    }
    unint64_t v223 = *((unsigned int *)v215 + 22);
    if (v223 > *((_DWORD *)v215 + 23))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v215 + 80), v215 + 96, v223, 16);
      LODWORD(v223) = *((_DWORD *)v215 + 22);
    }
    *((_DWORD *)v215 + 22) = v223;
    v225 = (char *)a3[2];
    unint64_t v224 = a3[3];
    if ((unint64_t)v225 < v224)
    {
      *(void *)v225 = v215;
      v226 = v225 + 8;
      goto LABEL_348;
    }
    v227 = (char *)a3[1];
    uint64_t v228 = (v225 - v227) >> 3;
    unint64_t v229 = v228 + 1;
    if ((unint64_t)(v228 + 1) >> 61) {
      goto LABEL_763;
    }
    uint64_t v230 = v224 - (void)v227;
    if (v230 >> 2 > v229) {
      unint64_t v229 = v230 >> 2;
    }
    if ((unint64_t)v230 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v231 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v231 = v229;
    }
    if (v231)
    {
      if (v231 >> 61) {
        goto LABEL_764;
      }
      v232 = (char *)operator new(8 * v231);
    }
    else
    {
      v232 = 0;
    }
    v233 = &v232[8 * v228];
    v234 = &v232[8 * v231];
    *(void *)v233 = v215;
    v226 = v233 + 8;
    if (v225 == v227)
    {
      a3[1] = (uint64_t)v233;
      a3[2] = (uint64_t)v226;
      a3[3] = (uint64_t)v234;
    }
    else
    {
      unint64_t v235 = v225 - v227 - 8;
      if (v235 < 0x78
        || &v225[-(v235 & 0xFFFFFFFFFFFFFFF8) - 8] < v233
        && &v232[v225 - v227 - (v235 & 0xFFFFFFFFFFFFFFF8) - 8] < v225)
      {
        goto LABEL_773;
      }
      uint64_t v236 = (v235 >> 3) + 1;
      uint64_t v237 = 8 * (v236 & 0x3FFFFFFFFFFFFFFCLL);
      v238 = &v225[-v237];
      v233 -= v237;
      v239 = &v232[8 * v228 - 16];
      v240 = v225 - 16;
      uint64_t v241 = v236 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v243 = *((_OWORD *)v240 - 1);
        long long v242 = *(_OWORD *)v240;
        *((_OWORD *)v240 - 1) = 0uLL;
        *(_OWORD *)v240 = 0uLL;
        *((_OWORD *)v239 - 1) = v243;
        *(_OWORD *)v239 = v242;
        v239 -= 32;
        v240 -= 32;
        v241 -= 4;
      }
      while (v241);
      v225 = v238;
      if (v236 != (v236 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_773:
        do
        {
          uint64_t v244 = *((void *)v225 - 1);
          v225 -= 8;
          *(void *)v225 = 0;
          *((void *)v233 - 1) = v244;
          v233 -= 8;
        }
        while (v225 != v227);
      }
      v225 = (char *)a3[1];
      v245 = (char *)a3[2];
      a3[1] = (uint64_t)v233;
      a3[2] = (uint64_t)v226;
      a3[3] = (uint64_t)v234;
      if (v245 != v225)
      {
        a2 = v589;
        int v7 = v590;
        do
        {
          uint64_t v247 = *((void *)v245 - 1);
          v245 -= 8;
          uint64_t v246 = v247;
          *(void *)v245 = 0;
          if (v247) {
            (*(void (**)(uint64_t))(*(void *)v246 + 8))(v246);
          }
        }
        while (v245 != v225);
        goto LABEL_346;
      }
    }
    a2 = v589;
    int v7 = v590;
LABEL_346:
    uint64_t v4 = v591;
    if (v225) {
      operator delete(v225);
    }
LABEL_348:
    a3[2] = (uint64_t)v226;
    if (v7 < 2) {
      goto LABEL_431;
    }
    uint64_t v248 = *a3;
    v249 = (char *)operator new(0x170uLL);
    mlir::PatternBenefit::PatternBenefit(&p_p, 1);
    mlir::Pattern::Pattern((uint64_t)(v249 + 8), (uint64_t)"mps.reciprocal_square_root", 26, (__int16)p_p, v248, 0, 0);
    *((void *)v249 + 12) = v4;
    *(void *)v249 = &unk_1EC97E930;
    p_p = 0;
    v592 = 0;
    llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::DenseMap<std::pair<unsigned int,std::string> const*>((uint64_t)(v249 + 104), (uint64_t *)&p_p, (uint64_t *)&v592);
    *((void *)v249 + 16) = v249 + 144;
    *((void *)v249 + 17) = 0x400000000;
    llvm::SmallVectorImpl<std::pair<llvm::APFloat,std::string>>::append<std::pair<llvm::APFloat,std::string> const*,void>((unsigned int *)v249 + 32, (uint64_t)&v595, (uint64_t)v600);
    if (!*((void *)v249 + 9))
    {
      p_p = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertElementwiseUnary<mlir::"
            "mps::ReciprocalSquareRootOp, mlir::anec::Rsqrt>]";
      v605[0] = 156;
      unint64_t v250 = llvm::StringRef::find((uint64_t *)&p_p, "DesiredTypeName = ", 0x12uLL, 0);
      if (v605[0] >= v250) {
        unint64_t v251 = v250;
      }
      else {
        unint64_t v251 = v605[0];
      }
      v252 = &p_p[v251];
      unint64_t v253 = v605[0] - v251;
      if (v605[0] - v251 >= 0x12) {
        uint64_t v254 = 18;
      }
      else {
        uint64_t v254 = v605[0] - v251;
      }
      v255 = &v252[v254];
      unint64_t v256 = v253 - v254;
      if (v256 >= v256 - 1) {
        --v256;
      }
      *((void *)v249 + 8) = v255;
      *((void *)v249 + 9) = v256;
    }
    unint64_t v257 = *((unsigned int *)v249 + 22);
    if (v257 > *((_DWORD *)v249 + 23))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v249 + 80), v249 + 96, v257, 16);
      LODWORD(v257) = *((_DWORD *)v249 + 22);
    }
    *((_DWORD *)v249 + 22) = v257;
    v259 = (char *)a3[2];
    unint64_t v258 = a3[3];
    if ((unint64_t)v259 < v258)
    {
      *(void *)v259 = v249;
      v260 = v259 + 8;
      goto LABEL_390;
    }
    v261 = (char *)a3[1];
    uint64_t v262 = (v259 - v261) >> 3;
    unint64_t v263 = v262 + 1;
    if ((unint64_t)(v262 + 1) >> 61) {
      goto LABEL_763;
    }
    uint64_t v264 = v258 - (void)v261;
    if (v264 >> 2 > v263) {
      unint64_t v263 = v264 >> 2;
    }
    if ((unint64_t)v264 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v265 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v265 = v263;
    }
    if (v265)
    {
      if (v265 >> 61) {
        goto LABEL_764;
      }
      v266 = (char *)operator new(8 * v265);
    }
    else
    {
      v266 = 0;
    }
    v267 = &v266[8 * v262];
    v268 = &v266[8 * v265];
    *(void *)v267 = v249;
    v260 = v267 + 8;
    if (v259 == v261)
    {
      a3[1] = (uint64_t)v267;
      a3[2] = (uint64_t)v260;
      a3[3] = (uint64_t)v268;
    }
    else
    {
      unint64_t v269 = v259 - v261 - 8;
      if (v269 < 0x78
        || &v259[-(v269 & 0xFFFFFFFFFFFFFFF8) - 8] < v267
        && &v266[v259 - v261 - (v269 & 0xFFFFFFFFFFFFFFF8) - 8] < v259)
      {
        goto LABEL_774;
      }
      uint64_t v270 = (v269 >> 3) + 1;
      uint64_t v271 = 8 * (v270 & 0x3FFFFFFFFFFFFFFCLL);
      v272 = &v259[-v271];
      v267 -= v271;
      v273 = &v266[8 * v262 - 16];
      v274 = v259 - 16;
      uint64_t v275 = v270 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v277 = *((_OWORD *)v274 - 1);
        long long v276 = *(_OWORD *)v274;
        *((_OWORD *)v274 - 1) = 0uLL;
        *(_OWORD *)v274 = 0uLL;
        *((_OWORD *)v273 - 1) = v277;
        *(_OWORD *)v273 = v276;
        v273 -= 32;
        v274 -= 32;
        v275 -= 4;
      }
      while (v275);
      v259 = v272;
      if (v270 != (v270 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_774:
        do
        {
          uint64_t v278 = *((void *)v259 - 1);
          v259 -= 8;
          *(void *)v259 = 0;
          *((void *)v267 - 1) = v278;
          v267 -= 8;
        }
        while (v259 != v261);
      }
      v259 = (char *)a3[1];
      v279 = (char *)a3[2];
      a3[1] = (uint64_t)v267;
      a3[2] = (uint64_t)v260;
      a3[3] = (uint64_t)v268;
      if (v279 != v259)
      {
        a2 = v589;
        int v7 = v590;
        do
        {
          uint64_t v281 = *((void *)v279 - 1);
          v279 -= 8;
          uint64_t v280 = v281;
          *(void *)v279 = 0;
          if (v281) {
            (*(void (**)(uint64_t))(*(void *)v280 + 8))(v280);
          }
        }
        while (v279 != v259);
        goto LABEL_388;
      }
    }
    a2 = v589;
    int v7 = v590;
LABEL_388:
    uint64_t v4 = v591;
    if (v259) {
      operator delete(v259);
    }
LABEL_390:
    a3[2] = (uint64_t)v260;
    uint64_t v282 = *a3;
    v283 = (char *)operator new(0x170uLL);
    mlir::PatternBenefit::PatternBenefit(&p_p, 1);
    mlir::Pattern::Pattern((uint64_t)(v283 + 8), (uint64_t)"mps.logarithm_base_2", 20, (__int16)p_p, v282, 0, 0);
    *((void *)v283 + 12) = v4;
    *(void *)v283 = &unk_1EC9A8950;
    p_p = 0;
    v592 = 0;
    llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::DenseMap<std::pair<unsigned int,std::string> const*>((uint64_t)(v283 + 104), (uint64_t *)&p_p, (uint64_t *)&v592);
    *((void *)v283 + 16) = v283 + 144;
    *((void *)v283 + 17) = 0x400000000;
    llvm::SmallVectorImpl<std::pair<llvm::APFloat,std::string>>::append<std::pair<llvm::APFloat,std::string> const*,void>((unsigned int *)v283 + 32, (uint64_t)&v595, (uint64_t)v600);
    if (!*((void *)v283 + 9))
    {
      p_p = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertElementwiseUnary<mlir::"
            "mps::LogarithmBase2Op, mlir::anec::Log2>]";
      v605[0] = 149;
      unint64_t v284 = llvm::StringRef::find((uint64_t *)&p_p, "DesiredTypeName = ", 0x12uLL, 0);
      if (v605[0] >= v284) {
        unint64_t v285 = v284;
      }
      else {
        unint64_t v285 = v605[0];
      }
      v286 = &p_p[v285];
      unint64_t v287 = v605[0] - v285;
      if (v605[0] - v285 >= 0x12) {
        uint64_t v288 = 18;
      }
      else {
        uint64_t v288 = v605[0] - v285;
      }
      v289 = &v286[v288];
      unint64_t v290 = v287 - v288;
      if (v290 >= v290 - 1) {
        --v290;
      }
      *((void *)v283 + 8) = v289;
      *((void *)v283 + 9) = v290;
    }
    unint64_t v291 = *((unsigned int *)v283 + 22);
    if (v291 > *((_DWORD *)v283 + 23))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v283 + 80), v283 + 96, v291, 16);
      LODWORD(v291) = *((_DWORD *)v283 + 22);
    }
    *((_DWORD *)v283 + 22) = v291;
    v293 = (char *)a3[2];
    unint64_t v292 = a3[3];
    if ((unint64_t)v293 < v292)
    {
      *(void *)v293 = v283;
      v294 = v293 + 8;
LABEL_430:
      a3[2] = (uint64_t)v294;
      goto LABEL_431;
    }
    v295 = (char *)a3[1];
    uint64_t v296 = (v293 - v295) >> 3;
    unint64_t v297 = v296 + 1;
    if ((unint64_t)(v296 + 1) >> 61) {
      goto LABEL_763;
    }
    uint64_t v298 = v292 - (void)v295;
    if (v298 >> 2 > v297) {
      unint64_t v297 = v298 >> 2;
    }
    if ((unint64_t)v298 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v299 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v299 = v297;
    }
    if (v299)
    {
      if (v299 >> 61) {
        goto LABEL_764;
      }
      v300 = (char *)operator new(8 * v299);
    }
    else
    {
      v300 = 0;
    }
    v301 = &v300[8 * v296];
    v302 = &v300[8 * v299];
    *(void *)v301 = v283;
    v294 = v301 + 8;
    if (v293 == v295)
    {
      a3[1] = (uint64_t)v301;
      a3[2] = (uint64_t)v294;
      a3[3] = (uint64_t)v302;
      int v7 = v590;
    }
    else
    {
      unint64_t v303 = v293 - v295 - 8;
      if (v303 < 0x78
        || &v293[-(v303 & 0xFFFFFFFFFFFFFFF8) - 8] < v301
        && &v300[v293 - v295 - (v303 & 0xFFFFFFFFFFFFFFF8) - 8] < v293)
      {
        goto LABEL_775;
      }
      uint64_t v304 = (v303 >> 3) + 1;
      uint64_t v305 = 8 * (v304 & 0x3FFFFFFFFFFFFFFCLL);
      v306 = &v293[-v305];
      v301 -= v305;
      v307 = &v300[8 * v296 - 16];
      v308 = v293 - 16;
      uint64_t v309 = v304 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v311 = *((_OWORD *)v308 - 1);
        long long v310 = *(_OWORD *)v308;
        *((_OWORD *)v308 - 1) = 0uLL;
        *(_OWORD *)v308 = 0uLL;
        *((_OWORD *)v307 - 1) = v311;
        *(_OWORD *)v307 = v310;
        v307 -= 32;
        v308 -= 32;
        v309 -= 4;
      }
      while (v309);
      v293 = v306;
      if (v304 != (v304 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_775:
        do
        {
          uint64_t v312 = *((void *)v293 - 1);
          v293 -= 8;
          *(void *)v293 = 0;
          *((void *)v301 - 1) = v312;
          v301 -= 8;
        }
        while (v293 != v295);
      }
      v293 = (char *)a3[1];
      v313 = (char *)a3[2];
      a3[1] = (uint64_t)v301;
      a3[2] = (uint64_t)v294;
      a3[3] = (uint64_t)v302;
      if (v313 == v293)
      {
        int v7 = v590;
        uint64_t v4 = v591;
        if (!v293) {
          goto LABEL_430;
        }
        goto LABEL_429;
      }
      int v7 = v590;
      do
      {
        uint64_t v315 = *((void *)v313 - 1);
        v313 -= 8;
        uint64_t v314 = v315;
        *(void *)v313 = 0;
        if (v315) {
          (*(void (**)(uint64_t))(*(void *)v314 + 8))(v314);
        }
      }
      while (v313 != v293);
    }
    uint64_t v4 = v591;
    if (!v293) {
      goto LABEL_430;
    }
LABEL_429:
    operator delete(v293);
    goto LABEL_430;
  }
LABEL_431:
  if (SHIBYTE(v599[1]) < 0) {
    operator delete(__p);
  }
  if (v77 == v596[0]) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v596);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v596);
  }
  if (v77 == v607[0]) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v607);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v607);
  }
  char v597 = 5;
  LODWORD(v595) = 1;
  strcpy((char *)v596, "alpha");
  if (v7 < 2) {
    goto LABEL_481;
  }
  uint64_t v316 = *a3;
  v317 = operator new(0x170uLL);
  mlir::PatternBenefit::PatternBenefit(&v606, 1);
  mlir::Pattern::Pattern((uint64_t)(v317 + 1), (uint64_t)"mps.elu", 7, (__int16)v606, v316, 0, 0);
  v317[12] = v4;
  void *v317 = &unk_1EC9A8A30;
  v606 = (const char *)&v595;
  p_p = (const char *)&__p;
  llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::DenseMap<std::pair<unsigned int,std::string> const*>((uint64_t)(v317 + 13), (uint64_t *)&v606, (uint64_t *)&p_p);
  v317[16] = v317 + 18;
  v317[17] = 0x400000000;
  if (!v317[9])
  {
    v606 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertElementwiseUnary<mlir::m"
           "ps::EluOp, mlir::anec::Elu>]";
    v607[0] = (void *)137;
    v318 = (char *)llvm::StringRef::find((uint64_t *)&v606, "DesiredTypeName = ", 0x12uLL, 0);
    if (v607[0] >= v318) {
      v319 = v318;
    }
    else {
      v319 = (char *)v607[0];
    }
    v320 = &v319[(void)v606];
    v321 = (char *)((char *)v607[0] - (char *)v319);
    if ((void *)((char *)v607[0] - (char *)v319) >= (void *)0x12) {
      uint64_t v322 = 18;
    }
    else {
      uint64_t v322 = (char *)v607[0] - (char *)v319;
    }
    v323 = &v320[v322];
    unint64_t v324 = (unint64_t)&v321[-v322];
    if (v324 >= v324 - 1) {
      --v324;
    }
    v317[8] = v323;
    v317[9] = v324;
  }
  unint64_t v325 = *((unsigned int *)v317 + 22);
  if (v325 > *((_DWORD *)v317 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v317 + 10), v317 + 12, v325, 16);
    LODWORD(v325) = *((_DWORD *)v317 + 22);
  }
  *((_DWORD *)v317 + 22) = v325;
  v327 = (char *)a3[2];
  unint64_t v326 = a3[3];
  if ((unint64_t)v327 < v326)
  {
    *(void *)v327 = v317;
    v328 = v327 + 8;
    goto LABEL_480;
  }
  v329 = (char *)a3[1];
  uint64_t v330 = (v327 - v329) >> 3;
  unint64_t v331 = v330 + 1;
  if ((unint64_t)(v330 + 1) >> 61) {
    goto LABEL_763;
  }
  uint64_t v332 = v326 - (void)v329;
  if (v332 >> 2 > v331) {
    unint64_t v331 = v332 >> 2;
  }
  if ((unint64_t)v332 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v333 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v333 = v331;
  }
  if (v333)
  {
    if (v333 >> 61) {
      goto LABEL_764;
    }
    v334 = (char *)operator new(8 * v333);
  }
  else
  {
    v334 = 0;
  }
  v335 = &v334[8 * v330];
  v336 = &v334[8 * v333];
  *(void *)v335 = v317;
  v328 = v335 + 8;
  if (v327 == v329)
  {
    a3[1] = (uint64_t)v335;
    a3[2] = (uint64_t)v328;
    a3[3] = (uint64_t)v336;
    int v7 = v590;
    goto LABEL_478;
  }
  unint64_t v337 = v327 - v329 - 8;
  if (v337 < 0x78
    || &v327[-(v337 & 0xFFFFFFFFFFFFFFF8) - 8] < v335 && &v334[v327 - v329 - (v337 & 0xFFFFFFFFFFFFFFF8) - 8] < v327)
  {
    goto LABEL_776;
  }
  uint64_t v338 = (v337 >> 3) + 1;
  uint64_t v339 = 8 * (v338 & 0x3FFFFFFFFFFFFFFCLL);
  v340 = &v327[-v339];
  v335 -= v339;
  v341 = &v334[8 * v330 - 16];
  v342 = v327 - 16;
  uint64_t v343 = v338 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v345 = *((_OWORD *)v342 - 1);
    long long v344 = *(_OWORD *)v342;
    *((_OWORD *)v342 - 1) = 0uLL;
    *(_OWORD *)v342 = 0uLL;
    *((_OWORD *)v341 - 1) = v345;
    *(_OWORD *)v341 = v344;
    v341 -= 32;
    v342 -= 32;
    v343 -= 4;
  }
  while (v343);
  v327 = v340;
  if (v338 != (v338 & 0x3FFFFFFFFFFFFFFCLL))
  {
LABEL_776:
    do
    {
      uint64_t v346 = *((void *)v327 - 1);
      v327 -= 8;
      *(void *)v327 = 0;
      *((void *)v335 - 1) = v346;
      v335 -= 8;
    }
    while (v327 != v329);
  }
  v327 = (char *)a3[1];
  v347 = (char *)a3[2];
  a3[1] = (uint64_t)v335;
  a3[2] = (uint64_t)v328;
  a3[3] = (uint64_t)v336;
  if (v347 != v327)
  {
    int v7 = v590;
    do
    {
      uint64_t v349 = *((void *)v347 - 1);
      v347 -= 8;
      uint64_t v348 = v349;
      *(void *)v347 = 0;
      if (v349) {
        (*(void (**)(uint64_t))(*(void *)v348 + 8))(v348);
      }
    }
    while (v347 != v327);
LABEL_478:
    uint64_t v4 = v591;
    if (!v327) {
      goto LABEL_480;
    }
    goto LABEL_479;
  }
  int v7 = v590;
  uint64_t v4 = v591;
  if (v327) {
LABEL_479:
  }
    operator delete(v327);
LABEL_480:
  a3[2] = (uint64_t)v328;
  if (v597 < 0)
  {
    operator delete(v596[0]);
    if (v7 < 0) {
      return;
    }
    goto LABEL_482;
  }
LABEL_481:
  if (v7 < 0) {
    return;
  }
LABEL_482:
  uint64_t v350 = *a3;
  v351 = operator new(0x70uLL);
  mlir::PatternBenefit::PatternBenefit(&v595, 1);
  mlir::Pattern::Pattern((uint64_t)(v351 + 1), (uint64_t)"mps.dequantize", 14, (__int16)v595, v350, 0, 0);
  v351[12] = v4;
  void *v351 = &unk_1EC9A84F0;
  *((unsigned char *)v351 + 104) = a2;
  if (!v351[9])
  {
    v595 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertQuantizationOp<mlir::mps"
           "::DequantizeOp>]";
    v596[0] = (void *)125;
    v352 = (char *)llvm::StringRef::find((uint64_t *)&v595, "DesiredTypeName = ", 0x12uLL, 0);
    if (v596[0] >= v352) {
      v353 = v352;
    }
    else {
      v353 = (char *)v596[0];
    }
    v354 = &v353[(void)v595];
    v355 = (char *)((char *)v596[0] - (char *)v353);
    if ((void *)((char *)v596[0] - (char *)v353) >= (void *)0x12) {
      uint64_t v356 = 18;
    }
    else {
      uint64_t v356 = (char *)v596[0] - (char *)v353;
    }
    v357 = &v354[v356];
    unint64_t v358 = (unint64_t)&v355[-v356];
    if (v358 >= v358 - 1) {
      --v358;
    }
    v351[8] = v357;
    v351[9] = v358;
  }
  unint64_t v359 = *((unsigned int *)v351 + 22);
  if (v359 > *((_DWORD *)v351 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v351 + 10), v351 + 12, v359, 16);
    LODWORD(v359) = *((_DWORD *)v351 + 22);
  }
  *((_DWORD *)v351 + 22) = v359;
  v361 = (char *)a3[2];
  unint64_t v360 = a3[3];
  if ((unint64_t)v361 >= v360)
  {
    v363 = (char *)a3[1];
    uint64_t v364 = (v361 - v363) >> 3;
    unint64_t v365 = v364 + 1;
    if ((unint64_t)(v364 + 1) >> 61) {
      goto LABEL_763;
    }
    uint64_t v366 = v360 - (void)v363;
    if (v366 >> 2 > v365) {
      unint64_t v365 = v366 >> 2;
    }
    if ((unint64_t)v366 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v367 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v367 = v365;
    }
    if (v367)
    {
      if (v367 >> 61) {
        goto LABEL_764;
      }
      v368 = (char *)operator new(8 * v367);
    }
    else
    {
      v368 = 0;
    }
    v369 = &v368[8 * v364];
    v370 = &v368[8 * v367];
    *(void *)v369 = v351;
    v362 = v369 + 8;
    if (v361 == v363)
    {
      a3[1] = (uint64_t)v369;
      a3[2] = (uint64_t)v362;
      a3[3] = (uint64_t)v370;
    }
    else
    {
      unint64_t v371 = v361 - v363 - 8;
      if (v371 < 0x78
        || &v361[-(v371 & 0xFFFFFFFFFFFFFFF8) - 8] < v369
        && &v368[v361 - v363 - (v371 & 0xFFFFFFFFFFFFFFF8) - 8] < v361)
      {
        goto LABEL_777;
      }
      uint64_t v372 = (v371 >> 3) + 1;
      uint64_t v373 = 8 * (v372 & 0x3FFFFFFFFFFFFFFCLL);
      v374 = &v361[-v373];
      v369 -= v373;
      v375 = &v368[8 * v364 - 16];
      v376 = v361 - 16;
      uint64_t v377 = v372 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v379 = *((_OWORD *)v376 - 1);
        long long v378 = *(_OWORD *)v376;
        *((_OWORD *)v376 - 1) = 0uLL;
        *(_OWORD *)v376 = 0uLL;
        *((_OWORD *)v375 - 1) = v379;
        *(_OWORD *)v375 = v378;
        v375 -= 32;
        v376 -= 32;
        v377 -= 4;
      }
      while (v377);
      v361 = v374;
      if (v372 != (v372 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_777:
        do
        {
          uint64_t v380 = *((void *)v361 - 1);
          v361 -= 8;
          *(void *)v361 = 0;
          *((void *)v369 - 1) = v380;
          v369 -= 8;
        }
        while (v361 != v363);
      }
      v361 = (char *)a3[1];
      v381 = (char *)a3[2];
      a3[1] = (uint64_t)v369;
      a3[2] = (uint64_t)v362;
      a3[3] = (uint64_t)v370;
      while (v381 != v361)
      {
        uint64_t v383 = *((void *)v381 - 1);
        v381 -= 8;
        uint64_t v382 = v383;
        *(void *)v381 = 0;
        if (v383) {
          (*(void (**)(uint64_t))(*(void *)v382 + 8))(v382);
        }
      }
    }
    uint64_t v4 = v591;
    if (v361) {
      operator delete(v361);
    }
  }
  else
  {
    *(void *)v361 = v351;
    v362 = v361 + 8;
  }
  a3[2] = (uint64_t)v362;
  uint64_t v384 = *a3;
  v385 = operator new(0x70uLL);
  mlir::PatternBenefit::PatternBenefit(&v595, 1);
  mlir::Pattern::Pattern((uint64_t)(v385 + 1), (uint64_t)"mps.quantize", 12, (__int16)v595, v384, 0, 0);
  v385[12] = v4;
  void *v385 = &unk_1EC9A8480;
  *((unsigned char *)v385 + 104) = a2;
  if (!v385[9])
  {
    v595 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertQuantizationOp<mlir::mps::QuantizeOp>]";
    v596[0] = (void *)123;
    v386 = (char *)llvm::StringRef::find((uint64_t *)&v595, "DesiredTypeName = ", 0x12uLL, 0);
    if (v596[0] >= v386) {
      v387 = v386;
    }
    else {
      v387 = (char *)v596[0];
    }
    v388 = &v387[(void)v595];
    v389 = (char *)((char *)v596[0] - (char *)v387);
    if ((void *)((char *)v596[0] - (char *)v387) >= (void *)0x12) {
      uint64_t v390 = 18;
    }
    else {
      uint64_t v390 = (char *)v596[0] - (char *)v387;
    }
    v391 = &v388[v390];
    unint64_t v392 = (unint64_t)&v389[-v390];
    if (v392 >= v392 - 1) {
      --v392;
    }
    v385[8] = v391;
    v385[9] = v392;
  }
  unint64_t v393 = *((unsigned int *)v385 + 22);
  if (v393 > *((_DWORD *)v385 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v385 + 10), v385 + 12, v393, 16);
    LODWORD(v393) = *((_DWORD *)v385 + 22);
  }
  *((_DWORD *)v385 + 22) = v393;
  v395 = (char *)a3[2];
  unint64_t v394 = a3[3];
  if ((unint64_t)v395 >= v394)
  {
    v397 = (char *)a3[1];
    uint64_t v398 = (v395 - v397) >> 3;
    unint64_t v399 = v398 + 1;
    if ((unint64_t)(v398 + 1) >> 61) {
      goto LABEL_763;
    }
    uint64_t v400 = v394 - (void)v397;
    if (v400 >> 2 > v399) {
      unint64_t v399 = v400 >> 2;
    }
    if ((unint64_t)v400 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v401 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v401 = v399;
    }
    if (v401)
    {
      if (v401 >> 61) {
        goto LABEL_764;
      }
      v402 = (char *)operator new(8 * v401);
    }
    else
    {
      v402 = 0;
    }
    v403 = &v402[8 * v398];
    v404 = &v402[8 * v401];
    *(void *)v403 = v385;
    v396 = v403 + 8;
    if (v395 == v397)
    {
      a3[1] = (uint64_t)v403;
      a3[2] = (uint64_t)v396;
      a3[3] = (uint64_t)v404;
    }
    else
    {
      unint64_t v405 = v395 - v397 - 8;
      if (v405 < 0x78
        || &v395[-(v405 & 0xFFFFFFFFFFFFFFF8) - 8] < v403
        && &v402[v395 - v397 - (v405 & 0xFFFFFFFFFFFFFFF8) - 8] < v395)
      {
        goto LABEL_778;
      }
      uint64_t v406 = (v405 >> 3) + 1;
      uint64_t v407 = 8 * (v406 & 0x3FFFFFFFFFFFFFFCLL);
      v408 = &v395[-v407];
      v403 -= v407;
      v409 = &v402[8 * v398 - 16];
      v410 = v395 - 16;
      uint64_t v411 = v406 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v413 = *((_OWORD *)v410 - 1);
        long long v412 = *(_OWORD *)v410;
        *((_OWORD *)v410 - 1) = 0uLL;
        *(_OWORD *)v410 = 0uLL;
        *((_OWORD *)v409 - 1) = v413;
        *(_OWORD *)v409 = v412;
        v409 -= 32;
        v410 -= 32;
        v411 -= 4;
      }
      while (v411);
      v395 = v408;
      if (v406 != (v406 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_778:
        do
        {
          uint64_t v414 = *((void *)v395 - 1);
          v395 -= 8;
          *(void *)v395 = 0;
          *((void *)v403 - 1) = v414;
          v403 -= 8;
        }
        while (v395 != v397);
      }
      v395 = (char *)a3[1];
      v415 = (char *)a3[2];
      a3[1] = (uint64_t)v403;
      a3[2] = (uint64_t)v396;
      a3[3] = (uint64_t)v404;
      while (v415 != v395)
      {
        uint64_t v417 = *((void *)v415 - 1);
        v415 -= 8;
        uint64_t v416 = v417;
        *(void *)v415 = 0;
        if (v417) {
          (*(void (**)(uint64_t))(*(void *)v416 + 8))(v416);
        }
      }
    }
    uint64_t v4 = v591;
    if (v395) {
      operator delete(v395);
    }
  }
  else
  {
    *(void *)v395 = v385;
    v396 = v395 + 8;
  }
  a3[2] = (uint64_t)v396;
  uint64_t v418 = *a3;
  v419 = operator new(0x70uLL);
  mlir::PatternBenefit::PatternBenefit(&v595, 1);
  mlir::Pattern::Pattern((uint64_t)(v419 + 1), (uint64_t)"mps.conv_2d_data_gradient", 25, (__int16)v595, v418, 0, 0);
  v419[12] = v4;
  void *v419 = &unk_1EC9A4C18;
  *((unsigned char *)v419 + 104) = a2;
  if (!v419[9])
  {
    v595 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertConv<mlir::mps::Conv2DDa"
           "taGradientOp, mlir::anec::Deconvolution>]";
    v596[0] = (void *)150;
    v420 = (char *)llvm::StringRef::find((uint64_t *)&v595, "DesiredTypeName = ", 0x12uLL, 0);
    if (v596[0] >= v420) {
      v421 = v420;
    }
    else {
      v421 = (char *)v596[0];
    }
    v422 = &v421[(void)v595];
    v423 = (char *)((char *)v596[0] - (char *)v421);
    if ((void *)((char *)v596[0] - (char *)v421) >= (void *)0x12) {
      uint64_t v424 = 18;
    }
    else {
      uint64_t v424 = (char *)v596[0] - (char *)v421;
    }
    v425 = &v422[v424];
    unint64_t v426 = (unint64_t)&v423[-v424];
    if (v426 >= v426 - 1) {
      --v426;
    }
    v419[8] = v425;
    v419[9] = v426;
  }
  unint64_t v427 = *((unsigned int *)v419 + 22);
  if (v427 > *((_DWORD *)v419 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v419 + 10), v419 + 12, v427, 16);
    LODWORD(v427) = *((_DWORD *)v419 + 22);
  }
  *((_DWORD *)v419 + 22) = v427;
  v429 = (char *)a3[2];
  unint64_t v428 = a3[3];
  if ((unint64_t)v429 >= v428)
  {
    v431 = (char *)a3[1];
    uint64_t v432 = (v429 - v431) >> 3;
    unint64_t v433 = v432 + 1;
    if ((unint64_t)(v432 + 1) >> 61) {
      goto LABEL_763;
    }
    uint64_t v434 = v428 - (void)v431;
    if (v434 >> 2 > v433) {
      unint64_t v433 = v434 >> 2;
    }
    if ((unint64_t)v434 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v435 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v435 = v433;
    }
    if (v435)
    {
      if (v435 >> 61) {
        goto LABEL_764;
      }
      v436 = (char *)operator new(8 * v435);
    }
    else
    {
      v436 = 0;
    }
    v437 = &v436[8 * v432];
    v438 = &v436[8 * v435];
    *(void *)v437 = v419;
    v430 = v437 + 8;
    if (v429 == v431)
    {
      a3[1] = (uint64_t)v437;
      a3[2] = (uint64_t)v430;
      a3[3] = (uint64_t)v438;
    }
    else
    {
      unint64_t v439 = v429 - v431 - 8;
      if (v439 < 0x78
        || &v429[-(v439 & 0xFFFFFFFFFFFFFFF8) - 8] < v437
        && &v436[v429 - v431 - (v439 & 0xFFFFFFFFFFFFFFF8) - 8] < v429)
      {
        goto LABEL_779;
      }
      uint64_t v440 = (v439 >> 3) + 1;
      uint64_t v441 = 8 * (v440 & 0x3FFFFFFFFFFFFFFCLL);
      v442 = &v429[-v441];
      v437 -= v441;
      v443 = &v436[8 * v432 - 16];
      v444 = v429 - 16;
      uint64_t v445 = v440 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v447 = *((_OWORD *)v444 - 1);
        long long v446 = *(_OWORD *)v444;
        *((_OWORD *)v444 - 1) = 0uLL;
        *(_OWORD *)v444 = 0uLL;
        *((_OWORD *)v443 - 1) = v447;
        *(_OWORD *)v443 = v446;
        v443 -= 32;
        v444 -= 32;
        v445 -= 4;
      }
      while (v445);
      v429 = v442;
      if (v440 != (v440 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_779:
        do
        {
          uint64_t v448 = *((void *)v429 - 1);
          v429 -= 8;
          *(void *)v429 = 0;
          *((void *)v437 - 1) = v448;
          v437 -= 8;
        }
        while (v429 != v431);
      }
      v429 = (char *)a3[1];
      v449 = (char *)a3[2];
      a3[1] = (uint64_t)v437;
      a3[2] = (uint64_t)v430;
      a3[3] = (uint64_t)v438;
      while (v449 != v429)
      {
        uint64_t v451 = *((void *)v449 - 1);
        v449 -= 8;
        uint64_t v450 = v451;
        *(void *)v449 = 0;
        if (v451) {
          (*(void (**)(uint64_t))(*(void *)v450 + 8))(v450);
        }
      }
    }
    uint64_t v4 = v591;
    if (v429) {
      operator delete(v429);
    }
  }
  else
  {
    *(void *)v429 = v419;
    v430 = v429 + 8;
  }
  a3[2] = (uint64_t)v430;
  uint64_t v452 = *a3;
  v453 = operator new(0x70uLL);
  mlir::PatternBenefit::PatternBenefit(&v595, 1);
  mlir::Pattern::Pattern((uint64_t)(v453 + 1), (uint64_t)"mps.conv_2d", 11, (__int16)v595, v452, 0, 0);
  v453[12] = v4;
  void *v453 = &unk_1EC9A4CF8;
  *((unsigned char *)v453 + 104) = a2;
  if (!v453[9])
  {
    v595 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertConv<mlir::mps::Conv2DOp"
           ", mlir::anec::Convolution>]";
    v596[0] = (void *)136;
    v454 = (char *)llvm::StringRef::find((uint64_t *)&v595, "DesiredTypeName = ", 0x12uLL, 0);
    if (v596[0] >= v454) {
      v455 = v454;
    }
    else {
      v455 = (char *)v596[0];
    }
    v456 = &v455[(void)v595];
    v457 = (char *)((char *)v596[0] - (char *)v455);
    if ((void *)((char *)v596[0] - (char *)v455) >= (void *)0x12) {
      uint64_t v458 = 18;
    }
    else {
      uint64_t v458 = (char *)v596[0] - (char *)v455;
    }
    v459 = &v456[v458];
    unint64_t v460 = (unint64_t)&v457[-v458];
    if (v460 >= v460 - 1) {
      --v460;
    }
    v453[8] = v459;
    v453[9] = v460;
  }
  unint64_t v461 = *((unsigned int *)v453 + 22);
  if (v461 > *((_DWORD *)v453 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v453 + 10), v453 + 12, v461, 16);
    LODWORD(v461) = *((_DWORD *)v453 + 22);
  }
  *((_DWORD *)v453 + 22) = v461;
  v463 = (char *)a3[2];
  unint64_t v462 = a3[3];
  if ((unint64_t)v463 >= v462)
  {
    v465 = (char *)a3[1];
    uint64_t v466 = (v463 - v465) >> 3;
    unint64_t v467 = v466 + 1;
    if ((unint64_t)(v466 + 1) >> 61) {
      goto LABEL_763;
    }
    uint64_t v468 = v462 - (void)v465;
    if (v468 >> 2 > v467) {
      unint64_t v467 = v468 >> 2;
    }
    if ((unint64_t)v468 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v469 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v469 = v467;
    }
    if (v469)
    {
      if (v469 >> 61) {
        goto LABEL_764;
      }
      v470 = (char *)operator new(8 * v469);
    }
    else
    {
      v470 = 0;
    }
    v471 = &v470[8 * v466];
    v472 = &v470[8 * v469];
    *(void *)v471 = v453;
    v464 = v471 + 8;
    if (v463 == v465)
    {
      a3[1] = (uint64_t)v471;
      a3[2] = (uint64_t)v464;
      a3[3] = (uint64_t)v472;
    }
    else
    {
      unint64_t v473 = v463 - v465 - 8;
      if (v473 < 0x78
        || &v463[-(v473 & 0xFFFFFFFFFFFFFFF8) - 8] < v471
        && &v470[v463 - v465 - (v473 & 0xFFFFFFFFFFFFFFF8) - 8] < v463)
      {
        goto LABEL_780;
      }
      uint64_t v474 = (v473 >> 3) + 1;
      uint64_t v475 = 8 * (v474 & 0x3FFFFFFFFFFFFFFCLL);
      v476 = &v463[-v475];
      v471 -= v475;
      v477 = &v470[8 * v466 - 16];
      v478 = v463 - 16;
      uint64_t v479 = v474 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v481 = *((_OWORD *)v478 - 1);
        long long v480 = *(_OWORD *)v478;
        *((_OWORD *)v478 - 1) = 0uLL;
        *(_OWORD *)v478 = 0uLL;
        *((_OWORD *)v477 - 1) = v481;
        *(_OWORD *)v477 = v480;
        v477 -= 32;
        v478 -= 32;
        v479 -= 4;
      }
      while (v479);
      v463 = v476;
      if (v474 != (v474 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_780:
        do
        {
          uint64_t v482 = *((void *)v463 - 1);
          v463 -= 8;
          *(void *)v463 = 0;
          *((void *)v471 - 1) = v482;
          v471 -= 8;
        }
        while (v463 != v465);
      }
      v463 = (char *)a3[1];
      v483 = (char *)a3[2];
      a3[1] = (uint64_t)v471;
      a3[2] = (uint64_t)v464;
      a3[3] = (uint64_t)v472;
      while (v483 != v463)
      {
        uint64_t v485 = *((void *)v483 - 1);
        v483 -= 8;
        uint64_t v484 = v485;
        *(void *)v483 = 0;
        if (v485) {
          (*(void (**)(uint64_t))(*(void *)v484 + 8))(v484);
        }
      }
    }
    uint64_t v4 = v591;
    if (v463) {
      operator delete(v463);
    }
  }
  else
  {
    *(void *)v463 = v453;
    v464 = v463 + 8;
  }
  a3[2] = (uint64_t)v464;
  uint64_t v486 = *a3;
  v487 = operator new(0x70uLL);
  mlir::PatternBenefit::PatternBenefit(&v595, 1);
  mlir::Pattern::Pattern((uint64_t)(v487 + 1), (uint64_t)"mps.conv_3d_data_gradient", 25, (__int16)v595, v486, 0, 0);
  v487[12] = v4;
  void *v487 = &unk_1EC9A4C88;
  *((unsigned char *)v487 + 104) = a2;
  if (!v487[9])
  {
    v595 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertConv<mlir::mps::Conv3DDa"
           "taGradientOp, mlir::anec::Deconvolution>]";
    v596[0] = (void *)150;
    v488 = (char *)llvm::StringRef::find((uint64_t *)&v595, "DesiredTypeName = ", 0x12uLL, 0);
    if (v596[0] >= v488) {
      v489 = v488;
    }
    else {
      v489 = (char *)v596[0];
    }
    v490 = &v489[(void)v595];
    v491 = (char *)((char *)v596[0] - (char *)v489);
    if ((void *)((char *)v596[0] - (char *)v489) >= (void *)0x12) {
      uint64_t v492 = 18;
    }
    else {
      uint64_t v492 = (char *)v596[0] - (char *)v489;
    }
    v493 = &v490[v492];
    unint64_t v494 = (unint64_t)&v491[-v492];
    if (v494 >= v494 - 1) {
      --v494;
    }
    v487[8] = v493;
    v487[9] = v494;
  }
  unint64_t v495 = *((unsigned int *)v487 + 22);
  if (v495 > *((_DWORD *)v487 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v487 + 10), v487 + 12, v495, 16);
    LODWORD(v495) = *((_DWORD *)v487 + 22);
  }
  *((_DWORD *)v487 + 22) = v495;
  v497 = (char *)a3[2];
  unint64_t v496 = a3[3];
  if ((unint64_t)v497 >= v496)
  {
    v499 = (char *)a3[1];
    uint64_t v500 = (v497 - v499) >> 3;
    unint64_t v501 = v500 + 1;
    if ((unint64_t)(v500 + 1) >> 61) {
      goto LABEL_763;
    }
    uint64_t v502 = v496 - (void)v499;
    if (v502 >> 2 > v501) {
      unint64_t v501 = v502 >> 2;
    }
    if ((unint64_t)v502 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v503 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v503 = v501;
    }
    if (v503)
    {
      if (v503 >> 61) {
        goto LABEL_764;
      }
      v504 = (char *)operator new(8 * v503);
    }
    else
    {
      v504 = 0;
    }
    v505 = &v504[8 * v500];
    v506 = &v504[8 * v503];
    *(void *)v505 = v487;
    v498 = v505 + 8;
    if (v497 == v499)
    {
      a3[1] = (uint64_t)v505;
      a3[2] = (uint64_t)v498;
      a3[3] = (uint64_t)v506;
    }
    else
    {
      unint64_t v507 = v497 - v499 - 8;
      if (v507 < 0x78
        || &v497[-(v507 & 0xFFFFFFFFFFFFFFF8) - 8] < v505
        && &v504[v497 - v499 - (v507 & 0xFFFFFFFFFFFFFFF8) - 8] < v497)
      {
        goto LABEL_781;
      }
      uint64_t v508 = (v507 >> 3) + 1;
      uint64_t v509 = 8 * (v508 & 0x3FFFFFFFFFFFFFFCLL);
      v510 = &v497[-v509];
      v505 -= v509;
      v511 = &v504[8 * v500 - 16];
      v512 = v497 - 16;
      uint64_t v513 = v508 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v515 = *((_OWORD *)v512 - 1);
        long long v514 = *(_OWORD *)v512;
        *((_OWORD *)v512 - 1) = 0uLL;
        *(_OWORD *)v512 = 0uLL;
        *((_OWORD *)v511 - 1) = v515;
        *(_OWORD *)v511 = v514;
        v511 -= 32;
        v512 -= 32;
        v513 -= 4;
      }
      while (v513);
      v497 = v510;
      if (v508 != (v508 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_781:
        do
        {
          uint64_t v516 = *((void *)v497 - 1);
          v497 -= 8;
          *(void *)v497 = 0;
          *((void *)v505 - 1) = v516;
          v505 -= 8;
        }
        while (v497 != v499);
      }
      v497 = (char *)a3[1];
      v517 = (char *)a3[2];
      a3[1] = (uint64_t)v505;
      a3[2] = (uint64_t)v498;
      a3[3] = (uint64_t)v506;
      while (v517 != v497)
      {
        uint64_t v519 = *((void *)v517 - 1);
        v517 -= 8;
        uint64_t v518 = v519;
        *(void *)v517 = 0;
        if (v519) {
          (*(void (**)(uint64_t))(*(void *)v518 + 8))(v518);
        }
      }
    }
    uint64_t v4 = v591;
    if (v497) {
      operator delete(v497);
    }
  }
  else
  {
    *(void *)v497 = v487;
    v498 = v497 + 8;
  }
  a3[2] = (uint64_t)v498;
  uint64_t v520 = *a3;
  v521 = operator new(0x70uLL);
  mlir::PatternBenefit::PatternBenefit(&v595, 1);
  mlir::Pattern::Pattern((uint64_t)(v521 + 1), (uint64_t)"mps.conv_3d", 11, (__int16)v595, v520, 0, 0);
  v521[12] = v4;
  void *v521 = &unk_1EC9A4D68;
  *((unsigned char *)v521 + 104) = a2;
  if (!v521[9])
  {
    v595 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertConv<mlir::mps::Conv3DOp"
           ", mlir::anec::Convolution>]";
    v596[0] = (void *)136;
    v522 = (char *)llvm::StringRef::find((uint64_t *)&v595, "DesiredTypeName = ", 0x12uLL, 0);
    if (v596[0] >= v522) {
      v523 = v522;
    }
    else {
      v523 = (char *)v596[0];
    }
    v524 = &v523[(void)v595];
    v525 = (char *)((char *)v596[0] - (char *)v523);
    if ((void *)((char *)v596[0] - (char *)v523) >= (void *)0x12) {
      uint64_t v526 = 18;
    }
    else {
      uint64_t v526 = (char *)v596[0] - (char *)v523;
    }
    v527 = &v524[v526];
    unint64_t v528 = (unint64_t)&v525[-v526];
    if (v528 >= v528 - 1) {
      --v528;
    }
    v521[8] = v527;
    v521[9] = v528;
  }
  unint64_t v529 = *((unsigned int *)v521 + 22);
  if (v529 > *((_DWORD *)v521 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v521 + 10), v521 + 12, v529, 16);
    LODWORD(v529) = *((_DWORD *)v521 + 22);
  }
  *((_DWORD *)v521 + 22) = v529;
  v531 = (char *)a3[2];
  unint64_t v530 = a3[3];
  if ((unint64_t)v531 >= v530)
  {
    v533 = (char *)a3[1];
    uint64_t v534 = (v531 - v533) >> 3;
    unint64_t v535 = v534 + 1;
    if ((unint64_t)(v534 + 1) >> 61) {
      goto LABEL_763;
    }
    uint64_t v536 = v530 - (void)v533;
    if (v536 >> 2 > v535) {
      unint64_t v535 = v536 >> 2;
    }
    if ((unint64_t)v536 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v537 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v537 = v535;
    }
    if (v537)
    {
      if (v537 >> 61) {
        goto LABEL_764;
      }
      v538 = (char *)operator new(8 * v537);
    }
    else
    {
      v538 = 0;
    }
    v539 = &v538[8 * v534];
    v540 = &v538[8 * v537];
    *(void *)v539 = v521;
    v532 = v539 + 8;
    if (v531 == v533)
    {
      a3[1] = (uint64_t)v539;
      a3[2] = (uint64_t)v532;
      a3[3] = (uint64_t)v540;
    }
    else
    {
      unint64_t v541 = v531 - v533 - 8;
      if (v541 < 0x78
        || &v531[-(v541 & 0xFFFFFFFFFFFFFFF8) - 8] < v539
        && &v538[v531 - v533 - (v541 & 0xFFFFFFFFFFFFFFF8) - 8] < v531)
      {
        goto LABEL_782;
      }
      uint64_t v542 = (v541 >> 3) + 1;
      uint64_t v543 = 8 * (v542 & 0x3FFFFFFFFFFFFFFCLL);
      v544 = &v531[-v543];
      v539 -= v543;
      v545 = &v538[8 * v534 - 16];
      v546 = v531 - 16;
      uint64_t v547 = v542 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v549 = *((_OWORD *)v546 - 1);
        long long v548 = *(_OWORD *)v546;
        *((_OWORD *)v546 - 1) = 0uLL;
        *(_OWORD *)v546 = 0uLL;
        *((_OWORD *)v545 - 1) = v549;
        *(_OWORD *)v545 = v548;
        v545 -= 32;
        v546 -= 32;
        v547 -= 4;
      }
      while (v547);
      v531 = v544;
      if (v542 != (v542 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_782:
        do
        {
          uint64_t v550 = *((void *)v531 - 1);
          v531 -= 8;
          *(void *)v531 = 0;
          *((void *)v539 - 1) = v550;
          v539 -= 8;
        }
        while (v531 != v533);
      }
      v531 = (char *)a3[1];
      v551 = (char *)a3[2];
      a3[1] = (uint64_t)v539;
      a3[2] = (uint64_t)v532;
      a3[3] = (uint64_t)v540;
      while (v551 != v531)
      {
        uint64_t v553 = *((void *)v551 - 1);
        v551 -= 8;
        uint64_t v552 = v553;
        *(void *)v551 = 0;
        if (v553) {
          (*(void (**)(uint64_t))(*(void *)v552 + 8))(v552);
        }
      }
    }
    uint64_t v4 = v591;
    if (v531) {
      operator delete(v531);
    }
  }
  else
  {
    *(void *)v531 = v521;
    v532 = v531 + 8;
  }
  a3[2] = (uint64_t)v532;
  uint64_t v554 = *a3;
  v555 = operator new(0x70uLL);
  mlir::PatternBenefit::PatternBenefit(&v595, 1);
  mlir::Pattern::Pattern((uint64_t)(v555 + 1), (uint64_t)"mps.depthwise_conv_2d", 21, (__int16)v595, v554, 0, 0);
  v555[12] = v4;
  void *v555 = &unk_1EC9A4BA8;
  *((unsigned char *)v555 + 104) = a2;
  if (!v555[9])
  {
    v595 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertConv<mlir::mps::Depthwis"
           "eConv2DOp, mlir::anec::Convolution>]";
    v596[0] = (void *)145;
    v556 = (char *)llvm::StringRef::find((uint64_t *)&v595, "DesiredTypeName = ", 0x12uLL, 0);
    if (v596[0] >= v556) {
      v557 = v556;
    }
    else {
      v557 = (char *)v596[0];
    }
    v558 = &v557[(void)v595];
    v559 = (char *)((char *)v596[0] - (char *)v557);
    if ((void *)((char *)v596[0] - (char *)v557) >= (void *)0x12) {
      uint64_t v560 = 18;
    }
    else {
      uint64_t v560 = (char *)v596[0] - (char *)v557;
    }
    v561 = &v558[v560];
    unint64_t v562 = (unint64_t)&v559[-v560];
    if (v562 >= v562 - 1) {
      --v562;
    }
    v555[8] = v561;
    v555[9] = v562;
  }
  unint64_t v563 = *((unsigned int *)v555 + 22);
  if (v563 > *((_DWORD *)v555 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v555 + 10), v555 + 12, v563, 16);
    LODWORD(v563) = *((_DWORD *)v555 + 22);
  }
  *((_DWORD *)v555 + 22) = v563;
  v565 = (char *)a3[2];
  unint64_t v564 = a3[3];
  if ((unint64_t)v565 >= v564)
  {
    v567 = (char *)a3[1];
    uint64_t v568 = (v565 - v567) >> 3;
    unint64_t v569 = v568 + 1;
    if (!((unint64_t)(v568 + 1) >> 61))
    {
      uint64_t v570 = v564 - (void)v567;
      if (v570 >> 2 > v569) {
        unint64_t v569 = v570 >> 2;
      }
      if ((unint64_t)v570 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v571 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v571 = v569;
      }
      if (!v571)
      {
        v572 = 0;
        goto LABEL_742;
      }
      if (!(v571 >> 61))
      {
        v572 = (char *)operator new(8 * v571);
LABEL_742:
        v573 = &v572[8 * v568];
        v574 = &v572[8 * v571];
        *(void *)v573 = v555;
        v566 = v573 + 8;
        if (v565 == v567)
        {
          a3[1] = (uint64_t)v573;
          a3[2] = (uint64_t)v566;
          a3[3] = (uint64_t)v574;
        }
        else
        {
          unint64_t v575 = v565 - v567 - 8;
          if (v575 < 0x78
            || &v565[-(v575 & 0xFFFFFFFFFFFFFFF8) - 8] < v573
            && &v572[v565 - v567 - (v575 & 0xFFFFFFFFFFFFFFF8) - 8] < v565)
          {
            goto LABEL_783;
          }
          uint64_t v576 = (v575 >> 3) + 1;
          uint64_t v577 = 8 * (v576 & 0x3FFFFFFFFFFFFFFCLL);
          v578 = &v565[-v577];
          v573 -= v577;
          v579 = &v572[8 * v568 - 16];
          v580 = v565 - 16;
          uint64_t v581 = v576 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v583 = *((_OWORD *)v580 - 1);
            long long v582 = *(_OWORD *)v580;
            *((_OWORD *)v580 - 1) = 0uLL;
            *(_OWORD *)v580 = 0uLL;
            *((_OWORD *)v579 - 1) = v583;
            *(_OWORD *)v579 = v582;
            v579 -= 32;
            v580 -= 32;
            v581 -= 4;
          }
          while (v581);
          v565 = v578;
          if (v576 != (v576 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_783:
            do
            {
              uint64_t v584 = *((void *)v565 - 1);
              v565 -= 8;
              *(void *)v565 = 0;
              *((void *)v573 - 1) = v584;
              v573 -= 8;
            }
            while (v565 != v567);
          }
          v565 = (char *)a3[1];
          v585 = (char *)a3[2];
          a3[1] = (uint64_t)v573;
          a3[2] = (uint64_t)v566;
          a3[3] = (uint64_t)v574;
          while (v585 != v565)
          {
            uint64_t v587 = *((void *)v585 - 1);
            v585 -= 8;
            uint64_t v586 = v587;
            *(void *)v585 = 0;
            if (v587) {
              (*(void (**)(uint64_t))(*(void *)v586 + 8))(v586);
            }
          }
        }
        if (v565) {
          operator delete(v565);
        }
        goto LABEL_757;
      }
LABEL_764:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
LABEL_763:
    abort();
  }
  *(void *)v565 = v555;
  v566 = v565 + 8;
LABEL_757:
  a3[2] = (uint64_t)v566;
}

#error "1807E20A8: too big function (funcsize=0)"

uint64_t std::pair<llvm::APFloat,std::string>::pair[abi:nn180100]<llvm::APFloat,char const(&)[7],0>(uint64_t a1, uint64_t a2, const char *a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v6 = (void *)(a2 + 8);
  int v7 = *(void **)(a2 + 8);
  if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) == v7) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v5, v6);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v5, (uint64_t)v6);
  }
  size_t v8 = strlen(a3);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v9 = v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    char v10 = operator new(v11 + 1);
    *(void *)(a1 + 40) = v9;
    *(void *)(a1 + 48) = v12 | 0x8000000000000000;
    *(void *)(a1 + 32) = v10;
  }
  else
  {
    char v10 = (void *)(a1 + 32);
    *(unsigned char *)(a1 + 55) = v8;
    if (!v8) {
      goto LABEL_12;
    }
  }
  memmove(v10, a3, v9);
LABEL_12:
  *((unsigned char *)v10 + v9) = 0;
  return a1;
}

void mlir::anonymous namespace'::ConvertBiasAdd::~ConvertBiasAdd(mlir::_anonymous_namespace_::ConvertBiasAdd *this)
{
  unint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  unint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::BiasAddOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  size_t v8 = *(uint64_t **)(a3 + 48);
  uint64_t v9 = *(void *)(a3 + 56);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v33 = 259;
      v30[0] = v32;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::BiasAddOp &>(mlir::mps::BiasAddOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v34[0] = *(_OWORD *)a3;
        v34[1] = v28;
        long long v29 = *(_OWORD *)(a3 + 48);
        v34[2] = *(_OWORD *)(a3 + 32);
        v34[3] = v29;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      uint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  uint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::BiasAddOp &>(mlir::mps::BiasAddOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertBiasAdd::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v39 = a2;
  long long v42 = *(_OWORD *)(a3 + 48);
  uint64_t v5 = mlir::ValueRange::dereference_iterator(&v42, 0);
  uint64_t v6 = (char *)mlir::ValueRange::dereference_iterator(&v42, 1);
  int v7 = (uint64_t *)(*(void *)(v5 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v7) {
    goto LABEL_10;
  }
  uint64_t v8 = *v7;
  unint64_t v9 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v10 = *(unsigned int *)(v8 + 16);
  if (!v10) {
    goto LABEL_10;
  }
  uint64_t v11 = *(void **)(v8 + 8);
  uint64_t v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    uint64_t v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    uint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      uint64_t v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_10:
  }
    uint64_t v17 = 0;
  v38[0] = mlir::getRankPromotionTypeForANE((uint64_t)v7, v17);
  v38[1] = v18;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v38);
  uint64_t v20 = v19;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v38);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v21);
  if (!v23) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  unint64_t v24 = IndexFromDim;
  int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v39);
  if (StorageType)
  {
    if (StorageType != 1)
    {
      uint64_t v36 = v39;
      GOC = &v39;
      uint64_t v32 = *(void *)(a4 + 16);
      if (!v32 || !mlir::RewriterBase::Listener::classof(v32)) {
        return 0;
      }
      uint64_t v34 = *(void *)(v36 + 24);
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t **))(*(void *)v32 + 64))(v32, v34, v35, &GOC);
    }
    uint64_t v26 = -1;
  }
  else
  {
    uint64_t v26 = -3;
  }
  if (v20 + v26 != v24
    || (GOC = (uint64_t *)v6, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&GOC)) == 0)
    || (uint64_t v28 = DefiningOp,
        uint64_t v29 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        !(*(unsigned int (**)(void, uint64_t))(**(void **)(v28 + 48) + 32))(*(void *)(v28 + 48), v29)))
  {
    uint64_t v32 = *(void *)(a4 + 16);
    if (!v32) {
      return 0;
    }
    uint64_t v33 = v39;
    if (!mlir::RewriterBase::Listener::classof(v32)) {
      return 0;
    }
    uint64_t v34 = *(void *)(v33 + 24);
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t **))(*(void *)v32 + 64))(v32, v34, v35, &GOC);
  }
  uint64_t v30 = (unsigned int *)v39;
  if (!GOC) {
    return 0;
  }
  uint64_t v40 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&GOC);
  uint64_t v31 = 1;
  mlir::ConversionPatternRewriter::replaceOp(a4, v30, (uint64_t)&v40, 1);
  return v31;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBiasAdd::matchAndRewriteWithStaticShapes(mlir::mps::BiasAddOp,mlir::mps::BiasAddOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::mps::MaterializeSparseTensorOp **a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "BiasAdd unsupported data format ");
  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType(*a1);
  __int16 v9 = 261;
  v8[0] = (const void **)mlir::mps::stringifyTensorDataLayout(StorageType);
  v8[1] = v5;
  uint64_t v6 = mlir::Diagnostic::operator<<(v3, v8);
  return mlir::Diagnostic::operator<<(v6, "\n");
}

uint64_t mlir::anonymous namespace'::anonymous namespace'::makeGOC(uint64_t a1, mlir::MLIRContext *a2, uint64_t a3, char *a4, char *a5, uint64_t OperandRange, int a7, int a8)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  uint64_t v44 = a4;
  uint64_t v45 = a3;
  uint64_t v43 = a5;
  uint64_t v15 = (uint64_t *)(*(void *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v15) {
    goto LABEL_10;
  }
  uint64_t v16 = *v15;
  unint64_t v17 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v18 = *(unsigned int *)(v16 + 16);
  if (!v18) {
    goto LABEL_10;
  }
  uint64_t v19 = *(void **)(v16 + 8);
  uint64_t v20 = &v19[2 * v18];
  do
  {
    unint64_t v21 = v18 >> 1;
    uint64_t v22 = &v19[2 * (v18 >> 1)];
    unint64_t v24 = *v22;
    char v23 = v22 + 2;
    v18 += ~(v18 >> 1);
    if (v24 < v17) {
      uint64_t v19 = v23;
    }
    else {
      unint64_t v18 = v21;
    }
  }
  while (v18);
  if (v19 != v20 && *v19 == v17) {
    uint64_t v25 = v19[1];
  }
  else {
LABEL_10:
  }
    uint64_t v25 = 0;
  v42[0] = mlir::getRankPromotionTypeForANE((uint64_t)v15, v25);
  v42[1] = v26;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v42);
  mlir::anec::getIndexFromDim(1, v27);
  if (v28)
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v42);
    uint64_t v51 = v53;
    uint64_t v52 = 0xC00000000;
    uint64_t v41 = 0;
    if (a4)
    {
      uint64_t v29 = v41;
    }
    else
    {
      uint64_t v29 = 0;
      v53[0] = 1065353216;
      LODWORD(v52) = 1;
    }
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v42);
    if (v32)
    {
      uint64_t v44 = (char *)GOCConstant - 16;
      uint64_t v48 = v50;
      uint64_t v49 = 0xC00000000;
      uint64_t v40 = 0;
      if (a5)
      {
        {
LABEL_27:
          if (v48 != v50) {
            free(v48);
          }
          goto LABEL_29;
        }
        uint64_t v33 = v40;
      }
      else
      {
        uint64_t v33 = 0;
        v50[0] = 0;
        LODWORD(v49) = 1;
      }
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v42);
      if (v36)
      {
        uint64_t v43 = (char *)v35 - 16;
        if (!OperandRange) {
          uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v42);
        }
        LOBYTE(v46) = 0;
        char v47 = 0;
        uint64_t v37 = (void *)mlir::ShapedType::cloneWith(v42, &v46, OperandRange);
      }
      goto LABEL_27;
    }
LABEL_29:
    if (v51 != v53) {
      free(v51);
    }
  }
  return 0;
}

uint64_t mlir::anonymous namespace'::anonymous namespace'::getGOCConstantValue(void *a1, uint64_t a2, int a3, int a4, uint64_t *a5)
{
  v43[2] = *MEMORY[0x1E4F143B8];
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t OperandRange = (uint64_t **)&v39;
  uint64_t ArgOperands = a1;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&ArgOperands);
  if (!DefiningOp || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&OperandRange, DefiningOp)) {
    return 0;
  }
  uint64_t ArgOperands = (void *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v39);
  uint64_t v42 = v11;
  uint64_t OperandRange = (uint64_t **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&ArgOperands);
  if (mlir::Type::isF32((mlir::Type *)&OperandRange) || a3)
  {
    uint64_t ArgOperands = (void *)(a1[1] & 0xFFFFFFFFFFFFFFF8);
    uint64_t Context = (mlir::Float32Type *)mlir::Attribute::getContext((mlir::Attribute *)&ArgOperands);
    uint64_t v14 = mlir::Float32Type::get(Context, v17);
  }
  else
  {
    uint64_t ArgOperands = (void *)(a1[1] & 0xFFFFFFFFFFFFFFF8);
    uint64_t v12 = (mlir::Float16Type *)mlir::Attribute::getContext((mlir::Attribute *)&ArgOperands);
    uint64_t v14 = mlir::Float16Type::get(v12, v13);
  }
  *a5 = v14;
  uint64_t ArgOperands = v43;
  uint64_t v42 = 0x400000000;
  uint64_t OperandRange = (uint64_t **)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v39);
  uint64_t v38 = v18;
  if (*(_UNKNOWN **)(*(void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&OperandRange)
                    + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id
    || (uint64_t OperandRange = (uint64_t **)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v39),
        uint64_t v38 = v19,
        uint64_t v20 = *(void **)(*(void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&OperandRange)
                       + 136),
        v20 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id)
    || v20 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
    || v20 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
    || v20 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
    || v20 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
    || v20 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
    || v20 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
    || v20 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
    || v20 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
    || v20 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
    || v20 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
    || v20 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
  {
    mlir::getIntValues<float>(v39, v40, (uint64_t)&ArgOperands, 1);
    unint64_t v22 = v42;
    unsigned int v23 = *(_DWORD *)(a2 + 8);
    if (v23 != v42)
    {
      if (v23 <= v42)
      {
        if (*(_DWORD *)(a2 + 12) < v42)
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v42, 4);
          unsigned int v23 = *(_DWORD *)(a2 + 8);
        }
        if (v23 != v22) {
          bzero((void *)(*(void *)a2 + 4 * v23), 4 * (v22 - v23));
        }
      }
      *(_DWORD *)(a2 + 8) = v22;
      unint64_t v22 = v42;
    }
    unint64_t v21 = (float *)ArgOperands;
    if (v22)
    {
      uint64_t v24 = 0;
      uint64_t v25 = *(void *)a2;
      if (v22 < 4 || (unint64_t)(v25 - (void)ArgOperands) < 0x10) {
        goto LABEL_52;
      }
      unint64_t v26 = 0;
      uint64_t v24 = v22 & 0xFFFFFFFC;
      __asm { FMOV            V0.4S, #1.0 }
      do
      {
        if (a3) {
          unsigned int v32 = -1;
        }
        else {
          unsigned int v32 = 0;
        }
        float32x4_t v33 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_n_s32(v32), (int8x16_t)vdivq_f32(_Q0, *(float32x4_t *)&v21[v26 / 4]), *(int8x16_t *)&v21[v26 / 4]);
        if (a4) {
          unsigned int v34 = -1;
        }
        else {
          unsigned int v34 = 0;
        }
        *(int8x16_t *)(v25 + v26) = vbslq_s8((int8x16_t)vdupq_n_s32(v34), (int8x16_t)vnegq_f32(v33), (int8x16_t)v33);
        v26 += 16;
      }
      while (((4 * v22) & 0x3FFFFFFF0) != v26);
      if (v22 != v24)
      {
LABEL_52:
        do
        {
          float v35 = v21[v24];
          if (a3) {
            float v35 = 1.0 / v35;
          }
          if (a4) {
            float v35 = -v35;
          }
          *(float *)(v25 + 4 * v24++) = v35;
        }
        while (v22 != v24);
      }
    }
    uint64_t v15 = 1;
  }
  else
  {
    uint64_t v15 = 0;
    unint64_t v21 = (float *)ArgOperands;
  }
  if (v21 != (float *)v43) {
    free(v21);
  }
  return v15;
}

mlir::GenericProgramPoint *mlir::anonymous namespace'::anonymous namespace'::makeGOCConstant(uint64_t a1, mlir::MLIRContext *a2, unint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, char a7, uint64_t a8)
{
  uint64_t F16Type = a8;
  v75[5] = *MEMORY[0x1E4F143B8];
  uint64_t v71 = a8;
  if (a8)
  {
    if (a7) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t F16Type = mlir::Builder::getF16Type((mlir::Float16Type **)(a1 + 8), a2);
    uint64_t v71 = F16Type;
    if (a7) {
      goto LABEL_7;
    }
  }
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, a3);
  if (!v17) {
    return 0;
  }
  a6 = IndexFromDim;
LABEL_7:
  __b = v75;
  int v74 = 5;
  if (a3 < 6)
  {
    if (a3) {
      memset_pattern16(v75, &unk_1810FE350, 8 * a3);
    }
    uint64_t v18 = v75;
  }
  else
  {
    unsigned int v73 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__b, v75, a3, 8);
    uint64_t v18 = __b;
    memset_pattern16(__b, &unk_1810FE350, 8 * a3);
  }
  unsigned int v73 = a3;
  v18[a6] = a5;
  uint64_t v19 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v18, a3, F16Type, 0);
  uint64_t v20 = __b;
  unint64_t v21 = (mlir::AffineMap *)v73;
  unint64_t v22 = (mlir::Float16Type **)(a1 + 8);
  uint64_t v24 = mlir::Builder::getF16Type(v22, v23);
  uint64_t v70 = mlir::MemRefType::get(v20, v21, v24, 0, 0, 0);
  if (!v19) {
    goto LABEL_21;
  }
  uint64_t v25 = *v19;
  unint64_t v26 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v27 = *(unsigned int *)(v25 + 16);
  if (!v27) {
    goto LABEL_21;
  }
  char v28 = *(void **)(v25 + 8);
  uint64_t v29 = &v28[2 * v27];
  do
  {
    unint64_t v30 = v27 >> 1;
    uint64_t v31 = &v28[2 * (v27 >> 1)];
    unint64_t v33 = *v31;
    unsigned int v32 = v31 + 2;
    v27 += ~(v27 >> 1);
    if (v33 < v26) {
      char v28 = v32;
    }
    else {
      unint64_t v27 = v30;
    }
  }
  while (v27);
  if (v28 != v29 && *v28 == v26) {
    uint64_t v34 = v28[1];
  }
  else {
LABEL_21:
  }
    uint64_t v34 = 0;
  mlir::mps::CPUNDArray::CPUNDArray(v68, v19, v34, 0);
  BOOL isF32 = mlir::Type::isF32((mlir::Type *)&v71);
  uint64_t v36 = v69;
  if (isF32)
  {
    if (a5 >= 1)
    {
      uint64_t v37 = 0;
      if ((unint64_t)a5 < 8) {
        goto LABEL_29;
      }
      if ((unint64_t)(v69 - a4) < 0x20) {
        goto LABEL_29;
      }
      uint64_t v37 = a5 & 0x7FFFFFFFFFFFFFF8;
      uint64_t v38 = (long long *)(a4 + 16);
      uint64_t v39 = (_OWORD *)(v69 + 16);
      unint64_t v40 = a5 & 0xFFFFFFFFFFFFFFF8;
      do
      {
        long long v41 = *v38;
        *(v39 - 1) = *(v38 - 1);
        *uint64_t v39 = v41;
        v38 += 2;
        v39 += 2;
        v40 -= 8;
      }
      while (v40);
      if (a5 != v37)
      {
LABEL_29:
        uint64_t v42 = a5 - v37;
        uint64_t v43 = 4 * v37;
        uint64_t v44 = (_DWORD *)(v36 + v43);
        uint64_t v45 = (int *)(a4 + v43);
        do
        {
          int v46 = *v45++;
          *v44++ = v46;
          --v42;
        }
        while (v42);
      }
    }
    goto LABEL_41;
  }
  if (a5 >= 1)
  {
    if ((unint64_t)a5 < 0x10)
    {
      uint64_t v47 = 0;
LABEL_39:
      uint64_t v56 = a5 - v47;
      uint64_t v57 = (_WORD *)(v36 + 2 * v47);
      uint64_t v58 = (int *)(a4 + 4 * v47);
      do
      {
        int v59 = *v58++;
        _S0 = v59;
        __asm { FCVT            H0, S0 }
        *v57++ = _S0;
        --v56;
      }
      while (v56);
      goto LABEL_41;
    }
    uint64_t v47 = a5 & 0x7FFFFFFFFFFFFFF0;
    uint64_t v49 = (float32x4_t *)(a4 + 32);
    uint64_t v50 = (float16x8_t *)(v69 + 16);
    unint64_t v51 = a5 & 0xFFFFFFFFFFFFFFF0;
    do
    {
      float32x4_t v53 = v49[-2];
      float32x4_t v52 = v49[-1];
      float32x4_t v55 = *v49;
      float32x4_t v54 = v49[1];
      v49 += 4;
      v50[-1] = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v53), v52);
      *uint64_t v50 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v55), v54);
      v50 += 2;
      v51 -= 16;
    }
    while (v51);
    if (a5 != v47) {
      goto LABEL_39;
    }
  }
LABEL_41:
  v67[0] = mlir::mps::CPUNDArray::getElementsAttr((mlir::mps::CPUNDArray *)v68, 0, 1);
  v67[1] = v65;
  uint64_t v48 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)v22, (uint64_t)a2, &v70, v67);
  mlir::mps::CPUNDArray::~CPUNDArray((mlir::mps::CPUNDArray *)v68);
  if (__b != v75) {
    free(__b);
  }
  return v48;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::GOC,mlir::MemRefType,mlir::Value &,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.gain_offset_control", (const unsigned __int8 *)0x18, Context);
  if (!v14)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.gain_offset_control";
    void v21[3] = 24;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::anec::GOC::build((uint64_t)a1, (uint64_t)v23, *a3, *a4, *a5, *a6);
  uint64_t v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::anonymous namespace'::canonicalizeType(void *a1, uint64_t a2)
{
  v31[67] = *(pthread_rwlock_t **)MEMORY[0x1E4F143B8];
  unint64_t v26 = a1;
  uint64_t v27 = a2;
  mlir::MPSToANECTypeConverter::MPSToANECTypeConverter((mlir::MPSToANECTypeConverter *)v31);
  uint64_t ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v26);
  if (mlir::ShapedType::getNumElements(ArgAttrsAttr, v3) == 1
    && (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v26), v4 <= 3))
  {
    uint64_t OperandRange = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v26);
    uint64_t v6 = mlir::TypeConverter::convertType((uint64_t)v31, OperandRange);
    if (!v6) {
      uint64_t v6 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v26);
    }
    mlir::getRankPromotionShapeForANE((uint64_t)v26, v27, (uint64_t **)&RankPromotionTypeForANE);
    mlir::MemRefType::get(RankPromotionTypeForANE, (mlir::AffineMap *)v29, v6, 0, 0, 0);
    if (RankPromotionTypeForANE != &v30) {
      free(RankPromotionTypeForANE);
    }
  }
  else
  {
    int v7 = (void *)mlir::TypeConverter::convertType((uint64_t)v31, v26);
    uint64_t v8 = (uint64_t)v7;
    uint64_t v25 = v7;
    if (!v7) {
      goto LABEL_16;
    }
    uint64_t v9 = *v7;
    unint64_t v10 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v11 = *(unsigned int *)(v9 + 16);
    if (!v11) {
      goto LABEL_16;
    }
    uint64_t v12 = *(void **)(v9 + 8);
    uint64_t v13 = &v12[2 * v11];
    do
    {
      unint64_t v14 = v11 >> 1;
      uint64_t v15 = &v12[2 * (v11 >> 1)];
      unint64_t v17 = *v15;
      uint64_t v16 = v15 + 2;
      v11 += ~(v11 >> 1);
      if (v17 < v10) {
        uint64_t v12 = v16;
      }
      else {
        unint64_t v11 = v14;
      }
    }
    while (v11);
    if (v12 != v13 && *v12 == v10) {
      uint64_t v18 = v12[1];
    }
    else {
LABEL_16:
    }
      uint64_t v18 = 0;
    RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v8, v18);
    uint64_t v29 = v19;
    __int16 v20 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
    __int16 v22 = v21;
    uint64_t v23 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&RankPromotionTypeForANE);
    uint64_t MemorySpace = mlir::MemRefType::getMemorySpace((mlir::MemRefType *)&v25);
    mlir::MemRefType::get(v20, v22, v23, 0, MemorySpace);
  }
  mlir::TypeConverter::~TypeConverter(v31);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBiasAdd::matchAndRewriteWithStaticShapes(mlir::mps::BiasAddOp,mlir::mps::BiasAddOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BiasAdd invalid channel or not a constant bias\n");
}

void mlir::anonymous namespace'::ConvertConstant::~ConvertConstant(mlir::_anonymous_namespace_::ConvertConstant *this)
{
  unint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  unint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ConstantOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ConstantOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v18, a3, a4);
  unint64_t v8 = v18[0];
  unint64_t v9 = v18[1];
  mlir::mps::detail::ConstantOpGenericAdaptorBase::ConstantOpGenericAdaptorBase((mlir::Attribute *)v19, a2);
  unint64_t v21 = v8;
  unint64_t v22 = v9;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v19, a5);
  unint64_t v11 = v20;
  if (v20)
  {
    uint64_t v12 = *(void **)(v20->n128_u64[0] + 136);
    if (v12 != &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id) {
      unint64_t v11 = 0;
    }
    unint64_t v17 = v11;
    if (v12 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
    {
      mlir::mps::MPSBufferTensorAttr::getHandle(&v17, &v16);
      uint64_t Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v17);
      Manager = (pthread_rwlock_t **)mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v14);
      return mlir::mps::MPSResourceBlobManagerInterface::decrementResourceRefcount(Manager, (MPSResourceBlobEntry *)v16.n128_u64[0]);
    }
  }
  return result;
}

uint64_t mlir::OpConversionPattern<mlir::mps::ConstantOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v19, a3, a4);
  unint64_t v8 = v19[0];
  unint64_t v9 = v19[1];
  mlir::mps::detail::ConstantOpGenericAdaptorBase::ConstantOpGenericAdaptorBase((mlir::Attribute *)v20, a2);
  unint64_t v22 = v8;
  unint64_t v23 = v9;
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v20, a5);
  unint64_t v11 = v21;
  if (v21)
  {
    uint64_t v12 = *(void **)(v21->n128_u64[0] + 136);
    if (v12 != &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id) {
      unint64_t v11 = 0;
    }
    uint64_t v18 = v11;
    if (v12 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
    {
      mlir::mps::MPSBufferTensorAttr::getHandle(&v18, &v17);
      uint64_t Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
      Manager = (pthread_rwlock_t **)mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v14);
      mlir::mps::MPSResourceBlobManagerInterface::decrementResourceRefcount(Manager, (MPSResourceBlobEntry *)v17.n128_u64[0]);
    }
  }
  return v10;
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ConstantOp>::matchAndRewrite(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (__n128 *)*((void *)a3 + 6);
  uint64_t v9 = *((void *)a3 + 7);
  uint64_t v10 = a3 + 3;
  float32x4_t v53 = v8;
  uint64_t v54 = 0;
  if (v9)
  {
    uint64_t v11 = 0;
    while (1)
    {
      uint64_t v13 = mlir::ValueRange::dereference_iterator(&v53, v11);
      v44[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v13 + 8) & 0xFFFFFFFFFFFFFFF8));
      v44[1] = v14;
      if (v44[0])
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v44)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v44))
        {
          goto LABEL_15;
        }
        uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v44);
        if (v16) {
          break;
        }
      }
LABEL_3:
      uint64_t v11 = ++v54;
      if (v53 == v8 && v11 == v9) {
        goto LABEL_18;
      }
    }
    uint64_t v17 = 8 * v16;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v17 -= 8;
      if (!v17) {
        goto LABEL_3;
      }
    }
LABEL_15:
    __int16 v47 = 259;
    uint64_t v45 = v46;
    v46[0].n128_u64[0] = (unint64_t)"failed: unranked input types or dynamic shapes are not supported on ANEs.";
    uint64_t v18 = *(void *)(a4 + 16);
    if (v18 && mlir::RewriterBase::Listener::classof(v18)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), __n128 **))(*(void *)v18 + 64))(v18, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ConstantOp &>(mlir::mps::ConstantOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v45);
    }
    return 0;
  }
LABEL_18:
  uint64_t v20 = *(unsigned int *)(a2 + 36);
  if (v20) {
    uint64_t v21 = a2 - 16;
  }
  else {
    uint64_t v21 = 0;
  }
  if (v20)
  {
    uint64_t v22 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v21, v22);
      float32x4_t v53 = (__n128 *)llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v54 = v24;
      if (v53)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53))
        {
          goto LABEL_32;
        }
        uint64_t v25 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v53);
        if (v26) {
          break;
        }
      }
LABEL_23:
      if (++v22 == v20) {
        goto LABEL_36;
      }
    }
    uint64_t v27 = 8 * v26;
    while (*v25 != 0x8000000000000000)
    {
      ++v25;
      v27 -= 8;
      if (!v27) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v46[0].n128_u64[0] = (unint64_t)"failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v47 = 259;
    v44[0] = v46;
    uint64_t v28 = *(void *)(a4 + 16);
    if (v28 && mlir::RewriterBase::Listener::classof(v28)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v28 + 64))(v28, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ConstantOp &>(mlir::mps::ConstantOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v44);
    }
    return 0;
  }
LABEL_36:
  if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id) {
    return 0;
  }
  long long v48 = *a3;
  char v49 = *((unsigned char *)a3 + 16);
  uint64_t v30 = (__n128 *)*((void *)a3 + 3);
  uint64_t v50 = v30;
  if (v30)
  {
    uint64_t v31 = *(void **)(v30->n128_u64[0] + 136);
    if (v31 != &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id) {
      uint64_t v30 = 0;
    }
    float32x4_t v53 = v30;
    if (v31 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
    {
      mlir::mps::MPSBufferTensorAttr::getHandle(&v53, v46);
      uint64_t Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v53);
      uint64_t Manager = mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v33);
      unint64_t v35 = v46[0].n128_u64[0];
      uint64_t v36 = (pthread_rwlock_t **)(Manager + 48);
      llvm::sys::RWMutexImpl::lock((pthread_rwlock_t **)(Manager + 48));
      ++*(void *)(v35 + 88);
      llvm::sys::RWMutexImpl::unlock_shared(v36);
    }
  }
  long long v37 = *v10;
  long long v51 = a3[2];
  long long v52 = v37;
  uint64_t v29 = (*(uint64_t (**)(uint64_t, uint64_t, long long *, uint64_t))(*(void *)a1 + 88))(a1, a2, &v48, a4);
  uint64_t v38 = v50;
  if (v50)
  {
    uint64_t v39 = *(void **)(v50->n128_u64[0] + 136);
    if (v39 != &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id) {
      uint64_t v38 = 0;
    }
    float32x4_t v53 = v38;
    if (v39 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
    {
      mlir::mps::MPSBufferTensorAttr::getHandle(&v53, v46);
      unint64_t v40 = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v53);
      uint64_t v42 = (pthread_rwlock_t **)mlir::mps::MPSResourceBlobManagerInterface::getManager(v40, v41);
      mlir::mps::MPSResourceBlobManagerInterface::decrementResourceRefcount(v42, (MPSResourceBlobEntry *)v46[0].n128_u64[0]);
    }
  }
  return v29;
}

void mlir::anonymous namespace'::ConvertConstant::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v44[67] = *(pthread_rwlock_t **)MEMORY[0x1E4F143B8];
  uint64_t v40 = a2;
  mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v44, *(const mlir::TypeConverter **)(a1 + 96));
  uint64_t v5 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  Value = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v40);
  uint64_t v38 = v16;
  uint64_t ArgOperands = (void *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&Value);
  uint64_t v42 = v17;
  uint64_t OperandRange = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&ArgOperands);
  uint64_t v19 = mlir::TypeConverter::convertType((uint64_t)v44, OperandRange);
  uint64_t v20 = (uint64_t)Value;
  uint64_t v21 = v38;
  LOBYTE(ArgOperands) = 0;
  char v43 = 0;
  uint64_t v22 = (uint64_t *)mlir::BaseMemRefType::cloneWith(&v39, (uint64_t)&ArgOperands, v19);
  uint64_t v23 = (uint64_t)v22;
  if (!v22) {
    goto LABEL_20;
  }
  uint64_t v24 = *v22;
  unint64_t v25 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v26 = *(unsigned int *)(v24 + 16);
  if (!v26) {
    goto LABEL_20;
  }
  uint64_t v27 = *(void **)(v24 + 8);
  uint64_t v28 = &v27[2 * v26];
  do
  {
    unint64_t v29 = v26 >> 1;
    uint64_t v30 = &v27[2 * (v26 >> 1)];
    unint64_t v32 = *v30;
    uint64_t v31 = v30 + 2;
    v26 += ~(v26 >> 1);
    if (v32 < v25) {
      uint64_t v27 = v31;
    }
    else {
      unint64_t v26 = v29;
    }
  }
  while (v26);
  if (v27 != v28 && *v27 == v25) {
    uint64_t v33 = v27[1];
  }
  else {
LABEL_20:
  }
    uint64_t v33 = 0;
  uint64_t ArgOperands = mlir::rewriteElementsAttr(v20, v21, v23, v33, 0);
  uint64_t v42 = v34;
  uint64_t v35 = v40;
  uint64_t v36 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 8), *(void *)(v40 + 24), (uint64_t *)&v39, &ArgOperands);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v35, v36);
  mlir::TypeConverter::~TypeConverter(v44);
}

BOOL mlir::mps::MPSResourceBlobManagerInterface::decrementResourceRefcount(pthread_rwlock_t **this, MPSResourceBlobEntry *a2)
{
  uint64_t v3 = this + 6;
  llvm::sys::RWMutexImpl::lock(this + 6);
  if (*((void *)a2 + 11) == 1)
  {
    *((void *)a2 + 11) = 0;
    if (*((unsigned char *)a2 + 80))
    {
      unint64_t v4 = *((void *)a2 + 8);
      if (v4 >= 8)
      {
        uint64_t v5 = (char *)a2 + 40;
        uint64_t v6 = (char *)a2 + 40;
        if ((v4 & 2) == 0) {
          uint64_t v6 = *(char **)v5;
        }
        (*(void (**)(char *, void, void, void))(v4 & 0xFFFFFFFFFFFFFFF8))(v6, *((void *)a2 + 2), *((void *)a2 + 3), *((void *)a2 + 4));
        unint64_t v7 = *((void *)a2 + 8);
        if (v7 >= 8)
        {
          if ((v7 & 4) != 0)
          {
            if ((v7 & 2) == 0) {
              uint64_t v5 = *(char **)v5;
            }
            (*(void (**)(char *))((v7 & 0xFFFFFFFFFFFFFFF8) + 16))(v5);
          }
          if ((v7 & 2) == 0) {
            llvm::deallocate_buffer(*((llvm **)a2 + 5), *((void **)a2 + 6));
          }
        }
      }
      *((unsigned char *)a2 + 80) = 0;
    }
  }
  else
  {
    --*((void *)a2 + 11);
  }

  return llvm::sys::RWMutexImpl::unlock_shared(v3);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ConstantOp &>(mlir::mps::ConstantOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t mlir::anonymous namespace'::anonymous namespace'::canonicalizeType(uint64_t a1, void *a2, uint64_t a3)
{
  v34[5] = *MEMORY[0x1E4F143B8];
  uint64_t v30 = a2;
  uint64_t v31 = a3;
  uint64_t ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v30);
  if (mlir::ShapedType::getNumElements(ArgAttrsAttr, v5) == 1
    && (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v30), v6 <= 3))
  {
    uint64_t OperandRange = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v30);
    uint64_t v8 = mlir::TypeConverter::convertType(a1, OperandRange);
    if (!v8) {
      uint64_t v8 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v30);
    }
    mlir::getRankPromotionShapeForANE((uint64_t)v30, v31, (uint64_t **)&RankPromotionTypeForANE);
    uint64_t v9 = mlir::MemRefType::get(RankPromotionTypeForANE, (mlir::AffineMap *)v33, v8, 0, 0, 0);
    if (RankPromotionTypeForANE != v34) {
      free(RankPromotionTypeForANE);
    }
  }
  else
  {
    uint64_t v10 = (void *)mlir::TypeConverter::convertType(a1, v30);
    uint64_t v11 = (uint64_t)v10;
    unint64_t v29 = v10;
    if (!v10) {
      goto LABEL_16;
    }
    uint64_t v12 = *v10;
    unint64_t v13 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v14 = *(unsigned int *)(v12 + 16);
    if (!v14) {
      goto LABEL_16;
    }
    uint64_t v15 = *(void **)(v12 + 8);
    uint64_t v16 = &v15[2 * v14];
    do
    {
      unint64_t v17 = v14 >> 1;
      uint64_t v18 = &v15[2 * (v14 >> 1)];
      unint64_t v20 = *v18;
      uint64_t v19 = v18 + 2;
      v14 += ~(v14 >> 1);
      if (v20 < v13) {
        uint64_t v15 = v19;
      }
      else {
        unint64_t v14 = v17;
      }
    }
    while (v14);
    if (v15 != v16 && *v15 == v13) {
      uint64_t v21 = v15[1];
    }
    else {
LABEL_16:
    }
      uint64_t v21 = 0;
    RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v11, v21);
    uint64_t v33 = v22;
    uint64_t v23 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
    unint64_t v25 = v24;
    uint64_t v26 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&RankPromotionTypeForANE);
    uint64_t MemorySpace = mlir::MemRefType::getMemorySpace((mlir::MemRefType *)&v29);
    return mlir::MemRefType::get(v23, v25, v26, 0, MemorySpace);
  }
  return v9;
}

mlir::TypeConverter *mlir::TypeConverter::TypeConverter(mlir::TypeConverter *this, const mlir::TypeConverter *a2)
{
  *(void *)this = &unk_1EC9AA670;
  *((void *)this + 1) = (char *)this + 24;
  unint64_t v4 = (void **)((char *)this + 8);
  *((void *)this + 2) = 0x400000000;
  if (*((_DWORD *)a2 + 4)) {
    llvm::SmallVectorImpl<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>>::operator=(v4, (void **)a2 + 1);
  }
  *((void *)this + 19) = (char *)this + 168;
  *((void *)this + 20) = 0x200000000;
  if (*((_DWORD *)a2 + 40)) {
    llvm::SmallVectorImpl<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>>::operator=((void **)this + 19, (void **)a2 + 19);
  }
  *((void *)this + 29) = (char *)this + 248;
  *((void *)this + 30) = 0x200000000;
  if (*((_DWORD *)a2 + 60)) {
    llvm::SmallVectorImpl<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>>::operator=((void **)this + 29, (void **)a2 + 29);
  }
  *((void *)this + 39) = (char *)this + 328;
  *((void *)this + 40) = 0x200000000;
  if (*((_DWORD *)a2 + 80)) {
    llvm::SmallVectorImpl<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>>::operator=((void **)this + 39, (void **)a2 + 39);
  }
  *((void *)this + 49) = (char *)this + 408;
  *((void *)this + 50) = 0x200000000;
  if (*((_DWORD *)a2 + 100)) {
    llvm::SmallVectorImpl<std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)>>::operator=((void **)this + 49, (void **)a2 + 49);
  }
  *((void *)this + 59) = 0;
  *((void *)this + 60) = 0;
  *((_DWORD *)this + 122) = 0;
  *((void *)this + 62) = 0;
  *((void *)this + 63) = 0;
  *((_DWORD *)this + 128) = 0;
  llvm::sys::RWMutexImpl::RWMutexImpl((mlir::TypeConverter *)((char *)this + 520));
  *((void *)this + 66) = 0;
  return this;
}

void **llvm::SmallVectorImpl<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>>::operator=(void **a1, void **a2)
{
  if (a1 != a2)
  {
    unint64_t v4 = *((unsigned int *)a2 + 2);
    uint64_t v5 = *((unsigned int *)a1 + 2);
    if (v5 >= v4)
    {
      if (v4)
      {
        std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)> const*,std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)> const*,std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>*>((uint64_t)&v25, *a2, &(*a2)[4 * v4], *a1);
        uint64_t v10 = v9;
        uint64_t v11 = (uint64_t)*a1;
        uint64_t v5 = *((unsigned int *)a1 + 2);
      }
      else
      {
        uint64_t v11 = (uint64_t)*a1;
        uint64_t v10 = *a1;
      }
      uint64_t v19 = (void *)(v11 + 32 * v5);
      if (v19 != v10)
      {
        unint64_t v20 = v19 - 4;
        uint64_t v21 = v19 - 4;
        do
        {
          uint64_t v23 = (void *)v21[3];
          if (v21 == v23)
          {
            (*(void (**)(void *))(*v21 + 32))(v21);
          }
          else if (v23)
          {
            (*(void (**)(void *))(*v23 + 40))(v23);
          }
          v20 -= 4;
          BOOL v22 = v21 == v10;
          v21 -= 4;
        }
        while (!v22);
      }
      goto LABEL_33;
    }
    if (*((_DWORD *)a1 + 3) >= v4)
    {
      if (v5)
      {
        std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)> const*,std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)> const*,std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>*>((uint64_t)&v26, *a2, &(*a2)[4 * v5], *a1);
        goto LABEL_17;
      }
    }
    else
    {
      if (v5)
      {
        uint64_t v6 = 32 * v5;
        uint64_t v7 = (uint64_t)(*a1 - 4);
        do
        {
          uint64_t v8 = *(void *)(v7 + v6 + 24);
          if (v7 + v6 == v8)
          {
            (*(void (**)(uint64_t))(*(void *)(v7 + v6) + 32))(v7 + v6);
          }
          else if (v8)
          {
            (*(void (**)(uint64_t))(*(void *)v8 + 40))(v8);
          }
          v6 -= 32;
        }
        while (v6);
      }
      *((_DWORD *)a1 + 2) = 0;
      llvm::SmallVectorTemplateBase<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>,false>::grow((uint64_t)a1, v4);
    }
    uint64_t v5 = 0;
LABEL_17:
    uint64_t v12 = *((unsigned int *)a2 + 2);
    if (v5 != v12)
    {
      uint64_t v13 = (uint64_t)*a2;
      uint64_t v14 = 32 * v5;
      uint64_t v15 = (uint64_t)&(*a1)[4 * v5];
      uint64_t v16 = v13 + 32 * v5;
      uint64_t v17 = 32 * v12 - v14;
      do
      {
        uint64_t v18 = *(void *)(v16 + 24);
        if (v18)
        {
          if (v16 == v18)
          {
            *(void *)(v15 + 24) = v15;
            (*(void (**)(void, uint64_t))(**(void **)(v16 + 24) + 24))(*(void *)(v16 + 24), v15);
          }
          else
          {
            *(void *)(v15 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 16))(v18);
          }
        }
        else
        {
          *(void *)(v15 + 24) = 0;
        }
        v16 += 32;
        v15 += 32;
        v17 -= 32;
      }
      while (v17);
    }
LABEL_33:
    *((_DWORD *)a1 + 2) = v4;
  }
  return a1;
}

void llvm::SmallVectorTemplateBase<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>,false>::grow(uint64_t a1, unint64_t a2)
{
  unint64_t v16 = 0;
  uint64_t v3 = (void *)(a1 + 16);
  unint64_t v4 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), a2, 32, &v16);
  uint64_t v5 = v4;
  uint64_t v6 = *(void **)a1;
  uint64_t v7 = *(unsigned int *)(a1 + 8);
  if (v7)
  {
    uint64_t v8 = 32 * v7;
    uint64_t v9 = v4;
    do
    {
      uint64_t v10 = (void *)v6[3];
      if (v10)
      {
        if (v6 == v10)
        {
          uint64_t v9[3] = v9;
          (*(void (**)(void, void *))(*(void *)v6[3] + 24))(v6[3], v9);
        }
        else
        {
          uint64_t v9[3] = v10;
          v6[3] = 0;
        }
      }
      else
      {
        uint64_t v9[3] = 0;
      }
      v9 += 4;
      v6 += 4;
      v8 -= 32;
    }
    while (v8);
    uint64_t v6 = *(void **)a1;
    uint64_t v11 = *(unsigned int *)(a1 + 8);
    if (v11)
    {
      uint64_t v12 = 4 * v11;
      uint64_t v13 = v6 - 4;
      do
      {
        uint64_t v14 = (void *)v13[v12 + 3];
        if (&v13[v12] == v14)
        {
          (*(void (**)(void *))(v13[v12] + 32))(&v13[v12]);
        }
        else if (v14)
        {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        v12 -= 4;
      }
      while (v12 * 8);
      uint64_t v6 = *(void **)a1;
    }
  }
  int v15 = v16;
  if (v6 != v3) {
    free(v6);
  }
  *(void *)a1 = v5;
  *(_DWORD *)(a1 + 12) = v15;
}

void *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)> const*,std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)> const*,std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>*>(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v5 = a2;
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a2 != a3)
  {
    uint64_t v7 = a2;
    do
    {
      uint64_t v8 = (void *)v5[3];
      if (v8)
      {
        if (v5 == v8)
        {
          uint64_t v11 = v10;
          (*(void (**)(void *, void *))(*v5 + 24))(v5, v10);
        }
        else
        {
          uint64_t v11 = (void *)(*(uint64_t (**)(void *))(*v8 + 16))(v8);
        }
      }
      else
      {
        uint64_t v11 = 0;
      }
      std::__function::__value_func<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>::swap[abi:nn180100](v10, a4);
      if (v11 == v10)
      {
        (*(void (**)(void *))(v10[0] + 32))(v10);
      }
      else if (v11)
      {
        (*(void (**)(void))(*v11 + 40))();
      }
      v5 += 4;
      a4 += 4;
      v7 += 4;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

void *std::__function::__value_func<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>::swap[abi:nn180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    uint64_t v3 = result;
    unint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void **llvm::SmallVectorImpl<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>>::operator=(void **a1, void **a2)
{
  if (a1 != a2)
  {
    unint64_t v4 = *((unsigned int *)a2 + 2);
    uint64_t v5 = *((unsigned int *)a1 + 2);
    if (v5 >= v4)
    {
      if (v4)
      {
        std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)> const*,std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)> const*,std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>*>((uint64_t)&v25, *a2, &(*a2)[4 * v4], *a1);
        uint64_t v10 = v9;
        uint64_t v11 = (uint64_t)*a1;
        uint64_t v5 = *((unsigned int *)a1 + 2);
      }
      else
      {
        uint64_t v11 = (uint64_t)*a1;
        uint64_t v10 = *a1;
      }
      uint64_t v19 = (void *)(v11 + 32 * v5);
      if (v19 != v10)
      {
        unint64_t v20 = v19 - 4;
        uint64_t v21 = v19 - 4;
        do
        {
          uint64_t v23 = (void *)v21[3];
          if (v21 == v23)
          {
            (*(void (**)(void *))(*v21 + 32))(v21);
          }
          else if (v23)
          {
            (*(void (**)(void *))(*v23 + 40))(v23);
          }
          v20 -= 4;
          BOOL v22 = v21 == v10;
          v21 -= 4;
        }
        while (!v22);
      }
      goto LABEL_33;
    }
    if (*((_DWORD *)a1 + 3) >= v4)
    {
      if (v5)
      {
        std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)> const*,std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)> const*,std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>*>((uint64_t)&v26, *a2, &(*a2)[4 * v5], *a1);
        goto LABEL_17;
      }
    }
    else
    {
      if (v5)
      {
        uint64_t v6 = 32 * v5;
        uint64_t v7 = (uint64_t)(*a1 - 4);
        do
        {
          uint64_t v8 = *(void *)(v7 + v6 + 24);
          if (v7 + v6 == v8)
          {
            (*(void (**)(uint64_t))(*(void *)(v7 + v6) + 32))(v7 + v6);
          }
          else if (v8)
          {
            (*(void (**)(uint64_t))(*(void *)v8 + 40))(v8);
          }
          v6 -= 32;
        }
        while (v6);
      }
      *((_DWORD *)a1 + 2) = 0;
      llvm::SmallVectorTemplateBase<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>,false>::grow((uint64_t)a1, v4);
    }
    uint64_t v5 = 0;
LABEL_17:
    uint64_t v12 = *((unsigned int *)a2 + 2);
    if (v5 != v12)
    {
      uint64_t v13 = (uint64_t)*a2;
      uint64_t v14 = 32 * v5;
      uint64_t v15 = (uint64_t)&(*a1)[4 * v5];
      uint64_t v16 = v13 + 32 * v5;
      uint64_t v17 = 32 * v12 - v14;
      do
      {
        uint64_t v18 = *(void *)(v16 + 24);
        if (v18)
        {
          if (v16 == v18)
          {
            *(void *)(v15 + 24) = v15;
            (*(void (**)(void, uint64_t))(**(void **)(v16 + 24) + 24))(*(void *)(v16 + 24), v15);
          }
          else
          {
            *(void *)(v15 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 16))(v18);
          }
        }
        else
        {
          *(void *)(v15 + 24) = 0;
        }
        v16 += 32;
        v15 += 32;
        v17 -= 32;
      }
      while (v17);
    }
LABEL_33:
    *((_DWORD *)a1 + 2) = v4;
  }
  return a1;
}

void llvm::SmallVectorTemplateBase<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>,false>::grow(uint64_t a1, unint64_t a2)
{
  unint64_t v16 = 0;
  uint64_t v3 = (void *)(a1 + 16);
  unint64_t v4 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), a2, 32, &v16);
  uint64_t v5 = v4;
  uint64_t v6 = *(void **)a1;
  uint64_t v7 = *(unsigned int *)(a1 + 8);
  if (v7)
  {
    uint64_t v8 = 32 * v7;
    uint64_t v9 = v4;
    do
    {
      uint64_t v10 = (void *)v6[3];
      if (v10)
      {
        if (v6 == v10)
        {
          uint64_t v9[3] = v9;
          (*(void (**)(void, void *))(*(void *)v6[3] + 24))(v6[3], v9);
        }
        else
        {
          uint64_t v9[3] = v10;
          v6[3] = 0;
        }
      }
      else
      {
        uint64_t v9[3] = 0;
      }
      v9 += 4;
      v6 += 4;
      v8 -= 32;
    }
    while (v8);
    uint64_t v6 = *(void **)a1;
    uint64_t v11 = *(unsigned int *)(a1 + 8);
    if (v11)
    {
      uint64_t v12 = 4 * v11;
      uint64_t v13 = v6 - 4;
      do
      {
        uint64_t v14 = (void *)v13[v12 + 3];
        if (&v13[v12] == v14)
        {
          (*(void (**)(void *))(v13[v12] + 32))(&v13[v12]);
        }
        else if (v14)
        {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        v12 -= 4;
      }
      while (v12 * 8);
      uint64_t v6 = *(void **)a1;
    }
  }
  int v15 = v16;
  if (v6 != v3) {
    free(v6);
  }
  *(void *)a1 = v5;
  *(_DWORD *)(a1 + 12) = v15;
}

void *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)> const*,std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)> const*,std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>*>(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v5 = a2;
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a2 != a3)
  {
    uint64_t v7 = a2;
    do
    {
      uint64_t v8 = (void *)v5[3];
      if (v8)
      {
        if (v5 == v8)
        {
          uint64_t v11 = v10;
          (*(void (**)(void *, void *))(*v5 + 24))(v5, v10);
        }
        else
        {
          uint64_t v11 = (void *)(*(uint64_t (**)(void *))(*v8 + 16))(v8);
        }
      }
      else
      {
        uint64_t v11 = 0;
      }
      std::__function::__value_func<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>::swap[abi:nn180100](v10, a4);
      if (v11 == v10)
      {
        (*(void (**)(void *))(v10[0] + 32))(v10);
      }
      else if (v11)
      {
        (*(void (**)(void))(*v11 + 40))();
      }
      v5 += 4;
      a4 += 4;
      v7 += 4;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

void *std::__function::__value_func<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>::swap[abi:nn180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    uint64_t v3 = result;
    unint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void **llvm::SmallVectorImpl<std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)>>::operator=(void **a1, void **a2)
{
  if (a1 != a2)
  {
    unint64_t v4 = *((unsigned int *)a2 + 2);
    uint64_t v5 = *((unsigned int *)a1 + 2);
    if (v5 >= v4)
    {
      if (v4)
      {
        std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)> const*,std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)> const*,std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)>*>((uint64_t)&v25, *a2, &(*a2)[4 * v4], *a1);
        uint64_t v10 = v9;
        uint64_t v11 = (uint64_t)*a1;
        uint64_t v5 = *((unsigned int *)a1 + 2);
      }
      else
      {
        uint64_t v11 = (uint64_t)*a1;
        uint64_t v10 = *a1;
      }
      uint64_t v19 = (void *)(v11 + 32 * v5);
      if (v19 != v10)
      {
        unint64_t v20 = v19 - 4;
        uint64_t v21 = v19 - 4;
        do
        {
          uint64_t v23 = (void *)v21[3];
          if (v21 == v23)
          {
            (*(void (**)(void *))(*v21 + 32))(v21);
          }
          else if (v23)
          {
            (*(void (**)(void *))(*v23 + 40))(v23);
          }
          v20 -= 4;
          BOOL v22 = v21 == v10;
          v21 -= 4;
        }
        while (!v22);
      }
      goto LABEL_33;
    }
    if (*((_DWORD *)a1 + 3) >= v4)
    {
      if (v5)
      {
        std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)> const*,std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)> const*,std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)>*>((uint64_t)&v26, *a2, &(*a2)[4 * v5], *a1);
        goto LABEL_17;
      }
    }
    else
    {
      if (v5)
      {
        uint64_t v6 = 32 * v5;
        uint64_t v7 = (uint64_t)(*a1 - 4);
        do
        {
          uint64_t v8 = *(void *)(v7 + v6 + 24);
          if (v7 + v6 == v8)
          {
            (*(void (**)(uint64_t))(*(void *)(v7 + v6) + 32))(v7 + v6);
          }
          else if (v8)
          {
            (*(void (**)(uint64_t))(*(void *)v8 + 40))(v8);
          }
          v6 -= 32;
        }
        while (v6);
      }
      *((_DWORD *)a1 + 2) = 0;
      llvm::SmallVectorTemplateBase<std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)>,false>::grow((uint64_t)a1, v4);
    }
    uint64_t v5 = 0;
LABEL_17:
    uint64_t v12 = *((unsigned int *)a2 + 2);
    if (v5 != v12)
    {
      uint64_t v13 = (uint64_t)*a2;
      uint64_t v14 = 32 * v5;
      uint64_t v15 = (uint64_t)&(*a1)[4 * v5];
      uint64_t v16 = v13 + 32 * v5;
      uint64_t v17 = 32 * v12 - v14;
      do
      {
        uint64_t v18 = *(void *)(v16 + 24);
        if (v18)
        {
          if (v16 == v18)
          {
            *(void *)(v15 + 24) = v15;
            (*(void (**)(void, uint64_t))(**(void **)(v16 + 24) + 24))(*(void *)(v16 + 24), v15);
          }
          else
          {
            *(void *)(v15 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 16))(v18);
          }
        }
        else
        {
          *(void *)(v15 + 24) = 0;
        }
        v16 += 32;
        v15 += 32;
        v17 -= 32;
      }
      while (v17);
    }
LABEL_33:
    *((_DWORD *)a1 + 2) = v4;
  }
  return a1;
}

void llvm::SmallVectorTemplateBase<std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)>,false>::grow(uint64_t a1, unint64_t a2)
{
  unint64_t v16 = 0;
  uint64_t v3 = (void *)(a1 + 16);
  unint64_t v4 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), a2, 32, &v16);
  uint64_t v5 = v4;
  uint64_t v6 = *(void **)a1;
  uint64_t v7 = *(unsigned int *)(a1 + 8);
  if (v7)
  {
    uint64_t v8 = 32 * v7;
    uint64_t v9 = v4;
    do
    {
      uint64_t v10 = (void *)v6[3];
      if (v10)
      {
        if (v6 == v10)
        {
          uint64_t v9[3] = v9;
          (*(void (**)(void, void *))(*(void *)v6[3] + 24))(v6[3], v9);
        }
        else
        {
          uint64_t v9[3] = v10;
          v6[3] = 0;
        }
      }
      else
      {
        uint64_t v9[3] = 0;
      }
      v9 += 4;
      v6 += 4;
      v8 -= 32;
    }
    while (v8);
    uint64_t v6 = *(void **)a1;
    uint64_t v11 = *(unsigned int *)(a1 + 8);
    if (v11)
    {
      uint64_t v12 = 4 * v11;
      uint64_t v13 = v6 - 4;
      do
      {
        uint64_t v14 = (void *)v13[v12 + 3];
        if (&v13[v12] == v14)
        {
          (*(void (**)(void *))(v13[v12] + 32))(&v13[v12]);
        }
        else if (v14)
        {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        v12 -= 4;
      }
      while (v12 * 8);
      uint64_t v6 = *(void **)a1;
    }
  }
  int v15 = v16;
  if (v6 != v3) {
    free(v6);
  }
  *(void *)a1 = v5;
  *(_DWORD *)(a1 + 12) = v15;
}

void *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)> const*,std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)> const*,std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)>*>(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v5 = a2;
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a2 != a3)
  {
    uint64_t v7 = a2;
    do
    {
      uint64_t v8 = (void *)v5[3];
      if (v8)
      {
        if (v5 == v8)
        {
          uint64_t v11 = v10;
          (*(void (**)(void *, void *))(*v5 + 24))(v5, v10);
        }
        else
        {
          uint64_t v11 = (void *)(*(uint64_t (**)(void *))(*v8 + 16))(v8);
        }
      }
      else
      {
        uint64_t v11 = 0;
      }
      std::__function::__value_func<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)>::swap[abi:nn180100](v10, a4);
      if (v11 == v10)
      {
        (*(void (**)(void *))(v10[0] + 32))(v10);
      }
      else if (v11)
      {
        (*(void (**)(void))(*v11 + 40))();
      }
      v5 += 4;
      a4 += 4;
      v7 += 4;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

void *std::__function::__value_func<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)>::swap[abi:nn180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    uint64_t v3 = result;
    unint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void mlir::anonymous namespace'::ConvertCropResize::~ConvertCropResize(mlir::_anonymous_namespace_::ConvertCropResize *this)
{
  unint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  unint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::CropResizeOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::CropResizeOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::CropResizeOpGenericAdaptorBase::CropResizeOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::CropResizeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::CropResizeOpGenericAdaptorBase::CropResizeOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::CropResizeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 96);
  uint64_t v9 = *(void *)(a3 + 104);
  long long v37 = v8;
  uint64_t v38 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        long long v37 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v38 = v23;
        if (v37)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v37);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v34[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v35 = 259;
      v32[0] = v34;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CropResizeOp &>(mlir::mps::CropResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v32);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 96);
        long long v29 = *(_OWORD *)(a3 + 64);
        v36[5] = *(_OWORD *)(a3 + 80);
        v36[6] = v28;
        long long v30 = *(_OWORD *)(a3 + 16);
        v36[0] = *(_OWORD *)a3;
        v36[1] = v30;
        long long v31 = *(_OWORD *)(a3 + 32);
        v36[3] = *(_OWORD *)(a3 + 48);
        v36[4] = v29;
        v36[2] = v31;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v36, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v37, v10);
    v32[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v32[1] = v13;
    if (v32[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v38;
    if (v37 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v35 = 259;
  uint64_t v33 = v34;
  v34[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CropResizeOp &>(mlir::mps::CropResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v33);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertCropResize::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v259 = *MEMORY[0x1E4F143B8];
  uint64_t v227 = a2;
  long long v258 = *(_OWORD *)(a3 + 96);
  uint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v258, 1) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v226[0] = v5;
  v226[1] = v15;
  uint64_t v16 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v227) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    uint64_t v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  GOCConstant = v16;
  uint64_t v250 = v26;
  uint64_t ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&GOCConstant);
  uint64_t v29 = v27;
  v255 = v257;
  uint64_t v256 = 0x500000000;
  size_t v30 = 8 * v27;
  if ((unint64_t)(8 * v27) < 0x29)
  {
    int v31 = 0;
    unint64_t v32 = v257;
    if (!v29) {
      goto LABEL_26;
    }
    goto LABEL_25;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v255, v257, (8 * v27) >> 3, 8);
  int v31 = v256;
  unint64_t v32 = v255;
  if (v29)
  {
LABEL_25:
    memcpy(&v32[8 * v31], ArgAttrsAttr, v30);
    int v31 = v256;
    unint64_t v32 = v255;
  }
LABEL_26:
  LODWORD(v256) = v31 + (v30 >> 3);
  llvm::SmallVectorImpl<long long>::insert((uint64_t)&v255, (uint64_t)v32, 3uLL, 1uLL);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(0, v256);
  if (!v34) {
    goto LABEL_203;
  }
  unint64_t v35 = IndexFromDim;
  unint64_t v36 = mlir::anec::getIndexFromDim(3, v256);
  if (!v37) {
    goto LABEL_203;
  }
  uint64_t v38 = v255;
  uint64_t v39 = v255[v35];
  v255[v35] = v255[v36];
  v38[v36] = v39;
  uint64_t v40 = (mlir::AffineMap *)v256;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v226);
  uint64_t v225 = mlir::MemRefType::get(v38, v40, OperandRange, 0, 0, 0);
  uint64_t v42 = *(void *)(v227 + 24);
  GOCConstant = (void *)mlir::ValueRange::dereference_iterator(&v258, 1);
  uint64_t v224 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), v42, &v225, (uint64_t *)&GOCConstant)- 16;
  char v43 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v227) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v43) {
    goto LABEL_37;
  }
  uint64_t v44 = *v43;
  unint64_t v45 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v46 = *(unsigned int *)(v44 + 16);
  if (!v46) {
    goto LABEL_37;
  }
  __int16 v47 = *(void **)(v44 + 8);
  long long v48 = &v47[2 * v46];
  do
  {
    unint64_t v49 = v46 >> 1;
    uint64_t v50 = &v47[2 * (v46 >> 1)];
    unint64_t v52 = *v50;
    long long v51 = v50 + 2;
    v46 += ~(v46 >> 1);
    if (v52 < v45) {
      __int16 v47 = v51;
    }
    else {
      unint64_t v46 = v49;
    }
  }
  while (v46);
  if (v47 != v48 && *v47 == v45) {
    uint64_t v53 = v47[1];
  }
  else {
LABEL_37:
  }
    uint64_t v53 = 0;
  v223[0] = v43;
  v223[1] = v53;
  mlir::mps::CropResizeOp::getSpatialScale((mlir::mps::CropResizeOp *)&v227, (uint64_t)&GOCConstant);
  uint64_t v54 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)&v242, 1.0);
  uint64_t v55 = llvm::APFloatBase::IEEEsingle(v54);
  llvm::APFloat::Storage::Storage(&v253, &v242, v55);
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v242);
  uint64_t v56 = (void *)v250;
  uint64_t v57 = v253;
  int v59 = llvm::APFloatBase::PPCDoubleDouble(v58);
  if (v56 == (void *)v57)
  {
    char v61 = v59 == v56
        ? llvm::detail::DoubleAPFloat::bitwiseIsEqual((llvm::detail::DoubleAPFloat *)&v250, (const llvm::detail::DoubleAPFloat *)&v253): llvm::detail::IEEEFloat::bitwiseIsEqual((llvm::detail::IEEEFloat *)&v250, (const llvm::detail::IEEEFloat *)&v253);
    char v60 = v61;
  }
  else
  {
    char v60 = 0;
  }
  if (v59 == (void *)v253) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v253);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v253);
  }
  if (v59 == (void *)v250)
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v250);
    if (v60) {
      goto LABEL_62;
    }
  }
  else
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v250);
    if (v60) {
      goto LABEL_62;
    }
  }
  mlir::mps::CropResizeOp::getSpatialScale((mlir::mps::CropResizeOp *)&v227, (uint64_t)&GOCConstant);
  float v62 = llvm::APFloat::convertToFloat(&GOCConstant);
  if (v59 == (void *)v250) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v250);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v250);
  }
  uint64_t v63 = *(mlir::MLIRContext **)(v227 + 24);
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v225);
  *(float *)&v252 = v62;
  uint64_t v250 = v65;
  uint64_t v66 = *(mlir::MLIRContext **)(v227 + 24);
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v225);
  LODWORD(v242) = 0;
  uint64_t v253 = v68;
  uint64_t v236 = 0;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v225);
  uint64_t v70 = (void *)mlir::anec::getIndexFromDim(4, v69);
  if (!v71) {
    goto LABEL_203;
  }
  uint64_t v236 = v70;
  uint64_t v72 = *(void *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v225) + 8 * v70);
  if (v72 == 5)
  {
    uint64_t v73 = *(void *)(v227 + 24);
    LODWORD(v242) = 4;
    LODWORD(v239) = 1;
    int v74 = (char *)mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value &,unsigned long long &,int,int>((mlir::Builder *)(a4 + 8), v73, &v224, (uint64_t *)&v236, (int *)&v242, (int *)&v239)- 16;
    uint64_t v75 = *(void *)(v227 + 24);
    LODWORD(v242) = 0;
    LODWORD(v239) = 4;
    uint64_t v224 = (uint64_t)mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value &,unsigned long long &,int,int>((mlir::Builder *)(a4 + 8), v75, &v224, (uint64_t *)&v236, (int *)&v242, (int *)&v239)- 16;
  }
  else
  {
    int v74 = 0;
  }
  if (!(_BYTE)v250 || !(_BYTE)v253) {
LABEL_203:
  }
    std::__throw_bad_optional_access[abi:nn180100]();
  uint64_t v76 = mlir::OpBuilder::create<mlir::anec::GOC,mlir::Value &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>((uint64_t *)(a4 + 8), *(void *)(v227 + 24), &v224, &GOCConstant, &v252);
  uint64_t v224 = (uint64_t)v76 - 16;
  if (v72 == 5)
  {
    uint64_t v77 = *(void *)(v227 + 24);
    v239 = (char *)v76 - 16;
    uint64_t v240 = (uint64_t)v74;
    mlir::ValueRange::ValueRange((unint64_t *)&v242, (uint64_t)&v239, 2uLL);
    LOBYTE(v234[0]) = 0;
    uint64_t v224 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Concat,mlir::ValueRange,unsigned long long &,BOOL>((mlir::Builder *)(a4 + 8), v77, (uint64_t *)&v242, (uint64_t *)&v236, (unsigned __int8 *)v234)- 16;
  }
LABEL_62:
  uint64_t v78 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v258, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v78) {
    goto LABEL_71;
  }
  uint64_t v79 = *v78;
  unint64_t v80 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v81 = *(unsigned int *)(v79 + 16);
  if (!v81) {
    goto LABEL_71;
  }
  uint64_t v82 = *(void **)(v79 + 8);
  uint64_t v83 = &v82[2 * v81];
  do
  {
    unint64_t v84 = v81 >> 1;
    char v85 = &v82[2 * (v81 >> 1)];
    unint64_t v87 = *v85;
    unint64_t v86 = v85 + 2;
    v81 += ~(v81 >> 1);
    if (v87 < v80) {
      uint64_t v82 = v86;
    }
    else {
      unint64_t v81 = v84;
    }
  }
  while (v81);
  if (v82 != v83 && *v82 == v80) {
    uint64_t v88 = v82[1];
  }
  else {
LABEL_71:
  }
    uint64_t v88 = 0;
  v222[0] = v78;
  v222[1] = v88;
  long long v90 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v222);
  uint64_t v91 = v89;
  v252 = (mlir::GenericProgramPoint *)v254;
  uint64_t v253 = 0x500000000;
  size_t v92 = 8 * v89;
  if ((unint64_t)(8 * v89) < 0x29)
  {
    unsigned int v93 = 0;
    if (!v89) {
      goto LABEL_77;
    }
    goto LABEL_76;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v252, v254, (8 * v89) >> 3, 8);
  unsigned int v93 = v253;
  if (v91)
  {
LABEL_76:
    memcpy((char *)v252 + 8 * v93, v90, v92);
    unsigned int v93 = v253;
  }
LABEL_77:
  LODWORD(v253) = v93 + (v92 >> 3);
  unint64_t v94 = mlir::anec::getIndexFromDim(4, v256);
  if (!v95) {
    goto LABEL_203;
  }
  uint64_t v96 = v255[v94];
  GOCConstant = (void *)1;
  llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v252, (uint64_t)v252 + 8 * (v96 == 5), (uint64_t *)&GOCConstant);
  char v97 = v252;
  uint64_t v98 = (mlir::AffineMap *)v253;
  uint64_t v99 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v222);
  uint64_t v221 = mlir::MemRefType::get(v97, v98, v99, 0, 0, 0);
  uint64_t v100 = *(void *)(v227 + 24);
  GOCConstant = (void *)mlir::ValueRange::dereference_iterator(&v258, 0);
  uint64_t v220 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), v100, &v221, (uint64_t *)&GOCConstant)- 16;
  if (v96 == 5) {
    goto LABEL_88;
  }
  GOCConstant = v251;
  uint64_t v250 = 0x500000000;
  int v101 = v253;
  if (v253)
  {
    if (v253 < 6)
    {
      uint64_t v103 = v251;
      unsigned int v102 = v253;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&GOCConstant, v251, v253, 8);
      unsigned int v102 = v253;
      if (!v253)
      {
LABEL_85:
        LODWORD(v250) = v101;
        goto LABEL_86;
      }
      uint64_t v103 = GOCConstant;
    }
    memcpy(v103, v252, 8 * v102);
    goto LABEL_85;
  }
LABEL_86:
  uint64_t v104 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v223);
  uint64_t v105 = GOCConstant;
  *(void *)GOCConstant = *v104;
  long long v106 = (mlir::AffineMap *)v250;
  uint64_t v107 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v222);
  long long v242 = (void *)mlir::MemRefType::get(v105, v106, v107, 0, 0, 0);
  uint64_t v220 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Broadcast,mlir::MemRefType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(void *)(v227 + 24), (uint64_t *)&v242, &v220)- 16;
  if (GOCConstant != v251) {
    free(GOCConstant);
  }
LABEL_88:
  GOCConstant = v251;
  uint64_t v250 = 0x400000000;
  v251[8] = 4;
  uint64_t ResizeHeight = mlir::mps::CropResizeOp::getResizeHeight((mlir::mps::CropResizeOp *)&v227);
  unsigned int WindowHeight = mlir::mps::CostVolumeOp::getWindowHeight((mlir::mps::CostVolumeOp *)&v227);
  uint64_t v246 = v248;
  v248[0] = ResizeHeight;
  v248[1] = WindowHeight;
  uint64_t v247 = 0x200000002;
  long long v242 = (void *)2;
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  uint64_t v111 = (void *)mlir::RankedTensorType::get((uint64_t)&v242, 1, IntegerType, 0);
  uint64_t v112 = v111;
  if (!v111) {
    goto LABEL_97;
  }
  uint64_t v113 = *v111;
  unint64_t v114 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v115 = *(unsigned int *)(v113 + 16);
  if (!v115) {
    goto LABEL_97;
  }
  uint64_t v116 = *(void **)(v113 + 8);
  unint64_t v117 = &v116[2 * v115];
  do
  {
    unint64_t v118 = v115 >> 1;
    unint64_t v119 = &v116[2 * (v115 >> 1)];
    unint64_t v121 = *v119;
    unint64_t v120 = v119 + 2;
    v115 += ~(v115 >> 1);
    if (v121 < v114) {
      uint64_t v116 = v120;
    }
    else {
      unint64_t v115 = v118;
    }
  }
  while (v115);
  if (v116 != v117 && *v116 == v114) {
    uint64_t v122 = v116[1];
  }
  else {
LABEL_97:
  }
    uint64_t v122 = 0;
  uint64_t v123 = mlir::DenseElementsAttr::getFromRawBuffer(v112, v122, v246, 8 * v247, 8, 1, 0);
  mlir::NamedAttrList::set((uint64_t)&GOCConstant, (uint64_t)"output_dims", 11, v123);
  long long v242 = v244;
  memset(v244, 0, sizeof(v244));
  uint64_t v245 = 0;
  uint64_t v243 = 0x500000005;
  uint64_t v124 = 0;
  if (mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v227)) {
    uint64_t v124 = 2
  }
         * (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v227) == 1);
  if (mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v227)
    && mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v227) == 2)
  {
    uint64_t v124 = 1;
  }
  v239 = v241;
  v241[0] = v124;
  v241[1] = v124;
  v241[2] = v124;
  v241[3] = v124;
  v241[4] = v124;
  uint64_t v240 = 0x500000005;
  uint64_t v236 = (void *)5;
  uint64_t v125 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  uint64_t v126 = (void *)mlir::RankedTensorType::get((uint64_t)&v236, 1, v125, 0);
  unint64_t v127 = v126;
  if (!v126) {
    goto LABEL_112;
  }
  uint64_t v128 = *v126;
  unint64_t v129 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v130 = *(unsigned int *)(v128 + 16);
  if (!v130) {
    goto LABEL_112;
  }
  __int16 v131 = *(void **)(v128 + 8);
  uint64_t v132 = &v131[2 * v130];
  do
  {
    unint64_t v133 = v130 >> 1;
    uint64_t v134 = &v131[2 * (v130 >> 1)];
    unint64_t v136 = *v134;
    uint64_t v135 = v134 + 2;
    v130 += ~(v130 >> 1);
    if (v136 < v129) {
      __int16 v131 = v135;
    }
    else {
      unint64_t v130 = v133;
    }
  }
  while (v130);
  if (v131 != v132 && *v131 == v129) {
    uint64_t v137 = v131[1];
  }
  else {
LABEL_112:
  }
    uint64_t v137 = 0;
  uint64_t v138 = mlir::DenseElementsAttr::getFromRawBuffer(v127, v137, v242, 8 * v243, 8, 1, 0);
  uint64_t v236 = (void *)5;
  uint64_t v139 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  long long v140 = (void *)mlir::RankedTensorType::get((uint64_t)&v236, 1, v139, 0);
  long long v141 = v140;
  if (!v140) {
    goto LABEL_122;
  }
  uint64_t v142 = *v140;
  unint64_t v143 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v144 = *(unsigned int *)(v142 + 16);
  if (!v144) {
    goto LABEL_122;
  }
  uint64_t v145 = *(void **)(v142 + 8);
  uint64_t v146 = &v145[2 * v144];
  do
  {
    unint64_t v147 = v144 >> 1;
    unint64_t v148 = &v145[2 * (v144 >> 1)];
    unint64_t v150 = *v148;
    unint64_t v149 = v148 + 2;
    v144 += ~(v144 >> 1);
    if (v150 < v143) {
      uint64_t v145 = v149;
    }
    else {
      unint64_t v144 = v147;
    }
  }
  while (v144);
  if (v145 != v146 && *v145 == v143) {
    uint64_t v151 = v145[1];
  }
  else {
LABEL_122:
  }
    uint64_t v151 = 0;
  uint64_t v152 = mlir::DenseElementsAttr::getFromRawBuffer(v141, v151, v239, 8 * v240, 8, 1, 0);
  mlir::NamedAttrList::set((uint64_t)&GOCConstant, (uint64_t)"normalized_range", 16, v138);
  mlir::NamedAttrList::set((uint64_t)&GOCConstant, (uint64_t)"coordinate_mode", 15, v152);
  int GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v227);
  uint64_t v236 = v238;
  v238[0] = GateLayout != 1;
  v238[1] = v238[0];
  v238[2] = v238[0];
  v238[3] = v238[0];
  v238[4] = v238[0];
  uint64_t v237 = 0x500000005;
  v234[0] = (void *)5;
  uint64_t v154 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  unint64_t v155 = (void *)mlir::RankedTensorType::get((uint64_t)v234, 1, v154, 0);
  unint64_t v156 = v155;
  if (!v155) {
    goto LABEL_132;
  }
  uint64_t v157 = *v155;
  unint64_t v158 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v159 = *(unsigned int *)(v157 + 16);
  if (!v159) {
    goto LABEL_132;
  }
  uint64_t v160 = *(void **)(v157 + 8);
  unint64_t v161 = &v160[2 * v159];
  do
  {
    unint64_t v162 = v159 >> 1;
    unint64_t v163 = &v160[2 * (v159 >> 1)];
    unint64_t v165 = *v163;
    v164 = v163 + 2;
    v159 += ~(v159 >> 1);
    if (v165 < v158) {
      uint64_t v160 = v164;
    }
    else {
      unint64_t v159 = v162;
    }
  }
  while (v159);
  if (v160 != v161 && *v160 == v158) {
    uint64_t v166 = v160[1];
  }
  else {
LABEL_132:
  }
    uint64_t v166 = 0;
  uint64_t v167 = mlir::DenseElementsAttr::getFromRawBuffer(v156, v166, v236, 8 * v237, 8, 1, 0);
  mlir::NamedAttrList::set((uint64_t)&GOCConstant, (uint64_t)"sampling_method", 15, v167);
  uint64_t v168 = qword_181110C98[(int)mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v227)];
  v234[0] = v235;
  v235[0] = v168;
  v235[1] = v168;
  v235[2] = v168;
  v235[3] = v168;
  v235[4] = v168;
  v234[1] = (void *)0x500000005;
  unint64_t v231 = (void *)5;
  uint64_t v169 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  v170 = (void *)mlir::RankedTensorType::get((uint64_t)&v231, 1, v169, 0);
  v171 = v170;
  if (!v170) {
    goto LABEL_142;
  }
  uint64_t v172 = *v170;
  unint64_t v173 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v174 = *(unsigned int *)(v172 + 16);
  if (!v174) {
    goto LABEL_142;
  }
  long long v175 = *(void **)(v172 + 8);
  uint64_t v176 = &v175[2 * v174];
  do
  {
    unint64_t v177 = v174 >> 1;
    uint64_t v178 = &v175[2 * (v174 >> 1)];
    unint64_t v180 = *v178;
    uint64_t v179 = v178 + 2;
    v174 += ~(v174 >> 1);
    if (v180 < v173) {
      long long v175 = v179;
    }
    else {
      unint64_t v174 = v177;
    }
  }
  while (v174);
  if (v175 != v176 && *v175 == v173) {
    uint64_t v181 = v175[1];
  }
  else {
LABEL_142:
  }
    uint64_t v181 = 0;
  uint64_t v182 = mlir::DenseElementsAttr::getFromRawBuffer(v171, v181, v236, 8 * v237, 8, 1, 0);
  mlir::NamedAttrList::set((uint64_t)&GOCConstant, (uint64_t)"sampling_mode", 13, v182);
  unint64_t v231 = v233;
  memset_pattern16(v233, &unk_181110B90, 0x28uLL);
  uint64_t v232 = 0x500000005;
  v230[0] = 5;
  uint64_t v183 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  v184 = (void *)mlir::RankedTensorType::get((uint64_t)v230, 1, v183, 0);
  unint64_t v185 = v184;
  if (!v184) {
    goto LABEL_152;
  }
  uint64_t v186 = *v184;
  unint64_t v187 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v188 = *(unsigned int *)(v186 + 16);
  if (!v188) {
    goto LABEL_152;
  }
  unint64_t v189 = *(void **)(v186 + 8);
  unint64_t v190 = &v189[2 * v188];
  do
  {
    unint64_t v191 = v188 >> 1;
    v192 = &v189[2 * (v188 >> 1)];
    unint64_t v194 = *v192;
    v193 = v192 + 2;
    v188 += ~(v188 >> 1);
    if (v194 < v187) {
      unint64_t v189 = v193;
    }
    else {
      unint64_t v188 = v191;
    }
  }
  while (v188);
  if (v189 != v190 && *v189 == v187) {
    uint64_t v195 = v189[1];
  }
  else {
LABEL_152:
  }
    uint64_t v195 = 0;
  uint64_t v196 = mlir::DenseElementsAttr::getFromRawBuffer(v185, v195, v231, 8 * v232, 8, 1, 0);
  mlir::NamedAttrList::set((uint64_t)&GOCConstant, (uint64_t)"padding_modes", 13, v196);
  F16FloatAttr = mlir::Builder::getF16FloatAttr((mlir::Float16Type **)(a4 + 8), 0.0, v197);
  mlir::NamedAttrList::set((uint64_t)&GOCConstant, (uint64_t)"background_value", 16, (uint64_t)F16FloatAttr);
  v199 = (uint64_t *)(*(void *)(*(void *)(*(void *)(v227 + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v199) {
    goto LABEL_162;
  }
  uint64_t v200 = *v199;
  unint64_t v201 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v202 = *(unsigned int *)(v200 + 16);
  if (!v202) {
    goto LABEL_162;
  }
  uint64_t v203 = *(void **)(v200 + 8);
  v204 = &v203[2 * v202];
  do
  {
    unint64_t v205 = v202 >> 1;
    v206 = &v203[2 * (v202 >> 1)];
    unint64_t v208 = *v206;
    uint64_t v207 = v206 + 2;
    v202 += ~(v202 >> 1);
    if (v208 < v201) {
      uint64_t v203 = v207;
    }
    else {
      unint64_t v202 = v205;
    }
  }
  while (v202);
  if (v203 != v204 && *v203 == v201) {
    uint64_t v209 = v203[1];
  }
  else {
LABEL_162:
  }
    uint64_t v209 = 0;
  v230[0] = v199;
  v230[1] = v209;
  uint64_t v210 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v230) + 8);
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(v227 + 24));
  switch(mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v227))
  {
    case 1u:
      if (v210 == 5) {
        uint64_t v212 = 1;
      }
      else {
        uint64_t v212 = 9;
      }
      break;
    case 2u:
      BOOL v213 = v210 == 5;
      uint64_t v214 = 10;
      uint64_t v215 = 2;
      goto LABEL_170;
    case 3u:
      BOOL v213 = v210 == 5;
      uint64_t v214 = 11;
      uint64_t v215 = 3;
LABEL_170:
      if (v213) {
        uint64_t v212 = v215;
      }
      else {
        uint64_t v212 = v214;
      }
      break;
    default:
      uint64_t v212 = 8 * (v210 != 5);
      break;
  }
  uint64_t v216 = mlir::anec::BoxCoordinateModeAttr::get(Context, v212);
  mlir::NamedAttrList::set((uint64_t)&GOCConstant, (uint64_t)"box_coordinate_mode", 19, v216);
  uint64_t v217 = v227;
  v228[0] = v220;
  v228[1] = v224;
  mlir::ValueRange::ValueRange((unint64_t *)v229, (uint64_t)v228, 2uLL);
  v218 = mlir::OpBuilder::create<mlir::anec::CropResize,mlir::ValueRange,mlir::NamedAttrList &>((mlir::UnknownLoc **)(a4 + 8), *(void *)(v217 + 24), v229, (uint64_t)&GOCConstant);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v217, v218);
  if (v231 != v233) {
    free(v231);
  }
  if (v234[0] != v235) {
    free(v234[0]);
  }
  if (v236 != v238) {
    free(v236);
  }
  if (v239 != v241) {
    free(v239);
  }
  if (v242 != v244) {
    free(v242);
  }
  if (v246 != v248) {
    free(v246);
  }
  if (GOCConstant != v251) {
    free(GOCConstant);
  }
  if (v252 != (mlir::GenericProgramPoint *)v254) {
    free(v252);
  }
  if (v255 != (void *)v257) {
    free(v255);
  }
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CropResizeOp &>(mlir::mps::CropResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.reshape", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"anec.reshape";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Broadcast::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  unint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Reshape,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value &,unsigned long long &,int,int>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, int *a5, int *a6)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.input_view", (const unsigned __int8 *)0xF, Context);
  if (!v14)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.input_view";
    void v21[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::anec::InputView::build(a1, (uint64_t)v23, *a3, *a4, *a5, *a6);
  uint64_t v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::InputView,void>::id) {
    __int16 v16 = v15;
  }
  else {
    __int16 v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::GOC,mlir::Value &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>(uint64_t *a1, uint64_t a2, uint64_t *a3, void *a4, void *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.gain_offset_control", (const unsigned __int8 *)0x18, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"anec.gain_offset_control";
    v19[3] = 24;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::anec::GOC::build(a1, (uint64_t)v21, *a3, *a4 - 16, *a5 - 16);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id) {
    char v14 = v13;
  }
  else {
    char v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Concat,mlir::ValueRange,unsigned long long &,BOOL>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned __int8 *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.concat", (const unsigned __int8 *)0xB, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"anec.concat";
    v19[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::anec::Concat::build(a1, (uint64_t)v21, *a3, a3[1], *a4, *a5);
  uint64_t v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Concat,void>::id) {
    char v14 = v13;
  }
  else {
    char v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Broadcast,mlir::MemRefType &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.broadcast", (const unsigned __int8 *)0xE, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"anec.broadcast";
    v17[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Broadcast::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Broadcast,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::CropResize,mlir::ValueRange,mlir::NamedAttrList &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.crop_resize", (const unsigned __int8 *)0x10, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.crop_resize";
    void v21[3] = 16;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  uint64_t v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::CropResize::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  uint64_t v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::CropResize,void>::id) {
    __int16 v16 = v15;
  }
  else {
    __int16 v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertDepthwiseConv3D::~ConvertDepthwiseConv3D(mlir::_anonymous_namespace_::ConvertDepthwiseConv3D *this)
{
  unint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  unint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DepthwiseConv3DOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::DepthwiseConv3DOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::DepthwiseConv3DOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DepthwiseConv3DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::DepthwiseConv3DOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::DepthwiseConv3DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 80);
  uint64_t v9 = *(void *)(a3 + 88);
  unint64_t v36 = v8;
  uint64_t v37 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        unint64_t v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v37 = v23;
        if (v36)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v36);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v33[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v34 = 259;
      v31[0] = v33;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DepthwiseConv3DOp &>(mlir::mps::DepthwiseConv3DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v31);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 48);
        v35[2] = *(_OWORD *)(a3 + 32);
        v35[3] = v28;
        long long v29 = *(_OWORD *)(a3 + 80);
        v35[4] = *(_OWORD *)(a3 + 64);
        v35[5] = v29;
        long long v30 = *(_OWORD *)(a3 + 16);
        v35[0] = *(_OWORD *)a3;
        v35[1] = v30;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v35, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v31[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v31[1] = v13;
    if (v31[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v31)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v31))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v31);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v37;
    if (v36 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v34 = 259;
  unint64_t v32 = v33;
  v33[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DepthwiseConv3DOp &>(mlir::mps::DepthwiseConv3DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v32);
  }
  return result;
}

void mlir::anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, void *a4)
{
  uint64_t v119 = *MEMORY[0x1E4F143B8];
  uint64_t v104 = a2;
  long long v118 = *(_OWORD *)(a3 + 80);
  uint64_t v6 = *((void *)a2 + 3);
  uint64_t v103 = mlir::ValueRange::dereference_iterator(&v118, 0);
  unint64_t v7 = (uint64_t *)mlir::ValueRange::dereference_iterator(&v118, 1);
  unsigned int v102 = v7;
  uint64_t Result = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v104);
  uint64_t v9 = (uint64_t *)(*(void *)(v103 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *v9;
  unint64_t v11 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v12 = *(unsigned int *)(v10 + 16);
  if (!v12) {
    goto LABEL_10;
  }
  uint64_t v13 = *(void **)(v10 + 8);
  unint64_t v14 = &v13[2 * v12];
  do
  {
    unint64_t v15 = v12 >> 1;
    uint64_t v16 = &v13[2 * (v12 >> 1)];
    unint64_t v18 = *v16;
    uint64_t v17 = v16 + 2;
    v12 += ~(v12 >> 1);
    if (v18 < v11) {
      uint64_t v13 = v17;
    }
    else {
      unint64_t v12 = v15;
    }
  }
  while (v12);
  if (v13 != v14 && *v13 == v11) {
    uint64_t v19 = v13[1];
  }
  else {
LABEL_10:
  }
    uint64_t v19 = 0;
  v101[0] = v9;
  v101[1] = v19;
  uint64_t v20 = (uint64_t *)(v7[1] & 0xFFFFFFFFFFFFFFF8);
  if (!v20) {
    goto LABEL_20;
  }
  uint64_t v21 = *v20;
  unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_20;
  }
  uint64_t v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    uint64_t v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    long long v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      uint64_t v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_20:
  }
    uint64_t v30 = 0;
  v100[0] = v20;
  v100[1] = v30;
  if (*(void *)(Result + 8) >= 8uLL) {
    mlir::TypeID::get<mlir::ShapedType>();
  }
  mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v117, *(const mlir::TypeConverter **)(a1 + 96));
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v101);
  if (v31 == 4 && (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v100), v32 == 4))
  {
    uint64_t ChannelAxis = (int)mlir::mps::DepthwiseConv3DDataGradientOp::getChannelAxis((mlir::mps::DepthwiseConv3DDataGradientOp *)&v104);
    __int16 v34 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v104) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v34) {
      goto LABEL_34;
    }
    uint64_t v35 = *v34;
    unint64_t v36 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v37 = *(unsigned int *)(v35 + 16);
    if (!v37) {
      goto LABEL_34;
    }
    uint64_t v38 = *(void **)(v35 + 8);
    uint64_t v39 = &v38[2 * v37];
    do
    {
      unint64_t v40 = v37 >> 1;
      long long v41 = &v38[2 * (v37 >> 1)];
      unint64_t v43 = *v41;
      uint64_t v42 = v41 + 2;
      v37 += ~(v37 >> 1);
      if (v43 < v36) {
        uint64_t v38 = v42;
      }
      else {
        unint64_t v37 = v40;
      }
    }
    while (v37);
    if (v38 != v39 && *v38 == v36) {
      uint64_t v44 = v38[1];
    }
    else {
LABEL_34:
    }
      uint64_t v44 = 0;
    uint64_t Strides = (uint64_t)v34;
    uint64_t v106 = v44;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&Strides);
    if (mlir::getPositiveAxis(ChannelAxis, v45) == 1)
    {
      if (*(void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v100) == 1)
      {
        uint64_t v46 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v100) + 8);
        uint64_t v47 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v101) + 8);
        uint64_t v98 = 0;
        uint64_t v99 = 0;
        unint64_t v114 = &v98;
        uint64_t Strides = (uint64_t)v7;
        uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Strides);
        if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&v114, DefiningOp))
        {
          uint64_t Strides = 3;
          uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
          char v97 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&Strides, 1, IntegerType, 0);
          uint64_t Strides = 6;
          uint64_t v50 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
          uint64_t v96 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&Strides, 1, v50, 0);
          unint64_t v114 = v116;
          uint64_t v115 = 0x300000000;
          uint64_t Strides = mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v104);
          long long v51 = mlir::Attribute::cast<mlir::ElementsAttr>((uint64_t **)&Strides);
          mlir::getIntValues<unsigned long long>((uint64_t)v51, v52, (uint64_t)&v114, 1);
          if (*(void *)v114 == 1)
          {
            uint64_t v53 = mlir::Type::cast<mlir::ShapedType>(&v97);
            uint64_t v95 = mlir::DenseElementsAttr::getFromRawBuffer(v53, v54, v114, 8 * v115, 8, 1, 0);
            uint64_t v111 = v113;
            uint64_t v112 = 0x300000000;
            uint64_t Strides = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v104);
            uint64_t v55 = mlir::Attribute::cast<mlir::ElementsAttr>((uint64_t **)&Strides);
            mlir::getIntValues<unsigned long long>((uint64_t)v55, v56, (uint64_t)&v111, 1);
            uint64_t v57 = mlir::Type::cast<mlir::ShapedType>(&v97);
            uint64_t v94 = mlir::DenseElementsAttr::getFromRawBuffer(v57, v58, v111, 8 * v112, 8, 1, 0);
            uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v100);
            uint64_t v60 = *((void *)v111 + 1) * (*(void *)(ArgAttrsAttr + 16) - 1) + 1;
            uint64_t v61 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v100);
            uint64_t v62 = *((void *)v111 + 2) * (*(void *)(v61 + 24) - 1) + 1;
            unint64_t v92 = 0;
            unint64_t v93 = 0;
            unint64_t v90 = 0;
            unint64_t v91 = 0;
            uint64_t Strides = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v104);
            uint64_t v63 = mlir::Attribute::cast<mlir::ElementsAttr>((uint64_t **)&Strides);
            uint64_t v65 = v64;
            int PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v104);
            uint64_t v67 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v101);
            {
              uint64_t ArgOperands = (uint64_t)mlir::Type::cast<mlir::ShapedType>(&v96);
              uint64_t v88 = v69;
              uint64_t Strides = 0;
              uint64_t v106 = 0;
              unint64_t v107 = v93;
              unint64_t v108 = v92;
              unint64_t v109 = v91;
              unint64_t v110 = v90;
              v86[0] = (uint64_t)&Strides;
              v86[1] = 6;
              uint64_t v89 = mlir::DenseIntElementsAttr::get<unsigned long long>(&ArgOperands, v86);
              v86[0] = 0;
              if (v46 / v47 == 1)
              {
                LODWORD(v85) = 1;
                LOBYTE(v84) = 1;
                uint64_t Strides = 0;
                uint64_t ArgOperands = 0;
                uint64_t v70 = mlir::OpBuilder::create<mlir::anec::Convolution,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingMode &,int,BOOL,decltype(nullptr),decltype(nullptr)>(a4 + 1, v6, &v103, (uint64_t *)&v102, &v95, &v94, &v89, v86, (int *)&v85, (char *)&v84);
              }
              else
              {
                uint64_t v85 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v101) + 8);
                uint64_t ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v98);
                uint64_t v88 = v77;
                uint64_t Strides = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v100) + 8);
                uint64_t v106 = 1;
                unint64_t v107 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v100) + 16);
                unint64_t v108 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v100) + 24);
                uint64_t v78 = (void *)mlir::ShapedType::clone((mlir::MemoryMapperInterface *)&ArgOperands, (uint64_t)&Strides, 4);
                uint64_t ArgOperands = mlir::TypeConverter::convertType((uint64_t)v117, v78);
                uint64_t v79 = v98;
                uint64_t v80 = v99;
                unint64_t v84 = (uint64_t *)v78;
                unint64_t v81 = mlir::Type::cast<mlir::ShapedType>(&v84);
                uint64_t Strides = (uint64_t)mlir::reshapeElementsAttr(v79, v80, (uint64_t)v81, v82);
                uint64_t v106 = v83;
                unsigned int v102 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), v6, &ArgOperands, (void **)&Strides)- 16);
                LOBYTE(v84) = 0;
                uint64_t Strides = 0;
                uint64_t ArgOperands = 0;
                uint64_t v70 = mlir::OpBuilder::create<mlir::anec::Convolution,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingMode &,long long &,BOOL,decltype(nullptr),decltype(nullptr)>(a4 + 1, v6, &v103, (uint64_t *)&v102, &v95, &v94, &v89, v86, &v85, (char *)&v84);
              }
              mlir::ConversionPatternRewriter::replaceOp((mlir::ConversionPatternRewriter *)a4, v104, v70);
            }
            else
            {
            }
            if (v111 != v113) {
              free(v111);
            }
          }
          else
          {
          }
          if (v114 != v116) {
            free(v114);
          }
        }
        else
        {
        }
LABEL_55:
        mlir::TypeConverter::~TypeConverter(v117);
      }
      uint64_t v71 = a4[2];
      if (!v71) {
        goto LABEL_55;
      }
      uint64_t v76 = v104;
      if (!mlir::RewriterBase::Listener::classof(v71)) {
        goto LABEL_55;
      }
      uint64_t v73 = *((void *)v76 + 3);
    }
    else
    {
      uint64_t v71 = a4[2];
      if (!v71) {
        goto LABEL_55;
      }
      uint64_t v75 = v104;
      if (!mlir::RewriterBase::Listener::classof(v71)) {
        goto LABEL_55;
      }
      uint64_t v73 = *((void *)v75 + 3);
    }
  }
  else
  {
    uint64_t v71 = a4[2];
    if (!v71) {
      goto LABEL_55;
    }
    uint64_t v72 = v104;
    if (!mlir::RewriterBase::Listener::classof(v71)) {
      goto LABEL_55;
    }
    uint64_t v73 = *((void *)v72 + 3);
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(void *)v71 + 64))(v71, v73, v74, &Strides);
  goto LABEL_55;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3 || !mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16))) {
    return 0;
  }
  uint64_t v6 = *(void *)(a2 + 24);
  unint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t))(*(void *)v3 + 64);
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3 || !mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16))) {
    return 0;
  }
  uint64_t v6 = *(void *)(a2 + 24);
  unint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t))(*(void *)v3 + 64);
}

uint64_t mlir::anonymous namespace'::getExplicitConv2DPadding(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unint64_t *a10, unint64_t *a11, unint64_t *a12, unint64_t *a13)
{
  v27[8] = *MEMORY[0x1E4F143B8];
  uint64_t v13 = 1;
  switch(a3)
  {
    case 0:
      uint64_t v25 = v27;
      uint64_t v26 = 0x800000000;
      mlir::getIntValues<unsigned long long>(a1, a2, (uint64_t)&v25, 1);
      uint64_t v20 = v25;
      uint64_t v21 = (char *)v25 + 8 * v26;
      if (v25 == v21 - 32)
      {
LABEL_12:
        *a10 = *((void *)v21 - 4);
        *a11 = *((void *)v21 - 3);
        *a12 = *((void *)v21 - 2);
        *a13 = *((void *)v21 - 1);
        uint64_t v13 = 1;
        if (v20 == v27) {
          return v13;
        }
        goto LABEL_16;
      }
      uint64_t v22 = 8 * v26 - 32;
      unint64_t v23 = v25;
      while (!*v23)
      {
        ++v23;
        v22 -= 8;
        if (!v22) {
          goto LABEL_12;
        }
      }
      uint64_t v13 = 0;
      if (v25 != v27) {
LABEL_16:
      }
        free(v20);
      return v13;
    case 1:
      *a10 = 0;
      *a11 = 0;
      *a12 = 0;
      *a13 = 0;
      return v13;
    case 2:
    case 4:
      uint64_t v14 = *(void *)(a4 + 16) % *(void *)(a6 + 8);
      if (!v14) {
        uint64_t v14 = *(void *)(a6 + 8);
      }
      unint64_t v15 = (a8 - v14) & ~((a8 - v14) >> 63);
      uint64_t v16 = *(void *)(a4 + 24) % *(void *)(a6 + 16);
      if (!v16) {
        uint64_t v16 = *(void *)(a6 + 16);
      }
      unint64_t v17 = (a9 - v16) & ~((a9 - v16) >> 63);
      *a10 = v15 >> 1;
      *a11 = v15 - (v15 >> 1);
      *a12 = v17 >> 1;
      *a13 = v17 - (v17 >> 1);
      if (a3 == 4)
      {
        unint64_t v18 = *a10;
        *a10 = *a11;
        *a11 = v18;
        unint64_t v19 = *a12;
        *a12 = *a13;
        *a13 = v19;
      }
      return v13;
    default:
      return v13;
  }
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3 || !mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16))) {
    return 0;
  }
  uint64_t v6 = *(void *)(a2 + 24);
  unint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t))(*(void *)v3 + 64);
}

uint64_t mlir::DenseIntElementsAttr::get<unsigned long long>(void *a1, uint64_t *a2)
{
  uint64_t v2 = a2[1];
  if (v2) {
    uint64_t v3 = *a2;
  }
  else {
    uint64_t v3 = 0;
  }
  return mlir::DenseElementsAttr::getFromRawBuffer(*a1, a1[1], v3, 8 * v2, 8, 1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Convolution,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingMode &,int,BOOL,decltype(nullptr),decltype(nullptr)>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, int *a9, char *a10)
{
  v29[38] = *MEMORY[0x1E4F143B8];
  uint64_t v24 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  uint64_t v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.convolution", (const unsigned __int8 *)0x10, Context);
  if (!v20)
  {
    __int16 v28 = 1283;
    v27[2] = (uint64_t)"anec.convolution";
    void v27[3] = 16;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v29, a2, v19);
  mlir::anec::Convolution::build(a1, (uint64_t)v29, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, 0, 0);
  uint64_t v21 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v29);
  if (*(_UNKNOWN **)(*((void *)v21 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id) {
    uint64_t v22 = v21;
  }
  else {
    uint64_t v22 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  return v22;
}

uint64_t mlir::ShapedType::clone(mlir::MemoryMapperInterface *a1, uint64_t a2, uint64_t a3)
{
  *(void *)&long long v6 = a2;
  *((void *)&v6 + 1) = a3;
  char v7 = 1;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange(a1);
  return mlir::ShapedType::cloneWith((uint64_t *)a1, &v6, OperandRange);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Convolution,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingMode &,long long &,BOOL,decltype(nullptr),decltype(nullptr)>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, char *a10)
{
  v29[38] = *MEMORY[0x1E4F143B8];
  uint64_t v24 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  uint64_t v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.convolution", (const unsigned __int8 *)0x10, Context);
  if (!v20)
  {
    __int16 v28 = 1283;
    v27[2] = (uint64_t)"anec.convolution";
    void v27[3] = 16;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v29, a2, v19);
  mlir::anec::Convolution::build(a1, (uint64_t)v29, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, 0, 0);
  uint64_t v21 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v29);
  if (*(_UNKNOWN **)(*((void *)v21 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id) {
    uint64_t v22 = v21;
  }
  else {
    uint64_t v22 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  return v22;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "CWConv3DOp must have 4D inputs\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "CWConv3DOp must use NCHW data format");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "CWConv3DOp must use (1, C*ChannelMult, H, W) weights format");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "CWConv3DOp must have constant weights");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Conv stride must be 1 for batch axis\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported padding values for Conv2D\n");
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::AddOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::AddOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::AddOpGenericAdaptorBase::AddOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::AddOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::AddOpGenericAdaptorBase::AddOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::AddOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::AddOp &>(mlir::mps::AddOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::AddOp &>(mlir::mps::AddOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  unint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  unint64_t v8 = v27;
  uint64_t v25 = v27;
  uint64_t v26 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    long long v28 = v7;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v6, 8);
    uint64_t v9 = v26;
    unint64_t v8 = v25;
    long long v28 = v7;
  }
  uint64_t v10 = 0;
  unint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v28, v10);
    uint64_t v10 = ++*((void *)&v28 + 1);
  }
  while ((void)v28 != v7 || v10 != v6);
  int v13 = v26;
LABEL_11:
  LODWORD(v26) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v24, (uint64_t)v25, v26);
  long long v28 = v24;
  unint64_t v14 = (char *)mlir::ValueRange::dereference_iterator(&v28, 0);
  uint64_t v15 = (char *)mlir::ValueRange::dereference_iterator(&v28, 1);
  {
    uint64_t v16 = *(mlir::MLIRContext **)(a2 + 24);
    uint64_t v17 = (uint64_t)a4;
    uint64_t v18 = (uint64_t)v14;
    uint64_t v19 = v15;
  }
  else
  {
      goto LABEL_17;
    uint64_t v16 = *(mlir::MLIRContext **)(a2 + 24);
    uint64_t v17 = (uint64_t)a4;
    uint64_t v18 = (uint64_t)v15;
    uint64_t v19 = v14;
  }
  if (GOC)
  {
    uint64_t v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&GOC);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)a2, (uint64_t)&v22, 1);
    goto LABEL_18;
  }
LABEL_17:
  uint64_t v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v25);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
LABEL_18:
  if (v25 != v27) {
    free(v25);
  }
  return 1;
}

void mlir::anonymous namespace'::anonymous namespace'::assembleBroadcastOperands(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 72);
  uint64_t v7 = *(void *)(v6 + 24);
  uint64_t v8 = *(void *)(v6 + 56);
  uint64_t v9 = **(void **)a3;
  uint64_t v10 = *(void *)(*(void *)a3 + 8);
  {
    uint64_t v13 = v12;
  }
  else
  {
      return;
    uint64_t BroadcastOperands = v14;
  }
  *(_DWORD *)(a3 + 8) = 0;
  if (*(_DWORD *)(a3 + 12) > 1u)
  {
    uint64_t v15 = 0;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), 2uLL, 8);
    uint64_t v15 = *(unsigned int *)(a3 + 8);
  }
  uint64_t v16 = (uint64_t *)(*(void *)a3 + 8 * v15);
  *uint64_t v16 = BroadcastOperands;
  v16[1] = v13;
  *(_DWORD *)(a3 + 8) += 2;
}

BOOL mlir::anonymous namespace'::anonymous namespace'::isBroadcastWithFullRank(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t *)(*(void *)(a2 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3) {
    goto LABEL_10;
  }
  uint64_t v4 = *v3;
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *(unsigned int *)(v4 + 16);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *(void **)(v4 + 8);
  uint64_t v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    uint64_t v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    unint64_t v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      uint64_t v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_10:
  }
    uint64_t v13 = 0;
  v33[0] = v3;
  v33[1] = v13;
  uint64_t v14 = (uint64_t *)(*(void *)(a1 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v14) {
    goto LABEL_20;
  }
  uint64_t v15 = *v14;
  unint64_t v16 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v17 = *(unsigned int *)(v15 + 16);
  if (!v17) {
    goto LABEL_20;
  }
  uint64_t v18 = *(void **)(v15 + 8);
  uint64_t v19 = &v18[2 * v17];
  do
  {
    unint64_t v20 = v17 >> 1;
    uint64_t v21 = &v18[2 * (v17 >> 1)];
    unint64_t v23 = *v21;
    uint64_t v22 = v21 + 2;
    v17 += ~(v17 >> 1);
    if (v23 < v16) {
      uint64_t v18 = v22;
    }
    else {
      unint64_t v17 = v20;
    }
  }
  while (v17);
  if (v18 != v19 && *v18 == v16) {
    uint64_t v24 = v18[1];
  }
  else {
LABEL_20:
  }
    uint64_t v24 = 0;
  v32[0] = v14;
  v32[1] = v24;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v33);
  uint64_t v26 = v25;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32);
  if (v26 >= v27) {
    return 0;
  }
  uint64_t ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v33);
  if (mlir::ShapedType::getNumElements(ArgAttrsAttr, v29) < 2) {
    return 0;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32);
  return v30 > 3;
}

uint64_t mlir::anonymous namespace'::anonymous namespace'::getBroadcastOperands(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v51[4] = *MEMORY[0x1E4F143B8];
  uint64_t v47 = a4;
  uint64_t v48 = a5;
  uint64_t v10 = (uint64_t *)(*(void *)(a4 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_10;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_10;
  }
  uint64_t v14 = *(void **)(v11 + 8);
  uint64_t v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    unint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    uint64_t v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      uint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_10:
  }
    uint64_t v20 = 0;
  v46[0] = v10;
  v46[1] = v20;
  uint64_t v21 = (uint64_t *)(*(void *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v21) {
    goto LABEL_20;
  }
  uint64_t v22 = *v21;
  unint64_t v23 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v24 = *(unsigned int *)(v22 + 16);
  if (!v24) {
    goto LABEL_20;
  }
  uint64_t v25 = *(void **)(v22 + 8);
  uint64_t v26 = &v25[2 * v24];
  do
  {
    unint64_t v27 = v24 >> 1;
    long long v28 = &v25[2 * (v24 >> 1)];
    unint64_t v30 = *v28;
    uint64_t v29 = v28 + 2;
    v24 += ~(v24 >> 1);
    if (v30 < v23) {
      uint64_t v25 = v29;
    }
    else {
      unint64_t v24 = v27;
    }
  }
  while (v24);
  if (v25 != v26 && *v25 == v23) {
    uint64_t v31 = v25[1];
  }
  else {
LABEL_20:
  }
    uint64_t v31 = 0;
  v45[0] = (uint64_t)v21;
  v45[1] = v31;
  uint64_t ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v45);
  uint64_t v34 = v32;
  unint64_t v49 = v51;
  uint64_t v50 = 0x400000000;
  size_t v35 = 8 * v32;
  if ((unint64_t)(8 * v32) < 0x21)
  {
    unsigned int v36 = 0;
    if (!v32) {
      goto LABEL_26;
    }
    goto LABEL_25;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, (8 * v32) >> 3, 8);
  unsigned int v36 = v50;
  if (v34)
  {
LABEL_25:
    memcpy((char *)v49 + 8 * v36, ArgAttrsAttr, v35);
    unsigned int v36 = v50;
  }
LABEL_26:
  LODWORD(v50) = v36 + (v35 >> 3);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v46);
  uint64_t v37 = (mlir::AffineMap *)v50;
  if (v38 != v50)
  {
    uint64_t v39 = v49;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v46);
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v49, (uint64_t)v39, v40 - v50, 1uLL);
    uint64_t v37 = (mlir::AffineMap *)v50;
  }
  long long v41 = v49;
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(a5);
  v45[0] = mlir::MemRefType::get(v41, v37, ElementTypeOrSelf, 0, 0, 0);
  mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a6 + 8), a1, v45, &v48);
  uint64_t v43 = v47;
  if (v49 != v51) {
    free(v49);
  }
  return v43;
}

uint64_t mlir::anonymous namespace'::anonymous namespace'::isCompatibleWithGOC(uint64_t a1, void *a2)
{
  v46[4] = *MEMORY[0x1E4F143B8];
  __s2 = a2;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&__s2);
  if (!DefiningOp) {
    return 0;
  }
  uint64_t v5 = DefiningOp;
  uint64_t v6 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(void, uint64_t))(**(void **)(v5 + 48) + 32))(*(void *)(v5 + 48), v6)) {
    return 0;
  }
  uint64_t v7 = (uint64_t *)(a2[1] & 0xFFFFFFFFFFFFFFF8);
  if (!v7) {
    goto LABEL_12;
  }
  uint64_t v8 = *v7;
  unint64_t v9 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v10 = *(unsigned int *)(v8 + 16);
  if (!v10) {
    goto LABEL_12;
  }
  uint64_t v11 = *(void **)(v8 + 8);
  unint64_t v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    uint64_t v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    uint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      uint64_t v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_12:
  }
    uint64_t v17 = 0;
  v43[0] = v7;
  v43[1] = v17;
  uint64_t ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v43);
  if (mlir::ShapedType::getNumElements(ArgAttrsAttr, v19) == 1) {
    return 1;
  }
  uint64_t v21 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v43);
  if (v22 < 3) {
    return 0;
  }
  unint64_t v23 = (uint64_t *)v21;
  unint64_t v24 = v22;
  uint64_t v25 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v43);
  if (mlir::ShapedType::getNumElements(v25, v26) != *(uint64_t *)((char *)v23
                                                                + ((uint64_t)((v24 << 32) - 0x300000000) >> 29)))
    return 0;
  unint64_t v27 = (uint64_t *)(*(void *)(a1 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27) {
    goto LABEL_26;
  }
  uint64_t v28 = *v27;
  unint64_t v29 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v30 = *(unsigned int *)(v28 + 16);
  if (!v30) {
    goto LABEL_26;
  }
  uint64_t v31 = *(void **)(v28 + 8);
  uint64_t v32 = &v31[2 * v30];
  do
  {
    unint64_t v33 = v30 >> 1;
    uint64_t v34 = &v31[2 * (v30 >> 1)];
    unint64_t v36 = *v34;
    size_t v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29) {
      uint64_t v31 = v35;
    }
    else {
      unint64_t v30 = v33;
    }
  }
  while (v30);
  if (v31 != v32 && *v31 == v29) {
    uint64_t v37 = v31[1];
  }
  else {
LABEL_26:
  }
    uint64_t v37 = 0;
  __s2 = v27;
  uint64_t v45 = v37;
  uint64_t v38 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__s2);
  unint64_t v40 = v39;
  __s2 = v46;
  uint64_t v45 = 0x400000000;
  if (mlir::OpTrait::util::getBroadcastedShape((uint64_t *)v38, v39, v23, v24, (uint64_t)&__s2))
  {
    long long v41 = __s2;
    BOOL v20 = v40 == v45 && memcmp(v38, __s2, 8 * v45) == 0;
  }
  else
  {
    BOOL v20 = 0;
    long long v41 = __s2;
  }
  if (v41 != v46) {
    free(v41);
  }
  return v20;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,llvm::SmallVector<mlir::Value,2u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.add", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.add";
    v15[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::Ceil::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  unint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id) {
    unint64_t v10 = v9;
  }
  else {
    unint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MultiplyOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::MultiplyOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::MultiplyOpGenericAdaptorBase::MultiplyOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MultiplyOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::MultiplyOpGenericAdaptorBase::MultiplyOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::MultiplyOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  size_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        size_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MultiplyOp &>(mlir::mps::MultiplyOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  unint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MultiplyOp &>(mlir::mps::MultiplyOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  unint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  unint64_t v8 = v27;
  uint64_t v25 = v27;
  uint64_t v26 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    long long v28 = v7;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v6, 8);
    uint64_t v9 = v26;
    unint64_t v8 = v25;
    long long v28 = v7;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v28, v10);
    uint64_t v10 = ++*((void *)&v28 + 1);
  }
  while ((void)v28 != v7 || v10 != v6);
  int v13 = v26;
LABEL_11:
  LODWORD(v26) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v24, (uint64_t)v25, v26);
  long long v28 = v24;
  unint64_t v14 = (char *)mlir::ValueRange::dereference_iterator(&v28, 0);
  uint64_t v15 = (char *)mlir::ValueRange::dereference_iterator(&v28, 1);
  {
    uint64_t v16 = *(mlir::MLIRContext **)(a2 + 24);
    uint64_t v17 = (uint64_t)a4;
    uint64_t v18 = (uint64_t)v14;
    uint64_t v19 = v15;
  }
  else
  {
      goto LABEL_17;
    uint64_t v16 = *(mlir::MLIRContext **)(a2 + 24);
    uint64_t v17 = (uint64_t)a4;
    uint64_t v18 = (uint64_t)v15;
    uint64_t v19 = v14;
  }
  if (GOC)
  {
    uint64_t v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&GOC);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)a2, (uint64_t)&v22, 1);
    goto LABEL_18;
  }
LABEL_17:
  uint64_t v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseMult,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v25);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
LABEL_18:
  if (v25 != v27) {
    free(v25);
  }
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MultiplyOp &>(mlir::mps::MultiplyOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseMult,llvm::SmallVector<mlir::Value,2u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.mult", (const unsigned __int8 *)9, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.mult";
    v15[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::Ceil::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMult,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SubtractOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SubtractOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SubtractOpGenericAdaptorBase::SubtractOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SubtractOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SubtractOpGenericAdaptorBase::SubtractOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SubtractOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  size_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        size_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SubtractOp &>(mlir::mps::SubtractOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  unint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SubtractOp &>(mlir::mps::SubtractOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, mlir::Float16Type **a4)
{
  v37[1] = *MEMORY[0x1E4F143B8];
  unint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  unint64_t v8 = v34;
  __int16 v32 = v34;
  uint64_t v33 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    long long v35 = v7;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v32, v34, v6, 8);
    uint64_t v9 = v33;
    unint64_t v8 = v32;
    long long v35 = v7;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v35, v10);
    uint64_t v10 = ++*((void *)&v35 + 1);
  }
  while ((void)v35 != v7 || v10 != v6);
  int v13 = v33;
LABEL_11:
  LODWORD(v33) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v31, (uint64_t)v32, v33);
  uint64_t v30 = a2;
  long long v35 = v31;
  unint64_t v14 = (char *)mlir::ValueRange::dereference_iterator(&v35, 0);
  uint64_t v15 = (char *)mlir::ValueRange::dereference_iterator(&v35, 1);
  uint64_t v16 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v30);
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v16);
  {
    uint64_t v17 = (unsigned int *)v30;
    if (v28[0])
    {
      v37[0] = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v28);
      uint64_t v18 = v37;
LABEL_14:
      mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, v17, (uint64_t)v18, 1);
      goto LABEL_20;
    }
  }
  else if (mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf))
  {
    {
      v37[0] = 1;
      uint64_t F16Type = mlir::Builder::getF16Type(a4 + 1, v19);
      uint64_t v21 = (void *)mlir::RankedTensorType::get((uint64_t)v37, 1, F16Type, 0);
      v28[0] = mlir::createSplatF16ElementsAttr(v21, -1.0);
      v28[1] = v22;
      uint64_t v23 = *(void *)(v30 + 24);
      uint64_t v36 = 1;
      uint64_t v24 = mlir::Builder::getF16Type(a4 + 1, (mlir::MLIRContext *)v22);
      v37[0] = mlir::MemRefType::get(&v36, (mlir::AffineMap *)1, v24, 0, 0, 0);
      uint64_t v25 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), v23, v37, v28);
      uint64_t v17 = (unsigned int *)v30;
      if (v37[0])
      {
        uint64_t v36 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v37);
        uint64_t v18 = &v36;
        goto LABEL_14;
      }
    }
  }
  uint64_t v26 = mlir::OpBuilder::create<mlir::anec::ElementwiseSub,llvm::SmallVector<mlir::Value,2u> &>((uint64_t *)a4 + 1, *(void *)(a2 + 24), (uint64_t)&v32);
  (*((void (**)(mlir::Float16Type **, uint64_t, mlir::GenericProgramPoint *))*a4 + 4))(a4, a2, v26);
LABEL_20:
  if (v32 != v34) {
    free(v32);
  }
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SubtractOp &>(mlir::mps::SubtractOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseSub,llvm::SmallVector<mlir::Value,2u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.sub", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.sub";
    v15[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::Ceil::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseSub,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MaximumOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::MaximumOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::MaximumOpGenericAdaptorBase::MaximumOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MaximumOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::MaximumOpGenericAdaptorBase::MaximumOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::MaximumOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  long long v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        long long v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MaximumOp &>(mlir::mps::MaximumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MaximumOp &>(mlir::mps::MaximumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  unint64_t v8 = v19;
  uint64_t v17 = v19;
  uint64_t v18 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    uint64_t v9 = v18;
    unint64_t v8 = v17;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    uint64_t v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  int v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  unint64_t v14 = mlir::OpBuilder::create<mlir::anec::ElementwiseMax,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19) {
    free(v17);
  }
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MaximumOp &>(mlir::mps::MaximumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseMax,llvm::SmallVector<mlir::Value,2u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.max", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.max";
    v15[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::Ceil::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMax,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MinimumOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::MinimumOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::MinimumOpGenericAdaptorBase::MinimumOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MinimumOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::MinimumOpGenericAdaptorBase::MinimumOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::MinimumOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  long long v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        long long v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MinimumOp &>(mlir::mps::MinimumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MinimumOp &>(mlir::mps::MinimumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  unint64_t v8 = v19;
  uint64_t v17 = v19;
  uint64_t v18 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    uint64_t v9 = v18;
    unint64_t v8 = v17;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    uint64_t v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  int v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  unint64_t v14 = mlir::OpBuilder::create<mlir::anec::ElementwiseMin,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19) {
    free(v17);
  }
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MinimumOp &>(mlir::mps::MinimumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseMin,llvm::SmallVector<mlir::Value,2u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.min", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.min";
    v15[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::Ceil::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMin,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PowerOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::PowerOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::PowerOpGenericAdaptorBase::PowerOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PowerOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::PowerOpGenericAdaptorBase::PowerOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::PowerOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  long long v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        long long v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PowerOp &>(mlir::mps::PowerOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PowerOp &>(mlir::mps::PowerOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  unint64_t v8 = v19;
  uint64_t v17 = v19;
  uint64_t v18 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    uint64_t v9 = v18;
    unint64_t v8 = v17;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    uint64_t v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  int v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  unint64_t v14 = mlir::OpBuilder::create<mlir::anec::ElementwisePower,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19) {
    free(v17);
  }
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PowerOp &>(mlir::mps::PowerOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwisePower,llvm::SmallVector<mlir::Value,2u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.power", (const unsigned __int8 *)0xA, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.power";
    v15[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::Ceil::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwisePower,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  unint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  char v8 = v27;
  uint64_t v25 = v27;
  uint64_t v26 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    long long v28 = v7;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v6, 8);
    uint64_t v9 = v26;
    char v8 = v25;
    long long v28 = v7;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v28, v10);
    uint64_t v10 = ++*((void *)&v28 + 1);
  }
  while ((void)v28 != v7 || v10 != v6);
  int v13 = v26;
LABEL_11:
  LODWORD(v26) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v24, (uint64_t)v25, v26);
  long long v28 = v24;
  __int16 v14 = (char *)mlir::ValueRange::dereference_iterator(&v28, 0);
  uint64_t v15 = (char *)mlir::ValueRange::dereference_iterator(&v28, 1);
  {
    __int16 v16 = *(mlir::MLIRContext **)(a2 + 24);
    uint64_t v17 = (uint64_t)a4;
    uint64_t v18 = (uint64_t)v14;
    uint64_t v19 = v15;
  }
  else
  {
      goto LABEL_17;
    __int16 v16 = *(mlir::MLIRContext **)(a2 + 24);
    uint64_t v17 = (uint64_t)a4;
    uint64_t v18 = (uint64_t)v15;
    uint64_t v19 = v14;
  }
  if (GOC)
  {
    uint64_t v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&GOC);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)a2, (uint64_t)&v22, 1);
    goto LABEL_18;
  }
LABEL_17:
  uint64_t v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v25);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
LABEL_18:
  if (v25 != v27) {
    free(v25);
  }
  return 1;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  unint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  char v8 = v27;
  uint64_t v25 = v27;
  uint64_t v26 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    long long v28 = v7;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v6, 8);
    uint64_t v9 = v26;
    char v8 = v25;
    long long v28 = v7;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v28, v10);
    uint64_t v10 = ++*((void *)&v28 + 1);
  }
  while ((void)v28 != v7 || v10 != v6);
  int v13 = v26;
LABEL_11:
  LODWORD(v26) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v24, (uint64_t)v25, v26);
  long long v28 = v24;
  __int16 v14 = (char *)mlir::ValueRange::dereference_iterator(&v28, 0);
  uint64_t v15 = (char *)mlir::ValueRange::dereference_iterator(&v28, 1);
  {
    __int16 v16 = *(mlir::MLIRContext **)(a2 + 24);
    uint64_t v17 = (uint64_t)a4;
    uint64_t v18 = (uint64_t)v14;
    uint64_t v19 = v15;
  }
  else
  {
      goto LABEL_17;
    __int16 v16 = *(mlir::MLIRContext **)(a2 + 24);
    uint64_t v17 = (uint64_t)a4;
    uint64_t v18 = (uint64_t)v15;
    uint64_t v19 = v14;
  }
  if (GOC)
  {
    uint64_t v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&GOC);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)a2, (uint64_t)&v22, 1);
    goto LABEL_18;
  }
LABEL_17:
  uint64_t v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseMult,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v25);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
LABEL_18:
  if (v25 != v27) {
    free(v25);
  }
  return 1;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, mlir::Float16Type **a4)
{
  v37[1] = *MEMORY[0x1E4F143B8];
  unint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  char v8 = v34;
  __int16 v32 = v34;
  uint64_t v33 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    long long v35 = v7;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v32, v34, v6, 8);
    uint64_t v9 = v33;
    char v8 = v32;
    long long v35 = v7;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v35, v10);
    uint64_t v10 = ++*((void *)&v35 + 1);
  }
  while ((void)v35 != v7 || v10 != v6);
  int v13 = v33;
LABEL_11:
  LODWORD(v33) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v31, (uint64_t)v32, v33);
  uint64_t v30 = a2;
  long long v35 = v31;
  __int16 v14 = (char *)mlir::ValueRange::dereference_iterator(&v35, 0);
  uint64_t v15 = (char *)mlir::ValueRange::dereference_iterator(&v35, 1);
  uint64_t v16 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v30);
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v16);
  {
    uint64_t v17 = (unsigned int *)v30;
    if (v28[0])
    {
      v37[0] = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v28);
      uint64_t v18 = v37;
LABEL_14:
      mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, v17, (uint64_t)v18, 1);
      goto LABEL_20;
    }
  }
  else if (mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf))
  {
    {
      v37[0] = 1;
      uint64_t F16Type = mlir::Builder::getF16Type(a4 + 1, v19);
      uint64_t v21 = (void *)mlir::RankedTensorType::get((uint64_t)v37, 1, F16Type, 0);
      v28[0] = mlir::createSplatF16ElementsAttr(v21, -1.0);
      v28[1] = v22;
      uint64_t v23 = *(void *)(v30 + 24);
      uint64_t v36 = 1;
      uint64_t v24 = mlir::Builder::getF16Type(a4 + 1, (mlir::MLIRContext *)v22);
      v37[0] = mlir::MemRefType::get(&v36, (mlir::AffineMap *)1, v24, 0, 0, 0);
      uint64_t v25 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), v23, v37, v28);
      uint64_t v17 = (unsigned int *)v30;
      if (v37[0])
      {
        uint64_t v36 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v37);
        uint64_t v18 = &v36;
        goto LABEL_14;
      }
    }
  }
  uint64_t v26 = mlir::OpBuilder::create<mlir::anec::ElementwiseSub,llvm::SmallVector<mlir::Value,2u> &>((uint64_t *)a4 + 1, *(void *)(a2 + 24), (uint64_t)&v32);
  (*((void (**)(mlir::Float16Type **, uint64_t, mlir::GenericProgramPoint *))*a4 + 4))(a4, a2, v26);
LABEL_20:
  if (v32 != v34) {
    free(v32);
  }
  return 1;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  char v8 = v19;
  uint64_t v17 = v19;
  uint64_t v18 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    uint64_t v9 = v18;
    char v8 = v17;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    uint64_t v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  int v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  __int16 v14 = mlir::OpBuilder::create<mlir::anec::ElementwiseMax,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19) {
    free(v17);
  }
  return 1;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  char v8 = v19;
  uint64_t v17 = v19;
  uint64_t v18 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    uint64_t v9 = v18;
    char v8 = v17;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    uint64_t v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  int v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  __int16 v14 = mlir::OpBuilder::create<mlir::anec::ElementwiseMin,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19) {
    free(v17);
  }
  return 1;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  char v8 = v19;
  uint64_t v17 = v19;
  uint64_t v18 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    uint64_t v9 = v18;
    char v8 = v17;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    uint64_t v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  int v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  __int16 v14 = mlir::OpBuilder::create<mlir::anec::ElementwisePower,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19) {
    free(v17);
  }
  return 1;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  unint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  char v8 = v27;
  uint64_t v25 = v27;
  uint64_t v26 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    long long v28 = v7;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v6, 8);
    uint64_t v9 = v26;
    char v8 = v25;
    long long v28 = v7;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v28, v10);
    uint64_t v10 = ++*((void *)&v28 + 1);
  }
  while ((void)v28 != v7 || v10 != v6);
  int v13 = v26;
LABEL_11:
  LODWORD(v26) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v24, (uint64_t)v25, v26);
  long long v28 = v24;
  __int16 v14 = (char *)mlir::ValueRange::dereference_iterator(&v28, 0);
  uint64_t v15 = (char *)mlir::ValueRange::dereference_iterator(&v28, 1);
  {
    unint64_t v16 = *(mlir::MLIRContext **)(a2 + 24);
    uint64_t v17 = (uint64_t)a4;
    uint64_t v18 = (uint64_t)v14;
    uint64_t v19 = v15;
  }
  else
  {
      goto LABEL_17;
    unint64_t v16 = *(mlir::MLIRContext **)(a2 + 24);
    uint64_t v17 = (uint64_t)a4;
    uint64_t v18 = (uint64_t)v15;
    uint64_t v19 = v14;
  }
  if (GOC)
  {
    uint64_t v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&GOC);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)a2, (uint64_t)&v22, 1);
    goto LABEL_18;
  }
LABEL_17:
  uint64_t v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v25);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
LABEL_18:
  if (v25 != v27) {
    free(v25);
  }
  return 1;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  unint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  char v8 = v27;
  uint64_t v25 = v27;
  uint64_t v26 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    long long v28 = v7;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v6, 8);
    uint64_t v9 = v26;
    char v8 = v25;
    long long v28 = v7;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v28, v10);
    uint64_t v10 = ++*((void *)&v28 + 1);
  }
  while ((void)v28 != v7 || v10 != v6);
  int v13 = v26;
LABEL_11:
  LODWORD(v26) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v24, (uint64_t)v25, v26);
  long long v28 = v24;
  __int16 v14 = (char *)mlir::ValueRange::dereference_iterator(&v28, 0);
  uint64_t v15 = (char *)mlir::ValueRange::dereference_iterator(&v28, 1);
  {
    unint64_t v16 = *(mlir::MLIRContext **)(a2 + 24);
    uint64_t v17 = (uint64_t)a4;
    uint64_t v18 = (uint64_t)v14;
    uint64_t v19 = v15;
  }
  else
  {
      goto LABEL_17;
    unint64_t v16 = *(mlir::MLIRContext **)(a2 + 24);
    uint64_t v17 = (uint64_t)a4;
    uint64_t v18 = (uint64_t)v15;
    uint64_t v19 = v14;
  }
  if (GOC)
  {
    uint64_t v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&GOC);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)a2, (uint64_t)&v22, 1);
    goto LABEL_18;
  }
LABEL_17:
  uint64_t v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseMult,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v25);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
LABEL_18:
  if (v25 != v27) {
    free(v25);
  }
  return 1;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, mlir::Float16Type **a4)
{
  v37[1] = *MEMORY[0x1E4F143B8];
  unint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  char v8 = v34;
  __int16 v32 = v34;
  uint64_t v33 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    long long v35 = v7;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v32, v34, v6, 8);
    uint64_t v9 = v33;
    char v8 = v32;
    long long v35 = v7;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v35, v10);
    uint64_t v10 = ++*((void *)&v35 + 1);
  }
  while ((void)v35 != v7 || v10 != v6);
  int v13 = v33;
LABEL_11:
  LODWORD(v33) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v31, (uint64_t)v32, v33);
  uint64_t v30 = a2;
  long long v35 = v31;
  __int16 v14 = (char *)mlir::ValueRange::dereference_iterator(&v35, 0);
  uint64_t v15 = (char *)mlir::ValueRange::dereference_iterator(&v35, 1);
  uint64_t v16 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v30);
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v16);
  {
    uint64_t v17 = (unsigned int *)v30;
    if (v28[0])
    {
      v37[0] = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v28);
      uint64_t v18 = v37;
LABEL_14:
      mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, v17, (uint64_t)v18, 1);
      goto LABEL_20;
    }
  }
  else if (mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf))
  {
    {
      v37[0] = 1;
      uint64_t F16Type = mlir::Builder::getF16Type(a4 + 1, v19);
      uint64_t v21 = (void *)mlir::RankedTensorType::get((uint64_t)v37, 1, F16Type, 0);
      v28[0] = mlir::createSplatF16ElementsAttr(v21, -1.0);
      v28[1] = v22;
      uint64_t v23 = *(void *)(v30 + 24);
      uint64_t v36 = 1;
      uint64_t v24 = mlir::Builder::getF16Type(a4 + 1, (mlir::MLIRContext *)v22);
      v37[0] = mlir::MemRefType::get(&v36, (mlir::AffineMap *)1, v24, 0, 0, 0);
      uint64_t v25 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), v23, v37, v28);
      uint64_t v17 = (unsigned int *)v30;
      if (v37[0])
      {
        uint64_t v36 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v37);
        uint64_t v18 = &v36;
        goto LABEL_14;
      }
    }
  }
  uint64_t v26 = mlir::OpBuilder::create<mlir::anec::ElementwiseSub,llvm::SmallVector<mlir::Value,2u> &>((uint64_t *)a4 + 1, *(void *)(a2 + 24), (uint64_t)&v32);
  (*((void (**)(mlir::Float16Type **, uint64_t, mlir::GenericProgramPoint *))*a4 + 4))(a4, a2, v26);
LABEL_20:
  if (v32 != v34) {
    free(v32);
  }
  return 1;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  char v8 = v19;
  uint64_t v17 = v19;
  uint64_t v18 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    uint64_t v9 = v18;
    char v8 = v17;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    uint64_t v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  int v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  __int16 v14 = mlir::OpBuilder::create<mlir::anec::ElementwiseMax,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19) {
    free(v17);
  }
  return 1;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  char v8 = v19;
  uint64_t v17 = v19;
  uint64_t v18 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    uint64_t v9 = v18;
    char v8 = v17;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    uint64_t v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  int v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  __int16 v14 = mlir::OpBuilder::create<mlir::anec::ElementwiseMin,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19) {
    free(v17);
  }
  return 1;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  char v8 = v19;
  uint64_t v17 = v19;
  uint64_t v18 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    uint64_t v9 = v18;
    char v8 = v17;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    uint64_t v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  int v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  __int16 v14 = mlir::OpBuilder::create<mlir::anec::ElementwisePower,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19) {
    free(v17);
  }
  return 1;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::AbsoluteOp,mlir::anec::ElementwiseAbs>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9A86B0;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        uint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        unint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_18080FA20()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::AbsoluteOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::AbsoluteOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::AbsoluteOpGenericAdaptorBase::AbsoluteOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::AbsoluteOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::AbsoluteOpGenericAdaptorBase::AbsoluteOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::AbsoluteOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  long long v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        long long v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::AbsoluteOp &>(mlir::mps::AbsoluteOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::AbsoluteOp &>(mlir::mps::AbsoluteOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::AbsoluteOp,mlir::anec::ElementwiseAbs>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5 = a1;
  v70[9] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          uint64_t v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          uint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    uint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    unint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      uint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        uint64_t v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      }
      else {
        uint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  long long v51 = mlir::OpBuilder::create<mlir::anec::ElementwiseAbs,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::DenseMap<std::pair<unsigned int,std::string> const*>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  unint64_t v6 = (unint64_t)(*a3 - *a2) >> 5;
  if (!v6)
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 16) = 0;
    goto LABEL_12;
  }
  unint64_t v7 = (4 * (int)v6 / 3u + 1) | ((unint64_t)(4 * (int)v6 / 3u + 1) >> 1);
  unint64_t v8 = v7 | (v7 >> 2) | ((v7 | (v7 >> 2)) >> 4);
  LODWORD(v8) = (((v8 | (v8 >> 8)) >> 16) | v8 | (v8 >> 8)) + 1;
  *(_DWORD *)(a1 + 16) = v8;
  buffer = llvm::allocate_buffer(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = buffer;
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (!v10) {
    goto LABEL_12;
  }
  uint64_t v11 = (v10 - 1) & 0x7FFFFFFFFFFFFFFLL;
  if (!v11)
  {
    unsigned int v14 = buffer;
LABEL_10:
    uint64_t v17 = &buffer[8 * v10];
    do
    {
      *unsigned int v14 = -1;
      v14 += 8;
    }
    while (v14 != v17);
    goto LABEL_12;
  }
  uint64_t v12 = v11 + 1;
  uint64_t v13 = (v11 + 1) & 0xFFFFFFFFFFFFFFELL;
  unsigned int v14 = &buffer[8 * v13];
  uint64_t v15 = buffer + 8;
  uint64_t v16 = v13;
  do
  {
    *(v15 - 8) = -1;
    *uint64_t v15 = -1;
    v15 += 16;
    v16 -= 2;
  }
  while (v16);
  if (v12 != v13) {
    goto LABEL_10;
  }
LABEL_12:
  uint64_t v18 = *a2;
  uint64_t v19 = *a3;
  if (v18 != v19)
  {
    while (1)
    {
      int v24 = *(_DWORD *)(a1 + 16);
      if (!v24) {
        break;
      }
      unsigned int v20 = v24 - 1;
      uint64_t v21 = (37 * *(_DWORD *)v18) & v20;
      char v22 = (_DWORD *)(*(void *)a1 + 32 * v21);
      int v23 = *v22;
      if (*(_DWORD *)v18 != *v22)
      {
        uint64_t v26 = 0;
        int v27 = 1;
        while (v23 != -1)
        {
          if (v26) {
            BOOL v28 = 0;
          }
          else {
            BOOL v28 = v23 == -2;
          }
          if (v28) {
            uint64_t v26 = v22;
          }
          int v29 = v21 + v27++;
          uint64_t v21 = v29 & v20;
          char v22 = (_DWORD *)(*(void *)a1 + 32 * v21);
          int v23 = *v22;
          if (*(_DWORD *)v18 == *v22) {
            goto LABEL_15;
          }
        }
        if (v26) {
          uint64_t v25 = (uint64_t)v26;
        }
        else {
          uint64_t v25 = (uint64_t)v22;
        }
        goto LABEL_18;
      }
LABEL_15:
      v18 += 32;
      if (v18 == v19) {
        return a1;
      }
    }
    uint64_t v25 = 0;
LABEL_18:
    llvm::DenseMapBase<llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>,unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::InsertIntoBucket<unsigned int const&,std::string const&>(a1, v25, (_DWORD *)v18, (long long *)(v18 + 8));
    goto LABEL_15;
  }
  return a1;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>,unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::InsertIntoBucket<unsigned int const&,std::string const&>(uint64_t a1, uint64_t a2, _DWORD *a3, long long *a4)
{
  int v8 = *(_DWORD *)(a1 + 8);
  unsigned int v9 = *(_DWORD *)(a1 + 16);
  if (4 * v8 + 4 >= 3 * v9)
  {
    v9 *= 2;
  }
  else if (v9 + ~v8 - *(_DWORD *)(a1 + 12) > v9 >> 3)
  {
    goto LABEL_3;
  }
  llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::grow(a1, v9);
  int v13 = *(_DWORD *)(a1 + 16);
  if (v13)
  {
    unsigned int v14 = v13 - 1;
    uint64_t v15 = (37 * *a3) & v14;
    a2 = *(void *)a1 + 32 * v15;
    int v16 = *(_DWORD *)a2;
    if (*a3 != *(_DWORD *)a2)
    {
      uint64_t v17 = 0;
      int v18 = 1;
      while (v16 != -1)
      {
        if (v17) {
          BOOL v19 = 0;
        }
        else {
          BOOL v19 = v16 == -2;
        }
        if (v19) {
          uint64_t v17 = a2;
        }
        int v20 = v15 + v18++;
        uint64_t v15 = v20 & v14;
        a2 = *(void *)a1 + 32 * v15;
        int v16 = *(_DWORD *)a2;
        if (*a3 == *(_DWORD *)a2) {
          goto LABEL_3;
        }
      }
      if (v17) {
        a2 = v17;
      }
    }
  }
  else
  {
    a2 = 0;
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*(_DWORD *)a2 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  *(_DWORD *)a2 = *a3;
  uint64_t v10 = (std::string *)(a2 + 8);
  if (*((char *)a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v10, *(const std::string::value_type **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v11 = *a4;
    *(void *)(a2 + 24) = *((void *)a4 + 2);
    *(_OWORD *)&v10->__r_.__value_.__l.__data_ = v11;
  }
  return a2;
}

_DWORD *llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = llvm::allocate_buffer(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    uint64_t v10 = (char *)(32 * v3);
    llvm::DenseMapBase<llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>,unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::moveFromOldBuckets(a1, v4, (int *)&v10[(void)v4]);
    llvm::deallocate_buffer((llvm *)v4, v10);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v11 = *(unsigned int *)(a1 + 16);
  if (v11)
  {
    uint64_t v12 = (v11 - 1) & 0x7FFFFFFFFFFFFFFLL;
    if (v12)
    {
      uint64_t v13 = v12 + 1;
      uint64_t v14 = (v12 + 1) & 0xFFFFFFFFFFFFFFELL;
      uint64_t v15 = &result[8 * v14];
      int v16 = result + 8;
      uint64_t v17 = v14;
      do
      {
        *(v16 - 8) = -1;
        *int v16 = -1;
        v16 += 16;
        v17 -= 2;
      }
      while (v17);
      if (v13 == v14) {
        return result;
      }
    }
    else
    {
      uint64_t v15 = result;
    }
    int v18 = &result[8 * v11];
    do
    {
      *uint64_t v15 = -1;
      v15 += 8;
    }
    while (v15 != v18);
  }
  return result;
}

void llvm::DenseMapBase<llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>,unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::moveFromOldBuckets(uint64_t a1, int *a2, int *a3)
{
  uint64_t v4 = a2;
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(_DWORD **)a1;
    uint64_t v8 = (v6 - 1) & 0x7FFFFFFFFFFFFFFLL;
    if (v8)
    {
      uint64_t v9 = v8 + 1;
      uint64_t v10 = (v8 + 1) & 0xFFFFFFFFFFFFFFELL;
      uint64_t v11 = &v7[8 * v10];
      uint64_t v12 = v7 + 8;
      uint64_t v13 = v10;
      do
      {
        *(v12 - 8) = -1;
        *uint64_t v12 = -1;
        v12 += 16;
        v13 -= 2;
      }
      while (v13);
      if (v9 == v10) {
        goto LABEL_10;
      }
    }
    else
    {
      uint64_t v11 = *(_DWORD **)a1;
    }
    uint64_t v14 = &v7[8 * v6];
    do
    {
      _DWORD *v11 = -1;
      v11 += 8;
    }
    while (v11 != v14);
  }
LABEL_10:
  if (a2 != a3)
  {
    do
    {
      int v15 = *v4;
      if (*v4 <= 0xFFFFFFFD)
      {
        int v16 = *(_DWORD *)(a1 + 16);
        if (v16)
        {
          unsigned int v17 = v16 - 1;
          uint64_t v18 = (v16 - 1) & (37 * v15);
          uint64_t v19 = *(void *)a1 + 32 * v18;
          int v20 = *(_DWORD *)v19;
          if (v15 != *(_DWORD *)v19)
          {
            uint64_t v21 = 0;
            int v22 = 1;
            while (v20 != -1)
            {
              if (v21) {
                BOOL v23 = 0;
              }
              else {
                BOOL v23 = v20 == -2;
              }
              if (v23) {
                uint64_t v21 = v19;
              }
              int v24 = v18 + v22++;
              uint64_t v18 = v24 & v17;
              uint64_t v19 = *(void *)a1 + 32 * v18;
              int v20 = *(_DWORD *)v19;
              if (v15 == *(_DWORD *)v19) {
                goto LABEL_26;
              }
            }
            if (v21) {
              uint64_t v19 = v21;
            }
          }
        }
        else
        {
          uint64_t v19 = 0;
        }
LABEL_26:
        *(_DWORD *)uint64_t v19 = v15;
        long long v25 = *(_OWORD *)(v4 + 2);
        *(void *)(v19 + 24) = *((void *)v4 + 3);
        *(_OWORD *)(v19 + 8) = v25;
        *((void *)v4 + 2) = 0;
        *((void *)v4 + 3) = 0;
        *((void *)v4 + 1) = 0;
        ++*(_DWORD *)(a1 + 8);
        if (*((char *)v4 + 31) < 0) {
          operator delete(*((void **)v4 + 1));
        }
      }
      v4 += 8;
    }
    while (v4 != a3);
  }
}

void llvm::SmallVectorImpl<std::pair<llvm::APFloat,std::string>>::append<std::pair<llvm::APFloat,std::string> const*,void>(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = a1;
  uint64_t v6 = 0x6DB6DB6DB6DB6DB7 * ((a3 - a2) >> 3);
  uint64_t v7 = a1[2];
  if (v6 + v7 > (unint64_t)a1[3])
  {
    unint64_t v19 = 0;
    uint64_t v8 = a1 + 4;
    uint64_t v9 = llvm::SmallVectorBase<unsigned int>::mallocForGrow((uint64_t)a1, a1 + 4, v6 + v7, 56, &v19);
    llvm::SmallVectorTemplateBase<std::pair<llvm::APFloat,std::string>,false>::moveElementsForGrow(v5, (uint64_t)v9);
    unsigned int v10 = v19;
    a1 = *(unsigned int **)v5;
    if (*(unsigned int **)v5 != v8) {
      free(a1);
    }
    *(void *)unint64_t v5 = v9;
    v5[3] = v10;
    LODWORD(v7) = v5[2];
  }
  if (a2 != a3)
  {
    uint64_t v11 = *(void *)v5 + 56 * v7;
    uint64_t v12 = llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1);
    uint64_t v13 = 0;
    do
    {
      uint64_t v14 = (llvm::detail::DoubleAPFloat *)(v11 + v13 + 8);
      int v15 = (const llvm::detail::DoubleAPFloat *)(a2 + v13 + 8);
      if (v12 == *(void **)v15) {
        llvm::detail::DoubleAPFloat::DoubleAPFloat(v14, v15);
      }
      else {
        llvm::detail::IEEEFloat::IEEEFloat(v14, v15);
      }
      int v16 = (std::string *)(v11 + v13 + 32);
      unsigned int v17 = (const std::string::value_type **)(a2 + v13 + 32);
      if (*(char *)(a2 + v13 + 55) < 0)
      {
        std::string::__init_copy_ctor_external(v16, *v17, *(void *)(a2 + v13 + 40));
      }
      else
      {
        long long v18 = *(_OWORD *)v17;
        *(void *)(v11 + v13 + 48) = *(void *)(a2 + v13 + 48);
        *(_OWORD *)&v16->__r_.__value_.__l.__data_ = v18;
      }
      v13 += 56;
    }
    while (a2 + v13 != a3);
    LODWORD(v7) = v5[2];
  }
  v5[2] = v7 + v6;
}

void llvm::SmallVectorTemplateBase<std::pair<llvm::APFloat,std::string>,false>::moveElementsForGrow(unsigned int *a1, uint64_t a2)
{
  uint64_t v2 = a1[2];
  if (v2)
  {
    uint64_t v5 = *(void *)a1;
    uint64_t v6 = llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1);
    uint64_t v7 = a2 + 32;
    uint64_t v8 = 56 * v2;
    uint64_t v9 = (long long *)(v5 + 32);
    do
    {
      uint64_t v11 = (void *)(v7 - 24);
      uint64_t v12 = (void *)v9 - 3;
      if (v6 == *((void **)v9 - 3)) {
        llvm::detail::DoubleAPFloat::DoubleAPFloat(v11, v12);
      }
      else {
        llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v11, (uint64_t)v12);
      }
      long long v10 = *v9;
      *(void *)(v7 + 16) = *((void *)v9 + 2);
      *(_OWORD *)uint64_t v7 = v10;
      v7 += 56;
      *((void *)v9 + 1) = 0;
      *((void *)v9 + 2) = 0;
      *(void *)uint64_t v9 = 0;
      uint64_t v9 = (long long *)((char *)v9 + 56);
      v8 -= 56;
    }
    while (v8);
    uint64_t v13 = a1[2];
    if (v13)
    {
      uint64_t v14 = *(void *)a1;
      uint64_t v15 = 56 * v13;
      do
      {
        while (1)
        {
          uint64_t v16 = v14 + v15;
          if (*(char *)(v14 + v15 - 1) < 0) {
            operator delete(*(void **)(v16 - 24));
          }
          unsigned int v17 = (llvm::detail::DoubleAPFloat *)(v16 - 48);
          if (v6 != *(void **)(v16 - 48)) {
            break;
          }
          llvm::detail::DoubleAPFloat::~DoubleAPFloat(v17);
          v15 -= 56;
          if (!v15) {
            return;
          }
        }
        llvm::detail::IEEEFloat::~IEEEFloat(v17);
        v15 -= 56;
      }
      while (v15);
    }
  }
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::AbsoluteOp &>(mlir::mps::AbsoluteOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::AbsoluteOp,mlir::anec::ElementwiseAbs>::matchAndRewriteWithStaticShapes(mlir::mps::AbsoluteOp,mlir::mps::AbsoluteOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      uint64_t v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseAbs,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.abs", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.abs";
    void v21[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAbs,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertExponent::~ConvertExponent(mlir::_anonymous_namespace_::ConvertExponent *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExponentOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExponentOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ExponentOpGenericAdaptorBase::ExponentOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExponentOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ExponentOpGenericAdaptorBase::ExponentOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ExponentOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExponentOp &>(mlir::mps::ExponentOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExponentOp &>(mlir::mps::ExponentOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertExponent::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::Float16Type **a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  long long v36 = *(_OWORD *)(a3 + 40);
  uint64_t v35 = mlir::ValueRange::dereference_iterator(&v36, 0);
  uint64_t v6 = (uint64_t *)(*(void *)(v35 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v34[0] = v6;
  v34[1] = v16;
  uint64_t v17 = *((void *)a2 + 3);
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v34);
  uint64_t v20 = v19;
  uint64_t F16Type = mlir::Builder::getF16Type(a4 + 1, v19);
  uint64_t v33 = mlir::MemRefType::get(ArgAttrsAttr, v20, F16Type, 0, 0, 0);
  uint64_t v22 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v34);
  uint64_t v24 = (uint64_t)v23;
  uint64_t v25 = mlir::Builder::getF16Type(a4 + 1, v23);
  uint64_t v26 = (void *)mlir::RankedTensorType::get(v22, v24, v25, 0);
  v32[0] = mlir::createSplatF16ElementsAttr(v26, 1.4427);
  v32[1] = v27;
  long long v31 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), v17, &v33, v32);
  uint64_t v30 = mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value &,mlir::mps::ConstantOp &>((uint64_t *)a4 + 1, v17, &v35, &v31);
  long long v28 = mlir::OpBuilder::create<mlir::anec::Exp2,mlir::anec::ElementwiseMult &>((uint64_t *)a4 + 1, v17, &v30);
  mlir::ConversionPatternRewriter::replaceOp((mlir::ConversionPatternRewriter *)a4, a2, v28);
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExponentOp &>(mlir::mps::ExponentOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value &,mlir::mps::ConstantOp &>(uint64_t *a1, uint64_t a2, uint64_t *a3, void *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.mult", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.mult";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ElementwiseAdd::build(a1, (uint64_t)v19, *a3, *a4 - 16);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMult,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Exp2,mlir::anec::ElementwiseMult &>(uint64_t *a1, uint64_t a2, void *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.exp2", (const unsigned __int8 *)9, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.exp2";
    v15[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::ElementwiseEqualZero::build(a1, (uint64_t)v17, *a3 - 16);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Exp2,void>::id) {
    char v10 = v9;
  }
  else {
    char v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

void mlir::anonymous namespace'::ConvertLogarithm::~ConvertLogarithm(mlir::_anonymous_namespace_::ConvertLogarithm *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::LogarithmOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::LogarithmOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::LogarithmOpGenericAdaptorBase::LogarithmOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::LogarithmOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::LogarithmOpGenericAdaptorBase::LogarithmOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::LogarithmOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LogarithmOp &>(mlir::mps::LogarithmOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LogarithmOp &>(mlir::mps::LogarithmOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertLogarithm::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, unint64_t *a3, mlir::Float16Type **a4)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  long long v40 = *(_OWORD *)(a3 + 5);
  uint64_t v7 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v40, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v7) {
    goto LABEL_10;
  }
  uint64_t v8 = *v7;
  unint64_t v9 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v10 = *(unsigned int *)(v8 + 16);
  if (!v10) {
    goto LABEL_10;
  }
  uint64_t v11 = *(void **)(v8 + 8);
  uint64_t v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    unint64_t v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    uint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      uint64_t v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_10:
  }
    uint64_t v17 = 0;
  v39[0] = v7;
  v39[1] = v17;
  uint64_t v18 = *(void *)(a2 + 24);
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v39);
  uint64_t v21 = v20;
  uint64_t F16Type = mlir::Builder::getF16Type(a4 + 1, v20);
  uint64_t v38 = mlir::MemRefType::get(ArgAttrsAttr, v21, F16Type, 0, 0, 0);
  uint64_t v23 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v39);
  uint64_t v25 = (uint64_t)v24;
  uint64_t v26 = mlir::Builder::getF16Type(a4 + 1, v24);
  uint64_t v27 = (void *)mlir::RankedTensorType::get(v23, v25, v26, 0);
  v37[0] = mlir::createSplatF16ElementsAttr(v27, 0.69315);
  v37[1] = v28;
  uint64_t v36 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), v18, &v38, v37);
  unsigned int ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 0);
  unint64_t v30 = a3[5];
  uint64_t v41 = (mlir::GenericProgramPoint *)v30;
  uint64_t v42 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    unint64_t v30 = mlir::ValueRange::offset_base(&v41, ODSOperandIndexAndLength);
  }
  uint64_t v41 = (mlir::GenericProgramPoint *)v30;
  uint64_t v42 = 0;
  uint64_t v35 = mlir::ValueRange::dereference_iterator(&v41, 0);
  F16uint64_t FloatAttr = mlir::Builder::getF16FloatAttr(a4 + 1, 0.0, v31);
  uint64_t v41 = mlir::OpBuilder::create<mlir::anec::Log2,mlir::Value,mlir::FloatAttr>((uint64_t *)a4 + 1, v18, &v35, (uint64_t *)&F16FloatAttr);
  __int16 v32 = mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::anec::Log2 &,mlir::mps::ConstantOp &>((uint64_t *)a4 + 1, *(void *)(a2 + 24), &v41, &v36);
  (*((void (**)(mlir::Float16Type **, uint64_t, mlir::GenericProgramPoint *))*a4 + 4))(a4, a2, v32);
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LogarithmOp &>(mlir::mps::LogarithmOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Log2,mlir::Value,mlir::FloatAttr>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.log2", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.log2";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Invert::build(a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Log2,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::anec::Log2 &,mlir::mps::ConstantOp &>(uint64_t *a1, uint64_t a2, void *a3, void *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.mult", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.mult";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ElementwiseAdd::build(a1, (uint64_t)v19, *a3 - 16, *a4 - 16);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMult,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::anonymous namespace'::ConvertSelect::~ConvertSelect(mlir::_anonymous_namespace_::ConvertSelect *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SelectOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SelectOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SelectOpGenericAdaptorBase::SelectOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SelectOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SelectOpGenericAdaptorBase::SelectOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SelectOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SelectOp &>(mlir::mps::SelectOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  unint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SelectOp &>(mlir::mps::SelectOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertSelect::matchAndRewriteWithStaticShapes(int a1, uint64_t a2, mlir::scf::detail::IfOpGenericAdaptorBase *this, uint64_t *a4)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a4 + 1;
  uint64_t v8 = *(void *)(a2 + 24);
  unsigned int ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 0);
  unint64_t v10 = *((void *)this + 5);
  unint64_t v26 = v10;
  uint64_t v27 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    unint64_t v10 = mlir::ValueRange::offset_base(&v26, ODSOperandIndexAndLength);
  }
  unint64_t v26 = v10;
  uint64_t v27 = 0;
  unint64_t v26 = mlir::ValueRange::dereference_iterator(&v26, 0);
  uint64_t v25 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseNotEqualZero,mlir::Value>(v7, v8, (uint64_t *)&v26) - 16;
  uint64_t v11 = *(void *)(a2 + 24);
  unsigned int v12 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 0);
  unint64_t v13 = *((void *)this + 5);
  unint64_t v26 = v13;
  uint64_t v27 = v12;
  if (v12) {
    unint64_t v13 = mlir::ValueRange::offset_base(&v26, v12);
  }
  unint64_t v26 = v13;
  uint64_t v27 = 0;
  unint64_t v26 = mlir::ValueRange::dereference_iterator(&v26, 0);
  uint64_t v24 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseEqualZero,mlir::Value>(v7, v11, (uint64_t *)&v26) - 16;
  uint64_t v14 = *(void *)(a2 + 24);
  unsigned int v15 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 1u);
  unint64_t v16 = *((void *)this + 5);
  unint64_t v26 = v16;
  uint64_t v27 = v15;
  if (v15) {
    unint64_t v16 = mlir::ValueRange::offset_base(&v26, v15);
  }
  unint64_t v26 = v16;
  uint64_t v27 = 0;
  unint64_t v26 = mlir::ValueRange::dereference_iterator(&v26, 0);
  uint64_t v23 = mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value,mlir::Value&>(v7, v14, (uint64_t *)&v26, &v25);
  uint64_t v17 = *(void *)(a2 + 24);
  unsigned int v18 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 2u);
  unint64_t v19 = *((void *)this + 5);
  unint64_t v26 = v19;
  uint64_t v27 = v18;
  if (v18) {
    unint64_t v19 = mlir::ValueRange::offset_base(&v26, v18);
  }
  unint64_t v26 = v19;
  uint64_t v27 = 0;
  uint64_t v22 = mlir::ValueRange::dereference_iterator(&v26, 0);
  unint64_t v26 = (unint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value,mlir::Value&>(v7, v17, &v22, &v24);
  uint64_t v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,mlir::anec::ElementwiseMult &,mlir::anec::ElementwiseMult &>(v7, *(void *)(a2 + 24), &v23, &v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SelectOp &>(mlir::mps::SelectOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseNotEqualZero,mlir::Value>(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.not_equal_zero", (const unsigned __int8 *)0x13, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.not_equal_zero";
    v15[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::ElementwiseGreaterThanEqualZero::build(a1, (uint64_t)v17, *a3);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseNotEqualZero,void>::id) {
    unint64_t v10 = v9;
  }
  else {
    unint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseEqualZero,mlir::Value>(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.equal_zero", (const unsigned __int8 *)0xF, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.equal_zero";
    v15[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::ElementwiseEqualZero::build(a1, (uint64_t)v17, *a3);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseEqualZero,void>::id) {
    unint64_t v10 = v9;
  }
  else {
    unint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value,mlir::Value&>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.mult", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.mult";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ElementwiseAdd::build(a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMult,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,mlir::anec::ElementwiseMult &,mlir::anec::ElementwiseMult &>(uint64_t *a1, uint64_t a2, void *a3, void *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.add", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.add";
    v17[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ElementwiseAdd::build(a1, (uint64_t)v19, *a3 - 16, *a4 - 16);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::anonymous namespace'::ConvertFlatten2D::~ConvertFlatten2D(mlir::_anonymous_namespace_::ConvertFlatten2D *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::Flatten2DOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::Flatten2DOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::Flatten2DOpGenericAdaptorBase::Flatten2DOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::Flatten2DOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::Flatten2DOpGenericAdaptorBase::Flatten2DOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::Flatten2DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::Flatten2DOp &>(mlir::mps::Flatten2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  unint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::Flatten2DOp &>(mlir::mps::Flatten2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertFlatten2D::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  v104[1] = *MEMORY[0x1E4F143B8];
  uint64_t v88 = a2;
  long long v95 = *(_OWORD *)(a3 + 40);
  uint64_t v6 = (void *)(*(void *)(*(void *)(*(void *)(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  uint64_t v89 = v6;
  uint64_t v90 = v16;
  uint64_t v17 = *(void **)(*(void *)(a2 + 72) + 56);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v89);
  SortedUniquePromotedPositiveAxesAttr = (uint64_t *)mlir::getSortedUniquePromotedPositiveAxesAttr(v17, v18, 0, 0);
  if (!v20)
  {
    LOBYTE(v91) = 0;
    char v94 = 0;
    goto LABEL_70;
  }
  uint64_t v21 = (uint64_t)SortedUniquePromotedPositiveAxesAttr;
  RankPromotionTypeForANE = v104;
  uint64_t v103 = 0x100000000;
  if (!SortedUniquePromotedPositiveAxesAttr) {
    goto LABEL_21;
  }
  uint64_t v22 = *SortedUniquePromotedPositiveAxesAttr;
  unint64_t v23 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v24 = *(unsigned int *)(v22 + 16);
  if (!v24) {
    goto LABEL_21;
  }
  uint64_t v25 = *(void **)(v22 + 8);
  uint64_t v26 = &v25[2 * v24];
  do
  {
    unint64_t v27 = v24 >> 1;
    long long v28 = &v25[2 * (v24 >> 1)];
    unint64_t v30 = *v28;
    int v29 = v28 + 2;
    v24 += ~(v24 >> 1);
    if (v30 < v23) {
      uint64_t v25 = v29;
    }
    else {
      unint64_t v24 = v27;
    }
  }
  while (v24);
  if (v25 != v26 && *v25 == v23) {
    uint64_t v31 = v25[1];
  }
  else {
LABEL_21:
  }
    uint64_t v31 = 0;
  uint64_t v32 = 1;
  mlir::getIntValues<long long>(v21, v31, (uint64_t)&RankPromotionTypeForANE, 1);
  mlir::getRankPromotionShapeForANE((uint64_t)v89, v90, (uint64_t **)&v99);
  uint64_t v96 = &v98;
  HIDWORD(v97) = 2;
  uint64_t v33 = RankPromotionTypeForANE;
  uint64_t v34 = *RankPromotionTypeForANE;
  if (!*RankPromotionTypeForANE)
  {
    uint64_t v43 = 1;
    goto LABEL_33;
  }
  uint64_t v35 = (v34 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (!v35)
  {
    uint64_t v43 = 1;
    uint64_t v38 = (char *)v99;
LABEL_31:
    uint64_t v44 = (char *)v99 + 8 * v34;
    do
    {
      uint64_t v45 = *(void *)v38;
      v38 += 8;
      v43 *= v45;
    }
    while (v38 != v44);
    goto LABEL_33;
  }
  uint64_t v36 = v35 + 1;
  uint64_t v37 = (v35 + 1) & 0x3FFFFFFFFFFFFFFELL;
  uint64_t v38 = (char *)v99 + 8 * v37;
  unint64_t v39 = (char *)v99 + 8;
  uint64_t v40 = 1;
  uint64_t v41 = v37;
  uint64_t v42 = 1;
  do
  {
    v40 *= *(v39 - 1);
    v42 *= *v39;
    v39 += 2;
    v41 -= 2;
  }
  while (v41);
  uint64_t v43 = v42 * v40;
  if (v36 != v37) {
    goto LABEL_31;
  }
LABEL_33:
  *(void *)&long long v98 = v43;
  LODWORD(v97) = 1;
  uint64_t v46 = *RankPromotionTypeForANE;
  if (*RankPromotionTypeForANE == v100) {
    goto LABEL_40;
  }
  uint64_t v47 = 8 * v46;
  uint64_t v48 = (uint64_t *)((char *)v99 + 8 * v46);
  unint64_t v49 = 8 * v100 - 8 - v47;
  if (!v49)
  {
    uint64_t v32 = 1;
    do
    {
LABEL_39:
      uint64_t v55 = *v48++;
      v32 *= v55;
    }
    while (v48 != (uint64_t *)((char *)v99 + 8 * v100));
    goto LABEL_40;
  }
  uint64_t v50 = (v49 >> 3) + 1;
  v48 += v50 & 0x3FFFFFFFFFFFFFFELL;
  long long v51 = (char *)v99 + v47 + 8;
  uint64_t v52 = 1;
  uint64_t v53 = v50 & 0x3FFFFFFFFFFFFFFELL;
  uint64_t v54 = 1;
  do
  {
    v52 *= *(v51 - 1);
    v54 *= *v51;
    v51 += 2;
    v53 -= 2;
  }
  while (v53);
  uint64_t v32 = v54 * v52;
  if (v50 != (v50 & 0x3FFFFFFFFFFFFFFELL)) {
    goto LABEL_39;
  }
LABEL_40:
  *((void *)&v98 + 1) = v32;
  unint64_t v91 = &v93;
  long long v93 = v98;
  uint64_t v92 = 0x200000002;
  char v94 = 1;
  if (v99 != v101)
  {
    free(v99);
    uint64_t v33 = RankPromotionTypeForANE;
  }
  if (v33 != v104) {
    free(v33);
  }
  if (!v94)
  {
LABEL_70:
    uint64_t v84 = a4[2];
    if (v84)
    {
      if (!mlir::RewriterBase::Listener::classof(v84))
      {
        uint64_t v84 = 0;
        if (v94)
        {
LABEL_74:
          if (v91 != &v93) {
            free(v91);
          }
        }
        return v84;
      }
    }
    if (v94) {
      goto LABEL_74;
    }
    return v84;
  }
  uint64_t v56 = (long long *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v88) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v56) {
    goto LABEL_54;
  }
  uint64_t v57 = *(void *)v56;
  unint64_t v58 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v59 = *(unsigned int *)(v57 + 16);
  if (!v59) {
    goto LABEL_54;
  }
  uint64_t v60 = *(void **)(v57 + 8);
  uint64_t v61 = &v60[2 * v59];
  do
  {
    unint64_t v62 = v59 >> 1;
    uint64_t v63 = &v60[2 * (v59 >> 1)];
    unint64_t v65 = *v63;
    uint64_t v64 = v63 + 2;
    v59 += ~(v59 >> 1);
    if (v65 < v58) {
      uint64_t v60 = v64;
    }
    else {
      unint64_t v59 = v62;
    }
  }
  while (v59);
  if (v60 != v61 && *v60 == v58) {
    uint64_t v66 = v60[1];
  }
  else {
LABEL_54:
  }
    uint64_t v66 = 0;
  uint64_t v96 = v56;
  uint64_t v97 = v66;
  if (v94)
  {
    long long v67 = *(_OWORD *)v91;
    uint64_t v99 = v101;
    v101[0] = v67;
    uint64_t v100 = 0x500000002;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v96);
    uint64_t v69 = (uint64_t *)mlir::MemRefType::get(v101, (mlir::AffineMap *)2, OperandRange, 0, 0, 0);
    uint64_t v70 = (uint64_t)v69;
    if (!v69) {
      goto LABEL_65;
    }
    uint64_t v71 = *v69;
    unint64_t v72 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v73 = *(unsigned int *)(v71 + 16);
    if (!v73) {
      goto LABEL_65;
    }
    int v74 = *(void **)(v71 + 8);
    uint64_t v75 = &v74[2 * v73];
    do
    {
      unint64_t v76 = v73 >> 1;
      uint64_t v77 = &v74[2 * (v73 >> 1)];
      unint64_t v79 = *v77;
      uint64_t v78 = v77 + 2;
      v73 += ~(v73 >> 1);
      if (v79 < v72) {
        int v74 = v78;
      }
      else {
        unint64_t v73 = v76;
      }
    }
    while (v73);
    if (v74 != v75 && *v74 == v72) {
      uint64_t v80 = v74[1];
    }
    else {
LABEL_65:
    }
      uint64_t v80 = 0;
    RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v70, v80);
    uint64_t v103 = v81;
    uint64_t v82 = v88;
    uint64_t v89 = (void *)mlir::ValueRange::dereference_iterator(&v95, 0);
    uint64_t v83 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 1), *(void *)(v82 + 24), (uint64_t *)&RankPromotionTypeForANE, (uint64_t *)&v89);
    (*(void (**)(void *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, v82, v83);
    if (v99 != v101) {
      free(v99);
    }
    uint64_t v84 = 1;
    if (!v94) {
      return v84;
    }
    goto LABEL_74;
  }
  unint64_t v86 = (const void ****)std::__throw_bad_optional_access[abi:nn180100]();
  return llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::Flatten2DOp &>(mlir::mps::Flatten2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(v86, v87);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::Flatten2DOp &>(mlir::mps::Flatten2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertFlatten2D::matchAndRewriteWithStaticShapes(mlir::mps::Flatten2DOp,mlir::mps::Flatten2DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: Flatten2DOp axis argument was not a constant. \n");
}

void *mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)0>::~ConvertDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)0>::~ConvertDivide(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DivideOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::DivideOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::DivideOpGenericAdaptorBase::DivideOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DivideOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::DivideOpGenericAdaptorBase::DivideOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::DivideOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DivideOp &>(mlir::mps::DivideOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  unint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DivideOp &>(mlir::mps::DivideOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)0,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  long long v19 = *(_OWORD *)(a3 + 40);
  uint64_t v17 = mlir::ValueRange::dereference_iterator(&v19, 0);
  uint64_t v6 = mlir::ValueRange::dereference_iterator(&v19, 1);
  uint64_t v16 = v6;
  uint64_t v7 = *(void *)(a2 + 24);
  F16uint64_t FloatAttr = v6;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&F16FloatAttr);
  if (DefiningOp
    && (uint64_t v9 = DefiningOp,
        uint64_t v10 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        (*(unsigned int (**)(void, uint64_t))(**(void **)(v9 + 48) + 32))(*(void *)(v9 + 48), v10))
    && (F16uint64_t FloatAttr = mlir::getElementTypeOrSelf(v6), mlir::Type::isF16((mlir::Type *)&F16FloatAttr)))
  {
    F16uint64_t FloatAttr = (uint64_t)mlir::Builder::getF16FloatAttr((mlir::Float16Type **)(a4 + 8), 0.0, v11);
    uint64_t v15 = mlir::OpBuilder::create<mlir::anec::Invert,mlir::Value &,mlir::FloatAttr &>((uint64_t *)(a4 + 8), v7, &v16, &F16FloatAttr);
    F16uint64_t FloatAttr = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value &,mlir::mps::ConstantOp &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v17, &v15)- 16;
    uint64_t v12 = 1;
    mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&F16FloatAttr, 1);
  }
  else
  {
    uint64_t v13 = *(void *)(a4 + 16);
    if (v13 && mlir::RewriterBase::Listener::classof(v13)) {
    else
    }
      return 0;
  }
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Invert,mlir::Value &,mlir::FloatAttr &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.invert", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.invert";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Invert::build(a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Invert,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)0,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(mlir::mps::DivideOp,mlir::mps::DivideOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: can only support divide by a constant on A11/A12 class ANEs \n");
}

void *mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)1>::~ConvertDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)1>::~ConvertDivide(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)1,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  long long v19 = *(_OWORD *)(a3 + 40);
  uint64_t v17 = mlir::ValueRange::dereference_iterator(&v19, 0);
  uint64_t v6 = mlir::ValueRange::dereference_iterator(&v19, 1);
  uint64_t v16 = v6;
  uint64_t v7 = *(void *)(a2 + 24);
  F16uint64_t FloatAttr = v6;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&F16FloatAttr);
  if (DefiningOp
    && (uint64_t v9 = DefiningOp,
        uint64_t v10 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        (*(unsigned int (**)(void, uint64_t))(**(void **)(v9 + 48) + 32))(*(void *)(v9 + 48), v10))
    && (F16uint64_t FloatAttr = mlir::getElementTypeOrSelf(v6), mlir::Type::isF16((mlir::Type *)&F16FloatAttr)))
  {
    F16uint64_t FloatAttr = (uint64_t)mlir::Builder::getF16FloatAttr((mlir::Float16Type **)(a4 + 8), 0.0, v11);
    uint64_t v15 = mlir::OpBuilder::create<mlir::anec::Invert,mlir::Value &,mlir::FloatAttr &>((uint64_t *)(a4 + 8), v7, &v16, &F16FloatAttr);
    F16uint64_t FloatAttr = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value &,mlir::mps::ConstantOp &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v17, &v15)- 16;
    uint64_t v12 = 1;
    mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&F16FloatAttr, 1);
  }
  else
  {
    uint64_t v13 = *(void *)(a4 + 16);
    if (v13 && mlir::RewriterBase::Listener::classof(v13)) {
    else
    }
      return 0;
  }
  return v12;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)1,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(mlir::mps::DivideOp,mlir::mps::DivideOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: can only support divide by a constant on A11/A12 class ANEs \n");
}

void *mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)2>::~ConvertDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)2>::~ConvertDivide(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)2,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  long long v10 = *(_OWORD *)(a3 + 40);
  uint64_t v9 = mlir::ValueRange::dereference_iterator(&v10, 0);
  uint64_t v8 = mlir::ValueRange::dereference_iterator(&v10, 1);
  uint64_t v7 = (char *)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v9, &v8)- 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.div", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.div";
    v17[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ElementwiseAdd::build(a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseDiv,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)3>::~ConvertDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)3>::~ConvertDivide(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)3,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  long long v10 = *(_OWORD *)(a3 + 40);
  uint64_t v9 = mlir::ValueRange::dereference_iterator(&v10, 0);
  uint64_t v8 = mlir::ValueRange::dereference_iterator(&v10, 1);
  uint64_t v7 = (char *)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v9, &v8)- 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

void *mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)4>::~ConvertDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)4>::~ConvertDivide(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)4,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  long long v10 = *(_OWORD *)(a3 + 40);
  uint64_t v9 = mlir::ValueRange::dereference_iterator(&v10, 0);
  uint64_t v8 = mlir::ValueRange::dereference_iterator(&v10, 1);
  uint64_t v7 = (char *)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v9, &v8)- 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

void *mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)5>::~ConvertDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)5>::~ConvertDivide(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)5,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  long long v10 = *(_OWORD *)(a3 + 40);
  uint64_t v9 = mlir::ValueRange::dereference_iterator(&v10, 0);
  uint64_t v8 = mlir::ValueRange::dereference_iterator(&v10, 1);
  uint64_t v7 = (char *)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v9, &v8)- 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

void *mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)6>::~ConvertDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)6>::~ConvertDivide(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)6,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  long long v10 = *(_OWORD *)(a3 + 40);
  uint64_t v9 = mlir::ValueRange::dereference_iterator(&v10, 0);
  uint64_t v8 = mlir::ValueRange::dereference_iterator(&v10, 1);
  uint64_t v7 = (char *)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v9, &v8)- 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

void *mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)0>::~ConvertFloorDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)0>::~ConvertFloorDivide(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::FloorDivideOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::FloorDivideOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::FloorDivideOpGenericAdaptorBase::FloorDivideOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::FloorDivideOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::FloorDivideOpGenericAdaptorBase::FloorDivideOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::FloorDivideOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::FloorDivideOp &>(mlir::mps::FloorDivideOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  unint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::FloorDivideOp &>(mlir::mps::FloorDivideOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)0,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  long long v20 = *(_OWORD *)(a3 + 40);
  uint64_t v18 = mlir::ValueRange::dereference_iterator(&v20, 0);
  uint64_t v6 = mlir::ValueRange::dereference_iterator(&v20, 1);
  uint64_t v17 = v6;
  uint64_t v7 = *(void *)(a2 + 24);
  uint64_t ElementTypeOrSelf = v6;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&ElementTypeOrSelf);
  if (DefiningOp
    && (uint64_t v9 = DefiningOp,
        uint64_t v10 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        (*(unsigned int (**)(void, uint64_t))(**(void **)(v9 + 48) + 32))(*(void *)(v9 + 48), v10))
    && (uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v6), mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf)))
  {
    F16uint64_t FloatAttr = mlir::Builder::getF16FloatAttr((mlir::Float16Type **)(a4 + 8), 0.0, v11);
    uint64_t v15 = mlir::OpBuilder::create<mlir::anec::Invert,mlir::Value &,mlir::FloatAttr &>((uint64_t *)(a4 + 8), v7, &v17, (uint64_t *)&F16FloatAttr);
    uint64_t ElementTypeOrSelf = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value &,mlir::mps::ConstantOp &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v18, &v15)- 16;
    F16uint64_t FloatAttr = (mlir::GenericProgramPoint *)((char *)mlir::OpBuilder::create<mlir::anec::Floor,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &ElementTypeOrSelf)- 16);
    uint64_t v12 = 1;
    mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&F16FloatAttr, 1);
  }
  else
  {
    uint64_t v13 = *(void *)(a4 + 16);
    if (v13 && mlir::RewriterBase::Listener::classof(v13)) {
    else
    }
      return 0;
  }
  return v12;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::FloorDivideOp &>(mlir::mps::FloorDivideOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Floor,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.floor", (const unsigned __int8 *)0xA, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.floor";
    v15[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::ElementwiseEqualZero::build(a1, (uint64_t)v17, *a3);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Floor,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)0,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(mlir::mps::FloorDivideOp,mlir::mps::FloorDivideOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: can only support divide by a constant on A11/A12 class ANEs \n");
}

void *mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)1>::~ConvertFloorDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)1>::~ConvertFloorDivide(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)1,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  long long v20 = *(_OWORD *)(a3 + 40);
  uint64_t v18 = mlir::ValueRange::dereference_iterator(&v20, 0);
  uint64_t v6 = mlir::ValueRange::dereference_iterator(&v20, 1);
  uint64_t v17 = v6;
  uint64_t v7 = *(void *)(a2 + 24);
  uint64_t ElementTypeOrSelf = v6;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&ElementTypeOrSelf);
  if (DefiningOp
    && (uint64_t v9 = DefiningOp,
        uint64_t v10 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        (*(unsigned int (**)(void, uint64_t))(**(void **)(v9 + 48) + 32))(*(void *)(v9 + 48), v10))
    && (uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v6), mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf)))
  {
    F16uint64_t FloatAttr = mlir::Builder::getF16FloatAttr((mlir::Float16Type **)(a4 + 8), 0.0, v11);
    uint64_t v15 = mlir::OpBuilder::create<mlir::anec::Invert,mlir::Value &,mlir::FloatAttr &>((uint64_t *)(a4 + 8), v7, &v17, (uint64_t *)&F16FloatAttr);
    uint64_t ElementTypeOrSelf = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value &,mlir::mps::ConstantOp &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v18, &v15)- 16;
    F16uint64_t FloatAttr = (mlir::GenericProgramPoint *)((char *)mlir::OpBuilder::create<mlir::anec::Floor,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &ElementTypeOrSelf)- 16);
    uint64_t v12 = 1;
    mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&F16FloatAttr, 1);
  }
  else
  {
    uint64_t v13 = *(void *)(a4 + 16);
    if (v13 && mlir::RewriterBase::Listener::classof(v13)) {
    else
    }
      return 0;
  }
  return v12;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)1,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(mlir::mps::FloorDivideOp,mlir::mps::FloorDivideOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: can only support divide by a constant on A11/A12 class ANEs \n");
}

void *mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)2>::~ConvertFloorDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)2>::~ConvertFloorDivide(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)2,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  long long v11 = *(_OWORD *)(a3 + 40);
  uint64_t v10 = mlir::ValueRange::dereference_iterator(&v11, 0);
  uint64_t v9 = mlir::ValueRange::dereference_iterator(&v11, 1);
  uint64_t v8 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v10, &v9)- 16;
  uint64_t v7 = (char *)mlir::OpBuilder::create<mlir::anec::Floor,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v8)
     - 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

void *mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)3>::~ConvertFloorDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)3>::~ConvertFloorDivide(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)3,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  long long v11 = *(_OWORD *)(a3 + 40);
  uint64_t v10 = mlir::ValueRange::dereference_iterator(&v11, 0);
  uint64_t v9 = mlir::ValueRange::dereference_iterator(&v11, 1);
  uint64_t v8 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v10, &v9)- 16;
  uint64_t v7 = (char *)mlir::OpBuilder::create<mlir::anec::Floor,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v8)
     - 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

void *mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)4>::~ConvertFloorDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)4>::~ConvertFloorDivide(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)4,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  long long v11 = *(_OWORD *)(a3 + 40);
  uint64_t v10 = mlir::ValueRange::dereference_iterator(&v11, 0);
  uint64_t v9 = mlir::ValueRange::dereference_iterator(&v11, 1);
  uint64_t v8 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v10, &v9)- 16;
  uint64_t v7 = (char *)mlir::OpBuilder::create<mlir::anec::Floor,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v8)
     - 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

void *mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)5>::~ConvertFloorDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)5>::~ConvertFloorDivide(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)5,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  long long v11 = *(_OWORD *)(a3 + 40);
  uint64_t v10 = mlir::ValueRange::dereference_iterator(&v11, 0);
  uint64_t v9 = mlir::ValueRange::dereference_iterator(&v11, 1);
  uint64_t v8 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v10, &v9)- 16;
  uint64_t v7 = (char *)mlir::OpBuilder::create<mlir::anec::Floor,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v8)
     - 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

void *mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)6>::~ConvertFloorDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)6>::~ConvertFloorDivide(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)6,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  long long v11 = *(_OWORD *)(a3 + 40);
  uint64_t v10 = mlir::ValueRange::dereference_iterator(&v11, 0);
  uint64_t v9 = mlir::ValueRange::dereference_iterator(&v11, 1);
  uint64_t v8 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v10, &v9)- 16;
  uint64_t v7 = (char *)mlir::OpBuilder::create<mlir::anec::Floor,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v8)
     - 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

void *mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)0>::~ConvertMatMul(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)0>::~ConvertMatMul(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MatMulOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::MatMulOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::MatMulOpGenericAdaptorBase::MatMulOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MatMulOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::MatMulOpGenericAdaptorBase::MatMulOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::MatMulOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 56);
  uint64_t v9 = *(void *)(a3 + 64);
  uint64_t v36 = v8;
  uint64_t v37 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v37 = v23;
        if (v36)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v36);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v33 = 259;
      v30[0] = v32;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MatMulOp &>(mlir::mps::MatMulOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 48);
        void v34[2] = *(_OWORD *)(a3 + 32);
        v34[3] = v28;
        uint64_t v35 = *(void *)(a3 + 64);
        long long v29 = *(_OWORD *)(a3 + 16);
        v34[0] = *(_OWORD *)a3;
        v34[1] = v29;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v37;
    if (v36 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  uint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MatMulOp &>(mlir::mps::MatMulOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v106 = *MEMORY[0x1E4F143B8];
  uint64_t v95 = a2;
  long long v103 = *(_OWORD *)(a3 + 56);
  unint64_t v5 = (void *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  long long v93 = v5;
  uint64_t v94 = v15;
  uint64_t v82 = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unint64_t v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t v84 = (uint64_t)v5;
  unint64_t v91 = v16;
  uint64_t v92 = v26;
  uint64_t v27 = (void *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27) {
    goto LABEL_30;
  }
  uint64_t v28 = *v27;
  unint64_t v29 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v30 = *(unsigned int *)(v28 + 16);
  if (!v30) {
    goto LABEL_30;
  }
  uint64_t v31 = *(void **)(v28 + 8);
  __int16 v32 = &v31[2 * v30];
  do
  {
    unint64_t v33 = v30 >> 1;
    uint64_t v34 = &v31[2 * (v30 >> 1)];
    unint64_t v36 = *v34;
    uint64_t v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29) {
      uint64_t v31 = v35;
    }
    else {
      unint64_t v30 = v33;
    }
  }
  while (v30);
  if (v31 != v32 && *v31 == v29) {
    uint64_t v37 = v31[1];
  }
  else {
LABEL_30:
  }
    uint64_t v37 = 0;
  uint64_t v89 = v27;
  uint64_t v90 = v37;
  uint64_t v38 = (char *)mlir::ValueRange::dereference_iterator(&v103, 0);
  uint64_t v88 = v38;
  unint64_t v39 = (char *)mlir::ValueRange::dereference_iterator(&v103, 1);
  uint64_t v87 = v39;
  uint64_t v40 = *(void *)(v95 + 24);
  memset(v86, 0, sizeof(v86));
  memset(v85, 0, sizeof(v85));
  Input = (uint64_t **)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95);
  Filter = (uint64_t **)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  {
    if (!matched) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 0;
LABEL_37:
    uint64_t ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86);
    uint64_t v105 = v46;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    if (v47 == 2 || (v45 & 1) == 0)
    {
      if (v47 != 2) {
        goto LABEL_42;
      }
LABEL_53:
      uint64_t v80 = (unsigned int *)v95;
      mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v102, *(const mlir::TypeConverter **)(a1 + 96));
      mlir::TypeConverter::~TypeConverter(v102);
    }
LABEL_39:
    unint64_t IndexFromDim = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v85);
    uint64_t v99 = v48;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&IndexFromDim);
    if (v49 != 2) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 1;
    goto LABEL_53;
  }
  BOOL TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95);
  unsigned __int8 v45 = TransposeRhs;
  if (matched) {
    goto LABEL_37;
  }
  if (TransposeRhs) {
    goto LABEL_39;
  }
LABEL_42:
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v93);
  if (v50 >= 4)
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v51;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v53 = v52;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v52);
    uint64_t v99 = v54;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v53);
    uint64_t v97 = v55;
    uint64_t v38 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    uint64_t v88 = v38;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v91);
  if (v56 >= 4)
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v57;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v59 = v58;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v58);
    uint64_t v99 = v60;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v59);
    uint64_t v97 = v61;
    unint64_t v39 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    uint64_t v87 = v39;
  }
  if (mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v95))
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v62;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v64 = v63;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v63);
    uint64_t v99 = v65;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v64);
    uint64_t v97 = v66;
    uint64_t v88 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  if (mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95))
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v67;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v69 = v68;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v68);
    uint64_t v99 = v70;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v69);
    uint64_t v97 = v71;
    uint64_t v87 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t ArgOperands = 0;
  unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::Value &,decltype(nullptr)>((mlir::UnknownLoc **)(a4 + 8), v40, (uint64_t *)&v88, (uint64_t *)&v87)- 16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v89);
  if (v73 >= 4)
  {
    uint64_t v100 = v72;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v89, v90);
    uint64_t v105 = v74;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v76 = v75;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v75);
    uint64_t v99 = v77;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v76);
    uint64_t v97 = v78;
    unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  unint64_t v79 = (unsigned int *)v95;
  uint64_t ArgOperands = (uint64_t)v72;
  mlir::ValueRange::ValueRange(v101, (uint64_t)&ArgOperands, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, v79, v101[0], v101[1]);
  return 1;
}

uint64_t mlir::anonymous namespace'::matchAsConst(uint64_t **a1, uint64_t a2)
{
  uint64_t v28 = a1;
  unint64_t v30 = (uint64_t **)a2;
  uint64_t ArgOperands = a1;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&ArgOperands);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v30, DefiningOp)) {
    return 1;
  }
  uint64_t ArgOperands = (uint64_t **)a2;
  uint64_t v25 = a2 + 16;
  uint64_t v26 = a2 + 32;
  uint64_t v27 = a2 + 48;
  uint64_t v29 = (uint64_t)a1;
  uint64_t v6 = mlir::Value::getDefiningOp((mlir::Value *)&v29);
  if (!v6) {
    return 0;
  }
  v23[0] = v6;
  if (*(_UNKNOWN **)(*(void *)(v6 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id) {
    return 0;
  }
  if ((*(unsigned char *)(v6 + 46) & 0x80) == 0) {
    return 0;
  }
  if (*(_DWORD *)(v6 + 68) != 4) {
    return 0;
  }
  char v32 = 1;
  unint64_t v30 = (uint64_t **)&v32;
  uint64_t v31 = v23;
  mlir::detail::enumerateImpl<std::tuple<mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>> &,mlir::detail::RecursivePatternMatcher<mlir::mps::DequantizeOp,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>> & &)#1},0ul,1ul,2ul,3ul>(&ArgOperands, (uint64_t)&v30);
  if (!v32
    || mlir::ElementsAttr::getNumElements(*(void *)(a2 + 48), *(void *)(a2 + 56)) != 1
    || (mlir::getSingleFloatValue<float>(*(void *)(a2 + 48), *(void *)(a2 + 56)) & 0x7FFFFFFF) != 0)
  {
    return 0;
  }
  uint64_t v29 = mlir::Value::getDefiningOp((mlir::Value *)&v28);
  uint64_t ArgOperands = (uint64_t **)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)(a2 + 16));
  uint64_t v25 = v7;
  unint64_t v30 = (uint64_t **)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)(a2 + 32));
  uint64_t v31 = v8;
  uint64_t ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
  if (mlir::ShapedType::getNumElements(ArgAttrsAttr, v10) == 1)
  {
    unint64_t v11 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v30);
    if (mlir::ShapedType::getNumElements(v11, v12) == 1
      && (mlir::mps::DequantizeLUTOp::getAxis((mlir::mps::DequantizeLUTOp *)&v29) & 0xFF00000000) == 0)
    {
      return 1;
    }
  }
  if ((mlir::mps::DequantizeLUTOp::getAxis((mlir::mps::DequantizeLUTOp *)&v29) & 0xFF00000000) == 0) {
    return 0;
  }
  v23[0] = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)a2);
  v23[1] = v13;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v23);
  uint64_t v15 = v14;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
  uint64_t v17 = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v30);
  uint64_t result = 0;
  if (v17 <= 1 && v18 <= 1)
  {
    if (v17 == 1 || v18 == 1)
    {
      uint64_t Axis = mlir::mps::DequantizeLUTOp::getAxis((mlir::mps::DequantizeLUTOp *)&v29);
      if ((Axis & 0xFF00000000) != 0)
      {
        uint64_t KernelDimFromIndex = mlir::anec::getKernelDimFromIndex((int)Axis, v15);
        return (KernelDimFromIndex & 0xFF00000000) != 0 && KernelDimFromIndex == 0;
      }
      else
      {
        uint64_t v22 = std::__throw_bad_optional_access[abi:nn180100]();
      }
    }
    return 1;
  }
  return result;
}

uint64_t mlir::anonymous namespace'::convertToLinear(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t *a8, unsigned __int8 a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  int v20 = a9;
  uint64_t v115 = *MEMORY[0x1E4F143B8];
  uint64_t v105 = a11;
  uint64_t v106 = a1;
  uint64_t v103 = a13;
  uint64_t v104 = a10;
  uint64_t v101 = a15;
  uint64_t v102 = a12;
  uint64_t v99 = 0;
  uint64_t v100 = a14;
  uint64_t v98 = 0;
  if (a9)
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v104);
    uint64_t v22 = (char *)a5;
    if (v23 >= 4)
    {
      uint64_t v111 = (char *)a5;
      *(void *)&long long v113 = mlir::getRankPromotionTypeForANE(v104, v105);
      *((void *)&v113 + 1) = v24;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v113);
      unint64_t v26 = v25;
      unint64_t IndexFromDim = (void *)mlir::anec::getIndexFromDim(1, v25);
      uint64_t v110 = v27;
      unint64_t v107 = mlir::anec::getIndexFromDim(3, v26);
      uint64_t v108 = v28;
      uint64_t v22 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a2 + 8), a4, (uint64_t *)&v111, (uint64_t *)&IndexFromDim, (uint64_t *)&v107)- 16;
    }
    if (!mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v106))
    {
      uint64_t v111 = v22;
      *(void *)&long long v113 = mlir::getRankPromotionTypeForANE(v104, v105);
      *((void *)&v113 + 1) = v29;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v113);
      unint64_t v31 = v30;
      unint64_t IndexFromDim = (void *)mlir::anec::getIndexFromDim(1, v30);
      uint64_t v110 = v32;
      unint64_t v107 = mlir::anec::getIndexFromDim(4, v31);
      uint64_t v108 = v33;
      uint64_t v22 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a2 + 8), a4, (uint64_t *)&v111, (uint64_t *)&IndexFromDim, (uint64_t *)&v107)- 16;
    }
    a5 = a6;
  }
  else
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v102);
    uint64_t v22 = (char *)a6;
    if (v35 >= 4)
    {
      uint64_t v111 = (char *)a6;
      *(void *)&long long v113 = mlir::getRankPromotionTypeForANE(v102, v103);
      *((void *)&v113 + 1) = v36;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v113);
      unint64_t v38 = v37;
      unint64_t IndexFromDim = (void *)mlir::anec::getIndexFromDim(1, v37);
      uint64_t v110 = v39;
      unint64_t v107 = mlir::anec::getIndexFromDim(3, v38);
      uint64_t v108 = v40;
      uint64_t v22 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a2 + 8), a4, (uint64_t *)&v111, (uint64_t *)&IndexFromDim, (uint64_t *)&v107)- 16;
    }
    if (mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v106))
    {
      uint64_t v111 = v22;
      *(void *)&long long v113 = mlir::getRankPromotionTypeForANE(v102, v103);
      *((void *)&v113 + 1) = v41;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v113);
      unint64_t v43 = v42;
      unint64_t IndexFromDim = (void *)mlir::anec::getIndexFromDim(1, v42);
      uint64_t v110 = v44;
      unint64_t v107 = mlir::anec::getIndexFromDim(4, v43);
      uint64_t v108 = v45;
      uint64_t v22 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a2 + 8), a4, (uint64_t *)&v111, (uint64_t *)&IndexFromDim, (uint64_t *)&v107)- 16;
    }
    a8 = a7;
  }
  uint64_t v98 = a5;
  uint64_t v99 = v22;
  uint64_t v46 = a8[2];
  if (v46)
  {
    uint64_t v47 = mlir::convertElementsAttr(v46, a8[3], 1);
    uint64_t v48 = (mlir::OpBuilder *)(a2 + 8);
    *(void *)&long long v113 = mlir::getElementTypeOrSelf((void *)a8[4]);
    BOOL isSignedInteger = mlir::Type::isSignedInteger((mlir::Type *)&v113);
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a2 + 8), 8u, isSignedInteger);
    unint64_t IndexFromDim = (void *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)(a8 + 4));
    uint64_t v110 = v51;
    LOBYTE(v113) = 0;
    char v114 = 0;
    uint64_t v52 = mlir::ShapedType::cloneWith((uint64_t *)&IndexFromDim, &v113, IntegerType);
    uint64_t v54 = mlir::rewriteElementsAttr(a8[4], a8[5], v52, v53, 1);
    Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)a8);
    uint64_t v56 = Type;
    if (!Type) {
      goto LABEL_22;
    }
    uint64_t v57 = *Type;
    unint64_t v58 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v59 = *(unsigned int *)(v57 + 16);
    if (!v59) {
      goto LABEL_22;
    }
    uint64_t v60 = *(void **)(v57 + 8);
    uint64_t v61 = &v60[2 * v59];
    do
    {
      unint64_t v62 = v59 >> 1;
      unint64_t v63 = &v60[2 * (v59 >> 1)];
      unint64_t v65 = *v63;
      unint64_t v64 = v63 + 2;
      v59 += ~(v59 >> 1);
      if (v65 < v58) {
        uint64_t v60 = v64;
      }
      else {
        unint64_t v59 = v62;
      }
    }
    while (v59);
    if (v60 != v61 && *v60 == v58) {
      uint64_t v66 = v60[1];
    }
    else {
LABEL_22:
    }
      uint64_t v66 = 0;
    *(void *)&long long v113 = v56;
    *((void *)&v113 + 1) = v66;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v113);
    unint64_t v68 = (void *)(*(void *)(v98 + 8) & 0xFFFFFFFFFFFFFFF8);
    if (v68)
    {
      uint64_t v69 = a3;
      uint64_t v70 = *v68;
      unint64_t v71 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v72 = *(unsigned int *)(v70 + 16);
      if (v72)
      {
        uint64_t v73 = *(void **)(v70 + 8);
        uint64_t v74 = &v73[2 * v72];
        do
        {
          unint64_t v75 = v72 >> 1;
          unint64_t v76 = &v73[2 * (v72 >> 1)];
          unint64_t v78 = *v76;
          uint64_t v77 = v76 + 2;
          v72 += ~(v72 >> 1);
          if (v78 < v71) {
            uint64_t v73 = v77;
          }
          else {
            unint64_t v72 = v75;
          }
        }
        while (v72);
        a3 = v69;
        if (v73 == v74)
        {
          uint64_t v79 = 0;
          int v20 = a9;
        }
        else
        {
          int v20 = a9;
          if (*v73 == v71) {
            uint64_t v79 = v73[1];
          }
          else {
            uint64_t v79 = 0;
          }
        }
      }
      else
      {
        uint64_t v79 = 0;
        a3 = v69;
        int v20 = a9;
      }
      uint64_t v48 = (mlir::OpBuilder *)(a2 + 8);
    }
    else
    {
      uint64_t v79 = 0;
    }
    unint64_t IndexFromDim = v68;
    uint64_t v110 = v79;
    LOBYTE(v113) = 0;
    char v114 = 0;
    uint64_t v80 = (void *)mlir::ShapedType::cloneWith((uint64_t *)&IndexFromDim, &v113, OperandRange);
    uint64_t v82 = v81;
    *(void *)&long long v113 = mlir::rewriteElementsAttr(*a8, a8[1], (uint64_t)v80, v82, 0);
    *((void *)&v113 + 1) = v83;
    uint64_t v98 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>(v48, a4, (uint64_t *)&IndexFromDim, (void **)&v113)- 16;
    *(void *)&long long v113 = v47;
  }
  else
  {
    uint64_t v54 = 0;
    *(void *)&long long v113 = 0;
  }
  unint64_t IndexFromDim = v54;
  uint64_t v84 = (char *)mlir::OpBuilder::create<mlir::anec::Linear,mlir::Value &,mlir::Value &,mlir::DenseFPElementsAttr,mlir::DenseIntElementsAttr>((mlir::UnknownLoc **)(a2 + 8), a4, (uint64_t *)&v99, &v98, (uint64_t *)&v113, (uint64_t *)&IndexFromDim)- 16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v100);
  if (v85 >= 4)
  {
    uint64_t v111 = v84;
    *(void *)&long long v113 = mlir::getRankPromotionTypeForANE(v100, v101);
    *((void *)&v113 + 1) = v86;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v113);
    unint64_t v88 = v87;
    unint64_t IndexFromDim = (void *)mlir::anec::getIndexFromDim(1, v87);
    uint64_t v110 = v89;
    unint64_t v107 = mlir::anec::getIndexFromDim(3, v88);
    uint64_t v108 = v90;
    uint64_t v84 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a2 + 8), a4, (uint64_t *)&v111, (uint64_t *)&IndexFromDim, (uint64_t *)&v107)- 16;
  }
  if (v20)
  {
    uint64_t v111 = v84;
    *(void *)&long long v113 = mlir::getRankPromotionTypeForANE(v100, v101);
    *((void *)&v113 + 1) = v91;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v113);
    unint64_t v93 = v92;
    unint64_t IndexFromDim = (void *)mlir::anec::getIndexFromDim(1, v92);
    uint64_t v110 = v94;
    unint64_t v107 = mlir::anec::getIndexFromDim(4, v93);
    uint64_t v108 = v95;
    uint64_t v84 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a2 + 8), a4, (uint64_t *)&v111, (uint64_t *)&IndexFromDim, (uint64_t *)&v107)- 16;
  }
  unint64_t v96 = v106;
  *(void *)&long long v113 = v84;
  mlir::ValueRange::ValueRange(v112, (uint64_t)&v113, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a2, v96, v112[0], v112[1]);
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::Value &,decltype(nullptr)>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.matmul", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.matmul";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::MatMul::build(a1, (uint64_t)v19, *a3, *a4, 0);
  unint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::MatMul,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>> &,mlir::detail::RecursivePatternMatcher<mlir::mps::DequantizeOp,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>> & &)#1},0ul,1ul,2ul,3ul>(uint64_t ***a1, uint64_t a2)
{
  uint64_t v12 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v12);
  if (DefiningOp) {
    LOBYTE(DefiningOp) = mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(a1, DefiningOp);
  }
  if (**(unsigned char **)a2) {
    char v5 = DefiningOp;
  }
  else {
    char v5 = 0;
  }
  **(unsigned char **)a2 = v5;
  uint64_t v12 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 56);
  uint64_t v6 = mlir::Value::getDefiningOp((mlir::Value *)&v12);
  if (v6) {
    LOBYTE(v6) = mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(a1 + 1, v6);
  }
  if (**(unsigned char **)a2) {
    char v7 = v6;
  }
  else {
    char v7 = 0;
  }
  **(unsigned char **)a2 = v7;
  uint64_t v12 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 88);
  uint64_t v8 = mlir::Value::getDefiningOp((mlir::Value *)&v12);
  if (v8) {
    LOBYTE(v8) = mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(a1 + 2, v8);
  }
  if (**(unsigned char **)a2) {
    char v9 = v8;
  }
  else {
    char v9 = 0;
  }
  **(unsigned char **)a2 = v9;
  uint64_t v12 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 120);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v12);
  if (result) {
    uint64_t result = mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(a1 + 3, result);
  }
  if (**(unsigned char **)a2) {
    char v11 = result;
  }
  else {
    char v11 = 0;
  }
  **(unsigned char **)a2 = v11;
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Linear,mlir::Value &,mlir::Value &,mlir::DenseFPElementsAttr,mlir::DenseIntElementsAttr>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.linear", (const unsigned __int8 *)0xB, Context);
  if (!v14)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.linear";
    void v21[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::anec::Linear::build(a1, (uint64_t)v23, *a3, *a4, *a5, *a6);
  uint64_t v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Linear,void>::id) {
    __int16 v16 = v15;
  }
  else {
    __int16 v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.transpose", (const unsigned __int8 *)0xE, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"anec.transpose";
    v19[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::anec::Transpose::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  uint64_t v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Transpose,void>::id) {
    char v14 = v13;
  }
  else {
    char v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void *mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)1>::~ConvertMatMul(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)1>::~ConvertMatMul(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v106 = *MEMORY[0x1E4F143B8];
  uint64_t v95 = a2;
  long long v103 = *(_OWORD *)(a3 + 56);
  char v5 = (void *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  char v9 = *(void **)(v6 + 8);
  char v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    char v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      char v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v93 = v5;
  uint64_t v94 = v15;
  uint64_t v82 = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  __int16 v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    uint64_t v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      __int16 v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t v84 = (uint64_t)v5;
  uint64_t v91 = v16;
  uint64_t v92 = v26;
  uint64_t v27 = (void *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27) {
    goto LABEL_30;
  }
  uint64_t v28 = *v27;
  unint64_t v29 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v30 = *(unsigned int *)(v28 + 16);
  if (!v30) {
    goto LABEL_30;
  }
  unint64_t v31 = *(void **)(v28 + 8);
  uint64_t v32 = &v31[2 * v30];
  do
  {
    unint64_t v33 = v30 >> 1;
    uint64_t v34 = &v31[2 * (v30 >> 1)];
    unint64_t v36 = *v34;
    uint64_t v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29) {
      unint64_t v31 = v35;
    }
    else {
      unint64_t v30 = v33;
    }
  }
  while (v30);
  if (v31 != v32 && *v31 == v29) {
    uint64_t v37 = v31[1];
  }
  else {
LABEL_30:
  }
    uint64_t v37 = 0;
  uint64_t v89 = v27;
  uint64_t v90 = v37;
  unint64_t v38 = (char *)mlir::ValueRange::dereference_iterator(&v103, 0);
  unint64_t v88 = v38;
  uint64_t v39 = (char *)mlir::ValueRange::dereference_iterator(&v103, 1);
  unint64_t v87 = v39;
  uint64_t v40 = *(void *)(v95 + 24);
  memset(v86, 0, sizeof(v86));
  memset(v85, 0, sizeof(v85));
  Input = (uint64_t **)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95);
  Filter = (uint64_t **)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  {
    if (!matched) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 0;
LABEL_37:
    uint64_t ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86);
    uint64_t v105 = v46;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    if (v47 == 2 || (v45 & 1) == 0)
    {
      if (v47 != 2) {
        goto LABEL_42;
      }
LABEL_53:
      uint64_t v80 = (unsigned int *)v95;
      mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v102, *(const mlir::TypeConverter **)(a1 + 96));
      mlir::TypeConverter::~TypeConverter(v102);
    }
LABEL_39:
    unint64_t IndexFromDim = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v85);
    uint64_t v99 = v48;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&IndexFromDim);
    if (v49 != 2) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 1;
    goto LABEL_53;
  }
  BOOL TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95);
  unsigned __int8 v45 = TransposeRhs;
  if (matched) {
    goto LABEL_37;
  }
  if (TransposeRhs) {
    goto LABEL_39;
  }
LABEL_42:
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v93);
  if (v50 >= 4)
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v51;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v53 = v52;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v52);
    uint64_t v99 = v54;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v53);
    uint64_t v97 = v55;
    unint64_t v38 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unint64_t v88 = v38;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v91);
  if (v56 >= 4)
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v57;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v59 = v58;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v58);
    uint64_t v99 = v60;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v59);
    uint64_t v97 = v61;
    uint64_t v39 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unint64_t v87 = v39;
  }
  if (mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v95))
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v62;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v64 = v63;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v63);
    uint64_t v99 = v65;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v64);
    uint64_t v97 = v66;
    unint64_t v88 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  if (mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95))
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v67;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v69 = v68;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v68);
    uint64_t v99 = v70;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v69);
    uint64_t v97 = v71;
    unint64_t v87 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t ArgOperands = 0;
  unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::Value &,decltype(nullptr)>((mlir::UnknownLoc **)(a4 + 8), v40, (uint64_t *)&v88, (uint64_t *)&v87)- 16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v89);
  if (v73 >= 4)
  {
    uint64_t v100 = v72;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v89, v90);
    uint64_t v105 = v74;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v76 = v75;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v75);
    uint64_t v99 = v77;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v76);
    uint64_t v97 = v78;
    unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t v79 = (unsigned int *)v95;
  uint64_t ArgOperands = (uint64_t)v72;
  mlir::ValueRange::ValueRange(v101, (uint64_t)&ArgOperands, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, v79, v101[0], v101[1]);
  return 1;
}

void *mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)2>::~ConvertMatMul(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)2>::~ConvertMatMul(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v106 = *MEMORY[0x1E4F143B8];
  uint64_t v95 = a2;
  long long v103 = *(_OWORD *)(a3 + 56);
  char v5 = (void *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  char v9 = *(void **)(v6 + 8);
  char v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    char v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      char v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v93 = v5;
  uint64_t v94 = v15;
  uint64_t v82 = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  __int16 v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    uint64_t v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      __int16 v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t v84 = (uint64_t)v5;
  uint64_t v91 = v16;
  uint64_t v92 = v26;
  uint64_t v27 = (void *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27) {
    goto LABEL_30;
  }
  uint64_t v28 = *v27;
  unint64_t v29 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v30 = *(unsigned int *)(v28 + 16);
  if (!v30) {
    goto LABEL_30;
  }
  unint64_t v31 = *(void **)(v28 + 8);
  uint64_t v32 = &v31[2 * v30];
  do
  {
    unint64_t v33 = v30 >> 1;
    uint64_t v34 = &v31[2 * (v30 >> 1)];
    unint64_t v36 = *v34;
    uint64_t v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29) {
      unint64_t v31 = v35;
    }
    else {
      unint64_t v30 = v33;
    }
  }
  while (v30);
  if (v31 != v32 && *v31 == v29) {
    uint64_t v37 = v31[1];
  }
  else {
LABEL_30:
  }
    uint64_t v37 = 0;
  uint64_t v89 = v27;
  uint64_t v90 = v37;
  unint64_t v38 = (char *)mlir::ValueRange::dereference_iterator(&v103, 0);
  unint64_t v88 = v38;
  uint64_t v39 = (char *)mlir::ValueRange::dereference_iterator(&v103, 1);
  unint64_t v87 = v39;
  uint64_t v40 = *(void *)(v95 + 24);
  memset(v86, 0, sizeof(v86));
  memset(v85, 0, sizeof(v85));
  Input = (uint64_t **)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95);
  Filter = (uint64_t **)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  {
    if (!matched) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 0;
LABEL_37:
    uint64_t ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86);
    uint64_t v105 = v46;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    if (v47 == 2 || (v45 & 1) == 0)
    {
      if (v47 != 2) {
        goto LABEL_42;
      }
LABEL_53:
      uint64_t v80 = (unsigned int *)v95;
      mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v102, *(const mlir::TypeConverter **)(a1 + 96));
      mlir::TypeConverter::~TypeConverter(v102);
    }
LABEL_39:
    unint64_t IndexFromDim = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v85);
    uint64_t v99 = v48;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&IndexFromDim);
    if (v49 != 2) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 1;
    goto LABEL_53;
  }
  BOOL TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95);
  unsigned __int8 v45 = TransposeRhs;
  if (matched) {
    goto LABEL_37;
  }
  if (TransposeRhs) {
    goto LABEL_39;
  }
LABEL_42:
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v93);
  if (v50 >= 4)
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v51;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v53 = v52;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v52);
    uint64_t v99 = v54;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v53);
    uint64_t v97 = v55;
    unint64_t v38 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unint64_t v88 = v38;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v91);
  if (v56 >= 4)
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v57;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v59 = v58;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v58);
    uint64_t v99 = v60;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v59);
    uint64_t v97 = v61;
    uint64_t v39 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unint64_t v87 = v39;
  }
  if (mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v95))
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v62;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v64 = v63;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v63);
    uint64_t v99 = v65;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v64);
    uint64_t v97 = v66;
    unint64_t v88 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  if (mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95))
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v67;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v69 = v68;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v68);
    uint64_t v99 = v70;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v69);
    uint64_t v97 = v71;
    unint64_t v87 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t ArgOperands = 0;
  unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::Value &,decltype(nullptr)>((mlir::UnknownLoc **)(a4 + 8), v40, (uint64_t *)&v88, (uint64_t *)&v87)- 16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v89);
  if (v73 >= 4)
  {
    uint64_t v100 = v72;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v89, v90);
    uint64_t v105 = v74;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v76 = v75;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v75);
    uint64_t v99 = v77;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v76);
    uint64_t v97 = v78;
    unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t v79 = (unsigned int *)v95;
  uint64_t ArgOperands = (uint64_t)v72;
  mlir::ValueRange::ValueRange(v101, (uint64_t)&ArgOperands, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, v79, v101[0], v101[1]);
  return 1;
}

void *mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)3>::~ConvertMatMul(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)3>::~ConvertMatMul(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v106 = *MEMORY[0x1E4F143B8];
  uint64_t v95 = a2;
  long long v103 = *(_OWORD *)(a3 + 56);
  char v5 = (void *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  char v9 = *(void **)(v6 + 8);
  char v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    char v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      char v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v93 = v5;
  uint64_t v94 = v15;
  uint64_t v82 = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  __int16 v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    uint64_t v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      __int16 v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t v84 = (uint64_t)v5;
  uint64_t v91 = v16;
  uint64_t v92 = v26;
  uint64_t v27 = (void *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27) {
    goto LABEL_30;
  }
  uint64_t v28 = *v27;
  unint64_t v29 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v30 = *(unsigned int *)(v28 + 16);
  if (!v30) {
    goto LABEL_30;
  }
  unint64_t v31 = *(void **)(v28 + 8);
  uint64_t v32 = &v31[2 * v30];
  do
  {
    unint64_t v33 = v30 >> 1;
    uint64_t v34 = &v31[2 * (v30 >> 1)];
    unint64_t v36 = *v34;
    uint64_t v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29) {
      unint64_t v31 = v35;
    }
    else {
      unint64_t v30 = v33;
    }
  }
  while (v30);
  if (v31 != v32 && *v31 == v29) {
    uint64_t v37 = v31[1];
  }
  else {
LABEL_30:
  }
    uint64_t v37 = 0;
  uint64_t v89 = v27;
  uint64_t v90 = v37;
  unint64_t v38 = (char *)mlir::ValueRange::dereference_iterator(&v103, 0);
  unint64_t v88 = v38;
  uint64_t v39 = (char *)mlir::ValueRange::dereference_iterator(&v103, 1);
  unint64_t v87 = v39;
  uint64_t v40 = *(void *)(v95 + 24);
  memset(v86, 0, sizeof(v86));
  memset(v85, 0, sizeof(v85));
  Input = (uint64_t **)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95);
  Filter = (uint64_t **)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  {
    if (!matched) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 0;
LABEL_37:
    uint64_t ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86);
    uint64_t v105 = v46;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    if (v47 == 2 || (v45 & 1) == 0)
    {
      if (v47 != 2) {
        goto LABEL_42;
      }
LABEL_53:
      uint64_t v80 = (unsigned int *)v95;
      mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v102, *(const mlir::TypeConverter **)(a1 + 96));
      mlir::TypeConverter::~TypeConverter(v102);
    }
LABEL_39:
    unint64_t IndexFromDim = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v85);
    uint64_t v99 = v48;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&IndexFromDim);
    if (v49 != 2) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 1;
    goto LABEL_53;
  }
  BOOL TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95);
  unsigned __int8 v45 = TransposeRhs;
  if (matched) {
    goto LABEL_37;
  }
  if (TransposeRhs) {
    goto LABEL_39;
  }
LABEL_42:
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v93);
  if (v50 >= 4)
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v51;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v53 = v52;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v52);
    uint64_t v99 = v54;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v53);
    uint64_t v97 = v55;
    unint64_t v38 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unint64_t v88 = v38;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v91);
  if (v56 >= 4)
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v57;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v59 = v58;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v58);
    uint64_t v99 = v60;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v59);
    uint64_t v97 = v61;
    uint64_t v39 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unint64_t v87 = v39;
  }
  if (mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v95))
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v62;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v64 = v63;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v63);
    uint64_t v99 = v65;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v64);
    uint64_t v97 = v66;
    unint64_t v88 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  if (mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95))
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v67;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v69 = v68;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v68);
    uint64_t v99 = v70;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v69);
    uint64_t v97 = v71;
    unint64_t v87 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t ArgOperands = 0;
  unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::Value &,decltype(nullptr)>((mlir::UnknownLoc **)(a4 + 8), v40, (uint64_t *)&v88, (uint64_t *)&v87)- 16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v89);
  if (v73 >= 4)
  {
    uint64_t v100 = v72;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v89, v90);
    uint64_t v105 = v74;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v76 = v75;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v75);
    uint64_t v99 = v77;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v76);
    uint64_t v97 = v78;
    unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t v79 = (unsigned int *)v95;
  uint64_t ArgOperands = (uint64_t)v72;
  mlir::ValueRange::ValueRange(v101, (uint64_t)&ArgOperands, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, v79, v101[0], v101[1]);
  return 1;
}

void *mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)4>::~ConvertMatMul(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)4>::~ConvertMatMul(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v106 = *MEMORY[0x1E4F143B8];
  uint64_t v95 = a2;
  long long v103 = *(_OWORD *)(a3 + 56);
  char v5 = (void *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  char v9 = *(void **)(v6 + 8);
  char v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    char v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      char v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v93 = v5;
  uint64_t v94 = v15;
  uint64_t v82 = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  __int16 v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    uint64_t v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      __int16 v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t v84 = (uint64_t)v5;
  uint64_t v91 = v16;
  uint64_t v92 = v26;
  uint64_t v27 = (void *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27) {
    goto LABEL_30;
  }
  uint64_t v28 = *v27;
  unint64_t v29 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v30 = *(unsigned int *)(v28 + 16);
  if (!v30) {
    goto LABEL_30;
  }
  unint64_t v31 = *(void **)(v28 + 8);
  uint64_t v32 = &v31[2 * v30];
  do
  {
    unint64_t v33 = v30 >> 1;
    uint64_t v34 = &v31[2 * (v30 >> 1)];
    unint64_t v36 = *v34;
    uint64_t v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29) {
      unint64_t v31 = v35;
    }
    else {
      unint64_t v30 = v33;
    }
  }
  while (v30);
  if (v31 != v32 && *v31 == v29) {
    uint64_t v37 = v31[1];
  }
  else {
LABEL_30:
  }
    uint64_t v37 = 0;
  uint64_t v89 = v27;
  uint64_t v90 = v37;
  unint64_t v38 = (char *)mlir::ValueRange::dereference_iterator(&v103, 0);
  unint64_t v88 = v38;
  uint64_t v39 = (char *)mlir::ValueRange::dereference_iterator(&v103, 1);
  unint64_t v87 = v39;
  uint64_t v40 = *(void *)(v95 + 24);
  memset(v86, 0, sizeof(v86));
  memset(v85, 0, sizeof(v85));
  Input = (uint64_t **)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95);
  Filter = (uint64_t **)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  {
    if (!matched) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 0;
LABEL_37:
    uint64_t ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86);
    uint64_t v105 = v46;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    if (v47 == 2 || (v45 & 1) == 0)
    {
      if (v47 != 2) {
        goto LABEL_42;
      }
LABEL_53:
      uint64_t v80 = (unsigned int *)v95;
      mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v102, *(const mlir::TypeConverter **)(a1 + 96));
      mlir::TypeConverter::~TypeConverter(v102);
    }
LABEL_39:
    unint64_t IndexFromDim = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v85);
    uint64_t v99 = v48;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&IndexFromDim);
    if (v49 != 2) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 1;
    goto LABEL_53;
  }
  BOOL TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95);
  unsigned __int8 v45 = TransposeRhs;
  if (matched) {
    goto LABEL_37;
  }
  if (TransposeRhs) {
    goto LABEL_39;
  }
LABEL_42:
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v93);
  if (v50 >= 4)
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v51;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v53 = v52;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v52);
    uint64_t v99 = v54;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v53);
    uint64_t v97 = v55;
    unint64_t v38 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unint64_t v88 = v38;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v91);
  if (v56 >= 4)
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v57;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v59 = v58;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v58);
    uint64_t v99 = v60;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v59);
    uint64_t v97 = v61;
    uint64_t v39 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unint64_t v87 = v39;
  }
  if (mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v95))
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v62;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v64 = v63;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v63);
    uint64_t v99 = v65;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v64);
    uint64_t v97 = v66;
    unint64_t v88 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  if (mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95))
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v67;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v69 = v68;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v68);
    uint64_t v99 = v70;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v69);
    uint64_t v97 = v71;
    unint64_t v87 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t ArgOperands = 0;
  unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::Value &,decltype(nullptr)>((mlir::UnknownLoc **)(a4 + 8), v40, (uint64_t *)&v88, (uint64_t *)&v87)- 16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v89);
  if (v73 >= 4)
  {
    uint64_t v100 = v72;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v89, v90);
    uint64_t v105 = v74;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v76 = v75;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v75);
    uint64_t v99 = v77;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v76);
    uint64_t v97 = v78;
    unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t v79 = (unsigned int *)v95;
  uint64_t ArgOperands = (uint64_t)v72;
  mlir::ValueRange::ValueRange(v101, (uint64_t)&ArgOperands, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, v79, v101[0], v101[1]);
  return 1;
}

void *mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)5>::~ConvertMatMul(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)5>::~ConvertMatMul(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v106 = *MEMORY[0x1E4F143B8];
  uint64_t v95 = a2;
  long long v103 = *(_OWORD *)(a3 + 56);
  char v5 = (void *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  char v9 = *(void **)(v6 + 8);
  char v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    char v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      char v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v93 = v5;
  uint64_t v94 = v15;
  uint64_t v82 = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  __int16 v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    uint64_t v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      __int16 v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t v84 = (uint64_t)v5;
  uint64_t v91 = v16;
  uint64_t v92 = v26;
  uint64_t v27 = (void *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27) {
    goto LABEL_30;
  }
  uint64_t v28 = *v27;
  unint64_t v29 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v30 = *(unsigned int *)(v28 + 16);
  if (!v30) {
    goto LABEL_30;
  }
  unint64_t v31 = *(void **)(v28 + 8);
  uint64_t v32 = &v31[2 * v30];
  do
  {
    unint64_t v33 = v30 >> 1;
    uint64_t v34 = &v31[2 * (v30 >> 1)];
    unint64_t v36 = *v34;
    uint64_t v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29) {
      unint64_t v31 = v35;
    }
    else {
      unint64_t v30 = v33;
    }
  }
  while (v30);
  if (v31 != v32 && *v31 == v29) {
    uint64_t v37 = v31[1];
  }
  else {
LABEL_30:
  }
    uint64_t v37 = 0;
  uint64_t v89 = v27;
  uint64_t v90 = v37;
  unint64_t v38 = (char *)mlir::ValueRange::dereference_iterator(&v103, 0);
  unint64_t v88 = v38;
  uint64_t v39 = (char *)mlir::ValueRange::dereference_iterator(&v103, 1);
  unint64_t v87 = v39;
  uint64_t v40 = *(void *)(v95 + 24);
  memset(v86, 0, sizeof(v86));
  memset(v85, 0, sizeof(v85));
  Input = (uint64_t **)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95);
  Filter = (uint64_t **)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  {
    if (!matched) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 0;
LABEL_37:
    uint64_t ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86);
    uint64_t v105 = v46;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    if (v47 == 2 || (v45 & 1) == 0)
    {
      if (v47 != 2) {
        goto LABEL_42;
      }
LABEL_53:
      uint64_t v80 = (unsigned int *)v95;
      mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v102, *(const mlir::TypeConverter **)(a1 + 96));
      mlir::TypeConverter::~TypeConverter(v102);
    }
LABEL_39:
    unint64_t IndexFromDim = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v85);
    uint64_t v99 = v48;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&IndexFromDim);
    if (v49 != 2) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 1;
    goto LABEL_53;
  }
  BOOL TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95);
  unsigned __int8 v45 = TransposeRhs;
  if (matched) {
    goto LABEL_37;
  }
  if (TransposeRhs) {
    goto LABEL_39;
  }
LABEL_42:
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v93);
  if (v50 >= 4)
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v51;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v53 = v52;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v52);
    uint64_t v99 = v54;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v53);
    uint64_t v97 = v55;
    unint64_t v38 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unint64_t v88 = v38;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v91);
  if (v56 >= 4)
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v57;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v59 = v58;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v58);
    uint64_t v99 = v60;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v59);
    uint64_t v97 = v61;
    uint64_t v39 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unint64_t v87 = v39;
  }
  if (mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v95))
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v62;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v64 = v63;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v63);
    uint64_t v99 = v65;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v64);
    uint64_t v97 = v66;
    unint64_t v88 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  if (mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95))
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v67;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v69 = v68;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v68);
    uint64_t v99 = v70;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v69);
    uint64_t v97 = v71;
    unint64_t v87 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t ArgOperands = 0;
  unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::Value &,decltype(nullptr)>((mlir::UnknownLoc **)(a4 + 8), v40, (uint64_t *)&v88, (uint64_t *)&v87)- 16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v89);
  if (v73 >= 4)
  {
    uint64_t v100 = v72;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v89, v90);
    uint64_t v105 = v74;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v76 = v75;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v75);
    uint64_t v99 = v77;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v76);
    uint64_t v97 = v78;
    unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t v79 = (unsigned int *)v95;
  uint64_t ArgOperands = (uint64_t)v72;
  mlir::ValueRange::ValueRange(v101, (uint64_t)&ArgOperands, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, v79, v101[0], v101[1]);
  return 1;
}

void *mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)6>::~ConvertMatMul(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)6>::~ConvertMatMul(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v106 = *MEMORY[0x1E4F143B8];
  uint64_t v95 = a2;
  long long v103 = *(_OWORD *)(a3 + 56);
  char v5 = (void *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  char v9 = *(void **)(v6 + 8);
  char v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    char v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      char v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v93 = v5;
  uint64_t v94 = v15;
  uint64_t v82 = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  __int16 v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    uint64_t v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      __int16 v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t v84 = (uint64_t)v5;
  uint64_t v91 = v16;
  uint64_t v92 = v26;
  uint64_t v27 = (void *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27) {
    goto LABEL_30;
  }
  uint64_t v28 = *v27;
  unint64_t v29 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v30 = *(unsigned int *)(v28 + 16);
  if (!v30) {
    goto LABEL_30;
  }
  unint64_t v31 = *(void **)(v28 + 8);
  uint64_t v32 = &v31[2 * v30];
  do
  {
    unint64_t v33 = v30 >> 1;
    uint64_t v34 = &v31[2 * (v30 >> 1)];
    unint64_t v36 = *v34;
    uint64_t v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29) {
      unint64_t v31 = v35;
    }
    else {
      unint64_t v30 = v33;
    }
  }
  while (v30);
  if (v31 != v32 && *v31 == v29) {
    uint64_t v37 = v31[1];
  }
  else {
LABEL_30:
  }
    uint64_t v37 = 0;
  uint64_t v89 = v27;
  uint64_t v90 = v37;
  unint64_t v38 = (char *)mlir::ValueRange::dereference_iterator(&v103, 0);
  unint64_t v88 = v38;
  uint64_t v39 = (char *)mlir::ValueRange::dereference_iterator(&v103, 1);
  unint64_t v87 = v39;
  uint64_t v40 = *(void *)(v95 + 24);
  memset(v86, 0, sizeof(v86));
  memset(v85, 0, sizeof(v85));
  Input = (uint64_t **)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95);
  Filter = (uint64_t **)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  {
    if (!matched) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 0;
LABEL_37:
    uint64_t ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86);
    uint64_t v105 = v46;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    if (v47 == 2 || (v45 & 1) == 0)
    {
      if (v47 != 2) {
        goto LABEL_42;
      }
LABEL_53:
      uint64_t v80 = (unsigned int *)v95;
      mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v102, *(const mlir::TypeConverter **)(a1 + 96));
      mlir::TypeConverter::~TypeConverter(v102);
    }
LABEL_39:
    unint64_t IndexFromDim = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v85);
    uint64_t v99 = v48;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&IndexFromDim);
    if (v49 != 2) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 1;
    goto LABEL_53;
  }
  BOOL TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95);
  unsigned __int8 v45 = TransposeRhs;
  if (matched) {
    goto LABEL_37;
  }
  if (TransposeRhs) {
    goto LABEL_39;
  }
LABEL_42:
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v93);
  if (v50 >= 4)
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v51;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v53 = v52;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v52);
    uint64_t v99 = v54;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v53);
    uint64_t v97 = v55;
    unint64_t v38 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unint64_t v88 = v38;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v91);
  if (v56 >= 4)
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v57;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v59 = v58;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v58);
    uint64_t v99 = v60;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v59);
    uint64_t v97 = v61;
    uint64_t v39 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unint64_t v87 = v39;
  }
  if (mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v95))
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v62;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v64 = v63;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v63);
    uint64_t v99 = v65;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v64);
    uint64_t v97 = v66;
    unint64_t v88 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  if (mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95))
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v67;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v69 = v68;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v68);
    uint64_t v99 = v70;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v69);
    uint64_t v97 = v71;
    unint64_t v87 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t ArgOperands = 0;
  unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::Value &,decltype(nullptr)>((mlir::UnknownLoc **)(a4 + 8), v40, (uint64_t *)&v88, (uint64_t *)&v87)- 16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v89);
  if (v73 >= 4)
  {
    uint64_t v100 = v72;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v89, v90);
    uint64_t v105 = v74;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    unint64_t v76 = v75;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v75);
    uint64_t v99 = v77;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v76);
    uint64_t v97 = v78;
    unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t v79 = (unsigned int *)v95;
  uint64_t ArgOperands = (uint64_t)v72;
  mlir::ValueRange::ValueRange(v101, (uint64_t)&ArgOperands, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, v79, v101[0], v101[1]);
  return 1;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::DegammaOp,mlir::anec::Degamma>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9A9210;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        char v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        unint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    unint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    unint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_180819AD8()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::DegammaOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::DegammaOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::DegammaOpGenericAdaptorBase::DegammaOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DegammaOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::DegammaOpGenericAdaptorBase::DegammaOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::DegammaOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DegammaOp &>(mlir::mps::DegammaOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  unint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DegammaOp &>(mlir::mps::DegammaOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::DegammaOp,mlir::anec::Degamma>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  char v5 = a1;
  v70[9] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      unint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          uint64_t v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    unint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  uint64_t v51 = mlir::OpBuilder::create<mlir::anec::Degamma,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DegammaOp &>(mlir::mps::DegammaOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::DegammaOp,mlir::anec::Degamma>::matchAndRewriteWithStaticShapes(mlir::mps::DegammaOp,mlir::mps::DegammaOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Degamma,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.degamma", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.degamma";
    void v21[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Degamma,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::DiracOp,mlir::anec::Dirac>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9A8E90;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_18081A804()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::DiracOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::DiracOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::DiracOpGenericAdaptorBase::DiracOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DiracOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::DiracOpGenericAdaptorBase::DiracOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::DiracOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DiracOp &>(mlir::mps::DiracOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DiracOp &>(mlir::mps::DiracOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::DiracOp,mlir::anec::Dirac>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          uint64_t v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    unint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  uint64_t v51 = mlir::OpBuilder::create<mlir::anec::Dirac,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DiracOp &>(mlir::mps::DiracOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::DiracOp,mlir::anec::Dirac>::matchAndRewriteWithStaticShapes(mlir::mps::DiracOp,mlir::mps::DiracOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Dirac,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.dirac", (const unsigned __int8 *)0xA, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.dirac";
    void v21[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Dirac,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::GeluOp,mlir::anec::Gelu>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9A8C60;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_18081B530()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::GeluOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::GeluOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::GeluOpGenericAdaptorBase::GeluOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GeluOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::GeluOpGenericAdaptorBase::GeluOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::GeluOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GeluOp &>(mlir::mps::GeluOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GeluOp &>(mlir::mps::GeluOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::GeluOp,mlir::anec::Gelu>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          uint64_t v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    unint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  uint64_t v51 = mlir::OpBuilder::create<mlir::anec::Gelu,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GeluOp &>(mlir::mps::GeluOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::GeluOp,mlir::anec::Gelu>::matchAndRewriteWithStaticShapes(mlir::mps::GeluOp,mlir::mps::GeluOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Gelu,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.gelu", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.gelu";
    void v21[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Gelu,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ReluOp,mlir::anec::Relu>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9A8CD0;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_18081C25C()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReluOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReluOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReluOpGenericAdaptorBase::ReluOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReluOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReluOpGenericAdaptorBase::ReluOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ReluOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReluOp &>(mlir::mps::ReluOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReluOp &>(mlir::mps::ReluOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ReluOp,mlir::anec::Relu>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          uint64_t v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    unint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  uint64_t v51 = mlir::OpBuilder::create<mlir::anec::Relu,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReluOp &>(mlir::mps::ReluOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ReluOp,mlir::anec::Relu>::matchAndRewriteWithStaticShapes(mlir::mps::ReluOp,mlir::mps::ReluOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Relu,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.relu", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.relu";
    void v21[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Relu,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::RoundOp,mlir::anec::RoundNearest>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9A90C0;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_18081CF88()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::RoundOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::RoundOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::RoundOpGenericAdaptorBase::RoundOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::RoundOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::RoundOpGenericAdaptorBase::RoundOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::RoundOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::RoundOp &>(mlir::mps::RoundOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::RoundOp &>(mlir::mps::RoundOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::RoundOp,mlir::anec::RoundNearest>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          uint64_t v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    unint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  uint64_t v51 = mlir::OpBuilder::create<mlir::anec::RoundNearest,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::RoundOp &>(mlir::mps::RoundOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::RoundOp,mlir::anec::RoundNearest>::matchAndRewriteWithStaticShapes(mlir::mps::RoundOp,mlir::mps::RoundOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::RoundNearest,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.round_nearest", (const unsigned __int8 *)0x12, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.round_nearest";
    void v21[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::RoundNearest,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SigmoidOp,mlir::anec::HighPrecisionSigmoid>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9A9280;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_18081DCB4()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SigmoidOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SigmoidOp &>(mlir::mps::SigmoidOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      uint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SigmoidOp &>(mlir::mps::SigmoidOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SigmoidOp,mlir::anec::HighPrecisionSigmoid>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          uint64_t v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    unint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  uint64_t v51 = mlir::OpBuilder::create<mlir::anec::HighPrecisionSigmoid,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SigmoidOp &>(mlir::mps::SigmoidOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SigmoidOp,mlir::anec::HighPrecisionSigmoid>::matchAndRewriteWithStaticShapes(mlir::mps::SigmoidOp,mlir::mps::SigmoidOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::HighPrecisionSigmoid,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.high_precision_sigmoid", (const unsigned __int8 *)0x1B, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.high_precision_sigmoid";
    void v21[3] = 27;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::HighPrecisionSigmoid,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SquareOp,mlir::anec::ElementwiseSquare>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9A91A0;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_18081E834()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::SquareOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SquareOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SquareOpGenericAdaptorBase::SquareOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SquareOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SquareOpGenericAdaptorBase::SquareOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SquareOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SquareOp &>(mlir::mps::SquareOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SquareOp &>(mlir::mps::SquareOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SquareOp,mlir::anec::ElementwiseSquare>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          uint64_t v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    unint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  uint64_t v51 = mlir::OpBuilder::create<mlir::anec::ElementwiseSquare,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SquareOp &>(mlir::mps::SquareOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SquareOp,mlir::anec::ElementwiseSquare>::matchAndRewriteWithStaticShapes(mlir::mps::SquareOp,mlir::mps::SquareOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseSquare,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.square", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.square";
    void v21[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseSquare,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SquareRootOp,mlir::anec::Sqrt>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9A8870;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_18081F560()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::SquareRootOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SquareRootOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SquareRootOpGenericAdaptorBase::SquareRootOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SquareRootOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SquareRootOpGenericAdaptorBase::SquareRootOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SquareRootOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SquareRootOp &>(mlir::mps::SquareRootOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SquareRootOp &>(mlir::mps::SquareRootOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SquareRootOp,mlir::anec::Sqrt>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          uint64_t v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    unint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  uint64_t v51 = mlir::OpBuilder::create<mlir::anec::Sqrt,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SquareRootOp &>(mlir::mps::SquareRootOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SquareRootOp,mlir::anec::Sqrt>::matchAndRewriteWithStaticShapes(mlir::mps::SquareRootOp,mlir::mps::SquareRootOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Sqrt,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.sqrt", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.sqrt";
    void v21[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Sqrt,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SwishOp,mlir::anec::Swish>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9A9130;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_18082028C()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::SwishOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SwishOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SwishOpGenericAdaptorBase::SwishOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SwishOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SwishOpGenericAdaptorBase::SwishOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SwishOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SwishOp &>(mlir::mps::SwishOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SwishOp &>(mlir::mps::SwishOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SwishOp,mlir::anec::Swish>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          uint64_t v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    unint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  uint64_t v51 = mlir::OpBuilder::create<mlir::anec::Swish,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SwishOp &>(mlir::mps::SwishOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SwishOp,mlir::anec::Swish>::matchAndRewriteWithStaticShapes(mlir::mps::SwishOp,mlir::mps::SwishOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Swish,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.swish", (const unsigned __int8 *)0xA, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.swish";
    void v21[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Swish,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::TanhOp,mlir::anec::Tanh>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9A8DB0;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_180820FB8()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::TanhOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::TanhOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::TanhOpGenericAdaptorBase::TanhOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::TanhOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::TanhOpGenericAdaptorBase::TanhOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::TanhOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TanhOp &>(mlir::mps::TanhOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TanhOp &>(mlir::mps::TanhOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::TanhOp,mlir::anec::Tanh>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          uint64_t v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    unint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  uint64_t v51 = mlir::OpBuilder::create<mlir::anec::Tanh,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TanhOp &>(mlir::mps::TanhOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::TanhOp,mlir::anec::Tanh>::matchAndRewriteWithStaticShapes(mlir::mps::TanhOp,mlir::mps::TanhOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Tanh,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.tanh", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.tanh";
    void v21[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Tanh,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void *mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::EqualToOp,mlir::anec::ElementwiseEqual>::~ConvertBinaryCompare(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::EqualToOp,mlir::anec::ElementwiseEqual>::~ConvertBinaryCompare(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::EqualToOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::EqualToOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::EqualToOpGenericAdaptorBase::EqualToOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::EqualToOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::EqualToOpGenericAdaptorBase::EqualToOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::EqualToOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::EqualToOp &>(mlir::mps::EqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::EqualToOp &>(mlir::mps::EqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::EqualToOp,mlir::anec::ElementwiseEqual>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void **)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  uint64_t v26 = v28;
  uint64_t v27 = 0x600000000;
  if (v6 < 7)
  {
    uint64_t v29 = v7;
    uint64_t v30 = 0;
    if (!v6)
    {
      int v13 = 0;
      unint64_t v14 = v28;
      goto LABEL_12;
    }
    uint64_t v8 = 0;
    uint64_t v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    uint64_t v8 = v27;
    uint64_t v9 = v26;
    uint64_t v29 = v7;
    uint64_t v30 = 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    uint64_t v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  int v13 = v27;
  unint64_t v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  uint64_t v24 = *((void *)v14 + 1);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp) {
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  uint64_t v29 = 0;
  uint64_t v25 = &v29;
  int v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  unsigned int v17 = v30;
  if (v16)
  {
    if (v30 >= 0x41)
    {
      if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
      {
        if (v29) {
          operator delete[](v29);
        }
        goto LABEL_32;
      }
      uint64_t v18 = (void **)v29;
    }
    else
    {
      uint64_t v18 = &v29;
    }
    BOOL v19 = *v18 == 0;
    if (v17 >= 0x41)
    {
LABEL_22:
      if (v29)
      {
        operator delete[](v29);
        if (!v19) {
          goto LABEL_32;
        }
LABEL_26:
        uint64_t v20 = a4[2];
        if (v20 && mlir::RewriterBase::Listener::classof(v20)) {
        else
        }
          uint64_t v21 = 0;
        goto LABEL_33;
      }
    }
  }
  else
  {
    BOOL v19 = 0;
    if (v30 >= 0x41) {
      goto LABEL_22;
    }
  }
  if (v19) {
    goto LABEL_26;
  }
LABEL_32:
  __int16 v22 = mlir::OpBuilder::create<mlir::anec::ElementwiseEqual,llvm::SmallVector<mlir::Value,6u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v22);
  uint64_t v21 = 1;
LABEL_33:
  if (v26 != v28) {
    free(v26);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::EqualToOp &>(mlir::mps::EqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t mlir::detail::constant_int_op_binder_any_splat::match(mlir::detail::constant_int_op_binder_any_splat *this, mlir::Operation *a2)
{
  v25[1] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 6) + 32))(*((void *)a2 + 6), v4)) {
    return 0;
  }
  v24[0] = v25;
  v24[1] = (void *)0x100000000;
  mlir::Operation::fold((uint64_t)a2, 0, 0, (uint64_t)v24);
  unint64_t v5 = *(void *)v24[0] & 0xFFFFFFFFFFFFFFF8;
  if (v24[0] != v25) {
    free(v24[0]);
  }
  if (!v5) {
    return 0;
  }
  unint64_t v6 = *(void **)(*(void *)(*((void *)a2 - 1) & 0xFFFFFFFFFFFFFFF8) + 136);
  if (v6 == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id
    || v6 == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
  {
    uint64_t v8 = *(void *)this;
    uint64_t v9 = *(void **)(*(void *)v5 + 136);
    BOOL v10 = v9 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id;
    BOOL v11 = v9 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id;
    if (v9 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
      unint64_t v12 = v5;
    }
    else {
      unint64_t v12 = 0;
    }
    v23[0] = v12;
    if (v10)
    {
      mlir::IntegerAttr::getValue(v23, (llvm::APInt *)v24);
      if (*(_DWORD *)(v8 + 8) >= 0x41u && *(void *)v8) {
        operator delete[](*(void **)v8);
      }
      *(void **)uint64_t v8 = v24[0];
      *(_DWORD *)(v8 + 8) = v24[1];
    }
  }
  else
  {
    if (mlir::DenseElementsAttr::classof(v5)) {
      uint64_t v15 = (mlir::detail::constant_int_op_binder_any_splat *)v5;
    }
    else {
      uint64_t v15 = 0;
    }
    v24[0] = v15;
    if (v15)
    {
      uint64_t v15 = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)v24)
          ? (mlir::detail::constant_int_op_binder_any_splat *)v5
          : 0;
      __int16 v22 = v15;
      if (v15)
      {
        uint64_t v16 = *(void *)this;
        mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v22);
        mlir::NamedAttribute::NamedAttribute(v24, (uint64_t)v22, 0);
        this = v22;
        uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v22);
        mlir::NamedAttribute::NamedAttribute(v23, (uint64_t)this, NumElements);
        uint64_t v18 = mlir::DenseElementsAttr::AttributeElementIterator::operator*(v24);
        BOOL v19 = *(void **)(*(void *)v18 + 136);
        BOOL v20 = v19 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id;
        LODWORD(this) = v19 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id;
        if (v19 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
          uint64_t v21 = v18;
        }
        else {
          uint64_t v21 = 0;
        }
        v23[0] = v21;
        if (v20)
        {
          mlir::IntegerAttr::getValue(v23, (llvm::APInt *)v24);
          if (*(_DWORD *)(v16 + 8) >= 0x41u && *(void *)v16) {
            operator delete[](*(void **)v16);
          }
          *(void **)uint64_t v16 = v24[0];
          *(_DWORD *)(v16 + 8) = v24[1];
        }
        LODWORD(v15) = 1;
      }
    }
    return v15 & this;
  }
  return v11;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::EqualToOp,mlir::anec::ElementwiseEqual>::matchAndRewriteWithStaticShapes(mlir::mps::EqualToOp,mlir::mps::EqualToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompare expects the second operand to be non-zero. \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseEqual,llvm::SmallVector<mlir::Value,6u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.equal", (const unsigned __int8 *)0xA, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.equal";
    v15[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::ElementwiseEqual::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseEqual,void>::id) {
    BOOL v10 = v9;
  }
  else {
    BOOL v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

void *mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::EqualToOp,mlir::anec::ElementwiseEqualZero>::~ConvertBinaryCompareToZero(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::EqualToOp,mlir::anec::ElementwiseEqualZero>::~ConvertBinaryCompareToZero(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::EqualToOp,mlir::anec::ElementwiseEqualZero>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void **)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  uint64_t v26 = v28;
  uint64_t v27 = 0x600000000;
  if (v6 < 7)
  {
    uint64_t v29 = v7;
    uint64_t v30 = 0;
    if (!v6)
    {
      int v13 = 0;
      __int16 v14 = v28;
      goto LABEL_12;
    }
    uint64_t v8 = 0;
    uint64_t v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    uint64_t v8 = v27;
    uint64_t v9 = v26;
    uint64_t v29 = v7;
    uint64_t v30 = 0;
  }
  uint64_t v10 = 0;
  BOOL v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    uint64_t v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  int v13 = v27;
  __int16 v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  uint64_t v24 = *((void *)v14 + 1);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp)
  {
LABEL_28:
    uint64_t v22 = a4[2];
    if (v22 && mlir::RewriterBase::Listener::classof(v22)) {
    else
    }
      uint64_t v21 = 0;
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  uint64_t v29 = 0;
  uint64_t v25 = &v29;
  int v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  unsigned int v17 = v30;
  if (!v16)
  {
    BOOL v19 = 0;
    if (v30 < 0x41) {
      goto LABEL_24;
    }
    goto LABEL_22;
  }
  if (v30 >= 0x41)
  {
    if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
    {
      if (v29) {
        operator delete[](v29);
      }
      goto LABEL_28;
    }
    uint64_t v18 = (void **)v29;
  }
  else
  {
    uint64_t v18 = &v29;
  }
  BOOL v19 = *v18 == 0;
  if (v17 >= 0x41)
  {
LABEL_22:
    if (v29) {
      operator delete[](v29);
    }
  }
LABEL_24:
  if (!v19) {
    goto LABEL_28;
  }
  BOOL v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseEqualZero,mlir::Value>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
  uint64_t v21 = 1;
LABEL_32:
  if (v26 != v28) {
    free(v26);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::EqualToOp,mlir::anec::ElementwiseEqualZero>::matchAndRewriteWithStaticShapes(mlir::mps::EqualToOp,mlir::mps::EqualToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompareToZero expects the second operand to be zero. \n");
}

void *mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::NotEqualToOp,mlir::anec::ElementwiseNotEqual>::~ConvertBinaryCompare(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::NotEqualToOp,mlir::anec::ElementwiseNotEqual>::~ConvertBinaryCompare(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::NotEqualToOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::NotEqualToOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::NotEqualToOpGenericAdaptorBase::NotEqualToOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::NotEqualToOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::NotEqualToOpGenericAdaptorBase::NotEqualToOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::NotEqualToOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::NotEqualToOp &>(mlir::mps::NotEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::NotEqualToOp &>(mlir::mps::NotEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::NotEqualToOp,mlir::anec::ElementwiseNotEqual>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void **)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  uint64_t v26 = v28;
  uint64_t v27 = 0x600000000;
  if (v6 < 7)
  {
    uint64_t v29 = v7;
    uint64_t v30 = 0;
    if (!v6)
    {
      int v13 = 0;
      unint64_t v14 = v28;
      goto LABEL_12;
    }
    uint64_t v8 = 0;
    uint64_t v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    uint64_t v8 = v27;
    uint64_t v9 = v26;
    uint64_t v29 = v7;
    uint64_t v30 = 0;
  }
  uint64_t v10 = 0;
  BOOL v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    uint64_t v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  int v13 = v27;
  unint64_t v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  uint64_t v24 = *((void *)v14 + 1);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp) {
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  uint64_t v29 = 0;
  uint64_t v25 = &v29;
  int v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  unsigned int v17 = v30;
  if (v16)
  {
    if (v30 >= 0x41)
    {
      if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
      {
        if (v29) {
          operator delete[](v29);
        }
        goto LABEL_32;
      }
      uint64_t v18 = (void **)v29;
    }
    else
    {
      uint64_t v18 = &v29;
    }
    BOOL v19 = *v18 == 0;
    if (v17 >= 0x41)
    {
LABEL_22:
      if (v29)
      {
        operator delete[](v29);
        if (!v19) {
          goto LABEL_32;
        }
LABEL_26:
        uint64_t v20 = a4[2];
        if (v20 && mlir::RewriterBase::Listener::classof(v20)) {
        else
        }
          uint64_t v21 = 0;
        goto LABEL_33;
      }
    }
  }
  else
  {
    BOOL v19 = 0;
    if (v30 >= 0x41) {
      goto LABEL_22;
    }
  }
  if (v19) {
    goto LABEL_26;
  }
LABEL_32:
  uint64_t v22 = mlir::OpBuilder::create<mlir::anec::ElementwiseNotEqual,llvm::SmallVector<mlir::Value,6u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v22);
  uint64_t v21 = 1;
LABEL_33:
  if (v26 != v28) {
    free(v26);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::NotEqualToOp &>(mlir::mps::NotEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::NotEqualToOp,mlir::anec::ElementwiseNotEqual>::matchAndRewriteWithStaticShapes(mlir::mps::NotEqualToOp,mlir::mps::NotEqualToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompare expects the second operand to be non-zero. \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseNotEqual,llvm::SmallVector<mlir::Value,6u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.not_equal", (const unsigned __int8 *)0xE, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.not_equal";
    v15[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::ElementwiseEqual::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseNotEqual,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

void *mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::NotEqualToOp,mlir::anec::ElementwiseNotEqualZero>::~ConvertBinaryCompareToZero(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::NotEqualToOp,mlir::anec::ElementwiseNotEqualZero>::~ConvertBinaryCompareToZero(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::NotEqualToOp,mlir::anec::ElementwiseNotEqualZero>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void **)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  uint64_t v26 = v28;
  uint64_t v27 = 0x600000000;
  if (v6 < 7)
  {
    uint64_t v29 = v7;
    uint64_t v30 = 0;
    if (!v6)
    {
      int v13 = 0;
      __int16 v14 = v28;
      goto LABEL_12;
    }
    uint64_t v8 = 0;
    uint64_t v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    uint64_t v8 = v27;
    uint64_t v9 = v26;
    uint64_t v29 = v7;
    uint64_t v30 = 0;
  }
  uint64_t v10 = 0;
  BOOL v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    uint64_t v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  int v13 = v27;
  __int16 v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  uint64_t v24 = *((void *)v14 + 1);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp)
  {
LABEL_28:
    uint64_t v22 = a4[2];
    if (v22 && mlir::RewriterBase::Listener::classof(v22)) {
    else
    }
      uint64_t v21 = 0;
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  uint64_t v29 = 0;
  uint64_t v25 = &v29;
  int v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  unsigned int v17 = v30;
  if (!v16)
  {
    BOOL v19 = 0;
    if (v30 < 0x41) {
      goto LABEL_24;
    }
    goto LABEL_22;
  }
  if (v30 >= 0x41)
  {
    if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
    {
      if (v29) {
        operator delete[](v29);
      }
      goto LABEL_28;
    }
    uint64_t v18 = (void **)v29;
  }
  else
  {
    uint64_t v18 = &v29;
  }
  BOOL v19 = *v18 == 0;
  if (v17 >= 0x41)
  {
LABEL_22:
    if (v29) {
      operator delete[](v29);
    }
  }
LABEL_24:
  if (!v19) {
    goto LABEL_28;
  }
  uint64_t v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseNotEqualZero,mlir::Value>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
  uint64_t v21 = 1;
LABEL_32:
  if (v26 != v28) {
    free(v26);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::NotEqualToOp,mlir::anec::ElementwiseNotEqualZero>::matchAndRewriteWithStaticShapes(mlir::mps::NotEqualToOp,mlir::mps::NotEqualToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompareToZero expects the second operand to be zero. \n");
}

void *mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::GreaterThanOp,mlir::anec::ElementwiseGreaterThan>::~ConvertBinaryCompare(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::GreaterThanOp,mlir::anec::ElementwiseGreaterThan>::~ConvertBinaryCompare(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GreaterThanOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::GreaterThanOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::GreaterThanOpGenericAdaptorBase::GreaterThanOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GreaterThanOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::GreaterThanOpGenericAdaptorBase::GreaterThanOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::GreaterThanOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GreaterThanOp &>(mlir::mps::GreaterThanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GreaterThanOp &>(mlir::mps::GreaterThanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::GreaterThanOp,mlir::anec::ElementwiseGreaterThan>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void **)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  uint64_t v26 = v28;
  uint64_t v27 = 0x600000000;
  if (v6 < 7)
  {
    uint64_t v29 = v7;
    uint64_t v30 = 0;
    if (!v6)
    {
      int v13 = 0;
      unint64_t v14 = v28;
      goto LABEL_12;
    }
    uint64_t v8 = 0;
    uint64_t v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    uint64_t v8 = v27;
    uint64_t v9 = v26;
    uint64_t v29 = v7;
    uint64_t v30 = 0;
  }
  uint64_t v10 = 0;
  BOOL v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    uint64_t v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  int v13 = v27;
  unint64_t v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  uint64_t v24 = *((void *)v14 + 1);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp) {
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  uint64_t v29 = 0;
  uint64_t v25 = &v29;
  int v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  unsigned int v17 = v30;
  if (v16)
  {
    if (v30 >= 0x41)
    {
      if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
      {
        if (v29) {
          operator delete[](v29);
        }
        goto LABEL_32;
      }
      uint64_t v18 = (void **)v29;
    }
    else
    {
      uint64_t v18 = &v29;
    }
    BOOL v19 = *v18 == 0;
    if (v17 >= 0x41)
    {
LABEL_22:
      if (v29)
      {
        operator delete[](v29);
        if (!v19) {
          goto LABEL_32;
        }
LABEL_26:
        uint64_t v20 = a4[2];
        if (v20 && mlir::RewriterBase::Listener::classof(v20)) {
        else
        }
          uint64_t v21 = 0;
        goto LABEL_33;
      }
    }
  }
  else
  {
    BOOL v19 = 0;
    if (v30 >= 0x41) {
      goto LABEL_22;
    }
  }
  if (v19) {
    goto LABEL_26;
  }
LABEL_32:
  uint64_t v22 = mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThan,llvm::SmallVector<mlir::Value,6u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v22);
  uint64_t v21 = 1;
LABEL_33:
  if (v26 != v28) {
    free(v26);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GreaterThanOp &>(mlir::mps::GreaterThanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::GreaterThanOp,mlir::anec::ElementwiseGreaterThan>::matchAndRewriteWithStaticShapes(mlir::mps::GreaterThanOp,mlir::mps::GreaterThanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompare expects the second operand to be non-zero. \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThan,llvm::SmallVector<mlir::Value,6u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.greater_than", (const unsigned __int8 *)0x11, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.greater_than";
    v15[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::ElementwiseEqual::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseGreaterThan,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

void *mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::GreaterThanOp,mlir::anec::ElementwiseGreaterThanZero>::~ConvertBinaryCompareToZero(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::GreaterThanOp,mlir::anec::ElementwiseGreaterThanZero>::~ConvertBinaryCompareToZero(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::GreaterThanOp,mlir::anec::ElementwiseGreaterThanZero>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void **)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  uint64_t v26 = v28;
  uint64_t v27 = 0x600000000;
  if (v6 < 7)
  {
    uint64_t v29 = v7;
    uint64_t v30 = 0;
    if (!v6)
    {
      int v13 = 0;
      __int16 v14 = v28;
      goto LABEL_12;
    }
    uint64_t v8 = 0;
    uint64_t v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    uint64_t v8 = v27;
    uint64_t v9 = v26;
    uint64_t v29 = v7;
    uint64_t v30 = 0;
  }
  uint64_t v10 = 0;
  BOOL v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    uint64_t v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  int v13 = v27;
  __int16 v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  uint64_t v24 = *((void *)v14 + 1);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp)
  {
LABEL_28:
    uint64_t v22 = a4[2];
    if (v22 && mlir::RewriterBase::Listener::classof(v22)) {
    else
    }
      uint64_t v21 = 0;
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  uint64_t v29 = 0;
  uint64_t v25 = &v29;
  int v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  unsigned int v17 = v30;
  if (!v16)
  {
    BOOL v19 = 0;
    if (v30 < 0x41) {
      goto LABEL_24;
    }
    goto LABEL_22;
  }
  if (v30 >= 0x41)
  {
    if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
    {
      if (v29) {
        operator delete[](v29);
      }
      goto LABEL_28;
    }
    uint64_t v18 = (void **)v29;
  }
  else
  {
    uint64_t v18 = &v29;
  }
  BOOL v19 = *v18 == 0;
  if (v17 >= 0x41)
  {
LABEL_22:
    if (v29) {
      operator delete[](v29);
    }
  }
LABEL_24:
  if (!v19) {
    goto LABEL_28;
  }
  uint64_t v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThanZero,mlir::Value &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
  uint64_t v21 = 1;
LABEL_32:
  if (v26 != v28) {
    free(v26);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::GreaterThanOp,mlir::anec::ElementwiseGreaterThanZero>::matchAndRewriteWithStaticShapes(mlir::mps::GreaterThanOp,mlir::mps::GreaterThanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompareToZero expects the second operand to be zero. \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThanZero,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.greater_than_zero", (const unsigned __int8 *)0x16, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.greater_than_zero";
    v15[3] = 22;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::ElementwiseGreaterThanEqualZero::build(a1, (uint64_t)v17, *a3);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseGreaterThanZero,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

void *mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::GreaterThanOrEqualToOp,mlir::anec::ElementwiseGreaterThanEqual>::~ConvertBinaryCompare(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::GreaterThanOrEqualToOp,mlir::anec::ElementwiseGreaterThanEqual>::~ConvertBinaryCompare(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GreaterThanOrEqualToOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::GreaterThanOrEqualToOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::GreaterThanOrEqualToOpGenericAdaptorBase::GreaterThanOrEqualToOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GreaterThanOrEqualToOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::GreaterThanOrEqualToOpGenericAdaptorBase::GreaterThanOrEqualToOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::GreaterThanOrEqualToOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GreaterThanOrEqualToOp &>(mlir::mps::GreaterThanOrEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GreaterThanOrEqualToOp &>(mlir::mps::GreaterThanOrEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::GreaterThanOrEqualToOp,mlir::anec::ElementwiseGreaterThanEqual>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void **)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  uint64_t v26 = v28;
  uint64_t v27 = 0x600000000;
  if (v6 < 7)
  {
    uint64_t v29 = v7;
    uint64_t v30 = 0;
    if (!v6)
    {
      int v13 = 0;
      unint64_t v14 = v28;
      goto LABEL_12;
    }
    uint64_t v8 = 0;
    uint64_t v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    uint64_t v8 = v27;
    uint64_t v9 = v26;
    uint64_t v29 = v7;
    uint64_t v30 = 0;
  }
  uint64_t v10 = 0;
  BOOL v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    uint64_t v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  int v13 = v27;
  unint64_t v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  uint64_t v24 = *((void *)v14 + 1);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp) {
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  uint64_t v29 = 0;
  uint64_t v25 = &v29;
  int v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  unsigned int v17 = v30;
  if (v16)
  {
    if (v30 >= 0x41)
    {
      if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
      {
        if (v29) {
          operator delete[](v29);
        }
        goto LABEL_32;
      }
      uint64_t v18 = (void **)v29;
    }
    else
    {
      uint64_t v18 = &v29;
    }
    BOOL v19 = *v18 == 0;
    if (v17 >= 0x41)
    {
LABEL_22:
      if (v29)
      {
        operator delete[](v29);
        if (!v19) {
          goto LABEL_32;
        }
LABEL_26:
        uint64_t v20 = a4[2];
        if (v20 && mlir::RewriterBase::Listener::classof(v20)) {
        else
        }
          uint64_t v21 = 0;
        goto LABEL_33;
      }
    }
  }
  else
  {
    BOOL v19 = 0;
    if (v30 >= 0x41) {
      goto LABEL_22;
    }
  }
  if (v19) {
    goto LABEL_26;
  }
LABEL_32:
  uint64_t v22 = mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThanEqual,llvm::SmallVector<mlir::Value,6u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v22);
  uint64_t v21 = 1;
LABEL_33:
  if (v26 != v28) {
    free(v26);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GreaterThanOrEqualToOp &>(mlir::mps::GreaterThanOrEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::GreaterThanOrEqualToOp,mlir::anec::ElementwiseGreaterThanEqual>::matchAndRewriteWithStaticShapes(mlir::mps::GreaterThanOrEqualToOp,mlir::mps::GreaterThanOrEqualToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompare expects the second operand to be non-zero. \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThanEqual,llvm::SmallVector<mlir::Value,6u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.greater_than_equal", (const unsigned __int8 *)0x17, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.greater_than_equal";
    v15[3] = 23;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::ElementwiseEqual::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseGreaterThanEqual,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

void *mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::GreaterThanOrEqualToOp,mlir::anec::ElementwiseGreaterThanEqualZero>::~ConvertBinaryCompareToZero(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::GreaterThanOrEqualToOp,mlir::anec::ElementwiseGreaterThanEqualZero>::~ConvertBinaryCompareToZero(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::GreaterThanOrEqualToOp,mlir::anec::ElementwiseGreaterThanEqualZero>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void **)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  uint64_t v26 = v28;
  uint64_t v27 = 0x600000000;
  if (v6 < 7)
  {
    uint64_t v29 = v7;
    uint64_t v30 = 0;
    if (!v6)
    {
      int v13 = 0;
      __int16 v14 = v28;
      goto LABEL_12;
    }
    uint64_t v8 = 0;
    uint64_t v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    uint64_t v8 = v27;
    uint64_t v9 = v26;
    uint64_t v29 = v7;
    uint64_t v30 = 0;
  }
  uint64_t v10 = 0;
  BOOL v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    uint64_t v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  int v13 = v27;
  __int16 v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  uint64_t v24 = *((void *)v14 + 1);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp)
  {
LABEL_28:
    uint64_t v22 = a4[2];
    if (v22 && mlir::RewriterBase::Listener::classof(v22)) {
    else
    }
      uint64_t v21 = 0;
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  uint64_t v29 = 0;
  uint64_t v25 = &v29;
  int v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  unsigned int v17 = v30;
  if (!v16)
  {
    BOOL v19 = 0;
    if (v30 < 0x41) {
      goto LABEL_24;
    }
    goto LABEL_22;
  }
  if (v30 >= 0x41)
  {
    if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
    {
      if (v29) {
        operator delete[](v29);
      }
      goto LABEL_28;
    }
    uint64_t v18 = (void **)v29;
  }
  else
  {
    uint64_t v18 = &v29;
  }
  BOOL v19 = *v18 == 0;
  if (v17 >= 0x41)
  {
LABEL_22:
    if (v29) {
      operator delete[](v29);
    }
  }
LABEL_24:
  if (!v19) {
    goto LABEL_28;
  }
  uint64_t v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThanEqualZero,mlir::Value &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
  uint64_t v21 = 1;
LABEL_32:
  if (v26 != v28) {
    free(v26);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::GreaterThanOrEqualToOp,mlir::anec::ElementwiseGreaterThanEqualZero>::matchAndRewriteWithStaticShapes(mlir::mps::GreaterThanOrEqualToOp,mlir::mps::GreaterThanOrEqualToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompareToZero expects the second operand to be zero. \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThanEqualZero,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.greater_than_equal_zero", (const unsigned __int8 *)0x1C, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.greater_than_equal_zero";
    v15[3] = 28;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::ElementwiseGreaterThanEqualZero::build(a1, (uint64_t)v17, *a3);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseGreaterThanEqualZero,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

void *mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::LessThanOp,mlir::anec::ElementwiseLessThan>::~ConvertBinaryCompare(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::LessThanOp,mlir::anec::ElementwiseLessThan>::~ConvertBinaryCompare(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::LessThanOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::LessThanOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::LessThanOpGenericAdaptorBase::LessThanOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::LessThanOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::LessThanOpGenericAdaptorBase::LessThanOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::LessThanOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LessThanOp &>(mlir::mps::LessThanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LessThanOp &>(mlir::mps::LessThanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::LessThanOp,mlir::anec::ElementwiseLessThan>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void **)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  uint64_t v26 = v28;
  uint64_t v27 = 0x600000000;
  if (v6 < 7)
  {
    uint64_t v29 = v7;
    uint64_t v30 = 0;
    if (!v6)
    {
      int v13 = 0;
      unint64_t v14 = v28;
      goto LABEL_12;
    }
    uint64_t v8 = 0;
    uint64_t v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    uint64_t v8 = v27;
    uint64_t v9 = v26;
    uint64_t v29 = v7;
    uint64_t v30 = 0;
  }
  uint64_t v10 = 0;
  BOOL v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    uint64_t v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  int v13 = v27;
  unint64_t v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  uint64_t v24 = *((void *)v14 + 1);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp) {
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  uint64_t v29 = 0;
  uint64_t v25 = &v29;
  int v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  unsigned int v17 = v30;
  if (v16)
  {
    if (v30 >= 0x41)
    {
      if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
      {
        if (v29) {
          operator delete[](v29);
        }
        goto LABEL_32;
      }
      uint64_t v18 = (void **)v29;
    }
    else
    {
      uint64_t v18 = &v29;
    }
    BOOL v19 = *v18 == 0;
    if (v17 >= 0x41)
    {
LABEL_22:
      if (v29)
      {
        operator delete[](v29);
        if (!v19) {
          goto LABEL_32;
        }
LABEL_26:
        uint64_t v20 = a4[2];
        if (v20 && mlir::RewriterBase::Listener::classof(v20)) {
        else
        }
          uint64_t v21 = 0;
        goto LABEL_33;
      }
    }
  }
  else
  {
    BOOL v19 = 0;
    if (v30 >= 0x41) {
      goto LABEL_22;
    }
  }
  if (v19) {
    goto LABEL_26;
  }
LABEL_32:
  uint64_t v22 = mlir::OpBuilder::create<mlir::anec::ElementwiseLessThan,llvm::SmallVector<mlir::Value,6u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v22);
  uint64_t v21 = 1;
LABEL_33:
  if (v26 != v28) {
    free(v26);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LessThanOp &>(mlir::mps::LessThanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::LessThanOp,mlir::anec::ElementwiseLessThan>::matchAndRewriteWithStaticShapes(mlir::mps::LessThanOp,mlir::mps::LessThanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompare expects the second operand to be non-zero. \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseLessThan,llvm::SmallVector<mlir::Value,6u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.less_than", (const unsigned __int8 *)0xE, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.less_than";
    v15[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::ElementwiseEqual::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseLessThan,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

void *mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::LessThanOp,mlir::anec::ElementwiseLessThanZero>::~ConvertBinaryCompareToZero(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::LessThanOp,mlir::anec::ElementwiseLessThanZero>::~ConvertBinaryCompareToZero(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::LessThanOp,mlir::anec::ElementwiseLessThanZero>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void **)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  uint64_t v26 = v28;
  uint64_t v27 = 0x600000000;
  if (v6 < 7)
  {
    uint64_t v29 = v7;
    uint64_t v30 = 0;
    if (!v6)
    {
      int v13 = 0;
      __int16 v14 = v28;
      goto LABEL_12;
    }
    uint64_t v8 = 0;
    uint64_t v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    uint64_t v8 = v27;
    uint64_t v9 = v26;
    uint64_t v29 = v7;
    uint64_t v30 = 0;
  }
  uint64_t v10 = 0;
  BOOL v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    uint64_t v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  int v13 = v27;
  __int16 v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  uint64_t v24 = *((void *)v14 + 1);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp)
  {
LABEL_28:
    uint64_t v22 = a4[2];
    if (v22 && mlir::RewriterBase::Listener::classof(v22)) {
    else
    }
      uint64_t v21 = 0;
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  uint64_t v29 = 0;
  uint64_t v25 = &v29;
  int v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  unsigned int v17 = v30;
  if (!v16)
  {
    BOOL v19 = 0;
    if (v30 < 0x41) {
      goto LABEL_24;
    }
    goto LABEL_22;
  }
  if (v30 >= 0x41)
  {
    if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
    {
      if (v29) {
        operator delete[](v29);
      }
      goto LABEL_28;
    }
    uint64_t v18 = (void **)v29;
  }
  else
  {
    uint64_t v18 = &v29;
  }
  BOOL v19 = *v18 == 0;
  if (v17 >= 0x41)
  {
LABEL_22:
    if (v29) {
      operator delete[](v29);
    }
  }
LABEL_24:
  if (!v19) {
    goto LABEL_28;
  }
  uint64_t v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseLessThanZero,mlir::Value &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
  uint64_t v21 = 1;
LABEL_32:
  if (v26 != v28) {
    free(v26);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::LessThanOp,mlir::anec::ElementwiseLessThanZero>::matchAndRewriteWithStaticShapes(mlir::mps::LessThanOp,mlir::mps::LessThanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompareToZero expects the second operand to be zero. \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseLessThanZero,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.less_than_zero", (const unsigned __int8 *)0x13, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.less_than_zero";
    v15[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::ElementwiseGreaterThanEqualZero::build(a1, (uint64_t)v17, *a3);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseLessThanZero,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

void *mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::LessThanOrEqualToOp,mlir::anec::ElementwiseLessThanEqual>::~ConvertBinaryCompare(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::LessThanOrEqualToOp,mlir::anec::ElementwiseLessThanEqual>::~ConvertBinaryCompare(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::LessThanOrEqualToOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::LessThanOrEqualToOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::LessThanOrEqualToOpGenericAdaptorBase::LessThanOrEqualToOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::LessThanOrEqualToOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::LessThanOrEqualToOpGenericAdaptorBase::LessThanOrEqualToOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::LessThanOrEqualToOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LessThanOrEqualToOp &>(mlir::mps::LessThanOrEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LessThanOrEqualToOp &>(mlir::mps::LessThanOrEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::LessThanOrEqualToOp,mlir::anec::ElementwiseLessThanEqual>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void **)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  uint64_t v26 = v28;
  uint64_t v27 = 0x600000000;
  if (v6 < 7)
  {
    uint64_t v29 = v7;
    uint64_t v30 = 0;
    if (!v6)
    {
      int v13 = 0;
      unint64_t v14 = v28;
      goto LABEL_12;
    }
    uint64_t v8 = 0;
    uint64_t v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    uint64_t v8 = v27;
    uint64_t v9 = v26;
    uint64_t v29 = v7;
    uint64_t v30 = 0;
  }
  uint64_t v10 = 0;
  BOOL v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    uint64_t v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  int v13 = v27;
  unint64_t v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  uint64_t v24 = *((void *)v14 + 1);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp) {
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  uint64_t v29 = 0;
  uint64_t v25 = &v29;
  int v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  unsigned int v17 = v30;
  if (v16)
  {
    if (v30 >= 0x41)
    {
      if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
      {
        if (v29) {
          operator delete[](v29);
        }
        goto LABEL_32;
      }
      uint64_t v18 = (void **)v29;
    }
    else
    {
      uint64_t v18 = &v29;
    }
    BOOL v19 = *v18 == 0;
    if (v17 >= 0x41)
    {
LABEL_22:
      if (v29)
      {
        operator delete[](v29);
        if (!v19) {
          goto LABEL_32;
        }
LABEL_26:
        uint64_t v20 = a4[2];
        if (v20 && mlir::RewriterBase::Listener::classof(v20)) {
        else
        }
          uint64_t v21 = 0;
        goto LABEL_33;
      }
    }
  }
  else
  {
    BOOL v19 = 0;
    if (v30 >= 0x41) {
      goto LABEL_22;
    }
  }
  if (v19) {
    goto LABEL_26;
  }
LABEL_32:
  uint64_t v22 = mlir::OpBuilder::create<mlir::anec::ElementwiseLessThanEqual,llvm::SmallVector<mlir::Value,6u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v22);
  uint64_t v21 = 1;
LABEL_33:
  if (v26 != v28) {
    free(v26);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LessThanOrEqualToOp &>(mlir::mps::LessThanOrEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::LessThanOrEqualToOp,mlir::anec::ElementwiseLessThanEqual>::matchAndRewriteWithStaticShapes(mlir::mps::LessThanOrEqualToOp,mlir::mps::LessThanOrEqualToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompare expects the second operand to be non-zero. \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseLessThanEqual,llvm::SmallVector<mlir::Value,6u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.less_than_equal", (const unsigned __int8 *)0x14, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.less_than_equal";
    v15[3] = 20;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::ElementwiseEqual::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseLessThanEqual,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

void *mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::LessThanOrEqualToOp,mlir::anec::ElementwiseLessThanEqualZero>::~ConvertBinaryCompareToZero(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::LessThanOrEqualToOp,mlir::anec::ElementwiseLessThanEqualZero>::~ConvertBinaryCompareToZero(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::LessThanOrEqualToOp,mlir::anec::ElementwiseLessThanEqualZero>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void **)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  uint64_t v26 = v28;
  uint64_t v27 = 0x600000000;
  if (v6 < 7)
  {
    uint64_t v29 = v7;
    uint64_t v30 = 0;
    if (!v6)
    {
      int v13 = 0;
      __int16 v14 = v28;
      goto LABEL_12;
    }
    uint64_t v8 = 0;
    uint64_t v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    uint64_t v8 = v27;
    uint64_t v9 = v26;
    uint64_t v29 = v7;
    uint64_t v30 = 0;
  }
  uint64_t v10 = 0;
  BOOL v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    uint64_t v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  int v13 = v27;
  __int16 v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  uint64_t v24 = *((void *)v14 + 1);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp)
  {
LABEL_28:
    uint64_t v22 = a4[2];
    if (v22 && mlir::RewriterBase::Listener::classof(v22)) {
    else
    }
      uint64_t v21 = 0;
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  uint64_t v29 = 0;
  uint64_t v25 = &v29;
  int v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  unsigned int v17 = v30;
  if (!v16)
  {
    BOOL v19 = 0;
    if (v30 < 0x41) {
      goto LABEL_24;
    }
    goto LABEL_22;
  }
  if (v30 >= 0x41)
  {
    if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
    {
      if (v29) {
        operator delete[](v29);
      }
      goto LABEL_28;
    }
    uint64_t v18 = (void **)v29;
  }
  else
  {
    uint64_t v18 = &v29;
  }
  BOOL v19 = *v18 == 0;
  if (v17 >= 0x41)
  {
LABEL_22:
    if (v29) {
      operator delete[](v29);
    }
  }
LABEL_24:
  if (!v19) {
    goto LABEL_28;
  }
  uint64_t v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseLessThanEqualZero,mlir::Value &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
  uint64_t v21 = 1;
LABEL_32:
  if (v26 != v28) {
    free(v26);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::LessThanOrEqualToOp,mlir::anec::ElementwiseLessThanEqualZero>::matchAndRewriteWithStaticShapes(mlir::mps::LessThanOrEqualToOp,mlir::mps::LessThanOrEqualToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompareToZero expects the second operand to be zero. \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseLessThanEqualZero,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.less_than_equal_zero", (const unsigned __int8 *)0x19, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.less_than_equal_zero";
    v15[3] = 25;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::ElementwiseGreaterThanEqualZero::build(a1, (uint64_t)v17, *a3);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseLessThanEqualZero,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::NotOp,mlir::anec::ElementwiseEqualZero>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9A8B10;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        unint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    BOOL v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    BOOL v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_180826DE4()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::NotOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::NotOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::NotOpGenericAdaptorBase::NotOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::NotOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::NotOpGenericAdaptorBase::NotOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::NotOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::NotOp &>(mlir::mps::NotOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::NotOp &>(mlir::mps::NotOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::NotOp,mlir::anec::ElementwiseEqualZero>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      BOOL v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          uint64_t v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    unint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  uint64_t v51 = mlir::OpBuilder::create<mlir::anec::ElementwiseEqualZero,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::NotOp &>(mlir::mps::NotOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::NotOp,mlir::anec::ElementwiseEqualZero>::matchAndRewriteWithStaticShapes(mlir::mps::NotOp,mlir::mps::NotOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseEqualZero,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.equal_zero", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.equal_zero";
    void v21[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseEqualZero,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void *mlir::anonymous namespace'::ConvertPool<mlir::mps::PoolAvgOp,mlir::anec::AveragePool>::~ConvertPool(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertPool<mlir::mps::PoolAvgOp,mlir::anec::AveragePool>::~ConvertPool(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolAvgOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolAvgOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::PoolAvgOpGenericAdaptorBase::PoolAvgOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolAvgOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::PoolAvgOpGenericAdaptorBase::PoolAvgOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::PoolAvgOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 96);
  uint64_t v9 = *(void *)(a3 + 104);
  uint64_t v37 = v8;
  uint64_t v38 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v37 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v38 = v23;
        if (v37)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v37);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v34[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v35 = 259;
      v32[0] = v34;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolAvgOp &>(mlir::mps::PoolAvgOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v32);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 96);
        long long v29 = *(_OWORD *)(a3 + 64);
        v36[5] = *(_OWORD *)(a3 + 80);
        v36[6] = v28;
        long long v30 = *(_OWORD *)(a3 + 16);
        v36[0] = *(_OWORD *)a3;
        v36[1] = v30;
        long long v31 = *(_OWORD *)(a3 + 32);
        v36[3] = *(_OWORD *)(a3 + 48);
        v36[4] = v29;
        v36[2] = v31;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v36, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v37, v10);
    v32[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v32[1] = v13;
    if (v32[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v38;
    if (v37 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v35 = 259;
  unint64_t v33 = v34;
  v34[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolAvgOp &>(mlir::mps::PoolAvgOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v33);
  }
  return result;
}

uint64_t llvm::SmallVectorImpl<unsigned long long>::resize(uint64_t result, unint64_t a2, unint64_t a3)
{
  unint64_t v3 = *(unsigned int *)(result + 8);
  unint64_t v4 = a2 - v3;
  if (a2 != v3)
  {
    int v5 = a2;
    if (a2 < v3)
    {
LABEL_11:
      *(_DWORD *)(result + 8) = v5;
      return result;
    }
    if (*(unsigned int *)(result + 12) < a2)
    {
      uint64_t v14 = result;
      unint64_t v12 = a2 - v3;
      unint64_t v13 = a3;
      llvm::SmallVectorBase<unsigned int>::grow_pod(result, (void *)(result + 16), a2, 8);
      unint64_t v4 = v12;
      a3 = v13;
      uint64_t result = v14;
      unint64_t v3 = *(unsigned int *)(v14 + 8);
      if (v12) {
        goto LABEL_5;
      }
    }
    else if (v4)
    {
LABEL_5:
      uint64_t v6 = *(void *)result + 8 * v3;
      uint64_t v7 = (unint64_t *)v6;
      unint64_t v8 = v4;
      if (v4 < 4) {
        goto LABEL_17;
      }
      uint64_t v7 = (unint64_t *)(v6 + 8 * (v4 & 0xFFFFFFFFFFFFFFFCLL));
      unint64_t v8 = v4 & 3;
      int64x2_t v9 = vdupq_n_s64(a3);
      uint64_t v10 = (int64x2_t *)(v6 + 16);
      unint64_t v11 = v4 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v10[-1] = v9;
        *uint64_t v10 = v9;
        v10 += 2;
        v11 -= 4;
      }
      while (v11);
      if (v4 != (v4 & 0xFFFFFFFFFFFFFFFCLL))
      {
LABEL_17:
        do
        {
          *v7++ = a3;
          --v8;
        }
        while (v8);
      }
    }
    int v5 = v3 + v4;
    goto LABEL_11;
  }
  return result;
}

uint64_t mlir::anonymous namespace'::updatePoolPadding(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t *a5, uint64_t a6, unint64_t **a7, int a8, char a9)
{
  v55[0] = a1;
  v55[1] = a2;
  uint64_t v13 = *a3;
  uint64_t v14 = *a5;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55);
  uint64_t v16 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55)
                  + 8 * (v15 - 4));
  uint64_t v17 = v16 % v14;
  if (v16 % v14) {
    uint64_t v18 = v16 % v14;
  }
  else {
    uint64_t v18 = v14;
  }
  unint64_t v19 = (v13 - v18) & ~((v13 - v18) >> 63);
  unint64_t v20 = v19 >> 1;
  uint64_t v21 = *a7;
  unint64_t v22 = v19 - (v19 >> 1);
  *uint64_t v21 = v20;
  v21[1] = v22;
  if (a9)
  {
    *uint64_t v21 = v22;
    v21[1] = v20;
    unint64_t v22 = v20;
  }
  if (v17) {
    BOOL v23 = a8 == 0;
  }
  else {
    BOOL v23 = 1;
  }
  if (!v23) {
    v21[1] = v22 + 1;
  }
  uint64_t v24 = a3[1];
  uint64_t v25 = a5[1];
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55);
  uint64_t v27 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55)
                  + 8 * (v26 - 3));
  uint64_t v28 = v27 % v25;
  if (v27 % v25) {
    uint64_t v29 = v27 % v25;
  }
  else {
    uint64_t v29 = v25;
  }
  unint64_t v30 = (v24 - v29) & ~((v24 - v29) >> 63);
  unint64_t v31 = v30 >> 1;
  __int16 v32 = *a7;
  unint64_t v33 = v30 - (v30 >> 1);
  void v32[2] = v31;
  void v32[3] = v33;
  if (a9)
  {
    void v32[2] = v33;
    void v32[3] = v31;
    unint64_t v33 = v31;
  }
  if (v28) {
    BOOL v34 = a8 == 0;
  }
  else {
    BOOL v34 = 1;
  }
  if (!v34) {
    void v32[3] = v33 + 1;
  }
  uint64_t v35 = a3[2];
  uint64_t v36 = a5[2];
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55);
  uint64_t v38 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55)
                  + 8 * (v37 - 2))
      % v36;
  if (v38) {
    uint64_t v39 = v38;
  }
  else {
    uint64_t v39 = v36;
  }
  unint64_t v40 = (v35 - v39) & ~((v35 - v39) >> 63);
  unint64_t v41 = v40 >> 1;
  unint64_t v42 = *a7;
  unint64_t v43 = v40 - (v40 >> 1);
  v42[4] = v41;
  v42[5] = v43;
  if (a9)
  {
    v42[4] = v43;
    v42[5] = v41;
    unint64_t v43 = v41;
  }
  if (v38 && a8) {
    v42[5] = v43 + 1;
  }
  uint64_t v44 = a3[3];
  uint64_t v45 = a5[3];
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55);
  unsigned int v47 = v46 - 1;
  uint64_t result = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55);
  uint64_t v49 = *(void *)(result + 8 * v47) % v45;
  if (v49) {
    uint64_t v50 = *(void *)(result + 8 * v47) % v45;
  }
  else {
    uint64_t v50 = v45;
  }
  unint64_t v51 = (v44 - v50) & ~((v44 - v50) >> 63);
  unint64_t v52 = v51 >> 1;
  unint64_t v53 = *a7;
  unint64_t v54 = v51 - (v51 >> 1);
  v53[6] = v52;
  v53[7] = v54;
  if (a9)
  {
    v53[6] = v54;
    v53[7] = v52;
    unint64_t v54 = v52;
  }
  if (v49)
  {
    if (a8) {
      v53[7] = v54 + 1;
    }
  }
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::AveragePool,mlir::Value &,mlir::NamedAttrList &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.average_pool", (const unsigned __int8 *)0x11, Context);
  if (!v10)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"anec.average_pool";
    v19[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v9);
  unint64_t v11 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::AveragePool::build(a1, (uint64_t)v21, a3, 1, v11, v12);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::AveragePool,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

char *std::__rotate[abi:nn180100]<std::_ClassicAlgPolicy,unsigned long long *,unsigned long long *>(char *__src, char *a2, char *a3)
{
  unint64_t v4 = a3;
  if (__src != a2)
  {
    if (a2 == a3)
    {
      return __src;
    }
    else if (__src + 8 == a2)
    {
      uint64_t v13 = *(void *)__src;
      int64_t v14 = a3 - a2;
      memmove(__src, a2, a3 - a2);
      unint64_t v4 = &__src[v14];
      *(void *)unint64_t v4 = v13;
    }
    else if (a2 + 8 == a3)
    {
      uint64_t v15 = *((void *)a3 - 1);
      unint64_t v4 = __src + 8;
      size_t v16 = a3 - 8 - __src;
      if (a3 - 8 != __src) {
        memmove(__src + 8, __src, v16);
      }
      *(void *)__src = v15;
    }
    else
    {
      uint64_t v6 = (a2 - __src) >> 3;
      uint64_t v7 = (a3 - a2) >> 3;
      if (v6 == v7)
      {
        uint64_t v8 = 0;
        do
        {
          uint64_t v9 = *(void *)&__src[v8];
          *(void *)&__src[v8] = *(void *)&a2[v8];
          char v10 = &__src[v8 + 8];
          *(void *)&a2[v8] = v9;
          uint64_t v11 = (uint64_t)&a2[v8 + 8];
          v8 += 8;
        }
        while (v10 != a2 && v11 != (void)a3);
        return a2;
      }
      else
      {
        uint64_t v17 = (a3 - a2) >> 3;
        uint64_t v18 = (a2 - __src) >> 3;
        do
        {
          uint64_t v19 = v18;
          uint64_t v18 = v17;
          uint64_t v17 = v19 % v17;
        }
        while (v17);
        if (v18)
        {
          __int16 v20 = &__src[8 * v18];
          do
          {
            uint64_t v22 = *((void *)v20 - 1);
            v20 -= 8;
            uint64_t v21 = v22;
            BOOL v23 = &v20[8 * v6];
            uint64_t v24 = v20;
            do
            {
              uint64_t v25 = v24;
              uint64_t v24 = v23;
              *(void *)uint64_t v25 = *(void *)v23;
              uint64_t v26 = (a3 - v23) >> 3;
              BOOL v27 = __OFSUB__(v6, v26);
              uint64_t v29 = v6 - v26;
              char v28 = (v29 < 0) ^ v27;
              BOOL v23 = &__src[8 * v29];
              if (v28) {
                BOOL v23 = &v24[8 * v6];
              }
            }
            while (v23 != v20);
            *(void *)uint64_t v24 = v21;
          }
          while (v20 != __src);
        }
        return &__src[8 * v7];
      }
    }
  }
  return v4;
}

void *mlir::anonymous namespace'::ConvertPool<mlir::mps::PoolL2NormOp,mlir::anec::L2NormPool>::~ConvertPool(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  unint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertPool<mlir::mps::PoolL2NormOp,mlir::anec::L2NormPool>::~ConvertPool(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  unint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolL2NormOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolL2NormOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::PoolL2NormOpGenericAdaptorBase::PoolL2NormOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolL2NormOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::PoolL2NormOpGenericAdaptorBase::PoolL2NormOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::PoolL2NormOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 96);
  uint64_t v9 = *(void *)(a3 + 104);
  int v37 = v8;
  uint64_t v38 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        int v37 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v38 = v23;
        if (v37)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v37);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v34[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v35 = 259;
      v32[0] = v34;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(mlir::mps::PoolL2NormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v32);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 96);
        long long v29 = *(_OWORD *)(a3 + 64);
        v36[5] = *(_OWORD *)(a3 + 80);
        v36[6] = v28;
        long long v30 = *(_OWORD *)(a3 + 16);
        v36[0] = *(_OWORD *)a3;
        v36[1] = v30;
        long long v31 = *(_OWORD *)(a3 + 32);
        v36[3] = *(_OWORD *)(a3 + 48);
        v36[4] = v29;
        v36[2] = v31;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v36, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v37, v10);
    v32[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v32[1] = v13;
    if (v32[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v38;
    if (v37 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v35 = 259;
  unint64_t v33 = v34;
  v34[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(mlir::mps::PoolL2NormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v33);
  }
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::L2NormPool,mlir::Value &,mlir::NamedAttrList &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.l2norm_pool", (const unsigned __int8 *)0x10, Context);
  if (!v10)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"anec.l2norm_pool";
    v19[3] = 16;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v9);
  uint64_t v11 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::L2NormPool::build(a1, (uint64_t)v21, a3, 1, v11, v12);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::L2NormPool,void>::id) {
    unint64_t v14 = v13;
  }
  else {
    unint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void *mlir::anonymous namespace'::ConvertPool<mlir::mps::PoolMaxOp,mlir::anec::MaxPool>::~ConvertPool(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  unint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertPool<mlir::mps::PoolMaxOp,mlir::anec::MaxPool>::~ConvertPool(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  unint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolMaxOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolMaxOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::PoolMaxOpGenericAdaptorBase::PoolMaxOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolMaxOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::PoolMaxOpGenericAdaptorBase::PoolMaxOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::PoolMaxOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 112);
  uint64_t v9 = *(void *)(a3 + 120);
  int v37 = v8;
  uint64_t v38 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        int v37 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v38 = v23;
        if (v37)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v37);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v34[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v35 = 259;
      v32[0] = v34;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolMaxOp &>(mlir::mps::PoolMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v32);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 112);
        v36[6] = *(_OWORD *)(a3 + 96);
        _OWORD v36[7] = v28;
        long long v29 = *(_OWORD *)(a3 + 80);
        v36[4] = *(_OWORD *)(a3 + 64);
        v36[5] = v29;
        long long v30 = *(_OWORD *)(a3 + 16);
        v36[0] = *(_OWORD *)a3;
        v36[1] = v30;
        long long v31 = *(_OWORD *)(a3 + 48);
        v36[2] = *(_OWORD *)(a3 + 32);
        v36[3] = v31;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v36, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v37, v10);
    v32[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v32[1] = v13;
    if (v32[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v38;
    if (v37 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v35 = 259;
  unint64_t v33 = v34;
  v34[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolMaxOp &>(mlir::mps::PoolMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v33);
  }
  return result;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolMaxOp &>(uint64_t a1, uint64_t *a2, unsigned char *a3)
{
  char v3 = 1;
  char v9 = 1;
  if (*a3)
  {
    uint64_t v7 = a3;
    char v3 = 3;
  }
  char v8 = v3;
  uint64_t v4 = *a2;
  uint64_t v10 = &v7;
  uint64_t v5 = *(void *)(a1 + 16);
  if (!v5) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16));
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v5 + 64))(v5, *(void *)(v4 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolMaxOp &>(mlir::mps::PoolMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v10);
  }
  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolMaxOp &>(mlir::mps::PoolMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::MaxPool,mlir::Value &,mlir::NamedAttrList &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.max_pool", (const unsigned __int8 *)0xD, Context);
  if (!v10)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"anec.max_pool";
    v19[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v9);
  uint64_t v11 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::MaxPool::build(a1, (uint64_t)v21, a3, 1, v11, v12);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::MaxPool,void>::id) {
    unint64_t v14 = v13;
  }
  else {
    unint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void mlir::anonymous namespace'::ConvertStencil::~ConvertStencil(mlir::_anonymous_namespace_::ConvertStencil *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  char v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  char v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::StencilOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::StencilOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::StencilOpGenericAdaptorBase::StencilOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::StencilOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::StencilOpGenericAdaptorBase::StencilOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::StencilOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 104);
  uint64_t v9 = *(void *)(a3 + 112);
  uint64_t v38 = v8;
  uint64_t v39 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v38 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v39 = v23;
        if (v38)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v38)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v38))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v38);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v34[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v35 = 259;
      v32[0] = v34;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StencilOp &>(mlir::mps::StencilOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v32);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 96);
        uint64_t v37 = *(void *)(a3 + 112);
        long long v29 = *(_OWORD *)(a3 + 64);
        v36[5] = *(_OWORD *)(a3 + 80);
        v36[6] = v28;
        long long v30 = *(_OWORD *)(a3 + 16);
        v36[0] = *(_OWORD *)a3;
        v36[1] = v30;
        long long v31 = *(_OWORD *)(a3 + 48);
        v36[2] = *(_OWORD *)(a3 + 32);
        v36[3] = v31;
        v36[4] = v29;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v36, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v38, v10);
    v32[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v32[1] = v13;
    if (v32[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v39;
    if (v38 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v35 = 259;
  unint64_t v33 = v34;
  v34[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StencilOp &>(mlir::mps::StencilOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v33);
  }
  return result;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mps::StencilOp &>(uint64_t a1, uint64_t *a2, unsigned char *a3)
{
  char v3 = 1;
  char v9 = 1;
  if (*a3)
  {
    uint64_t v7 = a3;
    char v3 = 3;
  }
  char v8 = v3;
  uint64_t v4 = *a2;
  uint64_t v10 = &v7;
  uint64_t v5 = *(void *)(a1 + 16);
  if (!v5) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16));
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v5 + 64))(v5, *(void *)(v4 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StencilOp &>(mlir::mps::StencilOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v10);
  }
  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StencilOp &>(mlir::mps::StencilOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

void *llvm::SmallVector<unsigned long long,3u>::SmallVector(void *a1, const void *a2, uint64_t a3)
{
  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  size_t v6 = 8 * a3;
  if ((unint64_t)(8 * a3) >= 0x19)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, a1 + 2, (8 * a3) >> 3, 8);
    unsigned int v7 = *((_DWORD *)a1 + 2);
    if (!a3) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  unsigned int v7 = 0;
  if (a3)
  {
LABEL_5:
    memcpy((void *)(*a1 + 8 * v7), a2, v6);
    unsigned int v7 = *((_DWORD *)a1 + 2);
  }
LABEL_6:
  *((_DWORD *)a1 + 2) = v7 + (v6 >> 3);
  return a1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::AveragePool,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::UnitAttr>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  v25[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.average_pool", (const unsigned __int8 *)0x11, Context);
  if (!v16)
  {
    __int16 v24 = 1283;
    void v23[2] = (uint64_t)"anec.average_pool";
    v23[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a2, v15);
  mlir::anec::AveragePool::build(a1, (uint64_t)v25, *a3, *a4, *a5, *a6, *a7);
  uint64_t v17 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v25);
  if (*(_UNKNOWN **)(*((void *)v17 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::AveragePool,void>::id) {
    __int16 v18 = v17;
  }
  else {
    __int16 v18 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
  return v18;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::CeilOp,mlir::anec::Ceil>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9A8BF0;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        uint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        unsigned int v7 = *(v5 - 6);
        size_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_18082D618()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::CeilOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::CeilOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::CeilOpGenericAdaptorBase::CeilOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::CeilOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::CeilOpGenericAdaptorBase::CeilOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::CeilOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  __int16 v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        __int16 v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CeilOp &>(mlir::mps::CeilOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  long long v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CeilOp &>(mlir::mps::CeilOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::CeilOp,mlir::anec::Ceil>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5 = a1;
  v70[9] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          __int16 v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    uint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  unint64_t v51 = mlir::OpBuilder::create<mlir::anec::Ceil,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CeilOp &>(mlir::mps::CeilOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::CeilOp,mlir::anec::Ceil>::matchAndRewriteWithStaticShapes(mlir::mps::CeilOp,mlir::mps::CeilOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Ceil,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.ceil", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.ceil";
    void v21[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Ceil,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ErfOp,mlir::anec::Erf>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9A8AA0;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_18082E344()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::ErfOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ErfOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ErfOpGenericAdaptorBase::ErfOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ErfOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ErfOpGenericAdaptorBase::ErfOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ErfOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ErfOp &>(mlir::mps::ErfOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ErfOp &>(mlir::mps::ErfOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ErfOp,mlir::anec::Erf>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          __int16 v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    uint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  unint64_t v51 = mlir::OpBuilder::create<mlir::anec::Erf,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ErfOp &>(mlir::mps::ErfOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ErfOp,mlir::anec::Erf>::matchAndRewriteWithStaticShapes(mlir::mps::ErfOp,mlir::mps::ErfOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Erf,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.erf", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.erf";
    void v21[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Erf,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ExponentBase2Op,mlir::anec::Exp2>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9A88E0;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_18082F070()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExponentBase2Op>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExponentBase2Op>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ExponentBase2OpGenericAdaptorBase::ExponentBase2OpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExponentBase2Op>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ExponentBase2OpGenericAdaptorBase::ExponentBase2OpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ExponentBase2Op>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExponentBase2Op &>(mlir::mps::ExponentBase2Op &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExponentBase2Op &>(mlir::mps::ExponentBase2Op &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ExponentBase2Op,mlir::anec::Exp2>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          __int16 v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    uint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  unint64_t v51 = mlir::OpBuilder::create<mlir::anec::Exp2,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExponentBase2Op &>(mlir::mps::ExponentBase2Op &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ExponentBase2Op,mlir::anec::Exp2>::matchAndRewriteWithStaticShapes(mlir::mps::ExponentBase2Op,mlir::mps::ExponentBase2OpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Exp2,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.exp2", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.exp2";
    void v21[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Exp2,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::FloorOp,mlir::anec::Floor>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9A8F00;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_18082FD9C()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::FloorOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::FloorOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::FloorOpGenericAdaptorBase::FloorOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::FloorOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::FloorOpGenericAdaptorBase::FloorOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::FloorOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::FloorOp &>(mlir::mps::FloorOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::FloorOp &>(mlir::mps::FloorOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::FloorOp,mlir::anec::Floor>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          __int16 v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    uint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  unint64_t v51 = mlir::OpBuilder::create<mlir::anec::Floor,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::FloorOp &>(mlir::mps::FloorOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::FloorOp,mlir::anec::Floor>::matchAndRewriteWithStaticShapes(mlir::mps::FloorOp,mlir::mps::FloorOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Floor,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.floor", (const unsigned __int8 *)0xA, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.floor";
    void v21[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Floor,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SignOp,mlir::anec::Sign>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9A8D40;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_180830AC8()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::SignOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SignOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SignOpGenericAdaptorBase::SignOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SignOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SignOpGenericAdaptorBase::SignOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SignOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SignOp &>(mlir::mps::SignOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SignOp &>(mlir::mps::SignOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SignOp,mlir::anec::Sign>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          __int16 v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    uint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  unint64_t v51 = mlir::OpBuilder::create<mlir::anec::Sign,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SignOp &>(mlir::mps::SignOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SignOp,mlir::anec::Sign>::matchAndRewriteWithStaticShapes(mlir::mps::SignOp,mlir::mps::SignOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Sign,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.sign", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.sign";
    void v21[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Sign,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::TruncateOp,mlir::anec::Trunc>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9A8720;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_1808317F4()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::TruncateOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::TruncateOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::TruncateOpGenericAdaptorBase::TruncateOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::TruncateOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::TruncateOpGenericAdaptorBase::TruncateOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::TruncateOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TruncateOp &>(mlir::mps::TruncateOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TruncateOp &>(mlir::mps::TruncateOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::TruncateOp,mlir::anec::Trunc>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          __int16 v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    uint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  unint64_t v51 = mlir::OpBuilder::create<mlir::anec::Trunc,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TruncateOp &>(mlir::mps::TruncateOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::TruncateOp,mlir::anec::Trunc>::matchAndRewriteWithStaticShapes(mlir::mps::TruncateOp,mlir::mps::TruncateOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Trunc,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.trunc", (const unsigned __int8 *)0xA, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.trunc";
    void v21[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Trunc,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void *mlir::anonymous namespace'::ConvertReductionA14Plus<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)2>::~ConvertReductionA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReductionA14Plus<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)2>::~ConvertReductionA14Plus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMaxOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMaxOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReductionMaxOpGenericAdaptorBase::ReductionMaxOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMaxOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReductionMaxOpGenericAdaptorBase::ReductionMaxOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ReductionMaxOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 56);
  uint64_t v9 = *(void *)(a3 + 64);
  uint64_t v36 = v8;
  uint64_t v37 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v37 = v23;
        if (v36)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v36);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v33 = 259;
      v30[0] = v32;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMaxOp &>(mlir::mps::ReductionMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 48);
        void v34[2] = *(_OWORD *)(a3 + 32);
        v34[3] = v28;
        uint64_t v35 = *(void *)(a3 + 64);
        long long v29 = *(_OWORD *)(a3 + 16);
        v34[0] = *(_OWORD *)a3;
        v34[1] = v29;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v37;
    if (v36 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  long long v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMaxOp &>(mlir::mps::ReductionMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void v29[2] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = (unsigned int *)a2;
  unint64_t v6 = *(void *)(a3 + 64);
  v29[0] = *(void *)(a3 + 56);
  v29[1] = v6;
  v24[1] = v7;
  if ((_BYTE)v7)
  {
    uint64_t v8 = *(void *)(a2 + 24);
    v26[0] = mlir::ValueRange::dereference_iterator(v29, 0);
    uint64_t v9 = mlir::OpBuilder::create<mlir::anec::ReduceMax,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v8, v26, v24);
    if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v25))
    {
      uint64_t v10 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v25) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v10) {
        goto LABEL_12;
      }
      uint64_t v11 = *v10;
      unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v13 = *(unsigned int *)(v11 + 16);
      if (!v13) {
        goto LABEL_12;
      }
      unint64_t v14 = *(void **)(v11 + 8);
      uint64_t v15 = &v14[2 * v13];
      do
      {
        unint64_t v16 = v13 >> 1;
        uint64_t v17 = &v14[2 * (v13 >> 1)];
        unint64_t v19 = *v17;
        uint64_t v18 = v17 + 2;
        v13 += ~(v13 >> 1);
        if (v19 < v12) {
          unint64_t v14 = v18;
        }
        else {
          unint64_t v13 = v16;
        }
      }
      while (v13);
      if (v14 != v15 && *v14 == v12) {
        uint64_t v20 = v14[1];
      }
      else {
LABEL_12:
      }
        uint64_t v20 = 0;
      v26[0] = (uint64_t)v10;
      v26[1] = v20;
    }
    v26[0] = (uint64_t)v9 - 16;
    uint64_t v21 = 1;
    mlir::ConversionPatternRewriter::replaceOp(a4, v25, (uint64_t)v26, 1);
  }
  else
  {
    v26[0] = (uint64_t)"failed to convert operand axes";
    __int16 v27 = 259;
    long long v28 = v26;
    uint64_t v22 = *(void *)(a4 + 16);
    if (v22 && mlir::RewriterBase::Listener::classof(v22)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), uint64_t **))(*(void *)v22 + 64))(v22, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMaxOp &>(mlir::mps::ReductionMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v28);
    }
    else {
      return 0;
    }
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMaxOp &>(mlir::mps::ReductionMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

unint64_t mlir::anonymous namespace'::convertAxes(uint64_t a1, unint64_t a2, uint64_t a3)
{
  void v55[2] = *MEMORY[0x1E4F143B8];
  v55[0] = a1;
  v55[1] = a2;
  unint64_t v51 = 0;
  unint64_t v5 = (uint64_t *)(*(void *)(*(void *)(*(void *)(a3 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    unint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    unint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v52 = v5;
  uint64_t v53 = v15;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v52);
  unint64_t v17 = v16;
  unint64_t v51 = v16;
  if (a2 > 1)
  {
    uint64_t v21 = (void *)mlir::ValueRange::dereference_iterator(v55, 1);
    unint64_t SortedUniquePromotedPositiveAxesAttr = mlir::getSortedUniquePromotedPositiveAxesAttr(v21, v17, 0, 0);
    if (v23) {
      unsigned __int8 v24 = SortedUniquePromotedPositiveAxesAttr;
    }
    else {
      unsigned __int8 v24 = 0;
    }
    if (v23) {
      unint64_t v25 = SortedUniquePromotedPositiveAxesAttr & 0xFFFFFFFFFFFFFF00;
    }
    else {
      unint64_t v25 = 0;
    }
    return v25 | v24;
  }
  unint64_t v52 = v54;
  uint64_t v53 = 0x600000000;
  if (!v16) {
    goto LABEL_31;
  }
  if (v16 < 7)
  {
    uint64_t v18 = 0;
    unint64_t v19 = (int64x2_t *)v54;
    unint64_t v20 = v16;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v52, v54, v16, 8);
    uint64_t v18 = v53;
    unint64_t v19 = (int64x2_t *)v52;
    unint64_t v20 = v17 - v53;
    if (v17 == v53) {
      goto LABEL_24;
    }
  }
  bzero((char *)v19 + 8 * v18, 8 * v20);
LABEL_24:
  LODWORD(v53) = v17;
  if (!v17) {
    goto LABEL_31;
  }
  unint64_t v26 = (v17 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (v26 < 3)
  {
    uint64_t v27 = 0;
    long long v28 = (uint64_t *)v19;
    do
LABEL_30:
      *v28++ = v27++;
    while (v28 != (uint64_t *)((char *)v19 + 8 * v17));
    goto LABEL_31;
  }
  unint64_t v29 = v26 + 1;
  uint64_t v27 = (v26 + 1) & 0x3FFFFFFFFFFFFFFCLL;
  long long v28 = &v19->i64[v27];
  int64x2_t v30 = (int64x2_t)xmmword_1810FE2E0;
  long long v31 = v19 + 1;
  int64x2_t v32 = vdupq_n_s64(2uLL);
  int64x2_t v33 = vdupq_n_s64(4uLL);
  uint64_t v34 = v27;
  do
  {
    v31[-1] = v30;
    *long long v31 = vaddq_s64(v30, v32);
    int64x2_t v30 = vaddq_s64(v30, v33);
    v31 += 2;
    v34 -= 4;
  }
  while (v34);
  if (v29 != v27) {
    goto LABEL_30;
  }
LABEL_31:
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a3 + 24));
  uint64_t v36 = mlir::IntegerType::get(Context, 0x40u, 2u);
  uint64_t v37 = (void *)mlir::RankedTensorType::get((uint64_t)&v51, 1, v36, 0);
  uint64_t v38 = v37;
  if (!v37) {
    goto LABEL_40;
  }
  uint64_t v39 = *v37;
  unint64_t v40 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v41 = *(unsigned int *)(v39 + 16);
  if (!v41) {
    goto LABEL_40;
  }
  unint64_t v42 = *(void **)(v39 + 8);
  unint64_t v43 = &v42[2 * v41];
  do
  {
    unint64_t v44 = v41 >> 1;
    uint64_t v45 = &v42[2 * (v41 >> 1)];
    unint64_t v47 = *v45;
    int v46 = v45 + 2;
    v41 += ~(v41 >> 1);
    if (v47 < v40) {
      unint64_t v42 = v46;
    }
    else {
      unint64_t v41 = v44;
    }
  }
  while (v41);
  if (v42 != v43 && *v42 == v40) {
    uint64_t v48 = v42[1];
  }
  else {
LABEL_40:
  }
    uint64_t v48 = 0;
  uint64_t v49 = mlir::DenseElementsAttr::getFromRawBuffer(v38, v48, v52, 8 * v53, 8, 1, 0);
  unsigned __int8 v24 = v49;
  unint64_t v25 = v49 & 0xFFFFFFFFFFFFFF00;
  if (v52 != v54) {
    free(v52);
  }
  return v25 | v24;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ReduceMax,mlir::Value,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.reduce_max", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.reduce_max";
    v17[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ReduceMax::build(a1, (uint64_t)v19, *a3, *a4);
  unint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ReduceMax,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *mlir::anonymous namespace'::ConvertReductionA14Plus<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)2>::~ConvertReductionA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReductionA14Plus<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)2>::~ConvertReductionA14Plus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ReductionMeanOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 48);
  uint64_t v9 = *(void *)(a3 + 56);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v33 = 259;
      v30[0] = v32;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMeanOp &>(mlir::mps::ReductionMeanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v34[0] = *(_OWORD *)a3;
        v34[1] = v28;
        long long v29 = *(_OWORD *)(a3 + 48);
        void v34[2] = *(_OWORD *)(a3 + 32);
        v34[3] = v29;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      uint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  long long v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMeanOp &>(mlir::mps::ReductionMeanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void v29[2] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = (unsigned int *)a2;
  unint64_t v6 = *(void *)(a3 + 56);
  v29[0] = *(void *)(a3 + 48);
  v29[1] = v6;
  v24[1] = v7;
  if ((_BYTE)v7)
  {
    uint64_t v8 = *(void *)(a2 + 24);
    v26[0] = mlir::ValueRange::dereference_iterator(v29, 0);
    uint64_t v9 = mlir::OpBuilder::create<mlir::anec::ReduceAvg,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v8, v26, v24);
    if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v25))
    {
      uint64_t v10 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v25) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v10) {
        goto LABEL_12;
      }
      uint64_t v11 = *v10;
      unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v13 = *(unsigned int *)(v11 + 16);
      if (!v13) {
        goto LABEL_12;
      }
      uint64_t v14 = *(void **)(v11 + 8);
      uint64_t v15 = &v14[2 * v13];
      do
      {
        unint64_t v16 = v13 >> 1;
        uint64_t v17 = &v14[2 * (v13 >> 1)];
        unint64_t v19 = *v17;
        __int16 v18 = v17 + 2;
        v13 += ~(v13 >> 1);
        if (v19 < v12) {
          uint64_t v14 = v18;
        }
        else {
          unint64_t v13 = v16;
        }
      }
      while (v13);
      if (v14 != v15 && *v14 == v12) {
        uint64_t v20 = v14[1];
      }
      else {
LABEL_12:
      }
        uint64_t v20 = 0;
      v26[0] = (uint64_t)v10;
      v26[1] = v20;
    }
    v26[0] = (uint64_t)v9 - 16;
    uint64_t v21 = 1;
    mlir::ConversionPatternRewriter::replaceOp(a4, v25, (uint64_t)v26, 1);
  }
  else
  {
    v26[0] = (uint64_t)"failed to convert operand axes";
    __int16 v27 = 259;
    long long v28 = v26;
    uint64_t v22 = *(void *)(a4 + 16);
    if (v22 && mlir::RewriterBase::Listener::classof(v22)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), uint64_t **))(*(void *)v22 + 64))(v22, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMeanOp &>(mlir::mps::ReductionMeanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v28);
    }
    else {
      return 0;
    }
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMeanOp &>(mlir::mps::ReductionMeanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ReduceAvg,mlir::Value,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.reduce_avg", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.reduce_avg";
    v17[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ReduceAvg::build(a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ReduceAvg,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *mlir::anonymous namespace'::ConvertReductionA14Plus<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)2>::~ConvertReductionA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReductionA14Plus<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)2>::~ConvertReductionA14Plus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMinOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMinOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReductionMinOpGenericAdaptorBase::ReductionMinOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMinOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReductionMinOpGenericAdaptorBase::ReductionMinOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ReductionMinOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 56);
  uint64_t v9 = *(void *)(a3 + 64);
  uint64_t v36 = v8;
  uint64_t v37 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v37 = v23;
        if (v36)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v36);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v33 = 259;
      v30[0] = v32;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMinOp &>(mlir::mps::ReductionMinOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 48);
        void v34[2] = *(_OWORD *)(a3 + 32);
        v34[3] = v28;
        uint64_t v35 = *(void *)(a3 + 64);
        long long v29 = *(_OWORD *)(a3 + 16);
        v34[0] = *(_OWORD *)a3;
        v34[1] = v29;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v37;
    if (v36 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  long long v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMinOp &>(mlir::mps::ReductionMinOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void v29[2] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = (unsigned int *)a2;
  unint64_t v6 = *(void *)(a3 + 64);
  v29[0] = *(void *)(a3 + 56);
  v29[1] = v6;
  v24[1] = v7;
  if ((_BYTE)v7)
  {
    uint64_t v8 = *(void *)(a2 + 24);
    v26[0] = mlir::ValueRange::dereference_iterator(v29, 0);
    uint64_t v9 = mlir::OpBuilder::create<mlir::anec::ReduceMin,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v8, v26, v24);
    if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v25))
    {
      uint64_t v10 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v25) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v10) {
        goto LABEL_12;
      }
      uint64_t v11 = *v10;
      unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v13 = *(unsigned int *)(v11 + 16);
      if (!v13) {
        goto LABEL_12;
      }
      unint64_t v14 = *(void **)(v11 + 8);
      uint64_t v15 = &v14[2 * v13];
      do
      {
        unint64_t v16 = v13 >> 1;
        uint64_t v17 = &v14[2 * (v13 >> 1)];
        unint64_t v19 = *v17;
        __int16 v18 = v17 + 2;
        v13 += ~(v13 >> 1);
        if (v19 < v12) {
          unint64_t v14 = v18;
        }
        else {
          unint64_t v13 = v16;
        }
      }
      while (v13);
      if (v14 != v15 && *v14 == v12) {
        uint64_t v20 = v14[1];
      }
      else {
LABEL_12:
      }
        uint64_t v20 = 0;
      v26[0] = (uint64_t)v10;
      v26[1] = v20;
    }
    v26[0] = (uint64_t)v9 - 16;
    uint64_t v21 = 1;
    mlir::ConversionPatternRewriter::replaceOp(a4, v25, (uint64_t)v26, 1);
  }
  else
  {
    v26[0] = (uint64_t)"failed to convert operand axes";
    __int16 v27 = 259;
    long long v28 = v26;
    uint64_t v22 = *(void *)(a4 + 16);
    if (v22 && mlir::RewriterBase::Listener::classof(v22)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), uint64_t **))(*(void *)v22 + 64))(v22, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMinOp &>(mlir::mps::ReductionMinOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v28);
    }
    else {
      return 0;
    }
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMinOp &>(mlir::mps::ReductionMinOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ReduceMin,mlir::Value,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.reduce_min", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.reduce_min";
    v17[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ReduceMin::build(a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ReduceMin,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *mlir::anonymous namespace'::ConvertReductionA14Plus<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)2>::~ConvertReductionA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReductionA14Plus<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)2>::~ConvertReductionA14Plus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionSumOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionSumOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReductionSumOpGenericAdaptorBase::ReductionSumOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionSumOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReductionSumOpGenericAdaptorBase::ReductionSumOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ReductionSumOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 48);
  uint64_t v9 = *(void *)(a3 + 56);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v33 = 259;
      v30[0] = v32;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionSumOp &>(mlir::mps::ReductionSumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v34[0] = *(_OWORD *)a3;
        v34[1] = v28;
        long long v29 = *(_OWORD *)(a3 + 48);
        void v34[2] = *(_OWORD *)(a3 + 32);
        v34[3] = v29;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  long long v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionSumOp &>(mlir::mps::ReductionSumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void v29[2] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = (unsigned int *)a2;
  unint64_t v6 = *(void *)(a3 + 56);
  v29[0] = *(void *)(a3 + 48);
  v29[1] = v6;
  v24[1] = v7;
  if ((_BYTE)v7)
  {
    uint64_t v8 = *(void *)(a2 + 24);
    v26[0] = mlir::ValueRange::dereference_iterator(v29, 0);
    uint64_t v9 = mlir::OpBuilder::create<mlir::anec::ReduceSum,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v8, v26, v24);
    if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v25))
    {
      uint64_t v10 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v25) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v10) {
        goto LABEL_12;
      }
      uint64_t v11 = *v10;
      unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v13 = *(unsigned int *)(v11 + 16);
      if (!v13) {
        goto LABEL_12;
      }
      unint64_t v14 = *(void **)(v11 + 8);
      uint64_t v15 = &v14[2 * v13];
      do
      {
        unint64_t v16 = v13 >> 1;
        uint64_t v17 = &v14[2 * (v13 >> 1)];
        unint64_t v19 = *v17;
        __int16 v18 = v17 + 2;
        v13 += ~(v13 >> 1);
        if (v19 < v12) {
          unint64_t v14 = v18;
        }
        else {
          unint64_t v13 = v16;
        }
      }
      while (v13);
      if (v14 != v15 && *v14 == v12) {
        uint64_t v20 = v14[1];
      }
      else {
LABEL_12:
      }
        uint64_t v20 = 0;
      v26[0] = (uint64_t)v10;
      v26[1] = v20;
    }
    v26[0] = (uint64_t)v9 - 16;
    uint64_t v21 = 1;
    mlir::ConversionPatternRewriter::replaceOp(a4, v25, (uint64_t)v26, 1);
  }
  else
  {
    v26[0] = (uint64_t)"failed to convert operand axes";
    __int16 v27 = 259;
    long long v28 = v26;
    uint64_t v22 = *(void *)(a4 + 16);
    if (v22 && mlir::RewriterBase::Listener::classof(v22)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), uint64_t **))(*(void *)v22 + 64))(v22, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionSumOp &>(mlir::mps::ReductionSumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v28);
    }
    else {
      return 0;
    }
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionSumOp &>(mlir::mps::ReductionSumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ReduceSum,mlir::Value,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.reduce_sum", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.reduce_sum";
    v17[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ReduceSum::build(a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ReduceSum,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)1>::~ConvertReductionA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)1>::~ConvertReductionA14Minus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v112[2] = *MEMORY[0x1E4F143B8];
  unint64_t v93 = (unsigned int *)a2;
  unint64_t v6 = *(void *)(a3 + 64);
  v112[0] = *(void *)(a3 + 56);
  v112[1] = v6;
  if (!v8)
  {
    unint64_t v96 = "failed to convert operand axes";
    v98[8] = 259;
    unint64_t v109 = &v96;
    uint64_t v55 = *(void *)(a4 + 16);
    if (v55)
    {
      if (mlir::RewriterBase::Listener::classof(v55)) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void ***))(*(void *)v55 + 64))(v55, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMaxOp &>(mlir::mps::ReductionMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v109);
      }
      return 0;
    }
    return v55;
  }
  uint64_t v9 = (uint64_t *)v7;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v93))
  {
    uint64_t v57 = v93;
    unint64_t v96 = &v93;
    uint64_t v55 = *(void *)(a4 + 16);
    if (v55)
    {
      if (mlir::RewriterBase::Listener::classof(v55)) {
      return 0;
      }
    }
    return v55;
  }
  char v10 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v93) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_12;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_12;
  }
  uint64_t v14 = *(void **)(v11 + 8);
  uint64_t v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    uint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    __int16 v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      uint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_12:
  }
    uint64_t v20 = 0;
  unint64_t v109 = (void **)v111;
  uint64_t v110 = 0x600000000;
  if (!v9) {
    goto LABEL_22;
  }
  uint64_t v21 = *v9;
  unint64_t v22 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_22;
  }
  unsigned __int8 v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    __int16 v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    long long v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      unsigned __int8 v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_22:
  }
    uint64_t v30 = 0;
  mlir::getIntValues<long long>((uint64_t)v9, v30, (uint64_t)&v109, 1);
  uint64_t v106 = v108;
  memset(v108, 0, sizeof(v108));
  uint64_t v107 = 0x600000006;
  long long v103 = v105;
  memset_pattern16(v105, &unk_1810FE350, 0x18uLL);
  uint64_t v104 = 0x600000003;
  uint64_t v100 = v102;
  memset_pattern16(v102, &unk_1810FE350, 0x18uLL);
  uint64_t v101 = 0x600000003;
  v92[0] = mlir::getRankPromotionTypeForANE((uint64_t)v10, v20);
  v92[1] = v31;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v92);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v32);
  if (v34)
  {
    if (v110)
    {
      unint64_t v35 = IndexFromDim;
      uint64_t v36 = (uint64_t *)v109;
      uint64_t v37 = 8 * v110;
      while (1)
      {
        uint64_t v38 = *v36;
        v94[0] = v38;
        if (v38 == v35) {
          break;
        }
        if (v38 <= 1)
        {
          uint64_t v61 = v93;
          unint64_t v96 = &v93;
          uint64_t v55 = *(void *)(a4 + 16);
          if (!v55) {
            goto LABEL_89;
          }
          if (mlir::RewriterBase::Listener::classof(v55))
          {
            uint64_t v59 = *((void *)v61 + 3);
            goto LABEL_54;
          }
          goto LABEL_56;
        }
        uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v92);
        *((void *)v100 + v38 - 2) = *(void *)(ArgAttrsAttr + 8 * v38);
        ++v36;
        v37 -= 8;
        if (!v37) {
          goto LABEL_29;
        }
      }
      uint64_t v58 = v93;
      unint64_t v96 = v94;
      uint64_t v97 = (uint64_t)&v93;
      uint64_t v55 = *(void *)(a4 + 16);
      if (!v55) {
        goto LABEL_89;
      }
      if (mlir::RewriterBase::Listener::classof(v55))
      {
        uint64_t v59 = *((void *)v58 + 3);
LABEL_54:
        uint64_t v55 = (*(uint64_t (**)(uint64_t, uint64_t, void *, void **))(*(void *)v55 + 64))(v55, v59, v60, &v96);
        goto LABEL_89;
      }
LABEL_56:
      uint64_t v55 = 0;
    }
    else
    {
LABEL_29:
      unint64_t v96 = v98;
      uint64_t v97 = 0x400000000;
      uint64_t v99 = 4;
      v94[0] = 3;
      uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      unint64_t v41 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v94, 1, IntegerType, 0);
      v94[0] = 6;
      uint64_t v42 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      unint64_t v43 = (void *)mlir::RankedTensorType::get((uint64_t)v94, 1, v42, 0);
      v94[0] = "ksize";
      __int16 v95 = 259;
      uint64_t StringAttr = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v94);
      if (v41)
      {
        uint64_t v45 = *v41;
        unint64_t v46 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v47 = *(unsigned int *)(v45 + 16);
        if (v47)
        {
          uint64_t v48 = *(void **)(v45 + 8);
          uint64_t v49 = &v48[2 * v47];
          do
          {
            unint64_t v50 = v47 >> 1;
            unint64_t v51 = &v48[2 * (v47 >> 1)];
            unint64_t v53 = *v51;
            unint64_t v52 = v51 + 2;
            v47 += ~(v47 >> 1);
            if (v53 < v46) {
              uint64_t v48 = v52;
            }
            else {
              unint64_t v47 = v50;
            }
          }
          while (v47);
          if (v48 == v49)
          {
            uint64_t v54 = 0;
          }
          else if (*v48 == v46)
          {
            uint64_t v54 = v48[1];
          }
          else
          {
            uint64_t v54 = 0;
          }
        }
        else
        {
          uint64_t v54 = 0;
        }
      }
      else
      {
        uint64_t v54 = 0;
      }
      uint64_t v62 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v54, v100, 8 * v101, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v96, StringAttr, v62);
      v94[0] = "stride";
      __int16 v95 = 259;
      uint64_t v63 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v94);
      if (v41)
      {
        uint64_t v64 = v43;
        uint64_t v65 = *v41;
        unint64_t v66 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v67 = *(unsigned int *)(v65 + 16);
        if (v67)
        {
          unint64_t v68 = *(void **)(v65 + 8);
          unint64_t v69 = &v68[2 * v67];
          do
          {
            unint64_t v70 = v67 >> 1;
            uint64_t v71 = &v68[2 * (v67 >> 1)];
            unint64_t v73 = *v71;
            unint64_t v72 = v71 + 2;
            v67 += ~(v67 >> 1);
            if (v73 < v66) {
              unint64_t v68 = v72;
            }
            else {
              unint64_t v67 = v70;
            }
          }
          while (v67);
          unint64_t v43 = v64;
          if (v68 == v69)
          {
            uint64_t v74 = 0;
          }
          else if (*v68 == v66)
          {
            uint64_t v74 = v68[1];
          }
          else
          {
            uint64_t v74 = 0;
          }
        }
        else
        {
          uint64_t v74 = 0;
          unint64_t v43 = v64;
        }
      }
      else
      {
        uint64_t v74 = 0;
      }
      uint64_t v75 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v74, v103, 8 * v104, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v96, v63, v75);
      v94[0] = "padding";
      __int16 v95 = 259;
      uint64_t v76 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v94);
      if (v43
        && (uint64_t v77 = *v43, v78 = mlir::TypeID::get<mlir::ShapedType>(), v79 = *(unsigned int *)(v77 + 16), v79))
      {
        uint64_t v80 = *(void **)(v77 + 8);
        uint64_t v81 = &v80[2 * v79];
        do
        {
          unint64_t v82 = v79 >> 1;
          uint64_t v83 = &v80[2 * (v79 >> 1)];
          unint64_t v85 = *v83;
          uint64_t v84 = v83 + 2;
          v79 += ~(v79 >> 1);
          if (v85 < v78) {
            uint64_t v80 = v84;
          }
          else {
            unint64_t v79 = v82;
          }
        }
        while (v79);
        if (v80 != v81 && *v80 == v78) {
          uint64_t v86 = v80[1];
        }
        else {
          uint64_t v86 = 0;
        }
      }
      else
      {
        uint64_t v86 = 0;
      }
      uint64_t v87 = mlir::DenseElementsAttr::getFromRawBuffer(v43, v86, v106, 8 * v107, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v96, v76, v87);
      v94[0] = mlir::ValueRange::dereference_iterator(v112, 0);
      uint64_t v91 = (char *)mlir::OpBuilder::create<mlir::anec::MaxPool,mlir::Value &,mlir::NamedAttrList &>((mlir::UnknownLoc **)(a4 + 8), *((void *)v93 + 3), (uint64_t)v94, (uint64_t)&v96)- 16;
      mlir::ConversionPatternRewriter::replaceOp(a4, v93, (uint64_t)&v91, 1);
      if (v96 != v98) {
        free(v96);
      }
      uint64_t v55 = 1;
    }
LABEL_89:
    if (v100 != v102) {
      free(v100);
    }
    if (v103 != v105) {
      free(v103);
    }
    if (v106 != v108) {
      free(v106);
    }
    if (v109 != (void **)v111) {
      free(v109);
    }
    return v55;
  }
  uint64_t v89 = (mlir::Operation ***)std::__throw_bad_optional_access[abi:nn180100]();
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMaxOp,mlir::mps::ReductionMaxOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Collapsing dimension for Op");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, "to MaxPool, AveragePool or Conv for A13 and below on ane is not supported \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMaxOp,mlir::mps::ReductionMaxOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "MaxPool/AveragePool for axes:");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = **a1;
  int v17 = 2;
  uint64_t v18 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  char v8 = &v17;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v14 = v7 + 1;
    BOOL v15 = v5 + 24 * v7 > (unint64_t)&v17;
    if (v5 <= (unint64_t)&v17 && v15)
    {
      unint64_t v16 = (char *)&v17 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v14, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      char v8 = (int *)&v16[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v14, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      char v8 = &v17;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  uint64_t v11 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(v3, "reduced from Op ");
  unint64_t v12 = mlir::Diagnostic::operator<<(v11, (mlir::Operation *)*a1[1]);
  return mlir::Diagnostic::operator<<((uint64_t)v12, "is not supported for A13 and below\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMaxOp,mlir::mps::ReductionMaxOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Axis value is incorrect for Op");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, "\n");
}

void *mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)1>::~ConvertReductionA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)1>::~ConvertReductionA14Minus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v114[2] = *MEMORY[0x1E4F143B8];
  __int16 v95 = (unsigned int *)a2;
  unint64_t v6 = *(void *)(a3 + 56);
  v114[0] = *(void *)(a3 + 48);
  v114[1] = v6;
  if (!v8)
  {
    uint64_t v98 = "failed to convert operand axes";
    v100[8] = 259;
    uint64_t v111 = &v98;
    uint64_t v55 = *(void *)(a4 + 16);
    if (v55)
    {
      if (mlir::RewriterBase::Listener::classof(v55)) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void ***))(*(void *)v55 + 64))(v55, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMeanOp &>(mlir::mps::ReductionMeanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v111);
      }
      return 0;
    }
    return v55;
  }
  uint64_t v9 = (uint64_t *)v7;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v95))
  {
    uint64_t v57 = v95;
    uint64_t v98 = &v95;
    uint64_t v55 = *(void *)(a4 + 16);
    if (v55)
    {
      if (mlir::RewriterBase::Listener::classof(v55)) {
      return 0;
      }
    }
    return v55;
  }
  long long v10 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_12;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_12;
  }
  unint64_t v14 = *(void **)(v11 + 8);
  BOOL v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    int v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    uint64_t v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      unint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_12:
  }
    uint64_t v20 = 0;
  uint64_t v111 = (void **)v113;
  uint64_t v112 = 0x600000000;
  if (!v9) {
    goto LABEL_22;
  }
  uint64_t v21 = *v9;
  unint64_t v22 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_22;
  }
  unsigned __int8 v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    __int16 v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    long long v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      unsigned __int8 v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_22:
  }
    uint64_t v30 = 0;
  mlir::getIntValues<long long>((uint64_t)v9, v30, (uint64_t)&v111, 1);
  uint64_t v108 = v110;
  memset(v110, 0, sizeof(v110));
  uint64_t v109 = 0x600000006;
  uint64_t v105 = v107;
  memset_pattern16(v107, &unk_1810FE350, 0x18uLL);
  uint64_t v106 = 0x600000003;
  uint64_t v102 = v104;
  memset_pattern16(v104, &unk_1810FE350, 0x18uLL);
  uint64_t v103 = 0x600000003;
  v94[0] = mlir::getRankPromotionTypeForANE((uint64_t)v10, v20);
  v94[1] = v31;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v94);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v32);
  if (v34)
  {
    if (v112)
    {
      unint64_t v35 = IndexFromDim;
      uint64_t v36 = (uint64_t *)v111;
      uint64_t v37 = 8 * v112;
      while (1)
      {
        uint64_t v38 = *v36;
        v96[0] = v38;
        if (v38 == v35) {
          break;
        }
        if (v38 <= 1)
        {
          uint64_t v61 = v95;
          uint64_t v98 = &v95;
          uint64_t v55 = *(void *)(a4 + 16);
          if (!v55) {
            goto LABEL_89;
          }
          if (mlir::RewriterBase::Listener::classof(v55))
          {
            uint64_t v59 = *((void *)v61 + 3);
            goto LABEL_54;
          }
          goto LABEL_56;
        }
        uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v94);
        *((void *)v102 + v38 - 2) = *(void *)(ArgAttrsAttr + 8 * v38);
        ++v36;
        v37 -= 8;
        if (!v37) {
          goto LABEL_29;
        }
      }
      uint64_t v58 = v95;
      uint64_t v98 = v96;
      uint64_t v99 = (uint64_t)&v95;
      uint64_t v55 = *(void *)(a4 + 16);
      if (!v55) {
        goto LABEL_89;
      }
      if (mlir::RewriterBase::Listener::classof(v55))
      {
        uint64_t v59 = *((void *)v58 + 3);
LABEL_54:
        uint64_t v55 = (*(uint64_t (**)(uint64_t, uint64_t, void *, void **))(*(void *)v55 + 64))(v55, v59, v60, &v98);
        goto LABEL_89;
      }
LABEL_56:
      uint64_t v55 = 0;
    }
    else
    {
LABEL_29:
      uint64_t v98 = v100;
      uint64_t v99 = 0x400000000;
      uint64_t v101 = 4;
      v96[0] = 3;
      uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      unint64_t v41 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v96, 1, IntegerType, 0);
      v96[0] = 6;
      uint64_t v42 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      unint64_t v43 = (void *)mlir::RankedTensorType::get((uint64_t)v96, 1, v42, 0);
      v96[0] = "ksize";
      __int16 v97 = 259;
      uint64_t StringAttr = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v96);
      if (v41)
      {
        uint64_t v45 = *v41;
        unint64_t v46 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v47 = *(unsigned int *)(v45 + 16);
        if (v47)
        {
          uint64_t v48 = *(void **)(v45 + 8);
          uint64_t v49 = &v48[2 * v47];
          do
          {
            unint64_t v50 = v47 >> 1;
            unint64_t v51 = &v48[2 * (v47 >> 1)];
            unint64_t v53 = *v51;
            unint64_t v52 = v51 + 2;
            v47 += ~(v47 >> 1);
            if (v53 < v46) {
              uint64_t v48 = v52;
            }
            else {
              unint64_t v47 = v50;
            }
          }
          while (v47);
          if (v48 == v49)
          {
            uint64_t v54 = 0;
          }
          else if (*v48 == v46)
          {
            uint64_t v54 = v48[1];
          }
          else
          {
            uint64_t v54 = 0;
          }
        }
        else
        {
          uint64_t v54 = 0;
        }
      }
      else
      {
        uint64_t v54 = 0;
      }
      uint64_t v62 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v54, v102, 8 * v103, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v98, StringAttr, v62);
      v96[0] = "stride";
      __int16 v97 = 259;
      uint64_t v63 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v96);
      if (v41)
      {
        uint64_t v64 = v43;
        uint64_t v65 = *v41;
        unint64_t v66 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v67 = *(unsigned int *)(v65 + 16);
        if (v67)
        {
          unint64_t v68 = *(void **)(v65 + 8);
          unint64_t v69 = &v68[2 * v67];
          do
          {
            unint64_t v70 = v67 >> 1;
            uint64_t v71 = &v68[2 * (v67 >> 1)];
            unint64_t v73 = *v71;
            unint64_t v72 = v71 + 2;
            v67 += ~(v67 >> 1);
            if (v73 < v66) {
              unint64_t v68 = v72;
            }
            else {
              unint64_t v67 = v70;
            }
          }
          while (v67);
          unint64_t v43 = v64;
          if (v68 == v69)
          {
            uint64_t v74 = 0;
          }
          else if (*v68 == v66)
          {
            uint64_t v74 = v68[1];
          }
          else
          {
            uint64_t v74 = 0;
          }
        }
        else
        {
          uint64_t v74 = 0;
          unint64_t v43 = v64;
        }
      }
      else
      {
        uint64_t v74 = 0;
      }
      uint64_t v75 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v74, v105, 8 * v106, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v98, v63, v75);
      v96[0] = "padding";
      __int16 v97 = 259;
      uint64_t v76 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v96);
      if (v43
        && (uint64_t v77 = *v43, v78 = mlir::TypeID::get<mlir::ShapedType>(), v79 = *(unsigned int *)(v77 + 16), v79))
      {
        uint64_t v80 = *(void **)(v77 + 8);
        uint64_t v81 = &v80[2 * v79];
        do
        {
          unint64_t v82 = v79 >> 1;
          uint64_t v83 = &v80[2 * (v79 >> 1)];
          unint64_t v85 = *v83;
          uint64_t v84 = v83 + 2;
          v79 += ~(v79 >> 1);
          if (v85 < v78) {
            uint64_t v80 = v84;
          }
          else {
            unint64_t v79 = v82;
          }
        }
        while (v79);
        if (v80 != v81 && *v80 == v78) {
          uint64_t v86 = v80[1];
        }
        else {
          uint64_t v86 = 0;
        }
      }
      else
      {
        uint64_t v86 = 0;
      }
      uint64_t v87 = mlir::DenseElementsAttr::getFromRawBuffer(v43, v86, v108, 8 * v109, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v98, v76, v87);
      v96[0] = mlir::ValueRange::dereference_iterator(v114, 0);
      uint64_t UnitAttr = mlir::Builder::getUnitAttr((mlir::UnitAttr **)(a4 + 8), v88);
      mlir::NamedAttrList::set((uint64_t)&v98, (uint64_t)"inc_pad", 7, UnitAttr);
      unint64_t v93 = (char *)mlir::OpBuilder::create<mlir::anec::AveragePool,mlir::Value &,mlir::NamedAttrList &>((mlir::UnknownLoc **)(a4 + 8), *((void *)v95 + 3), (uint64_t)v96, (uint64_t)&v98)- 16;
      mlir::ConversionPatternRewriter::replaceOp(a4, v95, (uint64_t)&v93, 1);
      if (v98 != v100) {
        free(v98);
      }
      uint64_t v55 = 1;
    }
LABEL_89:
    if (v102 != v104) {
      free(v102);
    }
    if (v105 != v107) {
      free(v105);
    }
    if (v108 != v110) {
      free(v108);
    }
    if (v111 != (void **)v113) {
      free(v111);
    }
    return v55;
  }
  uint64_t v91 = (mlir::Operation ***)std::__throw_bad_optional_access[abi:nn180100]();
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMeanOp,mlir::mps::ReductionMeanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Collapsing dimension for Op");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, "to MaxPool, AveragePool or Conv for A13 and below on ane is not supported \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMeanOp,mlir::mps::ReductionMeanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "MaxPool/AveragePool for axes:");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = **a1;
  int v17 = 2;
  uint64_t v18 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  char v8 = &v17;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v14 = v7 + 1;
    BOOL v15 = v5 + 24 * v7 > (unint64_t)&v17;
    if (v5 <= (unint64_t)&v17 && v15)
    {
      unint64_t v16 = (char *)&v17 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v14, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      char v8 = (int *)&v16[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v14, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      char v8 = &v17;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  uint64_t v11 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(v3, "reduced from Op ");
  unint64_t v12 = mlir::Diagnostic::operator<<(v11, (mlir::Operation *)*a1[1]);
  return mlir::Diagnostic::operator<<((uint64_t)v12, "is not supported for A13 and below\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMeanOp,mlir::mps::ReductionMeanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Axis value is incorrect for Op");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, "\n");
}

void *mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)1>::~ConvertReductionA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)1>::~ConvertReductionA14Minus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v140[2] = *MEMORY[0x1E4F143B8];
  uint64_t v119 = (unsigned int *)a2;
  unint64_t v6 = *(void *)(a3 + 64);
  v140[0] = *(void *)(a3 + 56);
  v140[1] = v6;
  if (!v8)
  {
    uint64_t v124 = "failed to convert operand axes";
    v126[8] = 259;
    uint64_t v137 = &v124;
    uint64_t v55 = *(void *)(a4 + 16);
    if (v55 && mlir::RewriterBase::Listener::classof(v55)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void ***))(*(void *)v55 + 64))(v55, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMinOp &>(mlir::mps::ReductionMinOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v137);
    }
    return 0;
  }
  uint64_t v9 = (uint64_t *)v7;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v119))
  {
    uint64_t v57 = v119;
    uint64_t v124 = &v119;
    uint64_t v58 = *(void *)(a4 + 16);
    if (v58 && mlir::RewriterBase::Listener::classof(v58)) {
    return 0;
    }
  }
  long long v10 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v119) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_12;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_12;
  }
  unint64_t v14 = *(void **)(v11 + 8);
  BOOL v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    int v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    uint64_t v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      unint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_12:
  }
    uint64_t v20 = 0;
  v118[0] = v10;
  v118[1] = v20;
  uint64_t v137 = (void **)v139;
  uint64_t v138 = 0x600000000;
  if (!v9) {
    goto LABEL_22;
  }
  uint64_t v21 = *v9;
  unint64_t v22 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_22;
  }
  unsigned __int8 v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    __int16 v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    long long v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      unsigned __int8 v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_22:
  }
    uint64_t v30 = 0;
  mlir::getIntValues<long long>((uint64_t)v9, v30, (uint64_t)&v137, 1);
  uint64_t v134 = v136;
  memset(v136, 0, sizeof(v136));
  uint64_t v135 = 0x600000006;
  __int16 v131 = v133;
  memset_pattern16(v133, &unk_1810FE350, 0x18uLL);
  uint64_t v132 = 0x600000003;
  uint64_t v128 = v130;
  memset_pattern16(v130, &unk_1810FE350, 0x18uLL);
  uint64_t v129 = 0x600000003;
  v117[0] = mlir::getRankPromotionTypeForANE((uint64_t)v10, v20);
  v117[1] = v31;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v117);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v32);
  if (v34)
  {
    if (v138)
    {
      unint64_t v35 = (uint64_t *)IndexFromDim;
      uint64_t v36 = (uint64_t **)v137;
      uint64_t v37 = 8 * v138;
      while (1)
      {
        uint64_t v38 = *v36;
        v122[0] = v38;
        if (v38 == v35) {
          break;
        }
        if ((uint64_t)v38 <= 1)
        {
          uint64_t v64 = v119;
          uint64_t v124 = &v119;
          uint64_t v61 = *(void *)(a4 + 16);
          if (v61 && mlir::RewriterBase::Listener::classof(v61))
          {
            uint64_t v62 = *((void *)v64 + 3);
            goto LABEL_54;
          }
          goto LABEL_55;
        }
        uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v117);
        *((void *)v128 + (void)v38 - 2) = *(void *)(ArgAttrsAttr + 8 * v38);
        ++v36;
        v37 -= 8;
        if (!v37) {
          goto LABEL_29;
        }
      }
      uint64_t v60 = v119;
      uint64_t v124 = v122;
      uint64_t v125 = (uint64_t)&v119;
      uint64_t v61 = *(void *)(a4 + 16);
      if (v61 && mlir::RewriterBase::Listener::classof(v61))
      {
        uint64_t v62 = *((void *)v60 + 3);
LABEL_54:
        uint64_t v59 = (*(uint64_t (**)(uint64_t, uint64_t, void *, void **))(*(void *)v61 + 64))(v61, v62, v63, &v124);
        goto LABEL_96;
      }
LABEL_55:
      uint64_t v59 = 0;
    }
    else
    {
LABEL_29:
      uint64_t v124 = v126;
      uint64_t v125 = 0x400000000;
      uint64_t v127 = 4;
      v122[0] = (uint64_t *)3;
      uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      unint64_t v41 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v122, 1, IntegerType, 0);
      v122[0] = (uint64_t *)6;
      uint64_t v42 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      unint64_t v43 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v122, 1, v42, 0);
      v122[0] = (uint64_t *)"ksize";
      __int16 v123 = 259;
      uint64_t StringAttr = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v122);
      if (v41)
      {
        uint64_t v45 = *v41;
        unint64_t v46 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v47 = *(unsigned int *)(v45 + 16);
        if (v47)
        {
          uint64_t v48 = *(void **)(v45 + 8);
          uint64_t v49 = &v48[2 * v47];
          do
          {
            unint64_t v50 = v47 >> 1;
            unint64_t v51 = &v48[2 * (v47 >> 1)];
            unint64_t v53 = *v51;
            unint64_t v52 = v51 + 2;
            v47 += ~(v47 >> 1);
            if (v53 < v46) {
              uint64_t v48 = v52;
            }
            else {
              unint64_t v47 = v50;
            }
          }
          while (v47);
          if (v48 == v49)
          {
            uint64_t v54 = 0;
          }
          else if (*v48 == v46)
          {
            uint64_t v54 = v48[1];
          }
          else
          {
            uint64_t v54 = 0;
          }
        }
        else
        {
          uint64_t v54 = 0;
        }
      }
      else
      {
        uint64_t v54 = 0;
      }
      uint64_t v65 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v54, v128, 8 * v129, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v124, StringAttr, v65);
      v122[0] = (uint64_t *)"stride";
      __int16 v123 = 259;
      uint64_t v66 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v122);
      if (!v41) {
        goto LABEL_70;
      }
      uint64_t v67 = *v41;
      unint64_t v68 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v69 = *(unsigned int *)(v67 + 16);
      if (!v69) {
        goto LABEL_70;
      }
      unint64_t v70 = *(void **)(v67 + 8);
      uint64_t v71 = &v70[2 * v69];
      do
      {
        unint64_t v72 = v69 >> 1;
        unint64_t v73 = &v70[2 * (v69 >> 1)];
        unint64_t v75 = *v73;
        uint64_t v74 = v73 + 2;
        v69 += ~(v69 >> 1);
        if (v75 < v68) {
          unint64_t v70 = v74;
        }
        else {
          unint64_t v69 = v72;
        }
      }
      while (v69);
      if (v70 != v71 && *v70 == v68) {
        uint64_t v76 = v70[1];
      }
      else {
LABEL_70:
      }
        uint64_t v76 = 0;
      uint64_t v77 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v76, v131, 8 * v132, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v124, v66, v77);
      v122[0] = (uint64_t *)"padding";
      __int16 v123 = 259;
      uint64_t v78 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v122);
      if (!v43) {
        goto LABEL_80;
      }
      uint64_t v79 = *v43;
      unint64_t v80 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v81 = *(unsigned int *)(v79 + 16);
      if (!v81) {
        goto LABEL_80;
      }
      unint64_t v82 = *(void **)(v79 + 8);
      uint64_t v83 = &v82[2 * v81];
      do
      {
        unint64_t v84 = v81 >> 1;
        unint64_t v85 = &v82[2 * (v81 >> 1)];
        unint64_t v87 = *v85;
        uint64_t v86 = v85 + 2;
        v81 += ~(v81 >> 1);
        if (v87 < v80) {
          unint64_t v82 = v86;
        }
        else {
          unint64_t v81 = v84;
        }
      }
      while (v81);
      if (v82 != v83 && *v82 == v80) {
        uint64_t v88 = v82[1];
      }
      else {
LABEL_80:
      }
        uint64_t v88 = 0;
      uint64_t v89 = mlir::DenseElementsAttr::getFromRawBuffer(v43, v88, v134, 8 * v135, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v124, v78, v89);
      uint64_t v90 = mlir::ValueRange::dereference_iterator(v140, 0);
      v122[0] = (uint64_t *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
      if (mlir::Type::isF16((mlir::Type *)v122)
        || (uint64_t GOC = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118),
            mlir::Type::isF32((mlir::Type *)&GOC)))
      {
        uint64_t GOC = 1;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
        uint64_t v92 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&GOC, 1, OperandRange, 0);
        uint64_t v93 = (uint64_t)v92;
        if (!v92) {
          goto LABEL_92;
        }
        uint64_t v94 = *v92;
        unint64_t v95 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v96 = *(unsigned int *)(v94 + 16);
        if (!v96) {
          goto LABEL_92;
        }
        __int16 v97 = *(void **)(v94 + 8);
        uint64_t v98 = &v97[2 * v96];
        do
        {
          unint64_t v99 = v96 >> 1;
          uint64_t v100 = &v97[2 * (v96 >> 1)];
          unint64_t v102 = *v100;
          uint64_t v101 = v100 + 2;
          v96 += ~(v96 >> 1);
          if (v102 < v95) {
            __int16 v97 = v101;
          }
          else {
            unint64_t v96 = v99;
          }
        }
        while (v96);
        if (v97 != v98 && *v97 == v95) {
          uint64_t v103 = v97[1];
        }
        else {
LABEL_92:
        }
          uint64_t v103 = 0;
        uint64_t v104 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
        uint64_t v120 = (uint64_t)mlir::FloatAttr::get(v104, -1.0);
        uint64_t v59 = 1;
        v122[0] = (uint64_t *)mlir::DenseElementsAttr::get(v93, v103, &v120, 1uLL);
        uint64_t v105 = *((void *)v119 + 3);
        uint64_t v120 = 1;
        uint64_t v106 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
        uint64_t GOC = mlir::MemRefType::get(&v120, (mlir::AffineMap *)1, v106, 0, 0, 0);
        uint64_t v107 = (char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::MemRefType &,mlir::mps::MPSBufferTensorAttr &>((mlir::OpBuilder *)(a4 + 8), v105, &GOC, v122)- 16;
        uint64_t v108 = *((void *)v119 + 3);
        uint64_t v116 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&GOC);
        uint64_t v120 = (uint64_t)mlir::OpBuilder::create<mlir::anec::MaxPool,mlir::Value &,mlir::NamedAttrList &>((mlir::UnknownLoc **)(a4 + 8), v108, (uint64_t)&v116, (uint64_t)&v124);
        uint64_t v109 = (mlir::MLIRContext *)*((void *)v119 + 3);
        uint64_t v110 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v120);
        mlir::ConversionPatternRewriter::replaceOp(a4, v119, (uint64_t)v122, 1);
      }
      else
      {
        uint64_t v112 = v119;
        v122[0] = v118;
        uint64_t v113 = *(void *)(a4 + 16);
        if (v113)
        {
          if (mlir::RewriterBase::Listener::classof(v113)) {
          else
          }
            uint64_t v59 = 0;
        }
        else
        {
          uint64_t v59 = 0;
        }
      }
      if (v124 != v126) {
        free(v124);
      }
    }
LABEL_96:
    if (v128 != v130) {
      free(v128);
    }
    if (v131 != v133) {
      free(v131);
    }
    if (v134 != v136) {
      free(v134);
    }
    if (v137 != (void **)v139) {
      free(v137);
    }
    return v59;
  }
  char v114 = (mlir::Operation ***)std::__throw_bad_optional_access[abi:nn180100]();
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMinOp,mlir::mps::ReductionMinOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Collapsing dimension for Op");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, "to MaxPool, AveragePool or Conv for A13 and below on ane is not supported \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMinOp,mlir::mps::ReductionMinOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "MaxPool/AveragePool for axes:");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = **a1;
  int v17 = 2;
  uint64_t v18 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  char v8 = &v17;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v14 = v7 + 1;
    BOOL v15 = v5 + 24 * v7 > (unint64_t)&v17;
    if (v5 <= (unint64_t)&v17 && v15)
    {
      unint64_t v16 = (char *)&v17 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v14, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      char v8 = (int *)&v16[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v14, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      char v8 = &v17;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  uint64_t v11 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(v3, "reduced from Op ");
  unint64_t v12 = mlir::Diagnostic::operator<<(v11, (mlir::Operation *)*a1[1]);
  return mlir::Diagnostic::operator<<((uint64_t)v12, "is not supported for A13 and below\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMinOp,mlir::mps::ReductionMinOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Axis value is incorrect for Op");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, "\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMinOp,mlir::mps::ReductionMinOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(mlir::MemoryMapperInterface **a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "ReduceMin for non fp type: ");
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange(*a1);
  unint64_t v5 = v15;
  mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)v15, OperandRange);
  uint64_t v6 = v3 + 16;
  unint64_t v7 = *(void *)(v3 + 16);
  uint64_t v8 = *(unsigned int *)(v3 + 24);
  if (v8 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v8 + 1;
    BOOL v13 = v7 + 24 * v8 > (unint64_t)v15;
    if (v7 <= (unint64_t)v15 && v13)
    {
      unint64_t v14 = &v15[-v7];
      llvm::SmallVectorBase<unsigned int>::grow_pod(v6, (void *)(v3 + 32), v12, 24);
      unint64_t v7 = *(void *)(v3 + 16);
      unint64_t v5 = &v14[v7];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v6, (void *)(v3 + 32), v12, 24);
      unint64_t v7 = *(void *)(v3 + 16);
      unint64_t v5 = v15;
    }
  }
  unint64_t v9 = v7 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v5;
  *(void *)(v9 + 16) = *((void *)v5 + 2);
  *(_OWORD *)unint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " is not supported for A13 and below\n");
}

void *mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)1>::~ConvertReductionA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)1>::~ConvertReductionA14Minus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

mlir::GenericProgramPoint *mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v96 = *MEMORY[0x1E4F143B8];
  unint64_t v72 = a2;
  unint64_t v6 = *(void *)(a3 + 56);
  uint64_t v94 = *(void *)(a3 + 48);
  unint64_t v95 = v6;
  if (!v8)
  {
    unint64_t v75 = "failed to convert operand axes";
    v77[8] = 259;
    uint64_t v78 = &v75;
    uint64_t v42 = *(void *)(a4 + 16);
    if (v42)
    {
      if (mlir::RewriterBase::Listener::classof(v42)) {
        return (mlir::GenericProgramPoint *)(*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v42 + 64))(v42, *((void *)a2 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionSumOp &>(mlir::mps::ReductionSumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v78);
      }
      return 0;
    }
    return (mlir::GenericProgramPoint *)v42;
  }
  unint64_t v9 = (uint64_t *)v7;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v72))
  {
    unint64_t v44 = v72;
    unint64_t v75 = &v72;
    uint64_t v42 = *(void *)(a4 + 16);
    if (v42)
    {
      if (mlir::RewriterBase::Listener::classof(v42)) {
      return 0;
      }
    }
    return (mlir::GenericProgramPoint *)v42;
  }
  long long v10 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v72) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_12;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_12;
  }
  unint64_t v14 = *(void **)(v11 + 8);
  BOOL v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    int v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    uint64_t v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      unint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_12:
  }
    uint64_t v20 = 0;
  uint64_t v91 = v93;
  uint64_t v92 = 0x600000000;
  if (!v9) {
    goto LABEL_22;
  }
  uint64_t v21 = *v9;
  unint64_t v22 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_22;
  }
  unsigned __int8 v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    __int16 v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    long long v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      unsigned __int8 v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_22:
  }
    uint64_t v30 = 0;
  mlir::getIntValues<long long>((uint64_t)v9, v30, (uint64_t)&v91, 1);
  uint64_t v88 = v90;
  memset(v90, 0, sizeof(v90));
  uint64_t v89 = 0x600000006;
  unint64_t v85 = v87;
  memset_pattern16(v87, &unk_1810FE350, 0x18uLL);
  uint64_t v86 = 0x600000003;
  unint64_t v82 = v84;
  memset_pattern16(v84, &unk_1810FE350, 0x18uLL);
  uint64_t v83 = 0x600000003;
  v71[0] = mlir::getRankPromotionTypeForANE((uint64_t)v10, v20);
  v71[1] = v31;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v71);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v32);
  if (v34)
  {
    if (v92 == 1 && *v91 == IndexFromDim)
    {
      uint64_t v69 = *((void *)v72 + 3);
      uint64_t v35 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v71)
                      + 8 * IndexFromDim);
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v71);
      uint64_t v78 = v80;
      v80[0] = 1;
      v80[1] = v35;
      int64x2_t v81 = vdupq_n_s64(1uLL);
      uint64_t v79 = 0x1000000004;
      uint64_t v70 = mlir::MemRefType::get(v80, (mlir::AffineMap *)4, OperandRange, 0, 0, 0);
      Value = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v70);
      uint64_t NumElements = (llvm::APFloatBase *)mlir::ShapedType::getNumElements(Value, v38);
      unint64_t v40 = (llvm::APFloatBase *)llvm::APFloatBase::IEEEhalf(NumElements);
      unint64_t v41 = (llvm::APFloatBase *)llvm::APFloatBase::PPCDoubleDouble(v40);
      if (v41 == v40) {
        llvm::detail::DoubleAPFloat::DoubleAPFloat(v74, (uint64_t)v40, 1);
      }
      else {
        llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v74, (uint64_t)v40, (llvm::APInt *)1);
      }
      unint64_t v75 = v77;
      uint64_t v76 = 0x1000000000;
      llvm::SmallVectorImpl<llvm::APFloat>::assign((unsigned int *)&v75, (unint64_t)NumElements, (uint64_t)&ElementsAttr);
      if (v41 == (llvm::APFloatBase *)v74[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v74);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v74);
      }
      unint64_t v47 = v78;
      uint64_t v48 = v79;
      uint64_t F16Type = mlir::Builder::getF16Type((mlir::Float16Type **)(a4 + 8), v46);
      unint64_t v50 = (void *)mlir::RankedTensorType::get((uint64_t)v47, v48, F16Type, 0);
      ElementsAttr = mlir::createElementsAttr(v50, (uint64_t)v75, v76);
      v74[0] = v51;
      mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 8), v69, &v70, (void **)&ElementsAttr);
      unint64_t v52 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v72) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v52) {
        goto LABEL_53;
      }
      uint64_t v53 = *v52;
      unint64_t v54 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v55 = *(unsigned int *)(v53 + 16);
      if (!v55) {
        goto LABEL_53;
      }
      uint64_t v56 = *(void **)(v53 + 8);
      uint64_t v57 = &v56[2 * v55];
      do
      {
        unint64_t v58 = v55 >> 1;
        uint64_t v59 = &v56[2 * (v55 >> 1)];
        unint64_t v61 = *v59;
        uint64_t v60 = v59 + 2;
        v55 += ~(v55 >> 1);
        if (v61 < v54) {
          uint64_t v56 = v60;
        }
        else {
          unint64_t v55 = v58;
        }
      }
      while (v55);
      if (v56 != v57 && *v56 == v54) {
        uint64_t v62 = v56[1];
      }
      else {
LABEL_53:
      }
        uint64_t v62 = 0;
    }
    uint64_t v45 = v72;
    unint64_t v75 = &v72;
    uint64_t v42 = *(void *)(a4 + 16);
    if (v42)
    {
      if (mlir::RewriterBase::Listener::classof(v42)) {
      else
      }
        uint64_t v42 = 0;
    }
    if (v82 != v84) {
      free(v82);
    }
    if (v85 != v87) {
      free(v85);
    }
    if (v88 != v90) {
      free(v88);
    }
    if (v91 != (void *)v93) {
      free(v91);
    }
    return (mlir::GenericProgramPoint *)v42;
  }
  uint64_t v64 = (mlir::Builder *)std::__throw_bad_optional_access[abi:nn180100]();
  return mlir::OpBuilder::create<mlir::anec::Convolution,mlir::MemRefType &,mlir::Value,mlir::Value&>(v64, v65, v66, v67, v68);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Convolution,mlir::MemRefType &,mlir::Value,mlir::Value&>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.convolution", (const unsigned __int8 *)0x10, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"anec.convolution";
    v19[3] = 16;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::anec::Convolution::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  unint64_t v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id) {
    unint64_t v14 = v13;
  }
  else {
    unint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionSumOp,mlir::mps::ReductionSumOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Collapsing dimension for Op");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, "to MaxPool, AveragePool or Conv for A13 and below on ane is not supported \n");
}

void llvm::SmallVectorImpl<llvm::APFloat>::assign(unsigned int *a1, unint64_t a2, uint64_t a3)
{
  unint64_t v5 = a1;
  if (a1[3] >= a2)
  {
    unint64_t v6 = a1[2];
    if (v6 >= a2) {
      unint64_t v7 = a2;
    }
    else {
      unint64_t v7 = a1[2];
    }
    if (v7)
    {
      char v8 = (llvm::APFloatBase *)(*(void *)a1 + 8);
      do
      {
        a1 = (unsigned int *)llvm::APFloat::Storage::operator=(v8, (uint64_t *)(a3 + 8));
        char v8 = (llvm::APFloatBase *)((char *)v8 + 32);
        --v7;
      }
      while (v7);
      unint64_t v6 = v5[2];
    }
    unint64_t v9 = v6 - a2;
    if (v6 >= a2)
    {
      if (v6 > a2)
      {
        uint64_t v16 = *(void *)v5;
        int v17 = llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1);
        __int16 v18 = (llvm::detail::DoubleAPFloat *)(32 * v6 + v16 - 24);
        uint64_t v19 = 32 * a2 - 32 * v6;
        do
        {
          if (v17 == *(void **)v18) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat(v18);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat(v18);
          }
          __int16 v18 = (llvm::detail::DoubleAPFloat *)(v20 - 32);
          v19 += 32;
        }
        while (v19);
      }
    }
    else
    {
      uint64_t v10 = *(void *)v5;
      uint64_t v11 = (const llvm::detail::DoubleAPFloat *)(a3 + 8);
      char v12 = llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1);
      unint64_t v13 = (llvm::detail::DoubleAPFloat *)(v10 + 32 * v6 + 8);
      do
      {
        if (v12 == *(void **)v11) {
          unint64_t v14 = llvm::detail::DoubleAPFloat::DoubleAPFloat(v13, v11);
        }
        else {
          unint64_t v14 = (llvm::detail::DoubleAPFloat *)llvm::detail::IEEEFloat::IEEEFloat(v13, v11);
        }
        unint64_t v13 = (llvm::detail::DoubleAPFloat *)((char *)v14 + 32);
      }
      while (!__CFADD__(v9++, 1));
    }
    v5[2] = a2;
  }
  else
  {
    llvm::SmallVectorTemplateBase<llvm::APFloat,false>::growAndAssign((uint64_t)a1, a2, a3);
  }
}

void llvm::SmallVectorTemplateBase<llvm::APFloat,false>::growAndAssign(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v20 = 0;
  unint64_t v6 = (char *)(a1 + 16);
  unint64_t v7 = (llvm::APFloatBase *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), a2, 32, &v20);
  char v8 = v7;
  if (a2)
  {
    unint64_t v9 = (const llvm::detail::DoubleAPFloat *)(a3 + 8);
    uint64_t v10 = llvm::APFloatBase::PPCDoubleDouble(v7);
    unint64_t v7 = (llvm::APFloatBase *)((char *)v8 + 8);
    unint64_t v11 = a2;
    do
    {
      if (v10 == *(void **)v9) {
        char v12 = llvm::detail::DoubleAPFloat::DoubleAPFloat(v7, v9);
      }
      else {
        char v12 = (llvm::detail::DoubleAPFloat *)llvm::detail::IEEEFloat::IEEEFloat(v7, v9);
      }
      unint64_t v7 = (llvm::detail::DoubleAPFloat *)((char *)v12 + 32);
      --v11;
    }
    while (v11);
  }
  unint64_t v13 = *(char **)a1;
  uint64_t v14 = *(unsigned int *)(a1 + 8);
  if (v14)
  {
    BOOL v15 = llvm::APFloatBase::PPCDoubleDouble(v7);
    uint64_t v16 = v13 - 24;
    uint64_t v17 = 32 * v14;
    do
    {
      while (1)
      {
        __int16 v18 = (llvm::detail::DoubleAPFloat *)&v16[v17];
        if (v15 != *(void **)&v16[v17]) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v18);
        v17 -= 32;
        if (!v17) {
          goto LABEL_12;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v18);
      v17 -= 32;
    }
    while (v17);
LABEL_12:
    unint64_t v13 = *(char **)a1;
  }
  int v19 = v20;
  if (v13 != v6) {
    free(v13);
  }
  *(void *)a1 = v8;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = v19;
}

llvm::APFloatBase *llvm::APFloat::Storage::operator=(llvm::APFloatBase *a1, uint64_t *a2)
{
  uint64_t v4 = *(void **)a1;
  unint64_t v5 = llvm::APFloatBase::PPCDoubleDouble(a1);
  uint64_t v6 = *a2;
  if (v5 != v4 && v5 != (void *)v6)
  {
    llvm::detail::IEEEFloat::operator=((uint64_t *)a1, a2);
    return a1;
  }
  char v8 = v5;
  if (v5 != v4)
  {
    if (a1 == (llvm::APFloatBase *)a2) {
      return a1;
    }
    llvm::detail::IEEEFloat::~IEEEFloat(a1);
    goto LABEL_12;
  }
  if (v4 == (void *)v6)
  {
    llvm::detail::DoubleAPFloat::operator=((uint64_t *)a1, a2);
    return a1;
  }
  if (a1 != (llvm::APFloatBase *)a2)
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat(a1);
LABEL_12:
    if (v8 == (void *)*a2) {
      llvm::detail::DoubleAPFloat::DoubleAPFloat(a1, (const llvm::detail::DoubleAPFloat *)a2);
    }
    else {
      llvm::detail::IEEEFloat::IEEEFloat(a1, (const llvm::detail::IEEEFloat *)a2);
    }
  }
  return a1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionSumOp,mlir::mps::ReductionSumOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "ReduceSum for axes other than channel axis: ");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " is not supported for A13 and below\n");
}

void *mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)0>::~ConvertReductionA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)0>::~ConvertReductionA14Minus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v112[2] = *MEMORY[0x1E4F143B8];
  uint64_t v93 = (unsigned int *)a2;
  unint64_t v6 = *(void *)(a3 + 64);
  v112[0] = *(void *)(a3 + 56);
  v112[1] = v6;
  if (!v8)
  {
    uint64_t v96 = "failed to convert operand axes";
    v98[8] = 259;
    uint64_t v109 = &v96;
    uint64_t v55 = *(void *)(a4 + 16);
    if (v55)
    {
      if (mlir::RewriterBase::Listener::classof(v55)) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void ***))(*(void *)v55 + 64))(v55, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMaxOp &>(mlir::mps::ReductionMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v109);
      }
      return 0;
    }
    return v55;
  }
  unint64_t v9 = (uint64_t *)v7;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v93))
  {
    uint64_t v57 = v93;
    uint64_t v96 = &v93;
    uint64_t v55 = *(void *)(a4 + 16);
    if (v55)
    {
      if (mlir::RewriterBase::Listener::classof(v55)) {
      return 0;
      }
    }
    return v55;
  }
  uint64_t v10 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v93) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_12;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_12;
  }
  uint64_t v14 = *(void **)(v11 + 8);
  BOOL v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    uint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    __int16 v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      uint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_12:
  }
    uint64_t v20 = 0;
  uint64_t v109 = (void **)v111;
  uint64_t v110 = 0x600000000;
  if (!v9) {
    goto LABEL_22;
  }
  uint64_t v21 = *v9;
  unint64_t v22 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_22;
  }
  unsigned __int8 v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    __int16 v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    long long v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      unsigned __int8 v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_22:
  }
    uint64_t v30 = 0;
  mlir::getIntValues<long long>((uint64_t)v9, v30, (uint64_t)&v109, 1);
  uint64_t v106 = v108;
  memset(v108, 0, sizeof(v108));
  uint64_t v107 = 0x600000006;
  uint64_t v103 = v105;
  memset_pattern16(v105, &unk_1810FE350, 0x18uLL);
  uint64_t v104 = 0x600000003;
  uint64_t v100 = v102;
  memset_pattern16(v102, &unk_1810FE350, 0x18uLL);
  uint64_t v101 = 0x600000003;
  v92[0] = mlir::getRankPromotionTypeForANE((uint64_t)v10, v20);
  v92[1] = v31;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v92);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v32);
  if (v34)
  {
    if (v110)
    {
      unint64_t v35 = IndexFromDim;
      uint64_t v36 = (uint64_t *)v109;
      uint64_t v37 = 8 * v110;
      while (1)
      {
        uint64_t v38 = *v36;
        v94[0] = v38;
        if (v38 == v35) {
          break;
        }
        if (v38 <= 1)
        {
          unint64_t v61 = v93;
          uint64_t v96 = &v93;
          uint64_t v55 = *(void *)(a4 + 16);
          if (!v55) {
            goto LABEL_89;
          }
          if (mlir::RewriterBase::Listener::classof(v55))
          {
            uint64_t v59 = *((void *)v61 + 3);
            goto LABEL_54;
          }
          goto LABEL_56;
        }
        uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v92);
        *((void *)v100 + v38 - 2) = *(void *)(ArgAttrsAttr + 8 * v38);
        ++v36;
        v37 -= 8;
        if (!v37) {
          goto LABEL_29;
        }
      }
      unint64_t v58 = v93;
      uint64_t v96 = v94;
      uint64_t v97 = (uint64_t)&v93;
      uint64_t v55 = *(void *)(a4 + 16);
      if (!v55) {
        goto LABEL_89;
      }
      if (mlir::RewriterBase::Listener::classof(v55))
      {
        uint64_t v59 = *((void *)v58 + 3);
LABEL_54:
        uint64_t v55 = (*(uint64_t (**)(uint64_t, uint64_t, void *, void **))(*(void *)v55 + 64))(v55, v59, v60, &v96);
        goto LABEL_89;
      }
LABEL_56:
      uint64_t v55 = 0;
    }
    else
    {
LABEL_29:
      uint64_t v96 = v98;
      uint64_t v97 = 0x400000000;
      uint64_t v99 = 4;
      v94[0] = 3;
      uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      unint64_t v41 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v94, 1, IntegerType, 0);
      v94[0] = 6;
      uint64_t v42 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      unint64_t v43 = (void *)mlir::RankedTensorType::get((uint64_t)v94, 1, v42, 0);
      v94[0] = "ksize";
      __int16 v95 = 259;
      uint64_t StringAttr = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v94);
      if (v41)
      {
        uint64_t v45 = *v41;
        unint64_t v46 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v47 = *(unsigned int *)(v45 + 16);
        if (v47)
        {
          uint64_t v48 = *(void **)(v45 + 8);
          uint64_t v49 = &v48[2 * v47];
          do
          {
            unint64_t v50 = v47 >> 1;
            uint64_t v51 = &v48[2 * (v47 >> 1)];
            unint64_t v53 = *v51;
            unint64_t v52 = v51 + 2;
            v47 += ~(v47 >> 1);
            if (v53 < v46) {
              uint64_t v48 = v52;
            }
            else {
              unint64_t v47 = v50;
            }
          }
          while (v47);
          if (v48 == v49)
          {
            uint64_t v54 = 0;
          }
          else if (*v48 == v46)
          {
            uint64_t v54 = v48[1];
          }
          else
          {
            uint64_t v54 = 0;
          }
        }
        else
        {
          uint64_t v54 = 0;
        }
      }
      else
      {
        uint64_t v54 = 0;
      }
      uint64_t v62 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v54, v100, 8 * v101, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v96, StringAttr, v62);
      v94[0] = "stride";
      __int16 v95 = 259;
      uint64_t v63 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v94);
      if (v41)
      {
        uint64_t v64 = v43;
        uint64_t v65 = *v41;
        unint64_t v66 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v67 = *(unsigned int *)(v65 + 16);
        if (v67)
        {
          unint64_t v68 = *(void **)(v65 + 8);
          uint64_t v69 = &v68[2 * v67];
          do
          {
            unint64_t v70 = v67 >> 1;
            uint64_t v71 = &v68[2 * (v67 >> 1)];
            unint64_t v73 = *v71;
            unint64_t v72 = v71 + 2;
            v67 += ~(v67 >> 1);
            if (v73 < v66) {
              unint64_t v68 = v72;
            }
            else {
              unint64_t v67 = v70;
            }
          }
          while (v67);
          unint64_t v43 = v64;
          if (v68 == v69)
          {
            uint64_t v74 = 0;
          }
          else if (*v68 == v66)
          {
            uint64_t v74 = v68[1];
          }
          else
          {
            uint64_t v74 = 0;
          }
        }
        else
        {
          uint64_t v74 = 0;
          unint64_t v43 = v64;
        }
      }
      else
      {
        uint64_t v74 = 0;
      }
      uint64_t v75 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v74, v103, 8 * v104, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v96, v63, v75);
      v94[0] = "padding";
      __int16 v95 = 259;
      uint64_t v76 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v94);
      if (v43
        && (uint64_t v77 = *v43, v78 = mlir::TypeID::get<mlir::ShapedType>(), v79 = *(unsigned int *)(v77 + 16), v79))
      {
        unint64_t v80 = *(void **)(v77 + 8);
        int64x2_t v81 = &v80[2 * v79];
        do
        {
          unint64_t v82 = v79 >> 1;
          uint64_t v83 = &v80[2 * (v79 >> 1)];
          unint64_t v85 = *v83;
          unint64_t v84 = v83 + 2;
          v79 += ~(v79 >> 1);
          if (v85 < v78) {
            unint64_t v80 = v84;
          }
          else {
            unint64_t v79 = v82;
          }
        }
        while (v79);
        if (v80 != v81 && *v80 == v78) {
          uint64_t v86 = v80[1];
        }
        else {
          uint64_t v86 = 0;
        }
      }
      else
      {
        uint64_t v86 = 0;
      }
      uint64_t v87 = mlir::DenseElementsAttr::getFromRawBuffer(v43, v86, v106, 8 * v107, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v96, v76, v87);
      v94[0] = mlir::ValueRange::dereference_iterator(v112, 0);
      uint64_t v91 = (char *)mlir::OpBuilder::create<mlir::anec::MaxPool,mlir::Value &,mlir::NamedAttrList &>((mlir::UnknownLoc **)(a4 + 8), *((void *)v93 + 3), (uint64_t)v94, (uint64_t)&v96)- 16;
      mlir::ConversionPatternRewriter::replaceOp(a4, v93, (uint64_t)&v91, 1);
      if (v96 != v98) {
        free(v96);
      }
      uint64_t v55 = 1;
    }
LABEL_89:
    if (v100 != v102) {
      free(v100);
    }
    if (v103 != v105) {
      free(v103);
    }
    if (v106 != v108) {
      free(v106);
    }
    if (v109 != (void **)v111) {
      free(v109);
    }
    return v55;
  }
  uint64_t v89 = (mlir::Operation ***)std::__throw_bad_optional_access[abi:nn180100]();
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMaxOp,mlir::mps::ReductionMaxOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Collapsing dimension for Op");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, "to MaxPool, AveragePool or Conv for A13 and below on ane is not supported \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMaxOp,mlir::mps::ReductionMaxOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "MaxPool/AveragePool for axes:");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = **a1;
  int v17 = 2;
  uint64_t v18 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  char v8 = &v17;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v14 = v7 + 1;
    BOOL v15 = v5 + 24 * v7 > (unint64_t)&v17;
    if (v5 <= (unint64_t)&v17 && v15)
    {
      unint64_t v16 = (char *)&v17 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v14, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      char v8 = (int *)&v16[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v14, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      char v8 = &v17;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  uint64_t v11 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(v3, "reduced from Op ");
  unint64_t v12 = mlir::Diagnostic::operator<<(v11, (mlir::Operation *)*a1[1]);
  return mlir::Diagnostic::operator<<((uint64_t)v12, "is not supported for A13 and below\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMaxOp,mlir::mps::ReductionMaxOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Axis value is incorrect for Op");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, "\n");
}

void *mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)0>::~ConvertReductionA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)0>::~ConvertReductionA14Minus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v114[2] = *MEMORY[0x1E4F143B8];
  __int16 v95 = (unsigned int *)a2;
  unint64_t v6 = *(void *)(a3 + 56);
  v114[0] = *(void *)(a3 + 48);
  v114[1] = v6;
  if (!v8)
  {
    uint64_t v98 = "failed to convert operand axes";
    v100[8] = 259;
    uint64_t v111 = &v98;
    uint64_t v55 = *(void *)(a4 + 16);
    if (v55)
    {
      if (mlir::RewriterBase::Listener::classof(v55)) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void ***))(*(void *)v55 + 64))(v55, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMeanOp &>(mlir::mps::ReductionMeanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v111);
      }
      return 0;
    }
    return v55;
  }
  uint64_t v9 = (uint64_t *)v7;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v95))
  {
    uint64_t v57 = v95;
    uint64_t v98 = &v95;
    uint64_t v55 = *(void *)(a4 + 16);
    if (v55)
    {
      if (mlir::RewriterBase::Listener::classof(v55)) {
      return 0;
      }
    }
    return v55;
  }
  long long v10 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_12;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_12;
  }
  unint64_t v14 = *(void **)(v11 + 8);
  BOOL v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    int v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    uint64_t v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      unint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_12:
  }
    uint64_t v20 = 0;
  uint64_t v111 = (void **)v113;
  uint64_t v112 = 0x600000000;
  if (!v9) {
    goto LABEL_22;
  }
  uint64_t v21 = *v9;
  unint64_t v22 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_22;
  }
  unsigned __int8 v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    __int16 v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    long long v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      unsigned __int8 v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_22:
  }
    uint64_t v30 = 0;
  mlir::getIntValues<long long>((uint64_t)v9, v30, (uint64_t)&v111, 1);
  uint64_t v108 = v110;
  memset(v110, 0, sizeof(v110));
  uint64_t v109 = 0x600000006;
  uint64_t v105 = v107;
  memset_pattern16(v107, &unk_1810FE350, 0x18uLL);
  uint64_t v106 = 0x600000003;
  unint64_t v102 = v104;
  memset_pattern16(v104, &unk_1810FE350, 0x18uLL);
  uint64_t v103 = 0x600000003;
  v94[0] = mlir::getRankPromotionTypeForANE((uint64_t)v10, v20);
  v94[1] = v31;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v94);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v32);
  if (v34)
  {
    if (v112)
    {
      unint64_t v35 = IndexFromDim;
      uint64_t v36 = (uint64_t *)v111;
      uint64_t v37 = 8 * v112;
      while (1)
      {
        uint64_t v38 = *v36;
        v96[0] = v38;
        if (v38 == v35) {
          break;
        }
        if (v38 <= 1)
        {
          unint64_t v61 = v95;
          uint64_t v98 = &v95;
          uint64_t v55 = *(void *)(a4 + 16);
          if (!v55) {
            goto LABEL_89;
          }
          if (mlir::RewriterBase::Listener::classof(v55))
          {
            uint64_t v59 = *((void *)v61 + 3);
            goto LABEL_54;
          }
          goto LABEL_56;
        }
        uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v94);
        *((void *)v102 + v38 - 2) = *(void *)(ArgAttrsAttr + 8 * v38);
        ++v36;
        v37 -= 8;
        if (!v37) {
          goto LABEL_29;
        }
      }
      unint64_t v58 = v95;
      uint64_t v98 = v96;
      uint64_t v99 = (uint64_t)&v95;
      uint64_t v55 = *(void *)(a4 + 16);
      if (!v55) {
        goto LABEL_89;
      }
      if (mlir::RewriterBase::Listener::classof(v55))
      {
        uint64_t v59 = *((void *)v58 + 3);
LABEL_54:
        uint64_t v55 = (*(uint64_t (**)(uint64_t, uint64_t, void *, void **))(*(void *)v55 + 64))(v55, v59, v60, &v98);
        goto LABEL_89;
      }
LABEL_56:
      uint64_t v55 = 0;
    }
    else
    {
LABEL_29:
      uint64_t v98 = v100;
      uint64_t v99 = 0x400000000;
      uint64_t v101 = 4;
      v96[0] = 3;
      uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      unint64_t v41 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v96, 1, IntegerType, 0);
      v96[0] = 6;
      uint64_t v42 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      unint64_t v43 = (void *)mlir::RankedTensorType::get((uint64_t)v96, 1, v42, 0);
      v96[0] = "ksize";
      __int16 v97 = 259;
      uint64_t StringAttr = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v96);
      if (v41)
      {
        uint64_t v45 = *v41;
        unint64_t v46 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v47 = *(unsigned int *)(v45 + 16);
        if (v47)
        {
          uint64_t v48 = *(void **)(v45 + 8);
          uint64_t v49 = &v48[2 * v47];
          do
          {
            unint64_t v50 = v47 >> 1;
            uint64_t v51 = &v48[2 * (v47 >> 1)];
            unint64_t v53 = *v51;
            unint64_t v52 = v51 + 2;
            v47 += ~(v47 >> 1);
            if (v53 < v46) {
              uint64_t v48 = v52;
            }
            else {
              unint64_t v47 = v50;
            }
          }
          while (v47);
          if (v48 == v49)
          {
            uint64_t v54 = 0;
          }
          else if (*v48 == v46)
          {
            uint64_t v54 = v48[1];
          }
          else
          {
            uint64_t v54 = 0;
          }
        }
        else
        {
          uint64_t v54 = 0;
        }
      }
      else
      {
        uint64_t v54 = 0;
      }
      uint64_t v62 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v54, v102, 8 * v103, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v98, StringAttr, v62);
      v96[0] = "stride";
      __int16 v97 = 259;
      uint64_t v63 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v96);
      if (v41)
      {
        uint64_t v64 = v43;
        uint64_t v65 = *v41;
        unint64_t v66 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v67 = *(unsigned int *)(v65 + 16);
        if (v67)
        {
          unint64_t v68 = *(void **)(v65 + 8);
          uint64_t v69 = &v68[2 * v67];
          do
          {
            unint64_t v70 = v67 >> 1;
            uint64_t v71 = &v68[2 * (v67 >> 1)];
            unint64_t v73 = *v71;
            unint64_t v72 = v71 + 2;
            v67 += ~(v67 >> 1);
            if (v73 < v66) {
              unint64_t v68 = v72;
            }
            else {
              unint64_t v67 = v70;
            }
          }
          while (v67);
          unint64_t v43 = v64;
          if (v68 == v69)
          {
            uint64_t v74 = 0;
          }
          else if (*v68 == v66)
          {
            uint64_t v74 = v68[1];
          }
          else
          {
            uint64_t v74 = 0;
          }
        }
        else
        {
          uint64_t v74 = 0;
          unint64_t v43 = v64;
        }
      }
      else
      {
        uint64_t v74 = 0;
      }
      uint64_t v75 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v74, v105, 8 * v106, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v98, v63, v75);
      v96[0] = "padding";
      __int16 v97 = 259;
      uint64_t v76 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v96);
      if (v43
        && (uint64_t v77 = *v43, v78 = mlir::TypeID::get<mlir::ShapedType>(), v79 = *(unsigned int *)(v77 + 16), v79))
      {
        unint64_t v80 = *(void **)(v77 + 8);
        int64x2_t v81 = &v80[2 * v79];
        do
        {
          unint64_t v82 = v79 >> 1;
          uint64_t v83 = &v80[2 * (v79 >> 1)];
          unint64_t v85 = *v83;
          unint64_t v84 = v83 + 2;
          v79 += ~(v79 >> 1);
          if (v85 < v78) {
            unint64_t v80 = v84;
          }
          else {
            unint64_t v79 = v82;
          }
        }
        while (v79);
        if (v80 != v81 && *v80 == v78) {
          uint64_t v86 = v80[1];
        }
        else {
          uint64_t v86 = 0;
        }
      }
      else
      {
        uint64_t v86 = 0;
      }
      uint64_t v87 = mlir::DenseElementsAttr::getFromRawBuffer(v43, v86, v108, 8 * v109, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v98, v76, v87);
      v96[0] = mlir::ValueRange::dereference_iterator(v114, 0);
      uint64_t UnitAttr = mlir::Builder::getUnitAttr((mlir::UnitAttr **)(a4 + 8), v88);
      mlir::NamedAttrList::set((uint64_t)&v98, (uint64_t)"inc_pad", 7, UnitAttr);
      uint64_t v93 = (char *)mlir::OpBuilder::create<mlir::anec::AveragePool,mlir::Value &,mlir::NamedAttrList &>((mlir::UnknownLoc **)(a4 + 8), *((void *)v95 + 3), (uint64_t)v96, (uint64_t)&v98)- 16;
      mlir::ConversionPatternRewriter::replaceOp(a4, v95, (uint64_t)&v93, 1);
      if (v98 != v100) {
        free(v98);
      }
      uint64_t v55 = 1;
    }
LABEL_89:
    if (v102 != v104) {
      free(v102);
    }
    if (v105 != v107) {
      free(v105);
    }
    if (v108 != v110) {
      free(v108);
    }
    if (v111 != (void **)v113) {
      free(v111);
    }
    return v55;
  }
  uint64_t v91 = (mlir::Operation ***)std::__throw_bad_optional_access[abi:nn180100]();
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMeanOp,mlir::mps::ReductionMeanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Collapsing dimension for Op");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, "to MaxPool, AveragePool or Conv for A13 and below on ane is not supported \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMeanOp,mlir::mps::ReductionMeanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "MaxPool/AveragePool for axes:");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = **a1;
  int v17 = 2;
  uint64_t v18 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  char v8 = &v17;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v14 = v7 + 1;
    BOOL v15 = v5 + 24 * v7 > (unint64_t)&v17;
    if (v5 <= (unint64_t)&v17 && v15)
    {
      unint64_t v16 = (char *)&v17 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v14, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      char v8 = (int *)&v16[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v14, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      char v8 = &v17;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  uint64_t v11 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(v3, "reduced from Op ");
  unint64_t v12 = mlir::Diagnostic::operator<<(v11, (mlir::Operation *)*a1[1]);
  return mlir::Diagnostic::operator<<((uint64_t)v12, "is not supported for A13 and below\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMeanOp,mlir::mps::ReductionMeanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Axis value is incorrect for Op");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, "\n");
}

void *mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)0>::~ConvertReductionA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)0>::~ConvertReductionA14Minus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v140[2] = *MEMORY[0x1E4F143B8];
  uint64_t v119 = (unsigned int *)a2;
  unint64_t v6 = *(void *)(a3 + 64);
  v140[0] = *(void *)(a3 + 56);
  v140[1] = v6;
  if (!v8)
  {
    uint64_t v124 = "failed to convert operand axes";
    v126[8] = 259;
    uint64_t v137 = &v124;
    uint64_t v55 = *(void *)(a4 + 16);
    if (v55 && mlir::RewriterBase::Listener::classof(v55)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void ***))(*(void *)v55 + 64))(v55, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMinOp &>(mlir::mps::ReductionMinOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v137);
    }
    return 0;
  }
  uint64_t v9 = (uint64_t *)v7;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v119))
  {
    uint64_t v57 = v119;
    uint64_t v124 = &v119;
    uint64_t v58 = *(void *)(a4 + 16);
    if (v58 && mlir::RewriterBase::Listener::classof(v58)) {
    return 0;
    }
  }
  long long v10 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v119) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_12;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_12;
  }
  unint64_t v14 = *(void **)(v11 + 8);
  BOOL v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    int v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    uint64_t v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      unint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_12:
  }
    uint64_t v20 = 0;
  v118[0] = v10;
  v118[1] = v20;
  uint64_t v137 = (void **)v139;
  uint64_t v138 = 0x600000000;
  if (!v9) {
    goto LABEL_22;
  }
  uint64_t v21 = *v9;
  unint64_t v22 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_22;
  }
  unsigned __int8 v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    __int16 v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    long long v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      unsigned __int8 v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_22:
  }
    uint64_t v30 = 0;
  mlir::getIntValues<long long>((uint64_t)v9, v30, (uint64_t)&v137, 1);
  uint64_t v134 = v136;
  memset(v136, 0, sizeof(v136));
  uint64_t v135 = 0x600000006;
  __int16 v131 = v133;
  memset_pattern16(v133, &unk_1810FE350, 0x18uLL);
  uint64_t v132 = 0x600000003;
  uint64_t v128 = v130;
  memset_pattern16(v130, &unk_1810FE350, 0x18uLL);
  uint64_t v129 = 0x600000003;
  v117[0] = mlir::getRankPromotionTypeForANE((uint64_t)v10, v20);
  v117[1] = v31;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v117);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v32);
  if (v34)
  {
    if (v138)
    {
      unint64_t v35 = (uint64_t *)IndexFromDim;
      uint64_t v36 = (uint64_t **)v137;
      uint64_t v37 = 8 * v138;
      while (1)
      {
        uint64_t v38 = *v36;
        v122[0] = v38;
        if (v38 == v35) {
          break;
        }
        if ((uint64_t)v38 <= 1)
        {
          uint64_t v64 = v119;
          uint64_t v124 = &v119;
          uint64_t v61 = *(void *)(a4 + 16);
          if (v61 && mlir::RewriterBase::Listener::classof(v61))
          {
            uint64_t v62 = *((void *)v64 + 3);
            goto LABEL_54;
          }
          goto LABEL_55;
        }
        uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v117);
        *((void *)v128 + (void)v38 - 2) = *(void *)(ArgAttrsAttr + 8 * v38);
        ++v36;
        v37 -= 8;
        if (!v37) {
          goto LABEL_29;
        }
      }
      uint64_t v60 = v119;
      uint64_t v124 = v122;
      uint64_t v125 = (uint64_t)&v119;
      uint64_t v61 = *(void *)(a4 + 16);
      if (v61 && mlir::RewriterBase::Listener::classof(v61))
      {
        uint64_t v62 = *((void *)v60 + 3);
LABEL_54:
        uint64_t v59 = (*(uint64_t (**)(uint64_t, uint64_t, void *, void **))(*(void *)v61 + 64))(v61, v62, v63, &v124);
        goto LABEL_96;
      }
LABEL_55:
      uint64_t v59 = 0;
    }
    else
    {
LABEL_29:
      uint64_t v124 = v126;
      uint64_t v125 = 0x400000000;
      uint64_t v127 = 4;
      v122[0] = (uint64_t *)3;
      uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      unint64_t v41 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v122, 1, IntegerType, 0);
      v122[0] = (uint64_t *)6;
      uint64_t v42 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      unint64_t v43 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v122, 1, v42, 0);
      v122[0] = (uint64_t *)"ksize";
      __int16 v123 = 259;
      uint64_t StringAttr = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v122);
      if (v41)
      {
        uint64_t v45 = *v41;
        unint64_t v46 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v47 = *(unsigned int *)(v45 + 16);
        if (v47)
        {
          uint64_t v48 = *(void **)(v45 + 8);
          uint64_t v49 = &v48[2 * v47];
          do
          {
            unint64_t v50 = v47 >> 1;
            uint64_t v51 = &v48[2 * (v47 >> 1)];
            unint64_t v53 = *v51;
            unint64_t v52 = v51 + 2;
            v47 += ~(v47 >> 1);
            if (v53 < v46) {
              uint64_t v48 = v52;
            }
            else {
              unint64_t v47 = v50;
            }
          }
          while (v47);
          if (v48 == v49)
          {
            uint64_t v54 = 0;
          }
          else if (*v48 == v46)
          {
            uint64_t v54 = v48[1];
          }
          else
          {
            uint64_t v54 = 0;
          }
        }
        else
        {
          uint64_t v54 = 0;
        }
      }
      else
      {
        uint64_t v54 = 0;
      }
      uint64_t v65 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v54, v128, 8 * v129, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v124, StringAttr, v65);
      v122[0] = (uint64_t *)"stride";
      __int16 v123 = 259;
      uint64_t v66 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v122);
      if (!v41) {
        goto LABEL_70;
      }
      uint64_t v67 = *v41;
      unint64_t v68 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v69 = *(unsigned int *)(v67 + 16);
      if (!v69) {
        goto LABEL_70;
      }
      unint64_t v70 = *(void **)(v67 + 8);
      uint64_t v71 = &v70[2 * v69];
      do
      {
        unint64_t v72 = v69 >> 1;
        unint64_t v73 = &v70[2 * (v69 >> 1)];
        unint64_t v75 = *v73;
        uint64_t v74 = v73 + 2;
        v69 += ~(v69 >> 1);
        if (v75 < v68) {
          unint64_t v70 = v74;
        }
        else {
          unint64_t v69 = v72;
        }
      }
      while (v69);
      if (v70 != v71 && *v70 == v68) {
        uint64_t v76 = v70[1];
      }
      else {
LABEL_70:
      }
        uint64_t v76 = 0;
      uint64_t v77 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v76, v131, 8 * v132, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v124, v66, v77);
      v122[0] = (uint64_t *)"padding";
      __int16 v123 = 259;
      uint64_t v78 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v122);
      if (!v43) {
        goto LABEL_80;
      }
      uint64_t v79 = *v43;
      unint64_t v80 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v81 = *(unsigned int *)(v79 + 16);
      if (!v81) {
        goto LABEL_80;
      }
      unint64_t v82 = *(void **)(v79 + 8);
      uint64_t v83 = &v82[2 * v81];
      do
      {
        unint64_t v84 = v81 >> 1;
        unint64_t v85 = &v82[2 * (v81 >> 1)];
        unint64_t v87 = *v85;
        uint64_t v86 = v85 + 2;
        v81 += ~(v81 >> 1);
        if (v87 < v80) {
          unint64_t v82 = v86;
        }
        else {
          unint64_t v81 = v84;
        }
      }
      while (v81);
      if (v82 != v83 && *v82 == v80) {
        uint64_t v88 = v82[1];
      }
      else {
LABEL_80:
      }
        uint64_t v88 = 0;
      uint64_t v89 = mlir::DenseElementsAttr::getFromRawBuffer(v43, v88, v134, 8 * v135, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v124, v78, v89);
      uint64_t v90 = mlir::ValueRange::dereference_iterator(v140, 0);
      v122[0] = (uint64_t *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
      if (mlir::Type::isF16((mlir::Type *)v122)
        || (uint64_t GOC = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118),
            mlir::Type::isF32((mlir::Type *)&GOC)))
      {
        uint64_t GOC = 1;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
        uint64_t v92 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&GOC, 1, OperandRange, 0);
        uint64_t v93 = (uint64_t)v92;
        if (!v92) {
          goto LABEL_92;
        }
        uint64_t v94 = *v92;
        unint64_t v95 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v96 = *(unsigned int *)(v94 + 16);
        if (!v96) {
          goto LABEL_92;
        }
        __int16 v97 = *(void **)(v94 + 8);
        uint64_t v98 = &v97[2 * v96];
        do
        {
          unint64_t v99 = v96 >> 1;
          uint64_t v100 = &v97[2 * (v96 >> 1)];
          unint64_t v102 = *v100;
          uint64_t v101 = v100 + 2;
          v96 += ~(v96 >> 1);
          if (v102 < v95) {
            __int16 v97 = v101;
          }
          else {
            unint64_t v96 = v99;
          }
        }
        while (v96);
        if (v97 != v98 && *v97 == v95) {
          uint64_t v103 = v97[1];
        }
        else {
LABEL_92:
        }
          uint64_t v103 = 0;
        uint64_t v104 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
        uint64_t v120 = (uint64_t)mlir::FloatAttr::get(v104, -1.0);
        uint64_t v59 = 1;
        v122[0] = (uint64_t *)mlir::DenseElementsAttr::get(v93, v103, &v120, 1uLL);
        uint64_t v105 = *((void *)v119 + 3);
        uint64_t v120 = 1;
        uint64_t v106 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
        uint64_t GOC = mlir::MemRefType::get(&v120, (mlir::AffineMap *)1, v106, 0, 0, 0);
        uint64_t v107 = (char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::MemRefType &,mlir::mps::MPSBufferTensorAttr &>((mlir::OpBuilder *)(a4 + 8), v105, &GOC, v122)- 16;
        uint64_t v108 = *((void *)v119 + 3);
        uint64_t v116 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&GOC);
        uint64_t v120 = (uint64_t)mlir::OpBuilder::create<mlir::anec::MaxPool,mlir::Value &,mlir::NamedAttrList &>((mlir::UnknownLoc **)(a4 + 8), v108, (uint64_t)&v116, (uint64_t)&v124);
        uint64_t v109 = (mlir::MLIRContext *)*((void *)v119 + 3);
        uint64_t v110 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v120);
        mlir::ConversionPatternRewriter::replaceOp(a4, v119, (uint64_t)v122, 1);
      }
      else
      {
        uint64_t v112 = v119;
        v122[0] = v118;
        uint64_t v113 = *(void *)(a4 + 16);
        if (v113)
        {
          if (mlir::RewriterBase::Listener::classof(v113)) {
          else
          }
            uint64_t v59 = 0;
        }
        else
        {
          uint64_t v59 = 0;
        }
      }
      if (v124 != v126) {
        free(v124);
      }
    }
LABEL_96:
    if (v128 != v130) {
      free(v128);
    }
    if (v131 != v133) {
      free(v131);
    }
    if (v134 != v136) {
      free(v134);
    }
    if (v137 != (void **)v139) {
      free(v137);
    }
    return v59;
  }
  char v114 = (mlir::Operation ***)std::__throw_bad_optional_access[abi:nn180100]();
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMinOp,mlir::mps::ReductionMinOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Collapsing dimension for Op");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, "to MaxPool, AveragePool or Conv for A13 and below on ane is not supported \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMinOp,mlir::mps::ReductionMinOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "MaxPool/AveragePool for axes:");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = **a1;
  int v17 = 2;
  uint64_t v18 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  char v8 = &v17;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v14 = v7 + 1;
    BOOL v15 = v5 + 24 * v7 > (unint64_t)&v17;
    if (v5 <= (unint64_t)&v17 && v15)
    {
      unint64_t v16 = (char *)&v17 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v14, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      char v8 = (int *)&v16[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v14, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      char v8 = &v17;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  uint64_t v11 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(v3, "reduced from Op ");
  unint64_t v12 = mlir::Diagnostic::operator<<(v11, (mlir::Operation *)*a1[1]);
  return mlir::Diagnostic::operator<<((uint64_t)v12, "is not supported for A13 and below\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMinOp,mlir::mps::ReductionMinOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Axis value is incorrect for Op");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, "\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMinOp,mlir::mps::ReductionMinOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(mlir::MemoryMapperInterface **a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "ReduceMin for non fp type: ");
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange(*a1);
  unint64_t v5 = v15;
  mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)v15, OperandRange);
  uint64_t v6 = v3 + 16;
  unint64_t v7 = *(void *)(v3 + 16);
  uint64_t v8 = *(unsigned int *)(v3 + 24);
  if (v8 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v8 + 1;
    BOOL v13 = v7 + 24 * v8 > (unint64_t)v15;
    if (v7 <= (unint64_t)v15 && v13)
    {
      unint64_t v14 = &v15[-v7];
      llvm::SmallVectorBase<unsigned int>::grow_pod(v6, (void *)(v3 + 32), v12, 24);
      unint64_t v7 = *(void *)(v3 + 16);
      unint64_t v5 = &v14[v7];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v6, (void *)(v3 + 32), v12, 24);
      unint64_t v7 = *(void *)(v3 + 16);
      unint64_t v5 = v15;
    }
  }
  unint64_t v9 = v7 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v5;
  *(void *)(v9 + 16) = *((void *)v5 + 2);
  *(_OWORD *)unint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " is not supported for A13 and below\n");
}

void *mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)0>::~ConvertReductionA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)0>::~ConvertReductionA14Minus(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v93 = *MEMORY[0x1E4F143B8];
  unint64_t v69 = a2;
  unint64_t v6 = *(void *)(a3 + 56);
  uint64_t v91 = *(void *)(a3 + 48);
  unint64_t v92 = v6;
  if (!v8)
  {
    unint64_t v72 = "failed to convert operand axes";
    v74[8] = 259;
    unint64_t v75 = &v72;
    uint64_t v42 = *(void *)(a4 + 16);
    if (v42)
    {
      if (mlir::RewriterBase::Listener::classof(v42)) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v42 + 64))(v42, *((void *)a2 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionSumOp &>(mlir::mps::ReductionSumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v75);
      }
      return 0;
    }
    return v42;
  }
  unint64_t v9 = (uint64_t *)v7;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v69))
  {
    unint64_t v44 = v69;
    unint64_t v72 = &v69;
    uint64_t v42 = *(void *)(a4 + 16);
    if (v42)
    {
      if (mlir::RewriterBase::Listener::classof(v42)) {
      return 0;
      }
    }
    return v42;
  }
  long long v10 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v69) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_12;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_12;
  }
  unint64_t v14 = *(void **)(v11 + 8);
  BOOL v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    int v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    uint64_t v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      unint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_12:
  }
    uint64_t v20 = 0;
  uint64_t v88 = v90;
  uint64_t v89 = 0x600000000;
  if (!v9) {
    goto LABEL_22;
  }
  uint64_t v21 = *v9;
  unint64_t v22 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_22;
  }
  unsigned __int8 v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    __int16 v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    long long v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      unsigned __int8 v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_22:
  }
    uint64_t v30 = 0;
  mlir::getIntValues<long long>((uint64_t)v9, v30, (uint64_t)&v88, 1);
  unint64_t v85 = v87;
  memset(v87, 0, sizeof(v87));
  uint64_t v86 = 0x600000006;
  unint64_t v82 = v84;
  memset_pattern16(v84, &unk_1810FE350, 0x18uLL);
  uint64_t v83 = 0x600000003;
  uint64_t v79 = v81;
  memset_pattern16(v81, &unk_1810FE350, 0x18uLL);
  uint64_t v80 = 0x600000003;
  v68[0] = mlir::getRankPromotionTypeForANE((uint64_t)v10, v20);
  v68[1] = v31;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v68);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v32);
  if (v34)
  {
    if (v89 == 1 && *v88 == IndexFromDim)
    {
      uint64_t v66 = *((void *)v69 + 3);
      uint64_t v35 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v68)
                      + 8 * IndexFromDim);
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v68);
      unint64_t v75 = v77;
      v77[0] = 1;
      v77[1] = v35;
      int64x2_t v78 = vdupq_n_s64(1uLL);
      uint64_t v76 = 0x1000000004;
      uint64_t v67 = mlir::MemRefType::get(v77, (mlir::AffineMap *)4, OperandRange, 0, 0, 0);
      Value = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v67);
      uint64_t NumElements = (llvm::APFloatBase *)mlir::ShapedType::getNumElements(Value, v38);
      unint64_t v40 = (llvm::APFloatBase *)llvm::APFloatBase::IEEEhalf(NumElements);
      unint64_t v41 = (llvm::APFloatBase *)llvm::APFloatBase::PPCDoubleDouble(v40);
      if (v41 == v40) {
        llvm::detail::DoubleAPFloat::DoubleAPFloat(v71, (uint64_t)v40, 1);
      }
      else {
        llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v71, (uint64_t)v40, (llvm::APInt *)1);
      }
      unint64_t v72 = v74;
      uint64_t v73 = 0x1000000000;
      llvm::SmallVectorImpl<llvm::APFloat>::assign((unsigned int *)&v72, (unint64_t)NumElements, (uint64_t)&ElementsAttr);
      if (v41 == (llvm::APFloatBase *)v71[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v71);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v71);
      }
      unint64_t v47 = v75;
      uint64_t v48 = v76;
      uint64_t F16Type = mlir::Builder::getF16Type((mlir::Float16Type **)(a4 + 8), v46);
      unint64_t v50 = (void *)mlir::RankedTensorType::get((uint64_t)v47, v48, F16Type, 0);
      ElementsAttr = mlir::createElementsAttr(v50, (uint64_t)v72, v73);
      v71[0] = v51;
      mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 8), v66, &v67, (void **)&ElementsAttr);
      unint64_t v52 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v69) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v52) {
        goto LABEL_53;
      }
      uint64_t v53 = *v52;
      unint64_t v54 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v55 = *(unsigned int *)(v53 + 16);
      if (!v55) {
        goto LABEL_53;
      }
      uint64_t v56 = *(void **)(v53 + 8);
      uint64_t v57 = &v56[2 * v55];
      do
      {
        unint64_t v58 = v55 >> 1;
        uint64_t v59 = &v56[2 * (v55 >> 1)];
        unint64_t v61 = *v59;
        uint64_t v60 = v59 + 2;
        v55 += ~(v55 >> 1);
        if (v61 < v54) {
          uint64_t v56 = v60;
        }
        else {
          unint64_t v55 = v58;
        }
      }
      while (v55);
      if (v56 != v57 && *v56 == v54) {
        uint64_t v62 = v56[1];
      }
      else {
LABEL_53:
      }
        uint64_t v62 = 0;
    }
    uint64_t v45 = v69;
    unint64_t v72 = &v69;
    uint64_t v42 = *(void *)(a4 + 16);
    if (v42)
    {
      if (mlir::RewriterBase::Listener::classof(v42)) {
      else
      }
        uint64_t v42 = 0;
    }
    if (v79 != v81) {
      free(v79);
    }
    if (v82 != v84) {
      free(v82);
    }
    if (v85 != v87) {
      free(v85);
    }
    if (v88 != (void *)v90) {
      free(v88);
    }
    return v42;
  }
  uint64_t v64 = (mlir::Operation ***)std::__throw_bad_optional_access[abi:nn180100]();
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionSumOp,mlir::mps::ReductionSumOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Collapsing dimension for Op");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, "to MaxPool, AveragePool or Conv for A13 and below on ane is not supported \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionSumOp,mlir::mps::ReductionSumOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "ReduceSum for axes other than channel axis: ");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " is not supported for A13 and below\n");
}

void *mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)0>::~ConvertReshape(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)0>::~ConvertReshape(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReshapeOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReshapeOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReshapeOpGenericAdaptorBase::ReshapeOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReshapeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReshapeOpGenericAdaptorBase::ReshapeOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ReshapeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 48);
  uint64_t v9 = *(void *)(a3 + 56);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v33 = 259;
      v30[0] = v32;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(mlir::mps::ReshapeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v34[0] = *(_OWORD *)a3;
        v34[1] = v28;
        long long v29 = *(_OWORD *)(a3 + 48);
        void v34[2] = *(_OWORD *)(a3 + 32);
        v34[3] = v29;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  uint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(mlir::mps::ReshapeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v149 = *MEMORY[0x1E4F143B8];
  uint64_t v138 = a2;
  long long v144 = *(_OWORD *)(a3 + 48);
  unint64_t v5 = (void *)(*(void *)(mlir::ValueRange::dereference_iterator(&v144, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v136 = v5;
  uint64_t v137 = v15;
  uint64_t v16 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v138) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  *(void *)&long long v146 = v16;
  *((void *)&v146 + 1) = v26;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v146);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v136);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  *(void *)&long long v135 = mlir::getRankPromotionTypeForANE(v32, v42);
  *((void *)&v135 + 1) = v43;
  v134[0] = mlir::getRankPromotionTypeForANE((uint64_t)v136, v137);
  v134[1] = v44;
  uint64_t v45 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v135);
  uint64_t v47 = v46;
  uint64_t v48 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v134);
  if (v47 == v49 && !memcmp(v45, v48, 8 * v47))
  {
    uint64_t v128 = (unsigned int *)v138;
    *(void *)&long long v146 = mlir::ValueRange::dereference_iterator(&v144, 0);
    uint64_t v79 = 1;
    mlir::ValueRange::ValueRange(v143, (uint64_t)&v146, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v128, v143[0], v143[1]);
    return v79;
  }
  *(void *)&long long v148 = v138;
  long long v146 = v144;
  unint64_t v50 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v146, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v50) {
    goto LABEL_42;
  }
  uint64_t v51 = *v50;
  unint64_t v52 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v53 = *(unsigned int *)(v51 + 16);
  if (!v53) {
    goto LABEL_42;
  }
  unint64_t v54 = *(void **)(v51 + 8);
  unint64_t v55 = &v54[2 * v53];
  do
  {
    unint64_t v56 = v53 >> 1;
    uint64_t v57 = &v54[2 * (v53 >> 1)];
    unint64_t v59 = *v57;
    unint64_t v58 = v57 + 2;
    v53 += ~(v53 >> 1);
    if (v59 < v52) {
      unint64_t v54 = v58;
    }
    else {
      unint64_t v53 = v56;
    }
  }
  while (v53);
  if (v54 != v55 && *v54 == v52) {
    uint64_t v60 = v54[1];
  }
  else {
LABEL_42:
  }
    uint64_t v60 = 0;
  uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v50, v60);
  uint64_t v63 = v62;
  uint64_t v64 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v148) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v64) {
    goto LABEL_52;
  }
  uint64_t v65 = *v64;
  unint64_t v66 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v67 = *(unsigned int *)(v65 + 16);
  if (!v67) {
    goto LABEL_52;
  }
  unint64_t v68 = *(void **)(v65 + 8);
  unint64_t v69 = &v68[2 * v67];
  do
  {
    unint64_t v70 = v67 >> 1;
    uint64_t v71 = &v68[2 * (v67 >> 1)];
    unint64_t v73 = *v71;
    unint64_t v72 = v71 + 2;
    v67 += ~(v67 >> 1);
    if (v73 < v66) {
      unint64_t v68 = v72;
    }
    else {
      unint64_t v67 = v70;
    }
  }
  while (v67);
  if (v68 != v69 && *v68 == v66) {
    uint64_t v74 = v68[1];
  }
  else {
LABEL_52:
  }
    uint64_t v74 = 0;
  uint64_t v75 = mlir::getRankPromotionTypeForANE((uint64_t)v64, v74);
  if (mlir::anec::verifyCompatibilityWithFlatten(RankPromotionTypeForANE, v63, v75, v76))
  {
    uint64_t v77 = *(void *)(v148 + 24);
    uint64_t v142 = mlir::ValueRange::dereference_iterator(&v146, 0);
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(v148 + 24));
    uint64_t v140 = mlir::anec::BoxCoordinateModeAttr::get(Context, 1);
    *(void *)&long long v141 = (char *)mlir::OpBuilder::create<mlir::anec::Flatten,mlir::Value,mlir::anec::FlattenModeAttr>((mlir::UnknownLoc **)(a4 + 8), v77, &v142, &v140)- 16;
    mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)v148, (uint64_t)&v141, 1);
    return 1;
  }
  uint64_t v80 = *(void *)(a4 + 16);
  if (v80)
  {
    uint64_t v81 = v148;
    if (mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16)))
    {
      {
        return 1;
      }
    }
  }
  uint64_t v142 = v138;
  long long v148 = v144;
  long long v141 = v135;
  unint64_t v82 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v148, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v82) {
    goto LABEL_67;
  }
  uint64_t v83 = *v82;
  unint64_t v84 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v85 = *(unsigned int *)(v83 + 16);
  if (!v85) {
    goto LABEL_67;
  }
  uint64_t v86 = *(void **)(v83 + 8);
  unint64_t v87 = &v86[2 * v85];
  do
  {
    unint64_t v88 = v85 >> 1;
    uint64_t v89 = &v86[2 * (v85 >> 1)];
    unint64_t v91 = *v89;
    uint64_t v90 = v89 + 2;
    v85 += ~(v85 >> 1);
    if (v91 < v84) {
      uint64_t v86 = v90;
    }
    else {
      unint64_t v85 = v88;
    }
  }
  while (v85);
  if (v86 != v87 && *v86 == v84) {
    uint64_t v92 = v86[1];
  }
  else {
LABEL_67:
  }
    uint64_t v92 = 0;
  uint64_t v93 = mlir::getRankPromotionTypeForANE((uint64_t)v82, v92);
  uint64_t v95 = v94;
  unint64_t v96 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v142) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v96) {
    goto LABEL_77;
  }
  uint64_t v97 = *v96;
  unint64_t v98 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v99 = *(unsigned int *)(v97 + 16);
  if (!v99) {
    goto LABEL_77;
  }
  uint64_t v100 = *(void **)(v97 + 8);
  uint64_t v101 = &v100[2 * v99];
  do
  {
    unint64_t v102 = v99 >> 1;
    uint64_t v103 = &v100[2 * (v99 >> 1)];
    unint64_t v105 = *v103;
    uint64_t v104 = v103 + 2;
    v99 += ~(v99 >> 1);
    if (v105 < v98) {
      uint64_t v100 = v104;
    }
    else {
      unint64_t v99 = v102;
    }
  }
  while (v99);
  if (v100 != v101 && *v100 == v98) {
    uint64_t v106 = v100[1];
  }
  else {
LABEL_77:
  }
    uint64_t v106 = 0;
  uint64_t v107 = mlir::getRankPromotionTypeForANE((uint64_t)v96, v106);
  if (mlir::anec::verifyCompatibilityWithUnflatten(v93, v95, v107, v108))
  {
    uint64_t v109 = mlir::Attribute::getContext((mlir::Attribute *)(v142 + 24));
    uint64_t v140 = mlir::anec::BoxCoordinateModeAttr::get(v109, 1);
    uint64_t v110 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v141);
    uint64_t v112 = v110 + 8 * v111;
    *(void *)&long long v146 = v147;
    v147[0] = *(void *)(v112 - 24);
    v147[1] = *(void *)(v112 - 16);
    v147[2] = *(void *)(v112 - 8);
    *((void *)&v146 + 1) = 0x300000003;
    uint64_t v145 = 3;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    char v114 = (void *)mlir::RankedTensorType::get((uint64_t)&v145, 1, IntegerType, 0);
    uint64_t v115 = v114;
    if (!v114) {
      goto LABEL_88;
    }
    uint64_t v116 = *v114;
    unint64_t v117 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v118 = *(unsigned int *)(v116 + 16);
    if (!v118) {
      goto LABEL_88;
    }
    uint64_t v119 = *(void **)(v116 + 8);
    uint64_t v120 = &v119[2 * v118];
    do
    {
      unint64_t v121 = v118 >> 1;
      uint64_t v122 = &v119[2 * (v118 >> 1)];
      unint64_t v124 = *v122;
      __int16 v123 = v122 + 2;
      v118 += ~(v118 >> 1);
      if (v124 < v117) {
        uint64_t v119 = v123;
      }
      else {
        unint64_t v118 = v121;
      }
    }
    while (v118);
    if (v119 != v120 && *v119 == v117) {
      uint64_t v125 = v119[1];
    }
    else {
LABEL_88:
    }
      uint64_t v125 = 0;
    uint64_t v145 = mlir::DenseElementsAttr::getFromRawBuffer(v115, v125, v146, 8 * DWORD2(v146), 8, 1, 0);
    uint64_t v126 = v142;
    uint64_t v139 = mlir::ValueRange::dereference_iterator(&v148, 0);
    uint64_t v127 = mlir::OpBuilder::create<mlir::anec::Unflatten,mlir::Value,mlir::anec::FlattenModeAttr &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), *(void *)(v126 + 24), &v139, &v140, &v145);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v126, v127);
    if ((void *)v146 != v147) {
      free((void *)v146);
    }
    return 1;
  }
  uint64_t v129 = *(void *)(a4 + 16);
  if (v129)
  {
    uint64_t v130 = v142;
    if (mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16)))
    {
      {
        return 1;
      }
    }
  }
  uint64_t v131 = *(void *)(a4 + 16);
  if (v131 && (uint64_t v132 = v138, mlir::RewriterBase::Listener::classof(v131))) {
  else
  }
    return 0;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Flatten,mlir::Value,mlir::anec::FlattenModeAttr>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.flatten", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.flatten";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Flatten::build(a1, (uint64_t)v19, *a3, *a4);
  unint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Flatten,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)0>::tryConvertToFlatten(mlir::mps::ReshapeOp,mlir::ValueRange,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: Reshape target shape must be NxCx1x1 to be lowered as Flatten on ANEs.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)0>::tryConvertToUnflatten(mlir::mps::ReshapeOp,mlir::ValueRange,mlir::ShapedType,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: Reshape input shape must be NxCx1x1 to be lowered as Unflatten on ANEs.");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Unflatten,mlir::Value,mlir::anec::FlattenModeAttr &,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.unflatten", (const unsigned __int8 *)0xE, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"anec.unflatten";
    v19[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::anec::Unflatten::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Unflatten,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReshapeOp,mlir::mps::ReshapeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: op couldn't be folded or converted to flatten on A11/A12.");
}

void *mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)1>::~ConvertReshape(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)1>::~ConvertReshape(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v149 = *MEMORY[0x1E4F143B8];
  uint64_t v138 = a2;
  long long v144 = *(_OWORD *)(a3 + 48);
  unint64_t v5 = (void *)(*(void *)(mlir::ValueRange::dereference_iterator(&v144, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  char v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    char v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v136 = v5;
  uint64_t v137 = v15;
  uint64_t v16 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v138) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  __int16 v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      __int16 v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  *(void *)&long long v146 = v16;
  *((void *)&v146 + 1) = v26;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v146);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v136);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  *(void *)&long long v135 = mlir::getRankPromotionTypeForANE(v32, v42);
  *((void *)&v135 + 1) = v43;
  v134[0] = mlir::getRankPromotionTypeForANE((uint64_t)v136, v137);
  v134[1] = v44;
  uint64_t v45 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v135);
  uint64_t v47 = v46;
  uint64_t v48 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v134);
  if (v47 == v49 && !memcmp(v45, v48, 8 * v47))
  {
    uint64_t v128 = (unsigned int *)v138;
    *(void *)&long long v146 = mlir::ValueRange::dereference_iterator(&v144, 0);
    uint64_t v79 = 1;
    mlir::ValueRange::ValueRange(v143, (uint64_t)&v146, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v128, v143[0], v143[1]);
    return v79;
  }
  *(void *)&long long v148 = v138;
  long long v146 = v144;
  unint64_t v50 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v146, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v50) {
    goto LABEL_42;
  }
  uint64_t v51 = *v50;
  unint64_t v52 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v53 = *(unsigned int *)(v51 + 16);
  if (!v53) {
    goto LABEL_42;
  }
  unint64_t v54 = *(void **)(v51 + 8);
  unint64_t v55 = &v54[2 * v53];
  do
  {
    unint64_t v56 = v53 >> 1;
    uint64_t v57 = &v54[2 * (v53 >> 1)];
    unint64_t v59 = *v57;
    unint64_t v58 = v57 + 2;
    v53 += ~(v53 >> 1);
    if (v59 < v52) {
      unint64_t v54 = v58;
    }
    else {
      unint64_t v53 = v56;
    }
  }
  while (v53);
  if (v54 != v55 && *v54 == v52) {
    uint64_t v60 = v54[1];
  }
  else {
LABEL_42:
  }
    uint64_t v60 = 0;
  uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v50, v60);
  uint64_t v63 = v62;
  uint64_t v64 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v148) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v64) {
    goto LABEL_52;
  }
  uint64_t v65 = *v64;
  unint64_t v66 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v67 = *(unsigned int *)(v65 + 16);
  if (!v67) {
    goto LABEL_52;
  }
  unint64_t v68 = *(void **)(v65 + 8);
  unint64_t v69 = &v68[2 * v67];
  do
  {
    unint64_t v70 = v67 >> 1;
    uint64_t v71 = &v68[2 * (v67 >> 1)];
    unint64_t v73 = *v71;
    unint64_t v72 = v71 + 2;
    v67 += ~(v67 >> 1);
    if (v73 < v66) {
      unint64_t v68 = v72;
    }
    else {
      unint64_t v67 = v70;
    }
  }
  while (v67);
  if (v68 != v69 && *v68 == v66) {
    uint64_t v74 = v68[1];
  }
  else {
LABEL_52:
  }
    uint64_t v74 = 0;
  uint64_t v75 = mlir::getRankPromotionTypeForANE((uint64_t)v64, v74);
  if (mlir::anec::verifyCompatibilityWithFlatten(RankPromotionTypeForANE, v63, v75, v76))
  {
    uint64_t v77 = *(void *)(v148 + 24);
    uint64_t v142 = mlir::ValueRange::dereference_iterator(&v146, 0);
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(v148 + 24));
    uint64_t v140 = mlir::anec::BoxCoordinateModeAttr::get(Context, 1);
    *(void *)&long long v141 = (char *)mlir::OpBuilder::create<mlir::anec::Flatten,mlir::Value,mlir::anec::FlattenModeAttr>((mlir::UnknownLoc **)(a4 + 8), v77, &v142, &v140)- 16;
    mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)v148, (uint64_t)&v141, 1);
    return 1;
  }
  uint64_t v80 = *(void *)(a4 + 16);
  if (v80)
  {
    uint64_t v81 = v148;
    if (mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16)))
    {
      {
        return 1;
      }
    }
  }
  uint64_t v142 = v138;
  long long v148 = v144;
  long long v141 = v135;
  unint64_t v82 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v148, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v82) {
    goto LABEL_67;
  }
  uint64_t v83 = *v82;
  unint64_t v84 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v85 = *(unsigned int *)(v83 + 16);
  if (!v85) {
    goto LABEL_67;
  }
  uint64_t v86 = *(void **)(v83 + 8);
  unint64_t v87 = &v86[2 * v85];
  do
  {
    unint64_t v88 = v85 >> 1;
    uint64_t v89 = &v86[2 * (v85 >> 1)];
    unint64_t v91 = *v89;
    uint64_t v90 = v89 + 2;
    v85 += ~(v85 >> 1);
    if (v91 < v84) {
      uint64_t v86 = v90;
    }
    else {
      unint64_t v85 = v88;
    }
  }
  while (v85);
  if (v86 != v87 && *v86 == v84) {
    uint64_t v92 = v86[1];
  }
  else {
LABEL_67:
  }
    uint64_t v92 = 0;
  uint64_t v93 = mlir::getRankPromotionTypeForANE((uint64_t)v82, v92);
  uint64_t v95 = v94;
  unint64_t v96 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v142) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v96) {
    goto LABEL_77;
  }
  uint64_t v97 = *v96;
  unint64_t v98 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v99 = *(unsigned int *)(v97 + 16);
  if (!v99) {
    goto LABEL_77;
  }
  uint64_t v100 = *(void **)(v97 + 8);
  uint64_t v101 = &v100[2 * v99];
  do
  {
    unint64_t v102 = v99 >> 1;
    uint64_t v103 = &v100[2 * (v99 >> 1)];
    unint64_t v105 = *v103;
    uint64_t v104 = v103 + 2;
    v99 += ~(v99 >> 1);
    if (v105 < v98) {
      uint64_t v100 = v104;
    }
    else {
      unint64_t v99 = v102;
    }
  }
  while (v99);
  if (v100 != v101 && *v100 == v98) {
    uint64_t v106 = v100[1];
  }
  else {
LABEL_77:
  }
    uint64_t v106 = 0;
  uint64_t v107 = mlir::getRankPromotionTypeForANE((uint64_t)v96, v106);
  if (mlir::anec::verifyCompatibilityWithUnflatten(v93, v95, v107, v108))
  {
    uint64_t v109 = mlir::Attribute::getContext((mlir::Attribute *)(v142 + 24));
    uint64_t v140 = mlir::anec::BoxCoordinateModeAttr::get(v109, 1);
    uint64_t v110 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v141);
    uint64_t v112 = v110 + 8 * v111;
    *(void *)&long long v146 = v147;
    v147[0] = *(void *)(v112 - 24);
    v147[1] = *(void *)(v112 - 16);
    v147[2] = *(void *)(v112 - 8);
    *((void *)&v146 + 1) = 0x300000003;
    uint64_t v145 = 3;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    char v114 = (void *)mlir::RankedTensorType::get((uint64_t)&v145, 1, IntegerType, 0);
    uint64_t v115 = v114;
    if (!v114) {
      goto LABEL_88;
    }
    uint64_t v116 = *v114;
    unint64_t v117 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v118 = *(unsigned int *)(v116 + 16);
    if (!v118) {
      goto LABEL_88;
    }
    uint64_t v119 = *(void **)(v116 + 8);
    uint64_t v120 = &v119[2 * v118];
    do
    {
      unint64_t v121 = v118 >> 1;
      uint64_t v122 = &v119[2 * (v118 >> 1)];
      unint64_t v124 = *v122;
      __int16 v123 = v122 + 2;
      v118 += ~(v118 >> 1);
      if (v124 < v117) {
        uint64_t v119 = v123;
      }
      else {
        unint64_t v118 = v121;
      }
    }
    while (v118);
    if (v119 != v120 && *v119 == v117) {
      uint64_t v125 = v119[1];
    }
    else {
LABEL_88:
    }
      uint64_t v125 = 0;
    uint64_t v145 = mlir::DenseElementsAttr::getFromRawBuffer(v115, v125, v146, 8 * DWORD2(v146), 8, 1, 0);
    uint64_t v126 = v142;
    uint64_t v139 = mlir::ValueRange::dereference_iterator(&v148, 0);
    uint64_t v127 = mlir::OpBuilder::create<mlir::anec::Unflatten,mlir::Value,mlir::anec::FlattenModeAttr &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), *(void *)(v126 + 24), &v139, &v140, &v145);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v126, v127);
    if ((void *)v146 != v147) {
      free((void *)v146);
    }
    return 1;
  }
  uint64_t v129 = *(void *)(a4 + 16);
  if (v129)
  {
    uint64_t v130 = v142;
    if (mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16)))
    {
      {
        return 1;
      }
    }
  }
  uint64_t v131 = *(void *)(a4 + 16);
  if (v131 && (uint64_t v132 = v138, mlir::RewriterBase::Listener::classof(v131))) {
  else
  }
    return 0;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)1>::tryConvertToFlatten(mlir::mps::ReshapeOp,mlir::ValueRange,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: Reshape target shape must be NxCx1x1 to be lowered as Flatten on ANEs.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)1>::tryConvertToUnflatten(mlir::mps::ReshapeOp,mlir::ValueRange,mlir::ShapedType,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: Reshape input shape must be NxCx1x1 to be lowered as Unflatten on ANEs.");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReshapeOp,mlir::mps::ReshapeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: op couldn't be folded or converted to flatten on A11/A12.");
}

void *mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)2>::~ConvertReshape(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)2>::~ConvertReshape(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 48);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  char v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    char v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  __int16 v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      __int16 v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)3>::~ConvertReshape(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)3>::~ConvertReshape(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 48);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  char v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    char v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  __int16 v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      __int16 v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)4>::~ConvertReshape(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)4>::~ConvertReshape(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 48);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  char v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    char v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  __int16 v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      __int16 v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)5>::~ConvertReshape(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)5>::~ConvertReshape(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 48);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  char v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    char v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  __int16 v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      __int16 v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)6>::~ConvertReshape(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)6>::~ConvertReshape(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 48);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  char v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    char v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  __int16 v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      __int16 v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)0>::~ConvertExpandDims(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)0>::~ConvertExpandDims(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExpandDimsOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExpandDimsOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ExpandDimsOpGenericAdaptorBase::ExpandDimsOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExpandDimsOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ExpandDimsOpGenericAdaptorBase::ExpandDimsOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ExpandDimsOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  unint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        unint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExpandDimsOp &>(mlir::mps::ExpandDimsOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExpandDimsOp &>(mlir::mps::ExpandDimsOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  uint64_t v60 = a2;
  long long v63 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (void *)(*(void *)(mlir::ValueRange::dereference_iterator(&v63, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v58 = v5;
  uint64_t v59 = v15;
  uint64_t v16 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v60) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = (uint64_t)v16;
  uint64_t v57 = v26;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v58);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v57 = v43;
  v55[0] = mlir::getRankPromotionTypeForANE((uint64_t)v58, v59);
  v55[1] = v44;
  uint64_t v45 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  uint64_t v47 = v46;
  uint64_t v48 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55);
  if (v47 == v49 && !memcmp(v45, v48, 8 * v47))
  {
    uint64_t v53 = v60;
    uint64_t v61 = mlir::ValueRange::dereference_iterator(&v63, 0);
    uint64_t v52 = 1;
    mlir::ValueRange::ValueRange(v62, (uint64_t)&v61, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v53, v62[0], v62[1]);
  }
  else
  {
    uint64_t v50 = *(void *)(a4 + 16);
    if (v50 && (uint64_t v51 = v60, mlir::RewriterBase::Listener::classof(v50))) {
    else
    }
      return 0;
  }
  return v52;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExpandDimsOp &>(mlir::mps::ExpandDimsOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ExpandDimsOp,mlir::mps::ExpandDimsOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: op couldn't be folded or converted to flatten on A11/A12.");
}

void *mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)1>::~ConvertExpandDims(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)1>::~ConvertExpandDims(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  uint64_t v60 = a2;
  long long v63 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (void *)(*(void *)(mlir::ValueRange::dereference_iterator(&v63, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v58 = v5;
  uint64_t v59 = v15;
  uint64_t v16 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v60) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = (uint64_t)v16;
  uint64_t v57 = v26;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v58);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v57 = v43;
  v55[0] = mlir::getRankPromotionTypeForANE((uint64_t)v58, v59);
  v55[1] = v44;
  uint64_t v45 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  uint64_t v47 = v46;
  uint64_t v48 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55);
  if (v47 == v49 && !memcmp(v45, v48, 8 * v47))
  {
    uint64_t v53 = v60;
    uint64_t v61 = mlir::ValueRange::dereference_iterator(&v63, 0);
    uint64_t v52 = 1;
    mlir::ValueRange::ValueRange(v62, (uint64_t)&v61, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v53, v62[0], v62[1]);
  }
  else
  {
    uint64_t v50 = *(void *)(a4 + 16);
    if (v50 && (uint64_t v51 = v60, mlir::RewriterBase::Listener::classof(v50))) {
    else
    }
      return 0;
  }
  return v52;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ExpandDimsOp,mlir::mps::ExpandDimsOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: op couldn't be folded or converted to flatten on A11/A12.");
}

void *mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)2>::~ConvertExpandDims(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)2>::~ConvertExpandDims(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)3>::~ConvertExpandDims(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)3>::~ConvertExpandDims(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)4>::~ConvertExpandDims(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)4>::~ConvertExpandDims(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)5>::~ConvertExpandDims(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)5>::~ConvertExpandDims(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)6>::~ConvertExpandDims(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)6>::~ConvertExpandDims(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)0>::~ConvertSqueeze(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)0>::~ConvertSqueeze(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SqueezeOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SqueezeOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SqueezeOpGenericAdaptorBase::SqueezeOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SqueezeOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SqueezeOpGenericAdaptorBase::SqueezeOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SqueezeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  unint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        unint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SqueezeOp &>(mlir::mps::SqueezeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SqueezeOp &>(mlir::mps::SqueezeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  uint64_t v60 = a2;
  long long v63 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (void *)(*(void *)(mlir::ValueRange::dereference_iterator(&v63, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v58 = v5;
  uint64_t v59 = v15;
  uint64_t v16 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v60) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = (uint64_t)v16;
  uint64_t v57 = v26;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v58);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v57 = v43;
  v55[0] = mlir::getRankPromotionTypeForANE((uint64_t)v58, v59);
  v55[1] = v44;
  uint64_t v45 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  uint64_t v47 = v46;
  uint64_t v48 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55);
  if (v47 == v49 && !memcmp(v45, v48, 8 * v47))
  {
    uint64_t v53 = v60;
    uint64_t v61 = mlir::ValueRange::dereference_iterator(&v63, 0);
    uint64_t v52 = 1;
    mlir::ValueRange::ValueRange(v62, (uint64_t)&v61, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v53, v62[0], v62[1]);
  }
  else
  {
    uint64_t v50 = *(void *)(a4 + 16);
    if (v50 && (uint64_t v51 = v60, mlir::RewriterBase::Listener::classof(v50))) {
    else
    }
      return 0;
  }
  return v52;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SqueezeOp &>(mlir::mps::SqueezeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::SqueezeOp,mlir::mps::SqueezeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: op couldn't be folded or converted to flatten on A11/A12.");
}

void *mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)1>::~ConvertSqueeze(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)1>::~ConvertSqueeze(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  uint64_t v60 = a2;
  long long v63 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (void *)(*(void *)(mlir::ValueRange::dereference_iterator(&v63, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v58 = v5;
  uint64_t v59 = v15;
  uint64_t v16 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v60) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = (uint64_t)v16;
  uint64_t v57 = v26;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v58);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v57 = v43;
  v55[0] = mlir::getRankPromotionTypeForANE((uint64_t)v58, v59);
  v55[1] = v44;
  uint64_t v45 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  uint64_t v47 = v46;
  uint64_t v48 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55);
  if (v47 == v49 && !memcmp(v45, v48, 8 * v47))
  {
    uint64_t v53 = v60;
    uint64_t v61 = mlir::ValueRange::dereference_iterator(&v63, 0);
    uint64_t v52 = 1;
    mlir::ValueRange::ValueRange(v62, (uint64_t)&v61, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v53, v62[0], v62[1]);
  }
  else
  {
    uint64_t v50 = *(void *)(a4 + 16);
    if (v50 && (uint64_t v51 = v60, mlir::RewriterBase::Listener::classof(v50))) {
    else
    }
      return 0;
  }
  return v52;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::SqueezeOp,mlir::mps::SqueezeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: op couldn't be folded or converted to flatten on A11/A12.");
}

void *mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)2>::~ConvertSqueeze(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)2>::~ConvertSqueeze(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)3>::~ConvertSqueeze(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)3>::~ConvertSqueeze(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)4>::~ConvertSqueeze(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)4>::~ConvertSqueeze(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)5>::~ConvertSqueeze(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)5>::~ConvertSqueeze(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)6>::~ConvertSqueeze(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)6>::~ConvertSqueeze(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void mlir::anonymous namespace'::ConvertCast::~ConvertCast(mlir::_anonymous_namespace_::ConvertCast *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::CastOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::CastOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::CastOpGenericAdaptorBase::CastOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::CastOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::CastOpGenericAdaptorBase::CastOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::CastOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 48);
  uint64_t v9 = *(void *)(a3 + 56);
  unint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        unint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v33 = 259;
      v30[0] = v32;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CastOp &>(mlir::mps::CastOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v34[0] = *(_OWORD *)a3;
        v34[1] = v28;
        long long v29 = *(_OWORD *)(a3 + 48);
        void v34[2] = *(_OWORD *)(a3 + 32);
        v34[3] = v29;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  uint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CastOp &>(mlir::mps::CastOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertCast::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, mlir::scf::detail::IfOpGenericAdaptorBase *this, uint64_t *a4)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  uint64_t v35 = a2;
  unsigned int ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 0);
  unint64_t v9 = *((void *)this + 6);
  *(void *)&long long v36 = v9;
  *((void *)&v36 + 1) = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    unint64_t v9 = mlir::ValueRange::offset_base(&v36, ODSOperandIndexAndLength);
  }
  long long v36 = v9;
  uint64_t v10 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v36, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_12;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_12;
  }
  unint64_t v14 = *(void **)(v11 + 8);
  uint64_t v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    uint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    unint64_t v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      unint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_12:
  }
    uint64_t v20 = 0;
  v34[0] = (uint64_t)v10;
  v34[1] = v20;
  *(void *)&long long v36 = mlir::mps::detail::CastOpGenericAdaptorBase::getResultElementType(this);
  if (mlir::Type::isInteger((mlir::Type *)&v36, 1))
  {
    mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)&v36, *(const mlir::TypeConverter **)(a1 + 96));
    uint64_t v21 = *(void *)(a2 + 24);
    unsigned int v22 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 0);
    unint64_t v23 = *((void *)this + 6);
    unint64_t v38 = v23;
    uint64_t v39 = v22;
    if (v22) {
      unint64_t v23 = mlir::ValueRange::offset_base(&v38, v22);
    }
    unint64_t v38 = v23;
    uint64_t v39 = 0;
    uint64_t v33 = mlir::ValueRange::dereference_iterator(&v38, 0);
    unint64_t v38 = (unint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseNotEqualZero,mlir::Value>(a4 + 1, v21, &v33);
    uint64_t v24 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v35);
    uint64_t v33 = mlir::TypeConverter::convertType((uint64_t)&v36, (void *)(*(void *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v25 = v35;
    uint64_t v26 = mlir::OpBuilder::create<mlir::anec::Cast,mlir::Type &,mlir::anec::ElementwiseNotEqualZero &>((mlir::OpBuilder *)(a4 + 1), *(void *)(v35 + 24), &v33, &v38);
    (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, v25, v26);
    mlir::TypeConverter::~TypeConverter((pthread_rwlock_t **)&v36);
  }
  Resultuint64_t ElementType = mlir::mps::detail::CastOpGenericAdaptorBase::getResultElementType(this);
  LOBYTE(v36) = 0;
  char v37 = 0;
  unint64_t v38 = mlir::ShapedType::cloneWith(v34, &v36, ResultElementType);
  uint64_t v39 = v28;
  unsigned int v29 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 0);
  unint64_t v30 = *((void *)this + 6);
  *(void *)&long long v36 = v30;
  *((void *)&v36 + 1) = v29;
  if (v29) {
    unint64_t v30 = mlir::ValueRange::offset_base(&v36, v29);
  }
  long long v36 = v30;
  *(void *)&long long v36 = mlir::ValueRange::dereference_iterator(&v36, 0);
  uint64_t v31 = mlir::OpBuilder::create<mlir::anec::Cast,mlir::ShapedType &,mlir::Value>((mlir::OpBuilder *)(a4 + 1), *(void *)(a2 + 24), (uint64_t *)&v38, (uint64_t *)&v36);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v31);
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Cast,mlir::Type &,mlir::anec::ElementwiseNotEqualZero &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, void *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.cast", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.cast";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Broadcast::build((uint64_t)a1, (uint64_t)v19, *a3, *a4 - 16);
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Cast,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Cast,mlir::ShapedType &,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.cast", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.cast";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Broadcast::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Cast,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::anonymous namespace'::ConvertSoftmax::~ConvertSoftmax(mlir::_anonymous_namespace_::ConvertSoftmax *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SoftmaxOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SoftmaxOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SoftmaxOpGenericAdaptorBase::SoftmaxOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SoftmaxOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SoftmaxOpGenericAdaptorBase::SoftmaxOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SoftmaxOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SoftmaxOp &>(mlir::mps::SoftmaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  unint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SoftmaxOp &>(mlir::mps::SoftmaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertSoftmax::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v29 = a2;
  long long v30 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v29) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v28[0] = v5;
  v28[1] = v15;
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v28) & 1) == 0)
  {
    uint64_t v22 = *(void *)(a4 + 16);
    if (v22)
    {
      uint64_t v23 = v29;
      if (mlir::RewriterBase::Listener::classof(v22)) {
    }
      }
    return 0;
  }
  uint64_t v16 = 1;
  uint64_t v17 = (void *)mlir::ValueRange::dereference_iterator(&v30, 1);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v28);
  v27[0] = mlir::getSortedUniquePromotedPositiveAxesAttr(v17, v18, 0, 0);
  v27[1] = v19;
  if (!(_BYTE)v19) {
    return 0;
  }
  unsigned __int8 v26 = 1;
  uint64_t v20 = v29;
  uint64_t v25 = mlir::ValueRange::dereference_iterator(&v30, 0);
  uint64_t v21 = mlir::OpBuilder::create<mlir::anec::Softmax,mlir::Value,mlir::DenseIntElementsAttr &,BOOL &>((mlir::UnitAttr **)(a4 + 8), *(void *)(v20 + 24), &v25, v27, &v26);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v20, v21);
  return v16;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SoftmaxOp &>(mlir::mps::SoftmaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertSoftmax::matchAndRewriteWithStaticShapes(mlir::mps::SoftmaxOp,mlir::mps::SoftmaxOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Softmax,mlir::Value,mlir::DenseIntElementsAttr &,BOOL &>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned __int8 *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.softmax", (const unsigned __int8 *)0xC, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"anec.softmax";
    v19[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::anec::Softmax::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Softmax,void>::id) {
    unint64_t v14 = v13;
  }
  else {
    unint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void mlir::anonymous namespace'::ConvertConcat::~ConvertConcat(mlir::_anonymous_namespace_::ConvertConcat *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ConcatOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ConcatOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ConcatOpGenericAdaptorBase::ConcatOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ConcatOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ConcatOpGenericAdaptorBase::ConcatOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ConcatOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 48);
  uint64_t v9 = *(void *)(a3 + 56);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v33 = 259;
      v30[0] = v32;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ConcatOp &>(mlir::mps::ConcatOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v34[0] = *(_OWORD *)a3;
        v34[1] = v28;
        long long v29 = *(_OWORD *)(a3 + 48);
        uint64_t v34[2] = *(_OWORD *)(a3 + 32);
        v34[3] = v29;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  uint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ConcatOp &>(mlir::mps::ConcatOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertConcat::matchAndRewriteWithStaticShapes(uint64_t a1, unsigned int *a2, uint64_t a3, void *a4)
{
  v40[2] = *MEMORY[0x1E4F143B8];
  unint64_t v38 = a2;
  uint64_t v5 = *(void *)(a3 + 48);
  uint64_t v6 = *(void *)(a3 + 56);
  v40[0] = v5;
  v40[1] = v6;
  if (v6 == 2)
  {
    v39[0] = mlir::ValueRange::dereference_iterator(v40, 0);
    uint64_t v8 = 1;
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, a2, (uint64_t)v39, 1);
    return v8;
  }
  uint64_t v9 = (uint64_t *)(*(void *)(*(void *)(mlir::mps::ConcatOp::getValues((mlir::mps::ConcatOp *)&v38) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v9) {
    goto LABEL_12;
  }
  uint64_t v10 = *v9;
  unint64_t v11 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v12 = *(unsigned int *)(v10 + 16);
  if (!v12) {
    goto LABEL_12;
  }
  uint64_t v13 = *(void **)(v10 + 8);
  unint64_t v14 = &v13[2 * v12];
  do
  {
    unint64_t v15 = v12 >> 1;
    uint64_t v16 = &v13[2 * (v12 >> 1)];
    unint64_t v18 = *v16;
    uint64_t v17 = v16 + 2;
    v12 += ~(v12 >> 1);
    if (v18 < v11) {
      uint64_t v13 = v17;
    }
    else {
      unint64_t v12 = v15;
    }
  }
  while (v12);
  if (v13 != v14 && *v13 == v11) {
    uint64_t v19 = v13[1];
  }
  else {
LABEL_12:
  }
    uint64_t v19 = 0;
  v37[0] = v9;
  v37[1] = v19;
  uint64_t Axis = (void *)mlir::mps::ConcatOp::getAxis((mlir::mps::ConcatOp *)&v38);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v37);
  v36[0] = mlir::getSortedUniquePromotedPositiveAxesAttr(Axis, v21, 0, 0);
  v36[1] = v22;
  if (!(_BYTE)v22)
  {
    uint64_t v24 = a4[2];
    if (v24)
    {
      uint64_t v25 = v38;
      if (mlir::RewriterBase::Listener::classof(v24))
      {
        uint64_t v26 = *((void *)v25 + 3);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(void *)v24 + 64))(v24, v26, v27, v39);
      }
    }
    return 0;
  }
  if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v36) != 1)
  {
    uint64_t v24 = a4[2];
    if (v24)
    {
      long long v28 = v38;
      if (mlir::RewriterBase::Listener::classof(v24))
      {
        uint64_t v26 = *((void *)v28 + 3);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(void *)v24 + 64))(v24, v26, v27, v39);
      }
    }
    return 0;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v39, v36[0], 0);
  mlir::DenseElementsAttr::IntElementIterator::operator*(v39, (llvm::APInt *)&__p);
  if (v35 > 0x40) {
    uint64_t v23 = *(void *)__p;
  }
  else {
    uint64_t v23 = (uint64_t)((void)__p << -(uint64_t)v35) >> -(uint64_t)v35;
  }
  uint64_t v33 = v23;
  BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v38);
  long long v29 = v38;
  v39[0] = v5;
  v39[1] = v6 - 1;
  long long v30 = mlir::OpBuilder::create<mlir::anec::Concat,mlir::ValueRange,unsigned long long &,BOOL>((mlir::Builder *)(a4 + 1), *((void *)v38 + 3), v39, &v33, (unsigned __int8 *)&InferredResultTypes);
  (*(void (**)(void *, unsigned int *, mlir::GenericProgramPoint *))(*a4 + 32))(a4, v29, v30);
  if (v35 >= 0x41 && __p) {
    operator delete[](__p);
  }
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ConcatOp &>(mlir::mps::ConcatOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertConcat::matchAndRewriteWithStaticShapes(mlir::mps::ConcatOp,mlir::mps::ConcatOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "ANE Concat supports only supports const positive axis \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertConcat::matchAndRewriteWithStaticShapes(mlir::mps::ConcatOp,mlir::mps::ConcatOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Concat supports only 1 axis \n");
}

void mlir::anonymous namespace'::ConvertSplit::~ConvertSplit(mlir::_anonymous_namespace_::ConvertSplit *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SplitOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SplitOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SplitOpGenericAdaptorBase::SplitOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SplitOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SplitOpGenericAdaptorBase::SplitOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SplitOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 48);
  uint64_t v9 = *(void *)(a3 + 56);
  unsigned int v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        unsigned int v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v33 = 259;
      v30[0] = v32;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SplitOp &>(mlir::mps::SplitOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v34[0] = *(_OWORD *)a3;
        v34[1] = v28;
        long long v29 = *(_OWORD *)(a3 + 48);
        uint64_t v34[2] = *(_OWORD *)(a3 + 32);
        v34[3] = v29;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  uint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SplitOp &>(mlir::mps::SplitOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertSplit::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v93 = *MEMORY[0x1E4F143B8];
  uint64_t v84 = a2;
  long long v92 = *(_OWORD *)(a3 + 48);
  uint64_t v5 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v84) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v83[0] = v5;
  v83[1] = v15;
  Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v84);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v83);
  v82[0] = mlir::getSortedUniquePromotedPositiveAxesAttr(Filter, v17, 0, 0);
  v82[1] = v18;
  if (!(_BYTE)v18)
  {
    uint64_t v21 = *(void *)(a4 + 16);
    if (!v21) {
      return v21;
    }
    uint64_t v22 = v84;
    if (mlir::RewriterBase::Listener::classof(v21))
    {
      uint64_t v23 = *(void *)(v22 + 24);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), int64x2_t **))(*(void *)v21 + 64))(v21, v23, v24, &v89);
    }
    return 0;
  }
  if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v82) != 1)
  {
    uint64_t v21 = *(void *)(a4 + 16);
    if (!v21) {
      return v21;
    }
    uint64_t v25 = v84;
    if (mlir::RewriterBase::Listener::classof(v21))
    {
      uint64_t v23 = *(void *)(v25 + 24);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), int64x2_t **))(*(void *)v21 + 64))(v21, v23, v24, &v89);
    }
    return 0;
  }
  uint64_t v19 = mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v89, v82[0], 0);
  mlir::DenseElementsAttr::IntElementIterator::operator*(v19, (llvm::APInt *)&__p);
  if (v81 > 0x40) {
    uint64_t v20 = *(void *)__p;
  }
  else {
    uint64_t v20 = (uint64_t)((void)__p << -(uint64_t)v81) >> -(uint64_t)v81;
  }
  uint64_t v79 = v20;
  uint64_t v26 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v92, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v26) {
    goto LABEL_33;
  }
  uint64_t v27 = *v26;
  unint64_t v28 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v29 = *(unsigned int *)(v27 + 16);
  if (!v29) {
    goto LABEL_33;
  }
  long long v30 = *(void **)(v27 + 8);
  uint64_t v31 = &v30[2 * v29];
  do
  {
    unint64_t v32 = v29 >> 1;
    __int16 v33 = &v30[2 * (v29 >> 1)];
    unint64_t v35 = *v33;
    uint64_t v34 = v33 + 2;
    v29 += ~(v29 >> 1);
    if (v35 < v28) {
      long long v30 = v34;
    }
    else {
      unint64_t v29 = v32;
    }
  }
  while (v29);
  if (v30 != v31 && *v30 == v28) {
    uint64_t v36 = v30[1];
  }
  else {
LABEL_33:
  }
    uint64_t v36 = 0;
  v78[0] = v26;
  v78[1] = v36;
  uint64_t v37 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v78)
                  + 8 * v20);
  uint64_t v89 = (int64x2_t *)v91;
  uint64_t v90 = 0x400000000;
  if (mlir::mps::SplitOp::getSplitSizes((mlir::mps::SplitOp *)&v84))
  {
    uint64_t SplitSizes = mlir::mps::SplitOp::getSplitSizes((mlir::mps::SplitOp *)&v84);
    if (mlir::matchConstantWithIntVector<long long>(SplitSizes, (uint64_t)&v89))
    {
      LODWORD(v39) = v90;
LABEL_75:
      FastmathAttr = v88;
      uint64_t v87 = 0x400000000;
      if (v39 >= 5)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&FastmathAttr, v88, v39, 8);
        LODWORD(v39) = v90;
      }
      uint64_t v77 = 0;
      if (v39)
      {
        unint64_t v67 = (uint64_t *)v89;
        uint64_t v68 = 8 * v39;
        do
        {
          uint64_t v76 = *v67;
          uint64_t v69 = *(void *)(v84 + 24);
          uint64_t v75 = mlir::ValueRange::dereference_iterator(&v92, 0);
          unint64_t v70 = mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value,long long const&,unsigned long long &,long long &>((mlir::Builder *)(a4 + 8), v69, &v75, &v79, &v77, &v76);
          uint64_t v71 = v87;
          if (v87 >= (unint64_t)HIDWORD(v87))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&FastmathAttr, v88, v87 + 1, 8);
            uint64_t v71 = v87;
          }
          *((void *)FastmathAttr + v71) = (char *)v70 - 16;
          unsigned int v72 = v87 + 1;
          LODWORD(v87) = v87 + 1;
          v77 += v76;
          ++v67;
          v68 -= 8;
        }
        while (v68);
      }
      else
      {
        unsigned int v72 = v87;
      }
      unint64_t v73 = (unsigned int *)v84;
      mlir::ValueRange::ValueRange(v85, (uint64_t)FastmathAttr, v72);
      mlir::ConversionPatternRewriter::replaceOp(a4, v73, v85[0], v85[1]);
      if (FastmathAttr != v88) {
        free(FastmathAttr);
      }
      uint64_t v21 = 1;
      goto LABEL_87;
    }
    uint64_t v21 = *(void *)(a4 + 16);
    if (v21)
    {
      uint64_t v48 = v84;
      if (mlir::RewriterBase::Listener::classof(v21))
      {
        uint64_t v49 = *(void *)(v48 + 24);
LABEL_52:
        uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v21 + 64))(v21, v49, v50, &FastmathAttr);
        goto LABEL_87;
      }
      goto LABEL_65;
    }
    goto LABEL_87;
  }
  if (mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v84))
  {
    FastmathAttr = (void *)mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v84);
    unint64_t UInt = (unint64_t)mlir::IntegerAttr::getUInt((mlir::IntegerAttr *)&FastmathAttr);
    uint64_t v41 = (v37 + UInt - 1) / UInt;
    unint64_t v39 = v37 / v41;
    if (v37 / v41 > (unint64_t)HIDWORD(v90))
    {
      LODWORD(v90) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v91, v37 / v41, 8);
      uint64_t v42 = (uint64_t *)v89;
      uint64_t v43 = (uint64_t *)v89;
      uint64_t v44 = v37 / v41;
      if (v39 < 4) {
        goto LABEL_95;
      }
      uint64_t v43 = &v89->i64[v39 & 0xFFFFFFFFFFFFFFFCLL];
      uint64_t v44 = (v37 / v41) & 3;
      int64x2_t v45 = vdupq_n_s64(v41);
      uint64_t v46 = v89 + 1;
      unint64_t v47 = v39 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v46[-1] = v45;
        *uint64_t v46 = v45;
        v46 += 2;
        v47 -= 4;
      }
      while (v47);
      if (v39 != (v39 & 0xFFFFFFFFFFFFFFFCLL))
      {
LABEL_95:
        do
        {
          *v43++ = v41;
          --v44;
        }
        while (v44);
      }
      goto LABEL_71;
    }
    uint64_t v42 = (uint64_t *)v89;
    unint64_t v52 = v90;
    if (v90 >= v39) {
      unint64_t v53 = v37 / v41;
    }
    else {
      unint64_t v53 = v90;
    }
    if (v53)
    {
      unint64_t v54 = (uint64_t *)v89;
      unint64_t v55 = v53;
      if (v53 < 4) {
        goto LABEL_96;
      }
      unint64_t v54 = &v89->i64[v53 & 0xFFFFFFFC];
      unint64_t v55 = v53 & 3;
      int64x2_t v56 = vdupq_n_s64(v41);
      uint64_t v57 = v89 + 1;
      uint64_t v58 = v53 & 0xFFFFFFFC;
      do
      {
        v57[-1] = v56;
        *uint64_t v57 = v56;
        v57 += 2;
        v58 -= 4;
      }
      while (v58);
      if (v53 != (v53 & 0xFFFFFFFC))
      {
LABEL_96:
        do
        {
          *v54++ = v41;
          --v55;
        }
        while (v55);
      }
    }
    unint64_t v59 = v39 - v52;
    if (v39 <= v52) {
      goto LABEL_71;
    }
    uint64_t v60 = (int64x2_t *)&v42[v52];
    if (v59 >= 4)
    {
      uint64_t v61 = &v60->i64[v59 & 0xFFFFFFFFFFFFFFFCLL];
      unint64_t v62 = v59 & 3;
      int64x2_t v63 = vdupq_n_s64(v41);
      uint64_t v64 = v60 + 1;
      unint64_t v65 = v59 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v64[-1] = v63;
        *uint64_t v64 = v63;
        v64 += 2;
        v65 -= 4;
      }
      while (v65);
      if (v59 == (v59 & 0xFFFFFFFFFFFFFFFCLL))
      {
LABEL_71:
        LODWORD(v90) = v37 / v41;
        uint64_t v66 = v37 % v41;
        if (v66)
        {
          if (HIDWORD(v90) <= v39)
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v91, v39 + 1, 8);
            LODWORD(v39) = v90;
            uint64_t v42 = (uint64_t *)v89;
          }
          v42[v39] = v66;
          LODWORD(v39) = v90 + 1;
          LODWORD(v90) = v90 + 1;
        }
        goto LABEL_75;
      }
    }
    else
    {
      uint64_t v61 = &v42[v52];
      unint64_t v62 = v59;
    }
    do
    {
      *v61++ = v41;
      --v62;
    }
    while (v62);
    goto LABEL_71;
  }
  uint64_t v21 = *(void *)(a4 + 16);
  if (v21)
  {
    uint64_t v51 = v84;
    if (mlir::RewriterBase::Listener::classof(v21))
    {
      uint64_t v49 = *(void *)(v51 + 24);
      goto LABEL_52;
    }
LABEL_65:
    uint64_t v21 = 0;
  }
LABEL_87:
  if (v89 != (int64x2_t *)v91) {
    free(v89);
  }
  if (v81 >= 0x41 && __p) {
    operator delete[](__p);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SplitOp &>(mlir::mps::SplitOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value,long long const&,unsigned long long &,long long &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.input_view", (const unsigned __int8 *)0xF, Context);
  if (!v14)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.input_view";
    void v21[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::anec::InputView::build(a1, (uint64_t)v23, *a3, *a4, *a5, *a6);
  uint64_t v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::InputView,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertSplit::matchAndRewriteWithStaticShapes(mlir::mps::SplitOp,mlir::mps::SplitOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "ANE Split supports only supports const positive axis");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertSplit::matchAndRewriteWithStaticShapes(mlir::mps::SplitOp,mlir::mps::SplitOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Split supports only 1 axis");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertSplit::matchAndRewriteWithStaticShapes(mlir::mps::SplitOp,mlir::mps::SplitOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Cannot statically infer split sizes");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertSplit::matchAndRewriteWithStaticShapes(mlir::mps::SplitOp,mlir::mps::SplitOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Cannot infer split sizes");
}

void *mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)0>::~ConvertResize(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)0>::~ConvertResize(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ResizeOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ResizeOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ResizeOpGenericAdaptorBase::ResizeOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ResizeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ResizeOpGenericAdaptorBase::ResizeOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ResizeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 88);
  uint64_t v9 = *(void *)(a3 + 96);
  uint64_t v37 = v8;
  uint64_t v38 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v37 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v38 = v23;
        if (v37)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v37);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v33[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v34 = 259;
      v31[0] = v33;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v31);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        uint64_t v36 = *(void *)(a3 + 96);
        long long v28 = *(_OWORD *)(a3 + 80);
        v35[4] = *(_OWORD *)(a3 + 64);
        v35[5] = v28;
        long long v29 = *(_OWORD *)(a3 + 16);
        v35[0] = *(_OWORD *)a3;
        v35[1] = v29;
        long long v30 = *(_OWORD *)(a3 + 48);
        v35[2] = *(_OWORD *)(a3 + 32);
        v35[3] = v30;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v35, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v37, v10);
    v31[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v31[1] = v13;
    if (v31[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v31)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v31))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v31);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v38;
    if (v37 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v34 = 259;
  unint64_t v32 = v33;
  v33[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v32);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::mps *a2, long long *a3, uint64_t *a4)
{
  uint64_t v296 = *MEMORY[0x1E4F143B8];
  long long v5 = a3[5];
  long long v264 = a3[4];
  *(_OWORD *)unint64_t v265 = v5;
  *(void *)&v265[16] = *((void *)a3 + 12);
  long long v6 = a3[1];
  long long v260 = *a3;
  long long v261 = v6;
  long long v7 = a3[3];
  long long v262 = a3[2];
  long long v263 = v7;
  uint64_t v256 = a2;
  long long v295 = *(_OWORD *)&v265[8];
  uint64_t v249 = *((void *)a2 + 3);
  uint64_t v255 = mlir::ValueRange::dereference_iterator(&v295, 0);
  unint64_t v8 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v256) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *v8;
  unint64_t v10 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v11 = *(unsigned int *)(v9 + 16);
  if (!v11) {
    goto LABEL_10;
  }
  uint64_t v12 = *(void **)(v9 + 8);
  uint64_t v13 = &v12[2 * v11];
  do
  {
    unint64_t v14 = v11 >> 1;
    uint64_t v15 = &v12[2 * (v11 >> 1)];
    unint64_t v17 = *v15;
    uint64_t v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10) {
      uint64_t v12 = v16;
    }
    else {
      unint64_t v11 = v14;
    }
  }
  while (v11);
  if (v12 != v13 && *v12 == v10) {
    uint64_t v18 = v12[1];
  }
  else {
LABEL_10:
  }
    uint64_t v18 = 0;
  v254[0] = v8;
  v254[1] = v18;
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)&v260, 0);
  uint64_t v20 = *(void **)&v265[8];
  v273[0] = *(void **)&v265[8];
  v273[1] = (void *)ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    uint64_t v20 = (void *)mlir::ValueRange::offset_base(v273, ODSOperandIndexAndLength);
  }
  v273[0] = v20;
  v273[1] = 0;
  uint64_t v21 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v273, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v21) {
    goto LABEL_22;
  }
  uint64_t v22 = *v21;
  unint64_t v23 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v24 = *(unsigned int *)(v22 + 16);
  if (!v24) {
    goto LABEL_22;
  }
  uint64_t v25 = *(void **)(v22 + 8);
  uint64_t v26 = &v25[2 * v24];
  do
  {
    unint64_t v27 = v24 >> 1;
    long long v28 = &v25[2 * (v24 >> 1)];
    unint64_t v30 = *v28;
    long long v29 = v28 + 2;
    v24 += ~(v24 >> 1);
    if (v30 < v23) {
      uint64_t v25 = v29;
    }
    else {
      unint64_t v24 = v27;
    }
  }
  while (v24);
  if (v25 != v26 && *v25 == v23) {
    uint64_t v31 = (void *)v25[1];
  }
  else {
LABEL_22:
  }
    uint64_t v31 = 0;
  v273[0] = v21;
  v273[1] = v31;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v273);
  unint64_t v33 = v32;
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(0, v32);
  unint64_t v35 = mlir::anec::getIndexFromDim(1, v33);
  unint64_t v36 = mlir::anec::getIndexFromDim(3, v33);
  unint64_t v37 = mlir::anec::getIndexFromDim(4, v33);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v254);
  if (v38 <= 3)
  {
    v273[0] = &v274;
    *(void *)&long long v274 = IndexFromDim;
    *((void *)&v274 + 1) = v35;
    *(void *)&long long v275 = v35;
    *((void *)&v275 + 1) = v36;
    *(void *)&long long v276 = v36;
    *((void *)&v276 + 1) = IndexFromDim;
    v273[1] = (void *)0x600000006;
    *(_OWORD *)v267 = xmmword_181110B40;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    uint64_t v40 = (void *)mlir::RankedTensorType::get((uint64_t)v267, 2, IntegerType, 0);
    uint64_t v41 = v40;
    if (!v40) {
      goto LABEL_33;
    }
    uint64_t v42 = *v40;
    unint64_t v43 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v44 = *(unsigned int *)(v42 + 16);
    if (!v44) {
      goto LABEL_33;
    }
    int64x2_t v45 = *(void **)(v42 + 8);
    uint64_t v46 = &v45[2 * v44];
    do
    {
      unint64_t v47 = v44 >> 1;
      uint64_t v48 = &v45[2 * (v44 >> 1)];
      unint64_t v50 = *v48;
      uint64_t v49 = v48 + 2;
      v44 += ~(v44 >> 1);
      if (v50 < v43) {
        int64x2_t v45 = v49;
      }
      else {
        unint64_t v44 = v47;
      }
    }
    while (v44);
    if (v45 != v46 && *v45 == v43) {
      uint64_t v51 = v45[1];
    }
    else {
LABEL_33:
    }
      uint64_t v51 = 0;
    unint64_t v292 = (mlir::Operation *)mlir::DenseElementsAttr::getFromRawBuffer(v41, v51, v273[0], 8 * LODWORD(v273[1]), 8, 1, 0);
    uint64_t v255 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v249, &v255, (uint64_t *)&v292)- 16;
    if (v273[0] != &v274) {
      free(v273[0]);
    }
  }
  unint64_t v52 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v256) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v52) {
    goto LABEL_45;
  }
  uint64_t v53 = *v52;
  unint64_t v54 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v55 = *(unsigned int *)(v53 + 16);
  if (!v55) {
    goto LABEL_45;
  }
  int64x2_t v56 = *(void **)(v53 + 8);
  uint64_t v57 = &v56[2 * v55];
  do
  {
    unint64_t v58 = v55 >> 1;
    unint64_t v59 = &v56[2 * (v55 >> 1)];
    unint64_t v61 = *v59;
    uint64_t v60 = v59 + 2;
    v55 += ~(v55 >> 1);
    if (v61 < v54) {
      int64x2_t v56 = v60;
    }
    else {
      unint64_t v55 = v58;
    }
  }
  while (v55);
  if (v56 != v57 && *v56 == v54) {
    uint64_t v62 = v56[1];
  }
  else {
LABEL_45:
  }
    uint64_t v62 = 0;
  v253[0] = v52;
  v253[1] = v62;
  uint64_t ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v253);
  uint64_t v65 = v63;
  unint64_t v292 = (mlir::Operation *)v294;
  uint64_t v293 = 0x400000000;
  size_t v66 = 8 * v63;
  if ((unint64_t)(8 * v63) < 0x21)
  {
    unsigned int v67 = 0;
    uint64_t v68 = (mlir::Operation *)v294;
    if (!v65) {
      goto LABEL_51;
    }
    goto LABEL_50;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v292, v294, (8 * v63) >> 3, 8);
  unsigned int v67 = v293;
  uint64_t v68 = v292;
  if (v65)
  {
LABEL_50:
    memcpy((char *)v68 + 8 * v67, ArgAttrsAttr, v66);
    unsigned int v67 = v293;
    uint64_t v68 = v292;
  }
LABEL_51:
  unsigned int v69 = v67 + (v66 >> 3);
  LODWORD(v293) = v69;
  if (v69 <= 3)
  {
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v292, (uint64_t)v68, 4 - v69, 1uLL);
    uint64_t v68 = v292;
  }
  uint64_t v70 = *((void *)v68 + v36);
  uint64_t v71 = *((void *)v68 + v37);
  v289 = v291;
  v291[0] = v70;
  v291[1] = v71;
  uint64_t v290 = 0x200000002;
  uint64_t ResizeLayout = mlir::mps::getResizeLayout(v256, v68);
  if ((ResizeLayout & 0xFF00000000) == 0)
  {
    uint64_t v87 = "Resize layout not supported";
    goto LABEL_87;
  }
  uint64_t v73 = ResizeLayout;
  if (ResizeLayout == 1)
  {
    v273[0] = &v274;
    *(void *)&long long v274 = v35;
    *((void *)&v274 + 1) = v36;
    *(void *)&long long v275 = v36;
    *((void *)&v275 + 1) = v37;
    *(void *)&long long v276 = v37;
    *((void *)&v276 + 1) = v35;
    v273[1] = (void *)0x600000006;
    *(_OWORD *)v267 = xmmword_181110B40;
    uint64_t v74 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    uint64_t v75 = (void *)mlir::RankedTensorType::get((uint64_t)v267, 2, v74, 0);
    uint64_t v76 = v75;
    if (v75)
    {
      uint64_t v77 = *v75;
      unint64_t v78 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v79 = *(unsigned int *)(v77 + 16);
      if (v79)
      {
        uint64_t v80 = *(void **)(v77 + 8);
        unsigned int v81 = &v80[2 * v79];
        do
        {
          unint64_t v82 = v79 >> 1;
          uint64_t v83 = &v80[2 * (v79 >> 1)];
          unint64_t v85 = *v83;
          uint64_t v84 = v83 + 2;
          v79 += ~(v79 >> 1);
          if (v85 < v78) {
            uint64_t v80 = v84;
          }
          else {
            unint64_t v79 = v82;
          }
        }
        while (v79);
        uint64_t v73 = 1;
        if (v80 == v81 || *v80 != v78) {
          goto LABEL_64;
        }
        uint64_t v86 = v80[1];
      }
      else
      {
        uint64_t v86 = 0;
        uint64_t v73 = 1;
      }
LABEL_72:
      v286 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v76, v86, v273[0], 8 * LODWORD(v273[1]), 8, 1, 0);
      uint64_t v255 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v249, &v255, (uint64_t *)&v286)- 16;
      unint64_t v88 = v292;
      uint64_t v89 = v289;
      void *v289 = *((void *)v292 + v35);
      v89[1] = *((void *)v88 + v36);
      if (v273[0] != &v274) {
        free(v273[0]);
      }
      goto LABEL_74;
    }
LABEL_64:
    uint64_t v86 = 0;
    goto LABEL_72;
  }
LABEL_74:
  v252[0] = 0;
  v252[1] = 0;
  Shape = (void *)mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v256);
  v267[0] = v252;
  v273[0] = Shape;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v273);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)v267, DefiningOp))
  {
    uint64_t v244 = v73;
    unint64_t v246 = IndexFromDim;
    v286 = v288;
    v288[0] = 0;
    v288[1] = 0;
    uint64_t v287 = 0x200000002;
    v283 = v285;
    memset_pattern16(v285, &unk_1810FE350, 0x10uLL);
    uint64_t v284 = 0x200000002;
    int GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v256);
    v273[0] = (void *)2;
    uint64_t v245 = (mlir::Builder *)(a4 + 1);
    uint64_t v93 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    uint64_t v94 = (void *)mlir::RankedTensorType::get((uint64_t)v273, 1, v93, 0);
    uint64_t v95 = v94;
    if (v94)
    {
      unint64_t v96 = v37;
      uint64_t v97 = *v94;
      unint64_t v98 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v99 = *(unsigned int *)(v97 + 16);
      if (v99)
      {
        uint64_t v100 = *(void **)(v97 + 8);
        uint64_t v101 = &v100[2 * v99];
        do
        {
          unint64_t v102 = v99 >> 1;
          uint64_t v103 = &v100[2 * (v99 >> 1)];
          unint64_t v105 = *v103;
          uint64_t v104 = v103 + 2;
          v99 += ~(v99 >> 1);
          if (v105 < v98) {
            uint64_t v100 = v104;
          }
          else {
            unint64_t v99 = v102;
          }
        }
        while (v99);
        unint64_t v37 = v96;
        if (v100 == v101)
        {
          uint64_t v106 = 0;
        }
        else if (*v100 == v98)
        {
          uint64_t v106 = v100[1];
        }
        else
        {
          uint64_t v106 = 0;
        }
      }
      else
      {
        uint64_t v106 = 0;
        unint64_t v37 = v96;
      }
    }
    else
    {
      uint64_t v106 = 0;
    }
    if (GateLayout == 1) {
      char v114 = (void **)&v286;
    }
    else {
      char v114 = &v283;
    }
    uint64_t v115 = *v114;
    uint64_t v116 = &v287;
    if (GateLayout != 1) {
      uint64_t v116 = &v284;
    }
    uint64_t v251 = mlir::DenseElementsAttr::getFromRawBuffer(v95, v106, v115, 8 * *(unsigned int *)v116, 8, 1, 0);
    __dst = v282;
    uint64_t v281 = 0x200000000;
    BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v256);
    BOOL IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v256);
    unint64_t v243 = v37;
    if (mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v256)
      || mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v256))
    {
      long long v277 = v264;
      long long v278 = *(_OWORD *)v265;
      *(void *)v279 = *(void *)&v265[16];
      *(_OWORD *)v273 = v260;
      long long v274 = v261;
      long long v275 = v262;
      long long v276 = v263;
      v258[0] = v256;
      uint64_t v120 = mlir::mps::getResizeLayout(v256, v119);
      if ((v120 & 0xFF00000000) == 0) {
        goto LABEL_211;
      }
      uint64_t v121 = 8 * (int)v120;
      unint64_t v122 = *(void *)((char *)&unk_181110CB0 + v121);
      uint64_t v123 = *(void *)((char *)&unk_181110CE8 + v121);
      unint64_t v124 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 2u);
      uint64_t v125 = (void *)*((void *)&v278 + 1);
      v267[0] = *((void **)&v278 + 1);
      v267[1] = (void *)v124;
      if (v124)
      {
        uint64_t v125 = (void *)mlir::ValueRange::offset_base(v267, v124);
        uint64_t v126 = v267[1];
      }
      else
      {
        uint64_t v126 = 0;
      }
      if ((void *)(HIDWORD(v124) + v124) == v126
        || (v267[0] = v125, v267[1] = 0, !mlir::ValueRange::dereference_iterator(v267, 0)))
      {
        float v130 = 1.0;
        float v131 = 1.0;
      }
      else
      {
        *(_OWORD *)v266 = 0uLL;
        unint64_t v127 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 2u);
        uint64_t v128 = (void *)*((void *)&v278 + 1);
        v267[0] = *((void **)&v278 + 1);
        v267[1] = (void *)v127;
        if (v127)
        {
          uint64_t v128 = (void *)mlir::ValueRange::offset_base(v267, v127);
          uint64_t v129 = v267[1];
        }
        else
        {
          uint64_t v129 = 0;
        }
        if ((void *)(HIDWORD(v127) + v127) == v129)
        {
          unint64_t v185 = 0;
        }
        else
        {
          v267[0] = v128;
          v267[1] = 0;
          unint64_t v185 = (void *)mlir::ValueRange::dereference_iterator(v267, 0);
        }
        unint64_t v257 = (uint64_t **)v266;
        v267[0] = v185;
        uint64_t v186 = mlir::Value::getDefiningOp((mlir::Value *)v267);
        if (!v186 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v257, v186)) {
          goto LABEL_211;
        }
        v267[0] = &v268;
        v267[1] = (void *)0x400000000;
        mlir::getIntValues<float>(v266[0], v266[1], (uint64_t)v267, 1);
        unint64_t v187 = LODWORD(v267[1]);
        float v130 = 1.0;
        float v131 = 1.0;
        if (v122 < LODWORD(v267[1]))
        {
          float v131 = *((float *)v267[0] + v122);
          float v130 = *((float *)v267[0] + v123);
        }
        if (v267[0] != &v268) {
          free(v267[0]);
        }
        if (v122 >= v187) {
          goto LABEL_211;
        }
      }
      unint64_t v132 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 3u);
      unint64_t v133 = (void *)*((void *)&v278 + 1);
      v267[0] = *((void **)&v278 + 1);
      v267[1] = (void *)v132;
      if (v132)
      {
        unint64_t v133 = (void *)mlir::ValueRange::offset_base(v267, v132);
        uint64_t v134 = v267[1];
      }
      else
      {
        uint64_t v134 = 0;
      }
      if ((void *)(HIDWORD(v132) + v132) == v134
        || (v267[0] = v133, v267[1] = 0, !mlir::ValueRange::dereference_iterator(v267, 0)))
      {
        float v138 = 0.0;
        float v139 = 0.0;
      }
      else
      {
        *(_OWORD *)v266 = 0uLL;
        unint64_t v135 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 3u);
        unint64_t v136 = (void *)*((void *)&v278 + 1);
        v267[0] = *((void **)&v278 + 1);
        v267[1] = (void *)v135;
        if (v135)
        {
          unint64_t v136 = (void *)mlir::ValueRange::offset_base(v267, v135);
          uint64_t v137 = v267[1];
        }
        else
        {
          uint64_t v137 = 0;
        }
        if ((void *)(HIDWORD(v135) + v135) == v137)
        {
          unint64_t v190 = 0;
        }
        else
        {
          v267[0] = v136;
          v267[1] = 0;
          unint64_t v190 = (void *)mlir::ValueRange::dereference_iterator(v267, 0);
        }
        unint64_t v257 = (uint64_t **)v266;
        v267[0] = v190;
        uint64_t v191 = mlir::Value::getDefiningOp((mlir::Value *)v267);
        if (!v191 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v257, v191)) {
          goto LABEL_211;
        }
        v267[0] = &v268;
        v267[1] = (void *)0x400000000;
        mlir::getIntValues<float>(v266[0], v266[1], (uint64_t)v267, 1);
        unint64_t v192 = LODWORD(v267[1]);
        float v138 = 0.0;
        float v139 = 0.0;
        if (v122 < LODWORD(v267[1]))
        {
          float v139 = *((float *)v267[0] + v122);
          float v138 = *((float *)v267[0] + v123);
        }
        if (v267[0] != &v268) {
          free(v267[0]);
        }
        if (v122 >= v192) {
          goto LABEL_211;
        }
      }
      unsigned int v140 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 0);
      long long v141 = (void *)*((void *)&v278 + 1);
      v267[0] = *((void **)&v278 + 1);
      v267[1] = (void *)v140;
      if (v140) {
        long long v141 = (void *)mlir::ValueRange::offset_base(v267, v140);
      }
      v267[0] = v141;
      v267[1] = 0;
      uint64_t v142 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v267, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v142) {
        goto LABEL_141;
      }
      uint64_t v143 = *v142;
      unint64_t v144 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v145 = *(unsigned int *)(v143 + 16);
      if (!v145) {
        goto LABEL_141;
      }
      long long v146 = *(void **)(v143 + 8);
      unint64_t v147 = &v146[2 * v145];
      do
      {
        unint64_t v148 = v145 >> 1;
        uint64_t v149 = &v146[2 * (v145 >> 1)];
        unint64_t v151 = *v149;
        unint64_t v150 = v149 + 2;
        v145 += ~(v145 >> 1);
        if (v151 < v144) {
          long long v146 = v150;
        }
        else {
          unint64_t v145 = v148;
        }
      }
      while (v145);
      if (v146 != v147 && *v146 == v144) {
        uint64_t v152 = (void *)v146[1];
      }
      else {
LABEL_141:
      }
        uint64_t v152 = 0;
      v267[0] = v142;
      v267[1] = v152;
      uint64_t v153 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v267);
      unint64_t v155 = v154;
      uint64_t v156 = *(void *)(a1 + 96);
      uint64_t v157 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v258);
      unint64_t v158 = (uint64_t *)mlir::TypeConverter::convertType(v156, (void *)(*(void *)(v157 + 8) & 0xFFFFFFFFFFFFFFF8));
      unint64_t v159 = v158;
      if (!v158) {
        goto LABEL_151;
      }
      uint64_t v160 = *v158;
      unint64_t v161 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v162 = *(unsigned int *)(v160 + 16);
      if (!v162) {
        goto LABEL_151;
      }
      unint64_t v163 = *(void **)(v160 + 8);
      v164 = &v163[2 * v162];
      do
      {
        unint64_t v165 = v162 >> 1;
        uint64_t v166 = &v163[2 * (v162 >> 1)];
        unint64_t v168 = *v166;
        uint64_t v167 = v166 + 2;
        v162 += ~(v162 >> 1);
        if (v168 < v161) {
          unint64_t v163 = v167;
        }
        else {
          unint64_t v162 = v165;
        }
      }
      while (v162);
      if (v163 != v164 && *v163 == v161) {
        uint64_t v169 = (void *)v163[1];
      }
      else {
LABEL_151:
      }
        uint64_t v169 = 0;
      v267[0] = v159;
      v267[1] = v169;
      uint64_t v170 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v267);
      unint64_t v172 = v171;
      unint64_t v173 = mlir::anec::getIndexFromDim(3, v155);
      unint64_t v174 = mlir::anec::getIndexFromDim(4, v172);
      float v175 = (float)*(uint64_t *)(v153 + 8 * v173);
      float v176 = (float)*(uint64_t *)(v153 + 8 * v174);
      float v177 = (float)*(uint64_t *)(v170 + 8 * v173);
      float v178 = (float)*(uint64_t *)(v170 + 8 * v174);
      BOOL v179 = v139 != 0.0;
      if (v138 != 0.0) {
        BOOL v179 = 1;
      }
      BOOL v180 = (v131 + -1.0) * 0.5 != v139 || (v130 + -1.0) * 0.5 != v138;
      BOOL v181 = v131 != (float)(v177 / v175) || v130 != (float)(v178 / v176);
      BOOL v182 = v131 != (float)((float)(v177 + -1.0) / (float)(v175 + -1.0))
          || v130 != (float)((float)(v178 + -1.0) / (float)(v176 + -1.0));
      if (v179 || v181)
      {
        if (v179 || v182)
        {
          if (!v180 && !v181)
          {
            BOOL InferredResultTypes = 0;
            BOOL IsSize = 1;
            goto LABEL_172;
          }
LABEL_211:
          uint64_t v193 = a4[2];
          if (v193)
          {
            unint64_t v194 = v256;
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
          }
            }
          uint64_t v109 = 0;
          int v110 = 0;
LABEL_215:
          if (__dst != v282) {
            free(__dst);
          }
          if (v283 != v285) {
            free(v283);
          }
          if (v286 != v288) {
            free(v286);
          }
          goto LABEL_91;
        }
        BOOL IsSize = 1;
        BOOL InferredResultTypes = 1;
LABEL_169:
        if (IsSize)
        {
          v267[0] = &v268;
          long long v268 = 0uLL;
LABEL_178:
          v267[1] = (void *)0x600000002;
          uint64_t v184 = v281;
          if (v281 >= 2)
          {
            *(_OWORD *)__dst = v268;
          }
          else
          {
            if (HIDWORD(v281) > 1)
            {
              if (v281) {
                memmove(__dst, &v268, 8 * v281);
              }
              else {
                uint64_t v184 = 0;
              }
            }
            else
            {
              LODWORD(v281) = 0;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v282, 2uLL, 8);
              uint64_t v184 = 0;
            }
            if (v184 != LODWORD(v267[1])) {
              memcpy((char *)__dst + 8 * v184, (char *)v267[0] + 8 * v184, 8 * LODWORD(v267[1]) - 8 * v184);
            }
          }
          LODWORD(v281) = 2;
          LODWORD(v267[1]) = 0;
          if (v267[0] != &v268) {
            free(v267[0]);
          }
          v267[0] = (void *)2;
          uint64_t v195 = mlir::Builder::getIntegerType(v245, 0x40u, 0);
          uint64_t v196 = (void *)mlir::RankedTensorType::get((uint64_t)v267, 1, v195, 0);
          unint64_t v197 = v196;
          if (!v196) {
            goto LABEL_235;
          }
          uint64_t v198 = *v196;
          unint64_t v199 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v200 = *(unsigned int *)(v198 + 16);
          if (!v200) {
            goto LABEL_235;
          }
          unint64_t v201 = *(void **)(v198 + 8);
          unint64_t v202 = &v201[2 * v200];
          do
          {
            unint64_t v203 = v200 >> 1;
            v204 = &v201[2 * (v200 >> 1)];
            unint64_t v206 = *v204;
            unint64_t v205 = v204 + 2;
            v200 += ~(v200 >> 1);
            if (v206 < v199) {
              unint64_t v201 = v205;
            }
            else {
              unint64_t v200 = v203;
            }
          }
          while (v200);
          if (v201 != v202 && *v201 == v199) {
            uint64_t v207 = v201[1];
          }
          else {
LABEL_235:
          }
            uint64_t v207 = 0;
          unint64_t v257 = (uint64_t **)mlir::DenseElementsAttr::getFromRawBuffer(v197, v207, __dst, 8 * v281, 8, 1, 0);
          unint64_t v208 = v289;
          uint64_t v209 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v266, -1.0);
          uint64_t v210 = llvm::APFloatBase::IEEEsingle(v209);
          llvm::APFloat::Storage::Storage(&v267[1], v266, v210);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v266);
          llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v258, -1.0);
          llvm::APFloat::Storage::Storage(&v266[1], v258, v210);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v258);
          v258[0] = mlir::OpBuilder::create<mlir::anec::Resize,mlir::Value &,unsigned long long &,unsigned long long &,llvm::APFloat,llvm::APFloat,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(v245, v249, &v255, v208, v208 + 1, (uint64_t)v267, (uint64_t)v266, &v251, (uint64_t *)&v257);
          v211 = (void *)v266[1];
          uint64_t v212 = llvm::APFloatBase::PPCDoubleDouble(v258[0]);
          if (v212 == v211) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v266[1]);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v266[1]);
          }
          if (v212 == v267[1]) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v267[1]);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v267[1]);
          }
          char v213 = mlir::anec::Resize::verifyAttributesWithFamily((uint64_t *)v258, 0);
          uint64_t v109 = v258[0];
          if (v213)
          {
            if (v244 == 1)
            {
              v267[0] = &v268;
              *(void *)&long long v268 = v35;
              *((void *)&v268 + 1) = v243;
              unint64_t v269 = v36;
              unint64_t v270 = v35;
              unint64_t v271 = v243;
              unint64_t v272 = v36;
              v267[1] = (void *)0x600000006;
              *(_OWORD *)v266 = xmmword_181110B40;
              uint64_t v214 = mlir::Builder::getIntegerType(v245, 0x40u, 0);
              uint64_t v215 = (void *)mlir::RankedTensorType::get((uint64_t)v266, 2, v214, 0);
              uint64_t v216 = v215;
              if (!v215) {
                goto LABEL_253;
              }
              uint64_t v217 = *v215;
              unint64_t v218 = mlir::TypeID::get<mlir::ShapedType>();
              unint64_t v219 = *(unsigned int *)(v217 + 16);
              if (!v219) {
                goto LABEL_253;
              }
              uint64_t v220 = *(void **)(v217 + 8);
              uint64_t v221 = &v220[2 * v219];
              do
              {
                unint64_t v222 = v219 >> 1;
                unint64_t v223 = &v220[2 * (v219 >> 1)];
                unint64_t v225 = *v223;
                uint64_t v224 = v223 + 2;
                v219 += ~(v219 >> 1);
                if (v225 < v218) {
                  uint64_t v220 = v224;
                }
                else {
                  unint64_t v219 = v222;
                }
              }
              while (v219);
              if (v220 != v221 && *v220 == v218) {
                uint64_t v226 = v220[1];
              }
              else {
LABEL_253:
              }
                uint64_t v226 = 0;
              uint64_t v250 = mlir::DenseElementsAttr::getFromRawBuffer(v216, v226, v267[0], 8 * LODWORD(v267[1]), 8, 1, 0);
              uint64_t v109 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::anec::Resize &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v245, v249, v258, &v250);
              if (v267[0] != &v268) {
                free(v267[0]);
              }
            }
            mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v254);
            if (v227 > 3)
            {
              int v110 = 1;
            }
            else
            {
              v267[0] = &v268;
              *(void *)&long long v268 = v35;
              *((void *)&v268 + 1) = v246;
              unint64_t v269 = v36;
              unint64_t v270 = v35;
              unint64_t v271 = v246;
              unint64_t v272 = v36;
              v267[1] = (void *)0x600000006;
              *(_OWORD *)v266 = xmmword_181110B40;
              uint64_t v228 = mlir::Builder::getIntegerType(v245, 0x40u, 0);
              unint64_t v229 = (void *)mlir::RankedTensorType::get((uint64_t)v266, 2, v228, 0);
              uint64_t v230 = v229;
              if (v229
                && (uint64_t v231 = *v229,
                    unint64_t v232 = mlir::TypeID::get<mlir::ShapedType>(),
                    unint64_t v233 = *(unsigned int *)(v231 + 16),
                    v233))
              {
                v234 = *(void **)(v231 + 8);
                unint64_t v235 = &v234[2 * v233];
                do
                {
                  unint64_t v236 = v233 >> 1;
                  uint64_t v237 = &v234[2 * (v233 >> 1)];
                  unint64_t v239 = *v237;
                  v238 = v237 + 2;
                  v233 += ~(v233 >> 1);
                  if (v239 < v232) {
                    v234 = v238;
                  }
                  else {
                    unint64_t v233 = v236;
                  }
                }
                while (v233);
                if (v234 != v235 && *v234 == v232) {
                  uint64_t v240 = v234[1];
                }
                else {
                  uint64_t v240 = 0;
                }
              }
              else
              {
                uint64_t v240 = 0;
              }
              uint64_t v250 = mlir::DenseElementsAttr::getFromRawBuffer(v230, v240, v267[0], 8 * LODWORD(v267[1]), 8, 1, 0);
              v266[0] = (uint64_t)v109 - 16;
              uint64_t v109 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v245, v249, v266, &v250);
              if (v267[0] != &v268) {
                free(v267[0]);
              }
              int v110 = 1;
            }
          }
          else
          {
            mlir::ConversionPatternRewriter::eraseOp((mlir::ConversionPatternRewriter *)a4, v258[0]);
            v267[0] = "requested attributes are not compatible with hardware requirements";
            LOWORD(v269) = 259;
            uint64_t v241 = v256;
            v266[0] = (uint64_t)v267;
            uint64_t v242 = a4[2];
            if (v242 && mlir::RewriterBase::Listener::classof(a4[2])) {
              (*(void (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(void *)v242 + 64))(v242, *((void *)v241 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v266);
            }
            uint64_t v109 = 0;
            int v110 = 0;
          }
          goto LABEL_215;
        }
LABEL_172:
        if (InferredResultTypes || IsSize)
        {
          if (InferredResultTypes || !IsSize)
          {
            uint64_t v188 = a4[2];
            if (v188)
            {
              unint64_t v189 = v256;
              if (mlir::RewriterBase::Listener::classof(a4[2])) {
            }
              }
            uint64_t v109 = 0;
            int v110 = 0;
            goto LABEL_215;
          }
          v267[0] = &v268;
          uint64_t v183 = &unk_1810FE350;
        }
        else
        {
          v267[0] = &v268;
          uint64_t v183 = &unk_181110BA0;
        }
        memset_pattern16(&v268, v183, 0x10uLL);
        goto LABEL_178;
      }
      BOOL IsSize = 0;
      BOOL InferredResultTypes = 0;
    }
    if (!InferredResultTypes) {
      goto LABEL_172;
    }
    goto LABEL_169;
  }
  uint64_t v87 = "Shape operand was not a constant";
LABEL_87:
  v273[0] = (void *)v87;
  LOWORD(v275) = 259;
  uint64_t v107 = v256;
  v267[0] = v273;
  uint64_t v108 = a4[2];
  if (v108 && mlir::RewriterBase::Listener::classof(a4[2])) {
    (*(void (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v108 + 64))(v108, *((void *)v107 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v267);
  }
  uint64_t v109 = 0;
  int v110 = 0;
LABEL_91:
  if (v289 != v291) {
    free(v289);
  }
  if (v292 != (mlir::Operation *)v294) {
    free(v292);
  }
  if (v110)
  {
    v273[0] = (char *)v109 - 16;
    uint64_t v111 = 1;
    mlir::ValueRange::ValueRange(v259, (uint64_t)v273, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)a2, v259[0], v259[1]);
  }
  else
  {
    v273[0] = "Conversion did not match a valid resize or a valid transformation supported by the hardware.";
    LOWORD(v275) = 259;
    v267[0] = v273;
    uint64_t v112 = a4[2];
    if (v112 && mlir::RewriterBase::Listener::classof(v112)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v112 + 64))(v112, *((void *)a2 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v267);
    }
    else {
      return 0;
    }
  }
  return v111;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.transpose", (const unsigned __int8 *)0xE, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.transpose";
    v17[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Transpose::build(a1, (uint64_t)v19, *a3, *a4);
  unint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Transpose,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Resize,mlir::Value &,unsigned long long &,unsigned long long &,llvm::APFloat,llvm::APFloat,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t *a8, uint64_t *a9)
{
  v40[38] = *MEMORY[0x1E4F143B8];
  uint64_t v31 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v31);
  uint64_t v18 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.resize", (const unsigned __int8 *)0xB, Context);
  if (!v19)
  {
    __int16 v35 = 1283;
    uint64_t v34[2] = (uint64_t)"anec.resize";
    v34[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v33 = 259;
    llvm::operator+(v34, (uint64_t *)&v32, (uint64_t)v40);
    llvm::report_fatal_error((llvm::Twine *)v40, 1);
  }
  mlir::OperationState::OperationState(v40, a2, v18);
  uint64_t v20 = *a3;
  uint64_t v21 = *a4;
  uint64_t v22 = *a5;
  unint64_t v24 = *(void **)(a6 + 8);
  unint64_t v23 = (void *)(a6 + 8);
  uint64_t v26 = llvm::APFloatBase::PPCDoubleDouble(v25);
  if (v26 == v24) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v39, v23);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v39, (uint64_t)v23);
  }
  unint64_t v27 = (void *)(a7 + 8);
  if (v26 == *(void **)(a7 + 8)) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v37, v27);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v37, (uint64_t)v27);
  }
  mlir::anec::Resize::build(a1, (uint64_t)v40, v20, v21, v22, (uint64_t)v38, (uint64_t)v36, *a8, *a9);
  if (v26 == (void *)v37[0]) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v37);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v37);
  }
  if (v26 == (void *)v39[0]) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v39);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v39);
  }
  long long v28 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v40);
  if (*(_UNKNOWN **)(*((void *)v28 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Resize,void>::id) {
    long long v29 = v28;
  }
  else {
    long long v29 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v40);
  return v29;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Transpose,mlir::anec::Resize &,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, void *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.transpose", (const unsigned __int8 *)0xE, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.transpose";
    v17[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Transpose::build(a1, (uint64_t)v19, *a3 - 16, *a4);
  unint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Transpose,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)0>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Resize with custom scale and offset values not supported on ANE.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)0>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported alignCorners, centerResult for Resize\n");
}

void *mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)1>::~ConvertResize(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)1>::~ConvertResize(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::mps *a2, long long *a3, uint64_t *a4)
{
  uint64_t v296 = *MEMORY[0x1E4F143B8];
  long long v5 = a3[5];
  long long v264 = a3[4];
  *(_OWORD *)unint64_t v265 = v5;
  *(void *)&v265[16] = *((void *)a3 + 12);
  long long v6 = a3[1];
  long long v260 = *a3;
  long long v261 = v6;
  long long v7 = a3[3];
  long long v262 = a3[2];
  long long v263 = v7;
  uint64_t v256 = a2;
  long long v295 = *(_OWORD *)&v265[8];
  uint64_t v249 = *((void *)a2 + 3);
  uint64_t v255 = mlir::ValueRange::dereference_iterator(&v295, 0);
  unint64_t v8 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v256) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *v8;
  unint64_t v10 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v11 = *(unsigned int *)(v9 + 16);
  if (!v11) {
    goto LABEL_10;
  }
  uint64_t v12 = *(void **)(v9 + 8);
  uint64_t v13 = &v12[2 * v11];
  do
  {
    unint64_t v14 = v11 >> 1;
    uint64_t v15 = &v12[2 * (v11 >> 1)];
    unint64_t v17 = *v15;
    __int16 v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10) {
      uint64_t v12 = v16;
    }
    else {
      unint64_t v11 = v14;
    }
  }
  while (v11);
  if (v12 != v13 && *v12 == v10) {
    uint64_t v18 = v12[1];
  }
  else {
LABEL_10:
  }
    uint64_t v18 = 0;
  v254[0] = v8;
  v254[1] = v18;
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)&v260, 0);
  uint64_t v20 = *(void **)&v265[8];
  v273[0] = *(void **)&v265[8];
  v273[1] = (void *)ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    uint64_t v20 = (void *)mlir::ValueRange::offset_base(v273, ODSOperandIndexAndLength);
  }
  v273[0] = v20;
  v273[1] = 0;
  uint64_t v21 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v273, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v21) {
    goto LABEL_22;
  }
  uint64_t v22 = *v21;
  unint64_t v23 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v24 = *(unsigned int *)(v22 + 16);
  if (!v24) {
    goto LABEL_22;
  }
  uint64_t v25 = *(void **)(v22 + 8);
  uint64_t v26 = &v25[2 * v24];
  do
  {
    unint64_t v27 = v24 >> 1;
    long long v28 = &v25[2 * (v24 >> 1)];
    unint64_t v30 = *v28;
    long long v29 = v28 + 2;
    v24 += ~(v24 >> 1);
    if (v30 < v23) {
      uint64_t v25 = v29;
    }
    else {
      unint64_t v24 = v27;
    }
  }
  while (v24);
  if (v25 != v26 && *v25 == v23) {
    uint64_t v31 = (void *)v25[1];
  }
  else {
LABEL_22:
  }
    uint64_t v31 = 0;
  v273[0] = v21;
  v273[1] = v31;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v273);
  unint64_t v33 = v32;
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(0, v32);
  unint64_t v35 = mlir::anec::getIndexFromDim(1, v33);
  unint64_t v36 = mlir::anec::getIndexFromDim(3, v33);
  unint64_t v37 = mlir::anec::getIndexFromDim(4, v33);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v254);
  if (v38 <= 3)
  {
    v273[0] = &v274;
    *(void *)&long long v274 = IndexFromDim;
    *((void *)&v274 + 1) = v35;
    *(void *)&long long v275 = v35;
    *((void *)&v275 + 1) = v36;
    *(void *)&long long v276 = v36;
    *((void *)&v276 + 1) = IndexFromDim;
    v273[1] = (void *)0x600000006;
    *(_OWORD *)v267 = xmmword_181110B40;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    uint64_t v40 = (void *)mlir::RankedTensorType::get((uint64_t)v267, 2, IntegerType, 0);
    uint64_t v41 = v40;
    if (!v40) {
      goto LABEL_33;
    }
    uint64_t v42 = *v40;
    unint64_t v43 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v44 = *(unsigned int *)(v42 + 16);
    if (!v44) {
      goto LABEL_33;
    }
    int64x2_t v45 = *(void **)(v42 + 8);
    uint64_t v46 = &v45[2 * v44];
    do
    {
      unint64_t v47 = v44 >> 1;
      uint64_t v48 = &v45[2 * (v44 >> 1)];
      unint64_t v50 = *v48;
      uint64_t v49 = v48 + 2;
      v44 += ~(v44 >> 1);
      if (v50 < v43) {
        int64x2_t v45 = v49;
      }
      else {
        unint64_t v44 = v47;
      }
    }
    while (v44);
    if (v45 != v46 && *v45 == v43) {
      uint64_t v51 = v45[1];
    }
    else {
LABEL_33:
    }
      uint64_t v51 = 0;
    unint64_t v292 = (mlir::Operation *)mlir::DenseElementsAttr::getFromRawBuffer(v41, v51, v273[0], 8 * LODWORD(v273[1]), 8, 1, 0);
    uint64_t v255 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v249, &v255, (uint64_t *)&v292)- 16;
    if (v273[0] != &v274) {
      free(v273[0]);
    }
  }
  unint64_t v52 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v256) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v52) {
    goto LABEL_45;
  }
  uint64_t v53 = *v52;
  unint64_t v54 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v55 = *(unsigned int *)(v53 + 16);
  if (!v55) {
    goto LABEL_45;
  }
  int64x2_t v56 = *(void **)(v53 + 8);
  uint64_t v57 = &v56[2 * v55];
  do
  {
    unint64_t v58 = v55 >> 1;
    unint64_t v59 = &v56[2 * (v55 >> 1)];
    unint64_t v61 = *v59;
    uint64_t v60 = v59 + 2;
    v55 += ~(v55 >> 1);
    if (v61 < v54) {
      int64x2_t v56 = v60;
    }
    else {
      unint64_t v55 = v58;
    }
  }
  while (v55);
  if (v56 != v57 && *v56 == v54) {
    uint64_t v62 = v56[1];
  }
  else {
LABEL_45:
  }
    uint64_t v62 = 0;
  v253[0] = v52;
  v253[1] = v62;
  uint64_t ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v253);
  uint64_t v65 = v63;
  unint64_t v292 = (mlir::Operation *)v294;
  uint64_t v293 = 0x400000000;
  size_t v66 = 8 * v63;
  if ((unint64_t)(8 * v63) < 0x21)
  {
    unsigned int v67 = 0;
    uint64_t v68 = (mlir::Operation *)v294;
    if (!v65) {
      goto LABEL_51;
    }
    goto LABEL_50;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v292, v294, (8 * v63) >> 3, 8);
  unsigned int v67 = v293;
  uint64_t v68 = v292;
  if (v65)
  {
LABEL_50:
    memcpy((char *)v68 + 8 * v67, ArgAttrsAttr, v66);
    unsigned int v67 = v293;
    uint64_t v68 = v292;
  }
LABEL_51:
  unsigned int v69 = v67 + (v66 >> 3);
  LODWORD(v293) = v69;
  if (v69 <= 3)
  {
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v292, (uint64_t)v68, 4 - v69, 1uLL);
    uint64_t v68 = v292;
  }
  uint64_t v70 = *((void *)v68 + v36);
  uint64_t v71 = *((void *)v68 + v37);
  v289 = v291;
  v291[0] = v70;
  v291[1] = v71;
  uint64_t v290 = 0x200000002;
  uint64_t ResizeLayout = mlir::mps::getResizeLayout(v256, v68);
  if ((ResizeLayout & 0xFF00000000) == 0)
  {
    uint64_t v87 = "Resize layout not supported";
    goto LABEL_87;
  }
  uint64_t v73 = ResizeLayout;
  if (ResizeLayout == 1)
  {
    v273[0] = &v274;
    *(void *)&long long v274 = v35;
    *((void *)&v274 + 1) = v36;
    *(void *)&long long v275 = v36;
    *((void *)&v275 + 1) = v37;
    *(void *)&long long v276 = v37;
    *((void *)&v276 + 1) = v35;
    v273[1] = (void *)0x600000006;
    *(_OWORD *)v267 = xmmword_181110B40;
    uint64_t v74 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    uint64_t v75 = (void *)mlir::RankedTensorType::get((uint64_t)v267, 2, v74, 0);
    uint64_t v76 = v75;
    if (v75)
    {
      uint64_t v77 = *v75;
      unint64_t v78 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v79 = *(unsigned int *)(v77 + 16);
      if (v79)
      {
        uint64_t v80 = *(void **)(v77 + 8);
        unsigned int v81 = &v80[2 * v79];
        do
        {
          unint64_t v82 = v79 >> 1;
          uint64_t v83 = &v80[2 * (v79 >> 1)];
          unint64_t v85 = *v83;
          uint64_t v84 = v83 + 2;
          v79 += ~(v79 >> 1);
          if (v85 < v78) {
            uint64_t v80 = v84;
          }
          else {
            unint64_t v79 = v82;
          }
        }
        while (v79);
        uint64_t v73 = 1;
        if (v80 == v81 || *v80 != v78) {
          goto LABEL_64;
        }
        uint64_t v86 = v80[1];
      }
      else
      {
        uint64_t v86 = 0;
        uint64_t v73 = 1;
      }
LABEL_72:
      v286 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v76, v86, v273[0], 8 * LODWORD(v273[1]), 8, 1, 0);
      uint64_t v255 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v249, &v255, (uint64_t *)&v286)- 16;
      unint64_t v88 = v292;
      uint64_t v89 = v289;
      void *v289 = *((void *)v292 + v35);
      v89[1] = *((void *)v88 + v36);
      if (v273[0] != &v274) {
        free(v273[0]);
      }
      goto LABEL_74;
    }
LABEL_64:
    uint64_t v86 = 0;
    goto LABEL_72;
  }
LABEL_74:
  v252[0] = 0;
  v252[1] = 0;
  Shape = (void *)mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v256);
  v267[0] = v252;
  v273[0] = Shape;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v273);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)v267, DefiningOp))
  {
    uint64_t v244 = v73;
    unint64_t v246 = IndexFromDim;
    v286 = v288;
    v288[0] = 0;
    v288[1] = 0;
    uint64_t v287 = 0x200000002;
    v283 = v285;
    memset_pattern16(v285, &unk_1810FE350, 0x10uLL);
    uint64_t v284 = 0x200000002;
    int GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v256);
    v273[0] = (void *)2;
    uint64_t v245 = (mlir::Builder *)(a4 + 1);
    uint64_t v93 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    uint64_t v94 = (void *)mlir::RankedTensorType::get((uint64_t)v273, 1, v93, 0);
    uint64_t v95 = v94;
    if (v94)
    {
      unint64_t v96 = v37;
      uint64_t v97 = *v94;
      unint64_t v98 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v99 = *(unsigned int *)(v97 + 16);
      if (v99)
      {
        uint64_t v100 = *(void **)(v97 + 8);
        uint64_t v101 = &v100[2 * v99];
        do
        {
          unint64_t v102 = v99 >> 1;
          uint64_t v103 = &v100[2 * (v99 >> 1)];
          unint64_t v105 = *v103;
          uint64_t v104 = v103 + 2;
          v99 += ~(v99 >> 1);
          if (v105 < v98) {
            uint64_t v100 = v104;
          }
          else {
            unint64_t v99 = v102;
          }
        }
        while (v99);
        unint64_t v37 = v96;
        if (v100 == v101)
        {
          uint64_t v106 = 0;
        }
        else if (*v100 == v98)
        {
          uint64_t v106 = v100[1];
        }
        else
        {
          uint64_t v106 = 0;
        }
      }
      else
      {
        uint64_t v106 = 0;
        unint64_t v37 = v96;
      }
    }
    else
    {
      uint64_t v106 = 0;
    }
    if (GateLayout == 1) {
      char v114 = (void **)&v286;
    }
    else {
      char v114 = &v283;
    }
    uint64_t v115 = *v114;
    uint64_t v116 = &v287;
    if (GateLayout != 1) {
      uint64_t v116 = &v284;
    }
    uint64_t v251 = mlir::DenseElementsAttr::getFromRawBuffer(v95, v106, v115, 8 * *(unsigned int *)v116, 8, 1, 0);
    __dst = v282;
    uint64_t v281 = 0x200000000;
    BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v256);
    BOOL IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v256);
    unint64_t v243 = v37;
    if (mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v256)
      || mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v256))
    {
      long long v277 = v264;
      long long v278 = *(_OWORD *)v265;
      *(void *)v279 = *(void *)&v265[16];
      *(_OWORD *)v273 = v260;
      long long v274 = v261;
      long long v275 = v262;
      long long v276 = v263;
      v258[0] = v256;
      uint64_t v120 = mlir::mps::getResizeLayout(v256, v119);
      if ((v120 & 0xFF00000000) == 0) {
        goto LABEL_211;
      }
      uint64_t v121 = 8 * (int)v120;
      unint64_t v122 = *(void *)((char *)&unk_181110CB0 + v121);
      uint64_t v123 = *(void *)((char *)&unk_181110CE8 + v121);
      unint64_t v124 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 2u);
      uint64_t v125 = (void *)*((void *)&v278 + 1);
      v267[0] = *((void **)&v278 + 1);
      v267[1] = (void *)v124;
      if (v124)
      {
        uint64_t v125 = (void *)mlir::ValueRange::offset_base(v267, v124);
        uint64_t v126 = v267[1];
      }
      else
      {
        uint64_t v126 = 0;
      }
      if ((void *)(HIDWORD(v124) + v124) == v126
        || (v267[0] = v125, v267[1] = 0, !mlir::ValueRange::dereference_iterator(v267, 0)))
      {
        float v130 = 1.0;
        float v131 = 1.0;
      }
      else
      {
        *(_OWORD *)v266 = 0uLL;
        unint64_t v127 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 2u);
        uint64_t v128 = (void *)*((void *)&v278 + 1);
        v267[0] = *((void **)&v278 + 1);
        v267[1] = (void *)v127;
        if (v127)
        {
          uint64_t v128 = (void *)mlir::ValueRange::offset_base(v267, v127);
          uint64_t v129 = v267[1];
        }
        else
        {
          uint64_t v129 = 0;
        }
        if ((void *)(HIDWORD(v127) + v127) == v129)
        {
          unint64_t v185 = 0;
        }
        else
        {
          v267[0] = v128;
          v267[1] = 0;
          unint64_t v185 = (void *)mlir::ValueRange::dereference_iterator(v267, 0);
        }
        unint64_t v257 = (uint64_t **)v266;
        v267[0] = v185;
        uint64_t v186 = mlir::Value::getDefiningOp((mlir::Value *)v267);
        if (!v186 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v257, v186)) {
          goto LABEL_211;
        }
        v267[0] = &v268;
        v267[1] = (void *)0x400000000;
        mlir::getIntValues<float>(v266[0], v266[1], (uint64_t)v267, 1);
        unint64_t v187 = LODWORD(v267[1]);
        float v130 = 1.0;
        float v131 = 1.0;
        if (v122 < LODWORD(v267[1]))
        {
          float v131 = *((float *)v267[0] + v122);
          float v130 = *((float *)v267[0] + v123);
        }
        if (v267[0] != &v268) {
          free(v267[0]);
        }
        if (v122 >= v187) {
          goto LABEL_211;
        }
      }
      unint64_t v132 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 3u);
      unint64_t v133 = (void *)*((void *)&v278 + 1);
      v267[0] = *((void **)&v278 + 1);
      v267[1] = (void *)v132;
      if (v132)
      {
        unint64_t v133 = (void *)mlir::ValueRange::offset_base(v267, v132);
        uint64_t v134 = v267[1];
      }
      else
      {
        uint64_t v134 = 0;
      }
      if ((void *)(HIDWORD(v132) + v132) == v134
        || (v267[0] = v133, v267[1] = 0, !mlir::ValueRange::dereference_iterator(v267, 0)))
      {
        float v138 = 0.0;
        float v139 = 0.0;
      }
      else
      {
        *(_OWORD *)v266 = 0uLL;
        unint64_t v135 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 3u);
        unint64_t v136 = (void *)*((void *)&v278 + 1);
        v267[0] = *((void **)&v278 + 1);
        v267[1] = (void *)v135;
        if (v135)
        {
          unint64_t v136 = (void *)mlir::ValueRange::offset_base(v267, v135);
          uint64_t v137 = v267[1];
        }
        else
        {
          uint64_t v137 = 0;
        }
        if ((void *)(HIDWORD(v135) + v135) == v137)
        {
          unint64_t v190 = 0;
        }
        else
        {
          v267[0] = v136;
          v267[1] = 0;
          unint64_t v190 = (void *)mlir::ValueRange::dereference_iterator(v267, 0);
        }
        unint64_t v257 = (uint64_t **)v266;
        v267[0] = v190;
        uint64_t v191 = mlir::Value::getDefiningOp((mlir::Value *)v267);
        if (!v191 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v257, v191)) {
          goto LABEL_211;
        }
        v267[0] = &v268;
        v267[1] = (void *)0x400000000;
        mlir::getIntValues<float>(v266[0], v266[1], (uint64_t)v267, 1);
        unint64_t v192 = LODWORD(v267[1]);
        float v138 = 0.0;
        float v139 = 0.0;
        if (v122 < LODWORD(v267[1]))
        {
          float v139 = *((float *)v267[0] + v122);
          float v138 = *((float *)v267[0] + v123);
        }
        if (v267[0] != &v268) {
          free(v267[0]);
        }
        if (v122 >= v192) {
          goto LABEL_211;
        }
      }
      unsigned int v140 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 0);
      long long v141 = (void *)*((void *)&v278 + 1);
      v267[0] = *((void **)&v278 + 1);
      v267[1] = (void *)v140;
      if (v140) {
        long long v141 = (void *)mlir::ValueRange::offset_base(v267, v140);
      }
      v267[0] = v141;
      v267[1] = 0;
      uint64_t v142 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v267, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v142) {
        goto LABEL_141;
      }
      uint64_t v143 = *v142;
      unint64_t v144 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v145 = *(unsigned int *)(v143 + 16);
      if (!v145) {
        goto LABEL_141;
      }
      long long v146 = *(void **)(v143 + 8);
      unint64_t v147 = &v146[2 * v145];
      do
      {
        unint64_t v148 = v145 >> 1;
        uint64_t v149 = &v146[2 * (v145 >> 1)];
        unint64_t v151 = *v149;
        unint64_t v150 = v149 + 2;
        v145 += ~(v145 >> 1);
        if (v151 < v144) {
          long long v146 = v150;
        }
        else {
          unint64_t v145 = v148;
        }
      }
      while (v145);
      if (v146 != v147 && *v146 == v144) {
        uint64_t v152 = (void *)v146[1];
      }
      else {
LABEL_141:
      }
        uint64_t v152 = 0;
      v267[0] = v142;
      v267[1] = v152;
      uint64_t v153 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v267);
      unint64_t v155 = v154;
      uint64_t v156 = *(void *)(a1 + 96);
      uint64_t v157 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v258);
      unint64_t v158 = (uint64_t *)mlir::TypeConverter::convertType(v156, (void *)(*(void *)(v157 + 8) & 0xFFFFFFFFFFFFFFF8));
      unint64_t v159 = v158;
      if (!v158) {
        goto LABEL_151;
      }
      uint64_t v160 = *v158;
      unint64_t v161 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v162 = *(unsigned int *)(v160 + 16);
      if (!v162) {
        goto LABEL_151;
      }
      unint64_t v163 = *(void **)(v160 + 8);
      v164 = &v163[2 * v162];
      do
      {
        unint64_t v165 = v162 >> 1;
        uint64_t v166 = &v163[2 * (v162 >> 1)];
        unint64_t v168 = *v166;
        uint64_t v167 = v166 + 2;
        v162 += ~(v162 >> 1);
        if (v168 < v161) {
          unint64_t v163 = v167;
        }
        else {
          unint64_t v162 = v165;
        }
      }
      while (v162);
      if (v163 != v164 && *v163 == v161) {
        uint64_t v169 = (void *)v163[1];
      }
      else {
LABEL_151:
      }
        uint64_t v169 = 0;
      v267[0] = v159;
      v267[1] = v169;
      uint64_t v170 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v267);
      unint64_t v172 = v171;
      unint64_t v173 = mlir::anec::getIndexFromDim(3, v155);
      unint64_t v174 = mlir::anec::getIndexFromDim(4, v172);
      float v175 = (float)*(uint64_t *)(v153 + 8 * v173);
      float v176 = (float)*(uint64_t *)(v153 + 8 * v174);
      float v177 = (float)*(uint64_t *)(v170 + 8 * v173);
      float v178 = (float)*(uint64_t *)(v170 + 8 * v174);
      BOOL v179 = v139 != 0.0;
      if (v138 != 0.0) {
        BOOL v179 = 1;
      }
      BOOL v180 = (v131 + -1.0) * 0.5 != v139 || (v130 + -1.0) * 0.5 != v138;
      BOOL v181 = v131 != (float)(v177 / v175) || v130 != (float)(v178 / v176);
      BOOL v182 = v131 != (float)((float)(v177 + -1.0) / (float)(v175 + -1.0))
          || v130 != (float)((float)(v178 + -1.0) / (float)(v176 + -1.0));
      if (v179 || v181)
      {
        if (v179 || v182)
        {
          if (!v180 && !v181)
          {
            BOOL InferredResultTypes = 0;
            BOOL IsSize = 1;
            goto LABEL_172;
          }
LABEL_211:
          uint64_t v193 = a4[2];
          if (v193)
          {
            unint64_t v194 = v256;
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
          }
            }
          uint64_t v109 = 0;
          int v110 = 0;
LABEL_215:
          if (__dst != v282) {
            free(__dst);
          }
          if (v283 != v285) {
            free(v283);
          }
          if (v286 != v288) {
            free(v286);
          }
          goto LABEL_91;
        }
        BOOL IsSize = 1;
        BOOL InferredResultTypes = 1;
LABEL_169:
        if (IsSize)
        {
          v267[0] = &v268;
          long long v268 = 0uLL;
LABEL_178:
          v267[1] = (void *)0x600000002;
          uint64_t v184 = v281;
          if (v281 >= 2)
          {
            *(_OWORD *)__dst = v268;
          }
          else
          {
            if (HIDWORD(v281) > 1)
            {
              if (v281) {
                memmove(__dst, &v268, 8 * v281);
              }
              else {
                uint64_t v184 = 0;
              }
            }
            else
            {
              LODWORD(v281) = 0;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v282, 2uLL, 8);
              uint64_t v184 = 0;
            }
            if (v184 != LODWORD(v267[1])) {
              memcpy((char *)__dst + 8 * v184, (char *)v267[0] + 8 * v184, 8 * LODWORD(v267[1]) - 8 * v184);
            }
          }
          LODWORD(v281) = 2;
          LODWORD(v267[1]) = 0;
          if (v267[0] != &v268) {
            free(v267[0]);
          }
          v267[0] = (void *)2;
          uint64_t v195 = mlir::Builder::getIntegerType(v245, 0x40u, 0);
          uint64_t v196 = (void *)mlir::RankedTensorType::get((uint64_t)v267, 1, v195, 0);
          unint64_t v197 = v196;
          if (!v196) {
            goto LABEL_235;
          }
          uint64_t v198 = *v196;
          unint64_t v199 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v200 = *(unsigned int *)(v198 + 16);
          if (!v200) {
            goto LABEL_235;
          }
          unint64_t v201 = *(void **)(v198 + 8);
          unint64_t v202 = &v201[2 * v200];
          do
          {
            unint64_t v203 = v200 >> 1;
            v204 = &v201[2 * (v200 >> 1)];
            unint64_t v206 = *v204;
            unint64_t v205 = v204 + 2;
            v200 += ~(v200 >> 1);
            if (v206 < v199) {
              unint64_t v201 = v205;
            }
            else {
              unint64_t v200 = v203;
            }
          }
          while (v200);
          if (v201 != v202 && *v201 == v199) {
            uint64_t v207 = v201[1];
          }
          else {
LABEL_235:
          }
            uint64_t v207 = 0;
          unint64_t v257 = (uint64_t **)mlir::DenseElementsAttr::getFromRawBuffer(v197, v207, __dst, 8 * v281, 8, 1, 0);
          unint64_t v208 = v289;
          uint64_t v209 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v266, -1.0);
          uint64_t v210 = llvm::APFloatBase::IEEEsingle(v209);
          llvm::APFloat::Storage::Storage(&v267[1], v266, v210);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v266);
          llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v258, -1.0);
          llvm::APFloat::Storage::Storage(&v266[1], v258, v210);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v258);
          v258[0] = mlir::OpBuilder::create<mlir::anec::Resize,mlir::Value &,unsigned long long &,unsigned long long &,llvm::APFloat,llvm::APFloat,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(v245, v249, &v255, v208, v208 + 1, (uint64_t)v267, (uint64_t)v266, &v251, (uint64_t *)&v257);
          v211 = (void *)v266[1];
          uint64_t v212 = llvm::APFloatBase::PPCDoubleDouble(v258[0]);
          if (v212 == v211) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v266[1]);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v266[1]);
          }
          if (v212 == v267[1]) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v267[1]);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v267[1]);
          }
          char v213 = mlir::anec::Resize::verifyAttributesWithFamily((uint64_t *)v258, 1);
          uint64_t v109 = v258[0];
          if (v213)
          {
            if (v244 == 1)
            {
              v267[0] = &v268;
              *(void *)&long long v268 = v35;
              *((void *)&v268 + 1) = v243;
              unint64_t v269 = v36;
              unint64_t v270 = v35;
              unint64_t v271 = v243;
              unint64_t v272 = v36;
              v267[1] = (void *)0x600000006;
              *(_OWORD *)v266 = xmmword_181110B40;
              uint64_t v214 = mlir::Builder::getIntegerType(v245, 0x40u, 0);
              uint64_t v215 = (void *)mlir::RankedTensorType::get((uint64_t)v266, 2, v214, 0);
              uint64_t v216 = v215;
              if (!v215) {
                goto LABEL_253;
              }
              uint64_t v217 = *v215;
              unint64_t v218 = mlir::TypeID::get<mlir::ShapedType>();
              unint64_t v219 = *(unsigned int *)(v217 + 16);
              if (!v219) {
                goto LABEL_253;
              }
              uint64_t v220 = *(void **)(v217 + 8);
              uint64_t v221 = &v220[2 * v219];
              do
              {
                unint64_t v222 = v219 >> 1;
                unint64_t v223 = &v220[2 * (v219 >> 1)];
                unint64_t v225 = *v223;
                uint64_t v224 = v223 + 2;
                v219 += ~(v219 >> 1);
                if (v225 < v218) {
                  uint64_t v220 = v224;
                }
                else {
                  unint64_t v219 = v222;
                }
              }
              while (v219);
              if (v220 != v221 && *v220 == v218) {
                uint64_t v226 = v220[1];
              }
              else {
LABEL_253:
              }
                uint64_t v226 = 0;
              uint64_t v250 = mlir::DenseElementsAttr::getFromRawBuffer(v216, v226, v267[0], 8 * LODWORD(v267[1]), 8, 1, 0);
              uint64_t v109 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::anec::Resize &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v245, v249, v258, &v250);
              if (v267[0] != &v268) {
                free(v267[0]);
              }
            }
            mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v254);
            if (v227 > 3)
            {
              int v110 = 1;
            }
            else
            {
              v267[0] = &v268;
              *(void *)&long long v268 = v35;
              *((void *)&v268 + 1) = v246;
              unint64_t v269 = v36;
              unint64_t v270 = v35;
              unint64_t v271 = v246;
              unint64_t v272 = v36;
              v267[1] = (void *)0x600000006;
              *(_OWORD *)v266 = xmmword_181110B40;
              uint64_t v228 = mlir::Builder::getIntegerType(v245, 0x40u, 0);
              unint64_t v229 = (void *)mlir::RankedTensorType::get((uint64_t)v266, 2, v228, 0);
              uint64_t v230 = v229;
              if (v229
                && (uint64_t v231 = *v229,
                    unint64_t v232 = mlir::TypeID::get<mlir::ShapedType>(),
                    unint64_t v233 = *(unsigned int *)(v231 + 16),
                    v233))
              {
                v234 = *(void **)(v231 + 8);
                unint64_t v235 = &v234[2 * v233];
                do
                {
                  unint64_t v236 = v233 >> 1;
                  uint64_t v237 = &v234[2 * (v233 >> 1)];
                  unint64_t v239 = *v237;
                  v238 = v237 + 2;
                  v233 += ~(v233 >> 1);
                  if (v239 < v232) {
                    v234 = v238;
                  }
                  else {
                    unint64_t v233 = v236;
                  }
                }
                while (v233);
                if (v234 != v235 && *v234 == v232) {
                  uint64_t v240 = v234[1];
                }
                else {
                  uint64_t v240 = 0;
                }
              }
              else
              {
                uint64_t v240 = 0;
              }
              uint64_t v250 = mlir::DenseElementsAttr::getFromRawBuffer(v230, v240, v267[0], 8 * LODWORD(v267[1]), 8, 1, 0);
              v266[0] = (uint64_t)v109 - 16;
              uint64_t v109 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v245, v249, v266, &v250);
              if (v267[0] != &v268) {
                free(v267[0]);
              }
              int v110 = 1;
            }
          }
          else
          {
            mlir::ConversionPatternRewriter::eraseOp((mlir::ConversionPatternRewriter *)a4, v258[0]);
            v267[0] = "requested attributes are not compatible with hardware requirements";
            LOWORD(v269) = 259;
            uint64_t v241 = v256;
            v266[0] = (uint64_t)v267;
            uint64_t v242 = a4[2];
            if (v242 && mlir::RewriterBase::Listener::classof(a4[2])) {
              (*(void (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(void *)v242 + 64))(v242, *((void *)v241 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v266);
            }
            uint64_t v109 = 0;
            int v110 = 0;
          }
          goto LABEL_215;
        }
LABEL_172:
        if (InferredResultTypes || IsSize)
        {
          if (InferredResultTypes || !IsSize)
          {
            uint64_t v188 = a4[2];
            if (v188)
            {
              unint64_t v189 = v256;
              if (mlir::RewriterBase::Listener::classof(a4[2])) {
            }
              }
            uint64_t v109 = 0;
            int v110 = 0;
            goto LABEL_215;
          }
          v267[0] = &v268;
          uint64_t v183 = &unk_1810FE350;
        }
        else
        {
          v267[0] = &v268;
          uint64_t v183 = &unk_181110BA0;
        }
        memset_pattern16(&v268, v183, 0x10uLL);
        goto LABEL_178;
      }
      BOOL IsSize = 0;
      BOOL InferredResultTypes = 0;
    }
    if (!InferredResultTypes) {
      goto LABEL_172;
    }
    goto LABEL_169;
  }
  uint64_t v87 = "Shape operand was not a constant";
LABEL_87:
  v273[0] = (void *)v87;
  LOWORD(v275) = 259;
  uint64_t v107 = v256;
  v267[0] = v273;
  uint64_t v108 = a4[2];
  if (v108 && mlir::RewriterBase::Listener::classof(a4[2])) {
    (*(void (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v108 + 64))(v108, *((void *)v107 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v267);
  }
  uint64_t v109 = 0;
  int v110 = 0;
LABEL_91:
  if (v289 != v291) {
    free(v289);
  }
  if (v292 != (mlir::Operation *)v294) {
    free(v292);
  }
  if (v110)
  {
    v273[0] = (char *)v109 - 16;
    uint64_t v111 = 1;
    mlir::ValueRange::ValueRange(v259, (uint64_t)v273, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)a2, v259[0], v259[1]);
  }
  else
  {
    v273[0] = "Conversion did not match a valid resize or a valid transformation supported by the hardware.";
    LOWORD(v275) = 259;
    v267[0] = v273;
    uint64_t v112 = a4[2];
    if (v112 && mlir::RewriterBase::Listener::classof(v112)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v112 + 64))(v112, *((void *)a2 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v267);
    }
    else {
      return 0;
    }
  }
  return v111;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)1>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Resize with custom scale and offset values not supported on ANE.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)1>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported alignCorners, centerResult for Resize\n");
}

void *mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)2>::~ConvertResize(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)2>::~ConvertResize(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::mps *a2, long long *a3, uint64_t *a4)
{
  uint64_t v298 = *MEMORY[0x1E4F143B8];
  long long v5 = a3[5];
  long long v266 = a3[4];
  *(_OWORD *)v267 = v5;
  *(void *)&v267[16] = *((void *)a3 + 12);
  long long v6 = a3[1];
  long long v262 = *a3;
  long long v263 = v6;
  long long v7 = a3[3];
  long long v264 = a3[2];
  long long v265 = v7;
  long long v258 = a2;
  long long v297 = *(_OWORD *)&v267[8];
  uint64_t v8 = *((void *)a2 + 3);
  uint64_t v257 = mlir::ValueRange::dereference_iterator(&v297, 0);
  uint64_t v9 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v258) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *v9;
  unint64_t v11 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v12 = *(unsigned int *)(v10 + 16);
  if (!v12) {
    goto LABEL_10;
  }
  uint64_t v13 = *(void **)(v10 + 8);
  unint64_t v14 = &v13[2 * v12];
  do
  {
    unint64_t v15 = v12 >> 1;
    __int16 v16 = &v13[2 * (v12 >> 1)];
    unint64_t v18 = *v16;
    unint64_t v17 = v16 + 2;
    v12 += ~(v12 >> 1);
    if (v18 < v11) {
      uint64_t v13 = v17;
    }
    else {
      unint64_t v12 = v15;
    }
  }
  while (v12);
  if (v13 != v14 && *v13 == v11) {
    uint64_t v19 = v13[1];
  }
  else {
LABEL_10:
  }
    uint64_t v19 = 0;
  v256[0] = v9;
  v256[1] = v19;
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)&v262, 0);
  uint64_t v21 = *(void **)&v267[8];
  v275[0] = *(void **)&v267[8];
  v275[1] = (void *)ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    uint64_t v21 = (void *)mlir::ValueRange::offset_base(v275, ODSOperandIndexAndLength);
  }
  v275[0] = v21;
  v275[1] = 0;
  uint64_t v22 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v275, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v22) {
    goto LABEL_22;
  }
  uint64_t v23 = *v22;
  unint64_t v24 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v25 = *(unsigned int *)(v23 + 16);
  if (!v25) {
    goto LABEL_22;
  }
  uint64_t v26 = *(void **)(v23 + 8);
  unint64_t v27 = &v26[2 * v25];
  do
  {
    unint64_t v28 = v25 >> 1;
    long long v29 = &v26[2 * (v25 >> 1)];
    unint64_t v31 = *v29;
    unint64_t v30 = v29 + 2;
    v25 += ~(v25 >> 1);
    if (v31 < v24) {
      uint64_t v26 = v30;
    }
    else {
      unint64_t v25 = v28;
    }
  }
  while (v25);
  if (v26 != v27 && *v26 == v24) {
    unint64_t v32 = (void *)v26[1];
  }
  else {
LABEL_22:
  }
    unint64_t v32 = 0;
  v275[0] = v22;
  v275[1] = v32;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v275);
  unint64_t v34 = v33;
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(0, v33);
  unint64_t v36 = mlir::anec::getIndexFromDim(1, v34);
  unint64_t v37 = mlir::anec::getIndexFromDim(3, v34);
  unint64_t v251 = mlir::anec::getIndexFromDim(4, v34);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v256);
  if (v38 <= 3)
  {
    v275[0] = &v276;
    *(void *)&long long v276 = IndexFromDim;
    *((void *)&v276 + 1) = v36;
    *(void *)&long long v277 = v36;
    *((void *)&v277 + 1) = v37;
    *(void *)&long long v278 = v37;
    *((void *)&v278 + 1) = IndexFromDim;
    v275[1] = (void *)0x600000006;
    *(_OWORD *)unint64_t v269 = xmmword_181110B40;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    uint64_t v40 = (void *)mlir::RankedTensorType::get((uint64_t)v269, 2, IntegerType, 0);
    uint64_t v41 = v40;
    if (!v40) {
      goto LABEL_33;
    }
    uint64_t v42 = *v40;
    unint64_t v43 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v44 = *(unsigned int *)(v42 + 16);
    if (!v44) {
      goto LABEL_33;
    }
    int64x2_t v45 = *(void **)(v42 + 8);
    uint64_t v46 = &v45[2 * v44];
    do
    {
      unint64_t v47 = v44 >> 1;
      uint64_t v48 = &v45[2 * (v44 >> 1)];
      unint64_t v50 = *v48;
      uint64_t v49 = v48 + 2;
      v44 += ~(v44 >> 1);
      if (v50 < v43) {
        int64x2_t v45 = v49;
      }
      else {
        unint64_t v44 = v47;
      }
    }
    while (v44);
    if (v45 != v46 && *v45 == v43) {
      uint64_t v51 = v45[1];
    }
    else {
LABEL_33:
    }
      uint64_t v51 = 0;
    v294 = (mlir::Operation *)mlir::DenseElementsAttr::getFromRawBuffer(v41, v51, v275[0], 8 * LODWORD(v275[1]), 8, 1, 0);
    uint64_t v257 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v8, &v257, (uint64_t *)&v294)- 16;
    if (v275[0] != &v276) {
      free(v275[0]);
    }
  }
  unint64_t v52 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v258) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v52) {
    goto LABEL_45;
  }
  uint64_t v53 = *v52;
  unint64_t v54 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v55 = *(unsigned int *)(v53 + 16);
  if (!v55) {
    goto LABEL_45;
  }
  int64x2_t v56 = *(void **)(v53 + 8);
  uint64_t v57 = &v56[2 * v55];
  do
  {
    unint64_t v58 = v55 >> 1;
    unint64_t v59 = &v56[2 * (v55 >> 1)];
    unint64_t v61 = *v59;
    uint64_t v60 = v59 + 2;
    v55 += ~(v55 >> 1);
    if (v61 < v54) {
      int64x2_t v56 = v60;
    }
    else {
      unint64_t v55 = v58;
    }
  }
  while (v55);
  if (v56 != v57 && *v56 == v54) {
    uint64_t v62 = v56[1];
  }
  else {
LABEL_45:
  }
    uint64_t v62 = 0;
  v255[0] = v52;
  v255[1] = v62;
  uint64_t ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v255);
  uint64_t v65 = v63;
  v294 = (mlir::Operation *)v296;
  uint64_t v295 = 0x400000000;
  size_t v66 = 8 * v63;
  if ((unint64_t)(8 * v63) < 0x21)
  {
    unsigned int v67 = 0;
    uint64_t v68 = (mlir::Operation *)v296;
    if (!v65) {
      goto LABEL_51;
    }
    goto LABEL_50;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v294, v296, (8 * v63) >> 3, 8);
  unsigned int v67 = v295;
  uint64_t v68 = v294;
  if (v65)
  {
LABEL_50:
    memcpy((char *)v68 + 8 * v67, ArgAttrsAttr, v66);
    unsigned int v67 = v295;
    uint64_t v68 = v294;
  }
LABEL_51:
  unsigned int v69 = v67 + (v66 >> 3);
  LODWORD(v295) = v69;
  if (v69 <= 3)
  {
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v294, (uint64_t)v68, 4 - v69, 1uLL);
    uint64_t v68 = v294;
  }
  uint64_t v70 = *((void *)v68 + v37);
  uint64_t v71 = *((void *)v68 + v251);
  unint64_t v291 = v293;
  v293[0] = v70;
  v293[1] = v71;
  uint64_t v292 = 0x200000002;
  uint64_t ResizeLayout = mlir::mps::getResizeLayout(v258, v68);
  if ((ResizeLayout & 0xFF00000000) != 0)
  {
    uint64_t v247 = ResizeLayout;
    if (ResizeLayout == 1)
    {
      v275[0] = &v276;
      *(void *)&long long v276 = v36;
      *((void *)&v276 + 1) = v37;
      *(void *)&long long v277 = v37;
      *((void *)&v277 + 1) = v251;
      *(void *)&long long v278 = v251;
      *((void *)&v278 + 1) = v36;
      v275[1] = (void *)0x600000006;
      *(_OWORD *)unint64_t v269 = xmmword_181110B40;
      uint64_t v73 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
      uint64_t v74 = (void *)mlir::RankedTensorType::get((uint64_t)v269, 2, v73, 0);
      uint64_t v75 = v74;
      if (v74)
      {
        uint64_t v76 = v8;
        uint64_t v77 = *v74;
        unint64_t v78 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v79 = *(unsigned int *)(v77 + 16);
        if (v79)
        {
          uint64_t v80 = *(void **)(v77 + 8);
          unsigned int v81 = &v80[2 * v79];
          do
          {
            unint64_t v82 = v79 >> 1;
            uint64_t v83 = &v80[2 * (v79 >> 1)];
            unint64_t v85 = *v83;
            uint64_t v84 = v83 + 2;
            v79 += ~(v79 >> 1);
            if (v85 < v78) {
              uint64_t v80 = v84;
            }
            else {
              unint64_t v79 = v82;
            }
          }
          while (v79);
          uint64_t v8 = v76;
          if (v80 == v81) {
            uint64_t v86 = 0;
          }
          else {
            uint64_t v86 = *v80 == v78 ? v80[1] : 0;
          }
        }
        else
        {
          uint64_t v86 = 0;
          uint64_t v8 = v76;
        }
      }
      else
      {
        uint64_t v86 = 0;
      }
      uint64_t v288 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v75, v86, v275[0], 8 * LODWORD(v275[1]), 8, 1, 0);
      uint64_t v257 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v8, &v257, (uint64_t *)&v288)- 16;
      unint64_t v88 = v294;
      uint64_t v89 = v291;
      *unint64_t v291 = *((void *)v294 + v36);
      v89[1] = *((void *)v88 + v37);
      if (v275[0] != &v276) {
        free(v275[0]);
      }
    }
    v254[0] = 0;
    v254[1] = 0;
    Shape = (void *)mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v258);
    v269[0] = v254;
    v275[0] = Shape;
    uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v275);
    if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)v269, DefiningOp))
    {
      uint64_t v245 = v8;
      uint64_t v288 = v290;
      v290[0] = 0;
      v290[1] = 0;
      uint64_t v289 = 0x200000002;
      unint64_t v285 = v287;
      memset_pattern16(v287, &unk_1810FE350, 0x10uLL);
      uint64_t v286 = 0x200000002;
      int GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v258);
      v275[0] = (void *)2;
      unint64_t v246 = (mlir::Builder *)(a4 + 1);
      uint64_t v93 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
      uint64_t v94 = (void *)mlir::RankedTensorType::get((uint64_t)v275, 1, v93, 0);
      uint64_t v95 = v94;
      if (v94)
      {
        uint64_t v96 = *v94;
        unint64_t v97 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v98 = *(unsigned int *)(v96 + 16);
        if (v98)
        {
          unint64_t v99 = *(void **)(v96 + 8);
          uint64_t v100 = &v99[2 * v98];
          do
          {
            unint64_t v101 = v98 >> 1;
            unint64_t v102 = &v99[2 * (v98 >> 1)];
            unint64_t v104 = *v102;
            uint64_t v103 = v102 + 2;
            v98 += ~(v98 >> 1);
            if (v104 < v97) {
              unint64_t v99 = v103;
            }
            else {
              unint64_t v98 = v101;
            }
          }
          while (v98);
          if (v99 == v100)
          {
            uint64_t v105 = 0;
          }
          else if (*v99 == v97)
          {
            uint64_t v105 = v99[1];
          }
          else
          {
            uint64_t v105 = 0;
          }
        }
        else
        {
          uint64_t v105 = 0;
        }
      }
      else
      {
        uint64_t v105 = 0;
      }
      if (GateLayout == 1) {
        uint64_t v113 = (void **)&v288;
      }
      else {
        uint64_t v113 = &v285;
      }
      char v114 = *v113;
      uint64_t v115 = &v289;
      if (GateLayout != 1) {
        uint64_t v115 = &v286;
      }
      uint64_t v253 = mlir::DenseElementsAttr::getFromRawBuffer(v95, v105, v114, 8 * *(unsigned int *)v115, 8, 1, 0);
      __dst = v284;
      uint64_t v283 = 0x200000000;
      BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v258);
      BOOL IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v258);
      if (!mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v258)
        && !mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v258))
      {
        goto LABEL_203;
      }
      long long v279 = v266;
      long long v280 = *(_OWORD *)v267;
      *(void *)uint64_t v281 = *(void *)&v267[16];
      *(_OWORD *)long long v275 = v262;
      long long v276 = v263;
      long long v277 = v264;
      long long v278 = v265;
      v260[0] = v258;
      uint64_t v119 = mlir::mps::getResizeLayout(v258, v118);
      if ((v119 & 0xFF00000000) == 0) {
        goto LABEL_197;
      }
      uint64_t v120 = 8 * (int)v119;
      unint64_t v121 = *(void *)((char *)&unk_181110CB0 + v120);
      uint64_t v122 = *(void *)((char *)&unk_181110CE8 + v120);
      unint64_t v123 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v275, 2u);
      unint64_t v124 = (void *)*((void *)&v280 + 1);
      v269[0] = *((void **)&v280 + 1);
      v269[1] = (void *)v123;
      if (v123)
      {
        unint64_t v124 = (void *)mlir::ValueRange::offset_base(v269, v123);
        uint64_t v125 = v269[1];
      }
      else
      {
        uint64_t v125 = 0;
      }
      if ((void *)(HIDWORD(v123) + v123) == v125
        || (v269[0] = v124, v269[1] = 0, !mlir::ValueRange::dereference_iterator(v269, 0)))
      {
        float v129 = 1.0;
        float v130 = 1.0;
      }
      else
      {
        *(_OWORD *)long long v268 = 0uLL;
        unint64_t v126 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v275, 2u);
        unint64_t v127 = (void *)*((void *)&v280 + 1);
        v269[0] = *((void **)&v280 + 1);
        v269[1] = (void *)v126;
        if (v126)
        {
          unint64_t v127 = (void *)mlir::ValueRange::offset_base(v269, v126);
          uint64_t v128 = v269[1];
        }
        else
        {
          uint64_t v128 = 0;
        }
        if ((void *)(HIDWORD(v126) + v126) == v128)
        {
          uint64_t v152 = 0;
        }
        else
        {
          v269[0] = v127;
          v269[1] = 0;
          uint64_t v152 = (void *)mlir::ValueRange::dereference_iterator(v269, 0);
        }
        uint64_t v259 = (uint64_t **)v268;
        v269[0] = v152;
        uint64_t v153 = mlir::Value::getDefiningOp((mlir::Value *)v269);
        if (!v153 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v259, v153)) {
          goto LABEL_197;
        }
        v269[0] = &v270;
        v269[1] = (void *)0x400000000;
        mlir::getIntValues<float>(v268[0], v268[1], (uint64_t)v269, 1);
        unint64_t v154 = LODWORD(v269[1]);
        float v129 = 1.0;
        float v130 = 1.0;
        if (v121 < LODWORD(v269[1]))
        {
          float v130 = *((float *)v269[0] + v121);
          float v129 = *((float *)v269[0] + v122);
        }
        if (v269[0] != &v270) {
          free(v269[0]);
        }
        if (v121 >= v154) {
          goto LABEL_197;
        }
      }
      unint64_t v131 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v275, 3u);
      unint64_t v132 = (void *)*((void *)&v280 + 1);
      v269[0] = *((void **)&v280 + 1);
      v269[1] = (void *)v131;
      if (v131)
      {
        unint64_t v132 = (void *)mlir::ValueRange::offset_base(v269, v131);
        unint64_t v133 = v269[1];
      }
      else
      {
        unint64_t v133 = 0;
      }
      if ((void *)(HIDWORD(v131) + v131) == v133
        || (v269[0] = v132, v269[1] = 0, !mlir::ValueRange::dereference_iterator(v269, 0)))
      {
        float v137 = 0.0;
        float v138 = 0.0;
      }
      else
      {
        *(_OWORD *)long long v268 = 0uLL;
        unint64_t v134 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v275, 3u);
        unint64_t v135 = (void *)*((void *)&v280 + 1);
        v269[0] = *((void **)&v280 + 1);
        v269[1] = (void *)v134;
        if (v134)
        {
          unint64_t v135 = (void *)mlir::ValueRange::offset_base(v269, v134);
          unint64_t v136 = v269[1];
        }
        else
        {
          unint64_t v136 = 0;
        }
        if ((void *)(HIDWORD(v134) + v134) == v136)
        {
          unint64_t v155 = 0;
        }
        else
        {
          v269[0] = v135;
          v269[1] = 0;
          unint64_t v155 = (void *)mlir::ValueRange::dereference_iterator(v269, 0);
        }
        uint64_t v259 = (uint64_t **)v268;
        v269[0] = v155;
        uint64_t v156 = mlir::Value::getDefiningOp((mlir::Value *)v269);
        if (!v156 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v259, v156)) {
          goto LABEL_197;
        }
        v269[0] = &v270;
        v269[1] = (void *)0x400000000;
        mlir::getIntValues<float>(v268[0], v268[1], (uint64_t)v269, 1);
        unint64_t v157 = LODWORD(v269[1]);
        float v137 = 0.0;
        float v138 = 0.0;
        if (v121 < LODWORD(v269[1]))
        {
          float v138 = *((float *)v269[0] + v121);
          float v137 = *((float *)v269[0] + v122);
        }
        if (v269[0] != &v270) {
          free(v269[0]);
        }
        if (v121 >= v157) {
          goto LABEL_197;
        }
      }
      unsigned int v139 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v275, 0);
      unsigned int v140 = (void *)*((void *)&v280 + 1);
      v269[0] = *((void **)&v280 + 1);
      v269[1] = (void *)v139;
      if (v139) {
        unsigned int v140 = (void *)mlir::ValueRange::offset_base(v269, v139);
      }
      v269[0] = v140;
      v269[1] = 0;
      long long v141 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v269, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v141) {
        goto LABEL_143;
      }
      uint64_t v142 = *v141;
      unint64_t v143 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v144 = *(unsigned int *)(v142 + 16);
      if (v144)
      {
        unint64_t v145 = *(void **)(v142 + 8);
        long long v146 = &v145[2 * v144];
        do
        {
          unint64_t v147 = v144 >> 1;
          unint64_t v148 = &v145[2 * (v144 >> 1)];
          unint64_t v150 = *v148;
          uint64_t v149 = v148 + 2;
          v144 += ~(v144 >> 1);
          if (v150 < v143) {
            unint64_t v145 = v149;
          }
          else {
            unint64_t v144 = v147;
          }
        }
        while (v144);
        if (v145 == v146 || *v145 != v143)
        {
LABEL_143:
          unint64_t v151 = 0;
          goto LABEL_170;
        }
        unint64_t v151 = (void *)v145[1];
      }
      else
      {
        unint64_t v151 = 0;
      }
LABEL_170:
      v269[0] = v141;
      v269[1] = v151;
      uint64_t v158 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v269);
      unint64_t v160 = v159;
      uint64_t v161 = *(void *)(a1 + 96);
      uint64_t v162 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v260);
      unint64_t v163 = (uint64_t *)mlir::TypeConverter::convertType(v161, (void *)(*(void *)(v162 + 8) & 0xFFFFFFFFFFFFFFF8));
      v164 = v163;
      if (v163)
      {
        uint64_t v165 = *v163;
        unint64_t v166 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v167 = *(unsigned int *)(v165 + 16);
        if (v167)
        {
          unint64_t v168 = *(void **)(v165 + 8);
          uint64_t v169 = &v168[2 * v167];
          do
          {
            unint64_t v170 = v167 >> 1;
            unint64_t v171 = &v168[2 * (v167 >> 1)];
            unint64_t v173 = *v171;
            unint64_t v172 = v171 + 2;
            v167 += ~(v167 >> 1);
            if (v173 < v166) {
              unint64_t v168 = v172;
            }
            else {
              unint64_t v167 = v170;
            }
          }
          while (v167);
          if (v168 == v169)
          {
            unint64_t v174 = 0;
          }
          else
          {
            if (*v168 != v166) {
              goto LABEL_179;
            }
            unint64_t v174 = (void *)v168[1];
          }
        }
        else
        {
          unint64_t v174 = 0;
        }
LABEL_183:
        v269[0] = v164;
        v269[1] = v174;
        uint64_t v175 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v269);
        unint64_t v177 = v176;
        unint64_t v178 = mlir::anec::getIndexFromDim(3, v160);
        unint64_t v179 = mlir::anec::getIndexFromDim(4, v177);
        float v180 = (float)*(uint64_t *)(v158 + 8 * v178);
        float v181 = (float)*(uint64_t *)(v158 + 8 * v179);
        float v182 = (float)*(uint64_t *)(v175 + 8 * v178);
        float v183 = (float)*(uint64_t *)(v175 + 8 * v179);
        BOOL v184 = v138 != 0.0;
        if (v137 != 0.0) {
          BOOL v184 = 1;
        }
        BOOL v185 = (v130 + -1.0) * 0.5 != v138 || (v129 + -1.0) * 0.5 != v137;
        BOOL v186 = v130 != (float)(v182 / v180) || v129 != (float)(v183 / v181);
        BOOL v187 = v130 != (float)((float)(v182 + -1.0) / (float)(v180 + -1.0))
            || v129 != (float)((float)(v183 + -1.0) / (float)(v181 + -1.0));
        if (v184 || v186)
        {
          if (v184 || v187)
          {
            if (v185 || v186)
            {
LABEL_197:
              uint64_t v188 = a4[2];
              if (!v188) {
                goto LABEL_209;
              }
              unint64_t v189 = v258;
              if (!mlir::RewriterBase::Listener::classof(a4[2])) {
                goto LABEL_209;
              }
              uint64_t v190 = *((void *)v189 + 3);
LABEL_208:
              (*(void (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v188 + 64))(v188, v190, v191, v269);
LABEL_209:
              uint64_t v108 = 0;
              int v109 = 0;
LABEL_210:
              if (__dst != v284) {
                free(__dst);
              }
              if (v285 != v287) {
                free(v285);
              }
              if (v288 != v290) {
                free(v288);
              }
              goto LABEL_93;
            }
            BOOL InferredResultTypes = 0;
            BOOL IsSize = 1;
          }
          else
          {
            BOOL IsSize = 1;
            BOOL InferredResultTypes = 1;
          }
        }
        else
        {
          BOOL IsSize = 0;
          BOOL InferredResultTypes = 0;
        }
LABEL_203:
        if (InferredResultTypes && IsSize)
        {
          uint64_t v188 = a4[2];
          if (!v188) {
            goto LABEL_209;
          }
          unint64_t v192 = v258;
          if (!mlir::RewriterBase::Listener::classof(a4[2])) {
            goto LABEL_209;
          }
          uint64_t v190 = *((void *)v192 + 3);
          goto LABEL_208;
        }
        if (InferredResultTypes || IsSize)
        {
          if (InferredResultTypes || !IsSize)
          {
            uint64_t v188 = a4[2];
            if (!v188) {
              goto LABEL_209;
            }
            uint64_t v195 = v258;
            if (!mlir::RewriterBase::Listener::classof(a4[2])) {
              goto LABEL_209;
            }
            uint64_t v190 = *((void *)v195 + 3);
            goto LABEL_208;
          }
          v269[0] = &v270;
          uint64_t v193 = &unk_1810FE350;
        }
        else
        {
          v269[0] = &v270;
          uint64_t v193 = &unk_181110BA0;
        }
        memset_pattern16(&v270, v193, 0x10uLL);
        v269[1] = (void *)0x600000002;
        uint64_t v194 = v283;
        if (v283 >= 2)
        {
          *(_OWORD *)__dst = v270;
        }
        else
        {
          if (HIDWORD(v283) > 1)
          {
            if (v283) {
              memmove(__dst, &v270, 8 * v283);
            }
            else {
              uint64_t v194 = 0;
            }
          }
          else
          {
            LODWORD(v283) = 0;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v284, 2uLL, 8);
            uint64_t v194 = 0;
          }
          if (v194 != LODWORD(v269[1])) {
            memcpy((char *)__dst + 8 * v194, (char *)v269[0] + 8 * v194, 8 * LODWORD(v269[1]) - 8 * v194);
          }
        }
        LODWORD(v283) = 2;
        LODWORD(v269[1]) = 0;
        if (v269[0] != &v270) {
          free(v269[0]);
        }
        v269[0] = (void *)2;
        uint64_t v196 = mlir::Builder::getIntegerType(v246, 0x40u, 0);
        unint64_t v197 = (void *)mlir::RankedTensorType::get((uint64_t)v269, 1, v196, 0);
        uint64_t v198 = v197;
        if (!v197) {
          goto LABEL_244;
        }
        uint64_t v199 = *v197;
        unint64_t v200 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v201 = *(unsigned int *)(v199 + 16);
        if (!v201) {
          goto LABEL_244;
        }
        unint64_t v202 = *(void **)(v199 + 8);
        unint64_t v203 = &v202[2 * v201];
        do
        {
          unint64_t v204 = v201 >> 1;
          unint64_t v205 = &v202[2 * (v201 >> 1)];
          unint64_t v207 = *v205;
          unint64_t v206 = v205 + 2;
          v201 += ~(v201 >> 1);
          if (v207 < v200) {
            unint64_t v202 = v206;
          }
          else {
            unint64_t v201 = v204;
          }
        }
        while (v201);
        if (v202 != v203 && *v202 == v200) {
          uint64_t v208 = v202[1];
        }
        else {
LABEL_244:
        }
          uint64_t v208 = 0;
        uint64_t v259 = (uint64_t **)mlir::DenseElementsAttr::getFromRawBuffer(v198, v208, __dst, 8 * v283, 8, 1, 0);
        uint64_t v209 = v291;
        uint64_t v249 = v291 + 1;
        uint64_t v210 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v268, -1.0);
        v211 = llvm::APFloatBase::IEEEsingle(v210);
        llvm::APFloat::Storage::Storage(&v269[1], v268, v211);
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v268);
        llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v260, -1.0);
        llvm::APFloat::Storage::Storage(&v268[1], v260, v211);
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v260);
        v260[0] = mlir::OpBuilder::create<mlir::anec::Resize,mlir::Value &,unsigned long long &,unsigned long long &,llvm::APFloat,llvm::APFloat,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(v246, v245, &v257, v209, v249, (uint64_t)v269, (uint64_t)v268, &v253, (uint64_t *)&v259);
        uint64_t v212 = (void *)v268[1];
        char v213 = llvm::APFloatBase::PPCDoubleDouble(v260[0]);
        if (v213 == v212) {
          llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v268[1]);
        }
        else {
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v268[1]);
        }
        if (v213 == v269[1]) {
          llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v269[1]);
        }
        else {
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v269[1]);
        }
        char v214 = mlir::anec::Resize::verifyAttributesWithFamily((uint64_t *)v260, 2);
        uint64_t v108 = v260[0];
        if (!v214)
        {
          mlir::ConversionPatternRewriter::eraseOp((mlir::ConversionPatternRewriter *)a4, v260[0]);
          v269[0] = "requested attributes are not compatible with hardware requirements";
          LOWORD(v271) = 259;
          unint64_t v229 = v258;
          v268[0] = (uint64_t)v269;
          uint64_t v230 = a4[2];
          if (v230 && mlir::RewriterBase::Listener::classof(a4[2])) {
            (*(void (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(void *)v230 + 64))(v230, *((void *)v229 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v268);
          }
          goto LABEL_209;
        }
        if (v247 != 1)
        {
LABEL_273:
          mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v256);
          if (v231 > 3)
          {
            int v109 = 1;
          }
          else
          {
            v269[0] = &v270;
            *(void *)&long long v270 = v36;
            *((void *)&v270 + 1) = IndexFromDim;
            unint64_t v271 = v37;
            unint64_t v272 = v36;
            unint64_t v273 = IndexFromDim;
            unint64_t v274 = v37;
            v269[1] = (void *)0x600000006;
            *(_OWORD *)long long v268 = xmmword_181110B40;
            uint64_t v232 = mlir::Builder::getIntegerType(v246, 0x40u, 0);
            unint64_t v233 = (void *)mlir::RankedTensorType::get((uint64_t)v268, 2, v232, 0);
            v234 = v233;
            if (v233)
            {
              uint64_t v235 = *v233;
              unint64_t v236 = mlir::TypeID::get<mlir::ShapedType>();
              unint64_t v237 = *(unsigned int *)(v235 + 16);
              if (v237)
              {
                v238 = *(void **)(v235 + 8);
                unint64_t v239 = &v238[2 * v237];
                do
                {
                  unint64_t v240 = v237 >> 1;
                  uint64_t v241 = &v238[2 * (v237 >> 1)];
                  unint64_t v243 = *v241;
                  uint64_t v242 = v241 + 2;
                  v237 += ~(v237 >> 1);
                  if (v243 < v236) {
                    v238 = v242;
                  }
                  else {
                    unint64_t v237 = v240;
                  }
                }
                while (v237);
                if (v238 != v239 && *v238 == v236) {
                  uint64_t v244 = v238[1];
                }
                else {
                  uint64_t v244 = 0;
                }
              }
              else
              {
                uint64_t v244 = 0;
              }
            }
            else
            {
              uint64_t v244 = 0;
            }
            uint64_t v252 = mlir::DenseElementsAttr::getFromRawBuffer(v234, v244, v269[0], 8 * LODWORD(v269[1]), 8, 1, 0);
            v268[0] = (uint64_t)v108 - 16;
            uint64_t v108 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v246, v245, v268, &v252);
            if (v269[0] != &v270) {
              free(v269[0]);
            }
            int v109 = 1;
          }
          goto LABEL_210;
        }
        unint64_t v215 = IndexFromDim;
        v269[0] = &v270;
        *(void *)&long long v270 = v36;
        *((void *)&v270 + 1) = v251;
        unint64_t v271 = v37;
        unint64_t v272 = v36;
        unint64_t v273 = v251;
        unint64_t v274 = v37;
        v269[1] = (void *)0x600000006;
        *(_OWORD *)long long v268 = xmmword_181110B40;
        uint64_t v216 = mlir::Builder::getIntegerType(v246, 0x40u, 0);
        uint64_t v217 = (void *)mlir::RankedTensorType::get((uint64_t)v268, 2, v216, 0);
        unint64_t v218 = v217;
        if (v217)
        {
          uint64_t v219 = *v217;
          unint64_t v220 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v221 = *(unsigned int *)(v219 + 16);
          if (!v221)
          {
            uint64_t v228 = 0;
            goto LABEL_270;
          }
          unint64_t v222 = *(void **)(v219 + 8);
          unint64_t v223 = &v222[2 * v221];
          do
          {
            unint64_t v224 = v221 >> 1;
            unint64_t v225 = &v222[2 * (v221 >> 1)];
            unint64_t v227 = *v225;
            uint64_t v226 = v225 + 2;
            v221 += ~(v221 >> 1);
            if (v227 < v220) {
              unint64_t v222 = v226;
            }
            else {
              unint64_t v221 = v224;
            }
          }
          while (v221);
          if (v222 == v223)
          {
            uint64_t v228 = 0;
            goto LABEL_270;
          }
          if (*v222 == v220)
          {
            uint64_t v228 = v222[1];
            goto LABEL_270;
          }
        }
        uint64_t v228 = 0;
LABEL_270:
        uint64_t v252 = mlir::DenseElementsAttr::getFromRawBuffer(v218, v228, v269[0], 8 * LODWORD(v269[1]), 8, 1, 0);
        uint64_t v108 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::anec::Resize &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v246, v245, v260, &v252);
        if (v269[0] != &v270) {
          free(v269[0]);
        }
        unint64_t IndexFromDim = v215;
        goto LABEL_273;
      }
LABEL_179:
      unint64_t v174 = 0;
      goto LABEL_183;
    }
    uint64_t v87 = "Shape operand was not a constant";
  }
  else
  {
    uint64_t v87 = "Resize layout not supported";
  }
  v275[0] = (void *)v87;
  LOWORD(v277) = 259;
  uint64_t v106 = v258;
  v269[0] = v275;
  uint64_t v107 = a4[2];
  if (v107 && mlir::RewriterBase::Listener::classof(a4[2])) {
    (*(void (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v107 + 64))(v107, *((void *)v106 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v269);
  }
  uint64_t v108 = 0;
  int v109 = 0;
LABEL_93:
  if (v291 != v293) {
    free(v291);
  }
  if (v294 != (mlir::Operation *)v296) {
    free(v294);
  }
  if (v109)
  {
    v275[0] = (char *)v108 - 16;
    uint64_t v110 = 1;
    mlir::ValueRange::ValueRange(v261, (uint64_t)v275, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)a2, v261[0], v261[1]);
  }
  else
  {
    v275[0] = "Conversion did not match a valid resize or a valid transformation supported by the hardware.";
    LOWORD(v277) = 259;
    v269[0] = v275;
    uint64_t v111 = a4[2];
    if (v111 && mlir::RewriterBase::Listener::classof(v111)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v111 + 64))(v111, *((void *)a2 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v269);
    }
    else {
      return 0;
    }
  }
  return v110;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)2>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Resize with custom scale and offset values not supported on ANE.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)2>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Resize alignCorners == centerResult == true is not supported on A14-class ANEs. \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)2>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported alignCorners, centerResult for Resize\n");
}

void *mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)3>::~ConvertResize(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)3>::~ConvertResize(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::mps *a2, long long *a3, uint64_t *a4)
{
  uint64_t v296 = *MEMORY[0x1E4F143B8];
  long long v5 = a3[5];
  long long v264 = a3[4];
  *(_OWORD *)long long v265 = v5;
  *(void *)&v265[16] = *((void *)a3 + 12);
  long long v6 = a3[1];
  long long v260 = *a3;
  long long v261 = v6;
  long long v7 = a3[3];
  long long v262 = a3[2];
  long long v263 = v7;
  uint64_t v256 = a2;
  long long v295 = *(_OWORD *)&v265[8];
  uint64_t v249 = *((void *)a2 + 3);
  uint64_t v255 = mlir::ValueRange::dereference_iterator(&v295, 0);
  uint64_t v8 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v256) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *v8;
  unint64_t v10 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v11 = *(unsigned int *)(v9 + 16);
  if (!v11) {
    goto LABEL_10;
  }
  unint64_t v12 = *(void **)(v9 + 8);
  uint64_t v13 = &v12[2 * v11];
  do
  {
    unint64_t v14 = v11 >> 1;
    unint64_t v15 = &v12[2 * (v11 >> 1)];
    unint64_t v17 = *v15;
    __int16 v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10) {
      unint64_t v12 = v16;
    }
    else {
      unint64_t v11 = v14;
    }
  }
  while (v11);
  if (v12 != v13 && *v12 == v10) {
    uint64_t v18 = v12[1];
  }
  else {
LABEL_10:
  }
    uint64_t v18 = 0;
  v254[0] = v8;
  v254[1] = v18;
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)&v260, 0);
  uint64_t v20 = *(void **)&v265[8];
  v273[0] = *(void **)&v265[8];
  v273[1] = (void *)ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    uint64_t v20 = (void *)mlir::ValueRange::offset_base(v273, ODSOperandIndexAndLength);
  }
  v273[0] = v20;
  v273[1] = 0;
  uint64_t v21 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v273, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v21) {
    goto LABEL_22;
  }
  uint64_t v22 = *v21;
  unint64_t v23 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v24 = *(unsigned int *)(v22 + 16);
  if (!v24) {
    goto LABEL_22;
  }
  unint64_t v25 = *(void **)(v22 + 8);
  uint64_t v26 = &v25[2 * v24];
  do
  {
    unint64_t v27 = v24 >> 1;
    unint64_t v28 = &v25[2 * (v24 >> 1)];
    unint64_t v30 = *v28;
    long long v29 = v28 + 2;
    v24 += ~(v24 >> 1);
    if (v30 < v23) {
      unint64_t v25 = v29;
    }
    else {
      unint64_t v24 = v27;
    }
  }
  while (v24);
  if (v25 != v26 && *v25 == v23) {
    unint64_t v31 = (void *)v25[1];
  }
  else {
LABEL_22:
  }
    unint64_t v31 = 0;
  v273[0] = v21;
  v273[1] = v31;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v273);
  unint64_t v33 = v32;
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(0, v32);
  unint64_t v35 = mlir::anec::getIndexFromDim(1, v33);
  unint64_t v36 = mlir::anec::getIndexFromDim(3, v33);
  unint64_t v37 = mlir::anec::getIndexFromDim(4, v33);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v254);
  if (v38 <= 3)
  {
    v273[0] = &v274;
    *(void *)&long long v274 = IndexFromDim;
    *((void *)&v274 + 1) = v35;
    *(void *)&long long v275 = v35;
    *((void *)&v275 + 1) = v36;
    *(void *)&long long v276 = v36;
    *((void *)&v276 + 1) = IndexFromDim;
    v273[1] = (void *)0x600000006;
    *(_OWORD *)v267 = xmmword_181110B40;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    uint64_t v40 = (void *)mlir::RankedTensorType::get((uint64_t)v267, 2, IntegerType, 0);
    uint64_t v41 = v40;
    if (!v40) {
      goto LABEL_33;
    }
    uint64_t v42 = *v40;
    unint64_t v43 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v44 = *(unsigned int *)(v42 + 16);
    if (!v44) {
      goto LABEL_33;
    }
    int64x2_t v45 = *(void **)(v42 + 8);
    uint64_t v46 = &v45[2 * v44];
    do
    {
      unint64_t v47 = v44 >> 1;
      uint64_t v48 = &v45[2 * (v44 >> 1)];
      unint64_t v50 = *v48;
      uint64_t v49 = v48 + 2;
      v44 += ~(v44 >> 1);
      if (v50 < v43) {
        int64x2_t v45 = v49;
      }
      else {
        unint64_t v44 = v47;
      }
    }
    while (v44);
    if (v45 != v46 && *v45 == v43) {
      uint64_t v51 = v45[1];
    }
    else {
LABEL_33:
    }
      uint64_t v51 = 0;
    uint64_t v292 = (mlir::Operation *)mlir::DenseElementsAttr::getFromRawBuffer(v41, v51, v273[0], 8 * LODWORD(v273[1]), 8, 1, 0);
    uint64_t v255 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v249, &v255, (uint64_t *)&v292)- 16;
    if (v273[0] != &v274) {
      free(v273[0]);
    }
  }
  unint64_t v52 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v256) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v52) {
    goto LABEL_45;
  }
  uint64_t v53 = *v52;
  unint64_t v54 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v55 = *(unsigned int *)(v53 + 16);
  if (!v55) {
    goto LABEL_45;
  }
  int64x2_t v56 = *(void **)(v53 + 8);
  uint64_t v57 = &v56[2 * v55];
  do
  {
    unint64_t v58 = v55 >> 1;
    unint64_t v59 = &v56[2 * (v55 >> 1)];
    unint64_t v61 = *v59;
    uint64_t v60 = v59 + 2;
    v55 += ~(v55 >> 1);
    if (v61 < v54) {
      int64x2_t v56 = v60;
    }
    else {
      unint64_t v55 = v58;
    }
  }
  while (v55);
  if (v56 != v57 && *v56 == v54) {
    uint64_t v62 = v56[1];
  }
  else {
LABEL_45:
  }
    uint64_t v62 = 0;
  v253[0] = v52;
  v253[1] = v62;
  uint64_t ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v253);
  uint64_t v65 = v63;
  uint64_t v292 = (mlir::Operation *)v294;
  uint64_t v293 = 0x400000000;
  size_t v66 = 8 * v63;
  if ((unint64_t)(8 * v63) < 0x21)
  {
    unsigned int v67 = 0;
    uint64_t v68 = (mlir::Operation *)v294;
    if (!v65) {
      goto LABEL_51;
    }
    goto LABEL_50;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v292, v294, (8 * v63) >> 3, 8);
  unsigned int v67 = v293;
  uint64_t v68 = v292;
  if (v65)
  {
LABEL_50:
    memcpy((char *)v68 + 8 * v67, ArgAttrsAttr, v66);
    unsigned int v67 = v293;
    uint64_t v68 = v292;
  }
LABEL_51:
  unsigned int v69 = v67 + (v66 >> 3);
  LODWORD(v293) = v69;
  if (v69 <= 3)
  {
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v292, (uint64_t)v68, 4 - v69, 1uLL);
    uint64_t v68 = v292;
  }
  uint64_t v70 = *((void *)v68 + v36);
  uint64_t v71 = *((void *)v68 + v37);
  uint64_t v289 = v291;
  v291[0] = v70;
  v291[1] = v71;
  uint64_t v290 = 0x200000002;
  uint64_t ResizeLayout = mlir::mps::getResizeLayout(v256, v68);
  if ((ResizeLayout & 0xFF00000000) == 0)
  {
    uint64_t v87 = "Resize layout not supported";
    goto LABEL_87;
  }
  uint64_t v73 = ResizeLayout;
  if (ResizeLayout == 1)
  {
    v273[0] = &v274;
    *(void *)&long long v274 = v35;
    *((void *)&v274 + 1) = v36;
    *(void *)&long long v275 = v36;
    *((void *)&v275 + 1) = v37;
    *(void *)&long long v276 = v37;
    *((void *)&v276 + 1) = v35;
    v273[1] = (void *)0x600000006;
    *(_OWORD *)v267 = xmmword_181110B40;
    uint64_t v74 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    uint64_t v75 = (void *)mlir::RankedTensorType::get((uint64_t)v267, 2, v74, 0);
    uint64_t v76 = v75;
    if (v75)
    {
      uint64_t v77 = *v75;
      unint64_t v78 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v79 = *(unsigned int *)(v77 + 16);
      if (v79)
      {
        uint64_t v80 = *(void **)(v77 + 8);
        unsigned int v81 = &v80[2 * v79];
        do
        {
          unint64_t v82 = v79 >> 1;
          uint64_t v83 = &v80[2 * (v79 >> 1)];
          unint64_t v85 = *v83;
          uint64_t v84 = v83 + 2;
          v79 += ~(v79 >> 1);
          if (v85 < v78) {
            uint64_t v80 = v84;
          }
          else {
            unint64_t v79 = v82;
          }
        }
        while (v79);
        uint64_t v73 = 1;
        if (v80 == v81 || *v80 != v78) {
          goto LABEL_64;
        }
        uint64_t v86 = v80[1];
      }
      else
      {
        uint64_t v86 = 0;
        uint64_t v73 = 1;
      }
LABEL_72:
      uint64_t v286 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v76, v86, v273[0], 8 * LODWORD(v273[1]), 8, 1, 0);
      uint64_t v255 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v249, &v255, (uint64_t *)&v286)- 16;
      unint64_t v88 = v292;
      uint64_t v89 = v289;
      void *v289 = *((void *)v292 + v35);
      v89[1] = *((void *)v88 + v36);
      if (v273[0] != &v274) {
        free(v273[0]);
      }
      goto LABEL_74;
    }
LABEL_64:
    uint64_t v86 = 0;
    goto LABEL_72;
  }
LABEL_74:
  v252[0] = 0;
  v252[1] = 0;
  Shape = (void *)mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v256);
  v267[0] = v252;
  v273[0] = Shape;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v273);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)v267, DefiningOp))
  {
    uint64_t v244 = v73;
    unint64_t v246 = IndexFromDim;
    uint64_t v286 = v288;
    v288[0] = 0;
    v288[1] = 0;
    uint64_t v287 = 0x200000002;
    uint64_t v283 = v285;
    memset_pattern16(v285, &unk_1810FE350, 0x10uLL);
    uint64_t v284 = 0x200000002;
    int GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v256);
    v273[0] = (void *)2;
    uint64_t v245 = (mlir::Builder *)(a4 + 1);
    uint64_t v93 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    uint64_t v94 = (void *)mlir::RankedTensorType::get((uint64_t)v273, 1, v93, 0);
    uint64_t v95 = v94;
    if (v94)
    {
      unint64_t v96 = v37;
      uint64_t v97 = *v94;
      unint64_t v98 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v99 = *(unsigned int *)(v97 + 16);
      if (v99)
      {
        uint64_t v100 = *(void **)(v97 + 8);
        unint64_t v101 = &v100[2 * v99];
        do
        {
          unint64_t v102 = v99 >> 1;
          uint64_t v103 = &v100[2 * (v99 >> 1)];
          unint64_t v105 = *v103;
          unint64_t v104 = v103 + 2;
          v99 += ~(v99 >> 1);
          if (v105 < v98) {
            uint64_t v100 = v104;
          }
          else {
            unint64_t v99 = v102;
          }
        }
        while (v99);
        unint64_t v37 = v96;
        if (v100 == v101)
        {
          uint64_t v106 = 0;
        }
        else if (*v100 == v98)
        {
          uint64_t v106 = v100[1];
        }
        else
        {
          uint64_t v106 = 0;
        }
      }
      else
      {
        uint64_t v106 = 0;
        unint64_t v37 = v96;
      }
    }
    else
    {
      uint64_t v106 = 0;
    }
    if (GateLayout == 1) {
      char v114 = (void **)&v286;
    }
    else {
      char v114 = &v283;
    }
    uint64_t v115 = *v114;
    uint64_t v116 = &v287;
    if (GateLayout != 1) {
      uint64_t v116 = &v284;
    }
    uint64_t v251 = mlir::DenseElementsAttr::getFromRawBuffer(v95, v106, v115, 8 * *(unsigned int *)v116, 8, 1, 0);
    __dst = v282;
    uint64_t v281 = 0x200000000;
    BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v256);
    BOOL IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v256);
    unint64_t v243 = v37;
    if (mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v256)
      || mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v256))
    {
      long long v277 = v264;
      long long v278 = *(_OWORD *)v265;
      *(void *)long long v279 = *(void *)&v265[16];
      *(_OWORD *)unint64_t v273 = v260;
      long long v274 = v261;
      long long v275 = v262;
      long long v276 = v263;
      v258[0] = v256;
      uint64_t v120 = mlir::mps::getResizeLayout(v256, v119);
      if ((v120 & 0xFF00000000) == 0) {
        goto LABEL_211;
      }
      uint64_t v121 = 8 * (int)v120;
      unint64_t v122 = *(void *)((char *)&unk_181110CB0 + v121);
      uint64_t v123 = *(void *)((char *)&unk_181110CE8 + v121);
      unint64_t v124 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 2u);
      uint64_t v125 = (void *)*((void *)&v278 + 1);
      v267[0] = *((void **)&v278 + 1);
      v267[1] = (void *)v124;
      if (v124)
      {
        uint64_t v125 = (void *)mlir::ValueRange::offset_base(v267, v124);
        unint64_t v126 = v267[1];
      }
      else
      {
        unint64_t v126 = 0;
      }
      if ((void *)(HIDWORD(v124) + v124) == v126
        || (v267[0] = v125, v267[1] = 0, !mlir::ValueRange::dereference_iterator(v267, 0)))
      {
        float v130 = 1.0;
        float v131 = 1.0;
      }
      else
      {
        *(_OWORD *)long long v266 = 0uLL;
        unint64_t v127 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 2u);
        uint64_t v128 = (void *)*((void *)&v278 + 1);
        v267[0] = *((void **)&v278 + 1);
        v267[1] = (void *)v127;
        if (v127)
        {
          uint64_t v128 = (void *)mlir::ValueRange::offset_base(v267, v127);
          float v129 = v267[1];
        }
        else
        {
          float v129 = 0;
        }
        if ((void *)(HIDWORD(v127) + v127) == v129)
        {
          BOOL v185 = 0;
        }
        else
        {
          v267[0] = v128;
          v267[1] = 0;
          BOOL v185 = (void *)mlir::ValueRange::dereference_iterator(v267, 0);
        }
        uint64_t v257 = (uint64_t **)v266;
        v267[0] = v185;
        uint64_t v186 = mlir::Value::getDefiningOp((mlir::Value *)v267);
        if (!v186 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v257, v186)) {
          goto LABEL_211;
        }
        v267[0] = &v268;
        v267[1] = (void *)0x400000000;
        mlir::getIntValues<float>(v266[0], v266[1], (uint64_t)v267, 1);
        unint64_t v187 = LODWORD(v267[1]);
        float v130 = 1.0;
        float v131 = 1.0;
        if (v122 < LODWORD(v267[1]))
        {
          float v131 = *((float *)v267[0] + v122);
          float v130 = *((float *)v267[0] + v123);
        }
        if (v267[0] != &v268) {
          free(v267[0]);
        }
        if (v122 >= v187) {
          goto LABEL_211;
        }
      }
      unint64_t v132 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 3u);
      unint64_t v133 = (void *)*((void *)&v278 + 1);
      v267[0] = *((void **)&v278 + 1);
      v267[1] = (void *)v132;
      if (v132)
      {
        unint64_t v133 = (void *)mlir::ValueRange::offset_base(v267, v132);
        unint64_t v134 = v267[1];
      }
      else
      {
        unint64_t v134 = 0;
      }
      if ((void *)(HIDWORD(v132) + v132) == v134
        || (v267[0] = v133, v267[1] = 0, !mlir::ValueRange::dereference_iterator(v267, 0)))
      {
        float v138 = 0.0;
        float v139 = 0.0;
      }
      else
      {
        *(_OWORD *)long long v266 = 0uLL;
        unint64_t v135 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 3u);
        unint64_t v136 = (void *)*((void *)&v278 + 1);
        v267[0] = *((void **)&v278 + 1);
        v267[1] = (void *)v135;
        if (v135)
        {
          unint64_t v136 = (void *)mlir::ValueRange::offset_base(v267, v135);
          float v137 = v267[1];
        }
        else
        {
          float v137 = 0;
        }
        if ((void *)(HIDWORD(v135) + v135) == v137)
        {
          uint64_t v190 = 0;
        }
        else
        {
          v267[0] = v136;
          v267[1] = 0;
          uint64_t v190 = (void *)mlir::ValueRange::dereference_iterator(v267, 0);
        }
        uint64_t v257 = (uint64_t **)v266;
        v267[0] = v190;
        uint64_t v191 = mlir::Value::getDefiningOp((mlir::Value *)v267);
        if (!v191 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v257, v191)) {
          goto LABEL_211;
        }
        v267[0] = &v268;
        v267[1] = (void *)0x400000000;
        mlir::getIntValues<float>(v266[0], v266[1], (uint64_t)v267, 1);
        unint64_t v192 = LODWORD(v267[1]);
        float v138 = 0.0;
        float v139 = 0.0;
        if (v122 < LODWORD(v267[1]))
        {
          float v139 = *((float *)v267[0] + v122);
          float v138 = *((float *)v267[0] + v123);
        }
        if (v267[0] != &v268) {
          free(v267[0]);
        }
        if (v122 >= v192) {
          goto LABEL_211;
        }
      }
      unsigned int v140 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 0);
      long long v141 = (void *)*((void *)&v278 + 1);
      v267[0] = *((void **)&v278 + 1);
      v267[1] = (void *)v140;
      if (v140) {
        long long v141 = (void *)mlir::ValueRange::offset_base(v267, v140);
      }
      v267[0] = v141;
      v267[1] = 0;
      uint64_t v142 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v267, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v142) {
        goto LABEL_141;
      }
      uint64_t v143 = *v142;
      unint64_t v144 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v145 = *(unsigned int *)(v143 + 16);
      if (!v145) {
        goto LABEL_141;
      }
      long long v146 = *(void **)(v143 + 8);
      unint64_t v147 = &v146[2 * v145];
      do
      {
        unint64_t v148 = v145 >> 1;
        uint64_t v149 = &v146[2 * (v145 >> 1)];
        unint64_t v151 = *v149;
        unint64_t v150 = v149 + 2;
        v145 += ~(v145 >> 1);
        if (v151 < v144) {
          long long v146 = v150;
        }
        else {
          unint64_t v145 = v148;
        }
      }
      while (v145);
      if (v146 != v147 && *v146 == v144) {
        uint64_t v152 = (void *)v146[1];
      }
      else {
LABEL_141:
      }
        uint64_t v152 = 0;
      v267[0] = v142;
      v267[1] = v152;
      uint64_t v153 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v267);
      unint64_t v155 = v154;
      uint64_t v156 = *(void *)(a1 + 96);
      uint64_t v157 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v258);
      uint64_t v158 = (uint64_t *)mlir::TypeConverter::convertType(v156, (void *)(*(void *)(v157 + 8) & 0xFFFFFFFFFFFFFFF8));
      unint64_t v159 = v158;
      if (!v158) {
        goto LABEL_151;
      }
      uint64_t v160 = *v158;
      unint64_t v161 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v162 = *(unsigned int *)(v160 + 16);
      if (!v162) {
        goto LABEL_151;
      }
      unint64_t v163 = *(void **)(v160 + 8);
      v164 = &v163[2 * v162];
      do
      {
        unint64_t v165 = v162 >> 1;
        unint64_t v166 = &v163[2 * (v162 >> 1)];
        unint64_t v168 = *v166;
        unint64_t v167 = v166 + 2;
        v162 += ~(v162 >> 1);
        if (v168 < v161) {
          unint64_t v163 = v167;
        }
        else {
          unint64_t v162 = v165;
        }
      }
      while (v162);
      if (v163 != v164 && *v163 == v161) {
        uint64_t v169 = (void *)v163[1];
      }
      else {
LABEL_151:
      }
        uint64_t v169 = 0;
      v267[0] = v159;
      v267[1] = v169;
      uint64_t v170 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v267);
      unint64_t v172 = v171;
      unint64_t v173 = mlir::anec::getIndexFromDim(3, v155);
      unint64_t v174 = mlir::anec::getIndexFromDim(4, v172);
      float v175 = (float)*(uint64_t *)(v153 + 8 * v173);
      float v176 = (float)*(uint64_t *)(v153 + 8 * v174);
      float v177 = (float)*(uint64_t *)(v170 + 8 * v173);
      float v178 = (float)*(uint64_t *)(v170 + 8 * v174);
      BOOL v179 = v139 != 0.0;
      if (v138 != 0.0) {
        BOOL v179 = 1;
      }
      BOOL v180 = (v131 + -1.0) * 0.5 != v139 || (v130 + -1.0) * 0.5 != v138;
      BOOL v181 = v131 != (float)(v177 / v175) || v130 != (float)(v178 / v176);
      BOOL v182 = v131 != (float)((float)(v177 + -1.0) / (float)(v175 + -1.0))
          || v130 != (float)((float)(v178 + -1.0) / (float)(v176 + -1.0));
      if (v179 || v181)
      {
        if (v179 || v182)
        {
          if (!v180 && !v181)
          {
            BOOL InferredResultTypes = 0;
            BOOL IsSize = 1;
            goto LABEL_172;
          }
LABEL_211:
          uint64_t v193 = a4[2];
          if (v193)
          {
            uint64_t v194 = v256;
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
          }
            }
          int v109 = 0;
          int v110 = 0;
LABEL_215:
          if (__dst != v282) {
            free(__dst);
          }
          if (v283 != v285) {
            free(v283);
          }
          if (v286 != v288) {
            free(v286);
          }
          goto LABEL_91;
        }
        BOOL IsSize = 1;
        BOOL InferredResultTypes = 1;
LABEL_169:
        if (IsSize)
        {
          v267[0] = &v268;
          long long v268 = 0uLL;
LABEL_178:
          v267[1] = (void *)0x600000002;
          uint64_t v184 = v281;
          if (v281 >= 2)
          {
            *(_OWORD *)__dst = v268;
          }
          else
          {
            if (HIDWORD(v281) > 1)
            {
              if (v281) {
                memmove(__dst, &v268, 8 * v281);
              }
              else {
                uint64_t v184 = 0;
              }
            }
            else
            {
              LODWORD(v281) = 0;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v282, 2uLL, 8);
              uint64_t v184 = 0;
            }
            if (v184 != LODWORD(v267[1])) {
              memcpy((char *)__dst + 8 * v184, (char *)v267[0] + 8 * v184, 8 * LODWORD(v267[1]) - 8 * v184);
            }
          }
          LODWORD(v281) = 2;
          LODWORD(v267[1]) = 0;
          if (v267[0] != &v268) {
            free(v267[0]);
          }
          v267[0] = (void *)2;
          uint64_t v195 = mlir::Builder::getIntegerType(v245, 0x40u, 0);
          uint64_t v196 = (void *)mlir::RankedTensorType::get((uint64_t)v267, 1, v195, 0);
          unint64_t v197 = v196;
          if (!v196) {
            goto LABEL_235;
          }
          uint64_t v198 = *v196;
          unint64_t v199 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v200 = *(unsigned int *)(v198 + 16);
          if (!v200) {
            goto LABEL_235;
          }
          unint64_t v201 = *(void **)(v198 + 8);
          unint64_t v202 = &v201[2 * v200];
          do
          {
            unint64_t v203 = v200 >> 1;
            unint64_t v204 = &v201[2 * (v200 >> 1)];
            unint64_t v206 = *v204;
            unint64_t v205 = v204 + 2;
            v200 += ~(v200 >> 1);
            if (v206 < v199) {
              unint64_t v201 = v205;
            }
            else {
              unint64_t v200 = v203;
            }
          }
          while (v200);
          if (v201 != v202 && *v201 == v199) {
            uint64_t v207 = v201[1];
          }
          else {
LABEL_235:
          }
            uint64_t v207 = 0;
          uint64_t v257 = (uint64_t **)mlir::DenseElementsAttr::getFromRawBuffer(v197, v207, __dst, 8 * v281, 8, 1, 0);
          uint64_t v208 = v289;
          uint64_t v209 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v266, -1.0);
          uint64_t v210 = llvm::APFloatBase::IEEEsingle(v209);
          llvm::APFloat::Storage::Storage(&v267[1], v266, v210);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v266);
          llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v258, -1.0);
          llvm::APFloat::Storage::Storage(&v266[1], v258, v210);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v258);
          v258[0] = mlir::OpBuilder::create<mlir::anec::Resize,mlir::Value &,unsigned long long &,unsigned long long &,llvm::APFloat,llvm::APFloat,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(v245, v249, &v255, v208, v208 + 1, (uint64_t)v267, (uint64_t)v266, &v251, (uint64_t *)&v257);
          v211 = (void *)v266[1];
          uint64_t v212 = llvm::APFloatBase::PPCDoubleDouble(v258[0]);
          if (v212 == v211) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v266[1]);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v266[1]);
          }
          if (v212 == v267[1]) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v267[1]);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v267[1]);
          }
          char v213 = mlir::anec::Resize::verifyAttributesWithFamily((uint64_t *)v258, 3);
          int v109 = v258[0];
          if (v213)
          {
            if (v244 == 1)
            {
              v267[0] = &v268;
              *(void *)&long long v268 = v35;
              *((void *)&v268 + 1) = v243;
              unint64_t v269 = v36;
              unint64_t v270 = v35;
              unint64_t v271 = v243;
              unint64_t v272 = v36;
              v267[1] = (void *)0x600000006;
              *(_OWORD *)long long v266 = xmmword_181110B40;
              uint64_t v214 = mlir::Builder::getIntegerType(v245, 0x40u, 0);
              unint64_t v215 = (void *)mlir::RankedTensorType::get((uint64_t)v266, 2, v214, 0);
              uint64_t v216 = v215;
              if (!v215) {
                goto LABEL_253;
              }
              uint64_t v217 = *v215;
              unint64_t v218 = mlir::TypeID::get<mlir::ShapedType>();
              unint64_t v219 = *(unsigned int *)(v217 + 16);
              if (!v219) {
                goto LABEL_253;
              }
              unint64_t v220 = *(void **)(v217 + 8);
              unint64_t v221 = &v220[2 * v219];
              do
              {
                unint64_t v222 = v219 >> 1;
                unint64_t v223 = &v220[2 * (v219 >> 1)];
                unint64_t v225 = *v223;
                unint64_t v224 = v223 + 2;
                v219 += ~(v219 >> 1);
                if (v225 < v218) {
                  unint64_t v220 = v224;
                }
                else {
                  unint64_t v219 = v222;
                }
              }
              while (v219);
              if (v220 != v221 && *v220 == v218) {
                uint64_t v226 = v220[1];
              }
              else {
LABEL_253:
              }
                uint64_t v226 = 0;
              uint64_t v250 = mlir::DenseElementsAttr::getFromRawBuffer(v216, v226, v267[0], 8 * LODWORD(v267[1]), 8, 1, 0);
              int v109 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::anec::Resize &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v245, v249, v258, &v250);
              if (v267[0] != &v268) {
                free(v267[0]);
              }
            }
            mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v254);
            if (v227 > 3)
            {
              int v110 = 1;
            }
            else
            {
              v267[0] = &v268;
              *(void *)&long long v268 = v35;
              *((void *)&v268 + 1) = v246;
              unint64_t v269 = v36;
              unint64_t v270 = v35;
              unint64_t v271 = v246;
              unint64_t v272 = v36;
              v267[1] = (void *)0x600000006;
              *(_OWORD *)long long v266 = xmmword_181110B40;
              uint64_t v228 = mlir::Builder::getIntegerType(v245, 0x40u, 0);
              unint64_t v229 = (void *)mlir::RankedTensorType::get((uint64_t)v266, 2, v228, 0);
              uint64_t v230 = v229;
              if (v229
                && (uint64_t v231 = *v229,
                    unint64_t v232 = mlir::TypeID::get<mlir::ShapedType>(),
                    unint64_t v233 = *(unsigned int *)(v231 + 16),
                    v233))
              {
                v234 = *(void **)(v231 + 8);
                uint64_t v235 = &v234[2 * v233];
                do
                {
                  unint64_t v236 = v233 >> 1;
                  unint64_t v237 = &v234[2 * (v233 >> 1)];
                  unint64_t v239 = *v237;
                  v238 = v237 + 2;
                  v233 += ~(v233 >> 1);
                  if (v239 < v232) {
                    v234 = v238;
                  }
                  else {
                    unint64_t v233 = v236;
                  }
                }
                while (v233);
                if (v234 != v235 && *v234 == v232) {
                  uint64_t v240 = v234[1];
                }
                else {
                  uint64_t v240 = 0;
                }
              }
              else
              {
                uint64_t v240 = 0;
              }
              uint64_t v250 = mlir::DenseElementsAttr::getFromRawBuffer(v230, v240, v267[0], 8 * LODWORD(v267[1]), 8, 1, 0);
              v266[0] = (uint64_t)v109 - 16;
              int v109 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v245, v249, v266, &v250);
              if (v267[0] != &v268) {
                free(v267[0]);
              }
              int v110 = 1;
            }
          }
          else
          {
            mlir::ConversionPatternRewriter::eraseOp((mlir::ConversionPatternRewriter *)a4, v258[0]);
            v267[0] = "requested attributes are not compatible with hardware requirements";
            LOWORD(v269) = 259;
            uint64_t v241 = v256;
            v266[0] = (uint64_t)v267;
            uint64_t v242 = a4[2];
            if (v242 && mlir::RewriterBase::Listener::classof(a4[2])) {
              (*(void (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(void *)v242 + 64))(v242, *((void *)v241 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v266);
            }
            int v109 = 0;
            int v110 = 0;
          }
          goto LABEL_215;
        }
LABEL_172:
        if (InferredResultTypes || IsSize)
        {
          if (InferredResultTypes || !IsSize)
          {
            uint64_t v188 = a4[2];
            if (v188)
            {
              unint64_t v189 = v256;
              if (mlir::RewriterBase::Listener::classof(a4[2])) {
            }
              }
            int v109 = 0;
            int v110 = 0;
            goto LABEL_215;
          }
          v267[0] = &v268;
          float v183 = &unk_1810FE350;
        }
        else
        {
          v267[0] = &v268;
          float v183 = &unk_181110BA0;
        }
        memset_pattern16(&v268, v183, 0x10uLL);
        goto LABEL_178;
      }
      BOOL IsSize = 0;
      BOOL InferredResultTypes = 0;
    }
    if (!InferredResultTypes) {
      goto LABEL_172;
    }
    goto LABEL_169;
  }
  uint64_t v87 = "Shape operand was not a constant";
LABEL_87:
  v273[0] = (void *)v87;
  LOWORD(v275) = 259;
  uint64_t v107 = v256;
  v267[0] = v273;
  uint64_t v108 = a4[2];
  if (v108 && mlir::RewriterBase::Listener::classof(a4[2])) {
    (*(void (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v108 + 64))(v108, *((void *)v107 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v267);
  }
  int v109 = 0;
  int v110 = 0;
LABEL_91:
  if (v289 != v291) {
    free(v289);
  }
  if (v292 != (mlir::Operation *)v294) {
    free(v292);
  }
  if (v110)
  {
    v273[0] = (char *)v109 - 16;
    uint64_t v111 = 1;
    mlir::ValueRange::ValueRange(v259, (uint64_t)v273, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)a2, v259[0], v259[1]);
  }
  else
  {
    v273[0] = "Conversion did not match a valid resize or a valid transformation supported by the hardware.";
    LOWORD(v275) = 259;
    v267[0] = v273;
    uint64_t v112 = a4[2];
    if (v112 && mlir::RewriterBase::Listener::classof(v112)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v112 + 64))(v112, *((void *)a2 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v267);
    }
    else {
      return 0;
    }
  }
  return v111;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)3>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Resize with custom scale and offset values not supported on ANE.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)3>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported alignCorners, centerResult for Resize\n");
}

void *mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)4>::~ConvertResize(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)4>::~ConvertResize(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::mps *a2, long long *a3, uint64_t *a4)
{
  uint64_t v296 = *MEMORY[0x1E4F143B8];
  long long v5 = a3[5];
  long long v264 = a3[4];
  *(_OWORD *)long long v265 = v5;
  *(void *)&v265[16] = *((void *)a3 + 12);
  long long v6 = a3[1];
  long long v260 = *a3;
  long long v261 = v6;
  long long v7 = a3[3];
  long long v262 = a3[2];
  long long v263 = v7;
  uint64_t v256 = a2;
  long long v295 = *(_OWORD *)&v265[8];
  uint64_t v249 = *((void *)a2 + 3);
  uint64_t v255 = mlir::ValueRange::dereference_iterator(&v295, 0);
  uint64_t v8 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v256) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *v8;
  unint64_t v10 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v11 = *(unsigned int *)(v9 + 16);
  if (!v11) {
    goto LABEL_10;
  }
  unint64_t v12 = *(void **)(v9 + 8);
  uint64_t v13 = &v12[2 * v11];
  do
  {
    unint64_t v14 = v11 >> 1;
    unint64_t v15 = &v12[2 * (v11 >> 1)];
    unint64_t v17 = *v15;
    __int16 v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10) {
      unint64_t v12 = v16;
    }
    else {
      unint64_t v11 = v14;
    }
  }
  while (v11);
  if (v12 != v13 && *v12 == v10) {
    uint64_t v18 = v12[1];
  }
  else {
LABEL_10:
  }
    uint64_t v18 = 0;
  v254[0] = v8;
  v254[1] = v18;
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)&v260, 0);
  uint64_t v20 = *(void **)&v265[8];
  v273[0] = *(void **)&v265[8];
  v273[1] = (void *)ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    uint64_t v20 = (void *)mlir::ValueRange::offset_base(v273, ODSOperandIndexAndLength);
  }
  v273[0] = v20;
  v273[1] = 0;
  uint64_t v21 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v273, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v21) {
    goto LABEL_22;
  }
  uint64_t v22 = *v21;
  unint64_t v23 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v24 = *(unsigned int *)(v22 + 16);
  if (!v24) {
    goto LABEL_22;
  }
  unint64_t v25 = *(void **)(v22 + 8);
  uint64_t v26 = &v25[2 * v24];
  do
  {
    unint64_t v27 = v24 >> 1;
    unint64_t v28 = &v25[2 * (v24 >> 1)];
    unint64_t v30 = *v28;
    long long v29 = v28 + 2;
    v24 += ~(v24 >> 1);
    if (v30 < v23) {
      unint64_t v25 = v29;
    }
    else {
      unint64_t v24 = v27;
    }
  }
  while (v24);
  if (v25 != v26 && *v25 == v23) {
    unint64_t v31 = (void *)v25[1];
  }
  else {
LABEL_22:
  }
    unint64_t v31 = 0;
  v273[0] = v21;
  v273[1] = v31;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v273);
  unint64_t v33 = v32;
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(0, v32);
  unint64_t v35 = mlir::anec::getIndexFromDim(1, v33);
  unint64_t v36 = mlir::anec::getIndexFromDim(3, v33);
  unint64_t v37 = mlir::anec::getIndexFromDim(4, v33);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v254);
  if (v38 <= 3)
  {
    v273[0] = &v274;
    *(void *)&long long v274 = IndexFromDim;
    *((void *)&v274 + 1) = v35;
    *(void *)&long long v275 = v35;
    *((void *)&v275 + 1) = v36;
    *(void *)&long long v276 = v36;
    *((void *)&v276 + 1) = IndexFromDim;
    v273[1] = (void *)0x600000006;
    *(_OWORD *)v267 = xmmword_181110B40;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    uint64_t v40 = (void *)mlir::RankedTensorType::get((uint64_t)v267, 2, IntegerType, 0);
    uint64_t v41 = v40;
    if (!v40) {
      goto LABEL_33;
    }
    uint64_t v42 = *v40;
    unint64_t v43 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v44 = *(unsigned int *)(v42 + 16);
    if (!v44) {
      goto LABEL_33;
    }
    int64x2_t v45 = *(void **)(v42 + 8);
    uint64_t v46 = &v45[2 * v44];
    do
    {
      unint64_t v47 = v44 >> 1;
      uint64_t v48 = &v45[2 * (v44 >> 1)];
      unint64_t v50 = *v48;
      uint64_t v49 = v48 + 2;
      v44 += ~(v44 >> 1);
      if (v50 < v43) {
        int64x2_t v45 = v49;
      }
      else {
        unint64_t v44 = v47;
      }
    }
    while (v44);
    if (v45 != v46 && *v45 == v43) {
      uint64_t v51 = v45[1];
    }
    else {
LABEL_33:
    }
      uint64_t v51 = 0;
    uint64_t v292 = (mlir::Operation *)mlir::DenseElementsAttr::getFromRawBuffer(v41, v51, v273[0], 8 * LODWORD(v273[1]), 8, 1, 0);
    uint64_t v255 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v249, &v255, (uint64_t *)&v292)- 16;
    if (v273[0] != &v274) {
      free(v273[0]);
    }
  }
  unint64_t v52 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v256) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v52) {
    goto LABEL_45;
  }
  uint64_t v53 = *v52;
  unint64_t v54 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v55 = *(unsigned int *)(v53 + 16);
  if (!v55) {
    goto LABEL_45;
  }
  int64x2_t v56 = *(void **)(v53 + 8);
  uint64_t v57 = &v56[2 * v55];
  do
  {
    unint64_t v58 = v55 >> 1;
    unint64_t v59 = &v56[2 * (v55 >> 1)];
    unint64_t v61 = *v59;
    uint64_t v60 = v59 + 2;
    v55 += ~(v55 >> 1);
    if (v61 < v54) {
      int64x2_t v56 = v60;
    }
    else {
      unint64_t v55 = v58;
    }
  }
  while (v55);
  if (v56 != v57 && *v56 == v54) {
    uint64_t v62 = v56[1];
  }
  else {
LABEL_45:
  }
    uint64_t v62 = 0;
  v253[0] = v52;
  v253[1] = v62;
  uint64_t ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v253);
  uint64_t v65 = v63;
  uint64_t v292 = (mlir::Operation *)v294;
  uint64_t v293 = 0x400000000;
  size_t v66 = 8 * v63;
  if ((unint64_t)(8 * v63) < 0x21)
  {
    unsigned int v67 = 0;
    uint64_t v68 = (mlir::Operation *)v294;
    if (!v65) {
      goto LABEL_51;
    }
    goto LABEL_50;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v292, v294, (8 * v63) >> 3, 8);
  unsigned int v67 = v293;
  uint64_t v68 = v292;
  if (v65)
  {
LABEL_50:
    memcpy((char *)v68 + 8 * v67, ArgAttrsAttr, v66);
    unsigned int v67 = v293;
    uint64_t v68 = v292;
  }
LABEL_51:
  unsigned int v69 = v67 + (v66 >> 3);
  LODWORD(v293) = v69;
  if (v69 <= 3)
  {
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v292, (uint64_t)v68, 4 - v69, 1uLL);
    uint64_t v68 = v292;
  }
  uint64_t v70 = *((void *)v68 + v36);
  uint64_t v71 = *((void *)v68 + v37);
  uint64_t v289 = v291;
  v291[0] = v70;
  v291[1] = v71;
  uint64_t v290 = 0x200000002;
  uint64_t ResizeLayout = mlir::mps::getResizeLayout(v256, v68);
  if ((ResizeLayout & 0xFF00000000) == 0)
  {
    uint64_t v87 = "Resize layout not supported";
    goto LABEL_87;
  }
  uint64_t v73 = ResizeLayout;
  if (ResizeLayout == 1)
  {
    v273[0] = &v274;
    *(void *)&long long v274 = v35;
    *((void *)&v274 + 1) = v36;
    *(void *)&long long v275 = v36;
    *((void *)&v275 + 1) = v37;
    *(void *)&long long v276 = v37;
    *((void *)&v276 + 1) = v35;
    v273[1] = (void *)0x600000006;
    *(_OWORD *)v267 = xmmword_181110B40;
    uint64_t v74 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    uint64_t v75 = (void *)mlir::RankedTensorType::get((uint64_t)v267, 2, v74, 0);
    uint64_t v76 = v75;
    if (v75)
    {
      uint64_t v77 = *v75;
      unint64_t v78 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v79 = *(unsigned int *)(v77 + 16);
      if (v79)
      {
        uint64_t v80 = *(void **)(v77 + 8);
        unsigned int v81 = &v80[2 * v79];
        do
        {
          unint64_t v82 = v79 >> 1;
          uint64_t v83 = &v80[2 * (v79 >> 1)];
          unint64_t v85 = *v83;
          uint64_t v84 = v83 + 2;
          v79 += ~(v79 >> 1);
          if (v85 < v78) {
            uint64_t v80 = v84;
          }
          else {
            unint64_t v79 = v82;
          }
        }
        while (v79);
        uint64_t v73 = 1;
        if (v80 == v81 || *v80 != v78) {
          goto LABEL_64;
        }
        uint64_t v86 = v80[1];
      }
      else
      {
        uint64_t v86 = 0;
        uint64_t v73 = 1;
      }
LABEL_72:
      uint64_t v286 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v76, v86, v273[0], 8 * LODWORD(v273[1]), 8, 1, 0);
      uint64_t v255 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v249, &v255, (uint64_t *)&v286)- 16;
      unint64_t v88 = v292;
      uint64_t v89 = v289;
      void *v289 = *((void *)v292 + v35);
      v89[1] = *((void *)v88 + v36);
      if (v273[0] != &v274) {
        free(v273[0]);
      }
      goto LABEL_74;
    }
LABEL_64:
    uint64_t v86 = 0;
    goto LABEL_72;
  }
LABEL_74:
  v252[0] = 0;
  v252[1] = 0;
  Shape = (void *)mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v256);
  v267[0] = v252;
  v273[0] = Shape;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v273);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)v267, DefiningOp))
  {
    uint64_t v244 = v73;
    unint64_t v246 = IndexFromDim;
    uint64_t v286 = v288;
    v288[0] = 0;
    v288[1] = 0;
    uint64_t v287 = 0x200000002;
    uint64_t v283 = v285;
    memset_pattern16(v285, &unk_1810FE350, 0x10uLL);
    uint64_t v284 = 0x200000002;
    int GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v256);
    v273[0] = (void *)2;
    uint64_t v245 = (mlir::Builder *)(a4 + 1);
    uint64_t v93 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    uint64_t v94 = (void *)mlir::RankedTensorType::get((uint64_t)v273, 1, v93, 0);
    uint64_t v95 = v94;
    if (v94)
    {
      unint64_t v96 = v37;
      uint64_t v97 = *v94;
      unint64_t v98 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v99 = *(unsigned int *)(v97 + 16);
      if (v99)
      {
        uint64_t v100 = *(void **)(v97 + 8);
        unint64_t v101 = &v100[2 * v99];
        do
        {
          unint64_t v102 = v99 >> 1;
          uint64_t v103 = &v100[2 * (v99 >> 1)];
          unint64_t v105 = *v103;
          unint64_t v104 = v103 + 2;
          v99 += ~(v99 >> 1);
          if (v105 < v98) {
            uint64_t v100 = v104;
          }
          else {
            unint64_t v99 = v102;
          }
        }
        while (v99);
        unint64_t v37 = v96;
        if (v100 == v101)
        {
          uint64_t v106 = 0;
        }
        else if (*v100 == v98)
        {
          uint64_t v106 = v100[1];
        }
        else
        {
          uint64_t v106 = 0;
        }
      }
      else
      {
        uint64_t v106 = 0;
        unint64_t v37 = v96;
      }
    }
    else
    {
      uint64_t v106 = 0;
    }
    if (GateLayout == 1) {
      char v114 = (void **)&v286;
    }
    else {
      char v114 = &v283;
    }
    uint64_t v115 = *v114;
    uint64_t v116 = &v287;
    if (GateLayout != 1) {
      uint64_t v116 = &v284;
    }
    uint64_t v251 = mlir::DenseElementsAttr::getFromRawBuffer(v95, v106, v115, 8 * *(unsigned int *)v116, 8, 1, 0);
    __dst = v282;
    uint64_t v281 = 0x200000000;
    BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v256);
    BOOL IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v256);
    unint64_t v243 = v37;
    if (mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v256)
      || mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v256))
    {
      long long v277 = v264;
      long long v278 = *(_OWORD *)v265;
      *(void *)long long v279 = *(void *)&v265[16];
      *(_OWORD *)unint64_t v273 = v260;
      long long v274 = v261;
      long long v275 = v262;
      long long v276 = v263;
      v258[0] = v256;
      uint64_t v120 = mlir::mps::getResizeLayout(v256, v119);
      if ((v120 & 0xFF00000000) == 0) {
        goto LABEL_211;
      }
      uint64_t v121 = 8 * (int)v120;
      unint64_t v122 = *(void *)((char *)&unk_181110CB0 + v121);
      uint64_t v123 = *(void *)((char *)&unk_181110CE8 + v121);
      unint64_t v124 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 2u);
      uint64_t v125 = (void *)*((void *)&v278 + 1);
      v267[0] = *((void **)&v278 + 1);
      v267[1] = (void *)v124;
      if (v124)
      {
        uint64_t v125 = (void *)mlir::ValueRange::offset_base(v267, v124);
        unint64_t v126 = v267[1];
      }
      else
      {
        unint64_t v126 = 0;
      }
      if ((void *)(HIDWORD(v124) + v124) == v126
        || (v267[0] = v125, v267[1] = 0, !mlir::ValueRange::dereference_iterator(v267, 0)))
      {
        float v130 = 1.0;
        float v131 = 1.0;
      }
      else
      {
        *(_OWORD *)long long v266 = 0uLL;
        unint64_t v127 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 2u);
        uint64_t v128 = (void *)*((void *)&v278 + 1);
        v267[0] = *((void **)&v278 + 1);
        v267[1] = (void *)v127;
        if (v127)
        {
          uint64_t v128 = (void *)mlir::ValueRange::offset_base(v267, v127);
          float v129 = v267[1];
        }
        else
        {
          float v129 = 0;
        }
        if ((void *)(HIDWORD(v127) + v127) == v129)
        {
          BOOL v185 = 0;
        }
        else
        {
          v267[0] = v128;
          v267[1] = 0;
          BOOL v185 = (void *)mlir::ValueRange::dereference_iterator(v267, 0);
        }
        uint64_t v257 = (uint64_t **)v266;
        v267[0] = v185;
        uint64_t v186 = mlir::Value::getDefiningOp((mlir::Value *)v267);
        if (!v186 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v257, v186)) {
          goto LABEL_211;
        }
        v267[0] = &v268;
        v267[1] = (void *)0x400000000;
        mlir::getIntValues<float>(v266[0], v266[1], (uint64_t)v267, 1);
        unint64_t v187 = LODWORD(v267[1]);
        float v130 = 1.0;
        float v131 = 1.0;
        if (v122 < LODWORD(v267[1]))
        {
          float v131 = *((float *)v267[0] + v122);
          float v130 = *((float *)v267[0] + v123);
        }
        if (v267[0] != &v268) {
          free(v267[0]);
        }
        if (v122 >= v187) {
          goto LABEL_211;
        }
      }
      unint64_t v132 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 3u);
      unint64_t v133 = (void *)*((void *)&v278 + 1);
      v267[0] = *((void **)&v278 + 1);
      v267[1] = (void *)v132;
      if (v132)
      {
        unint64_t v133 = (void *)mlir::ValueRange::offset_base(v267, v132);
        unint64_t v134 = v267[1];
      }
      else
      {
        unint64_t v134 = 0;
      }
      if ((void *)(HIDWORD(v132) + v132) == v134
        || (v267[0] = v133, v267[1] = 0, !mlir::ValueRange::dereference_iterator(v267, 0)))
      {
        float v138 = 0.0;
        float v139 = 0.0;
      }
      else
      {
        *(_OWORD *)long long v266 = 0uLL;
        unint64_t v135 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 3u);
        unint64_t v136 = (void *)*((void *)&v278 + 1);
        v267[0] = *((void **)&v278 + 1);
        v267[1] = (void *)v135;
        if (v135)
        {
          unint64_t v136 = (void *)mlir::ValueRange::offset_base(v267, v135);
          float v137 = v267[1];
        }
        else
        {
          float v137 = 0;
        }
        if ((void *)(HIDWORD(v135) + v135) == v137)
        {
          uint64_t v190 = 0;
        }
        else
        {
          v267[0] = v136;
          v267[1] = 0;
          uint64_t v190 = (void *)mlir::ValueRange::dereference_iterator(v267, 0);
        }
        uint64_t v257 = (uint64_t **)v266;
        v267[0] = v190;
        uint64_t v191 = mlir::Value::getDefiningOp((mlir::Value *)v267);
        if (!v191 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v257, v191)) {
          goto LABEL_211;
        }
        v267[0] = &v268;
        v267[1] = (void *)0x400000000;
        mlir::getIntValues<float>(v266[0], v266[1], (uint64_t)v267, 1);
        unint64_t v192 = LODWORD(v267[1]);
        float v138 = 0.0;
        float v139 = 0.0;
        if (v122 < LODWORD(v267[1]))
        {
          float v139 = *((float *)v267[0] + v122);
          float v138 = *((float *)v267[0] + v123);
        }
        if (v267[0] != &v268) {
          free(v267[0]);
        }
        if (v122 >= v192) {
          goto LABEL_211;
        }
      }
      unsigned int v140 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 0);
      long long v141 = (void *)*((void *)&v278 + 1);
      v267[0] = *((void **)&v278 + 1);
      v267[1] = (void *)v140;
      if (v140) {
        long long v141 = (void *)mlir::ValueRange::offset_base(v267, v140);
      }
      v267[0] = v141;
      v267[1] = 0;
      uint64_t v142 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v267, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v142) {
        goto LABEL_141;
      }
      uint64_t v143 = *v142;
      unint64_t v144 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v145 = *(unsigned int *)(v143 + 16);
      if (!v145) {
        goto LABEL_141;
      }
      long long v146 = *(void **)(v143 + 8);
      unint64_t v147 = &v146[2 * v145];
      do
      {
        unint64_t v148 = v145 >> 1;
        uint64_t v149 = &v146[2 * (v145 >> 1)];
        unint64_t v151 = *v149;
        unint64_t v150 = v149 + 2;
        v145 += ~(v145 >> 1);
        if (v151 < v144) {
          long long v146 = v150;
        }
        else {
          unint64_t v145 = v148;
        }
      }
      while (v145);
      if (v146 != v147 && *v146 == v144) {
        uint64_t v152 = (void *)v146[1];
      }
      else {
LABEL_141:
      }
        uint64_t v152 = 0;
      v267[0] = v142;
      v267[1] = v152;
      uint64_t v153 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v267);
      unint64_t v155 = v154;
      uint64_t v156 = *(void *)(a1 + 96);
      uint64_t v157 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v258);
      uint64_t v158 = (uint64_t *)mlir::TypeConverter::convertType(v156, (void *)(*(void *)(v157 + 8) & 0xFFFFFFFFFFFFFFF8));
      unint64_t v159 = v158;
      if (!v158) {
        goto LABEL_151;
      }
      uint64_t v160 = *v158;
      unint64_t v161 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v162 = *(unsigned int *)(v160 + 16);
      if (!v162) {
        goto LABEL_151;
      }
      unint64_t v163 = *(void **)(v160 + 8);
      v164 = &v163[2 * v162];
      do
      {
        unint64_t v165 = v162 >> 1;
        unint64_t v166 = &v163[2 * (v162 >> 1)];
        unint64_t v168 = *v166;
        unint64_t v167 = v166 + 2;
        v162 += ~(v162 >> 1);
        if (v168 < v161) {
          unint64_t v163 = v167;
        }
        else {
          unint64_t v162 = v165;
        }
      }
      while (v162);
      if (v163 != v164 && *v163 == v161) {
        uint64_t v169 = (void *)v163[1];
      }
      else {
LABEL_151:
      }
        uint64_t v169 = 0;
      v267[0] = v159;
      v267[1] = v169;
      uint64_t v170 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v267);
      unint64_t v172 = v171;
      unint64_t v173 = mlir::anec::getIndexFromDim(3, v155);
      unint64_t v174 = mlir::anec::getIndexFromDim(4, v172);
      float v175 = (float)*(uint64_t *)(v153 + 8 * v173);
      float v176 = (float)*(uint64_t *)(v153 + 8 * v174);
      float v177 = (float)*(uint64_t *)(v170 + 8 * v173);
      float v178 = (float)*(uint64_t *)(v170 + 8 * v174);
      BOOL v179 = v139 != 0.0;
      if (v138 != 0.0) {
        BOOL v179 = 1;
      }
      BOOL v180 = (v131 + -1.0) * 0.5 != v139 || (v130 + -1.0) * 0.5 != v138;
      BOOL v181 = v131 != (float)(v177 / v175) || v130 != (float)(v178 / v176);
      BOOL v182 = v131 != (float)((float)(v177 + -1.0) / (float)(v175 + -1.0))
          || v130 != (float)((float)(v178 + -1.0) / (float)(v176 + -1.0));
      if (v179 || v181)
      {
        if (v179 || v182)
        {
          if (!v180 && !v181)
          {
            BOOL InferredResultTypes = 0;
            BOOL IsSize = 1;
            goto LABEL_172;
          }
LABEL_211:
          uint64_t v193 = a4[2];
          if (v193)
          {
            uint64_t v194 = v256;
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
          }
            }
          int v109 = 0;
          int v110 = 0;
LABEL_215:
          if (__dst != v282) {
            free(__dst);
          }
          if (v283 != v285) {
            free(v283);
          }
          if (v286 != v288) {
            free(v286);
          }
          goto LABEL_91;
        }
        BOOL IsSize = 1;
        BOOL InferredResultTypes = 1;
LABEL_169:
        if (IsSize)
        {
          v267[0] = &v268;
          long long v268 = 0uLL;
LABEL_178:
          v267[1] = (void *)0x600000002;
          uint64_t v184 = v281;
          if (v281 >= 2)
          {
            *(_OWORD *)__dst = v268;
          }
          else
          {
            if (HIDWORD(v281) > 1)
            {
              if (v281) {
                memmove(__dst, &v268, 8 * v281);
              }
              else {
                uint64_t v184 = 0;
              }
            }
            else
            {
              LODWORD(v281) = 0;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v282, 2uLL, 8);
              uint64_t v184 = 0;
            }
            if (v184 != LODWORD(v267[1])) {
              memcpy((char *)__dst + 8 * v184, (char *)v267[0] + 8 * v184, 8 * LODWORD(v267[1]) - 8 * v184);
            }
          }
          LODWORD(v281) = 2;
          LODWORD(v267[1]) = 0;
          if (v267[0] != &v268) {
            free(v267[0]);
          }
          v267[0] = (void *)2;
          uint64_t v195 = mlir::Builder::getIntegerType(v245, 0x40u, 0);
          uint64_t v196 = (void *)mlir::RankedTensorType::get((uint64_t)v267, 1, v195, 0);
          unint64_t v197 = v196;
          if (!v196) {
            goto LABEL_235;
          }
          uint64_t v198 = *v196;
          unint64_t v199 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v200 = *(unsigned int *)(v198 + 16);
          if (!v200) {
            goto LABEL_235;
          }
          unint64_t v201 = *(void **)(v198 + 8);
          unint64_t v202 = &v201[2 * v200];
          do
          {
            unint64_t v203 = v200 >> 1;
            unint64_t v204 = &v201[2 * (v200 >> 1)];
            unint64_t v206 = *v204;
            unint64_t v205 = v204 + 2;
            v200 += ~(v200 >> 1);
            if (v206 < v199) {
              unint64_t v201 = v205;
            }
            else {
              unint64_t v200 = v203;
            }
          }
          while (v200);
          if (v201 != v202 && *v201 == v199) {
            uint64_t v207 = v201[1];
          }
          else {
LABEL_235:
          }
            uint64_t v207 = 0;
          uint64_t v257 = (uint64_t **)mlir::DenseElementsAttr::getFromRawBuffer(v197, v207, __dst, 8 * v281, 8, 1, 0);
          uint64_t v208 = v289;
          uint64_t v209 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v266, -1.0);
          uint64_t v210 = llvm::APFloatBase::IEEEsingle(v209);
          llvm::APFloat::Storage::Storage(&v267[1], v266, v210);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v266);
          llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v258, -1.0);
          llvm::APFloat::Storage::Storage(&v266[1], v258, v210);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v258);
          v258[0] = mlir::OpBuilder::create<mlir::anec::Resize,mlir::Value &,unsigned long long &,unsigned long long &,llvm::APFloat,llvm::APFloat,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(v245, v249, &v255, v208, v208 + 1, (uint64_t)v267, (uint64_t)v266, &v251, (uint64_t *)&v257);
          v211 = (void *)v266[1];
          uint64_t v212 = llvm::APFloatBase::PPCDoubleDouble(v258[0]);
          if (v212 == v211) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v266[1]);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v266[1]);
          }
          if (v212 == v267[1]) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v267[1]);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v267[1]);
          }
          char v213 = mlir::anec::Resize::verifyAttributesWithFamily((uint64_t *)v258, 4);
          int v109 = v258[0];
          if (v213)
          {
            if (v244 == 1)
            {
              v267[0] = &v268;
              *(void *)&long long v268 = v35;
              *((void *)&v268 + 1) = v243;
              unint64_t v269 = v36;
              unint64_t v270 = v35;
              unint64_t v271 = v243;
              unint64_t v272 = v36;
              v267[1] = (void *)0x600000006;
              *(_OWORD *)long long v266 = xmmword_181110B40;
              uint64_t v214 = mlir::Builder::getIntegerType(v245, 0x40u, 0);
              unint64_t v215 = (void *)mlir::RankedTensorType::get((uint64_t)v266, 2, v214, 0);
              uint64_t v216 = v215;
              if (!v215) {
                goto LABEL_253;
              }
              uint64_t v217 = *v215;
              unint64_t v218 = mlir::TypeID::get<mlir::ShapedType>();
              unint64_t v219 = *(unsigned int *)(v217 + 16);
              if (!v219) {
                goto LABEL_253;
              }
              unint64_t v220 = *(void **)(v217 + 8);
              unint64_t v221 = &v220[2 * v219];
              do
              {
                unint64_t v222 = v219 >> 1;
                unint64_t v223 = &v220[2 * (v219 >> 1)];
                unint64_t v225 = *v223;
                unint64_t v224 = v223 + 2;
                v219 += ~(v219 >> 1);
                if (v225 < v218) {
                  unint64_t v220 = v224;
                }
                else {
                  unint64_t v219 = v222;
                }
              }
              while (v219);
              if (v220 != v221 && *v220 == v218) {
                uint64_t v226 = v220[1];
              }
              else {
LABEL_253:
              }
                uint64_t v226 = 0;
              uint64_t v250 = mlir::DenseElementsAttr::getFromRawBuffer(v216, v226, v267[0], 8 * LODWORD(v267[1]), 8, 1, 0);
              int v109 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::anec::Resize &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v245, v249, v258, &v250);
              if (v267[0] != &v268) {
                free(v267[0]);
              }
            }
            mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v254);
            if (v227 > 3)
            {
              int v110 = 1;
            }
            else
            {
              v267[0] = &v268;
              *(void *)&long long v268 = v35;
              *((void *)&v268 + 1) = v246;
              unint64_t v269 = v36;
              unint64_t v270 = v35;
              unint64_t v271 = v246;
              unint64_t v272 = v36;
              v267[1] = (void *)0x600000006;
              *(_OWORD *)long long v266 = xmmword_181110B40;
              uint64_t v228 = mlir::Builder::getIntegerType(v245, 0x40u, 0);
              unint64_t v229 = (void *)mlir::RankedTensorType::get((uint64_t)v266, 2, v228, 0);
              uint64_t v230 = v229;
              if (v229
                && (uint64_t v231 = *v229,
                    unint64_t v232 = mlir::TypeID::get<mlir::ShapedType>(),
                    unint64_t v233 = *(unsigned int *)(v231 + 16),
                    v233))
              {
                v234 = *(void **)(v231 + 8);
                uint64_t v235 = &v234[2 * v233];
                do
                {
                  unint64_t v236 = v233 >> 1;
                  unint64_t v237 = &v234[2 * (v233 >> 1)];
                  unint64_t v239 = *v237;
                  v238 = v237 + 2;
                  v233 += ~(v233 >> 1);
                  if (v239 < v232) {
                    v234 = v238;
                  }
                  else {
                    unint64_t v233 = v236;
                  }
                }
                while (v233);
                if (v234 != v235 && *v234 == v232) {
                  uint64_t v240 = v234[1];
                }
                else {
                  uint64_t v240 = 0;
                }
              }
              else
              {
                uint64_t v240 = 0;
              }
              uint64_t v250 = mlir::DenseElementsAttr::getFromRawBuffer(v230, v240, v267[0], 8 * LODWORD(v267[1]), 8, 1, 0);
              v266[0] = (uint64_t)v109 - 16;
              int v109 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v245, v249, v266, &v250);
              if (v267[0] != &v268) {
                free(v267[0]);
              }
              int v110 = 1;
            }
          }
          else
          {
            mlir::ConversionPatternRewriter::eraseOp((mlir::ConversionPatternRewriter *)a4, v258[0]);
            v267[0] = "requested attributes are not compatible with hardware requirements";
            LOWORD(v269) = 259;
            uint64_t v241 = v256;
            v266[0] = (uint64_t)v267;
            uint64_t v242 = a4[2];
            if (v242 && mlir::RewriterBase::Listener::classof(a4[2])) {
              (*(void (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(void *)v242 + 64))(v242, *((void *)v241 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v266);
            }
            int v109 = 0;
            int v110 = 0;
          }
          goto LABEL_215;
        }
LABEL_172:
        if (InferredResultTypes || IsSize)
        {
          if (InferredResultTypes || !IsSize)
          {
            uint64_t v188 = a4[2];
            if (v188)
            {
              unint64_t v189 = v256;
              if (mlir::RewriterBase::Listener::classof(a4[2])) {
            }
              }
            int v109 = 0;
            int v110 = 0;
            goto LABEL_215;
          }
          v267[0] = &v268;
          float v183 = &unk_1810FE350;
        }
        else
        {
          v267[0] = &v268;
          float v183 = &unk_181110BA0;
        }
        memset_pattern16(&v268, v183, 0x10uLL);
        goto LABEL_178;
      }
      BOOL IsSize = 0;
      BOOL InferredResultTypes = 0;
    }
    if (!InferredResultTypes) {
      goto LABEL_172;
    }
    goto LABEL_169;
  }
  uint64_t v87 = "Shape operand was not a constant";
LABEL_87:
  v273[0] = (void *)v87;
  LOWORD(v275) = 259;
  uint64_t v107 = v256;
  v267[0] = v273;
  uint64_t v108 = a4[2];
  if (v108 && mlir::RewriterBase::Listener::classof(a4[2])) {
    (*(void (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v108 + 64))(v108, *((void *)v107 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v267);
  }
  int v109 = 0;
  int v110 = 0;
LABEL_91:
  if (v289 != v291) {
    free(v289);
  }
  if (v292 != (mlir::Operation *)v294) {
    free(v292);
  }
  if (v110)
  {
    v273[0] = (char *)v109 - 16;
    uint64_t v111 = 1;
    mlir::ValueRange::ValueRange(v259, (uint64_t)v273, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)a2, v259[0], v259[1]);
  }
  else
  {
    v273[0] = "Conversion did not match a valid resize or a valid transformation supported by the hardware.";
    LOWORD(v275) = 259;
    v267[0] = v273;
    uint64_t v112 = a4[2];
    if (v112 && mlir::RewriterBase::Listener::classof(v112)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v112 + 64))(v112, *((void *)a2 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v267);
    }
    else {
      return 0;
    }
  }
  return v111;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)4>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Resize with custom scale and offset values not supported on ANE.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)4>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported alignCorners, centerResult for Resize\n");
}

void *mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)5>::~ConvertResize(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)5>::~ConvertResize(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::mps *a2, long long *a3, uint64_t *a4)
{
  uint64_t v296 = *MEMORY[0x1E4F143B8];
  long long v5 = a3[5];
  long long v264 = a3[4];
  *(_OWORD *)long long v265 = v5;
  *(void *)&v265[16] = *((void *)a3 + 12);
  long long v6 = a3[1];
  long long v260 = *a3;
  long long v261 = v6;
  long long v7 = a3[3];
  long long v262 = a3[2];
  long long v263 = v7;
  uint64_t v256 = a2;
  long long v295 = *(_OWORD *)&v265[8];
  uint64_t v249 = *((void *)a2 + 3);
  uint64_t v255 = mlir::ValueRange::dereference_iterator(&v295, 0);
  uint64_t v8 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v256) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *v8;
  unint64_t v10 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v11 = *(unsigned int *)(v9 + 16);
  if (!v11) {
    goto LABEL_10;
  }
  unint64_t v12 = *(void **)(v9 + 8);
  uint64_t v13 = &v12[2 * v11];
  do
  {
    unint64_t v14 = v11 >> 1;
    unint64_t v15 = &v12[2 * (v11 >> 1)];
    unint64_t v17 = *v15;
    __int16 v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10) {
      unint64_t v12 = v16;
    }
    else {
      unint64_t v11 = v14;
    }
  }
  while (v11);
  if (v12 != v13 && *v12 == v10) {
    uint64_t v18 = v12[1];
  }
  else {
LABEL_10:
  }
    uint64_t v18 = 0;
  v254[0] = v8;
  v254[1] = v18;
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)&v260, 0);
  uint64_t v20 = *(void **)&v265[8];
  v273[0] = *(void **)&v265[8];
  v273[1] = (void *)ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    uint64_t v20 = (void *)mlir::ValueRange::offset_base(v273, ODSOperandIndexAndLength);
  }
  v273[0] = v20;
  v273[1] = 0;
  uint64_t v21 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v273, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v21) {
    goto LABEL_22;
  }
  uint64_t v22 = *v21;
  unint64_t v23 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v24 = *(unsigned int *)(v22 + 16);
  if (!v24) {
    goto LABEL_22;
  }
  unint64_t v25 = *(void **)(v22 + 8);
  uint64_t v26 = &v25[2 * v24];
  do
  {
    unint64_t v27 = v24 >> 1;
    unint64_t v28 = &v25[2 * (v24 >> 1)];
    unint64_t v30 = *v28;
    long long v29 = v28 + 2;
    v24 += ~(v24 >> 1);
    if (v30 < v23) {
      unint64_t v25 = v29;
    }
    else {
      unint64_t v24 = v27;
    }
  }
  while (v24);
  if (v25 != v26 && *v25 == v23) {
    unint64_t v31 = (void *)v25[1];
  }
  else {
LABEL_22:
  }
    unint64_t v31 = 0;
  v273[0] = v21;
  v273[1] = v31;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v273);
  unint64_t v33 = v32;
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(0, v32);
  unint64_t v35 = mlir::anec::getIndexFromDim(1, v33);
  unint64_t v36 = mlir::anec::getIndexFromDim(3, v33);
  unint64_t v37 = mlir::anec::getIndexFromDim(4, v33);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v254);
  if (v38 <= 3)
  {
    v273[0] = &v274;
    *(void *)&long long v274 = IndexFromDim;
    *((void *)&v274 + 1) = v35;
    *(void *)&long long v275 = v35;
    *((void *)&v275 + 1) = v36;
    *(void *)&long long v276 = v36;
    *((void *)&v276 + 1) = IndexFromDim;
    v273[1] = (void *)0x600000006;
    *(_OWORD *)v267 = xmmword_181110B40;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    uint64_t v40 = (void *)mlir::RankedTensorType::get((uint64_t)v267, 2, IntegerType, 0);
    uint64_t v41 = v40;
    if (!v40) {
      goto LABEL_33;
    }
    uint64_t v42 = *v40;
    unint64_t v43 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v44 = *(unsigned int *)(v42 + 16);
    if (!v44) {
      goto LABEL_33;
    }
    int64x2_t v45 = *(void **)(v42 + 8);
    uint64_t v46 = &v45[2 * v44];
    do
    {
      unint64_t v47 = v44 >> 1;
      uint64_t v48 = &v45[2 * (v44 >> 1)];
      unint64_t v50 = *v48;
      uint64_t v49 = v48 + 2;
      v44 += ~(v44 >> 1);
      if (v50 < v43) {
        int64x2_t v45 = v49;
      }
      else {
        unint64_t v44 = v47;
      }
    }
    while (v44);
    if (v45 != v46 && *v45 == v43) {
      uint64_t v51 = v45[1];
    }
    else {
LABEL_33:
    }
      uint64_t v51 = 0;
    uint64_t v292 = (mlir::Operation *)mlir::DenseElementsAttr::getFromRawBuffer(v41, v51, v273[0], 8 * LODWORD(v273[1]), 8, 1, 0);
    uint64_t v255 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v249, &v255, (uint64_t *)&v292)- 16;
    if (v273[0] != &v274) {
      free(v273[0]);
    }
  }
  unint64_t v52 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v256) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v52) {
    goto LABEL_45;
  }
  uint64_t v53 = *v52;
  unint64_t v54 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v55 = *(unsigned int *)(v53 + 16);
  if (!v55) {
    goto LABEL_45;
  }
  int64x2_t v56 = *(void **)(v53 + 8);
  uint64_t v57 = &v56[2 * v55];
  do
  {
    unint64_t v58 = v55 >> 1;
    unint64_t v59 = &v56[2 * (v55 >> 1)];
    unint64_t v61 = *v59;
    uint64_t v60 = v59 + 2;
    v55 += ~(v55 >> 1);
    if (v61 < v54) {
      int64x2_t v56 = v60;
    }
    else {
      unint64_t v55 = v58;
    }
  }
  while (v55);
  if (v56 != v57 && *v56 == v54) {
    uint64_t v62 = v56[1];
  }
  else {
LABEL_45:
  }
    uint64_t v62 = 0;
  v253[0] = v52;
  v253[1] = v62;
  uint64_t ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v253);
  uint64_t v65 = v63;
  uint64_t v292 = (mlir::Operation *)v294;
  uint64_t v293 = 0x400000000;
  size_t v66 = 8 * v63;
  if ((unint64_t)(8 * v63) < 0x21)
  {
    unsigned int v67 = 0;
    uint64_t v68 = (mlir::Operation *)v294;
    if (!v65) {
      goto LABEL_51;
    }
    goto LABEL_50;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v292, v294, (8 * v63) >> 3, 8);
  unsigned int v67 = v293;
  uint64_t v68 = v292;
  if (v65)
  {
LABEL_50:
    memcpy((char *)v68 + 8 * v67, ArgAttrsAttr, v66);
    unsigned int v67 = v293;
    uint64_t v68 = v292;
  }
LABEL_51:
  unsigned int v69 = v67 + (v66 >> 3);
  LODWORD(v293) = v69;
  if (v69 <= 3)
  {
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v292, (uint64_t)v68, 4 - v69, 1uLL);
    uint64_t v68 = v292;
  }
  uint64_t v70 = *((void *)v68 + v36);
  uint64_t v71 = *((void *)v68 + v37);
  uint64_t v289 = v291;
  v291[0] = v70;
  v291[1] = v71;
  uint64_t v290 = 0x200000002;
  uint64_t ResizeLayout = mlir::mps::getResizeLayout(v256, v68);
  if ((ResizeLayout & 0xFF00000000) == 0)
  {
    uint64_t v87 = "Resize layout not supported";
    goto LABEL_87;
  }
  uint64_t v73 = ResizeLayout;
  if (ResizeLayout == 1)
  {
    v273[0] = &v274;
    *(void *)&long long v274 = v35;
    *((void *)&v274 + 1) = v36;
    *(void *)&long long v275 = v36;
    *((void *)&v275 + 1) = v37;
    *(void *)&long long v276 = v37;
    *((void *)&v276 + 1) = v35;
    v273[1] = (void *)0x600000006;
    *(_OWORD *)v267 = xmmword_181110B40;
    uint64_t v74 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    uint64_t v75 = (void *)mlir::RankedTensorType::get((uint64_t)v267, 2, v74, 0);
    uint64_t v76 = v75;
    if (v75)
    {
      uint64_t v77 = *v75;
      unint64_t v78 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v79 = *(unsigned int *)(v77 + 16);
      if (v79)
      {
        uint64_t v80 = *(void **)(v77 + 8);
        unsigned int v81 = &v80[2 * v79];
        do
        {
          unint64_t v82 = v79 >> 1;
          uint64_t v83 = &v80[2 * (v79 >> 1)];
          unint64_t v85 = *v83;
          uint64_t v84 = v83 + 2;
          v79 += ~(v79 >> 1);
          if (v85 < v78) {
            uint64_t v80 = v84;
          }
          else {
            unint64_t v79 = v82;
          }
        }
        while (v79);
        uint64_t v73 = 1;
        if (v80 == v81 || *v80 != v78) {
          goto LABEL_64;
        }
        uint64_t v86 = v80[1];
      }
      else
      {
        uint64_t v86 = 0;
        uint64_t v73 = 1;
      }
LABEL_72:
      uint64_t v286 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v76, v86, v273[0], 8 * LODWORD(v273[1]), 8, 1, 0);
      uint64_t v255 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v249, &v255, (uint64_t *)&v286)- 16;
      unint64_t v88 = v292;
      uint64_t v89 = v289;
      void *v289 = *((void *)v292 + v35);
      v89[1] = *((void *)v88 + v36);
      if (v273[0] != &v274) {
        free(v273[0]);
      }
      goto LABEL_74;
    }
LABEL_64:
    uint64_t v86 = 0;
    goto LABEL_72;
  }
LABEL_74:
  v252[0] = 0;
  v252[1] = 0;
  Shape = (void *)mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v256);
  v267[0] = v252;
  v273[0] = Shape;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v273);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)v267, DefiningOp))
  {
    uint64_t v244 = v73;
    unint64_t v246 = IndexFromDim;
    uint64_t v286 = v288;
    v288[0] = 0;
    v288[1] = 0;
    uint64_t v287 = 0x200000002;
    uint64_t v283 = v285;
    memset_pattern16(v285, &unk_1810FE350, 0x10uLL);
    uint64_t v284 = 0x200000002;
    int GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v256);
    v273[0] = (void *)2;
    uint64_t v245 = (mlir::Builder *)(a4 + 1);
    uint64_t v93 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    uint64_t v94 = (void *)mlir::RankedTensorType::get((uint64_t)v273, 1, v93, 0);
    uint64_t v95 = v94;
    if (v94)
    {
      unint64_t v96 = v37;
      uint64_t v97 = *v94;
      unint64_t v98 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v99 = *(unsigned int *)(v97 + 16);
      if (v99)
      {
        uint64_t v100 = *(void **)(v97 + 8);
        unint64_t v101 = &v100[2 * v99];
        do
        {
          unint64_t v102 = v99 >> 1;
          uint64_t v103 = &v100[2 * (v99 >> 1)];
          unint64_t v105 = *v103;
          unint64_t v104 = v103 + 2;
          v99 += ~(v99 >> 1);
          if (v105 < v98) {
            uint64_t v100 = v104;
          }
          else {
            unint64_t v99 = v102;
          }
        }
        while (v99);
        unint64_t v37 = v96;
        if (v100 == v101)
        {
          uint64_t v106 = 0;
        }
        else if (*v100 == v98)
        {
          uint64_t v106 = v100[1];
        }
        else
        {
          uint64_t v106 = 0;
        }
      }
      else
      {
        uint64_t v106 = 0;
        unint64_t v37 = v96;
      }
    }
    else
    {
      uint64_t v106 = 0;
    }
    if (GateLayout == 1) {
      char v114 = (void **)&v286;
    }
    else {
      char v114 = &v283;
    }
    uint64_t v115 = *v114;
    uint64_t v116 = &v287;
    if (GateLayout != 1) {
      uint64_t v116 = &v284;
    }
    uint64_t v251 = mlir::DenseElementsAttr::getFromRawBuffer(v95, v106, v115, 8 * *(unsigned int *)v116, 8, 1, 0);
    __dst = v282;
    uint64_t v281 = 0x200000000;
    BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v256);
    BOOL IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v256);
    unint64_t v243 = v37;
    if (mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v256)
      || mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v256))
    {
      long long v277 = v264;
      long long v278 = *(_OWORD *)v265;
      *(void *)long long v279 = *(void *)&v265[16];
      *(_OWORD *)unint64_t v273 = v260;
      long long v274 = v261;
      long long v275 = v262;
      long long v276 = v263;
      v258[0] = v256;
      uint64_t v120 = mlir::mps::getResizeLayout(v256, v119);
      if ((v120 & 0xFF00000000) == 0) {
        goto LABEL_211;
      }
      uint64_t v121 = 8 * (int)v120;
      unint64_t v122 = *(void *)((char *)&unk_181110CB0 + v121);
      uint64_t v123 = *(void *)((char *)&unk_181110CE8 + v121);
      unint64_t v124 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 2u);
      uint64_t v125 = (void *)*((void *)&v278 + 1);
      v267[0] = *((void **)&v278 + 1);
      v267[1] = (void *)v124;
      if (v124)
      {
        uint64_t v125 = (void *)mlir::ValueRange::offset_base(v267, v124);
        unint64_t v126 = v267[1];
      }
      else
      {
        unint64_t v126 = 0;
      }
      if ((void *)(HIDWORD(v124) + v124) == v126
        || (v267[0] = v125, v267[1] = 0, !mlir::ValueRange::dereference_iterator(v267, 0)))
      {
        float v130 = 1.0;
        float v131 = 1.0;
      }
      else
      {
        *(_OWORD *)long long v266 = 0uLL;
        unint64_t v127 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 2u);
        uint64_t v128 = (void *)*((void *)&v278 + 1);
        v267[0] = *((void **)&v278 + 1);
        v267[1] = (void *)v127;
        if (v127)
        {
          uint64_t v128 = (void *)mlir::ValueRange::offset_base(v267, v127);
          float v129 = v267[1];
        }
        else
        {
          float v129 = 0;
        }
        if ((void *)(HIDWORD(v127) + v127) == v129)
        {
          BOOL v185 = 0;
        }
        else
        {
          v267[0] = v128;
          v267[1] = 0;
          BOOL v185 = (void *)mlir::ValueRange::dereference_iterator(v267, 0);
        }
        uint64_t v257 = (uint64_t **)v266;
        v267[0] = v185;
        uint64_t v186 = mlir::Value::getDefiningOp((mlir::Value *)v267);
        if (!v186 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v257, v186)) {
          goto LABEL_211;
        }
        v267[0] = &v268;
        v267[1] = (void *)0x400000000;
        mlir::getIntValues<float>(v266[0], v266[1], (uint64_t)v267, 1);
        unint64_t v187 = LODWORD(v267[1]);
        float v130 = 1.0;
        float v131 = 1.0;
        if (v122 < LODWORD(v267[1]))
        {
          float v131 = *((float *)v267[0] + v122);
          float v130 = *((float *)v267[0] + v123);
        }
        if (v267[0] != &v268) {
          free(v267[0]);
        }
        if (v122 >= v187) {
          goto LABEL_211;
        }
      }
      unint64_t v132 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 3u);
      unint64_t v133 = (void *)*((void *)&v278 + 1);
      v267[0] = *((void **)&v278 + 1);
      v267[1] = (void *)v132;
      if (v132)
      {
        unint64_t v133 = (void *)mlir::ValueRange::offset_base(v267, v132);
        unint64_t v134 = v267[1];
      }
      else
      {
        unint64_t v134 = 0;
      }
      if ((void *)(HIDWORD(v132) + v132) == v134
        || (v267[0] = v133, v267[1] = 0, !mlir::ValueRange::dereference_iterator(v267, 0)))
      {
        float v138 = 0.0;
        float v139 = 0.0;
      }
      else
      {
        *(_OWORD *)long long v266 = 0uLL;
        unint64_t v135 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 3u);
        unint64_t v136 = (void *)*((void *)&v278 + 1);
        v267[0] = *((void **)&v278 + 1);
        v267[1] = (void *)v135;
        if (v135)
        {
          unint64_t v136 = (void *)mlir::ValueRange::offset_base(v267, v135);
          float v137 = v267[1];
        }
        else
        {
          float v137 = 0;
        }
        if ((void *)(HIDWORD(v135) + v135) == v137)
        {
          uint64_t v190 = 0;
        }
        else
        {
          v267[0] = v136;
          v267[1] = 0;
          uint64_t v190 = (void *)mlir::ValueRange::dereference_iterator(v267, 0);
        }
        uint64_t v257 = (uint64_t **)v266;
        v267[0] = v190;
        uint64_t v191 = mlir::Value::getDefiningOp((mlir::Value *)v267);
        if (!v191 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v257, v191)) {
          goto LABEL_211;
        }
        v267[0] = &v268;
        v267[1] = (void *)0x400000000;
        mlir::getIntValues<float>(v266[0], v266[1], (uint64_t)v267, 1);
        unint64_t v192 = LODWORD(v267[1]);
        float v138 = 0.0;
        float v139 = 0.0;
        if (v122 < LODWORD(v267[1]))
        {
          float v139 = *((float *)v267[0] + v122);
          float v138 = *((float *)v267[0] + v123);
        }
        if (v267[0] != &v268) {
          free(v267[0]);
        }
        if (v122 >= v192) {
          goto LABEL_211;
        }
      }
      unsigned int v140 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 0);
      long long v141 = (void *)*((void *)&v278 + 1);
      v267[0] = *((void **)&v278 + 1);
      v267[1] = (void *)v140;
      if (v140) {
        long long v141 = (void *)mlir::ValueRange::offset_base(v267, v140);
      }
      v267[0] = v141;
      v267[1] = 0;
      uint64_t v142 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v267, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v142) {
        goto LABEL_141;
      }
      uint64_t v143 = *v142;
      unint64_t v144 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v145 = *(unsigned int *)(v143 + 16);
      if (!v145) {
        goto LABEL_141;
      }
      long long v146 = *(void **)(v143 + 8);
      unint64_t v147 = &v146[2 * v145];
      do
      {
        unint64_t v148 = v145 >> 1;
        uint64_t v149 = &v146[2 * (v145 >> 1)];
        unint64_t v151 = *v149;
        unint64_t v150 = v149 + 2;
        v145 += ~(v145 >> 1);
        if (v151 < v144) {
          long long v146 = v150;
        }
        else {
          unint64_t v145 = v148;
        }
      }
      while (v145);
      if (v146 != v147 && *v146 == v144) {
        uint64_t v152 = (void *)v146[1];
      }
      else {
LABEL_141:
      }
        uint64_t v152 = 0;
      v267[0] = v142;
      v267[1] = v152;
      uint64_t v153 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v267);
      unint64_t v155 = v154;
      uint64_t v156 = *(void *)(a1 + 96);
      uint64_t v157 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v258);
      uint64_t v158 = (uint64_t *)mlir::TypeConverter::convertType(v156, (void *)(*(void *)(v157 + 8) & 0xFFFFFFFFFFFFFFF8));
      unint64_t v159 = v158;
      if (!v158) {
        goto LABEL_151;
      }
      uint64_t v160 = *v158;
      unint64_t v161 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v162 = *(unsigned int *)(v160 + 16);
      if (!v162) {
        goto LABEL_151;
      }
      unint64_t v163 = *(void **)(v160 + 8);
      v164 = &v163[2 * v162];
      do
      {
        unint64_t v165 = v162 >> 1;
        unint64_t v166 = &v163[2 * (v162 >> 1)];
        unint64_t v168 = *v166;
        unint64_t v167 = v166 + 2;
        v162 += ~(v162 >> 1);
        if (v168 < v161) {
          unint64_t v163 = v167;
        }
        else {
          unint64_t v162 = v165;
        }
      }
      while (v162);
      if (v163 != v164 && *v163 == v161) {
        uint64_t v169 = (void *)v163[1];
      }
      else {
LABEL_151:
      }
        uint64_t v169 = 0;
      v267[0] = v159;
      v267[1] = v169;
      uint64_t v170 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v267);
      unint64_t v172 = v171;
      unint64_t v173 = mlir::anec::getIndexFromDim(3, v155);
      unint64_t v174 = mlir::anec::getIndexFromDim(4, v172);
      float v175 = (float)*(uint64_t *)(v153 + 8 * v173);
      float v176 = (float)*(uint64_t *)(v153 + 8 * v174);
      float v177 = (float)*(uint64_t *)(v170 + 8 * v173);
      float v178 = (float)*(uint64_t *)(v170 + 8 * v174);
      BOOL v179 = v139 != 0.0;
      if (v138 != 0.0) {
        BOOL v179 = 1;
      }
      BOOL v180 = (v131 + -1.0) * 0.5 != v139 || (v130 + -1.0) * 0.5 != v138;
      BOOL v181 = v131 != (float)(v177 / v175) || v130 != (float)(v178 / v176);
      BOOL v182 = v131 != (float)((float)(v177 + -1.0) / (float)(v175 + -1.0))
          || v130 != (float)((float)(v178 + -1.0) / (float)(v176 + -1.0));
      if (v179 || v181)
      {
        if (v179 || v182)
        {
          if (!v180 && !v181)
          {
            BOOL InferredResultTypes = 0;
            BOOL IsSize = 1;
            goto LABEL_172;
          }
LABEL_211:
          uint64_t v193 = a4[2];
          if (v193)
          {
            uint64_t v194 = v256;
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
          }
            }
          int v109 = 0;
          int v110 = 0;
LABEL_215:
          if (__dst != v282) {
            free(__dst);
          }
          if (v283 != v285) {
            free(v283);
          }
          if (v286 != v288) {
            free(v286);
          }
          goto LABEL_91;
        }
        BOOL IsSize = 1;
        BOOL InferredResultTypes = 1;
LABEL_169:
        if (IsSize)
        {
          v267[0] = &v268;
          long long v268 = 0uLL;
LABEL_178:
          v267[1] = (void *)0x600000002;
          uint64_t v184 = v281;
          if (v281 >= 2)
          {
            *(_OWORD *)__dst = v268;
          }
          else
          {
            if (HIDWORD(v281) > 1)
            {
              if (v281) {
                memmove(__dst, &v268, 8 * v281);
              }
              else {
                uint64_t v184 = 0;
              }
            }
            else
            {
              LODWORD(v281) = 0;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v282, 2uLL, 8);
              uint64_t v184 = 0;
            }
            if (v184 != LODWORD(v267[1])) {
              memcpy((char *)__dst + 8 * v184, (char *)v267[0] + 8 * v184, 8 * LODWORD(v267[1]) - 8 * v184);
            }
          }
          LODWORD(v281) = 2;
          LODWORD(v267[1]) = 0;
          if (v267[0] != &v268) {
            free(v267[0]);
          }
          v267[0] = (void *)2;
          uint64_t v195 = mlir::Builder::getIntegerType(v245, 0x40u, 0);
          uint64_t v196 = (void *)mlir::RankedTensorType::get((uint64_t)v267, 1, v195, 0);
          unint64_t v197 = v196;
          if (!v196) {
            goto LABEL_235;
          }
          uint64_t v198 = *v196;
          unint64_t v199 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v200 = *(unsigned int *)(v198 + 16);
          if (!v200) {
            goto LABEL_235;
          }
          unint64_t v201 = *(void **)(v198 + 8);
          unint64_t v202 = &v201[2 * v200];
          do
          {
            unint64_t v203 = v200 >> 1;
            unint64_t v204 = &v201[2 * (v200 >> 1)];
            unint64_t v206 = *v204;
            unint64_t v205 = v204 + 2;
            v200 += ~(v200 >> 1);
            if (v206 < v199) {
              unint64_t v201 = v205;
            }
            else {
              unint64_t v200 = v203;
            }
          }
          while (v200);
          if (v201 != v202 && *v201 == v199) {
            uint64_t v207 = v201[1];
          }
          else {
LABEL_235:
          }
            uint64_t v207 = 0;
          uint64_t v257 = (uint64_t **)mlir::DenseElementsAttr::getFromRawBuffer(v197, v207, __dst, 8 * v281, 8, 1, 0);
          uint64_t v208 = v289;
          uint64_t v209 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v266, -1.0);
          uint64_t v210 = llvm::APFloatBase::IEEEsingle(v209);
          llvm::APFloat::Storage::Storage(&v267[1], v266, v210);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v266);
          llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v258, -1.0);
          llvm::APFloat::Storage::Storage(&v266[1], v258, v210);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v258);
          v258[0] = mlir::OpBuilder::create<mlir::anec::Resize,mlir::Value &,unsigned long long &,unsigned long long &,llvm::APFloat,llvm::APFloat,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(v245, v249, &v255, v208, v208 + 1, (uint64_t)v267, (uint64_t)v266, &v251, (uint64_t *)&v257);
          v211 = (void *)v266[1];
          uint64_t v212 = llvm::APFloatBase::PPCDoubleDouble(v258[0]);
          if (v212 == v211) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v266[1]);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v266[1]);
          }
          if (v212 == v267[1]) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v267[1]);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v267[1]);
          }
          char v213 = mlir::anec::Resize::verifyAttributesWithFamily((uint64_t *)v258, 5);
          int v109 = v258[0];
          if (v213)
          {
            if (v244 == 1)
            {
              v267[0] = &v268;
              *(void *)&long long v268 = v35;
              *((void *)&v268 + 1) = v243;
              unint64_t v269 = v36;
              unint64_t v270 = v35;
              unint64_t v271 = v243;
              unint64_t v272 = v36;
              v267[1] = (void *)0x600000006;
              *(_OWORD *)long long v266 = xmmword_181110B40;
              uint64_t v214 = mlir::Builder::getIntegerType(v245, 0x40u, 0);
              unint64_t v215 = (void *)mlir::RankedTensorType::get((uint64_t)v266, 2, v214, 0);
              uint64_t v216 = v215;
              if (!v215) {
                goto LABEL_253;
              }
              uint64_t v217 = *v215;
              unint64_t v218 = mlir::TypeID::get<mlir::ShapedType>();
              unint64_t v219 = *(unsigned int *)(v217 + 16);
              if (!v219) {
                goto LABEL_253;
              }
              unint64_t v220 = *(void **)(v217 + 8);
              unint64_t v221 = &v220[2 * v219];
              do
              {
                unint64_t v222 = v219 >> 1;
                unint64_t v223 = &v220[2 * (v219 >> 1)];
                unint64_t v225 = *v223;
                unint64_t v224 = v223 + 2;
                v219 += ~(v219 >> 1);
                if (v225 < v218) {
                  unint64_t v220 = v224;
                }
                else {
                  unint64_t v219 = v222;
                }
              }
              while (v219);
              if (v220 != v221 && *v220 == v218) {
                uint64_t v226 = v220[1];
              }
              else {
LABEL_253:
              }
                uint64_t v226 = 0;
              uint64_t v250 = mlir::DenseElementsAttr::getFromRawBuffer(v216, v226, v267[0], 8 * LODWORD(v267[1]), 8, 1, 0);
              int v109 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::anec::Resize &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v245, v249, v258, &v250);
              if (v267[0] != &v268) {
                free(v267[0]);
              }
            }
            mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v254);
            if (v227 > 3)
            {
              int v110 = 1;
            }
            else
            {
              v267[0] = &v268;
              *(void *)&long long v268 = v35;
              *((void *)&v268 + 1) = v246;
              unint64_t v269 = v36;
              unint64_t v270 = v35;
              unint64_t v271 = v246;
              unint64_t v272 = v36;
              v267[1] = (void *)0x600000006;
              *(_OWORD *)long long v266 = xmmword_181110B40;
              uint64_t v228 = mlir::Builder::getIntegerType(v245, 0x40u, 0);
              unint64_t v229 = (void *)mlir::RankedTensorType::get((uint64_t)v266, 2, v228, 0);
              uint64_t v230 = v229;
              if (v229
                && (uint64_t v231 = *v229,
                    unint64_t v232 = mlir::TypeID::get<mlir::ShapedType>(),
                    unint64_t v233 = *(unsigned int *)(v231 + 16),
                    v233))
              {
                v234 = *(void **)(v231 + 8);
                uint64_t v235 = &v234[2 * v233];
                do
                {
                  unint64_t v236 = v233 >> 1;
                  unint64_t v237 = &v234[2 * (v233 >> 1)];
                  unint64_t v239 = *v237;
                  v238 = v237 + 2;
                  v233 += ~(v233 >> 1);
                  if (v239 < v232) {
                    v234 = v238;
                  }
                  else {
                    unint64_t v233 = v236;
                  }
                }
                while (v233);
                if (v234 != v235 && *v234 == v232) {
                  uint64_t v240 = v234[1];
                }
                else {
                  uint64_t v240 = 0;
                }
              }
              else
              {
                uint64_t v240 = 0;
              }
              uint64_t v250 = mlir::DenseElementsAttr::getFromRawBuffer(v230, v240, v267[0], 8 * LODWORD(v267[1]), 8, 1, 0);
              v266[0] = (uint64_t)v109 - 16;
              int v109 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v245, v249, v266, &v250);
              if (v267[0] != &v268) {
                free(v267[0]);
              }
              int v110 = 1;
            }
          }
          else
          {
            mlir::ConversionPatternRewriter::eraseOp((mlir::ConversionPatternRewriter *)a4, v258[0]);
            v267[0] = "requested attributes are not compatible with hardware requirements";
            LOWORD(v269) = 259;
            uint64_t v241 = v256;
            v266[0] = (uint64_t)v267;
            uint64_t v242 = a4[2];
            if (v242 && mlir::RewriterBase::Listener::classof(a4[2])) {
              (*(void (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(void *)v242 + 64))(v242, *((void *)v241 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v266);
            }
            int v109 = 0;
            int v110 = 0;
          }
          goto LABEL_215;
        }
LABEL_172:
        if (InferredResultTypes || IsSize)
        {
          if (InferredResultTypes || !IsSize)
          {
            uint64_t v188 = a4[2];
            if (v188)
            {
              unint64_t v189 = v256;
              if (mlir::RewriterBase::Listener::classof(a4[2])) {
            }
              }
            int v109 = 0;
            int v110 = 0;
            goto LABEL_215;
          }
          v267[0] = &v268;
          float v183 = &unk_1810FE350;
        }
        else
        {
          v267[0] = &v268;
          float v183 = &unk_181110BA0;
        }
        memset_pattern16(&v268, v183, 0x10uLL);
        goto LABEL_178;
      }
      BOOL IsSize = 0;
      BOOL InferredResultTypes = 0;
    }
    if (!InferredResultTypes) {
      goto LABEL_172;
    }
    goto LABEL_169;
  }
  uint64_t v87 = "Shape operand was not a constant";
LABEL_87:
  v273[0] = (void *)v87;
  LOWORD(v275) = 259;
  uint64_t v107 = v256;
  v267[0] = v273;
  uint64_t v108 = a4[2];
  if (v108 && mlir::RewriterBase::Listener::classof(a4[2])) {
    (*(void (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v108 + 64))(v108, *((void *)v107 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v267);
  }
  int v109 = 0;
  int v110 = 0;
LABEL_91:
  if (v289 != v291) {
    free(v289);
  }
  if (v292 != (mlir::Operation *)v294) {
    free(v292);
  }
  if (v110)
  {
    v273[0] = (char *)v109 - 16;
    uint64_t v111 = 1;
    mlir::ValueRange::ValueRange(v259, (uint64_t)v273, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)a2, v259[0], v259[1]);
  }
  else
  {
    v273[0] = "Conversion did not match a valid resize or a valid transformation supported by the hardware.";
    LOWORD(v275) = 259;
    v267[0] = v273;
    uint64_t v112 = a4[2];
    if (v112 && mlir::RewriterBase::Listener::classof(v112)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v112 + 64))(v112, *((void *)a2 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v267);
    }
    else {
      return 0;
    }
  }
  return v111;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)5>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Resize with custom scale and offset values not supported on ANE.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)5>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported alignCorners, centerResult for Resize\n");
}

void *mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)6>::~ConvertResize(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)6>::~ConvertResize(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::mps *a2, long long *a3, uint64_t *a4)
{
  uint64_t v296 = *MEMORY[0x1E4F143B8];
  long long v5 = a3[5];
  long long v264 = a3[4];
  *(_OWORD *)long long v265 = v5;
  *(void *)&v265[16] = *((void *)a3 + 12);
  long long v6 = a3[1];
  long long v260 = *a3;
  long long v261 = v6;
  long long v7 = a3[3];
  long long v262 = a3[2];
  long long v263 = v7;
  uint64_t v256 = a2;
  long long v295 = *(_OWORD *)&v265[8];
  uint64_t v249 = *((void *)a2 + 3);
  uint64_t v255 = mlir::ValueRange::dereference_iterator(&v295, 0);
  uint64_t v8 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v256) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *v8;
  unint64_t v10 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v11 = *(unsigned int *)(v9 + 16);
  if (!v11) {
    goto LABEL_10;
  }
  unint64_t v12 = *(void **)(v9 + 8);
  uint64_t v13 = &v12[2 * v11];
  do
  {
    unint64_t v14 = v11 >> 1;
    unint64_t v15 = &v12[2 * (v11 >> 1)];
    unint64_t v17 = *v15;
    __int16 v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10) {
      unint64_t v12 = v16;
    }
    else {
      unint64_t v11 = v14;
    }
  }
  while (v11);
  if (v12 != v13 && *v12 == v10) {
    uint64_t v18 = v12[1];
  }
  else {
LABEL_10:
  }
    uint64_t v18 = 0;
  v254[0] = v8;
  v254[1] = v18;
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)&v260, 0);
  uint64_t v20 = *(void **)&v265[8];
  v273[0] = *(void **)&v265[8];
  v273[1] = (void *)ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    uint64_t v20 = (void *)mlir::ValueRange::offset_base(v273, ODSOperandIndexAndLength);
  }
  v273[0] = v20;
  v273[1] = 0;
  uint64_t v21 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v273, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v21) {
    goto LABEL_22;
  }
  uint64_t v22 = *v21;
  unint64_t v23 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v24 = *(unsigned int *)(v22 + 16);
  if (!v24) {
    goto LABEL_22;
  }
  unint64_t v25 = *(void **)(v22 + 8);
  uint64_t v26 = &v25[2 * v24];
  do
  {
    unint64_t v27 = v24 >> 1;
    unint64_t v28 = &v25[2 * (v24 >> 1)];
    unint64_t v30 = *v28;
    long long v29 = v28 + 2;
    v24 += ~(v24 >> 1);
    if (v30 < v23) {
      unint64_t v25 = v29;
    }
    else {
      unint64_t v24 = v27;
    }
  }
  while (v24);
  if (v25 != v26 && *v25 == v23) {
    unint64_t v31 = (void *)v25[1];
  }
  else {
LABEL_22:
  }
    unint64_t v31 = 0;
  v273[0] = v21;
  v273[1] = v31;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v273);
  unint64_t v33 = v32;
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(0, v32);
  unint64_t v35 = mlir::anec::getIndexFromDim(1, v33);
  unint64_t v36 = mlir::anec::getIndexFromDim(3, v33);
  unint64_t v37 = mlir::anec::getIndexFromDim(4, v33);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v254);
  if (v38 <= 3)
  {
    v273[0] = &v274;
    *(void *)&long long v274 = IndexFromDim;
    *((void *)&v274 + 1) = v35;
    *(void *)&long long v275 = v35;
    *((void *)&v275 + 1) = v36;
    *(void *)&long long v276 = v36;
    *((void *)&v276 + 1) = IndexFromDim;
    v273[1] = (void *)0x600000006;
    *(_OWORD *)v267 = xmmword_181110B40;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    uint64_t v40 = (void *)mlir::RankedTensorType::get((uint64_t)v267, 2, IntegerType, 0);
    uint64_t v41 = v40;
    if (!v40) {
      goto LABEL_33;
    }
    uint64_t v42 = *v40;
    unint64_t v43 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v44 = *(unsigned int *)(v42 + 16);
    if (!v44) {
      goto LABEL_33;
    }
    int64x2_t v45 = *(void **)(v42 + 8);
    uint64_t v46 = &v45[2 * v44];
    do
    {
      unint64_t v47 = v44 >> 1;
      uint64_t v48 = &v45[2 * (v44 >> 1)];
      unint64_t v50 = *v48;
      uint64_t v49 = v48 + 2;
      v44 += ~(v44 >> 1);
      if (v50 < v43) {
        int64x2_t v45 = v49;
      }
      else {
        unint64_t v44 = v47;
      }
    }
    while (v44);
    if (v45 != v46 && *v45 == v43) {
      uint64_t v51 = v45[1];
    }
    else {
LABEL_33:
    }
      uint64_t v51 = 0;
    uint64_t v292 = (mlir::Operation *)mlir::DenseElementsAttr::getFromRawBuffer(v41, v51, v273[0], 8 * LODWORD(v273[1]), 8, 1, 0);
    uint64_t v255 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v249, &v255, (uint64_t *)&v292)- 16;
    if (v273[0] != &v274) {
      free(v273[0]);
    }
  }
  unint64_t v52 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v256) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v52) {
    goto LABEL_45;
  }
  uint64_t v53 = *v52;
  unint64_t v54 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v55 = *(unsigned int *)(v53 + 16);
  if (!v55) {
    goto LABEL_45;
  }
  int64x2_t v56 = *(void **)(v53 + 8);
  uint64_t v57 = &v56[2 * v55];
  do
  {
    unint64_t v58 = v55 >> 1;
    unint64_t v59 = &v56[2 * (v55 >> 1)];
    unint64_t v61 = *v59;
    uint64_t v60 = v59 + 2;
    v55 += ~(v55 >> 1);
    if (v61 < v54) {
      int64x2_t v56 = v60;
    }
    else {
      unint64_t v55 = v58;
    }
  }
  while (v55);
  if (v56 != v57 && *v56 == v54) {
    uint64_t v62 = v56[1];
  }
  else {
LABEL_45:
  }
    uint64_t v62 = 0;
  v253[0] = v52;
  v253[1] = v62;
  uint64_t ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v253);
  uint64_t v65 = v63;
  uint64_t v292 = (mlir::Operation *)v294;
  uint64_t v293 = 0x400000000;
  size_t v66 = 8 * v63;
  if ((unint64_t)(8 * v63) < 0x21)
  {
    unsigned int v67 = 0;
    uint64_t v68 = (mlir::Operation *)v294;
    if (!v65) {
      goto LABEL_51;
    }
    goto LABEL_50;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v292, v294, (8 * v63) >> 3, 8);
  unsigned int v67 = v293;
  uint64_t v68 = v292;
  if (v65)
  {
LABEL_50:
    memcpy((char *)v68 + 8 * v67, ArgAttrsAttr, v66);
    unsigned int v67 = v293;
    uint64_t v68 = v292;
  }
LABEL_51:
  unsigned int v69 = v67 + (v66 >> 3);
  LODWORD(v293) = v69;
  if (v69 <= 3)
  {
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v292, (uint64_t)v68, 4 - v69, 1uLL);
    uint64_t v68 = v292;
  }
  uint64_t v70 = *((void *)v68 + v36);
  uint64_t v71 = *((void *)v68 + v37);
  uint64_t v289 = v291;
  v291[0] = v70;
  v291[1] = v71;
  uint64_t v290 = 0x200000002;
  uint64_t ResizeLayout = mlir::mps::getResizeLayout(v256, v68);
  if ((ResizeLayout & 0xFF00000000) == 0)
  {
    uint64_t v87 = "Resize layout not supported";
    goto LABEL_87;
  }
  uint64_t v73 = ResizeLayout;
  if (ResizeLayout == 1)
  {
    v273[0] = &v274;
    *(void *)&long long v274 = v35;
    *((void *)&v274 + 1) = v36;
    *(void *)&long long v275 = v36;
    *((void *)&v275 + 1) = v37;
    *(void *)&long long v276 = v37;
    *((void *)&v276 + 1) = v35;
    v273[1] = (void *)0x600000006;
    *(_OWORD *)v267 = xmmword_181110B40;
    uint64_t v74 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    uint64_t v75 = (void *)mlir::RankedTensorType::get((uint64_t)v267, 2, v74, 0);
    uint64_t v76 = v75;
    if (v75)
    {
      uint64_t v77 = *v75;
      unint64_t v78 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v79 = *(unsigned int *)(v77 + 16);
      if (v79)
      {
        uint64_t v80 = *(void **)(v77 + 8);
        unsigned int v81 = &v80[2 * v79];
        do
        {
          unint64_t v82 = v79 >> 1;
          uint64_t v83 = &v80[2 * (v79 >> 1)];
          unint64_t v85 = *v83;
          uint64_t v84 = v83 + 2;
          v79 += ~(v79 >> 1);
          if (v85 < v78) {
            uint64_t v80 = v84;
          }
          else {
            unint64_t v79 = v82;
          }
        }
        while (v79);
        uint64_t v73 = 1;
        if (v80 == v81 || *v80 != v78) {
          goto LABEL_64;
        }
        uint64_t v86 = v80[1];
      }
      else
      {
        uint64_t v86 = 0;
        uint64_t v73 = 1;
      }
LABEL_72:
      uint64_t v286 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v76, v86, v273[0], 8 * LODWORD(v273[1]), 8, 1, 0);
      uint64_t v255 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v249, &v255, (uint64_t *)&v286)- 16;
      unint64_t v88 = v292;
      uint64_t v89 = v289;
      void *v289 = *((void *)v292 + v35);
      v89[1] = *((void *)v88 + v36);
      if (v273[0] != &v274) {
        free(v273[0]);
      }
      goto LABEL_74;
    }
LABEL_64:
    uint64_t v86 = 0;
    goto LABEL_72;
  }
LABEL_74:
  v252[0] = 0;
  v252[1] = 0;
  Shape = (void *)mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v256);
  v267[0] = v252;
  v273[0] = Shape;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v273);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)v267, DefiningOp))
  {
    uint64_t v244 = v73;
    unint64_t v246 = IndexFromDim;
    uint64_t v286 = v288;
    v288[0] = 0;
    v288[1] = 0;
    uint64_t v287 = 0x200000002;
    uint64_t v283 = v285;
    memset_pattern16(v285, &unk_1810FE350, 0x10uLL);
    uint64_t v284 = 0x200000002;
    int GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v256);
    v273[0] = (void *)2;
    uint64_t v245 = (mlir::Builder *)(a4 + 1);
    uint64_t v93 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    uint64_t v94 = (void *)mlir::RankedTensorType::get((uint64_t)v273, 1, v93, 0);
    uint64_t v95 = v94;
    if (v94)
    {
      unint64_t v96 = v37;
      uint64_t v97 = *v94;
      unint64_t v98 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v99 = *(unsigned int *)(v97 + 16);
      if (v99)
      {
        uint64_t v100 = *(void **)(v97 + 8);
        unint64_t v101 = &v100[2 * v99];
        do
        {
          unint64_t v102 = v99 >> 1;
          uint64_t v103 = &v100[2 * (v99 >> 1)];
          unint64_t v105 = *v103;
          unint64_t v104 = v103 + 2;
          v99 += ~(v99 >> 1);
          if (v105 < v98) {
            uint64_t v100 = v104;
          }
          else {
            unint64_t v99 = v102;
          }
        }
        while (v99);
        unint64_t v37 = v96;
        if (v100 == v101)
        {
          uint64_t v106 = 0;
        }
        else if (*v100 == v98)
        {
          uint64_t v106 = v100[1];
        }
        else
        {
          uint64_t v106 = 0;
        }
      }
      else
      {
        uint64_t v106 = 0;
        unint64_t v37 = v96;
      }
    }
    else
    {
      uint64_t v106 = 0;
    }
    if (GateLayout == 1) {
      char v114 = (void **)&v286;
    }
    else {
      char v114 = &v283;
    }
    uint64_t v115 = *v114;
    uint64_t v116 = &v287;
    if (GateLayout != 1) {
      uint64_t v116 = &v284;
    }
    uint64_t v251 = mlir::DenseElementsAttr::getFromRawBuffer(v95, v106, v115, 8 * *(unsigned int *)v116, 8, 1, 0);
    __dst = v282;
    uint64_t v281 = 0x200000000;
    BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v256);
    BOOL IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v256);
    unint64_t v243 = v37;
    if (mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v256)
      || mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v256))
    {
      long long v277 = v264;
      long long v278 = *(_OWORD *)v265;
      *(void *)long long v279 = *(void *)&v265[16];
      *(_OWORD *)unint64_t v273 = v260;
      long long v274 = v261;
      long long v275 = v262;
      long long v276 = v263;
      v258[0] = v256;
      uint64_t v120 = mlir::mps::getResizeLayout(v256, v119);
      if ((v120 & 0xFF00000000) == 0) {
        goto LABEL_211;
      }
      uint64_t v121 = 8 * (int)v120;
      unint64_t v122 = *(void *)((char *)&unk_181110CB0 + v121);
      uint64_t v123 = *(void *)((char *)&unk_181110CE8 + v121);
      unint64_t v124 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 2u);
      uint64_t v125 = (void *)*((void *)&v278 + 1);
      v267[0] = *((void **)&v278 + 1);
      v267[1] = (void *)v124;
      if (v124)
      {
        uint64_t v125 = (void *)mlir::ValueRange::offset_base(v267, v124);
        unint64_t v126 = v267[1];
      }
      else
      {
        unint64_t v126 = 0;
      }
      if ((void *)(HIDWORD(v124) + v124) == v126
        || (v267[0] = v125, v267[1] = 0, !mlir::ValueRange::dereference_iterator(v267, 0)))
      {
        float v130 = 1.0;
        float v131 = 1.0;
      }
      else
      {
        *(_OWORD *)long long v266 = 0uLL;
        unint64_t v127 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 2u);
        uint64_t v128 = (void *)*((void *)&v278 + 1);
        v267[0] = *((void **)&v278 + 1);
        v267[1] = (void *)v127;
        if (v127)
        {
          uint64_t v128 = (void *)mlir::ValueRange::offset_base(v267, v127);
          float v129 = v267[1];
        }
        else
        {
          float v129 = 0;
        }
        if ((void *)(HIDWORD(v127) + v127) == v129)
        {
          BOOL v185 = 0;
        }
        else
        {
          v267[0] = v128;
          v267[1] = 0;
          BOOL v185 = (void *)mlir::ValueRange::dereference_iterator(v267, 0);
        }
        uint64_t v257 = (uint64_t **)v266;
        v267[0] = v185;
        uint64_t v186 = mlir::Value::getDefiningOp((mlir::Value *)v267);
        if (!v186 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v257, v186)) {
          goto LABEL_211;
        }
        v267[0] = &v268;
        v267[1] = (void *)0x400000000;
        mlir::getIntValues<float>(v266[0], v266[1], (uint64_t)v267, 1);
        unint64_t v187 = LODWORD(v267[1]);
        float v130 = 1.0;
        float v131 = 1.0;
        if (v122 < LODWORD(v267[1]))
        {
          float v131 = *((float *)v267[0] + v122);
          float v130 = *((float *)v267[0] + v123);
        }
        if (v267[0] != &v268) {
          free(v267[0]);
        }
        if (v122 >= v187) {
          goto LABEL_211;
        }
      }
      unint64_t v132 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 3u);
      unint64_t v133 = (void *)*((void *)&v278 + 1);
      v267[0] = *((void **)&v278 + 1);
      v267[1] = (void *)v132;
      if (v132)
      {
        unint64_t v133 = (void *)mlir::ValueRange::offset_base(v267, v132);
        unint64_t v134 = v267[1];
      }
      else
      {
        unint64_t v134 = 0;
      }
      if ((void *)(HIDWORD(v132) + v132) == v134
        || (v267[0] = v133, v267[1] = 0, !mlir::ValueRange::dereference_iterator(v267, 0)))
      {
        float v138 = 0.0;
        float v139 = 0.0;
      }
      else
      {
        *(_OWORD *)long long v266 = 0uLL;
        unint64_t v135 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 3u);
        unint64_t v136 = (void *)*((void *)&v278 + 1);
        v267[0] = *((void **)&v278 + 1);
        v267[1] = (void *)v135;
        if (v135)
        {
          unint64_t v136 = (void *)mlir::ValueRange::offset_base(v267, v135);
          float v137 = v267[1];
        }
        else
        {
          float v137 = 0;
        }
        if ((void *)(HIDWORD(v135) + v135) == v137)
        {
          uint64_t v190 = 0;
        }
        else
        {
          v267[0] = v136;
          v267[1] = 0;
          uint64_t v190 = (void *)mlir::ValueRange::dereference_iterator(v267, 0);
        }
        uint64_t v257 = (uint64_t **)v266;
        v267[0] = v190;
        uint64_t v191 = mlir::Value::getDefiningOp((mlir::Value *)v267);
        if (!v191 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v257, v191)) {
          goto LABEL_211;
        }
        v267[0] = &v268;
        v267[1] = (void *)0x400000000;
        mlir::getIntValues<float>(v266[0], v266[1], (uint64_t)v267, 1);
        unint64_t v192 = LODWORD(v267[1]);
        float v138 = 0.0;
        float v139 = 0.0;
        if (v122 < LODWORD(v267[1]))
        {
          float v139 = *((float *)v267[0] + v122);
          float v138 = *((float *)v267[0] + v123);
        }
        if (v267[0] != &v268) {
          free(v267[0]);
        }
        if (v122 >= v192) {
          goto LABEL_211;
        }
      }
      unsigned int v140 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v273, 0);
      long long v141 = (void *)*((void *)&v278 + 1);
      v267[0] = *((void **)&v278 + 1);
      v267[1] = (void *)v140;
      if (v140) {
        long long v141 = (void *)mlir::ValueRange::offset_base(v267, v140);
      }
      v267[0] = v141;
      v267[1] = 0;
      uint64_t v142 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v267, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v142) {
        goto LABEL_141;
      }
      uint64_t v143 = *v142;
      unint64_t v144 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v145 = *(unsigned int *)(v143 + 16);
      if (!v145) {
        goto LABEL_141;
      }
      long long v146 = *(void **)(v143 + 8);
      unint64_t v147 = &v146[2 * v145];
      do
      {
        unint64_t v148 = v145 >> 1;
        uint64_t v149 = &v146[2 * (v145 >> 1)];
        unint64_t v151 = *v149;
        unint64_t v150 = v149 + 2;
        v145 += ~(v145 >> 1);
        if (v151 < v144) {
          long long v146 = v150;
        }
        else {
          unint64_t v145 = v148;
        }
      }
      while (v145);
      if (v146 != v147 && *v146 == v144) {
        uint64_t v152 = (void *)v146[1];
      }
      else {
LABEL_141:
      }
        uint64_t v152 = 0;
      v267[0] = v142;
      v267[1] = v152;
      uint64_t v153 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v267);
      unint64_t v155 = v154;
      uint64_t v156 = *(void *)(a1 + 96);
      uint64_t v157 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v258);
      uint64_t v158 = (uint64_t *)mlir::TypeConverter::convertType(v156, (void *)(*(void *)(v157 + 8) & 0xFFFFFFFFFFFFFFF8));
      unint64_t v159 = v158;
      if (!v158) {
        goto LABEL_151;
      }
      uint64_t v160 = *v158;
      unint64_t v161 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v162 = *(unsigned int *)(v160 + 16);
      if (!v162) {
        goto LABEL_151;
      }
      unint64_t v163 = *(void **)(v160 + 8);
      v164 = &v163[2 * v162];
      do
      {
        unint64_t v165 = v162 >> 1;
        unint64_t v166 = &v163[2 * (v162 >> 1)];
        unint64_t v168 = *v166;
        unint64_t v167 = v166 + 2;
        v162 += ~(v162 >> 1);
        if (v168 < v161) {
          unint64_t v163 = v167;
        }
        else {
          unint64_t v162 = v165;
        }
      }
      while (v162);
      if (v163 != v164 && *v163 == v161) {
        uint64_t v169 = (void *)v163[1];
      }
      else {
LABEL_151:
      }
        uint64_t v169 = 0;
      v267[0] = v159;
      v267[1] = v169;
      uint64_t v170 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v267);
      unint64_t v172 = v171;
      unint64_t v173 = mlir::anec::getIndexFromDim(3, v155);
      unint64_t v174 = mlir::anec::getIndexFromDim(4, v172);
      float v175 = (float)*(uint64_t *)(v153 + 8 * v173);
      float v176 = (float)*(uint64_t *)(v153 + 8 * v174);
      float v177 = (float)*(uint64_t *)(v170 + 8 * v173);
      float v178 = (float)*(uint64_t *)(v170 + 8 * v174);
      BOOL v179 = v139 != 0.0;
      if (v138 != 0.0) {
        BOOL v179 = 1;
      }
      BOOL v180 = (v131 + -1.0) * 0.5 != v139 || (v130 + -1.0) * 0.5 != v138;
      BOOL v181 = v131 != (float)(v177 / v175) || v130 != (float)(v178 / v176);
      BOOL v182 = v131 != (float)((float)(v177 + -1.0) / (float)(v175 + -1.0))
          || v130 != (float)((float)(v178 + -1.0) / (float)(v176 + -1.0));
      if (v179 || v181)
      {
        if (v179 || v182)
        {
          if (!v180 && !v181)
          {
            BOOL InferredResultTypes = 0;
            BOOL IsSize = 1;
            goto LABEL_172;
          }
LABEL_211:
          uint64_t v193 = a4[2];
          if (v193)
          {
            uint64_t v194 = v256;
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
          }
            }
          int v109 = 0;
          int v110 = 0;
LABEL_215:
          if (__dst != v282) {
            free(__dst);
          }
          if (v283 != v285) {
            free(v283);
          }
          if (v286 != v288) {
            free(v286);
          }
          goto LABEL_91;
        }
        BOOL IsSize = 1;
        BOOL InferredResultTypes = 1;
LABEL_169:
        if (IsSize)
        {
          v267[0] = &v268;
          long long v268 = 0uLL;
LABEL_178:
          v267[1] = (void *)0x600000002;
          uint64_t v184 = v281;
          if (v281 >= 2)
          {
            *(_OWORD *)__dst = v268;
          }
          else
          {
            if (HIDWORD(v281) > 1)
            {
              if (v281) {
                memmove(__dst, &v268, 8 * v281);
              }
              else {
                uint64_t v184 = 0;
              }
            }
            else
            {
              LODWORD(v281) = 0;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v282, 2uLL, 8);
              uint64_t v184 = 0;
            }
            if (v184 != LODWORD(v267[1])) {
              memcpy((char *)__dst + 8 * v184, (char *)v267[0] + 8 * v184, 8 * LODWORD(v267[1]) - 8 * v184);
            }
          }
          LODWORD(v281) = 2;
          LODWORD(v267[1]) = 0;
          if (v267[0] != &v268) {
            free(v267[0]);
          }
          v267[0] = (void *)2;
          uint64_t v195 = mlir::Builder::getIntegerType(v245, 0x40u, 0);
          uint64_t v196 = (void *)mlir::RankedTensorType::get((uint64_t)v267, 1, v195, 0);
          unint64_t v197 = v196;
          if (!v196) {
            goto LABEL_235;
          }
          uint64_t v198 = *v196;
          unint64_t v199 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v200 = *(unsigned int *)(v198 + 16);
          if (!v200) {
            goto LABEL_235;
          }
          unint64_t v201 = *(void **)(v198 + 8);
          unint64_t v202 = &v201[2 * v200];
          do
          {
            unint64_t v203 = v200 >> 1;
            unint64_t v204 = &v201[2 * (v200 >> 1)];
            unint64_t v206 = *v204;
            unint64_t v205 = v204 + 2;
            v200 += ~(v200 >> 1);
            if (v206 < v199) {
              unint64_t v201 = v205;
            }
            else {
              unint64_t v200 = v203;
            }
          }
          while (v200);
          if (v201 != v202 && *v201 == v199) {
            uint64_t v207 = v201[1];
          }
          else {
LABEL_235:
          }
            uint64_t v207 = 0;
          uint64_t v257 = (uint64_t **)mlir::DenseElementsAttr::getFromRawBuffer(v197, v207, __dst, 8 * v281, 8, 1, 0);
          uint64_t v208 = v289;
          uint64_t v209 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v266, -1.0);
          uint64_t v210 = llvm::APFloatBase::IEEEsingle(v209);
          llvm::APFloat::Storage::Storage(&v267[1], v266, v210);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v266);
          llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v258, -1.0);
          llvm::APFloat::Storage::Storage(&v266[1], v258, v210);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v258);
          v258[0] = mlir::OpBuilder::create<mlir::anec::Resize,mlir::Value &,unsigned long long &,unsigned long long &,llvm::APFloat,llvm::APFloat,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(v245, v249, &v255, v208, v208 + 1, (uint64_t)v267, (uint64_t)v266, &v251, (uint64_t *)&v257);
          v211 = (void *)v266[1];
          uint64_t v212 = llvm::APFloatBase::PPCDoubleDouble(v258[0]);
          if (v212 == v211) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v266[1]);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v266[1]);
          }
          if (v212 == v267[1]) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v267[1]);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v267[1]);
          }
          char v213 = mlir::anec::Resize::verifyAttributesWithFamily((uint64_t *)v258, 6);
          int v109 = v258[0];
          if (v213)
          {
            if (v244 == 1)
            {
              v267[0] = &v268;
              *(void *)&long long v268 = v35;
              *((void *)&v268 + 1) = v243;
              unint64_t v269 = v36;
              unint64_t v270 = v35;
              unint64_t v271 = v243;
              unint64_t v272 = v36;
              v267[1] = (void *)0x600000006;
              *(_OWORD *)long long v266 = xmmword_181110B40;
              uint64_t v214 = mlir::Builder::getIntegerType(v245, 0x40u, 0);
              unint64_t v215 = (void *)mlir::RankedTensorType::get((uint64_t)v266, 2, v214, 0);
              uint64_t v216 = v215;
              if (!v215) {
                goto LABEL_253;
              }
              uint64_t v217 = *v215;
              unint64_t v218 = mlir::TypeID::get<mlir::ShapedType>();
              unint64_t v219 = *(unsigned int *)(v217 + 16);
              if (!v219) {
                goto LABEL_253;
              }
              unint64_t v220 = *(void **)(v217 + 8);
              unint64_t v221 = &v220[2 * v219];
              do
              {
                unint64_t v222 = v219 >> 1;
                unint64_t v223 = &v220[2 * (v219 >> 1)];
                unint64_t v225 = *v223;
                unint64_t v224 = v223 + 2;
                v219 += ~(v219 >> 1);
                if (v225 < v218) {
                  unint64_t v220 = v224;
                }
                else {
                  unint64_t v219 = v222;
                }
              }
              while (v219);
              if (v220 != v221 && *v220 == v218) {
                uint64_t v226 = v220[1];
              }
              else {
LABEL_253:
              }
                uint64_t v226 = 0;
              uint64_t v250 = mlir::DenseElementsAttr::getFromRawBuffer(v216, v226, v267[0], 8 * LODWORD(v267[1]), 8, 1, 0);
              int v109 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::anec::Resize &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v245, v249, v258, &v250);
              if (v267[0] != &v268) {
                free(v267[0]);
              }
            }
            mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v254);
            if (v227 > 3)
            {
              int v110 = 1;
            }
            else
            {
              v267[0] = &v268;
              *(void *)&long long v268 = v35;
              *((void *)&v268 + 1) = v246;
              unint64_t v269 = v36;
              unint64_t v270 = v35;
              unint64_t v271 = v246;
              unint64_t v272 = v36;
              v267[1] = (void *)0x600000006;
              *(_OWORD *)long long v266 = xmmword_181110B40;
              uint64_t v228 = mlir::Builder::getIntegerType(v245, 0x40u, 0);
              unint64_t v229 = (void *)mlir::RankedTensorType::get((uint64_t)v266, 2, v228, 0);
              uint64_t v230 = v229;
              if (v229
                && (uint64_t v231 = *v229,
                    unint64_t v232 = mlir::TypeID::get<mlir::ShapedType>(),
                    unint64_t v233 = *(unsigned int *)(v231 + 16),
                    v233))
              {
                v234 = *(void **)(v231 + 8);
                uint64_t v235 = &v234[2 * v233];
                do
                {
                  unint64_t v236 = v233 >> 1;
                  unint64_t v237 = &v234[2 * (v233 >> 1)];
                  unint64_t v239 = *v237;
                  v238 = v237 + 2;
                  v233 += ~(v233 >> 1);
                  if (v239 < v232) {
                    v234 = v238;
                  }
                  else {
                    unint64_t v233 = v236;
                  }
                }
                while (v233);
                if (v234 != v235 && *v234 == v232) {
                  uint64_t v240 = v234[1];
                }
                else {
                  uint64_t v240 = 0;
                }
              }
              else
              {
                uint64_t v240 = 0;
              }
              uint64_t v250 = mlir::DenseElementsAttr::getFromRawBuffer(v230, v240, v267[0], 8 * LODWORD(v267[1]), 8, 1, 0);
              v266[0] = (uint64_t)v109 - 16;
              int v109 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v245, v249, v266, &v250);
              if (v267[0] != &v268) {
                free(v267[0]);
              }
              int v110 = 1;
            }
          }
          else
          {
            mlir::ConversionPatternRewriter::eraseOp((mlir::ConversionPatternRewriter *)a4, v258[0]);
            v267[0] = "requested attributes are not compatible with hardware requirements";
            LOWORD(v269) = 259;
            uint64_t v241 = v256;
            v266[0] = (uint64_t)v267;
            uint64_t v242 = a4[2];
            if (v242 && mlir::RewriterBase::Listener::classof(a4[2])) {
              (*(void (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(void *)v242 + 64))(v242, *((void *)v241 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v266);
            }
            int v109 = 0;
            int v110 = 0;
          }
          goto LABEL_215;
        }
LABEL_172:
        if (InferredResultTypes || IsSize)
        {
          if (InferredResultTypes || !IsSize)
          {
            uint64_t v188 = a4[2];
            if (v188)
            {
              unint64_t v189 = v256;
              if (mlir::RewriterBase::Listener::classof(a4[2])) {
            }
              }
            int v109 = 0;
            int v110 = 0;
            goto LABEL_215;
          }
          v267[0] = &v268;
          float v183 = &unk_1810FE350;
        }
        else
        {
          v267[0] = &v268;
          float v183 = &unk_181110BA0;
        }
        memset_pattern16(&v268, v183, 0x10uLL);
        goto LABEL_178;
      }
      BOOL IsSize = 0;
      BOOL InferredResultTypes = 0;
    }
    if (!InferredResultTypes) {
      goto LABEL_172;
    }
    goto LABEL_169;
  }
  uint64_t v87 = "Shape operand was not a constant";
LABEL_87:
  v273[0] = (void *)v87;
  LOWORD(v275) = 259;
  uint64_t v107 = v256;
  v267[0] = v273;
  uint64_t v108 = a4[2];
  if (v108 && mlir::RewriterBase::Listener::classof(a4[2])) {
    (*(void (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v108 + 64))(v108, *((void *)v107 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v267);
  }
  int v109 = 0;
  int v110 = 0;
LABEL_91:
  if (v289 != v291) {
    free(v289);
  }
  if (v292 != (mlir::Operation *)v294) {
    free(v292);
  }
  if (v110)
  {
    v273[0] = (char *)v109 - 16;
    uint64_t v111 = 1;
    mlir::ValueRange::ValueRange(v259, (uint64_t)v273, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)a2, v259[0], v259[1]);
  }
  else
  {
    v273[0] = "Conversion did not match a valid resize or a valid transformation supported by the hardware.";
    LOWORD(v275) = 259;
    v267[0] = v273;
    uint64_t v112 = a4[2];
    if (v112 && mlir::RewriterBase::Listener::classof(v112)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v112 + 64))(v112, *((void *)a2 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v267);
    }
    else {
      return 0;
    }
  }
  return v111;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)6>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Resize with custom scale and offset values not supported on ANE.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)6>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported alignCorners, centerResult for Resize\n");
}

void mlir::anonymous namespace'::ConvertInstanceNorm::~ConvertInstanceNorm(mlir::_anonymous_namespace_::ConvertInstanceNorm *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::InstanceNormOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::InstanceNormOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::InstanceNormOpGenericAdaptorBase::InstanceNormOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::InstanceNormOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::InstanceNormOpGenericAdaptorBase::InstanceNormOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::InstanceNormOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 48);
  uint64_t v9 = *(void *)(a3 + 56);
  unint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        unint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v33 = 259;
      v30[0] = v32;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::InstanceNormOp &>(mlir::mps::InstanceNormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v34[0] = *(_OWORD *)a3;
        v34[1] = v28;
        long long v29 = *(_OWORD *)(a3 + 48);
        uint64_t v34[2] = *(_OWORD *)(a3 + 32);
        v34[3] = v29;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  unint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::InstanceNormOp &>(mlir::mps::InstanceNormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertInstanceNorm::matchAndRewriteWithStaticShapes(uint64_t a1, unsigned int *a2, mlir::scf::detail::IfOpGenericAdaptorBase *a3, uint64_t a4)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  uint64_t v57 = a2;
  long long v6 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v57) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  unint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v56[0] = v6;
  v56[1] = v16;
  unsigned int ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(a3, 1u);
  unint64_t v18 = *((void *)a3 + 6);
  *(void *)&long long v58 = v18;
  *((void *)&v58 + 1) = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    unint64_t v18 = mlir::ValueRange::offset_base(&v58, ODSOperandIndexAndLength);
  }
  long long v58 = v18;
  uint64_t v19 = (void *)mlir::ValueRange::dereference_iterator(&v58, 0);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v56);
  v55[0] = mlir::getSortedUniquePromotedPositiveAxesAttr(v19, v20, 0, 0);
  v55[1] = v21;
  if (!(_BYTE)v21) {
    return 0;
  }
  unsigned int v22 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(a3, 0);
  unint64_t v23 = *((void *)a3 + 6);
  *(void *)&long long v58 = v23;
  *((void *)&v58 + 1) = v22;
  if (v22) {
    unint64_t v23 = mlir::ValueRange::offset_base(&v58, v22);
  }
  long long v58 = v23;
  unint64_t v24 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v58, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v24) {
    goto LABEL_25;
  }
  uint64_t v25 = *v24;
  unint64_t v26 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v27 = *(unsigned int *)(v25 + 16);
  if (!v27) {
    goto LABEL_25;
  }
  long long v28 = *(void **)(v25 + 8);
  long long v29 = &v28[2 * v27];
  do
  {
    unint64_t v30 = v27 >> 1;
    unint64_t v31 = &v28[2 * (v27 >> 1)];
    unint64_t v33 = *v31;
    unint64_t v32 = v31 + 2;
    v27 += ~(v27 >> 1);
    if (v33 < v26) {
      long long v28 = v32;
    }
    else {
      unint64_t v27 = v30;
    }
  }
  while (v27);
  if (v28 != v29 && *v28 == v26) {
    uint64_t v34 = v28[1];
  }
  else {
LABEL_25:
  }
    uint64_t v34 = 0;
  v54[0] = mlir::getRankPromotionTypeForANE((uint64_t)v24, v34);
  v54[1] = (uint64_t)v35;
  uint64_t v36 = *((void *)v57 + 3);
  uint64_t F16Type = mlir::Builder::getF16Type((mlir::Float16Type **)(a4 + 8), v35);
  LOBYTE(v58) = 0;
  char v59 = 0;
  v52[0] = mlir::ShapedType::cloneWith(v54, &v58, F16Type);
  v52[1] = v38;
  unsigned int v39 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(a3, 0);
  unint64_t v40 = *((void *)a3 + 6);
  *(void *)&long long v58 = v40;
  *((void *)&v58 + 1) = v39;
  if (v39) {
    unint64_t v40 = mlir::ValueRange::offset_base(&v58, v39);
  }
  long long v58 = v40;
  *(void *)&long long v58 = mlir::ValueRange::dereference_iterator(&v58, 0);
  uint64_t v53 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Cast,mlir::ShapedType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), v36, v52, (uint64_t *)&v58)- 16;
  uint64_t v41 = *((void *)v57 + 3);
  mlir::mps::detail::InstanceNormOpGenericAdaptorBase::getEpsilon(a3, (uint64_t)&v58);
  uint64_t v42 = mlir::OpBuilder::create<mlir::anec::InstanceNorm,mlir::Value &,mlir::DenseIntElementsAttr &,llvm::APFloat>((mlir::Float32Type **)(a4 + 8), v41, &v53, v55, (uint64_t)&v58);
  uint64_t v53 = (uint64_t)v42 - 16;
  unint64_t v43 = (void *)*((void *)&v58 + 1);
  if (llvm::APFloatBase::PPCDoubleDouble(v42) == v43) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)((char *)&v58 + 8));
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)((char *)&v58 + 8));
  }
  uint64_t v45 = *((void *)v57 + 3);
  unsigned int v46 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(a3, 0);
  unint64_t v47 = *((void *)a3 + 6);
  *(void *)&long long v58 = v47;
  *((void *)&v58 + 1) = v46;
  if (v46) {
    unint64_t v47 = mlir::ValueRange::offset_base(&v58, v46);
  }
  long long v58 = v47;
  uint64_t v48 = mlir::ValueRange::dereference_iterator(&v58, 0);
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v48);
  LOBYTE(v58) = 0;
  char v59 = 0;
  *(void *)&long long v58 = mlir::ShapedType::cloneWith(v54, &v58, ElementTypeOrSelf);
  *((void *)&v58 + 1) = v50;
  uint64_t v53 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Cast,mlir::ShapedType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), v45, (uint64_t *)&v58, &v53)- 16;
  uint64_t v44 = 1;
  mlir::ConversionPatternRewriter::replaceOp(a4, v57, (uint64_t)&v53, 1);
  return v44;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::InstanceNormOp &>(mlir::mps::InstanceNormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::InstanceNorm,mlir::Value &,mlir::DenseIntElementsAttr &,llvm::APFloat>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v29[38] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.instance_norm", (const unsigned __int8 *)0x12, Context);
  if (!v12)
  {
    __int16 v26 = 1283;
    void v25[2] = (uint64_t)"anec.instance_norm";
    v25[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v29, a2, v11);
  uint64_t v13 = *a3;
  uint64_t v14 = *a4;
  uint64_t v16 = *(void **)(a5 + 8);
  unint64_t v15 = (void *)(a5 + 8);
  unint64_t v18 = llvm::APFloatBase::PPCDoubleDouble(v17);
  if (v18 == v16) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v28, v15);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v28, (uint64_t)v15);
  }
  mlir::anec::InstanceNorm::build(a1, (uint64_t)v29, v13, v14, (uint64_t)v27);
  if (v18 == (void *)v28[0]) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v28);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v28);
  }
  uint64_t v19 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v29);
  if (*(_UNKNOWN **)(*((void *)v19 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::InstanceNorm,void>::id) {
    unint64_t v20 = v19;
  }
  else {
    unint64_t v20 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  return v20;
}

void mlir::anonymous namespace'::ConvertPermute::~ConvertPermute(mlir::_anonymous_namespace_::ConvertPermute *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PermuteOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::PermuteOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::PermuteOpGenericAdaptorBase::PermuteOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PermuteOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::PermuteOpGenericAdaptorBase::PermuteOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::PermuteOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  unint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        unint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PermuteOp &>(mlir::mps::PermuteOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  unint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PermuteOp &>(mlir::mps::PermuteOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertPermute::matchAndRewriteWithStaticShapes(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  v51[6] = *MEMORY[0x1E4F143B8];
  unint64_t v43 = a2;
  long long v45 = *(_OWORD *)(a3 + 40);
  if (*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43) + 8) >= 8uLL) {
    mlir::TypeID::get<mlir::ShapedType>();
  }
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  long long v5 = (void *)mlir::ValueRange::dereference_iterator(&v45, 1);
  unsigned int v46 = &v41;
  uint64_t v49 = v5;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v49);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&v46, DefiningOp))
  {
    uint64_t v8 = v42;
    uint64_t v7 = v43;
    long long v9 = v45;
    uint64_t v10 = v41;
    uint64_t v11 = (uint64_t *)(*(void *)(*(void *)(*((void *)v43 + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v11) {
      goto LABEL_14;
    }
    uint64_t v12 = *v11;
    unint64_t v13 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v14 = *(unsigned int *)(v12 + 16);
    if (!v14) {
      goto LABEL_14;
    }
    uint64_t v15 = *(void **)(v12 + 8);
    uint64_t v16 = &v15[2 * v14];
    do
    {
      unint64_t v17 = v14 >> 1;
      unint64_t v18 = &v15[2 * (v14 >> 1)];
      unint64_t v20 = *v18;
      uint64_t v19 = v18 + 2;
      v14 += ~(v14 >> 1);
      if (v20 < v13) {
        uint64_t v15 = v19;
      }
      else {
        unint64_t v14 = v17;
      }
    }
    while (v14);
    if (v15 != v16 && *v15 == v13) {
      uint64_t v21 = v15[1];
    }
    else {
LABEL_14:
    }
      uint64_t v21 = 0;
    v44[0] = v11;
    v44[1] = v21;
    uint64_t v49 = v51;
    uint64_t v50 = 0x600000000;
    mlir::getIntValues<long long>(v10, v8, (uint64_t)&v49, 1);
    unsigned int v46 = v48;
    uint64_t v47 = 0x400000000;
    uint64_t v22 = (uint64_t *)v49;
    uint64_t v23 = v50;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v44);
    char PositivePromotedAxes = mlir::getPositivePromotedAxes(v22, v23, v24, (uint64_t)&v46, 0, 0);
    if (PositivePromotedAxes)
    {
      if (v47)
      {
        size_t v26 = 8 * v47;
        uint64_t v27 = v46;
        long long v28 = (char *)operator new(v26);
        memcpy(v28, v27, v26);
        long long v29 = &v28[v26];
      }
      else
      {
        long long v28 = 0;
        long long v29 = 0;
      }
      unsigned __int8 v34 = Transpose;
      unint64_t v36 = Transpose >> 8;
      if (v28) {
        operator delete(v28);
      }
      uint64_t v35 = 1;
    }
    else
    {
      unsigned __int8 v34 = 0;
      uint64_t v35 = 0;
      unint64_t v36 = 0;
    }
    if (v46 != v48) {
      free(v46);
    }
    if (v49 != v51) {
      free(v49);
    }
    uint64_t v49 = (void *)(v34 | (v36 << 8));
    uint64_t v50 = v35;
    uint64_t v38 = v43;
    if (PositivePromotedAxes)
    {
      uint64_t v33 = 1;
      mlir::ConversionPatternRewriter::replaceOp(a4, v43, (uint64_t)&v49, 1);
      return v33;
    }
    uint64_t v39 = *(void *)(a4 + 16);
    if (v39 && mlir::RewriterBase::Listener::classof(v39)) {
    return 0;
    }
  }
  uint64_t v30 = *(void *)(a4 + 16);
  if (!v30) {
    return 0;
  }
  unint64_t v31 = v43;
  if (!mlir::RewriterBase::Listener::classof(v30)) {
    return 0;
  }
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PermuteOp &>(mlir::mps::PermuteOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPermute::matchAndRewriteWithStaticShapes(mlir::mps::PermuteOp,mlir::mps::PermuteOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: Permute can be lowered to Transpose only if indices argument is a constant \n");
}

uint64_t mlir::anonymous namespace'::createTranspose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unint64_t a5, uint64_t a6)
{
  v58[1] = *MEMORY[0x1E4F143B8];
  v56[0] = a2;
  v56[1] = a3;
  uint64_t v10 = (uint64_t *)(*(void *)(*(void *)(*(void *)(a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_10;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_10;
  }
  unint64_t v14 = *(void **)(v11 + 8);
  uint64_t v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    unint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    unint64_t v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      unint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_10:
  }
    uint64_t v20 = 0;
  v48[0] = v10;
  v48[1] = v20;
  unint64_t v52 = v55;
  int v54 = 4;
  if (a5 < 5)
  {
    if (!a5)
    {
      unsigned int v53 = 0;
      uint64_t v49 = v51;
      uint64_t v50 = 0x500000000;
      goto LABEL_49;
    }
    bzero(v55, 8 * a5);
    uint64_t v21 = (int64x2_t *)v55;
  }
  else
  {
    unsigned int v53 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v52, v55, a5, 8);
    uint64_t v21 = (int64x2_t *)v52;
    bzero(v52, 8 * a5);
  }
  unsigned int v53 = a5;
  if (!a5) {
    goto LABEL_38;
  }
  unint64_t v22 = (a5 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (v22 < 3)
  {
    uint64_t v23 = 0;
    unint64_t v24 = (uint64_t *)v21;
    do
LABEL_21:
      *v24++ = v23++;
    while (v24 != (uint64_t *)((char *)v21 + 8 * a5));
    goto LABEL_22;
  }
  unint64_t v25 = v22 + 1;
  uint64_t v23 = (v22 + 1) & 0x3FFFFFFFFFFFFFFCLL;
  unint64_t v24 = &v21->i64[v23];
  int64x2_t v26 = (int64x2_t)xmmword_1810FE2E0;
  uint64_t v27 = v21 + 1;
  int64x2_t v28 = vdupq_n_s64(2uLL);
  int64x2_t v29 = vdupq_n_s64(4uLL);
  uint64_t v30 = v23;
  do
  {
    v27[-1] = v26;
    *uint64_t v27 = vaddq_s64(v26, v28);
    int64x2_t v26 = vaddq_s64(v26, v29);
    v27 += 2;
    v30 -= 4;
  }
  while (v30);
  if (v25 != v23) {
    goto LABEL_21;
  }
LABEL_22:
  if (a5)
  {
    uint64_t v31 = 8 * a5;
    do
    {
      uint64_t v32 = v21->i64[0];
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v48);
      if (v32 == 2) {
        uint64_t v34 = 3;
      }
      else {
        uint64_t v34 = v32;
      }
      if (v32) {
        uint64_t v35 = 3;
      }
      else {
        uint64_t v35 = 1;
      }
      if (v33 != 2) {
        uint64_t v35 = v32;
      }
      if (v33 != 3) {
        uint64_t v34 = v35;
      }
      if (v33 < 2) {
        uint64_t v34 = 3;
      }
      v21->i64[0] = v34;
      uint64_t v21 = (int64x2_t *)((char *)v21 + 8);
      v31 -= 8;
    }
    while (v31);
    uint64_t v21 = (int64x2_t *)v52;
    unsigned int v36 = v53;
    goto LABEL_39;
  }
LABEL_38:
  unsigned int v36 = a5;
LABEL_39:
  uint64_t v49 = v51;
  uint64_t v50 = 0x500000000;
  if (v36)
  {
    unsigned int v37 = 0;
    uint64_t v38 = 8 * v36 - 8;
    uint64_t v39 = 8 * a5 - 8;
    do
    {
      uint64_t v40 = *a4;
      uint64_t v41 = v21->i64[0];
      if (*a4 != v21->i64[0])
      {
        if (v37 >= HIDWORD(v50))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v37 + 1, 16);
          unsigned int v37 = v50;
        }
        uint64_t v42 = (char *)v49 + 16 * v37;
        *uint64_t v42 = v40;
        v42[1] = v41;
        unsigned int v37 = v50 + 1;
        LODWORD(v50) = v50 + 1;
      }
      if (!v39) {
        break;
      }
      ++a4;
      uint64_t v21 = (int64x2_t *)((char *)v21 + 8);
      uint64_t v43 = v38;
      v38 -= 8;
      v39 -= 8;
    }
    while (v43);
  }
LABEL_49:
  uint64_t v44 = *(void *)(a1 + 24);
  uint64_t v47 = mlir::ValueRange::dereference_iterator(v56, 0);
  v57[0] = v58;
  v57[1] = (void *)0x100000000;
  mlir::OpBuilder::createOrFold<mlir::anec::Transpose,mlir::Value,llvm::SmallVector<std::pair<unsigned long long,unsigned long long>,5u> &>((mlir::Builder *)(a6 + 8), (uint64_t)v57, v44, &v47, (uint64_t)&v49);
  uint64_t v45 = *(void *)v57[0];
  if (v57[0] != v58) {
    free(v57[0]);
  }
  if (v49 != v51) {
    free(v49);
  }
  if (v52 != v55) {
    free(v52);
  }
  return v45;
}

void mlir::OpBuilder::createOrFold<mlir::anec::Transpose,mlir::Value,llvm::SmallVector<std::pair<unsigned long long,unsigned long long>,5u> &>(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  v25[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a3;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.transpose", (const unsigned __int8 *)0xE, Context);
  if (!v12)
  {
    __int16 v24 = 1283;
    void v23[2] = (uint64_t)"anec.transpose";
    v23[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a3, v11);
  mlir::anec::Transpose::build(a1, (uint64_t)v25, *a4, *(uint64_t **)a5, *(unsigned int *)(a5 + 8));
  unint64_t v14 = (mlir::GenericProgramPoint *)mlir::Operation::create((mlir::Operation *)v25, v13);
  uint64_t v15 = *((void *)a1 + 2);
  if (v15)
  {
    unint64_t v16 = (uint64_t *)*((void *)a1 + 3);
    llvm::ilist_traits<mlir::Operation>::addNodeToList(v15 + 32, (uint64_t)v14);
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
    uint64_t v17 = *v16;
    *unint64_t v18 = *v16;
    v18[1] = (uint64_t)v16;
    *(void *)(v17 + 8) = v18;
    *unint64_t v16 = (uint64_t)v18;
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
  }
  if (mlir::OpBuilder::tryFold(a1, (uint64_t)v14, a2))
  {
    mlir::Operation::erase(v14);
  }
  else
  {
    uint64_t v19 = *((void *)a1 + 1);
    if (v19) {
      (*(void (**)(uint64_t, mlir::GenericProgramPoint *))(*(void *)v19 + 16))(v19, v14);
    }
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPermute::matchAndRewriteWithStaticShapes(mlir::mps::PermuteOp,mlir::mps::PermuteOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: Could not extract valid positive and rank-promoted axes. \n");
}

void mlir::anonymous namespace'::ConvertGatherND::~ConvertGatherND(mlir::_anonymous_namespace_::ConvertGatherND *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GatherNDOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::GatherNDOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::GatherNDOpGenericAdaptorBase::GatherNDOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GatherNDOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::GatherNDOpGenericAdaptorBase::GatherNDOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::GatherNDOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 56);
  uint64_t v9 = *(void *)(a3 + 64);
  unsigned int v36 = v8;
  uint64_t v37 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        unsigned int v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v37 = v23;
        if (v36)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v36);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v33 = 259;
      v30[0] = v32;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherNDOp &>(mlir::mps::GatherNDOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 48);
        uint64_t v34[2] = *(_OWORD *)(a3 + 32);
        v34[3] = v28;
        uint64_t v35 = *(void *)(a3 + 64);
        long long v29 = *(_OWORD *)(a3 + 16);
        v34[0] = *(_OWORD *)a3;
        v34[1] = v29;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v37;
    if (v36 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  uint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherNDOp &>(mlir::mps::GatherNDOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertGatherND::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v200 = *MEMORY[0x1E4F143B8];
  uint64_t v181 = a2;
  long long v194 = *(_OWORD *)(a3 + 56);
  long long v5 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v181) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v180[0] = v5;
  v180[1] = v15;
  uint64_t v16 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v181) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    __int16 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  v179[0] = v16;
  v179[1] = v26;
  uint64_t v27 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v181) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27) {
    goto LABEL_30;
  }
  uint64_t v28 = *v27;
  unint64_t v29 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v30 = *(unsigned int *)(v28 + 16);
  if (!v30) {
    goto LABEL_30;
  }
  uint64_t v31 = *(void **)(v28 + 8);
  uint64_t v32 = &v31[2 * v30];
  do
  {
    unint64_t v33 = v30 >> 1;
    uint64_t v34 = &v31[2 * (v30 >> 1)];
    unint64_t v36 = *v34;
    uint64_t v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29) {
      uint64_t v31 = v35;
    }
    else {
      unint64_t v30 = v33;
    }
  }
  while (v30);
  if (v31 != v32 && *v31 == v29) {
    uint64_t v37 = v31[1];
  }
  else {
LABEL_30:
  }
    uint64_t v37 = 0;
  v178[0] = v27;
  v178[1] = v37;
  unsigned int Count = mlir::pdl_interp::CheckOperandCountOp::getCount((mlir::pdl_interp::CheckOperandCountOp *)&v181);
  uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v179);
  uint64_t v41 = *(void *)(ArgAttrsAttr + 8 * v40 - 8);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v180);
  if (v42 > 5
    || (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v179), v43 > 5)
    || (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v178), v44 >= 6))
  {
    uint64_t v45 = *(void *)(a4 + 16);
    if (!v45) {
      return 0;
    }
    uint64_t v46 = v181;
    uint64_t result = mlir::RewriterBase::Listener::classof(v45);
    if (result) {
    return result;
    }
  }
  uint64_t v177 = mlir::ValueRange::dereference_iterator(&v194, 1);
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf((void *)(*(void *)(v177 + 8) & 0xFFFFFFFFFFFFFFF8));
  if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) >= 9
    && !mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf))
  {
    uint64_t v49 = (uint64_t *)(*(void *)(v177 + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v49) {
      goto LABEL_49;
    }
    uint64_t v50 = *v49;
    unint64_t v51 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v52 = *(unsigned int *)(v50 + 16);
    if (!v52) {
      goto LABEL_49;
    }
    unsigned int v53 = *(void **)(v50 + 8);
    int v54 = &v53[2 * v52];
    do
    {
      unint64_t v55 = v52 >> 1;
      int64x2_t v56 = &v53[2 * (v52 >> 1)];
      unint64_t v58 = *v56;
      uint64_t v57 = v56 + 2;
      v52 += ~(v52 >> 1);
      if (v58 < v51) {
        unsigned int v53 = v57;
      }
      else {
        unint64_t v52 = v55;
      }
    }
    while (v52);
    if (v53 != v54 && *v53 == v51) {
      uint64_t v59 = v53[1];
    }
    else {
LABEL_49:
    }
      uint64_t v59 = 0;
    uint64_t v191 = v49;
    uint64_t v192 = v59;
    uint64_t F16Type = mlir::Builder::getF16Type((mlir::Float16Type **)(a4 + 8), v48);
    LOBYTE(v197) = 0;
    LOBYTE(v198) = 0;
    mlir::ShapedType::cloneWith((uint64_t *)&v191, &v197, F16Type);
    uint64_t v61 = *(void *)(v181 + 24);
    uint64_t v191 = (void *)mlir::Builder::getF16Type((mlir::Float16Type **)(a4 + 8), v62);
    *(void *)&long long v197 = &v198;
    *((void *)&v197 + 1) = 0x100000000;
    mlir::OpBuilder::createOrFold<mlir::mps::CastOp,mlir::Value &,mlir::FloatType>(a4 + 8, (uint64_t)&v197, v61, &v177, (uint64_t *)&v191);
    uint64_t v63 = *(void *)v197;
    if ((uint64_t *)v197 != &v198) {
      free((void *)v197);
    }
    uint64_t v177 = v63;
  }
  uint64_t v64 = Count;
  uint64_t v191 = v193;
  uint64_t v192 = 0x500000000;
  uint64_t v65 = (unsigned char *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v180);
  uint64_t v66 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v180);
  unsigned int v67 = 0;
  unsigned int v69 = (unsigned char *)(v66 + 8 * v68);
  LODWORD(v192) = 0;
  unint64_t v70 = (v69 - v65) >> 3;
  if (v70 > HIDWORD(v192))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v191, v193, v70, 8);
    unsigned int v67 = v192;
  }
  if (v69 != v65)
  {
    memcpy((char *)v191 + 8 * v67, v65, v69 - v65);
    unsigned int v67 = v192;
  }
  LODWORD(v192) = v67 + ((unint64_t)(v69 - v65) >> 3);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v179);
  uint64_t v72 = v71 + ~(v41 + v64);
  uint64_t v73 = v72 & ~(v72 >> 63);
  if (v72 >= 1)
  {
    uint64_t v74 = v72 & ~(v72 >> 63);
    do
    {
      *(void *)&long long v197 = 1;
      llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v191, (uint64_t)v191 + 8 * v64, (uint64_t *)&v197);
      --v74;
    }
    while (v74);
  }
  unsigned int v75 = v192;
  uint64_t v76 = 5 - v192;
  if (v192 <= 4)
  {
    uint64_t v77 = v76 <= 1 ? 1 : 5 - v192;
    *(void *)&long long v197 = 1;
    llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v191, (uint64_t)v191, (uint64_t *)&v197);
    if (v75 <= 3)
    {
      *(void *)&long long v197 = 1;
      llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v191, (uint64_t)v191, (uint64_t *)&v197);
      if (v77 != 2)
      {
        *(void *)&long long v197 = 1;
        llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v191, (uint64_t)v191, (uint64_t *)&v197);
        if (v77 != 3)
        {
          *(void *)&long long v197 = 1;
          llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v191, (uint64_t)v191, (uint64_t *)&v197);
          if (v77 != 4)
          {
            *(void *)&long long v197 = 1;
            llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v191, (uint64_t)v191, (uint64_t *)&v197);
          }
        }
      }
    }
  }
  uint64_t v188 = v190;
  unint64_t v78 = (char *)v191;
  unint64_t v79 = (char *)v191 + 8 * v76 + 8 * v64;
  uint64_t v189 = 0x500000000;
  size_t v80 = 8 * v76 + 8 * v64;
  if (v80 >= 0x29)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v188, v190, (uint64_t)v80 >> 3, 8);
    unsigned int v81 = v189;
    if (v78 == v79) {
      goto LABEL_77;
    }
    goto LABEL_76;
  }
  unsigned int v81 = 0;
  if (v191 != v79)
  {
LABEL_76:
    memcpy((char *)v188 + 8 * v81, v78, v80);
    unsigned int v81 = v189;
  }
LABEL_77:
  unsigned int v82 = v81 + (v80 >> 3);
  LODWORD(v189) = v82;
  unint64_t v83 = -v72 & ~(-v72 >> 63);
  if (v72 < 0)
  {
    if (v83 <= 1) {
      uint64_t v95 = 1;
    }
    else {
      uint64_t v95 = -v72 & ~(-v72 >> 63);
    }
    do
    {
      if (v82 >= HIDWORD(v189))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v188, v190, v82 + 1, 8);
        unsigned int v82 = v189;
      }
      *((void *)v188 + v82) = 1;
      unsigned int v82 = v189 + 1;
      LODWORD(v189) = v189 + 1;
      --v95;
    }
    while (v95);
  }
  uint64_t v84 = (char *)v188 + 8 * v82;
  unint64_t v85 = (char *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v179) + 8 * v64);
  uint64_t v86 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v179);
  llvm::SmallVectorImpl<mlir::Attribute>::insert<mlir::Attribute const*,void>((uint64_t)&v188, (uint64_t)v84, v85, (char *)(v86 + 8 * v87 - 8));
  uint64_t v88 = v73 + v64 + v76;
  uint64_t v89 = 5 - (v41 + v88);
  if (v89 >= 1)
  {
    uint64_t v90 = 0;
    unsigned int v91 = v189;
    do
    {
      if (v91 >= HIDWORD(v189))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v188, v190, v91 + 1, 8);
        unsigned int v91 = v189;
      }
      *((void *)v188 + v91) = 1;
      unsigned int v91 = v189 + 1;
      LODWORD(v189) = v189 + 1;
      ++v90;
    }
    while (v90 < v89);
  }
  BOOL v185 = v187;
  uint64_t v186 = 0x500000000;
  LODWORD(v92) = 0;
  if (v41)
  {
    uint64_t v93 = v41;
    do
    {
      if (v92 >= HIDWORD(v186))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v185, v187, v92 + 1, 8);
        LODWORD(v92) = v186;
      }
      *((void *)v185 + v92) = v88;
      LODWORD(v92) = v186 + 1;
      LODWORD(v186) = v186 + 1;
      ++v88;
      --v93;
    }
    while (v93);
    uint64_t v94 = v185;
  }
  else
  {
    uint64_t v94 = v187;
  }
  BOOL v182 = v184;
  uint64_t v183 = 0x500000000;
  if (*(void *)&v94[8 * v92 - 8] <= 2uLL)
  {
    uint64_t v92 = v92;
  }
  else
  {
    unint64_t v96 = (uint64_t *)(*(void *)(v177 + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v96) {
      goto LABEL_107;
    }
    uint64_t v97 = *v96;
    unint64_t v98 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v99 = *(unsigned int *)(v97 + 16);
    if (!v99) {
      goto LABEL_107;
    }
    uint64_t v100 = *(void **)(v97 + 8);
    unint64_t v101 = &v100[2 * v99];
    do
    {
      unint64_t v102 = v99 >> 1;
      uint64_t v103 = &v100[2 * (v99 >> 1)];
      unint64_t v105 = *v103;
      unint64_t v104 = v103 + 2;
      v99 += ~(v99 >> 1);
      if (v105 < v98) {
        uint64_t v100 = v104;
      }
      else {
        unint64_t v99 = v102;
      }
    }
    while (v99);
    if (v100 != v101 && *v100 == v98) {
      uint64_t v106 = v100[1];
    }
    else {
LABEL_107:
    }
      uint64_t v106 = 0;
    *(void *)&long long v197 = v96;
    *((void *)&v197 + 1) = v106;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v197);
    unsigned int v108 = v183;
    if (v107)
    {
      uint64_t v109 = v107;
      unint64_t v110 = 0;
      uint64_t v111 = *((void *)v185 + v186 - 1);
      uint64_t v112 = v83 + v107 - v111 + 1;
      uint64_t v113 = v107 - 1;
      uint64_t v114 = v83 - v111 + v107 + 1;
      do
      {
        if (v114 == v110) {
          uint64_t v115 = v113;
        }
        else {
          uint64_t v115 = (__PAIR128__(v110, v112) - v110) >> 64;
        }
        if (v108 >= HIDWORD(v183))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v182, v184, v108 + 1, 8);
          unsigned int v108 = v183;
        }
        *((void *)v182 + v108) = v115;
        unsigned int v108 = v183 + 1;
        LODWORD(v183) = v183 + 1;
        ++v110;
      }
      while (v109 != v110);
    }
    uint64_t v116 = v182;
    uint64_t v117 = *(void *)(v181 + 24);
    *(void *)&long long v197 = &v198;
    *((void *)&v197 + 1) = 0x500000000;
    if (v108)
    {
      uint64_t v118 = 0;
      uint64_t v119 = 8 * v108;
      do
      {
        if (v118 != v116[v118])
        {
          unint64_t __src = v116[v118];
          uint64_t v196 = v118;
          llvm::SmallVectorImpl<mlir::Attribute>::insert<mlir::Attribute const*,void>((uint64_t)&v197, v197 + 8 * DWORD2(v197), (char *)&__src, (char *)&v197);
        }
        ++v118;
        v119 -= 8;
      }
      while (v119);
      unint64_t v120 = (unint64_t)DWORD2(v197) >> 1;
    }
    else
    {
      unint64_t v120 = 0;
    }
    unint64_t __src = v120;
    uint64_t v196 = 2;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    unint64_t v122 = (void *)mlir::RankedTensorType::get((uint64_t)&__src, 2, IntegerType, 0);
    uint64_t v123 = v122;
    if (!v122) {
      goto LABEL_134;
    }
    uint64_t v124 = *v122;
    unint64_t v125 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v126 = *(unsigned int *)(v124 + 16);
    if (!v126) {
      goto LABEL_134;
    }
    unint64_t v127 = *(void **)(v124 + 8);
    uint64_t v128 = &v127[2 * v126];
    do
    {
      unint64_t v129 = v126 >> 1;
      float v130 = &v127[2 * (v126 >> 1)];
      unint64_t v132 = *v130;
      float v131 = v130 + 2;
      v126 += ~(v126 >> 1);
      if (v132 < v125) {
        unint64_t v127 = v131;
      }
      else {
        unint64_t v126 = v129;
      }
    }
    while (v126);
    if (v127 != v128 && *v127 == v125) {
      uint64_t v133 = v127[1];
    }
    else {
LABEL_134:
    }
      uint64_t v133 = 0;
    uint64_t v134 = mlir::DenseElementsAttr::getFromRawBuffer(v123, v133, v197, 8 * DWORD2(v197), 8, 1, 0);
    if ((uint64_t *)v197 != &v198) {
      free((void *)v197);
    }
    *(void *)&long long v197 = v134;
    uint64_t v177 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v117, &v177, (uint64_t *)&v197)- 16;
    uint64_t v92 = v186;
  }
  *(void *)&long long v197 = v92;
  uint64_t v135 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  unint64_t v136 = (void *)mlir::RankedTensorType::get((uint64_t)&v197, 1, v135, 0);
  float v137 = v136;
  if (!v136) {
    goto LABEL_147;
  }
  uint64_t v138 = *v136;
  unint64_t v139 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v140 = *(unsigned int *)(v138 + 16);
  if (!v140) {
    goto LABEL_147;
  }
  long long v141 = *(void **)(v138 + 8);
  uint64_t v142 = &v141[2 * v140];
  do
  {
    unint64_t v143 = v140 >> 1;
    unint64_t v144 = &v141[2 * (v140 >> 1)];
    unint64_t v146 = *v144;
    unint64_t v145 = v144 + 2;
    v140 += ~(v140 >> 1);
    if (v146 < v139) {
      long long v141 = v145;
    }
    else {
      unint64_t v140 = v143;
    }
  }
  while (v140);
  if (v141 != v142 && *v141 == v139) {
    uint64_t v147 = v141[1];
  }
  else {
LABEL_147:
  }
    uint64_t v147 = 0;
  unint64_t __src = mlir::DenseElementsAttr::getFromRawBuffer(v137, v147, v185, 8 * v186, 8, 1, 0);
  unint64_t v148 = v191;
  uint64_t v149 = (mlir::AffineMap *)v192;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v180);
  uint64_t v175 = mlir::MemRefType::get(v148, v149, OperandRange, 0, 0, 0);
  long long v197 = *(_OWORD *)v188;
  uint64_t v198 = *((void *)v188 + 2) * v41;
  long long v199 = *(_OWORD *)((char *)v188 + 24);
  uint64_t v151 = mlir::getElementTypeOrSelf(v177);
  uint64_t v174 = mlir::MemRefType::get(&v197, (mlir::AffineMap *)5, v151, 0, 0, 0);
  uint64_t v152 = *(void *)(v181 + 24);
  *(void *)&long long v197 = mlir::ValueRange::dereference_iterator(&v194, 0);
  uint64_t v173 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), v152, &v175, (uint64_t *)&v197)- 16;
  uint64_t v177 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v181 + 24), &v174, &v177)- 16;
  unint64_t v172 = mlir::OpBuilder::create<mlir::anec::GatherND,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), *(void *)(v181 + 24), &v173, &v177, (uint64_t *)&__src);
  uint64_t v153 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v178);
  unint64_t v155 = v154;
  uint64_t v156 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v178);
  uint64_t v157 = (uint64_t *)mlir::MemRefType::get(v153, v155, v156, 0, 0, 0);
  uint64_t v158 = (uint64_t)v157;
  uint64_t v159 = v181;
  if (!v157) {
    goto LABEL_157;
  }
  uint64_t v160 = *v157;
  unint64_t v161 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v162 = *(unsigned int *)(v160 + 16);
  if (!v162) {
    goto LABEL_157;
  }
  unint64_t v163 = *(void **)(v160 + 8);
  v164 = &v163[2 * v162];
  do
  {
    unint64_t v165 = v162 >> 1;
    unint64_t v166 = &v163[2 * (v162 >> 1)];
    unint64_t v168 = *v166;
    unint64_t v167 = v166 + 2;
    v162 += ~(v162 >> 1);
    if (v168 < v161) {
      unint64_t v163 = v167;
    }
    else {
      unint64_t v162 = v165;
    }
  }
  while (v162);
  if (v163 != v164 && *v163 == v161) {
    uint64_t v169 = v163[1];
  }
  else {
LABEL_157:
  }
    uint64_t v169 = 0;
  *(void *)&long long v197 = mlir::getRankPromotionTypeForANE(v158, v169);
  *((void *)&v197 + 1) = v170;
  unint64_t v171 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::ShapedType,mlir::anec::GatherND &>((mlir::OpBuilder *)(a4 + 8), *(void *)(v159 + 24), (uint64_t *)&v197, &v172);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v159, v171);
  if (v182 != v184) {
    free(v182);
  }
  if (v185 != v187) {
    free(v185);
  }
  if (v188 != v190) {
    free(v188);
  }
  if (v191 != v193) {
    free(v191);
  }
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherNDOp &>(mlir::mps::GatherNDOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::GatherND,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.gather_nd", (const unsigned __int8 *)0xE, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"anec.gather_nd";
    v19[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::anec::GatherND::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GatherND,void>::id) {
    unint64_t v14 = v13;
  }
  else {
    unint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertGatherND::matchAndRewriteWithStaticShapes(mlir::mps::GatherNDOp,mlir::mps::GatherNDOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Inputs / output with rank > 5 not supported");
}

void mlir::OpBuilder::createOrFold<mlir::mps::CastOp,mlir::Value &,mlir::FloatType>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  v25[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a3;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, Context);
  if (!v12)
  {
    __int16 v24 = 1283;
    void v23[2] = (uint64_t)"mps.cast";
    v23[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a3, v11);
  mlir::mps::CastOp::build((mlir::UnknownLoc **)a1, (uint64_t)v25, *a4, *a5);
  unint64_t v14 = (mlir::GenericProgramPoint *)mlir::Operation::create((mlir::Operation *)v25, v13);
  uint64_t v15 = *(void *)(a1 + 16);
  if (v15)
  {
    uint64_t v16 = *(uint64_t **)(a1 + 24);
    llvm::ilist_traits<mlir::Operation>::addNodeToList(v15 + 32, (uint64_t)v14);
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
    uint64_t v17 = *v16;
    *__int16 v18 = *v16;
    v18[1] = (uint64_t)v16;
    *(void *)(v17 + 8) = v18;
    *uint64_t v16 = (uint64_t)v18;
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
  }
  if (mlir::OpBuilder::tryFold((void *)a1, (uint64_t)v14, a2))
  {
    mlir::Operation::erase(v14);
  }
  else
  {
    uint64_t v19 = *(void *)(a1 + 8);
    if (v19) {
      (*(void (**)(uint64_t, mlir::GenericProgramPoint *))(*(void *)v19 + 16))(v19, v14);
    }
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Reshape,mlir::ShapedType,mlir::anec::GatherND &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, void *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.reshape", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.reshape";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Broadcast::build((uint64_t)a1, (uint64_t)v19, *a3, *a4 - 16);
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Reshape,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::anonymous namespace'::ConvertGather::~ConvertGather(mlir::_anonymous_namespace_::ConvertGather *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GatherOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::GatherOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::GatherOpGenericAdaptorBase::GatherOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GatherOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::GatherOpGenericAdaptorBase::GatherOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::GatherOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 56);
  uint64_t v9 = *(void *)(a3 + 64);
  unint64_t v36 = v8;
  uint64_t v37 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        unint64_t v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v37 = v23;
        if (v36)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v36);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v33 = 259;
      v30[0] = v32;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherOp &>(mlir::mps::GatherOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 48);
        uint64_t v34[2] = *(_OWORD *)(a3 + 32);
        v34[3] = v28;
        uint64_t v35 = *(void *)(a3 + 64);
        long long v29 = *(_OWORD *)(a3 + 16);
        v34[0] = *(_OWORD *)a3;
        v34[1] = v29;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v37;
    if (v36 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  uint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherOp &>(mlir::mps::GatherOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertGather::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, mlir::mps::detail::GatherOpGenericAdaptorBase *a3, mlir::Float16Type **a4)
{
  uint64_t v169 = *MEMORY[0x1E4F143B8];
  uint64_t v152 = a2;
  uint64_t v6 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v152) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v151[0] = v6;
  v151[1] = v16;
  uint64_t v17 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v152) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v17) {
    goto LABEL_20;
  }
  uint64_t v18 = *v17;
  unint64_t v19 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v20 = *(unsigned int *)(v18 + 16);
  if (!v20) {
    goto LABEL_20;
  }
  uint64_t v21 = *(void **)(v18 + 8);
  __int16 v22 = &v21[2 * v20];
  do
  {
    unint64_t v23 = v20 >> 1;
    __int16 v24 = &v21[2 * (v20 >> 1)];
    unint64_t v26 = *v24;
    uint64_t v25 = v24 + 2;
    v20 += ~(v20 >> 1);
    if (v26 < v19) {
      uint64_t v21 = v25;
    }
    else {
      unint64_t v20 = v23;
    }
  }
  while (v20);
  if (v21 != v22 && *v21 == v19) {
    uint64_t v27 = v21[1];
  }
  else {
LABEL_20:
  }
    uint64_t v27 = 0;
  v150[0] = v17;
  v150[1] = v27;
  long long v28 = (uint64_t *)(*(void *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v152) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v28) {
    goto LABEL_30;
  }
  uint64_t v29 = *v28;
  unint64_t v30 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v31 = *(unsigned int *)(v29 + 16);
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v32 = *(void **)(v29 + 8);
  __int16 v33 = &v32[2 * v31];
  do
  {
    unint64_t v34 = v31 >> 1;
    uint64_t v35 = &v32[2 * (v31 >> 1)];
    unint64_t v37 = *v35;
    unint64_t v36 = v35 + 2;
    v31 += ~(v31 >> 1);
    if (v37 < v30) {
      uint64_t v32 = v36;
    }
    else {
      unint64_t v31 = v34;
    }
  }
  while (v31);
  if (v32 != v33 && *v32 == v30) {
    uint64_t v38 = v32[1];
  }
  else {
LABEL_30:
  }
    uint64_t v38 = 0;
  v149[0] = v28;
  v149[1] = v38;
  unsigned int BatchDims = mlir::mps::detail::GatherOpGenericAdaptorBase::getBatchDims(a3);
  unsigned int ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(a3, 1u);
  unint64_t v41 = *((void *)a3 + 7);
  *(void *)&long long v154 = v41;
  *((void *)&v154 + 1) = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    unint64_t v41 = mlir::ValueRange::offset_base(&v154, ODSOperandIndexAndLength);
  }
  long long v154 = v41;
  uint64_t v148 = mlir::ValueRange::dereference_iterator(&v154, 0);
  uint64_t ElementTypeOrSelf = (void *)mlir::getElementTypeOrSelf(v148);
  if ((unint64_t)mlir::mps::getElementBitWidth(ElementTypeOrSelf) >= 9
    && !mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf))
  {
    uint64_t v43 = (unint64_t *)(*(void *)(v148 + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v43) {
      goto LABEL_44;
    }
    unint64_t v44 = *v43;
    unint64_t v45 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v46 = *(unsigned int *)(v44 + 16);
    if (!v46) {
      goto LABEL_44;
    }
    uint64_t v47 = *(void **)(v44 + 8);
    uint64_t v48 = &v47[2 * v46];
    do
    {
      unint64_t v49 = v46 >> 1;
      uint64_t v50 = &v47[2 * (v46 >> 1)];
      unint64_t v52 = *v50;
      unint64_t v51 = v50 + 2;
      v46 += ~(v46 >> 1);
      if (v52 < v45) {
        uint64_t v47 = v51;
      }
      else {
        unint64_t v46 = v49;
      }
    }
    while (v46);
    if (v47 != v48 && *v47 == v45) {
      uint64_t v53 = v47[1];
    }
    else {
LABEL_44:
    }
      uint64_t v53 = 0;
    uint64_t v159 = v43;
    uint64_t v160 = v53;
    uint64_t F16Type = mlir::Builder::getF16Type(a4 + 1, v42);
    LOBYTE(v154) = 0;
    v155[0] = 0;
    mlir::ShapedType::cloneWith((uint64_t *)&v159, &v154, F16Type);
    uint64_t v55 = *(void *)(v152 + 24);
    uint64_t v159 = (unint64_t *)mlir::Builder::getF16Type(a4 + 1, v56);
    *(void *)&long long v154 = v155;
    *((void *)&v154 + 1) = 0x100000000;
    mlir::OpBuilder::createOrFold<mlir::mps::CastOp,mlir::Value &,mlir::FloatType>((uint64_t)(a4 + 1), (uint64_t)&v154, v55, &v148, (uint64_t *)&v159);
    uint64_t v57 = *(void *)v154;
    if ((unsigned char *)v154 != v155) {
      free((void *)v154);
    }
    uint64_t v148 = v57;
  }
  unint64_t v146 = 0;
  unsigned int v58 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(a3, 2u);
  unint64_t v59 = *((void *)a3 + 7);
  *(void *)&long long v154 = v59;
  *((void *)&v154 + 1) = v58;
  if (v58) {
    unint64_t v59 = mlir::ValueRange::offset_base(&v154, v58);
  }
  long long v154 = v59;
  uint64_t v60 = mlir::ValueRange::dereference_iterator(&v154, 0);
  uint64_t v159 = (unint64_t *)&v146;
  *(void *)&long long v154 = v60;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v154);
  if (!DefiningOp || !mlir::detail::constant_op_binder<mlir::DenseIntElementsAttr>::match(&v159, DefiningOp)) {
    return 0;
  }
  v164 = &v166;
  uint64_t v165 = 0x100000000;
  uint64_t v62 = (uint64_t)v146;
  if (!v146) {
    goto LABEL_61;
  }
  uint64_t v63 = *v146;
  unint64_t v64 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v65 = *(unsigned int *)(v63 + 16);
  if (!v65) {
    goto LABEL_61;
  }
  uint64_t v66 = *(void **)(v63 + 8);
  unsigned int v67 = &v66[2 * v65];
  do
  {
    unint64_t v68 = v65 >> 1;
    unsigned int v69 = &v66[2 * (v65 >> 1)];
    unint64_t v71 = *v69;
    unint64_t v70 = v69 + 2;
    v65 += ~(v65 >> 1);
    if (v71 < v64) {
      uint64_t v66 = v70;
    }
    else {
      unint64_t v65 = v68;
    }
  }
  while (v65);
  if (v66 != v67 && *v66 == v64) {
    uint64_t v72 = v66[1];
  }
  else {
LABEL_61:
  }
    uint64_t v72 = 0;
  mlir::getIntValues<long long>(v62, v72, (uint64_t)&v164, 1);
  v162[0] = &v163;
  v162[1] = (void *)0x100000000;
  uint64_t v73 = v164;
  uint64_t v74 = v165;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v151);
  if (mlir::getPositiveAxes(v73, v74, v75, (uint64_t)v162, 0, 0, 0))
  {
    uint64_t v141 = *(void *)v162[0];
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v151);
    uint64_t v77 = v76;
    uint64_t ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v151);
    uint64_t v80 = v78;
    uint64_t v159 = (unint64_t *)v161;
    uint64_t v160 = 0x500000000;
    if ((unint64_t)(8 * v78) < 0x29)
    {
      int v81 = 0;
      uint64_t v82 = BatchDims;
      if (!v78) {
        goto LABEL_70;
      }
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v159, v161, (8 * v78) >> 3, 8);
      int v81 = v160;
      uint64_t v82 = BatchDims;
      if (!v80)
      {
LABEL_70:
        LODWORD(v160) = v81 + v80;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v150);
        if (v84) {
          mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v150);
        }
        else {
          uint64_t v85 = 1;
        }
        llvm::SmallVectorImpl<long long>::insert((uint64_t)&v159, (uint64_t)&v159[*(void *)v162[0]], v85 + ~v82, 1uLL);
        uint64_t v86 = (5 - v160) & ~((5 - v160) >> 63);
        if (v160 <= 4) {
          llvm::SmallVectorImpl<long long>::insert((uint64_t)&v159, (uint64_t)v159, (5 - v160) & ~((5 - v160) >> 63), 1uLL);
        }
        uint64_t v156 = v158;
        uint64_t v87 = v159;
        uint64_t v88 = &v159[v86 + v82];
        uint64_t v157 = 0x500000000;
        uint64_t v89 = (char *)v88 - (char *)v159;
        if ((unint64_t)((char *)v88 - (char *)v159) < 0x29)
        {
          unsigned int v90 = 0;
          if (v159 == v88) {
            goto LABEL_83;
          }
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v156, v158, v89 >> 3, 8);
          unsigned int v90 = v157;
          if (v87 == v88)
          {
LABEL_83:
            unsigned int v91 = v90 + ((unint64_t)v89 >> 3);
            LODWORD(v157) = v91;
            if (*(void *)v162[0] - v82 >= 1) {
              llvm::SmallVectorImpl<long long>::insert((uint64_t)&v156, (uint64_t)v156 + 8 * v91, *(void *)v162[0] - v82, 1uLL);
            }
            uint64_t v93 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v150);
            uint64_t v94 = v92;
            *(void *)&long long v154 = v155;
            *((void *)&v154 + 1) = 0x600000000;
            size_t v95 = 8 * v92;
            if ((unint64_t)(8 * v92) < 0x31)
            {
              unsigned int v96 = 0;
              if (!v92)
              {
LABEL_90:
                unsigned int v97 = v96 + (v95 >> 3);
                DWORD2(v154) = v97;
                if (!v97)
                {
                  if (HIDWORD(v154))
                  {
                    uint64_t v98 = 0;
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v154, v155, 1uLL, 8);
                    uint64_t v98 = DWORD2(v154);
                  }
                  *(void *)(v154 + 8 * v98) = 1;
                  unsigned int v97 = ++DWORD2(v154);
                }
                llvm::SmallVectorImpl<mlir::Attribute>::insert<mlir::Attribute const*,void>((uint64_t)&v156, (uint64_t)v156 + 8 * v157, (char *)(v154 + 8 * v82), (char *)(v154 + 8 * v97));
                if (v157 <= 4) {
                  llvm::SmallVectorImpl<long long>::insert((uint64_t)&v156, (uint64_t)v156 + 8 * v157, 5 - v157, 1uLL);
                }
                uint64_t RankPromotionTypeForANE = 1;
                uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
                uint64_t v100 = (void *)mlir::RankedTensorType::get((uint64_t)&RankPromotionTypeForANE, 1, IntegerType, 0);
                unint64_t v101 = v100;
                if (!v100) {
                  goto LABEL_105;
                }
                uint64_t v102 = *v100;
                unint64_t v103 = mlir::TypeID::get<mlir::ShapedType>();
                unint64_t v104 = *(unsigned int *)(v102 + 16);
                if (!v104) {
                  goto LABEL_105;
                }
                unint64_t v105 = *(void **)(v102 + 8);
                uint64_t v106 = &v105[2 * v104];
                do
                {
                  unint64_t v107 = v104 >> 1;
                  unsigned int v108 = &v105[2 * (v104 >> 1)];
                  unint64_t v110 = *v108;
                  uint64_t v109 = v108 + 2;
                  v104 += ~(v104 >> 1);
                  if (v110 < v103) {
                    unint64_t v105 = v109;
                  }
                  else {
                    unint64_t v104 = v107;
                  }
                }
                while (v104);
                if (v105 != v106 && *v105 == v103) {
                  uint64_t v111 = v105[1];
                }
                else {
LABEL_105:
                }
                  uint64_t v111 = 0;
                uint64_t v153 = ((5 - v77) & ~((5 - v77) >> 63)) + v141;
                uint64_t v145 = mlir::DenseElementsAttr::getFromRawBuffer(v101, v111, &v153, 8, 8, 1, 0);
                uint64_t v112 = v159;
                uint64_t v113 = (mlir::AffineMap *)v160;
                uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v151);
                uint64_t v153 = mlir::MemRefType::get(v112, v113, OperandRange, 0, 0, 0);
                uint64_t v115 = v156;
                uint64_t v116 = (mlir::AffineMap *)v157;
                uint64_t v117 = mlir::getElementTypeOrSelf(v148);
                uint64_t v144 = mlir::MemRefType::get(v115, v116, v117, 0, 0, 0);
                uint64_t v118 = *(void *)(v152 + 24);
                unsigned int v119 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(a3, 0);
                unint64_t v120 = *((void *)a3 + 7);
                uint64_t RankPromotionTypeForANE = v120;
                uint64_t v168 = v119;
                if (v119) {
                  unint64_t v120 = mlir::ValueRange::offset_base(&RankPromotionTypeForANE, v119);
                }
                uint64_t RankPromotionTypeForANE = v120;
                uint64_t v168 = 0;
                uint64_t RankPromotionTypeForANE = mlir::ValueRange::dereference_iterator(&RankPromotionTypeForANE, 0);
                uint64_t v143 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 1), v118, &v153, &RankPromotionTypeForANE)- 16;
                uint64_t v148 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 1), *(void *)(v152 + 24), &v144, &v148)- 16;
                uint64_t v142 = mlir::OpBuilder::create<mlir::anec::GatherND,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &>(a4 + 1, *(void *)(v152 + 24), &v143, &v148, &v145);
                uint64_t v121 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v149);
                uint64_t v123 = v122;
                uint64_t v124 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v149);
                unint64_t v125 = (uint64_t *)mlir::MemRefType::get(v121, v123, v124, 0, 0, 0);
                uint64_t v126 = (uint64_t)v125;
                uint64_t v127 = v152;
                if (!v125) {
                  goto LABEL_117;
                }
                uint64_t v128 = *v125;
                unint64_t v129 = mlir::TypeID::get<mlir::ShapedType>();
                unint64_t v130 = *(unsigned int *)(v128 + 16);
                if (!v130) {
                  goto LABEL_117;
                }
                float v131 = *(void **)(v128 + 8);
                unint64_t v132 = &v131[2 * v130];
                do
                {
                  unint64_t v133 = v130 >> 1;
                  uint64_t v134 = &v131[2 * (v130 >> 1)];
                  unint64_t v136 = *v134;
                  uint64_t v135 = v134 + 2;
                  v130 += ~(v130 >> 1);
                  if (v136 < v129) {
                    float v131 = v135;
                  }
                  else {
                    unint64_t v130 = v133;
                  }
                }
                while (v130);
                if (v131 != v132 && *v131 == v129) {
                  uint64_t v137 = v131[1];
                }
                else {
LABEL_117:
                }
                  uint64_t v137 = 0;
                uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE(v126, v137);
                uint64_t v168 = v138;
                unint64_t v139 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::ShapedType,mlir::anec::GatherND &>((mlir::OpBuilder *)(a4 + 1), *(void *)(v127 + 24), &RankPromotionTypeForANE, &v142);
                (*((void (**)(mlir::Float16Type **, uint64_t, mlir::GenericProgramPoint *))*a4 + 4))(a4, v127, v139);
                if ((unsigned char *)v154 != v155) {
                  free((void *)v154);
                }
                if (v156 != v158) {
                  free(v156);
                }
                if (v159 != (unint64_t *)v161) {
                  free(v159);
                }
                uint64_t v83 = 1;
                goto LABEL_125;
              }
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v154, v155, (8 * v92) >> 3, 8);
              unsigned int v96 = DWORD2(v154);
              if (!v94) {
                goto LABEL_90;
              }
            }
            memcpy((void *)(v154 + 8 * v96), v93, v95);
            unsigned int v96 = DWORD2(v154);
            goto LABEL_90;
          }
        }
        memcpy((char *)v156 + 8 * v90, v87, (char *)v88 - (char *)v87);
        unsigned int v90 = v157;
        goto LABEL_83;
      }
    }
    memcpy(&v159[v81], ArgAttrsAttr, 8 * v80);
    int v81 = v160;
    goto LABEL_70;
  }
  uint64_t v83 = 0;
LABEL_125:
  if (v162[0] != &v163) {
    free(v162[0]);
  }
  if (v164 != &v166) {
    free(v164);
  }
  return v83;
}

BOOL mlir::detail::constant_op_binder<mlir::DenseIntElementsAttr>::match(unint64_t **a1, uint64_t a2)
{
  v10[1] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 48) + 32))(*(void *)(a2 + 48), v4)) {
    return 0;
  }
  v9[0] = v10;
  v9[1] = (void *)0x100000000;
  mlir::Operation::fold(a2, 0, 0, (uint64_t)v9);
  unint64_t v5 = *(void *)v9[0] & 0xFFFFFFFFFFFFFFF8;
  if (mlir::DenseIntElementsAttr::classof(v5)) {
    unint64_t v6 = v5;
  }
  else {
    unint64_t v6 = 0;
  }
  BOOL v7 = v6 != 0;
  if (v6 && *a1) {
    **a1 = v6;
  }
  if (v9[0] != v10) {
    free(v9[0]);
  }
  return v7;
}

void *mlir::anonymous namespace'::ConvertDepthToSpace2D<mlir::anec::PixelShuffle>::~ConvertDepthToSpace2D(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertDepthToSpace2D<mlir::anec::PixelShuffle>::~ConvertDepthToSpace2D(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DepthToSpace2DOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::DepthToSpace2DOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::DepthToSpace2DOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DepthToSpace2DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::DepthToSpace2DOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::DepthToSpace2DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 56);
  uint64_t v9 = *(void *)(a3 + 64);
  unint64_t v36 = v8;
  uint64_t v37 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        unint64_t v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v37 = v23;
        if (v36)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v36);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v33 = 259;
      v30[0] = v32;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DepthToSpace2DOp &>(mlir::mps::DepthToSpace2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 48);
        uint64_t v34[2] = *(_OWORD *)(a3 + 32);
        v34[3] = v28;
        uint64_t v35 = *(void *)(a3 + 64);
        long long v29 = *(_OWORD *)(a3 + 16);
        v34[0] = *(_OWORD *)a3;
        v34[1] = v29;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v37;
    if (v36 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  unint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DepthToSpace2DOp &>(mlir::mps::DepthToSpace2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertDepthToSpace2D<mlir::anec::PixelShuffle>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v34 = a2;
  long long v38 = *(_OWORD *)(a3 + 56);
  if (!*(unsigned char *)(a2 + 47)
    || (uint64_t InherentAttr = mlir::Operation::getInherentAttr(a2, (uint64_t)"pixel_shuffle", 13), !v7))
  {
    if (mlir::DictionaryAttr::contains(a2 + 56, "pixel_shuffle", 0xDuLL)) {
      goto LABEL_4;
    }
    return 0;
  }
  if (!InherentAttr) {
    return 0;
  }
LABEL_4:
  uint64_t v35 = (void *)3;
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  uint64_t v9 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&v35, 1, IntegerType, 0);
  uint64_t Index = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v34);
  unsigned int v11 = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v34);
  uint64_t v35 = v37;
  v37[0] = Index;
  v37[1] = v11;
  void v37[2] = 1;
  uint64_t v36 = 0x300000003;
  if (!v9) {
    goto LABEL_13;
  }
  uint64_t v12 = *v9;
  unint64_t v13 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v14 = *(unsigned int *)(v12 + 16);
  if (!v14) {
    goto LABEL_13;
  }
  uint64_t v15 = *(void **)(v12 + 8);
  uint64_t v16 = &v15[2 * v14];
  do
  {
    unint64_t v17 = v14 >> 1;
    uint64_t v18 = &v15[2 * (v14 >> 1)];
    unint64_t v20 = *v18;
    uint64_t v19 = v18 + 2;
    v14 += ~(v14 >> 1);
    if (v20 < v13) {
      uint64_t v15 = v19;
    }
    else {
      unint64_t v14 = v17;
    }
  }
  while (v14);
  if (v15 != v16 && *v15 == v13) {
    uint64_t v21 = v15[1];
  }
  else {
LABEL_13:
  }
    uint64_t v21 = 0;
  uint64_t v33 = mlir::DenseElementsAttr::getFromRawBuffer(v9, v21, v35, 8 * v36, 8, 1, 0);
  uint64_t v22 = v34;
  uint64_t v23 = mlir::ValueRange::dereference_iterator(&v38, 0);
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v34);
  uint64_t v25 = (void *)mlir::ValueRange::dereference_iterator(&v38, 1);
  uint64_t v26 = (void *)mlir::ValueRange::dereference_iterator(&v38, 2);
  uint64_t v27 = (void *)mlir::ValueRange::dereference_iterator(&v38, 3);
  {
    uint64_t v28 = v34;
    uint64_t v32 = mlir::ValueRange::dereference_iterator(&v38, 0);
    long long v29 = mlir::OpBuilder::create<mlir::anec::PixelShuffle,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), *(void *)(v28 + 24), &v32, &v33);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v28, v29);
    uint64_t v30 = 1;
  }
  else
  {
    uint64_t v30 = 0;
  }
  if (v35 != v37) {
    free(v35);
  }
  return v30;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DepthToSpace2DOp &>(mlir::mps::DepthToSpace2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t mlir::anonymous namespace'::convertDepthSpaceCommon<mlir::mps::DepthToSpace2DOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7)
{
  uint64_t v75 = *MEMORY[0x1E4F143B8];
  unint64_t v13 = (uint64_t *)(*(void *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v13) {
    goto LABEL_10;
  }
  uint64_t v14 = *v13;
  unint64_t v15 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v16 = *(unsigned int *)(v14 + 16);
  if (!v16) {
    goto LABEL_10;
  }
  unint64_t v17 = *(void **)(v14 + 8);
  uint64_t v18 = &v17[2 * v16];
  do
  {
    unint64_t v19 = v16 >> 1;
    unint64_t v20 = &v17[2 * (v16 >> 1)];
    unint64_t v22 = *v20;
    uint64_t v21 = v20 + 2;
    v16 += ~(v16 >> 1);
    if (v22 < v15) {
      unint64_t v17 = v21;
    }
    else {
      unint64_t v16 = v19;
    }
  }
  while (v16);
  if (v17 != v18 && *v17 == v15) {
    uint64_t v23 = v17[1];
  }
  else {
LABEL_10:
  }
    uint64_t v23 = 0;
  v70[0] = v13;
  v70[1] = v23;
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v70) & 1) == 0)
  {
    uint64_t v43 = *(void *)(a2 + 16);
    if (v43 && mlir::RewriterBase::Listener::classof(v43))
    {
      uint64_t v44 = *(void *)(a1 + 24);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v43 + 64))(v43, v44, v45, v71);
    }
    return 0;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v70);
  if (v24 != 4)
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v70);
    if (v25 != 5)
    {
      uint64_t v43 = *(void *)(a2 + 16);
      if (v43 && mlir::RewriterBase::Listener::classof(v43))
      {
        uint64_t v44 = *(void *)(a1 + 24);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v43 + 64))(v43, v44, v45, v71);
      }
      return 0;
    }
  }
  uint64_t v26 = (uint64_t *)(*(void *)(a4 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v26) {
    goto LABEL_23;
  }
  uint64_t v27 = *v26;
  unint64_t v28 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v29 = *(unsigned int *)(v27 + 16);
  if (!v29) {
    goto LABEL_23;
  }
  uint64_t v30 = *(void **)(v27 + 8);
  unint64_t v31 = &v30[2 * v29];
  do
  {
    unint64_t v32 = v29 >> 1;
    uint64_t v33 = &v30[2 * (v29 >> 1)];
    unint64_t v35 = *v33;
    uint64_t v34 = v33 + 2;
    v29 += ~(v29 >> 1);
    if (v35 < v28) {
      uint64_t v30 = v34;
    }
    else {
      unint64_t v29 = v32;
    }
  }
  while (v29);
  if (v30 != v31 && *v30 == v28) {
    uint64_t v36 = v30[1];
  }
  else {
LABEL_23:
  }
    uint64_t v36 = 0;
  v69[0] = v26;
  v69[1] = v36;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v70);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v37);
  if (v39)
  {
    unint64_t v40 = IndexFromDim;
    v71[0] = &v72;
    uint64_t v72 = a7;
    uint64_t v73 = a6;
    uint64_t v74 = a5;
    v71[1] = (void *)0x300000003;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v69);
    unint64_t SortedUniquePromotedPositiveAxesAttr = mlir::getSortedUniquePromotedPositiveAxesAttr(a7, v41, 0, 0);
    uint64_t v68 = v42;
    if (!(_BYTE)v42) {
      goto LABEL_58;
    }
    if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&SortedUniquePromotedPositiveAxesAttr) != 1) {
      goto LABEL_54;
    }
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v64, SortedUniquePromotedPositiveAxesAttr, 0);
    mlir::DenseElementsAttr::IntElementIterator::operator*(v64, (llvm::APInt *)&__p);
    if (v66 > 0x40)
    {
      uint64_t v47 = *(void *)__p;
      operator delete[](__p);
      if (v40 != v47) {
        goto LABEL_51;
      }
    }
    else if (v40 != (uint64_t)((void)__p << -(uint64_t)v66) >> -(uint64_t)v66)
    {
      goto LABEL_51;
    }
    uint64_t v48 = v73;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v69);
    unint64_t SortedUniquePromotedPositiveAxesAttr = mlir::getSortedUniquePromotedPositiveAxesAttr(v48, v49, 0, 0);
    uint64_t v68 = v50;
    if (!(_BYTE)v50) {
      goto LABEL_58;
    }
    if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&SortedUniquePromotedPositiveAxesAttr) != 1) {
      goto LABEL_54;
    }
    unint64_t v51 = v40 + 1;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v64, SortedUniquePromotedPositiveAxesAttr, 0);
    mlir::DenseElementsAttr::IntElementIterator::operator*(v64, (llvm::APInt *)&__p);
    if (v66 < 0x41)
    {
      if (v51 != (uint64_t)((void)__p << -(uint64_t)v66) >> -(uint64_t)v66) {
        goto LABEL_51;
      }
LABEL_47:
      uint64_t v53 = v74;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v69);
      unint64_t SortedUniquePromotedPositiveAxesAttr = mlir::getSortedUniquePromotedPositiveAxesAttr(v53, v54, 0, 0);
      uint64_t v68 = v55;
      if ((_BYTE)v55)
      {
        if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&SortedUniquePromotedPositiveAxesAttr) == 1)
        {
          unint64_t v56 = v40 + 2;
          mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v64, SortedUniquePromotedPositiveAxesAttr, 0);
          mlir::DenseElementsAttr::IntElementIterator::operator*(v64, (llvm::APInt *)&__p);
          if (v66 >= 0x41)
          {
            uint64_t v61 = *(void *)__p;
            operator delete[](__p);
            if (v56 != v61) {
              goto LABEL_51;
            }
          }
          else if (v56 != (uint64_t)((void)__p << -(uint64_t)v66) >> -(uint64_t)v66)
          {
            goto LABEL_51;
          }
          uint64_t v46 = 1;
LABEL_59:
          if (v71[0] != &v72) {
            free(v71[0]);
          }
          return v46;
        }
LABEL_54:
        uint64_t v57 = *(void *)(a2 + 16);
        if (v57 && mlir::RewriterBase::Listener::classof(v57))
        {
          uint64_t v58 = *(void *)(a1 + 24);
          goto LABEL_57;
        }
      }
LABEL_58:
      uint64_t v46 = 0;
      goto LABEL_59;
    }
    uint64_t v52 = *(void *)__p;
    operator delete[](__p);
    if (v51 == v52) {
      goto LABEL_47;
    }
LABEL_51:
    uint64_t v57 = *(void *)(a2 + 16);
    if (v57 && mlir::RewriterBase::Listener::classof(v57))
    {
      uint64_t v58 = *(void *)(a1 + 24);
LABEL_57:
      uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(void *)v57 + 64))(v57, v58, v59, v64);
      goto LABEL_59;
    }
    goto LABEL_58;
  }
  int v62 = std::__throw_bad_optional_access[abi:nn180100]();
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::anonymous namespace'::convertDepthSpaceCommon<mlir::mps::DepthToSpace2DOp>(mlir::mps::DepthToSpace2DOp,mlir::ConversionPatternRewriter &,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::anonymous namespace'::convertDepthSpaceCommon<mlir::mps::DepthToSpace2DOp>(mlir::mps::DepthToSpace2DOp,mlir::ConversionPatternRewriter &,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, " only handling rank 4 or 5 input");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::anonymous namespace'::convertDepthSpaceCommon<mlir::mps::DepthToSpace2DOp>(mlir::mps::DepthToSpace2DOp,mlir::ConversionPatternRewriter &,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Channel <-> Space supports only 1 axis \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::anonymous namespace'::convertDepthSpaceCommon<mlir::mps::DepthToSpace2DOp>(mlir::mps::DepthToSpace2DOp,mlir::ConversionPatternRewriter &,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "only supporting NCHW in Depth <-> Space -> Channel <-> Space\n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::PixelShuffle,mlir::Value,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.pixel_shuffle", (const unsigned __int8 *)0x12, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.pixel_shuffle";
    v17[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::PixelShuffle::build(a1, (uint64_t)v19, *a3, *a4);
  unsigned int v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::PixelShuffle,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *mlir::anonymous namespace'::ConvertDepthToSpace2D<mlir::anec::ChannelToSpace>::~ConvertDepthToSpace2D(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertDepthToSpace2D<mlir::anec::ChannelToSpace>::~ConvertDepthToSpace2D(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertDepthToSpace2D<mlir::anec::ChannelToSpace>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v34 = a2;
  long long v38 = *(_OWORD *)(a3 + 56);
  if (*(unsigned char *)(a2 + 47) && (uint64_t InherentAttr = mlir::Operation::getInherentAttr(a2, (uint64_t)"pixel_shuffle", 13), v7))
  {
    if (InherentAttr) {
      return 0;
    }
  }
  else if (mlir::DictionaryAttr::contains(a2 + 56, "pixel_shuffle", 0xDuLL))
  {
    return 0;
  }
  unint64_t v35 = (void *)3;
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  char v10 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&v35, 1, IntegerType, 0);
  uint64_t Index = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v34);
  unsigned int v12 = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v34);
  unint64_t v35 = v37;
  v37[0] = Index;
  v37[1] = v12;
  void v37[2] = 1;
  uint64_t v36 = 0x300000003;
  if (!v10) {
    goto LABEL_15;
  }
  uint64_t v13 = *v10;
  unint64_t v14 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v15 = *(unsigned int *)(v13 + 16);
  if (!v15) {
    goto LABEL_15;
  }
  __int16 v16 = *(void **)(v13 + 8);
  unint64_t v17 = &v16[2 * v15];
  do
  {
    unint64_t v18 = v15 >> 1;
    unint64_t v19 = &v16[2 * (v15 >> 1)];
    unint64_t v21 = *v19;
    unint64_t v20 = v19 + 2;
    v15 += ~(v15 >> 1);
    if (v21 < v14) {
      __int16 v16 = v20;
    }
    else {
      unint64_t v15 = v18;
    }
  }
  while (v15);
  if (v16 != v17 && *v16 == v14) {
    uint64_t v22 = v16[1];
  }
  else {
LABEL_15:
  }
    uint64_t v22 = 0;
  uint64_t v33 = mlir::DenseElementsAttr::getFromRawBuffer(v10, v22, v35, 8 * v36, 8, 1, 0);
  uint64_t v23 = v34;
  uint64_t v24 = mlir::ValueRange::dereference_iterator(&v38, 0);
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v34);
  uint64_t v26 = (void *)mlir::ValueRange::dereference_iterator(&v38, 1);
  uint64_t v27 = (void *)mlir::ValueRange::dereference_iterator(&v38, 2);
  unint64_t v28 = (void *)mlir::ValueRange::dereference_iterator(&v38, 3);
  {
    uint64_t v29 = v34;
    uint64_t v32 = mlir::ValueRange::dereference_iterator(&v38, 0);
    uint64_t v30 = mlir::OpBuilder::create<mlir::anec::ChannelToSpace,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), *(void *)(v29 + 24), &v32, &v33);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v29, v30);
    uint64_t v8 = 1;
  }
  else
  {
    uint64_t v8 = 0;
  }
  if (v35 != v37) {
    free(v35);
  }
  return v8;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ChannelToSpace,mlir::Value,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.channel_to_space", (const unsigned __int8 *)0x15, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.channel_to_space";
    v17[3] = 21;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ChannelToSpace::build(a1, (uint64_t)v19, *a3, *a4);
  unsigned int v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ChannelToSpace,void>::id) {
    unsigned int v12 = v11;
  }
  else {
    unsigned int v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *mlir::anonymous namespace'::ConvertSpaceToDepth2D<mlir::anec::PixelUnshuffle>::~ConvertSpaceToDepth2D(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSpaceToDepth2D<mlir::anec::PixelUnshuffle>::~ConvertSpaceToDepth2D(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SpaceToDepth2DOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SpaceToDepth2DOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SpaceToDepth2DOpGenericAdaptorBase::SpaceToDepth2DOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SpaceToDepth2DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SpaceToDepth2DOpGenericAdaptorBase::SpaceToDepth2DOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SpaceToDepth2DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 56);
  uint64_t v9 = *(void *)(a3 + 64);
  uint64_t v36 = v8;
  uint64_t v37 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v37 = v23;
        if (v36)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v36);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v33 = 259;
      v30[0] = v32;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SpaceToDepth2DOp &>(mlir::mps::SpaceToDepth2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 48);
        uint64_t v34[2] = *(_OWORD *)(a3 + 32);
        v34[3] = v28;
        uint64_t v35 = *(void *)(a3 + 64);
        long long v29 = *(_OWORD *)(a3 + 16);
        v34[0] = *(_OWORD *)a3;
        v34[1] = v29;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v37;
    if (v36 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  unint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SpaceToDepth2DOp &>(mlir::mps::SpaceToDepth2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertSpaceToDepth2D<mlir::anec::PixelUnshuffle>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v34 = a2;
  long long v38 = *(_OWORD *)(a3 + 56);
  if (!*(unsigned char *)(a2 + 47)
    || (uint64_t InherentAttr = mlir::Operation::getInherentAttr(a2, (uint64_t)"pixel_shuffle", 13), !v7))
  {
    if (mlir::DictionaryAttr::contains(a2 + 56, "pixel_shuffle", 0xDuLL)) {
      goto LABEL_4;
    }
    return 0;
  }
  if (!InherentAttr) {
    return 0;
  }
LABEL_4:
  uint64_t v35 = (void *)3;
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  uint64_t v9 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&v35, 1, IntegerType, 0);
  uint64_t Index = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v34);
  unsigned int v11 = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v34);
  uint64_t v35 = v37;
  v37[0] = Index;
  v37[1] = v11;
  void v37[2] = 1;
  uint64_t v36 = 0x300000003;
  if (!v9) {
    goto LABEL_13;
  }
  uint64_t v12 = *v9;
  unint64_t v13 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v14 = *(unsigned int *)(v12 + 16);
  if (!v14) {
    goto LABEL_13;
  }
  uint64_t v15 = *(void **)(v12 + 8);
  uint64_t v16 = &v15[2 * v14];
  do
  {
    unint64_t v17 = v14 >> 1;
    __int16 v18 = &v15[2 * (v14 >> 1)];
    unint64_t v20 = *v18;
    uint64_t v19 = v18 + 2;
    v14 += ~(v14 >> 1);
    if (v20 < v13) {
      uint64_t v15 = v19;
    }
    else {
      unint64_t v14 = v17;
    }
  }
  while (v14);
  if (v15 != v16 && *v15 == v13) {
    uint64_t v21 = v15[1];
  }
  else {
LABEL_13:
  }
    uint64_t v21 = 0;
  uint64_t v33 = mlir::DenseElementsAttr::getFromRawBuffer(v9, v21, v35, 8 * v36, 8, 1, 0);
  uint64_t v22 = v34;
  uint64_t v23 = mlir::ValueRange::dereference_iterator(&v38, 0);
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v34);
  uint64_t v25 = (void *)mlir::ValueRange::dereference_iterator(&v38, 1);
  uint64_t v26 = (void *)mlir::ValueRange::dereference_iterator(&v38, 2);
  uint64_t v27 = (void *)mlir::ValueRange::dereference_iterator(&v38, 3);
  {
    uint64_t v28 = v34;
    uint64_t v32 = mlir::ValueRange::dereference_iterator(&v38, 0);
    long long v29 = mlir::OpBuilder::create<mlir::anec::PixelUnshuffle,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), *(void *)(v28 + 24), &v32, &v33);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v28, v29);
    uint64_t v30 = 1;
  }
  else
  {
    uint64_t v30 = 0;
  }
  if (v35 != v37) {
    free(v35);
  }
  return v30;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SpaceToDepth2DOp &>(mlir::mps::SpaceToDepth2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t mlir::anonymous namespace'::convertDepthSpaceCommon<mlir::mps::SpaceToDepth2DOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7)
{
  uint64_t v75 = *MEMORY[0x1E4F143B8];
  unint64_t v13 = (uint64_t *)(*(void *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v13) {
    goto LABEL_10;
  }
  uint64_t v14 = *v13;
  unint64_t v15 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v16 = *(unsigned int *)(v14 + 16);
  if (!v16) {
    goto LABEL_10;
  }
  unint64_t v17 = *(void **)(v14 + 8);
  __int16 v18 = &v17[2 * v16];
  do
  {
    unint64_t v19 = v16 >> 1;
    unint64_t v20 = &v17[2 * (v16 >> 1)];
    unint64_t v22 = *v20;
    uint64_t v21 = v20 + 2;
    v16 += ~(v16 >> 1);
    if (v22 < v15) {
      unint64_t v17 = v21;
    }
    else {
      unint64_t v16 = v19;
    }
  }
  while (v16);
  if (v17 != v18 && *v17 == v15) {
    uint64_t v23 = v17[1];
  }
  else {
LABEL_10:
  }
    uint64_t v23 = 0;
  v70[0] = v13;
  v70[1] = v23;
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v70) & 1) == 0)
  {
    uint64_t v43 = *(void *)(a2 + 16);
    if (v43 && mlir::RewriterBase::Listener::classof(v43))
    {
      uint64_t v44 = *(void *)(a1 + 24);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v43 + 64))(v43, v44, v45, v71);
    }
    return 0;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v70);
  if (v24 != 4)
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v70);
    if (v25 != 5)
    {
      uint64_t v43 = *(void *)(a2 + 16);
      if (v43 && mlir::RewriterBase::Listener::classof(v43))
      {
        uint64_t v44 = *(void *)(a1 + 24);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v43 + 64))(v43, v44, v45, v71);
      }
      return 0;
    }
  }
  uint64_t v26 = (uint64_t *)(*(void *)(a4 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v26) {
    goto LABEL_23;
  }
  uint64_t v27 = *v26;
  unint64_t v28 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v29 = *(unsigned int *)(v27 + 16);
  if (!v29) {
    goto LABEL_23;
  }
  uint64_t v30 = *(void **)(v27 + 8);
  unint64_t v31 = &v30[2 * v29];
  do
  {
    unint64_t v32 = v29 >> 1;
    uint64_t v33 = &v30[2 * (v29 >> 1)];
    unint64_t v35 = *v33;
    uint64_t v34 = v33 + 2;
    v29 += ~(v29 >> 1);
    if (v35 < v28) {
      uint64_t v30 = v34;
    }
    else {
      unint64_t v29 = v32;
    }
  }
  while (v29);
  if (v30 != v31 && *v30 == v28) {
    uint64_t v36 = v30[1];
  }
  else {
LABEL_23:
  }
    uint64_t v36 = 0;
  v69[0] = v26;
  v69[1] = v36;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v70);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v37);
  if (v39)
  {
    unint64_t v40 = IndexFromDim;
    v71[0] = &v72;
    uint64_t v72 = a7;
    uint64_t v73 = a6;
    uint64_t v74 = a5;
    v71[1] = (void *)0x300000003;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v69);
    unint64_t SortedUniquePromotedPositiveAxesAttr = mlir::getSortedUniquePromotedPositiveAxesAttr(a7, v41, 0, 0);
    uint64_t v68 = v42;
    if (!(_BYTE)v42) {
      goto LABEL_58;
    }
    if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&SortedUniquePromotedPositiveAxesAttr) != 1) {
      goto LABEL_54;
    }
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v64, SortedUniquePromotedPositiveAxesAttr, 0);
    mlir::DenseElementsAttr::IntElementIterator::operator*(v64, (llvm::APInt *)&__p);
    if (v66 > 0x40)
    {
      uint64_t v47 = *(void *)__p;
      operator delete[](__p);
      if (v40 != v47) {
        goto LABEL_51;
      }
    }
    else if (v40 != (uint64_t)((void)__p << -(uint64_t)v66) >> -(uint64_t)v66)
    {
      goto LABEL_51;
    }
    uint64_t v48 = v73;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v69);
    unint64_t SortedUniquePromotedPositiveAxesAttr = mlir::getSortedUniquePromotedPositiveAxesAttr(v48, v49, 0, 0);
    uint64_t v68 = v50;
    if (!(_BYTE)v50) {
      goto LABEL_58;
    }
    if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&SortedUniquePromotedPositiveAxesAttr) != 1) {
      goto LABEL_54;
    }
    unint64_t v51 = v40 + 1;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v64, SortedUniquePromotedPositiveAxesAttr, 0);
    mlir::DenseElementsAttr::IntElementIterator::operator*(v64, (llvm::APInt *)&__p);
    if (v66 < 0x41)
    {
      if (v51 != (uint64_t)((void)__p << -(uint64_t)v66) >> -(uint64_t)v66) {
        goto LABEL_51;
      }
LABEL_47:
      uint64_t v53 = v74;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v69);
      unint64_t SortedUniquePromotedPositiveAxesAttr = mlir::getSortedUniquePromotedPositiveAxesAttr(v53, v54, 0, 0);
      uint64_t v68 = v55;
      if ((_BYTE)v55)
      {
        if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&SortedUniquePromotedPositiveAxesAttr) == 1)
        {
          unint64_t v56 = v40 + 2;
          mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v64, SortedUniquePromotedPositiveAxesAttr, 0);
          mlir::DenseElementsAttr::IntElementIterator::operator*(v64, (llvm::APInt *)&__p);
          if (v66 >= 0x41)
          {
            uint64_t v61 = *(void *)__p;
            operator delete[](__p);
            if (v56 != v61) {
              goto LABEL_51;
            }
          }
          else if (v56 != (uint64_t)((void)__p << -(uint64_t)v66) >> -(uint64_t)v66)
          {
            goto LABEL_51;
          }
          uint64_t v46 = 1;
LABEL_59:
          if (v71[0] != &v72) {
            free(v71[0]);
          }
          return v46;
        }
LABEL_54:
        uint64_t v57 = *(void *)(a2 + 16);
        if (v57 && mlir::RewriterBase::Listener::classof(v57))
        {
          uint64_t v58 = *(void *)(a1 + 24);
          goto LABEL_57;
        }
      }
LABEL_58:
      uint64_t v46 = 0;
      goto LABEL_59;
    }
    uint64_t v52 = *(void *)__p;
    operator delete[](__p);
    if (v51 == v52) {
      goto LABEL_47;
    }
LABEL_51:
    uint64_t v57 = *(void *)(a2 + 16);
    if (v57 && mlir::RewriterBase::Listener::classof(v57))
    {
      uint64_t v58 = *(void *)(a1 + 24);
LABEL_57:
      uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(void *)v57 + 64))(v57, v58, v59, v64);
      goto LABEL_59;
    }
    goto LABEL_58;
  }
  int v62 = std::__throw_bad_optional_access[abi:nn180100]();
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::anonymous namespace'::convertDepthSpaceCommon<mlir::mps::SpaceToDepth2DOp>(mlir::mps::SpaceToDepth2DOp,mlir::ConversionPatternRewriter &,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::anonymous namespace'::convertDepthSpaceCommon<mlir::mps::SpaceToDepth2DOp>(mlir::mps::SpaceToDepth2DOp,mlir::ConversionPatternRewriter &,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, " only handling rank 4 or 5 input");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::anonymous namespace'::convertDepthSpaceCommon<mlir::mps::SpaceToDepth2DOp>(mlir::mps::SpaceToDepth2DOp,mlir::ConversionPatternRewriter &,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Channel <-> Space supports only 1 axis \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::anonymous namespace'::convertDepthSpaceCommon<mlir::mps::SpaceToDepth2DOp>(mlir::mps::SpaceToDepth2DOp,mlir::ConversionPatternRewriter &,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "only supporting NCHW in Depth <-> Space -> Channel <-> Space\n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::PixelUnshuffle,mlir::Value,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.pixel_unshuffle", (const unsigned __int8 *)0x14, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.pixel_unshuffle";
    v17[3] = 20;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::PixelUnshuffle::build(a1, (uint64_t)v19, *a3, *a4);
  unsigned int v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::PixelUnshuffle,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *mlir::anonymous namespace'::ConvertSpaceToDepth2D<mlir::anec::SpaceToChannel>::~ConvertSpaceToDepth2D(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSpaceToDepth2D<mlir::anec::SpaceToChannel>::~ConvertSpaceToDepth2D(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertSpaceToDepth2D<mlir::anec::SpaceToChannel>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v34 = a2;
  long long v38 = *(_OWORD *)(a3 + 56);
  if (*(unsigned char *)(a2 + 47) && (uint64_t InherentAttr = mlir::Operation::getInherentAttr(a2, (uint64_t)"pixel_shuffle", 13), v7))
  {
    if (InherentAttr) {
      return 0;
    }
  }
  else if (mlir::DictionaryAttr::contains(a2 + 56, "pixel_shuffle", 0xDuLL))
  {
    return 0;
  }
  unint64_t v35 = (void *)3;
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  char v10 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&v35, 1, IntegerType, 0);
  uint64_t Index = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v34);
  unsigned int v12 = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v34);
  unint64_t v35 = v37;
  v37[0] = Index;
  v37[1] = v12;
  void v37[2] = 1;
  uint64_t v36 = 0x300000003;
  if (!v10) {
    goto LABEL_15;
  }
  uint64_t v13 = *v10;
  unint64_t v14 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v15 = *(unsigned int *)(v13 + 16);
  if (!v15) {
    goto LABEL_15;
  }
  __int16 v16 = *(void **)(v13 + 8);
  unint64_t v17 = &v16[2 * v15];
  do
  {
    unint64_t v18 = v15 >> 1;
    unint64_t v19 = &v16[2 * (v15 >> 1)];
    unint64_t v21 = *v19;
    unint64_t v20 = v19 + 2;
    v15 += ~(v15 >> 1);
    if (v21 < v14) {
      __int16 v16 = v20;
    }
    else {
      unint64_t v15 = v18;
    }
  }
  while (v15);
  if (v16 != v17 && *v16 == v14) {
    uint64_t v22 = v16[1];
  }
  else {
LABEL_15:
  }
    uint64_t v22 = 0;
  uint64_t v33 = mlir::DenseElementsAttr::getFromRawBuffer(v10, v22, v35, 8 * v36, 8, 1, 0);
  uint64_t v23 = v34;
  uint64_t v24 = mlir::ValueRange::dereference_iterator(&v38, 0);
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v34);
  uint64_t v26 = (void *)mlir::ValueRange::dereference_iterator(&v38, 1);
  uint64_t v27 = (void *)mlir::ValueRange::dereference_iterator(&v38, 2);
  unint64_t v28 = (void *)mlir::ValueRange::dereference_iterator(&v38, 3);
  {
    uint64_t v29 = v34;
    uint64_t v32 = mlir::ValueRange::dereference_iterator(&v38, 0);
    uint64_t v30 = mlir::OpBuilder::create<mlir::anec::SpaceToChannel,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), *(void *)(v29 + 24), &v32, &v33);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a4 + 32))(a4, v29, v30);
    uint64_t v8 = 1;
  }
  else
  {
    uint64_t v8 = 0;
  }
  if (v35 != v37) {
    free(v35);
  }
  return v8;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::SpaceToChannel,mlir::Value,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.space_to_channel", (const unsigned __int8 *)0x15, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.space_to_channel";
    v17[3] = 21;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::SpaceToChannel::build(a1, (uint64_t)v19, *a3, *a4);
  unsigned int v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::SpaceToChannel,void>::id) {
    unsigned int v12 = v11;
  }
  else {
    unsigned int v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::BatchToSpaceOp,mlir::anec::BatchToSpace>::~ConvertBatchToSpace(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::BatchToSpaceOp,mlir::anec::BatchToSpace>::~ConvertBatchToSpace(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BatchToSpaceOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::BatchToSpaceOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::BatchToSpaceOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BatchToSpaceOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::BatchToSpaceOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::BatchToSpaceOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 48);
  uint64_t v9 = *(void *)(a3 + 56);
  unint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        unint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v33 = 259;
      v30[0] = v32;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::BatchToSpaceOp &>(mlir::mps::BatchToSpaceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v34[0] = *(_OWORD *)a3;
        v34[1] = v28;
        long long v29 = *(_OWORD *)(a3 + 48);
        uint64_t v34[2] = *(_OWORD *)(a3 + 32);
        v34[3] = v29;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  unint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::BatchToSpaceOp &>(mlir::mps::BatchToSpaceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::BatchToSpaceOp,mlir::anec::BatchToSpace>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v109 = *MEMORY[0x1E4F143B8];
  uint64_t v95 = a2;
  long long v108 = *(_OWORD *)(a3 + 48);
  uint64_t v5 = mlir::ValueRange::dereference_iterator(&v108, 0);
  uint64_t v94 = v5;
  unint64_t v6 = (char *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *(void *)v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  unsigned int v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  uint64_t RankPromotionTypeForANE = v6;
  uint64_t v106 = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  unint64_t v18 = v17;
  uint64_t v19 = (uint64_t *)(*(void *)(v5 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *v19;
  unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v22 = *(unsigned int *)(v20 + 16);
  if (!v22) {
    goto LABEL_20;
  }
  uint64_t v23 = *(void **)(v20 + 8);
  uint64_t v24 = &v23[2 * v22];
  do
  {
    unint64_t v25 = v22 >> 1;
    uint64_t v26 = &v23[2 * (v22 >> 1)];
    unint64_t v28 = *v26;
    uint64_t v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21) {
      uint64_t v23 = v27;
    }
    else {
      unint64_t v22 = v25;
    }
  }
  while (v22);
  if (v23 != v24 && *v23 == v21) {
    uint64_t v29 = v23[1];
  }
  else {
LABEL_20:
  }
    uint64_t v29 = 0;
  uint64_t RankPromotionTypeForANE = (char *)mlir::getRankPromotionTypeForANE((uint64_t)v19, v29);
  uint64_t v106 = v30;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  unint64_t v32 = v31;
  Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  v93[0] = mlir::getSortedUniquePromotedPositiveAxesAttr(Filter, v18, *(void *)(v95 + 24), 1);
  v93[1] = v34;
  if (!(_BYTE)v34)
  {
    uint64_t v43 = a4[2];
    if (v43)
    {
      uint64_t v47 = v95;
      if (mlir::RewriterBase::Listener::classof(v43))
      {
        uint64_t v45 = *(void *)(v47 + 24);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), char **))(*(void *)v43 + 64))(v43, v45, v46, &RankPromotionTypeForANE);
      }
    }
    return 0;
  }
  Bias = (void *)mlir::anec::GOC::getBias((mlir::anec::GOC *)&v95);
  v92[0] = mlir::getSortedUniquePromotedPositiveAxesAttr(Bias, v18, *(void *)(v95 + 24), 1);
  v92[1] = v36;
  if (!(_BYTE)v36)
  {
    uint64_t v43 = a4[2];
    if (v43)
    {
      uint64_t v48 = v95;
      if (mlir::RewriterBase::Listener::classof(v43))
      {
        uint64_t v45 = *(void *)(v48 + 24);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), char **))(*(void *)v43 + 64))(v43, v45, v46, &RankPromotionTypeForANE);
      }
    }
    return 0;
  }
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(0, v32);
  unint64_t v38 = mlir::anec::getIndexFromDim(2, v32);
  uint64_t v40 = v39;
  unint64_t v91 = mlir::anec::getIndexFromDim(3, v32);
  unint64_t v41 = mlir::anec::getIndexFromDim(4, v32);
  if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v92) != 1)
  {
LABEL_26:
    uint64_t v43 = a4[2];
    if (v43)
    {
      uint64_t v44 = v95;
      if (mlir::RewriterBase::Listener::classof(v43))
      {
        uint64_t v45 = *(void *)(v44 + 24);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), char **))(*(void *)v43 + 64))(v43, v45, v46, &RankPromotionTypeForANE);
      }
    }
    return 0;
  }
  uint64_t v42 = mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&RankPromotionTypeForANE, v92[0], 0);
  mlir::DenseElementsAttr::IntElementIterator::operator*(v42, (llvm::APInt *)&__p);
  if (v102 >= 0x41)
  {
    uint64_t v50 = *(void *)__p;
    operator delete[](__p);
    if (IndexFromDim != v50) {
      goto LABEL_26;
    }
  }
  else if (IndexFromDim != (uint64_t)((void)__p << -(uint64_t)v102) >> -(uint64_t)v102)
  {
    goto LABEL_26;
  }
  uint64_t RankPromotionTypeForANE = v107;
  uint64_t v106 = 0x300000000;
  uint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v95);
  if (mlir::matchConstantWithIntVector<unsigned long long>(SparseShape, (uint64_t)&RankPromotionTypeForANE))
  {
    unint64_t v89 = v41;
    unint64_t v90 = v38;
    long long __p = &v103;
    uint64_t v104 = 1;
    long long v103 = xmmword_181110BC0;
    uint64_t v102 = 0x300000003;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v96, v93[0], 0);
    long long v98 = *(_OWORD *)v96;
    long long v99 = v97;
    uint64_t v100 = RankPromotionTypeForANE;
    uint64_t v52 = v93[0];
    uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v93);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v96, v52, NumElements);
    unint64_t v54 = v96[0];
    int v55 = LOBYTE(v96[1]);
    uint64_t v56 = v97;
    BOOL v58 = (void)v99 == (void)v97 && BYTE8(v98) == LOBYTE(v96[1]) && (void *)v98 == v96[0];
    if (v58 || (unint64_t v59 = &RankPromotionTypeForANE[8 * v106], v100 == v59))
    {
LABEL_84:
      *(void *)&long long v98 = 3;
      uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
      uint64_t v73 = (void *)mlir::RankedTensorType::get((uint64_t)&v98, 1, IntegerType, 0);
      uint64_t v74 = v73;
      if (v73
        && (uint64_t v75 = *v73, v76 = mlir::TypeID::get<mlir::ShapedType>(), v77 = *(unsigned int *)(v75 + 16), v77))
      {
        uint64_t v78 = *(void **)(v75 + 8);
        unint64_t v79 = &v78[2 * v77];
        do
        {
          unint64_t v80 = v77 >> 1;
          int v81 = &v78[2 * (v77 >> 1)];
          unint64_t v83 = *v81;
          uint64_t v82 = v81 + 2;
          v77 += ~(v77 >> 1);
          if (v83 < v76) {
            uint64_t v78 = v82;
          }
          else {
            unint64_t v77 = v80;
          }
        }
        while (v77);
        if (v78 != v79 && *v78 == v76) {
          uint64_t v84 = v78[1];
        }
        else {
          uint64_t v84 = 0;
        }
      }
      else
      {
        uint64_t v84 = 0;
      }
      uint64_t v40 = 1;
      *(void *)&long long v98 = mlir::DenseElementsAttr::getFromRawBuffer(v74, v84, __p, 8 * v102, 8, 1, 0);
      uint64_t v87 = v95;
      uint64_t v88 = mlir::OpBuilder::create<mlir::anec::BatchToSpace,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, *(void *)(v95 + 24), &v94, (uint64_t *)&v98);
      (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, v87, v88);
    }
    else
    {
      uint64_t v60 = v40;
      while (1)
      {
        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v98, (llvm::APInt *)v96);
        unsigned int v61 = v96[1];
        int v62 = v96[0];
        if (v60
          && (LODWORD(v96[1]) > 0x40
            ? (uint64_t v63 = *(void *)v96[0])
            : (uint64_t v63 = (uint64_t)v96[0] << -LOBYTE(v96[1]) >> -LOBYTE(v96[1])),
              v63 == v90))
        {
          *((void *)__p + 2) = *(void *)v100;
          int v64 = 1;
        }
        else
        {
          uint64_t v65 = LODWORD(v96[1]) > 0x40 ? *(void *)v96[0] : (uint64_t)v96[0] << -LOBYTE(v96[1]) >> -LOBYTE(v96[1]);
          if (v65 == v91)
          {
            *((void *)__p + 1) = *(void *)v100;
            int v64 = 1;
          }
          else
          {
            uint64_t v66 = *(void *)v100;
            if (v65 == v89)
            {
              *(void *)long long __p = v66;
              int v64 = 1;
            }
            else if (v66 == 1)
            {
              int v64 = 1;
            }
            else
            {
              uint64_t v40 = a4[2];
              if (v40)
              {
                uint64_t v67 = v95;
                if (mlir::RewriterBase::Listener::classof(a4[2])) {
                else
                }
                  uint64_t v40 = 0;
              }
              int v64 = 0;
            }
          }
        }
        if (v61 >= 0x41 && v62) {
          operator delete[](v62);
        }
        if (!v64) {
          break;
        }
        uint64_t v68 = v100 + 8;
        *(void *)&long long v99 = v99 + 1;
        v100 += 8;
        if ((void)v99 == v56 && BYTE8(v98) == v55 && (void)v98 == (void)v54 || v68 == v59) {
          goto LABEL_84;
        }
      }
    }
    if (__p != &v103) {
      free(__p);
    }
  }
  else
  {
    uint64_t v85 = a4[2];
    if (v85 && (uint64_t v86 = v95, mlir::RewriterBase::Listener::classof(v85))) {
    else
    }
      uint64_t v40 = 0;
  }
  if (RankPromotionTypeForANE != v107) {
    free(RankPromotionTypeForANE);
  }
  return v40;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::BatchToSpaceOp &>(mlir::mps::BatchToSpaceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::BatchToSpaceOp,mlir::anec::BatchToSpace>::matchAndRewriteWithStaticShapes(mlir::mps::BatchToSpaceOp,mlir::mps::BatchToSpaceOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace spatial_axis operand must be constant\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::BatchToSpaceOp,mlir::anec::BatchToSpace>::matchAndRewriteWithStaticShapes(mlir::mps::BatchToSpaceOp,mlir::mps::BatchToSpaceOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace batch_axis operand must be constant\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::BatchToSpaceOp,mlir::anec::BatchToSpace>::matchAndRewriteWithStaticShapes(mlir::mps::BatchToSpaceOp,mlir::mps::BatchToSpaceOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace batch_axis operand must match with ANEC batch axis\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::BatchToSpaceOp,mlir::anec::BatchToSpace>::matchAndRewriteWithStaticShapes(mlir::mps::BatchToSpaceOp,mlir::mps::BatchToSpaceOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace block_dimensions operand must be constant\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::BatchToSpaceOp,mlir::anec::BatchToSpace>::matchAndRewriteWithStaticShapes(mlir::mps::BatchToSpaceOp,mlir::mps::BatchToSpaceOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace spatial_axes operand must match with ANEC spatial axes\n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::BatchToSpace,mlir::Value &,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.batch_to_space", (const unsigned __int8 *)0x13, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.batch_to_space";
    v17[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::BatchToSpace::build(a1, (uint64_t)v19, *a3, *a4);
  unsigned int v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::BatchToSpace,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::SpaceToBatchOp,mlir::anec::SpaceToBatch>::~ConvertBatchToSpace(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::SpaceToBatchOp,mlir::anec::SpaceToBatch>::~ConvertBatchToSpace(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SpaceToBatchOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SpaceToBatchOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SpaceToBatchOpGenericAdaptorBase::SpaceToBatchOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SpaceToBatchOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SpaceToBatchOpGenericAdaptorBase::SpaceToBatchOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SpaceToBatchOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 48);
  uint64_t v9 = *(void *)(a3 + 56);
  unint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        unint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v33 = 259;
      v30[0] = v32;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SpaceToBatchOp &>(mlir::mps::SpaceToBatchOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v34[0] = *(_OWORD *)a3;
        v34[1] = v28;
        long long v29 = *(_OWORD *)(a3 + 48);
        uint64_t v34[2] = *(_OWORD *)(a3 + 32);
        v34[3] = v29;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  unint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SpaceToBatchOp &>(mlir::mps::SpaceToBatchOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::SpaceToBatchOp,mlir::anec::SpaceToBatch>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v109 = *MEMORY[0x1E4F143B8];
  uint64_t v95 = a2;
  long long v108 = *(_OWORD *)(a3 + 48);
  uint64_t v5 = mlir::ValueRange::dereference_iterator(&v108, 0);
  uint64_t v94 = v5;
  unint64_t v6 = (char *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *(void *)v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  unsigned int v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  uint64_t RankPromotionTypeForANE = v6;
  uint64_t v106 = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  unint64_t v18 = v17;
  uint64_t v19 = (uint64_t *)(*(void *)(v5 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *v19;
  unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v22 = *(unsigned int *)(v20 + 16);
  if (!v22) {
    goto LABEL_20;
  }
  uint64_t v23 = *(void **)(v20 + 8);
  uint64_t v24 = &v23[2 * v22];
  do
  {
    unint64_t v25 = v22 >> 1;
    uint64_t v26 = &v23[2 * (v22 >> 1)];
    unint64_t v28 = *v26;
    uint64_t v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21) {
      uint64_t v23 = v27;
    }
    else {
      unint64_t v22 = v25;
    }
  }
  while (v22);
  if (v23 != v24 && *v23 == v21) {
    uint64_t v29 = v23[1];
  }
  else {
LABEL_20:
  }
    uint64_t v29 = 0;
  uint64_t RankPromotionTypeForANE = (char *)mlir::getRankPromotionTypeForANE((uint64_t)v19, v29);
  uint64_t v106 = v30;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  unint64_t v32 = v31;
  Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  v93[0] = mlir::getSortedUniquePromotedPositiveAxesAttr(Filter, v18, *(void *)(v95 + 24), 1);
  v93[1] = v34;
  if (!(_BYTE)v34)
  {
    uint64_t v43 = a4[2];
    if (v43)
    {
      uint64_t v47 = v95;
      if (mlir::RewriterBase::Listener::classof(v43))
      {
        uint64_t v45 = *(void *)(v47 + 24);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), char **))(*(void *)v43 + 64))(v43, v45, v46, &RankPromotionTypeForANE);
      }
    }
    return 0;
  }
  Bias = (void *)mlir::anec::GOC::getBias((mlir::anec::GOC *)&v95);
  v92[0] = mlir::getSortedUniquePromotedPositiveAxesAttr(Bias, v18, *(void *)(v95 + 24), 1);
  v92[1] = v36;
  if (!(_BYTE)v36)
  {
    uint64_t v43 = a4[2];
    if (v43)
    {
      uint64_t v48 = v95;
      if (mlir::RewriterBase::Listener::classof(v43))
      {
        uint64_t v45 = *(void *)(v48 + 24);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), char **))(*(void *)v43 + 64))(v43, v45, v46, &RankPromotionTypeForANE);
      }
    }
    return 0;
  }
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(0, v32);
  unint64_t v38 = mlir::anec::getIndexFromDim(2, v32);
  uint64_t v40 = v39;
  unint64_t v91 = mlir::anec::getIndexFromDim(3, v32);
  unint64_t v41 = mlir::anec::getIndexFromDim(4, v32);
  if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v92) != 1)
  {
LABEL_26:
    uint64_t v43 = a4[2];
    if (v43)
    {
      uint64_t v44 = v95;
      if (mlir::RewriterBase::Listener::classof(v43))
      {
        uint64_t v45 = *(void *)(v44 + 24);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), char **))(*(void *)v43 + 64))(v43, v45, v46, &RankPromotionTypeForANE);
      }
    }
    return 0;
  }
  uint64_t v42 = mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&RankPromotionTypeForANE, v92[0], 0);
  mlir::DenseElementsAttr::IntElementIterator::operator*(v42, (llvm::APInt *)&__p);
  if (v102 >= 0x41)
  {
    uint64_t v50 = *(void *)__p;
    operator delete[](__p);
    if (IndexFromDim != v50) {
      goto LABEL_26;
    }
  }
  else if (IndexFromDim != (uint64_t)((void)__p << -(uint64_t)v102) >> -(uint64_t)v102)
  {
    goto LABEL_26;
  }
  uint64_t RankPromotionTypeForANE = v107;
  uint64_t v106 = 0x300000000;
  uint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v95);
  if (mlir::matchConstantWithIntVector<unsigned long long>(SparseShape, (uint64_t)&RankPromotionTypeForANE))
  {
    unint64_t v89 = v41;
    unint64_t v90 = v38;
    long long __p = &v103;
    uint64_t v104 = 1;
    long long v103 = xmmword_181110BC0;
    uint64_t v102 = 0x300000003;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v96, v93[0], 0);
    long long v98 = *(_OWORD *)v96;
    long long v99 = v97;
    uint64_t v100 = RankPromotionTypeForANE;
    uint64_t v52 = v93[0];
    uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v93);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v96, v52, NumElements);
    unint64_t v54 = v96[0];
    int v55 = LOBYTE(v96[1]);
    uint64_t v56 = v97;
    BOOL v58 = (void)v99 == (void)v97 && BYTE8(v98) == LOBYTE(v96[1]) && (void *)v98 == v96[0];
    if (v58 || (unint64_t v59 = &RankPromotionTypeForANE[8 * v106], v100 == v59))
    {
LABEL_84:
      *(void *)&long long v98 = 3;
      uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
      uint64_t v73 = (void *)mlir::RankedTensorType::get((uint64_t)&v98, 1, IntegerType, 0);
      uint64_t v74 = v73;
      if (v73
        && (uint64_t v75 = *v73, v76 = mlir::TypeID::get<mlir::ShapedType>(), v77 = *(unsigned int *)(v75 + 16), v77))
      {
        uint64_t v78 = *(void **)(v75 + 8);
        unint64_t v79 = &v78[2 * v77];
        do
        {
          unint64_t v80 = v77 >> 1;
          int v81 = &v78[2 * (v77 >> 1)];
          unint64_t v83 = *v81;
          uint64_t v82 = v81 + 2;
          v77 += ~(v77 >> 1);
          if (v83 < v76) {
            uint64_t v78 = v82;
          }
          else {
            unint64_t v77 = v80;
          }
        }
        while (v77);
        if (v78 != v79 && *v78 == v76) {
          uint64_t v84 = v78[1];
        }
        else {
          uint64_t v84 = 0;
        }
      }
      else
      {
        uint64_t v84 = 0;
      }
      uint64_t v40 = 1;
      *(void *)&long long v98 = mlir::DenseElementsAttr::getFromRawBuffer(v74, v84, __p, 8 * v102, 8, 1, 0);
      uint64_t v87 = v95;
      uint64_t v88 = mlir::OpBuilder::create<mlir::anec::SpaceToBatch,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, *(void *)(v95 + 24), &v94, (uint64_t *)&v98);
      (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, v87, v88);
    }
    else
    {
      uint64_t v60 = v40;
      while (1)
      {
        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v98, (llvm::APInt *)v96);
        unsigned int v61 = v96[1];
        int v62 = v96[0];
        if (v60
          && (LODWORD(v96[1]) > 0x40
            ? (uint64_t v63 = *(void *)v96[0])
            : (uint64_t v63 = (uint64_t)v96[0] << -LOBYTE(v96[1]) >> -LOBYTE(v96[1])),
              v63 == v90))
        {
          *((void *)__p + 2) = *(void *)v100;
          int v64 = 1;
        }
        else
        {
          uint64_t v65 = LODWORD(v96[1]) > 0x40 ? *(void *)v96[0] : (uint64_t)v96[0] << -LOBYTE(v96[1]) >> -LOBYTE(v96[1]);
          if (v65 == v91)
          {
            *((void *)__p + 1) = *(void *)v100;
            int v64 = 1;
          }
          else
          {
            uint64_t v66 = *(void *)v100;
            if (v65 == v89)
            {
              *(void *)long long __p = v66;
              int v64 = 1;
            }
            else if (v66 == 1)
            {
              int v64 = 1;
            }
            else
            {
              uint64_t v40 = a4[2];
              if (v40)
              {
                uint64_t v67 = v95;
                if (mlir::RewriterBase::Listener::classof(a4[2])) {
                else
                }
                  uint64_t v40 = 0;
              }
              int v64 = 0;
            }
          }
        }
        if (v61 >= 0x41 && v62) {
          operator delete[](v62);
        }
        if (!v64) {
          break;
        }
        uint64_t v68 = v100 + 8;
        *(void *)&long long v99 = v99 + 1;
        v100 += 8;
        if ((void)v99 == v56 && BYTE8(v98) == v55 && (void)v98 == (void)v54 || v68 == v59) {
          goto LABEL_84;
        }
      }
    }
    if (__p != &v103) {
      free(__p);
    }
  }
  else
  {
    uint64_t v85 = a4[2];
    if (v85 && (uint64_t v86 = v95, mlir::RewriterBase::Listener::classof(v85))) {
    else
    }
      uint64_t v40 = 0;
  }
  if (RankPromotionTypeForANE != v107) {
    free(RankPromotionTypeForANE);
  }
  return v40;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SpaceToBatchOp &>(mlir::mps::SpaceToBatchOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::SpaceToBatchOp,mlir::anec::SpaceToBatch>::matchAndRewriteWithStaticShapes(mlir::mps::SpaceToBatchOp,mlir::mps::SpaceToBatchOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace spatial_axis operand must be constant\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::SpaceToBatchOp,mlir::anec::SpaceToBatch>::matchAndRewriteWithStaticShapes(mlir::mps::SpaceToBatchOp,mlir::mps::SpaceToBatchOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace batch_axis operand must be constant\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::SpaceToBatchOp,mlir::anec::SpaceToBatch>::matchAndRewriteWithStaticShapes(mlir::mps::SpaceToBatchOp,mlir::mps::SpaceToBatchOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace batch_axis operand must match with ANEC batch axis\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::SpaceToBatchOp,mlir::anec::SpaceToBatch>::matchAndRewriteWithStaticShapes(mlir::mps::SpaceToBatchOp,mlir::mps::SpaceToBatchOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace block_dimensions operand must be constant\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::SpaceToBatchOp,mlir::anec::SpaceToBatch>::matchAndRewriteWithStaticShapes(mlir::mps::SpaceToBatchOp,mlir::mps::SpaceToBatchOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace spatial_axes operand must match with ANEC spatial axes\n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::SpaceToBatch,mlir::Value &,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.space_to_batch", (const unsigned __int8 *)0x13, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.space_to_batch";
    v17[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::SpaceToBatch::build(a1, (uint64_t)v19, *a3, *a4);
  unsigned int v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::SpaceToBatch,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)0>::~ConvertTranspose(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)0>::~ConvertTranspose(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::TransposeOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::TransposeOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::TransposeOpGenericAdaptorBase::TransposeOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::TransposeOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::TransposeOpGenericAdaptorBase::TransposeOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::TransposeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  unint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        unint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TransposeOp &>(mlir::mps::TransposeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TransposeOp &>(mlir::mps::TransposeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v37 = a2;
  long long v47 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  unsigned int v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v36[0] = v6;
  v36[1] = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v36);
  unint64_t v18 = v17;
  v45[0] = &v46;
  v45[1] = (void *)0x100000000;
  v43[0] = &v44;
  v43[1] = (void *)0x100000000;
  unsigned int ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 1u);
  uint64_t v20 = *(void **)(a3 + 40);
  uint64_t v40 = v20;
  uint64_t v41 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    uint64_t v20 = (void *)mlir::ValueRange::offset_base(&v40, ODSOperandIndexAndLength);
  }
  uint64_t v40 = v20;
  uint64_t v41 = 0;
  uint64_t v21 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (!mlir::matchConstantWithIntVector<long long>(v21, (uint64_t)v45)) {
    goto LABEL_23;
  }
  unsigned int v22 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 2u);
  uint64_t v23 = *(void **)(a3 + 40);
  uint64_t v40 = v23;
  uint64_t v41 = v22;
  if (v22) {
    uint64_t v23 = (void *)mlir::ValueRange::offset_base(&v40, v22);
  }
  uint64_t v40 = v23;
  uint64_t v41 = 0;
  uint64_t v24 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (mlir::matchConstantWithIntVector<long long>(v24, (uint64_t)v43))
  {
    uint64_t v25 = *(void *)v45[0];
    uint64_t v26 = *(void *)v43[0];
    uint64_t v40 = v42;
    v42[0] = v25;
    v42[1] = v26;
    uint64_t v41 = 0x600000002;
    v38[0] = v39;
    v38[1] = (void *)0x600000000;
    if (mlir::getPositivePromotedAxes(v42, 2, v18, (uint64_t)v38, 0, 0))
    {
      uint64_t v27 = v37;
      uint64_t v28 = *(void *)v38[0];
      uint64_t v34 = *((void *)v38[0] + 1);
      unint64_t v35 = (uint64_t *)v28;
      uint64_t v33 = mlir::ValueRange::dereference_iterator(&v47, 0);
      uint64_t v29 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 1), *(void *)(v27 + 24), &v33, (uint64_t *)&v35, &v34);
      (*(void (**)(void *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, v27, v29);
      uint64_t v30 = 1;
    }
    else
    {
      uint64_t v32 = v37;
      unint64_t v35 = &v37;
      uint64_t v30 = a4[2];
      if (v30)
      {
        if (mlir::RewriterBase::Listener::classof(v30)) {
        else
        }
          uint64_t v30 = 0;
      }
    }
    if (v38[0] != v39) {
      free(v38[0]);
    }
    if (v40 != v42) {
      free(v40);
    }
  }
  else
  {
LABEL_23:
    uint64_t v30 = 0;
  }
  if (v43[0] != &v44) {
    free(v43[0]);
  }
  if (v45[0] != &v46) {
    free(v45[0]);
  }
  return v30;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TransposeOp &>(mlir::mps::TransposeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::TransposeOp,mlir::mps::TransposeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract positive axes from Op ");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

void *mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)1>::~ConvertTranspose(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)1>::~ConvertTranspose(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v37 = a2;
  long long v47 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  unsigned int v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v36[0] = v6;
  v36[1] = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v36);
  unint64_t v18 = v17;
  v45[0] = &v46;
  v45[1] = (void *)0x100000000;
  v43[0] = &v44;
  v43[1] = (void *)0x100000000;
  unsigned int ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 1u);
  uint64_t v20 = *(void **)(a3 + 40);
  uint64_t v40 = v20;
  uint64_t v41 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    uint64_t v20 = (void *)mlir::ValueRange::offset_base(&v40, ODSOperandIndexAndLength);
  }
  uint64_t v40 = v20;
  uint64_t v41 = 0;
  uint64_t v21 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (!mlir::matchConstantWithIntVector<long long>(v21, (uint64_t)v45)) {
    goto LABEL_23;
  }
  unsigned int v22 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 2u);
  uint64_t v23 = *(void **)(a3 + 40);
  uint64_t v40 = v23;
  uint64_t v41 = v22;
  if (v22) {
    uint64_t v23 = (void *)mlir::ValueRange::offset_base(&v40, v22);
  }
  uint64_t v40 = v23;
  uint64_t v41 = 0;
  uint64_t v24 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (mlir::matchConstantWithIntVector<long long>(v24, (uint64_t)v43))
  {
    uint64_t v25 = *(void *)v45[0];
    uint64_t v26 = *(void *)v43[0];
    uint64_t v40 = v42;
    v42[0] = v25;
    v42[1] = v26;
    uint64_t v41 = 0x600000002;
    v38[0] = v39;
    v38[1] = (void *)0x600000000;
    if (mlir::getPositivePromotedAxes(v42, 2, v18, (uint64_t)v38, 0, 0))
    {
      uint64_t v27 = v37;
      uint64_t v28 = *(void *)v38[0];
      uint64_t v34 = *((void *)v38[0] + 1);
      unint64_t v35 = (uint64_t *)v28;
      uint64_t v33 = mlir::ValueRange::dereference_iterator(&v47, 0);
      uint64_t v29 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 1), *(void *)(v27 + 24), &v33, (uint64_t *)&v35, &v34);
      (*(void (**)(void *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, v27, v29);
      uint64_t v30 = 1;
    }
    else
    {
      uint64_t v32 = v37;
      unint64_t v35 = &v37;
      uint64_t v30 = a4[2];
      if (v30)
      {
        if (mlir::RewriterBase::Listener::classof(v30)) {
        else
        }
          uint64_t v30 = 0;
      }
    }
    if (v38[0] != v39) {
      free(v38[0]);
    }
    if (v40 != v42) {
      free(v40);
    }
  }
  else
  {
LABEL_23:
    uint64_t v30 = 0;
  }
  if (v43[0] != &v44) {
    free(v43[0]);
  }
  if (v45[0] != &v46) {
    free(v45[0]);
  }
  return v30;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::TransposeOp,mlir::mps::TransposeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract positive axes from Op ");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

void *mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)2>::~ConvertTranspose(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)2>::~ConvertTranspose(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v37 = a2;
  long long v47 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  unsigned int v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v36[0] = v6;
  v36[1] = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v36);
  unint64_t v18 = v17;
  v45[0] = &v46;
  v45[1] = (void *)0x100000000;
  v43[0] = &v44;
  v43[1] = (void *)0x100000000;
  unsigned int ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 1u);
  uint64_t v20 = *(void **)(a3 + 40);
  uint64_t v40 = v20;
  uint64_t v41 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    uint64_t v20 = (void *)mlir::ValueRange::offset_base(&v40, ODSOperandIndexAndLength);
  }
  uint64_t v40 = v20;
  uint64_t v41 = 0;
  uint64_t v21 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (!mlir::matchConstantWithIntVector<long long>(v21, (uint64_t)v45)) {
    goto LABEL_23;
  }
  unsigned int v22 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 2u);
  uint64_t v23 = *(void **)(a3 + 40);
  uint64_t v40 = v23;
  uint64_t v41 = v22;
  if (v22) {
    uint64_t v23 = (void *)mlir::ValueRange::offset_base(&v40, v22);
  }
  uint64_t v40 = v23;
  uint64_t v41 = 0;
  uint64_t v24 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (mlir::matchConstantWithIntVector<long long>(v24, (uint64_t)v43))
  {
    uint64_t v25 = *(void *)v45[0];
    uint64_t v26 = *(void *)v43[0];
    uint64_t v40 = v42;
    v42[0] = v25;
    v42[1] = v26;
    uint64_t v41 = 0x600000002;
    v38[0] = v39;
    v38[1] = (void *)0x600000000;
    if (mlir::getPositivePromotedAxes(v42, 2, v18, (uint64_t)v38, 0, 0))
    {
      uint64_t v27 = v37;
      uint64_t v28 = *(void *)v38[0];
      uint64_t v34 = *((void *)v38[0] + 1);
      unint64_t v35 = (uint64_t *)v28;
      uint64_t v33 = mlir::ValueRange::dereference_iterator(&v47, 0);
      uint64_t v29 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 1), *(void *)(v27 + 24), &v33, (uint64_t *)&v35, &v34);
      (*(void (**)(void *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, v27, v29);
      uint64_t v30 = 1;
    }
    else
    {
      uint64_t v32 = v37;
      unint64_t v35 = &v37;
      uint64_t v30 = a4[2];
      if (v30)
      {
        if (mlir::RewriterBase::Listener::classof(v30)) {
        else
        }
          uint64_t v30 = 0;
      }
    }
    if (v38[0] != v39) {
      free(v38[0]);
    }
    if (v40 != v42) {
      free(v40);
    }
  }
  else
  {
LABEL_23:
    uint64_t v30 = 0;
  }
  if (v43[0] != &v44) {
    free(v43[0]);
  }
  if (v45[0] != &v46) {
    free(v45[0]);
  }
  return v30;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(mlir::mps::TransposeOp,mlir::mps::TransposeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract positive axes from Op ");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

void *mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)3>::~ConvertTranspose(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)3>::~ConvertTranspose(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v37 = a2;
  long long v47 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  unsigned int v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v36[0] = v6;
  v36[1] = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v36);
  unint64_t v18 = v17;
  v45[0] = &v46;
  v45[1] = (void *)0x100000000;
  v43[0] = &v44;
  v43[1] = (void *)0x100000000;
  unsigned int ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 1u);
  uint64_t v20 = *(void **)(a3 + 40);
  uint64_t v40 = v20;
  uint64_t v41 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    uint64_t v20 = (void *)mlir::ValueRange::offset_base(&v40, ODSOperandIndexAndLength);
  }
  uint64_t v40 = v20;
  uint64_t v41 = 0;
  uint64_t v21 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (!mlir::matchConstantWithIntVector<long long>(v21, (uint64_t)v45)) {
    goto LABEL_23;
  }
  unsigned int v22 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 2u);
  uint64_t v23 = *(void **)(a3 + 40);
  uint64_t v40 = v23;
  uint64_t v41 = v22;
  if (v22) {
    uint64_t v23 = (void *)mlir::ValueRange::offset_base(&v40, v22);
  }
  uint64_t v40 = v23;
  uint64_t v41 = 0;
  uint64_t v24 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (mlir::matchConstantWithIntVector<long long>(v24, (uint64_t)v43))
  {
    uint64_t v25 = *(void *)v45[0];
    uint64_t v26 = *(void *)v43[0];
    uint64_t v40 = v42;
    v42[0] = v25;
    v42[1] = v26;
    uint64_t v41 = 0x600000002;
    v38[0] = v39;
    v38[1] = (void *)0x600000000;
    if (mlir::getPositivePromotedAxes(v42, 2, v18, (uint64_t)v38, 0, 0))
    {
      uint64_t v27 = v37;
      uint64_t v28 = *(void *)v38[0];
      uint64_t v34 = *((void *)v38[0] + 1);
      unint64_t v35 = (uint64_t *)v28;
      uint64_t v33 = mlir::ValueRange::dereference_iterator(&v47, 0);
      uint64_t v29 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 1), *(void *)(v27 + 24), &v33, (uint64_t *)&v35, &v34);
      (*(void (**)(void *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, v27, v29);
      uint64_t v30 = 1;
    }
    else
    {
      uint64_t v32 = v37;
      unint64_t v35 = &v37;
      uint64_t v30 = a4[2];
      if (v30)
      {
        if (mlir::RewriterBase::Listener::classof(v30)) {
        else
        }
          uint64_t v30 = 0;
      }
    }
    if (v38[0] != v39) {
      free(v38[0]);
    }
    if (v40 != v42) {
      free(v40);
    }
  }
  else
  {
LABEL_23:
    uint64_t v30 = 0;
  }
  if (v43[0] != &v44) {
    free(v43[0]);
  }
  if (v45[0] != &v46) {
    free(v45[0]);
  }
  return v30;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(mlir::mps::TransposeOp,mlir::mps::TransposeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract positive axes from Op ");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

void *mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)4>::~ConvertTranspose(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)4>::~ConvertTranspose(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v37 = a2;
  long long v47 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  unsigned int v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v36[0] = v6;
  v36[1] = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v36);
  unint64_t v18 = v17;
  v45[0] = &v46;
  v45[1] = (void *)0x100000000;
  v43[0] = &v44;
  v43[1] = (void *)0x100000000;
  unsigned int ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 1u);
  uint64_t v20 = *(void **)(a3 + 40);
  uint64_t v40 = v20;
  uint64_t v41 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    uint64_t v20 = (void *)mlir::ValueRange::offset_base(&v40, ODSOperandIndexAndLength);
  }
  uint64_t v40 = v20;
  uint64_t v41 = 0;
  uint64_t v21 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (!mlir::matchConstantWithIntVector<long long>(v21, (uint64_t)v45)) {
    goto LABEL_23;
  }
  unsigned int v22 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 2u);
  uint64_t v23 = *(void **)(a3 + 40);
  uint64_t v40 = v23;
  uint64_t v41 = v22;
  if (v22) {
    uint64_t v23 = (void *)mlir::ValueRange::offset_base(&v40, v22);
  }
  uint64_t v40 = v23;
  uint64_t v41 = 0;
  uint64_t v24 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (mlir::matchConstantWithIntVector<long long>(v24, (uint64_t)v43))
  {
    uint64_t v25 = *(void *)v45[0];
    uint64_t v26 = *(void *)v43[0];
    uint64_t v40 = v42;
    v42[0] = v25;
    v42[1] = v26;
    uint64_t v41 = 0x600000002;
    v38[0] = v39;
    v38[1] = (void *)0x600000000;
    if (mlir::getPositivePromotedAxes(v42, 2, v18, (uint64_t)v38, 0, 0))
    {
      uint64_t v27 = v37;
      uint64_t v28 = *(void *)v38[0];
      uint64_t v34 = *((void *)v38[0] + 1);
      unint64_t v35 = (uint64_t *)v28;
      uint64_t v33 = mlir::ValueRange::dereference_iterator(&v47, 0);
      uint64_t v29 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 1), *(void *)(v27 + 24), &v33, (uint64_t *)&v35, &v34);
      (*(void (**)(void *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, v27, v29);
      uint64_t v30 = 1;
    }
    else
    {
      uint64_t v32 = v37;
      unint64_t v35 = &v37;
      uint64_t v30 = a4[2];
      if (v30)
      {
        if (mlir::RewriterBase::Listener::classof(v30)) {
        else
        }
          uint64_t v30 = 0;
      }
    }
    if (v38[0] != v39) {
      free(v38[0]);
    }
    if (v40 != v42) {
      free(v40);
    }
  }
  else
  {
LABEL_23:
    uint64_t v30 = 0;
  }
  if (v43[0] != &v44) {
    free(v43[0]);
  }
  if (v45[0] != &v46) {
    free(v45[0]);
  }
  return v30;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(mlir::mps::TransposeOp,mlir::mps::TransposeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract positive axes from Op ");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

void *mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)5>::~ConvertTranspose(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)5>::~ConvertTranspose(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v37 = a2;
  long long v47 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  unsigned int v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v36[0] = v6;
  v36[1] = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v36);
  unint64_t v18 = v17;
  v45[0] = &v46;
  v45[1] = (void *)0x100000000;
  v43[0] = &v44;
  v43[1] = (void *)0x100000000;
  unsigned int ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 1u);
  uint64_t v20 = *(void **)(a3 + 40);
  uint64_t v40 = v20;
  uint64_t v41 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    uint64_t v20 = (void *)mlir::ValueRange::offset_base(&v40, ODSOperandIndexAndLength);
  }
  uint64_t v40 = v20;
  uint64_t v41 = 0;
  uint64_t v21 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (!mlir::matchConstantWithIntVector<long long>(v21, (uint64_t)v45)) {
    goto LABEL_23;
  }
  unsigned int v22 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 2u);
  uint64_t v23 = *(void **)(a3 + 40);
  uint64_t v40 = v23;
  uint64_t v41 = v22;
  if (v22) {
    uint64_t v23 = (void *)mlir::ValueRange::offset_base(&v40, v22);
  }
  uint64_t v40 = v23;
  uint64_t v41 = 0;
  uint64_t v24 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (mlir::matchConstantWithIntVector<long long>(v24, (uint64_t)v43))
  {
    uint64_t v25 = *(void *)v45[0];
    uint64_t v26 = *(void *)v43[0];
    uint64_t v40 = v42;
    v42[0] = v25;
    v42[1] = v26;
    uint64_t v41 = 0x600000002;
    v38[0] = v39;
    v38[1] = (void *)0x600000000;
    if (mlir::getPositivePromotedAxes(v42, 2, v18, (uint64_t)v38, 0, 0))
    {
      uint64_t v27 = v37;
      uint64_t v28 = *(void *)v38[0];
      uint64_t v34 = *((void *)v38[0] + 1);
      unint64_t v35 = (uint64_t *)v28;
      uint64_t v33 = mlir::ValueRange::dereference_iterator(&v47, 0);
      uint64_t v29 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 1), *(void *)(v27 + 24), &v33, (uint64_t *)&v35, &v34);
      (*(void (**)(void *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, v27, v29);
      uint64_t v30 = 1;
    }
    else
    {
      uint64_t v32 = v37;
      unint64_t v35 = &v37;
      uint64_t v30 = a4[2];
      if (v30)
      {
        if (mlir::RewriterBase::Listener::classof(v30)) {
        else
        }
          uint64_t v30 = 0;
      }
    }
    if (v38[0] != v39) {
      free(v38[0]);
    }
    if (v40 != v42) {
      free(v40);
    }
  }
  else
  {
LABEL_23:
    uint64_t v30 = 0;
  }
  if (v43[0] != &v44) {
    free(v43[0]);
  }
  if (v45[0] != &v46) {
    free(v45[0]);
  }
  return v30;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(mlir::mps::TransposeOp,mlir::mps::TransposeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract positive axes from Op ");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

void *mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)6>::~ConvertTranspose(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)6>::~ConvertTranspose(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v37 = a2;
  long long v47 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  unsigned int v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v36[0] = v6;
  v36[1] = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v36);
  unint64_t v18 = v17;
  v45[0] = &v46;
  v45[1] = (void *)0x100000000;
  v43[0] = &v44;
  v43[1] = (void *)0x100000000;
  unsigned int ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 1u);
  uint64_t v20 = *(void **)(a3 + 40);
  uint64_t v40 = v20;
  uint64_t v41 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    uint64_t v20 = (void *)mlir::ValueRange::offset_base(&v40, ODSOperandIndexAndLength);
  }
  uint64_t v40 = v20;
  uint64_t v41 = 0;
  uint64_t v21 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (!mlir::matchConstantWithIntVector<long long>(v21, (uint64_t)v45)) {
    goto LABEL_23;
  }
  unsigned int v22 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 2u);
  uint64_t v23 = *(void **)(a3 + 40);
  uint64_t v40 = v23;
  uint64_t v41 = v22;
  if (v22) {
    uint64_t v23 = (void *)mlir::ValueRange::offset_base(&v40, v22);
  }
  uint64_t v40 = v23;
  uint64_t v41 = 0;
  uint64_t v24 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (mlir::matchConstantWithIntVector<long long>(v24, (uint64_t)v43))
  {
    uint64_t v25 = *(void *)v45[0];
    uint64_t v26 = *(void *)v43[0];
    uint64_t v40 = v42;
    v42[0] = v25;
    v42[1] = v26;
    uint64_t v41 = 0x600000002;
    v38[0] = v39;
    v38[1] = (void *)0x600000000;
    if (mlir::getPositivePromotedAxes(v42, 2, v18, (uint64_t)v38, 0, 0))
    {
      uint64_t v27 = v37;
      uint64_t v28 = *(void *)v38[0];
      uint64_t v34 = *((void *)v38[0] + 1);
      unint64_t v35 = (uint64_t *)v28;
      uint64_t v33 = mlir::ValueRange::dereference_iterator(&v47, 0);
      uint64_t v29 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 1), *(void *)(v27 + 24), &v33, (uint64_t *)&v35, &v34);
      (*(void (**)(void *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, v27, v29);
      uint64_t v30 = 1;
    }
    else
    {
      uint64_t v32 = v37;
      unint64_t v35 = &v37;
      uint64_t v30 = a4[2];
      if (v30)
      {
        if (mlir::RewriterBase::Listener::classof(v30)) {
        else
        }
          uint64_t v30 = 0;
      }
    }
    if (v38[0] != v39) {
      free(v38[0]);
    }
    if (v40 != v42) {
      free(v40);
    }
  }
  else
  {
LABEL_23:
    uint64_t v30 = 0;
  }
  if (v43[0] != &v44) {
    free(v43[0]);
  }
  if (v45[0] != &v46) {
    free(v45[0]);
  }
  return v30;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(mlir::mps::TransposeOp,mlir::mps::TransposeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract positive axes from Op ");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

void *mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)0>::~ConvertBroadcast(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)0>::~ConvertBroadcast(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BroadcastToOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::BroadcastToOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::BroadcastToOpGenericAdaptorBase::BroadcastToOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BroadcastToOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::BroadcastToOpGenericAdaptorBase::BroadcastToOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::BroadcastToOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  unint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        unint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::BroadcastToOp &>(mlir::mps::BroadcastToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::BroadcastToOp &>(mlir::mps::BroadcastToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, mlir::UnknownLoc **a4)
{
  uint64_t v89 = *MEMORY[0x1E4F143B8];
  long long v88 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (void *)(*(void *)(mlir::ValueRange::dereference_iterator(&v88, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  unsigned int v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  uint64_t v75 = v6;
  uint64_t v76 = v16;
  uint64_t v85 = v87;
  uint64_t v86 = 0x500000000;
  uint64_t v17 = mlir::ValueRange::dereference_iterator(&v88, 1);
  if (!mlir::matchConstantWithIntVector<long long>(v17, (uint64_t)&v85))
  {
    uint64_t v48 = (uint64_t)a4[2];
    if (v48 && mlir::RewriterBase::Listener::classof(v48))
    {
      uint64_t v49 = *(void *)(a2 + 24);
LABEL_35:
      uint64_t v51 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v48 + 64))(v48, v49, v50, &SplatF16ElementsAttr);
      goto LABEL_57;
    }
LABEL_36:
    uint64_t v51 = 0;
    goto LABEL_57;
  }
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v75);
  unint64_t v18 = (uint64_t *)mlir::MemRefType::get(v85, (mlir::AffineMap *)v86, OperandRange, 0, 0, 0);
  uint64_t v19 = (uint64_t)v18;
  if (!v18) {
    goto LABEL_21;
  }
  uint64_t v20 = *v18;
  unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v22 = *(unsigned int *)(v20 + 16);
  if (!v22) {
    goto LABEL_21;
  }
  uint64_t v23 = *(void **)(v20 + 8);
  uint64_t v24 = &v23[2 * v22];
  do
  {
    unint64_t v25 = v22 >> 1;
    uint64_t v26 = &v23[2 * (v22 >> 1)];
    unint64_t v28 = *v26;
    uint64_t v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21) {
      uint64_t v23 = v27;
    }
    else {
      unint64_t v22 = v25;
    }
  }
  while (v22);
  if (v23 != v24 && *v23 == v21) {
    uint64_t v29 = v23[1];
  }
  else {
LABEL_21:
  }
    uint64_t v29 = 0;
  uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE(v19, v29);
  uint64_t v32 = v31;
  v73[0] = RankPromotionTypeForANE;
  v73[1] = v31;
  if (!mlir::Type::isF16((mlir::Type *)&OperandRange))
  {
    uint64_t v48 = (uint64_t)a4[2];
    if (v48 && mlir::RewriterBase::Listener::classof(v48))
    {
      uint64_t v49 = *(void *)(a2 + 24);
      goto LABEL_35;
    }
    goto LABEL_36;
  }
  uint64_t v33 = mlir::getRankPromotionTypeForANE((uint64_t)v75, v76);
  uint64_t v82 = v84;
  uint64_t v83 = 0x400000000;
  if (mlir::getBroadcastIndices(v33, v34, RankPromotionTypeForANE, v32, (uint64_t)&v82))
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v73);
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(4, v35);
    if (v83)
    {
      unint64_t v37 = IndexFromDim;
      unint64_t v38 = v82;
      uint64_t v39 = 8 * v83;
      while (IndexFromDim != *v38)
      {
        ++v38;
        v39 -= 8;
        if (!v39)
        {
          uint64_t v72 = mlir::ValueRange::dereference_iterator(&v88, 0);
          uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v73);
          uint64_t v42 = v41;
          uint64_t v43 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v73);
          uint64_t v44 = (void *)mlir::RankedTensorType::get(ArgAttrsAttr, v42, v43, 0);
          SplatF16ElementsAttr = mlir::createSplatF16ElementsAttr(v44, 0.0);
          uint64_t v80 = v45;
          uint64_t v46 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), *(void *)(a2 + 24), v73, (void **)&SplatF16ElementsAttr);
          v77[0] = mlir::ValueRange::dereference_iterator(&v88, 0);
          v77[1] = (char *)v46 - 16;
          mlir::ValueRange::ValueRange((unint64_t *)v78, (uint64_t)v77, 2uLL);
          long long v47 = mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,mlir::ValueRange>((uint64_t *)a4 + 1, *(void *)(a2 + 24), (uint64_t *)v78);
          (*((void (**)(mlir::UnknownLoc **, uint64_t, mlir::GenericProgramPoint *))*a4 + 4))(a4, a2, v47);
          goto LABEL_54;
        }
      }
      uint64_t v72 = mlir::ValueRange::dereference_iterator(&v88, 0);
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v73);
      unint64_t v56 = v55;
      SplatF16ElementsAttr = v81;
      HIDWORD(v80) = 5;
      if (v55 < 6)
      {
        if (!v55)
        {
LABEL_52:
          LODWORD(v80) = v56;
          uint64_t v59 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v73);
          uint64_t v60 = SplatF16ElementsAttr;
          *((void *)SplatF16ElementsAttr + v37) = *(void *)(v59 + 8 * v37);
          uint64_t v61 = v80;
          uint64_t v62 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v73);
          uint64_t v63 = (void *)mlir::RankedTensorType::get((uint64_t)v60, v61, v62, 0);
          v78[0] = mlir::createSplatF16ElementsAttr(v63, 1.0);
          v78[1] = v64;
          uint64_t v65 = *(void *)(a2 + 24);
          uint64_t v66 = SplatF16ElementsAttr;
          uint64_t v67 = (mlir::AffineMap *)v80;
          uint64_t v68 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v73);
          uint64_t v71 = mlir::MemRefType::get(v66, v67, v68, 0, 0, 0);
          v77[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), v65, &v71, v78);
          uint64_t v71 = 0;
          unsigned int v69 = mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::mps::ConstantOp &,decltype(nullptr)>(a4 + 1, *(void *)(a2 + 24), &v72, v77);
          (*((void (**)(mlir::UnknownLoc **, uint64_t, mlir::GenericProgramPoint *))*a4 + 4))(a4, a2, v69);
          if (SplatF16ElementsAttr != v81) {
            free(SplatF16ElementsAttr);
          }
LABEL_54:
          uint64_t v51 = 1;
          goto LABEL_55;
        }
        size_t v58 = 8 * v55;
        uint64_t v57 = v81;
      }
      else
      {
        LODWORD(v80) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&SplatF16ElementsAttr, v81, v55, 8);
        uint64_t v57 = SplatF16ElementsAttr;
        size_t v58 = 8 * v56;
      }
      memset_pattern16(v57, &unk_1810FE350, v58);
      goto LABEL_52;
    }
    uint64_t v52 = (uint64_t)a4[2];
    if (v52 && mlir::RewriterBase::Listener::classof(v52))
    {
      uint64_t v53 = *(void *)(a2 + 24);
      goto LABEL_44;
    }
  }
  else
  {
    uint64_t v52 = (uint64_t)a4[2];
    if (v52 && mlir::RewriterBase::Listener::classof(v52))
    {
      uint64_t v53 = *(void *)(a2 + 24);
LABEL_44:
      uint64_t v51 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v52 + 64))(v52, v53, v54, &SplatF16ElementsAttr);
      goto LABEL_55;
    }
  }
  uint64_t v51 = 0;
LABEL_55:
  if (v82 != v84) {
    free(v82);
  }
LABEL_57:
  if (v85 != v87) {
    free(v85);
  }
  return v51;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::BroadcastToOp &>(mlir::mps::BroadcastToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Operand 1 should be constant. \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Only fp16 is supported for A11/A12 Broadcasts. \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unable to determine A11/A12 Broadcast. \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported A11/A12 Broadcast. \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::mps::ConstantOp &,decltype(nullptr)>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, void *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.matmul", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.matmul";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::MatMul::build(a1, (uint64_t)v19, *a3, *a4 - 16, 0);
  unsigned int v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::MatMul,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,mlir::ValueRange>(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.add", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.add";
    v15[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::Ceil::build(a1, (uint64_t)v17, *a3, a3[1], 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id) {
    char v10 = v9;
  }
  else {
    char v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

void *mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)1>::~ConvertBroadcast(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)1>::~ConvertBroadcast(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, mlir::UnknownLoc **a4)
{
  uint64_t v89 = *MEMORY[0x1E4F143B8];
  long long v88 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (void *)(*(void *)(mlir::ValueRange::dereference_iterator(&v88, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  char v10 = *(void **)(v7 + 8);
  unsigned int v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    __int16 v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      char v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  uint64_t v75 = v6;
  uint64_t v76 = v16;
  uint64_t v85 = v87;
  uint64_t v86 = 0x500000000;
  uint64_t v17 = mlir::ValueRange::dereference_iterator(&v88, 1);
  if (!mlir::matchConstantWithIntVector<long long>(v17, (uint64_t)&v85))
  {
    uint64_t v48 = (uint64_t)a4[2];
    if (v48 && mlir::RewriterBase::Listener::classof(v48))
    {
      uint64_t v49 = *(void *)(a2 + 24);
LABEL_35:
      uint64_t v51 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v48 + 64))(v48, v49, v50, &SplatF16ElementsAttr);
      goto LABEL_57;
    }
LABEL_36:
    uint64_t v51 = 0;
    goto LABEL_57;
  }
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v75);
  __int16 v18 = (uint64_t *)mlir::MemRefType::get(v85, (mlir::AffineMap *)v86, OperandRange, 0, 0, 0);
  uint64_t v19 = (uint64_t)v18;
  if (!v18) {
    goto LABEL_21;
  }
  uint64_t v20 = *v18;
  unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v22 = *(unsigned int *)(v20 + 16);
  if (!v22) {
    goto LABEL_21;
  }
  uint64_t v23 = *(void **)(v20 + 8);
  uint64_t v24 = &v23[2 * v22];
  do
  {
    unint64_t v25 = v22 >> 1;
    uint64_t v26 = &v23[2 * (v22 >> 1)];
    unint64_t v28 = *v26;
    uint64_t v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21) {
      uint64_t v23 = v27;
    }
    else {
      unint64_t v22 = v25;
    }
  }
  while (v22);
  if (v23 != v24 && *v23 == v21) {
    uint64_t v29 = v23[1];
  }
  else {
LABEL_21:
  }
    uint64_t v29 = 0;
  uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE(v19, v29);
  uint64_t v32 = v31;
  v73[0] = RankPromotionTypeForANE;
  v73[1] = v31;
  if (!mlir::Type::isF16((mlir::Type *)&OperandRange))
  {
    uint64_t v48 = (uint64_t)a4[2];
    if (v48 && mlir::RewriterBase::Listener::classof(v48))
    {
      uint64_t v49 = *(void *)(a2 + 24);
      goto LABEL_35;
    }
    goto LABEL_36;
  }
  uint64_t v33 = mlir::getRankPromotionTypeForANE((uint64_t)v75, v76);
  uint64_t v82 = v84;
  uint64_t v83 = 0x400000000;
  if (mlir::getBroadcastIndices(v33, v34, RankPromotionTypeForANE, v32, (uint64_t)&v82))
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v73);
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(4, v35);
    if (v83)
    {
      unint64_t v37 = IndexFromDim;
      unint64_t v38 = v82;
      uint64_t v39 = 8 * v83;
      while (IndexFromDim != *v38)
      {
        ++v38;
        v39 -= 8;
        if (!v39)
        {
          uint64_t v72 = mlir::ValueRange::dereference_iterator(&v88, 0);
          uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v73);
          uint64_t v42 = v41;
          uint64_t v43 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v73);
          uint64_t v44 = (void *)mlir::RankedTensorType::get(ArgAttrsAttr, v42, v43, 0);
          SplatF16ElementsAttr = mlir::createSplatF16ElementsAttr(v44, 0.0);
          uint64_t v80 = v45;
          uint64_t v46 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), *(void *)(a2 + 24), v73, (void **)&SplatF16ElementsAttr);
          v77[0] = mlir::ValueRange::dereference_iterator(&v88, 0);
          v77[1] = (char *)v46 - 16;
          mlir::ValueRange::ValueRange((unint64_t *)v78, (uint64_t)v77, 2uLL);
          long long v47 = mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,mlir::ValueRange>((uint64_t *)a4 + 1, *(void *)(a2 + 24), (uint64_t *)v78);
          (*((void (**)(mlir::UnknownLoc **, uint64_t, mlir::GenericProgramPoint *))*a4 + 4))(a4, a2, v47);
          goto LABEL_54;
        }
      }
      uint64_t v72 = mlir::ValueRange::dereference_iterator(&v88, 0);
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v73);
      unint64_t v56 = v55;
      SplatF16ElementsAttr = v81;
      HIDWORD(v80) = 5;
      if (v55 < 6)
      {
        if (!v55)
        {
LABEL_52:
          LODWORD(v80) = v56;
          uint64_t v59 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v73);
          uint64_t v60 = SplatF16ElementsAttr;
          *((void *)SplatF16ElementsAttr + v37) = *(void *)(v59 + 8 * v37);
          uint64_t v61 = v80;
          uint64_t v62 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v73);
          uint64_t v63 = (void *)mlir::RankedTensorType::get((uint64_t)v60, v61, v62, 0);
          v78[0] = mlir::createSplatF16ElementsAttr(v63, 1.0);
          v78[1] = v64;
          uint64_t v65 = *(void *)(a2 + 24);
          uint64_t v66 = SplatF16ElementsAttr;
          uint64_t v67 = (mlir::AffineMap *)v80;
          uint64_t v68 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v73);
          uint64_t v71 = mlir::MemRefType::get(v66, v67, v68, 0, 0, 0);
          v77[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), v65, &v71, v78);
          uint64_t v71 = 0;
          unsigned int v69 = mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::mps::ConstantOp &,decltype(nullptr)>(a4 + 1, *(void *)(a2 + 24), &v72, v77);
          (*((void (**)(mlir::UnknownLoc **, uint64_t, mlir::GenericProgramPoint *))*a4 + 4))(a4, a2, v69);
          if (SplatF16ElementsAttr != v81) {
            free(SplatF16ElementsAttr);
          }
LABEL_54:
          uint64_t v51 = 1;
          goto LABEL_55;
        }
        size_t v58 = 8 * v55;
        uint64_t v57 = v81;
      }
      else
      {
        LODWORD(v80) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&SplatF16ElementsAttr, v81, v55, 8);
        uint64_t v57 = SplatF16ElementsAttr;
        size_t v58 = 8 * v56;
      }
      memset_pattern16(v57, &unk_1810FE350, v58);
      goto LABEL_52;
    }
    uint64_t v52 = (uint64_t)a4[2];
    if (v52 && mlir::RewriterBase::Listener::classof(v52))
    {
      uint64_t v53 = *(void *)(a2 + 24);
      goto LABEL_44;
    }
  }
  else
  {
    uint64_t v52 = (uint64_t)a4[2];
    if (v52 && mlir::RewriterBase::Listener::classof(v52))
    {
      uint64_t v53 = *(void *)(a2 + 24);
LABEL_44:
      uint64_t v51 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v52 + 64))(v52, v53, v54, &SplatF16ElementsAttr);
      goto LABEL_55;
    }
  }
  uint64_t v51 = 0;
LABEL_55:
  if (v82 != v84) {
    free(v82);
  }
LABEL_57:
  if (v85 != v87) {
    free(v85);
  }
  return v51;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Operand 1 should be constant. \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Only fp16 is supported for A11/A12 Broadcasts. \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unable to determine A11/A12 Broadcast. \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported A11/A12 Broadcast. \n");
}

void *mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)2>::~ConvertBroadcast(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)2>::~ConvertBroadcast(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  long long v42 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v42, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  char v10 = *(void **)(v7 + 8);
  unsigned int v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    __int16 v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      char v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v38[0] = v6;
  v38[1] = v16;
  uint64_t v39 = v41;
  uint64_t v40 = 0x500000000;
  uint64_t v17 = mlir::ValueRange::dereference_iterator(&v42, 1);
  if (mlir::matchConstantWithIntVector<long long>(v17, (uint64_t)&v39))
  {
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v38);
    uint64_t v19 = (uint64_t *)mlir::MemRefType::get(v39, (mlir::AffineMap *)v40, OperandRange, 0, 0, 0);
    uint64_t v20 = (uint64_t)v19;
    if (!v19) {
      goto LABEL_21;
    }
    uint64_t v21 = *v19;
    unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v23 = *(unsigned int *)(v21 + 16);
    if (!v23) {
      goto LABEL_21;
    }
    uint64_t v24 = *(void **)(v21 + 8);
    unint64_t v25 = &v24[2 * v23];
    do
    {
      unint64_t v26 = v23 >> 1;
      uint64_t v27 = &v24[2 * (v23 >> 1)];
      unint64_t v29 = *v27;
      unint64_t v28 = v27 + 2;
      v23 += ~(v23 >> 1);
      if (v29 < v22) {
        uint64_t v24 = v28;
      }
      else {
        unint64_t v23 = v26;
      }
    }
    while (v23);
    if (v24 != v25 && *v24 == v22) {
      uint64_t v30 = v24[1];
    }
    else {
LABEL_21:
    }
      uint64_t v30 = 0;
    v37[0] = mlir::getRankPromotionTypeForANE(v20, v30);
    v37[1] = v31;
    uint64_t v36 = mlir::ValueRange::dereference_iterator(&v42, 0);
    uint64_t v32 = mlir::OpBuilder::create<mlir::anec::Broadcast,mlir::MemRefType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 1), *(void *)(a2 + 24), v37, &v36);
    (*(void (**)(void *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v32);
    uint64_t v33 = 1;
  }
  else
  {
    uint64_t v34 = a4[2];
    if (v34 && mlir::RewriterBase::Listener::classof(v34)) {
    else
    }
      uint64_t v33 = 0;
  }
  if (v39 != v41) {
    free(v39);
  }
  return v33;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Operand 1 should be constant. \n");
}

void *mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)3>::~ConvertBroadcast(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)3>::~ConvertBroadcast(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  long long v42 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v42, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  char v10 = *(void **)(v7 + 8);
  unsigned int v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    __int16 v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      char v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v38[0] = v6;
  v38[1] = v16;
  uint64_t v39 = v41;
  uint64_t v40 = 0x500000000;
  uint64_t v17 = mlir::ValueRange::dereference_iterator(&v42, 1);
  if (mlir::matchConstantWithIntVector<long long>(v17, (uint64_t)&v39))
  {
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v38);
    uint64_t v19 = (uint64_t *)mlir::MemRefType::get(v39, (mlir::AffineMap *)v40, OperandRange, 0, 0, 0);
    uint64_t v20 = (uint64_t)v19;
    if (!v19) {
      goto LABEL_21;
    }
    uint64_t v21 = *v19;
    unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v23 = *(unsigned int *)(v21 + 16);
    if (!v23) {
      goto LABEL_21;
    }
    uint64_t v24 = *(void **)(v21 + 8);
    unint64_t v25 = &v24[2 * v23];
    do
    {
      unint64_t v26 = v23 >> 1;
      uint64_t v27 = &v24[2 * (v23 >> 1)];
      unint64_t v29 = *v27;
      unint64_t v28 = v27 + 2;
      v23 += ~(v23 >> 1);
      if (v29 < v22) {
        uint64_t v24 = v28;
      }
      else {
        unint64_t v23 = v26;
      }
    }
    while (v23);
    if (v24 != v25 && *v24 == v22) {
      uint64_t v30 = v24[1];
    }
    else {
LABEL_21:
    }
      uint64_t v30 = 0;
    v37[0] = mlir::getRankPromotionTypeForANE(v20, v30);
    v37[1] = v31;
    uint64_t v36 = mlir::ValueRange::dereference_iterator(&v42, 0);
    uint64_t v32 = mlir::OpBuilder::create<mlir::anec::Broadcast,mlir::MemRefType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 1), *(void *)(a2 + 24), v37, &v36);
    (*(void (**)(void *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v32);
    uint64_t v33 = 1;
  }
  else
  {
    uint64_t v34 = a4[2];
    if (v34 && mlir::RewriterBase::Listener::classof(v34)) {
    else
    }
      uint64_t v33 = 0;
  }
  if (v39 != v41) {
    free(v39);
  }
  return v33;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Operand 1 should be constant. \n");
}

void *mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)4>::~ConvertBroadcast(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)4>::~ConvertBroadcast(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  long long v42 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v42, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  char v10 = *(void **)(v7 + 8);
  unsigned int v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    __int16 v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      char v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v38[0] = v6;
  v38[1] = v16;
  uint64_t v39 = v41;
  uint64_t v40 = 0x500000000;
  uint64_t v17 = mlir::ValueRange::dereference_iterator(&v42, 1);
  if (mlir::matchConstantWithIntVector<long long>(v17, (uint64_t)&v39))
  {
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v38);
    uint64_t v19 = (uint64_t *)mlir::MemRefType::get(v39, (mlir::AffineMap *)v40, OperandRange, 0, 0, 0);
    uint64_t v20 = (uint64_t)v19;
    if (!v19) {
      goto LABEL_21;
    }
    uint64_t v21 = *v19;
    unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v23 = *(unsigned int *)(v21 + 16);
    if (!v23) {
      goto LABEL_21;
    }
    uint64_t v24 = *(void **)(v21 + 8);
    unint64_t v25 = &v24[2 * v23];
    do
    {
      unint64_t v26 = v23 >> 1;
      uint64_t v27 = &v24[2 * (v23 >> 1)];
      unint64_t v29 = *v27;
      unint64_t v28 = v27 + 2;
      v23 += ~(v23 >> 1);
      if (v29 < v22) {
        uint64_t v24 = v28;
      }
      else {
        unint64_t v23 = v26;
      }
    }
    while (v23);
    if (v24 != v25 && *v24 == v22) {
      uint64_t v30 = v24[1];
    }
    else {
LABEL_21:
    }
      uint64_t v30 = 0;
    v37[0] = mlir::getRankPromotionTypeForANE(v20, v30);
    v37[1] = v31;
    uint64_t v36 = mlir::ValueRange::dereference_iterator(&v42, 0);
    uint64_t v32 = mlir::OpBuilder::create<mlir::anec::Broadcast,mlir::MemRefType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 1), *(void *)(a2 + 24), v37, &v36);
    (*(void (**)(void *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v32);
    uint64_t v33 = 1;
  }
  else
  {
    uint64_t v34 = a4[2];
    if (v34 && mlir::RewriterBase::Listener::classof(v34)) {
    else
    }
      uint64_t v33 = 0;
  }
  if (v39 != v41) {
    free(v39);
  }
  return v33;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Operand 1 should be constant. \n");
}

void *mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)5>::~ConvertBroadcast(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)5>::~ConvertBroadcast(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  long long v42 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v42, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  char v10 = *(void **)(v7 + 8);
  unsigned int v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    __int16 v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      char v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v38[0] = v6;
  v38[1] = v16;
  uint64_t v39 = v41;
  uint64_t v40 = 0x500000000;
  uint64_t v17 = mlir::ValueRange::dereference_iterator(&v42, 1);
  if (mlir::matchConstantWithIntVector<long long>(v17, (uint64_t)&v39))
  {
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v38);
    uint64_t v19 = (uint64_t *)mlir::MemRefType::get(v39, (mlir::AffineMap *)v40, OperandRange, 0, 0, 0);
    uint64_t v20 = (uint64_t)v19;
    if (!v19) {
      goto LABEL_21;
    }
    uint64_t v21 = *v19;
    unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v23 = *(unsigned int *)(v21 + 16);
    if (!v23) {
      goto LABEL_21;
    }
    uint64_t v24 = *(void **)(v21 + 8);
    unint64_t v25 = &v24[2 * v23];
    do
    {
      unint64_t v26 = v23 >> 1;
      uint64_t v27 = &v24[2 * (v23 >> 1)];
      unint64_t v29 = *v27;
      unint64_t v28 = v27 + 2;
      v23 += ~(v23 >> 1);
      if (v29 < v22) {
        uint64_t v24 = v28;
      }
      else {
        unint64_t v23 = v26;
      }
    }
    while (v23);
    if (v24 != v25 && *v24 == v22) {
      uint64_t v30 = v24[1];
    }
    else {
LABEL_21:
    }
      uint64_t v30 = 0;
    v37[0] = mlir::getRankPromotionTypeForANE(v20, v30);
    v37[1] = v31;
    uint64_t v36 = mlir::ValueRange::dereference_iterator(&v42, 0);
    uint64_t v32 = mlir::OpBuilder::create<mlir::anec::Broadcast,mlir::MemRefType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 1), *(void *)(a2 + 24), v37, &v36);
    (*(void (**)(void *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v32);
    uint64_t v33 = 1;
  }
  else
  {
    uint64_t v34 = a4[2];
    if (v34 && mlir::RewriterBase::Listener::classof(v34)) {
    else
    }
      uint64_t v33 = 0;
  }
  if (v39 != v41) {
    free(v39);
  }
  return v33;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Operand 1 should be constant. \n");
}

void *mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)6>::~ConvertBroadcast(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)6>::~ConvertBroadcast(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  long long v42 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v42, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  char v10 = *(void **)(v7 + 8);
  unsigned int v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    __int16 v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      char v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v38[0] = v6;
  v38[1] = v16;
  uint64_t v39 = v41;
  uint64_t v40 = 0x500000000;
  uint64_t v17 = mlir::ValueRange::dereference_iterator(&v42, 1);
  if (mlir::matchConstantWithIntVector<long long>(v17, (uint64_t)&v39))
  {
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v38);
    uint64_t v19 = (uint64_t *)mlir::MemRefType::get(v39, (mlir::AffineMap *)v40, OperandRange, 0, 0, 0);
    uint64_t v20 = (uint64_t)v19;
    if (!v19) {
      goto LABEL_21;
    }
    uint64_t v21 = *v19;
    unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v23 = *(unsigned int *)(v21 + 16);
    if (!v23) {
      goto LABEL_21;
    }
    uint64_t v24 = *(void **)(v21 + 8);
    unint64_t v25 = &v24[2 * v23];
    do
    {
      unint64_t v26 = v23 >> 1;
      uint64_t v27 = &v24[2 * (v23 >> 1)];
      unint64_t v29 = *v27;
      unint64_t v28 = v27 + 2;
      v23 += ~(v23 >> 1);
      if (v29 < v22) {
        uint64_t v24 = v28;
      }
      else {
        unint64_t v23 = v26;
      }
    }
    while (v23);
    if (v24 != v25 && *v24 == v22) {
      uint64_t v30 = v24[1];
    }
    else {
LABEL_21:
    }
      uint64_t v30 = 0;
    v37[0] = mlir::getRankPromotionTypeForANE(v20, v30);
    v37[1] = v31;
    uint64_t v36 = mlir::ValueRange::dereference_iterator(&v42, 0);
    uint64_t v32 = mlir::OpBuilder::create<mlir::anec::Broadcast,mlir::MemRefType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 1), *(void *)(a2 + 24), v37, &v36);
    (*(void (**)(void *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v32);
    uint64_t v33 = 1;
  }
  else
  {
    uint64_t v34 = a4[2];
    if (v34 && mlir::RewriterBase::Listener::classof(v34)) {
    else
    }
      uint64_t v33 = 0;
  }
  if (v39 != v41) {
    free(v39);
  }
  return v33;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Operand 1 should be constant. \n");
}

void *mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)0>::~ConvertPadding(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)0>::~ConvertPadding(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PadOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::PadOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::PadOpGenericAdaptorBase::PadOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PadOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::PadOpGenericAdaptorBase::PadOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::PadOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 48);
  uint64_t v9 = *(void *)(a3 + 56);
  unint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        unint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v33 = 259;
      v30[0] = v32;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PadOp &>(mlir::mps::PadOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v34[0] = *(_OWORD *)a3;
        v34[1] = v28;
        long long v29 = *(_OWORD *)(a3 + 48);
        uint64_t v34[2] = *(_OWORD *)(a3 + 32);
        v34[3] = v29;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  uint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PadOp &>(mlir::mps::PadOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  long long v14 = *(_OWORD *)(a3 + 48);
  uint64_t v3 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3) {
    goto LABEL_10;
  }
  uint64_t v4 = *v3;
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *(unsigned int *)(v4 + 16);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *(void **)(v4 + 8);
  unint64_t v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    uint64_t v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    unsigned int v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      uint64_t v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_10:
  }
    uint64_t v13 = 0;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PadOp &>(mlir::mps::PadOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)0>::createPadding(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, unsigned int *a5, uint64_t *a6, uint64_t a7)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  size_t v58 = v60;
  memset(v60, 0, sizeof(v60));
  uint64_t v59 = 0xA0000000ALL;
  unint64_t v55 = v57;
  memset_pattern16(v57, &unk_181110BB0, 0x28uLL);
  uint64_t v56 = 0x500000005;
  uint64_t v12 = a5[2];
  if (v12)
  {
    uint64_t v13 = 0;
    uint64_t v14 = 16 * v12;
    uint64_t v15 = (void *)(*(void *)a5 + 8);
    do
    {
      ReferenceFormatuint64_t Index = mlir::anec::getReferenceFormatIndex(v13, a5[2], 5uLL);
      if (!v18) {
        std::__throw_bad_optional_access[abi:nn180100]();
      }
      uint64_t v19 = *(v15 - 1);
      if (v19 || *v15)
      {
        uint64_t v16 = (char *)v58 + 16 * ReferenceFormatIndex;
        *uint64_t v16 = v19;
        v16[1] = *v15;
        *((void *)v55 + ReferenceFormatIndex) = a4;
      }
      uint64_t v13 = (mlir::anec *)((char *)v13 + 1);
      v15 += 2;
      v14 -= 16;
    }
    while (v14);
  }
  long long v54 = xmmword_1810FE2F0;
  uint64_t v20 = (mlir::Builder *)(a7 + 8);
  uint64_t IntegerType = mlir::Builder::getIntegerType(v20, 0x40u, 0);
  unint64_t v22 = (void *)mlir::RankedTensorType::get((uint64_t)&v54, 2, IntegerType, 0);
  uint64_t v23 = v22;
  if (v22 && (uint64_t v24 = *v22, v25 = mlir::TypeID::get<mlir::ShapedType>(), v26 = *(unsigned int *)(v24 + 16), v26))
  {
    uint64_t v27 = *(void **)(v24 + 8);
    long long v28 = &v27[2 * v26];
    do
    {
      unint64_t v29 = v26 >> 1;
      uint64_t v30 = &v27[2 * (v26 >> 1)];
      unint64_t v32 = *v30;
      uint64_t v31 = v30 + 2;
      v26 += ~(v26 >> 1);
      if (v32 < v25) {
        uint64_t v27 = v31;
      }
      else {
        unint64_t v26 = v29;
      }
    }
    while (v26);
    __int16 v33 = a6;
    uint64_t v34 = a1;
    if (v27 != v28 && *v27 == v25) {
      uint64_t v35 = v27[1];
    }
    else {
      uint64_t v35 = 0;
    }
  }
  else
  {
    uint64_t v35 = 0;
    __int16 v33 = a6;
    uint64_t v34 = a1;
  }
  uint64_t v52 = mlir::DenseElementsAttr::getFromRawBuffer(v23, v35, v58, 8 * v59, 8, 1, 0);
  uint64_t v53 = 5;
  uint64_t v36 = mlir::Builder::getIntegerType(v20, 0x40u, 0);
  uint64_t v37 = (void *)mlir::RankedTensorType::get((uint64_t)&v53, 1, v36, 0);
  unint64_t v38 = v37;
  if (!v37) {
    goto LABEL_29;
  }
  uint64_t v39 = *v37;
  unint64_t v40 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v41 = *(unsigned int *)(v39 + 16);
  if (!v41) {
    goto LABEL_29;
  }
  long long v42 = *(void **)(v39 + 8);
  uint64_t v43 = &v42[2 * v41];
  do
  {
    unint64_t v44 = v41 >> 1;
    uint64_t v45 = &v42[2 * (v41 >> 1)];
    unint64_t v47 = *v45;
    uint64_t v46 = v45 + 2;
    v41 += ~(v41 >> 1);
    if (v47 < v40) {
      long long v42 = v46;
    }
    else {
      unint64_t v41 = v44;
    }
  }
  while (v41);
  if (v42 != v43 && *v42 == v40) {
    uint64_t v48 = v42[1];
  }
  else {
LABEL_29:
  }
    uint64_t v48 = 0;
  *(void *)&long long v54 = mlir::DenseElementsAttr::getFromRawBuffer(v38, v48, v55, 8 * v56, 8, 1, 0);
  uint64_t v49 = mlir::OpBuilder::create<mlir::anec::Padding,mlir::Value const&,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::FloatAttr &>((mlir::UnknownLoc **)v20, v34, a2, (uint64_t *)&v54, &v52, v33);
  if (v55 != v57) {
    free(v55);
  }
  if (v58 != v60) {
    free(v58);
  }
  return v49;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant 'constant_values' attribute");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a 16-bit integer or floating-point attribute ");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a single-element integer or floating-point attribute ");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(mlir::Operation ***a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant padding mode attribute");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

void mlir::getListOfPairs<unsigned long long>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v13[8] = *MEMORY[0x1E4F143B8];
  unsigned int v11 = v13;
  uint64_t v12 = 0x800000000;
  mlir::getIntValues<unsigned long long>(a1, a2, (uint64_t)&v11, 1);
  uint64_t v4 = (char *)v11;
  uint64_t v5 = v12;
  if (v12)
  {
    unsigned int v6 = *(_DWORD *)(a3 + 8);
    uint64_t v7 = (char *)v11;
    do
    {
      long long v8 = *(_OWORD *)v7;
      v7 += 16;
      long long v9 = v8;
      if (v6 >= *(_DWORD *)(a3 + 12))
      {
        long long v10 = v9;
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v6 + 1, 16);
        *(_OWORD *)(*(void *)a3 + 16 * *(unsigned int *)(a3 + 8)) = v10;
        unsigned int v6 = *(_DWORD *)(a3 + 8);
        uint64_t v4 = (char *)v11;
        uint64_t v5 = v12;
      }
      else
      {
        *(_OWORD *)(*(void *)a3 + 16 * v6) = v9;
      }
      *(_DWORD *)(a3 + 8) = ++v6;
    }
    while (v7 != &v4[8 * v5]);
  }
  if (v4 != (char *)v13) {
    free(v4);
  }
}

char *llvm::SmallVectorImpl<std::pair<unsigned long long,unsigned long long>>::insert<std::pair<unsigned long long,unsigned long long>*,void>(uint64_t a1, uint64_t a2, char *__src, char *a4)
{
  uint64_t v5 = __src;
  uint64_t v7 = *(void *)a1;
  uint64_t v8 = (a2 - *(void *)a1) >> 4;
  uint64_t v10 = *(unsigned int *)(a1 + 8);
  unint64_t v9 = *(unsigned int *)(a1 + 12);
  unsigned int v11 = *(_DWORD *)(a1 + 8);
  size_t v12 = a4 - __src;
  unint64_t v13 = (a4 - __src) >> 4;
  unint64_t v14 = v13 + v10;
  if (*(void *)a1 + 16 * v10 == a2)
  {
    if (v14 > v9)
    {
      uint64_t v23 = v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v14, 16);
      uint64_t v5 = v23;
      unsigned int v11 = *(_DWORD *)(a1 + 8);
      uint64_t v7 = *(void *)a1;
    }
    if (v5 != a4)
    {
      memcpy((void *)(v7 + 16 * v11), v5, v12);
      unsigned int v11 = *(_DWORD *)(a1 + 8);
      uint64_t v7 = *(void *)a1;
    }
    *(_DWORD *)(a1 + 8) = v11 + (v12 >> 4);
    return (char *)(v7 + 16 * v8);
  }
  else
  {
    uint64_t v100 = a2 - *(void *)a1;
    if (v14 > v9)
    {
      uint64_t v15 = v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v14, 16);
      uint64_t v5 = v15;
      uint64_t v7 = *(void *)a1;
      uint64_t v10 = *(unsigned int *)(a1 + 8);
      unsigned int v11 = *(_DWORD *)(a1 + 8);
    }
    uint64_t v16 = (char *)(v7 + 16 * v8);
    unint64_t v17 = v7 + 16 * v10;
    unint64_t v18 = v17 - (void)v16;
    uint64_t v19 = v8;
    unint64_t v20 = (uint64_t)(v17 - (void)v16) >> 4;
    if (v20 < v13)
    {
      unsigned int v21 = v11 + (v12 >> 4);
      *(_DWORD *)(a1 + 8) = v21;
      if (v19 == v10)
      {
        unint64_t v22 = (long long *)v5;
        goto LABEL_103;
      }
      uint64_t v79 = v19;
      uint64_t v80 = v5;
      memcpy((void *)(v7 + 16 * v21 - 16 * v20), v16, v17 - (void)v16);
      if (v18 >= 0xE0)
      {
        uint64_t v84 = v7 + (v100 & 0xFFFFFFFFFFFFFFF0);
        unint64_t v85 = v84 + v18 - 8;
        BOOL v87 = v84 + 8 < (unint64_t)&v80[v18] && (unint64_t)(v80 + 8) < v84 + v18;
        BOOL v88 = v85 <= (unint64_t)v80 || v16 >= &v80[v18 - 8];
        if (!v88 || v87)
        {
          int v81 = v16;
          uint64_t v82 = (uint64_t)(v17 - (void)v16) >> 4;
          unint64_t v22 = (long long *)v80;
        }
        else
        {
          unint64_t v89 = 16 * (v20 & 0xFFFFFFFFFFFFFFFCLL);
          int v81 = &v16[v89];
          uint64_t v82 = (v18 >> 4) & 3;
          unint64_t v22 = (long long *)&v80[v89];
          unint64_t v90 = (long long *)(v80 + 32);
          unint64_t v91 = (_OWORD *)(v7 + 16 * v79 + 32);
          unint64_t v92 = v20 & 0xFFFFFFFFFFFFFFFCLL;
          do
          {
            long long v94 = *(v90 - 2);
            long long v93 = *(v90 - 1);
            long long v96 = *v90;
            long long v95 = v90[1];
            v90 += 4;
            *(v91 - 2) = v94;
            *(v91 - 1) = v93;
            *unint64_t v91 = v96;
            v91[1] = v95;
            v91 += 4;
            v92 -= 4;
          }
          while (v92);
          if (v20 == (v20 & 0xFFFFFFFFFFFFFFFCLL))
          {
LABEL_103:
            if (v22 != (long long *)a4) {
              memcpy((void *)(v7 + 16 * v10), v22, a4 - (char *)v22);
            }
            return v16;
          }
        }
      }
      else
      {
        int v81 = v16;
        uint64_t v82 = (uint64_t)(v17 - (void)v16) >> 4;
        unint64_t v22 = (long long *)v80;
      }
      do
      {
        long long v97 = *v22++;
        *(_OWORD *)int v81 = v97;
        v81 += 16;
        --v82;
      }
      while (v82);
      goto LABEL_103;
    }
    uint64_t v99 = v19;
    uint64_t v24 = v10;
    if (v13 + v10 > *(unsigned int *)(a1 + 12))
    {
      unint64_t v25 = v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v13 + v10, 16);
      uint64_t v5 = v25;
      uint64_t v24 = *(unsigned int *)(a1 + 8);
      unsigned int v11 = *(_DWORD *)(a1 + 8);
    }
    unint64_t v26 = (void *)(v17 - 16 * v13);
    if (a4 != v5)
    {
      uint64_t v27 = (_OWORD *)(*(void *)a1 + 16 * v24);
      uint64_t v28 = -16 * v13;
      do
      {
        *v27++ = *(_OWORD *)(v17 + v28);
        v28 += 16;
      }
      while (v28);
      unsigned int v11 = *(_DWORD *)(a1 + 8);
    }
    *(_DWORD *)(a1 + 8) = v11 + v13;
    if (v26 != (void *)v16)
    {
      uint64_t v29 = 16 * v10;
      unint64_t v30 = 16 * v10 - 16 * (v13 + v99) - 16;
      if (v30 < 0x550) {
        goto LABEL_60;
      }
      uint64_t v31 = v29 - 16;
      uint64_t v32 = v29 - 16 - 16 * (v13 + v99);
      if (v7 - -16 * (v13 + v99) > v7 + v29 - 16) {
        goto LABEL_60;
      }
      uint64_t v33 = v29 - 8;
      if (v7 + v33 - v32 > (unint64_t)(v7 + v33)
        || v7 + v31 - (v12 & 0xFFFFFFFFFFFFFFF0) - v32 > v7 + v31 - (v12 & 0xFFFFFFFFFFFFFFF0)
        || v7 + v33 - (v12 & 0xFFFFFFFFFFFFFFF0) - v32 > v7 + v33 - (v12 & 0xFFFFFFFFFFFFFFF0))
      {
        goto LABEL_60;
      }
      uint64_t v34 = 16 * (v13 + v99);
      uint64_t v35 = v31 - v34;
      unint64_t v36 = v7 + v34;
      unint64_t v37 = v7 + v33;
      unint64_t v38 = v7 + v33 - (v31 - v34);
      size_t v39 = v7 + v34 - (v12 & 0xFFFFFFFFFFFFFFF0);
      size_t v40 = v33 - (v12 & 0xFFFFFFFFFFFFFFF0);
      unint64_t v41 = v7 + v40;
      size_t v42 = v7 + v40 - v35;
      BOOL v43 = v36 >= v7 + v40 || v39 >= v37;
      BOOL v44 = !v43;
      BOOL v45 = v36 >= (unint64_t)v26 || v42 >= v37;
      BOOL v46 = !v45;
      BOOL v47 = v38 >= v41 || v39 >= v17;
      BOOL v48 = !v47;
      BOOL v49 = v38 >= (unint64_t)v26 || v42 >= v17;
      BOOL v50 = !v49;
      if (v38 < v37 && v36 < v17) {
        goto LABEL_60;
      }
      if (v44) {
        goto LABEL_60;
      }
      if (v46) {
        goto LABEL_60;
      }
      if (v48) {
        goto LABEL_60;
      }
      if (v50) {
        goto LABEL_60;
      }
      uint64_t v52 = (v30 >> 4) + 1;
      uint64_t v53 = 16 * (v52 & 0x1FFFFFFFFFFFFFFCLL);
      unint64_t v54 = v17 - v53;
      unint64_t v26 = (void *)((char *)v26 - v53);
      unint64_t v55 = (double *)(v17 - 32);
      uint64_t v56 = v52 & 0x1FFFFFFFFFFFFFFCLL;
      do
      {
        uint64_t v57 = &v55[-2 * v13];
        float64x2x2_t v101 = vld2q_f64(v57);
        v57 -= 4;
        float64x2x2_t v102 = vld2q_f64(v57);
        size_t v58 = v55 - 4;
        vst2q_f64(v55, v101);
        vst2q_f64(v58, v102);
        v55 -= 8;
        v56 -= 4;
      }
      while (v56);
      unint64_t v17 = v54;
      if (v52 != (v52 & 0x1FFFFFFFFFFFFFFCLL))
      {
LABEL_60:
        uint64_t v59 = (void *)(v17 - 8);
        do
        {
          uint64_t v60 = *(v26 - 2);
          v26 -= 2;
          *(v59 - 1) = v60;
          void *v59 = v26[1];
          v59 -= 2;
        }
        while (v26 != (void *)v16);
      }
    }
    if (a4 != v5)
    {
      unint64_t v61 = a4 - v5 - 16;
      if (v61 < 0x150
        || ((unint64_t v62 = (v100 & 0xFFFFFFFFFFFFFFF0) + v7 + (v61 & 0xFFFFFFFFFFFFFFF0),
             unint64_t v63 = v62 + 8,
             unint64_t v64 = v62 + 16,
             v7 + (v100 & 0xFFFFFFFFFFFFFFF0) + 8 < (unint64_t)&v5[(v61 & 0xFFFFFFFFFFFFFFF0) + 16])
          ? (BOOL v65 = (unint64_t)(v5 + 8) >= v64)
          : (BOOL v65 = 1),
            v65 ? (char v66 = 0) : (char v66 = 1),
            v63 > (unint64_t)v5 ? (BOOL v67 = v16 >= &v5[(v61 & 0xFFFFFFFFFFFFFFF0) + 8]) : (BOOL v67 = 1),
            !v67 || (v66 & 1) != 0))
      {
        unint64_t v70 = v16;
        uint64_t v71 = v5;
      }
      else
      {
        uint64_t v68 = (v61 >> 4) + 1;
        uint64_t v69 = 16 * (v68 & 0x1FFFFFFFFFFFFFFCLL);
        unint64_t v70 = &v16[v69];
        uint64_t v71 = &v5[v69];
        uint64_t v72 = (long long *)(v5 + 32);
        uint64_t v73 = (_OWORD *)(v7 + 16 * v99 + 32);
        uint64_t v74 = v68 & 0x1FFFFFFFFFFFFFFCLL;
        do
        {
          long long v76 = *(v72 - 2);
          long long v75 = *(v72 - 1);
          long long v78 = *v72;
          long long v77 = v72[1];
          v72 += 4;
          *(v73 - 2) = v76;
          *(v73 - 1) = v75;
          _OWORD *v73 = v78;
          v73[1] = v77;
          v73 += 4;
          v74 -= 4;
        }
        while (v74);
        if (v68 == (v68 & 0x1FFFFFFFFFFFFFFCLL)) {
          return v16;
        }
      }
      do
      {
        long long v83 = *(_OWORD *)v71;
        v71 += 16;
        *(_OWORD *)unint64_t v70 = v83;
        v70 += 16;
      }
      while (v71 != a4);
    }
  }
  return v16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Padding,mlir::Value const&,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::FloatAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  v23[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.padding", (const unsigned __int8 *)0xC, Context);
  if (!v14)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.padding";
    void v21[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::anec::Padding::build(a1, (uint64_t)v23, *a3, *a4, *a5, *a6);
  uint64_t v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Padding,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void std::deque<std::pair<mlir::anec::Dim,std::pair<unsigned long long,unsigned long long>>>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0xAA;
  unint64_t v4 = v2 - 170;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    unsigned int v6 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    uint64_t v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_57:
      *(void *)uint64_t v5 = v8;
      *(void *)(a1 + 16) += 8;
      return;
    }
    unint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v30 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v30 = 1;
      }
      if (!(v30 >> 61))
      {
        unint64_t v31 = v30 >> 2;
        uint64_t v32 = 8 * v30;
        uint64_t v33 = (char *)operator new(8 * v30);
        uint64_t v34 = &v33[8 * v31];
        uint64_t v35 = &v33[v32];
        int64_t v37 = v5 - v7;
        BOOL v36 = v5 == v7;
        uint64_t v5 = v34;
        if (!v36)
        {
          uint64_t v5 = &v34[v37 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v38 = v37 - 8;
          if ((unint64_t)(v37 - 8) >= 0x38)
          {
            uint64_t v52 = &v33[8 * v31];
            size_t v39 = v52;
            if ((unint64_t)(v52 - v7) >= 0x20)
            {
              uint64_t v53 = (v38 >> 3) + 1;
              uint64_t v54 = 8 * (v53 & 0x3FFFFFFFFFFFFFFCLL);
              size_t v39 = &v34[v54];
              v7 += v54;
              unint64_t v55 = (long long *)(v6 + 3);
              uint64_t v56 = v52 + 16;
              uint64_t v57 = v53 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v58 = *v55;
                *(v56 - 1) = *(v55 - 1);
                *uint64_t v56 = v58;
                v55 += 2;
                v56 += 2;
                v57 -= 4;
              }
              while (v57);
              if (v53 == (v53 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_55;
              }
            }
          }
          else
          {
            size_t v39 = &v33[8 * v31];
          }
          do
          {
            uint64_t v59 = *(void *)v7;
            v7 += 8;
            *(void *)size_t v39 = v59;
            v39 += 8;
          }
          while (v39 != v5);
        }
        goto LABEL_55;
      }
LABEL_65:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    uint64_t v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      uint64_t v7 = *(char **)(a1 + 8);
    }
    uint64_t v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_57;
  }
  uint64_t v18 = *(char **)(a1 + 8);
  unint64_t v17 = *(char **)(a1 + 16);
  uint64_t v19 = v17 - v18;
  uint64_t v20 = (v17 - v18) >> 3;
  unsigned int v21 = *(char **)(a1 + 24);
  uint64_t v22 = (uint64_t)&v21[-*(void *)a1];
  if (v20 < (unint64_t)(v22 >> 3))
  {
    if (v21 != v17)
    {
      uint64_t v68 = (char *)operator new(0xFF0uLL);
      std::__split_buffer<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *,std::allocator<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *>>::push_back((char **)a1, &v68);
      return;
    }
    uint64_t v68 = (char *)operator new(0xFF0uLL);
    std::__split_buffer<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *,std::allocator<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *>>::push_front((void **)a1, &v68);
    size_t v40 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    uint64_t v7 = (char *)(v40 + 1);
    uint64_t v8 = *v40;
    *(void *)(a1 + 8) = v40 + 1;
    if (v5 != *(char **)(a1 + 24)) {
      goto LABEL_57;
    }
    unint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v41 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v41 = 1;
      }
      if (!(v41 >> 61))
      {
        unint64_t v42 = v41 >> 2;
        uint64_t v43 = 8 * v41;
        uint64_t v33 = (char *)operator new(8 * v41);
        uint64_t v34 = &v33[8 * v42];
        uint64_t v35 = &v33[v43];
        int64_t v44 = v5 - v7;
        BOOL v36 = v5 == v7;
        uint64_t v5 = v34;
        if (!v36)
        {
          uint64_t v5 = &v34[v44 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v45 = v44 - 8;
          if ((unint64_t)(v44 - 8) >= 0x38)
          {
            uint64_t v60 = &v33[8 * v42];
            BOOL v46 = v60;
            if ((unint64_t)(v60 - v7) >= 0x20)
            {
              uint64_t v61 = (v45 >> 3) + 1;
              uint64_t v62 = 8 * (v61 & 0x3FFFFFFFFFFFFFFCLL);
              BOOL v46 = &v34[v62];
              v7 += v62;
              unint64_t v63 = (long long *)(v40 + 3);
              unint64_t v64 = v60 + 16;
              uint64_t v65 = v61 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v66 = *v63;
                *(v64 - 1) = *(v63 - 1);
                *unint64_t v64 = v66;
                v63 += 2;
                v64 += 2;
                v65 -= 4;
              }
              while (v65);
              if (v61 == (v61 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_55;
              }
            }
          }
          else
          {
            BOOL v46 = &v33[8 * v42];
          }
          do
          {
            uint64_t v67 = *(void *)v7;
            v7 += 8;
            *(void *)BOOL v46 = v67;
            v46 += 8;
          }
          while (v46 != v5);
        }
LABEL_55:
        *(void *)a1 = v33;
        *(void *)(a1 + 8) = v34;
        *(void *)(a1 + 16) = v5;
        *(void *)(a1 + 24) = v35;
        if (v9)
        {
          operator delete(v9);
          uint64_t v5 = *(char **)(a1 + 16);
        }
        goto LABEL_57;
      }
      goto LABEL_65;
    }
    goto LABEL_5;
  }
  uint64_t v23 = v22 >> 2;
  if (v21 == *(char **)a1) {
    unint64_t v24 = 1;
  }
  else {
    unint64_t v24 = v23;
  }
  uint64_t v72 = a1 + 24;
  if (v24 >> 61) {
    goto LABEL_65;
  }
  unint64_t v25 = (char *)operator new(8 * v24);
  unint64_t v26 = &v25[8 * v20];
  uint64_t v68 = v25;
  uint64_t v69 = v26;
  uint64_t v27 = &v25[8 * v24];
  uint64_t v71 = v27;
  uint64_t v28 = operator new(0xFF0uLL);
  if (v20 == v24)
  {
    if (v19 < 1)
    {
      if (v17 == v18) {
        unint64_t v47 = 1;
      }
      else {
        unint64_t v47 = v19 >> 2;
      }
      if (v47 >> 61) {
        goto LABEL_65;
      }
      BOOL v48 = (char *)operator new(8 * v47);
      unint64_t v26 = &v48[8 * (v47 >> 2)];
      uint64_t v27 = &v48[8 * v47];
      uint64_t v68 = v48;
      uint64_t v69 = v26;
      uint64_t v71 = v27;
      operator delete(v25);
      uint64_t v18 = *(char **)(a1 + 8);
      unint64_t v17 = *(char **)(a1 + 16);
      unint64_t v25 = v48;
    }
    else
    {
      unint64_t v29 = v20 + 2;
      if (v20 >= -1) {
        unint64_t v29 = v20 + 1;
      }
      v26 -= 8 * (v29 >> 1);
      uint64_t v69 = v26;
    }
  }
  *(void *)unint64_t v26 = v28;
  BOOL v49 = v26 + 8;
  unint64_t v70 = v26 + 8;
  if (v17 == v18)
  {
    unint64_t v17 = v18;
  }
  else
  {
    do
    {
      v17 -= 8;
      std::__split_buffer<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *,std::allocator<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *>>::push_front((void **)&v68, v17);
    }
    while (v17 != *(char **)(a1 + 8));
    unint64_t v25 = v68;
    unint64_t v26 = v69;
    uint64_t v18 = *(char **)(a1 + 16);
    BOOL v49 = v70;
    uint64_t v27 = v71;
  }
  BOOL v50 = *(char **)a1;
  *(void *)a1 = v25;
  *(void *)(a1 + 8) = v26;
  uint64_t v68 = v50;
  uint64_t v69 = v17;
  uint64_t v51 = *(char **)(a1 + 24);
  *(void *)(a1 + 16) = v49;
  *(void *)(a1 + 24) = v27;
  unint64_t v70 = v18;
  uint64_t v71 = v51;
  if (v18 != v17) {
    unint64_t v70 = &v18[(v17 - v18 + 7) & 0xFFFFFFFFFFFFFFF8];
  }
  if (v50) {
    operator delete(v50);
  }
}

void *mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)1>::~ConvertPadding(void *a1)
{
  unint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)1>::~ConvertPadding(void *__p)
{
  unint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  BOOL v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  long long v14 = *(_OWORD *)(a3 + 48);
  BOOL v3 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3) {
    goto LABEL_10;
  }
  uint64_t v4 = *v3;
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *(unsigned int *)(v4 + 16);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *(void **)(v4 + 8);
  uint64_t v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    uint64_t v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    uint64_t v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      uint64_t v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_10:
  }
    uint64_t v13 = 0;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant 'constant_values' attribute");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a 16-bit integer or floating-point attribute ");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Operation ***a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a single-element integer or floating-point attribute ");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(mlir::Operation ***a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant padding mode attribute");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

void *mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)2>::~ConvertPadding(void *a1)
{
  unint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)2>::~ConvertPadding(void *__p)
{
  unint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  BOOL v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  long long v14 = *(_OWORD *)(a3 + 48);
  BOOL v3 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3) {
    goto LABEL_10;
  }
  uint64_t v4 = *v3;
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *(unsigned int *)(v4 + 16);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *(void **)(v4 + 8);
  uint64_t v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    uint64_t v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    uint64_t v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      uint64_t v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_10:
  }
    uint64_t v13 = 0;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant 'constant_values' attribute");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a 16-bit integer or floating-point attribute ");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Operation ***a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a single-element integer or floating-point attribute ");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(mlir::Operation ***a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant padding mode attribute");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

void *mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)3>::~ConvertPadding(void *a1)
{
  unint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)3>::~ConvertPadding(void *__p)
{
  unint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  BOOL v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  long long v14 = *(_OWORD *)(a3 + 48);
  BOOL v3 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3) {
    goto LABEL_10;
  }
  uint64_t v4 = *v3;
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *(unsigned int *)(v4 + 16);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *(void **)(v4 + 8);
  uint64_t v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    uint64_t v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    uint64_t v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      uint64_t v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_10:
  }
    uint64_t v13 = 0;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant 'constant_values' attribute");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a 16-bit integer or floating-point attribute ");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Operation ***a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a single-element integer or floating-point attribute ");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(mlir::Operation ***a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant padding mode attribute");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

void *mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)4>::~ConvertPadding(void *a1)
{
  unint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)4>::~ConvertPadding(void *__p)
{
  unint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  BOOL v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  long long v14 = *(_OWORD *)(a3 + 48);
  BOOL v3 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3) {
    goto LABEL_10;
  }
  uint64_t v4 = *v3;
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *(unsigned int *)(v4 + 16);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *(void **)(v4 + 8);
  uint64_t v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    uint64_t v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    uint64_t v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      uint64_t v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_10:
  }
    uint64_t v13 = 0;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant 'constant_values' attribute");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a 16-bit integer or floating-point attribute ");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Operation ***a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a single-element integer or floating-point attribute ");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(mlir::Operation ***a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant padding mode attribute");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

void *mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)5>::~ConvertPadding(void *a1)
{
  unint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)5>::~ConvertPadding(void *__p)
{
  unint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  BOOL v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  long long v14 = *(_OWORD *)(a3 + 48);
  BOOL v3 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3) {
    goto LABEL_10;
  }
  uint64_t v4 = *v3;
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *(unsigned int *)(v4 + 16);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *(void **)(v4 + 8);
  uint64_t v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    uint64_t v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    uint64_t v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      uint64_t v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_10:
  }
    uint64_t v13 = 0;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant 'constant_values' attribute");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a 16-bit integer or floating-point attribute ");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Operation ***a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a single-element integer or floating-point attribute ");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(mlir::Operation ***a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant padding mode attribute");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

void *mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)6>::~ConvertPadding(void *a1)
{
  unint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)6>::~ConvertPadding(void *__p)
{
  unint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  BOOL v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  long long v14 = *(_OWORD *)(a3 + 48);
  BOOL v3 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3) {
    goto LABEL_10;
  }
  uint64_t v4 = *v3;
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *(unsigned int *)(v4 + 16);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *(void **)(v4 + 8);
  uint64_t v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    uint64_t v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    uint64_t v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      uint64_t v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_10:
  }
    uint64_t v13 = 0;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant 'constant_values' attribute");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a 16-bit integer or floating-point attribute ");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Operation ***a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a single-element integer or floating-point attribute ");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(mlir::Operation ***a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant padding mode attribute");
  uint64_t v4 = mlir::Diagnostic::operator<<(v3, **a1);

  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

void *mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)0>::~ConvertSlice(void *a1)
{
  unint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)0>::~ConvertSlice(void *__p)
{
  unint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  BOOL v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SliceOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SliceOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SliceOpGenericAdaptorBase::SliceOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SliceOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SliceOpGenericAdaptorBase::SliceOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SliceOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v36 = v23;
        if (v35)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v32 = 259;
      v29[0] = v31;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 16);
        v33[0] = *(_OWORD *)a3;
        v33[1] = v28;
        void v33[2] = *(_OWORD *)(a3 + 32);
        uint64_t v34 = *(void *)(a3 + 48);
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  unint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::ConversionPatternRewriter *a4)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  BOOL v48 = a2;
  long long v56 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (void *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v48) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  BOOL v46 = v5;
  uint64_t v47 = v15;
  v54[0] = &v55;
  v54[1] = (void *)0x100000000;
  unint64_t v45 = 0;
  v44[0] = (unint64_t *)&v45;
  Filter = (const char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v48);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Filter);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::DenseIntElementsAttr>::match(v44, DefiningOp))
  {
    uint64_t v17 = v45;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v46);
    if (mlir::getPositivePromotedAxes(v17, v18, (uint64_t)v54, 0, 0))
    {
      v44[0] = (unint64_t *)mlir::getRankPromotionTypeForANE((uint64_t)v46, v47);
      v44[1] = v19;
      uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v48);
      Filter = 0;
      uint64_t v50 = 0;
      p_Filter = &Filter;
      uint64_t v53 = (const char **)Bias;
      uint64_t v21 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
      if (v21)
      {
        if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v21))
        {
          uint64_t SingleInt = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
          if ((SingleInt & 0xFF00000000) != 0)
          {
            uint64_t v23 = (int)SingleInt;
            uint64_t v24 = *(unsigned int *)v54[0];
            uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v44);
            Positiveuint64_t Axis = mlir::tryGetPositiveAxis(v23, *(void *)(ArgAttrsAttr + 8 * v24), 0, 0, 0);
            if (v27)
            {
              unint64_t v28 = PositiveAxis;
              uint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v48);
              Filter = 0;
              uint64_t v50 = 0;
              p_Filter = &Filter;
              uint64_t v53 = (const char **)SparseShape;
              uint64_t v30 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
              if (v30)
              {
                if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v30))
                {
                  uint64_t v31 = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
                  if ((v31 & 0xFF00000000) != 0)
                  {
                    int v32 = v31;
                    uint64_t v33 = *((void *)v48 + 3);
                    uint64_t v34 = mlir::ValueRange::dereference_iterator(&v56, 0);
                    uint64_t v35 = v32;
                    uint64_t v36 = 1;
                    mlir::ConversionPatternRewriter::replaceOp(a4, v48, v37);
                    goto LABEL_31;
                  }
                }
              }
              goto LABEL_30;
            }
            Filter = "failed: could not extract a positive value for start attribute";
            __int16 v51 = 259;
            unint64_t v41 = v48;
            uint64_t v53 = &Filter;
            uint64_t v42 = *((void *)a4 + 2);
            if (v42)
            {
              if (mlir::RewriterBase::Listener::classof(v42))
              {
                uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), const char ***))(*(void *)v42 + 64))(v42, *((void *)v41 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v53);
                goto LABEL_25;
              }
            }
          }
        }
      }
    }
    else
    {
      Filter = "failed: could not extract positive promoted axes";
      __int16 v51 = 259;
      unint64_t v38 = v48;
      v44[0] = (unint64_t *)&Filter;
      uint64_t v39 = *((void *)a4 + 2);
      if (v39 && mlir::RewriterBase::Listener::classof(v39))
      {
        uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), unint64_t **))(*(void *)v39 + 64))(v39, *((void *)v38 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v44);
LABEL_25:
        uint64_t v36 = v40;
        goto LABEL_31;
      }
    }
  }
LABEL_30:
  uint64_t v36 = 0;
LABEL_31:
  if (v54[0] != &v55) {
    free(v54[0]);
  }
  return v36;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::anonymous namespace'::makeInputViewOp<(mlir::anec::Family)0>(uint64_t a1, uint64_t a2, uint64_t a3, mlir::anec *a4, unint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v52 = a3;
  uint64_t v13 = (uint64_t *)(*(void *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v13) {
    goto LABEL_10;
  }
  uint64_t v14 = *v13;
  unint64_t v15 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v16 = *(unsigned int *)(v14 + 16);
  if (!v16) {
    goto LABEL_10;
  }
  uint64_t v17 = *(void **)(v14 + 8);
  unint64_t v18 = &v17[2 * v16];
  do
  {
    unint64_t v19 = v16 >> 1;
    uint64_t v20 = &v17[2 * (v16 >> 1)];
    unint64_t v22 = *v20;
    uint64_t v21 = v20 + 2;
    v16 += ~(v16 >> 1);
    if (v22 < v15) {
      uint64_t v17 = v21;
    }
    else {
      unint64_t v16 = v19;
    }
  }
  while (v16);
  if (v17 != v18 && *v17 == v15) {
    uint64_t v23 = v17[1];
  }
  else {
LABEL_10:
  }
    uint64_t v23 = 0;
  v51[0] = mlir::getRankPromotionTypeForANE((uint64_t)v13, v23);
  v51[1] = v24;
  uint64_t OperandRange = (mlir::GenericProgramPoint *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v51);
  unsigned int v25 = 12;
  if (!mlir::Type::isF16((mlir::Type *)&OperandRange))
  {
    uint64_t v49 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v51);
    if (mlir::Type::isF32((mlir::Type *)&v49)) {
      unsigned int v25 = 12;
    }
    else {
      unsigned int v25 = 28;
    }
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v51);
  DimFromuint64_t Index = mlir::anec::getDimFromIndex(a4, v26);
  if ((DimFromIndex & 0xFF00000000) != 0)
  {
    if (DimFromIndex != 4 || v25 >= a5)
    {
      unint64_t v41 = (mlir::Builder *)(a1 + 8);
      uint64_t v49 = a5;
      uint64_t OperandRange = a4;
      uint64_t v47 = a7;
      uint64_t v48 = a6;
      return mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value &,unsigned long long,unsigned long long,unsigned long long,unsigned long long>(v41, a2, &v52, (uint64_t *)&OperandRange, &v49, &v48, &v47);
    }
    uint64_t v45 = a6;
    uint64_t v46 = a7;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v51);
    unsigned int IndexFromDim = mlir::anec::getIndexFromDim(4, v28);
    if (v30)
    {
      unsigned int v31 = IndexFromDim;
      uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v51);
      unint64_t v33 = a5 / v25;
      unint64_t v34 = a5 % v25;
      uint64_t v36 = v33 > 1 && v34 == 0;
      uint64_t v37 = v33 - v36;
      if (v33 != v36)
      {
        uint64_t v38 = *(void *)(ArgAttrsAttr + 8 * v31);
        unsigned int v39 = v25;
        do
        {
          uint64_t v48 = v25;
          uint64_t v49 = (uint64_t)a4;
          uint64_t v47 = v38 - v39;
          uint64_t OperandRange = mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value,long long const&,unsigned long long &,long long &>((mlir::Builder *)(a1 + 8), a2, &v52, &v49, &v48, &v47);
          uint64_t v52 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&OperandRange);
          v39 += v25;
          --v37;
        }
        while (v37);
      }
      if (v34) {
        uint64_t v40 = v34;
      }
      else {
        uint64_t v40 = v25;
      }
      unint64_t v41 = (mlir::Builder *)(a1 + 8);
      uint64_t v49 = v40;
      uint64_t OperandRange = a4;
      uint64_t v47 = v46;
      uint64_t v48 = v45;
      return mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value &,unsigned long long,unsigned long long,unsigned long long,unsigned long long>(v41, a2, &v52, (uint64_t *)&OperandRange, &v49, &v48, &v47);
    }
  }
  uint64_t v43 = std::__throw_bad_optional_access[abi:nn180100]();
  return (mlir::GenericProgramPoint *)mlir::getSingleIntValue<int>(v43, v44);
}

uint64_t mlir::getSingleIntValue<int>(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = a1;
  uint64_t v13 = a2;
  v11[0] = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v12);
  v11[1] = v2;
  uint64_t ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v11);
  if (mlir::ShapedType::getNumElements(ArgAttrsAttr, v4) == 1
    && (v10[0] = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v12),
        v10[1] = v5,
        *(_UNKNOWN **)(*(void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v10)
                     + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id))
  {
    LODWORD(v10[0]) = 0;
    mlir::copyElementsAttrData<int>(v12, v13, (uint64_t)v10, 1);
    unsigned int v8 = v10[0] & 0xFFFFFF00;
    int v6 = LOBYTE(v10[0]);
    uint64_t v7 = 0x100000000;
  }
  else
  {
    int v6 = 0;
    uint64_t v7 = 0;
    unsigned int v8 = 0;
  }
  return v7 | v8 | v6;
}

float mlir::copyElementsAttrData<int>(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  v98[5] = *MEMORY[0x1E4F143B8];
  uint64_t v95 = a1;
  uint64_t v96 = a2;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v95);
  uint64_t v7 = Type;
  if (!Type) {
    goto LABEL_10;
  }
  uint64_t v8 = *Type;
  unint64_t v9 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v10 = *(unsigned int *)(v8 + 16);
  if (!v10) {
    goto LABEL_10;
  }
  unint64_t v11 = *(void **)(v8 + 8);
  uint64_t v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    uint64_t v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    unint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      unint64_t v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_10:
  }
    uint64_t v17 = 0;
  v94[0] = v7;
  v94[1] = v17;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v94);
  int v18 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v95);
  ElementsAttrRawData = (unsigned __int8 *)mlir::getElementsAttrRawData(v95);
  uint64_t v21 = v20;
  if (!v18 || a4)
  {
    int64_t NumElements = mlir::ElementsAttr::getNumElements(v95, v96);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
    {
      if (NumElements < 1) {
        return *(float *)&v22;
      }
      goto LABEL_17;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 8))
    {
      if (NumElements < 1) {
        return *(float *)&v22;
      }
      goto LABEL_28;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16))
    {
      if (NumElements < 1) {
        return *(float *)&v22;
      }
      if ((unint64_t)NumElements >= 2)
      {
        uint64_t v29 = 0;
        unint64_t v28 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v18) {
            uint64_t v30 = 0;
          }
          else {
            uint64_t v30 = v29;
          }
          if (v18) {
            uint64_t v31 = 0;
          }
          else {
            uint64_t v31 = v29 + 1;
          }
          int v32 = *(unsigned __int16 *)&ElementsAttrRawData[2 * v31];
          unint64_t v33 = (_DWORD *)(a3 + 4 * v29);
          *unint64_t v33 = *(unsigned __int16 *)&ElementsAttrRawData[2 * v30];
          v33[1] = v32;
          v29 += 2;
        }
        while (v29 != v28);
        goto LABEL_200;
      }
      goto LABEL_37;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 16))
    {
      if (NumElements < 1) {
        return *(float *)&v22;
      }
      goto LABEL_55;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32))
    {
      if (NumElements < 1) {
        return *(float *)&v22;
      }
      goto LABEL_62;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 32))
    {
      if (NumElements < 1) {
        return *(float *)&v22;
      }
      goto LABEL_82;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
    {
      if (NumElements < 1) {
        return *(float *)&v22;
      }
      goto LABEL_93;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 64))
    {
      if (NumElements < 1) {
        return *(float *)&v22;
      }
      goto LABEL_100;
    }
    if (mlir::Type::isF16((mlir::Type *)&OperandRange))
    {
      if (NumElements < 1) {
        return *(float *)&v22;
      }
      goto LABEL_116;
    }
    if (mlir::Type::isF32((mlir::Type *)&OperandRange))
    {
      if (NumElements < 1) {
        return *(float *)&v22;
      }
      goto LABEL_132;
    }
    if (mlir::Type::isF64((mlir::Type *)&OperandRange))
    {
      if (NumElements < 1) {
        return *(float *)&v22;
      }
      goto LABEL_148;
    }
    if (mlir::Type::isBF16((mlir::Type *)&OperandRange))
    {
      if (NumElements < 1) {
        return *(float *)&v22;
      }
      goto LABEL_163;
    }
LABEL_165:
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 1))
    {
      if (v18) {
        unint64_t v70 = 1;
      }
      else {
        unint64_t v70 = NumElements;
      }
      llvm::SmallVector<char,40u>::SmallVector((uint64_t)v97, v70);
      mlir::detail::unpackBooleanData(ElementsAttrRawData, v21, (uint64_t)v97[0], (unint64_t)v97[1]);
      uint64_t v71 = (char *)v97[0];
      if (NumElements >= 1)
      {
        for (uint64_t i = 0; i != NumElements; ++i)
        {
          if (v18) {
            uint64_t v73 = 0;
          }
          else {
            uint64_t v73 = i;
          }
          *(_DWORD *)(a3 + 4 * i) = v71[v73];
        }
      }
      if (v71 != (char *)v98) {
        free(v71);
      }
    }
    else
    {
      mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange);
      IntOrFloatBitunsigned int Width = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange);
      mlir::detail::unpackQuantizedData<int>(ElementsAttrRawData, v21, a3, NumElements, IntOrFloatBitWidth);
    }
    return *(float *)&v22;
  }
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
  {
    int64_t NumElements = 1;
LABEL_17:
    for (uint64_t j = 0; j != NumElements; ++j)
    {
      if (v18) {
        uint64_t v25 = 0;
      }
      else {
        uint64_t v25 = j;
      }
      *(_DWORD *)(a3 + 4 * j) = ElementsAttrRawData[v25];
    }
    return *(float *)&v22;
  }
  if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 8))
  {
    int64_t NumElements = 1;
LABEL_28:
    for (uint64_t k = 0; k != NumElements; ++k)
    {
      if (v18) {
        uint64_t v27 = 0;
      }
      else {
        uint64_t v27 = k;
      }
      *(_DWORD *)(a3 + 4 * k) = (char)ElementsAttrRawData[v27];
    }
    return *(float *)&v22;
  }
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16))
  {
    int64_t NumElements = 1;
LABEL_37:
    unint64_t v28 = 0;
    do
    {
      if (v18) {
        unint64_t v84 = 0;
      }
      else {
        unint64_t v84 = v28;
      }
      *(_DWORD *)(a3 + 4 * v28++) = *(unsigned __int16 *)&ElementsAttrRawData[2 * v84];
LABEL_200:
      ;
    }
    while (NumElements != v28);
    return *(float *)&v22;
  }
  if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 16))
  {
    int64_t NumElements = 1;
LABEL_55:
    if ((unint64_t)NumElements >= 2)
    {
      uint64_t v37 = 0;
      unint64_t v34 = NumElements & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v18) {
          uint64_t v38 = 0;
        }
        else {
          uint64_t v38 = v37;
        }
        if (v18) {
          uint64_t v39 = 0;
        }
        else {
          uint64_t v39 = v37 + 1;
        }
        int v40 = *(__int16 *)&ElementsAttrRawData[2 * v39];
        unint64_t v41 = (_DWORD *)(a3 + 4 * v37);
        _DWORD *v41 = *(__int16 *)&ElementsAttrRawData[2 * v38];
        v41[1] = v40;
        v37 += 2;
      }
      while (v37 != v34);
      goto LABEL_206;
    }
    unint64_t v34 = 0;
    do
    {
      if (v18) {
        unint64_t v85 = 0;
      }
      else {
        unint64_t v85 = v34;
      }
      *(_DWORD *)(a3 + 4 * v34++) = *(__int16 *)&ElementsAttrRawData[2 * v85];
LABEL_206:
      ;
    }
    while (NumElements != v34);
    return *(float *)&v22;
  }
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32))
  {
    int64_t NumElements = 1;
LABEL_62:
    for (uint64_t m = 0; m != NumElements; ++m)
    {
      if (v18) {
        uint64_t v36 = 0;
      }
      else {
        uint64_t v36 = m;
      }
      *(_DWORD *)(a3 + 4 * m) = *(_DWORD *)&ElementsAttrRawData[4 * v36];
    }
    return *(float *)&v22;
  }
  if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 32))
  {
    int64_t NumElements = 1;
LABEL_82:
    for (uint64_t n = 0; n != NumElements; ++n)
    {
      if (v18) {
        uint64_t v43 = 0;
      }
      else {
        uint64_t v43 = n;
      }
      *(_DWORD *)(a3 + 4 * n) = *(_DWORD *)&ElementsAttrRawData[4 * v43];
    }
    return *(float *)&v22;
  }
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
  {
    int64_t NumElements = 1;
LABEL_93:
    if ((unint64_t)NumElements >= 2)
    {
      uint64_t v46 = 0;
      unint64_t v44 = NumElements & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v18) {
          uint64_t v47 = 0;
        }
        else {
          uint64_t v47 = v46;
        }
        if (v18) {
          uint64_t v48 = 0;
        }
        else {
          uint64_t v48 = v46 + 1;
        }
        uint64_t v49 = *(void *)&ElementsAttrRawData[8 * v48];
        uint64_t v50 = (_DWORD *)(a3 + 4 * v46);
        *uint64_t v50 = *(void *)&ElementsAttrRawData[8 * v47];
        v50[1] = v49;
        v46 += 2;
      }
      while (v46 != v44);
      goto LABEL_212;
    }
    unint64_t v44 = 0;
    do
    {
      if (v18) {
        unint64_t v86 = 0;
      }
      else {
        unint64_t v86 = v44;
      }
      *(_DWORD *)(a3 + 4 * v44++) = *(void *)&ElementsAttrRawData[8 * v86];
LABEL_212:
      ;
    }
    while (NumElements != v44);
    return *(float *)&v22;
  }
  if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 64))
  {
    int64_t NumElements = 1;
LABEL_100:
    if ((unint64_t)NumElements >= 2)
    {
      uint64_t v52 = 0;
      unint64_t v45 = NumElements & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v18) {
          uint64_t v53 = 0;
        }
        else {
          uint64_t v53 = v52;
        }
        if (v18) {
          uint64_t v54 = 0;
        }
        else {
          uint64_t v54 = v52 + 1;
        }
        uint64_t v55 = *(void *)&ElementsAttrRawData[8 * v54];
        long long v56 = (_DWORD *)(a3 + 4 * v52);
        *long long v56 = *(void *)&ElementsAttrRawData[8 * v53];
        v56[1] = v55;
        v52 += 2;
      }
      while (v52 != v45);
      goto LABEL_218;
    }
    unint64_t v45 = 0;
    do
    {
      if (v18) {
        unint64_t v87 = 0;
      }
      else {
        unint64_t v87 = v45;
      }
      *(_DWORD *)(a3 + 4 * v45++) = *(void *)&ElementsAttrRawData[8 * v87];
LABEL_218:
      ;
    }
    while (NumElements != v45);
    return *(float *)&v22;
  }
  if (mlir::Type::isF16((mlir::Type *)&OperandRange))
  {
    int64_t NumElements = 1;
LABEL_116:
    if ((unint64_t)NumElements >= 2)
    {
      uint64_t v58 = 0;
      unint64_t v51 = NumElements & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v18) {
          uint64_t v59 = 0;
        }
        else {
          uint64_t v59 = v58;
        }
        if (v18) {
          uint64_t v60 = 0;
        }
        else {
          uint64_t v60 = v58 + 1;
        }
        LOWORD(v22) = *(_WORD *)&ElementsAttrRawData[2 * v59];
        int v61 = (int)*(short float *)&ElementsAttrRawData[2 * v60];
        uint64_t v62 = (_DWORD *)(a3 + 4 * v58);
        _DWORD *v62 = (int)*(short float *)&v22;
        v62[1] = v61;
        v58 += 2;
      }
      while (v58 != v51);
      goto LABEL_224;
    }
    unint64_t v51 = 0;
    do
    {
      if (v18) {
        unint64_t v88 = 0;
      }
      else {
        unint64_t v88 = v51;
      }
      LOWORD(v22) = *(_WORD *)&ElementsAttrRawData[2 * v88];
      *(_DWORD *)(a3 + 4 * v51++) = (int)*(short float *)&v22;
LABEL_224:
      ;
    }
    while (NumElements != v51);
    return *(float *)&v22;
  }
  if (mlir::Type::isF32((mlir::Type *)&OperandRange))
  {
    int64_t NumElements = 1;
LABEL_132:
    if ((unint64_t)NumElements >= 2)
    {
      uint64_t v64 = 0;
      unint64_t v57 = NumElements & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v18) {
          uint64_t v65 = 0;
        }
        else {
          uint64_t v65 = v64;
        }
        if (v18) {
          uint64_t v66 = 0;
        }
        else {
          uint64_t v66 = v64 + 1;
        }
        LODWORD(v22) = *(_DWORD *)&ElementsAttrRawData[4 * v65];
        int v67 = (int)*(float *)&ElementsAttrRawData[4 * v66];
        uint64_t v68 = (_DWORD *)(a3 + 4 * v64);
        *uint64_t v68 = (int)*(float *)&v22;
        v68[1] = v67;
        v64 += 2;
      }
      while (v64 != v57);
      goto LABEL_230;
    }
    unint64_t v57 = 0;
    do
    {
      if (v18) {
        unint64_t v89 = 0;
      }
      else {
        unint64_t v89 = v57;
      }
      LODWORD(v22) = *(_DWORD *)&ElementsAttrRawData[4 * v89];
      *(_DWORD *)(a3 + 4 * v57++) = (int)*(float *)&v22;
LABEL_230:
      ;
    }
    while (NumElements != v57);
    return *(float *)&v22;
  }
  if (mlir::Type::isF64((mlir::Type *)&OperandRange))
  {
    int64_t NumElements = 1;
LABEL_148:
    if ((unint64_t)NumElements >= 2)
    {
      uint64_t v74 = 0;
      unint64_t v63 = NumElements & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v18) {
          uint64_t v75 = 0;
        }
        else {
          uint64_t v75 = v74;
        }
        if (v18) {
          uint64_t v76 = 0;
        }
        else {
          uint64_t v76 = v74 + 1;
        }
        double v22 = *(double *)&ElementsAttrRawData[8 * v75];
        int v77 = (int)*(double *)&ElementsAttrRawData[8 * v76];
        long long v78 = (_DWORD *)(a3 + 4 * v74);
        *long long v78 = (int)v22;
        v78[1] = v77;
        v74 += 2;
      }
      while (v74 != v63);
      goto LABEL_236;
    }
    unint64_t v63 = 0;
    do
    {
      if (v18) {
        unint64_t v90 = 0;
      }
      else {
        unint64_t v90 = v63;
      }
      double v22 = *(double *)&ElementsAttrRawData[8 * v90];
      *(_DWORD *)(a3 + 4 * v63++) = (int)v22;
LABEL_236:
      ;
    }
    while (NumElements != v63);
    return *(float *)&v22;
  }
  int64_t NumElements = 1;
  if (!mlir::Type::isBF16((mlir::Type *)&OperandRange)) {
    goto LABEL_165;
  }
LABEL_163:
  if ((unint64_t)NumElements >= 2)
  {
    uint64_t v80 = 0;
    unint64_t v69 = NumElements & 0xFFFFFFFFFFFFFFFELL;
    int v81 = (double *)a3;
    do
    {
      if (v18) {
        uint64_t v82 = 0;
      }
      else {
        uint64_t v82 = v80;
      }
      if (v18) {
        uint64_t v83 = 0;
      }
      else {
        uint64_t v83 = v80 + 1;
      }
      LOWORD(v22) = *(_WORD *)&ElementsAttrRawData[2 * v82];
      WORD2(v22) = *(_WORD *)&ElementsAttrRawData[2 * v83];
      double v22 = COERCE_DOUBLE(vcvt_s32_f32((float32x2_t)vshl_n_s32(*(int32x2_t *)&v22, 0x10uLL)));
      *v81++ = v22;
      v80 += 2;
    }
    while (v80 != v69);
    goto LABEL_238;
  }
  unint64_t v69 = 0;
  do
  {
    if (v18) {
      unint64_t v91 = 0;
    }
    else {
      unint64_t v91 = v69;
    }
    LODWORD(v22) = *(unsigned __int16 *)&ElementsAttrRawData[2 * v91] << 16;
    *(_DWORD *)(a3 + 4 * v69++) = (int)*(float *)&v22;
LABEL_238:
    ;
  }
  while (NumElements != v69);
  return *(float *)&v22;
}

unsigned __int8 *mlir::detail::unpackQuantizedData<int>(unsigned __int8 *result, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  if (a2)
  {
    uint64_t v5 = 0;
    int v6 = ~(-1 << a5);
    unint64_t v7 = a4;
    unint64_t v8 = 8 / a5;
    do
    {
      unint64_t v9 = v5 * v8;
      unint64_t v10 = a4 - v5 * v8;
      if (v10 >= v8) {
        unint64_t v10 = 8 / a5;
      }
      if (!v10) {
        goto LABEL_3;
      }
      unsigned int v11 = *result;
      if (v7 >= v8) {
        unint64_t v12 = 8 / a5;
      }
      else {
        unint64_t v12 = v7;
      }
      uint64x2_t v13 = (uint64x2_t)vdupq_n_s64(v12 - 1);
      int32x2_t v14 = vmovn_s64((int64x2_t)vcgeq_u64(v13, (uint64x2_t)xmmword_1810FE2E0));
      if (v14.i8[0]) {
        *(_DWORD *)(a3 + 4 * v9) = v6 & v11;
      }
      if (v14.i8[4]) {
        *(_DWORD *)(a3 + 4 * v9 + 4) = (v11 >> a5) & v6;
      }
      uint64_t v15 = ((_BYTE)v12 + 1) & 0x1E;
      if (v15 == 2) {
        goto LABEL_3;
      }
      int32x2_t v16 = vmovn_s64((int64x2_t)vcgtq_u64(v13, (uint64x2_t)xmmword_1810FE320));
      if (v16.i8[0])
      {
        *(_DWORD *)(a3 + 4 * v9 + 8) = (v11 >> (2 * a5)) & v6;
        if (v16.i8[4])
        {
LABEL_20:
          *(_DWORD *)(a3 + 4 * v9 + 12) = (v11 >> (3 * a5)) & v6;
          if (v15 == 4) {
            goto LABEL_3;
          }
          goto LABEL_21;
        }
      }
      else if (v16.i8[4])
      {
        goto LABEL_20;
      }
      if (v15 == 4) {
        goto LABEL_3;
      }
LABEL_21:
      int32x2_t v17 = vmovn_s64((int64x2_t)vcgtq_u64(v13, (uint64x2_t)xmmword_1810FE330));
      if (v17.i8[0])
      {
        *(_DWORD *)(a3 + 4 * v9 + 16) = (v11 >> (4 * a5)) & v6;
        if ((v17.i8[4] & 1) == 0)
        {
LABEL_23:
          if (v15 != 6) {
            goto LABEL_27;
          }
          goto LABEL_3;
        }
      }
      else if ((v17.i8[4] & 1) == 0)
      {
        goto LABEL_23;
      }
      *(_DWORD *)(a3 + 4 * v9 + 20) = (v11 >> (5 * a5)) & v6;
      if (v15 != 6)
      {
LABEL_27:
        int32x2_t v18 = vmovn_s64((int64x2_t)vcgtq_u64(v13, (uint64x2_t)xmmword_1810FE340));
        if (v18.i8[0]) {
          *(_DWORD *)(a3 + 4 * v9 + 24) = (v11 >> (6 * a5)) & v6;
        }
        if (v18.i8[4]) {
          *(_DWORD *)(a3 + 4 * v9 + 28) = (v11 >> (7 * a5)) & v6;
        }
      }
LABEL_3:
      ++v5;
      v7 -= v8;
      ++result;
      --a2;
    }
    while (a2);
  }
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value &,unsigned long long,unsigned long long,unsigned long long,unsigned long long>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  v25[38] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.input_view", (const unsigned __int8 *)0xF, Context);
  if (!v16)
  {
    __int16 v24 = 1283;
    void v23[2] = (uint64_t)"anec.input_view";
    v23[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a2, v15);
  mlir::anec::InputView::build(a1, (uint64_t)v25, *a3, *a4, *a5, *a6, *a7);
  int32x2_t v17 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v25);
  if (*(_UNKNOWN **)(*((void *)v17 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::InputView,void>::id) {
    int32x2_t v18 = v17;
  }
  else {
    int32x2_t v18 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
  return v18;
}

void *mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)1>::~ConvertSlice(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)1>::~ConvertSlice(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  BOOL v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::ConversionPatternRewriter *a4)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  uint64_t v48 = a2;
  long long v56 = *(_OWORD *)(a3 + 40);
  uint64_t v5 = (void *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v48) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  unint64_t v9 = *(void **)(v6 + 8);
  unint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    unint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64x2_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      unint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  uint64_t v46 = v5;
  uint64_t v47 = v15;
  v54[0] = &v55;
  v54[1] = (void *)0x100000000;
  unint64_t v45 = 0;
  v44[0] = (unint64_t *)&v45;
  Filter = (const char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v48);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Filter);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::DenseIntElementsAttr>::match(v44, DefiningOp))
  {
    int32x2_t v17 = v45;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v46);
    if (mlir::getPositivePromotedAxes(v17, v18, (uint64_t)v54, 0, 0))
    {
      v44[0] = (unint64_t *)mlir::getRankPromotionTypeForANE((uint64_t)v46, v47);
      v44[1] = v19;
      uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v48);
      Filter = 0;
      uint64_t v50 = 0;
      p_Filter = &Filter;
      uint64_t v53 = (const char **)Bias;
      uint64_t v21 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
      if (v21)
      {
        if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v21))
        {
          uint64_t SingleInt = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
          if ((SingleInt & 0xFF00000000) != 0)
          {
            uint64_t v23 = (int)SingleInt;
            uint64_t v24 = *(unsigned int *)v54[0];
            uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v44);
            Positiveuint64_t Axis = mlir::tryGetPositiveAxis(v23, *(void *)(ArgAttrsAttr + 8 * v24), 0, 0, 0);
            if (v27)
            {
              unint64_t v28 = PositiveAxis;
              uint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v48);
              Filter = 0;
              uint64_t v50 = 0;
              p_Filter = &Filter;
              uint64_t v53 = (const char **)SparseShape;
              uint64_t v30 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
              if (v30)
              {
                if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v30))
                {
                  uint64_t v31 = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
                  if ((v31 & 0xFF00000000) != 0)
                  {
                    int v32 = v31;
                    uint64_t v33 = *((void *)v48 + 3);
                    uint64_t v34 = mlir::ValueRange::dereference_iterator(&v56, 0);
                    uint64_t v35 = v32;
                    uint64_t v36 = 1;
                    mlir::ConversionPatternRewriter::replaceOp(a4, v48, v37);
                    goto LABEL_31;
                  }
                }
              }
              goto LABEL_30;
            }
            Filter = "failed: could not extract a positive value for start attribute";
            __int16 v51 = 259;
            unint64_t v41 = v48;
            uint64_t v53 = &Filter;
            uint64_t v42 = *((void *)a4 + 2);
            if (v42)
            {
              if (mlir::RewriterBase::Listener::classof(v42))
              {
                uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), const char ***))(*(void *)v42 + 64))(v42, *((void *)v41 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v53);
                goto LABEL_25;
              }
            }
          }
        }
      }
    }
    else
    {
      Filter = "failed: could not extract positive promoted axes";
      __int16 v51 = 259;
      uint64_t v38 = v48;
      v44[0] = (unint64_t *)&Filter;
      uint64_t v39 = *((void *)a4 + 2);
      if (v39 && mlir::RewriterBase::Listener::classof(v39))
      {
        uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), unint64_t **))(*(void *)v39 + 64))(v39, *((void *)v38 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v44);
LABEL_25:
        uint64_t v36 = v40;
        goto LABEL_31;
      }
    }
  }
LABEL_30:
  uint64_t v36 = 0;
LABEL_31:
  if (v54[0] != &v55) {
    free(v54[0]);
  }
  return v36;
}

void *mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)2>::~ConvertSlice(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)2>::~ConvertSlice(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  BOOL v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::ConversionPatternRewriter *a4)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  uint64_t v48 = a2;
  long long v56 = *(_OWORD *)(a3 + 40);
  uint64_t v5 = (void *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v48) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  unint64_t v9 = *(void **)(v6 + 8);
  unint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    unint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64x2_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      unint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  uint64_t v46 = v5;
  uint64_t v47 = v15;
  v54[0] = &v55;
  v54[1] = (void *)0x100000000;
  unint64_t v45 = 0;
  v44[0] = (unint64_t *)&v45;
  Filter = (const char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v48);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Filter);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::DenseIntElementsAttr>::match(v44, DefiningOp))
  {
    int32x2_t v17 = v45;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v46);
    if (mlir::getPositivePromotedAxes(v17, v18, (uint64_t)v54, 0, 0))
    {
      v44[0] = (unint64_t *)mlir::getRankPromotionTypeForANE((uint64_t)v46, v47);
      v44[1] = v19;
      uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v48);
      Filter = 0;
      uint64_t v50 = 0;
      p_Filter = &Filter;
      uint64_t v53 = (const char **)Bias;
      uint64_t v21 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
      if (v21)
      {
        if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v21))
        {
          uint64_t SingleInt = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
          if ((SingleInt & 0xFF00000000) != 0)
          {
            uint64_t v23 = (int)SingleInt;
            uint64_t v24 = *(unsigned int *)v54[0];
            uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v44);
            Positiveuint64_t Axis = mlir::tryGetPositiveAxis(v23, *(void *)(ArgAttrsAttr + 8 * v24), 0, 0, 0);
            if (v27)
            {
              uint64_t v28 = PositiveAxis;
              uint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v48);
              Filter = 0;
              uint64_t v50 = 0;
              p_Filter = &Filter;
              uint64_t v53 = (const char **)SparseShape;
              uint64_t v30 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
              if (v30)
              {
                if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v30))
                {
                  uint64_t v31 = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
                  if ((v31 & 0xFF00000000) != 0)
                  {
                    int v32 = v31;
                    uint64_t v33 = *((void *)v48 + 3);
                    uint64_t v34 = mlir::ValueRange::dereference_iterator(&v56, 0);
                    uint64_t v35 = v32;
                    uint64_t v36 = 1;
                    mlir::ConversionPatternRewriter::replaceOp(a4, v48, v37);
                    goto LABEL_31;
                  }
                }
              }
              goto LABEL_30;
            }
            Filter = "failed: could not extract a positive value for start attribute";
            __int16 v51 = 259;
            unint64_t v41 = v48;
            uint64_t v53 = &Filter;
            uint64_t v42 = *((void *)a4 + 2);
            if (v42)
            {
              if (mlir::RewriterBase::Listener::classof(v42))
              {
                uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), const char ***))(*(void *)v42 + 64))(v42, *((void *)v41 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v53);
                goto LABEL_25;
              }
            }
          }
        }
      }
    }
    else
    {
      Filter = "failed: could not extract positive promoted axes";
      __int16 v51 = 259;
      uint64_t v38 = v48;
      v44[0] = (unint64_t *)&Filter;
      uint64_t v39 = *((void *)a4 + 2);
      if (v39 && mlir::RewriterBase::Listener::classof(v39))
      {
        uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), unint64_t **))(*(void *)v39 + 64))(v39, *((void *)v38 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v44);
LABEL_25:
        uint64_t v36 = v40;
        goto LABEL_31;
      }
    }
  }
LABEL_30:
  uint64_t v36 = 0;
LABEL_31:
  if (v54[0] != &v55) {
    free(v54[0]);
  }
  return v36;
}

mlir::GenericProgramPoint *mlir::anonymous namespace'::makeInputViewOp<(mlir::anec::Family)2>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v31 = a3;
  uint64x2_t v13 = (uint64_t *)(*(void *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v13) {
    goto LABEL_10;
  }
  uint64_t v14 = *v13;
  unint64_t v15 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v16 = *(unsigned int *)(v14 + 16);
  if (!v16) {
    goto LABEL_10;
  }
  int32x2_t v17 = *(void **)(v14 + 8);
  unint64_t v18 = &v17[2 * v16];
  do
  {
    unint64_t v19 = v16 >> 1;
    uint64_t v20 = &v17[2 * (v16 >> 1)];
    unint64_t v22 = *v20;
    uint64_t v21 = v20 + 2;
    v16 += ~(v16 >> 1);
    if (v22 < v15) {
      int32x2_t v17 = v21;
    }
    else {
      unint64_t v16 = v19;
    }
  }
  while (v16);
  if (v17 != v18 && *v17 == v15) {
    uint64_t v23 = v17[1];
  }
  else {
LABEL_10:
  }
    uint64_t v23 = 0;
  v30[0] = mlir::getRankPromotionTypeForANE((uint64_t)v13, v23);
  v30[1] = v24;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v30);
  if (!mlir::Type::isF16((mlir::Type *)&OperandRange))
  {
    uint64_t v28 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v30);
    mlir::Type::isF32((mlir::Type *)&v28);
  }
  uint64_t v28 = a5;
  uint64_t OperandRange = a4;
  uint64_t v26 = a7;
  uint64_t v27 = a6;
  return mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value &,unsigned long long,unsigned long long,unsigned long long,unsigned long long>((mlir::Builder *)(a1 + 8), a2, &v31, &OperandRange, &v28, &v27, &v26);
}

void *mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)3>::~ConvertSlice(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)3>::~ConvertSlice(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  BOOL v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::ConversionPatternRewriter *a4)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  uint64_t v48 = a2;
  long long v56 = *(_OWORD *)(a3 + 40);
  uint64_t v5 = (void *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v48) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  unint64_t v9 = *(void **)(v6 + 8);
  unint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    unint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64x2_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      unint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  uint64_t v46 = v5;
  uint64_t v47 = v15;
  v54[0] = &v55;
  v54[1] = (void *)0x100000000;
  unint64_t v45 = 0;
  v44[0] = (unint64_t *)&v45;
  Filter = (const char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v48);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Filter);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::DenseIntElementsAttr>::match(v44, DefiningOp))
  {
    int32x2_t v17 = v45;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v46);
    if (mlir::getPositivePromotedAxes(v17, v18, (uint64_t)v54, 0, 0))
    {
      v44[0] = (unint64_t *)mlir::getRankPromotionTypeForANE((uint64_t)v46, v47);
      v44[1] = v19;
      uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v48);
      Filter = 0;
      uint64_t v50 = 0;
      p_Filter = &Filter;
      uint64_t v53 = (const char **)Bias;
      uint64_t v21 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
      if (v21)
      {
        if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v21))
        {
          uint64_t SingleInt = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
          if ((SingleInt & 0xFF00000000) != 0)
          {
            uint64_t v23 = (int)SingleInt;
            uint64_t v24 = *(unsigned int *)v54[0];
            uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v44);
            Positiveuint64_t Axis = mlir::tryGetPositiveAxis(v23, *(void *)(ArgAttrsAttr + 8 * v24), 0, 0, 0);
            if (v27)
            {
              uint64_t v28 = PositiveAxis;
              uint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v48);
              Filter = 0;
              uint64_t v50 = 0;
              p_Filter = &Filter;
              uint64_t v53 = (const char **)SparseShape;
              uint64_t v30 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
              if (v30)
              {
                if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v30))
                {
                  uint64_t v31 = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
                  if ((v31 & 0xFF00000000) != 0)
                  {
                    int v32 = v31;
                    uint64_t v33 = *((void *)v48 + 3);
                    uint64_t v34 = mlir::ValueRange::dereference_iterator(&v56, 0);
                    uint64_t v35 = v32;
                    uint64_t v36 = 1;
                    mlir::ConversionPatternRewriter::replaceOp(a4, v48, v37);
                    goto LABEL_31;
                  }
                }
              }
              goto LABEL_30;
            }
            Filter = "failed: could not extract a positive value for start attribute";
            __int16 v51 = 259;
            unint64_t v41 = v48;
            uint64_t v53 = &Filter;
            uint64_t v42 = *((void *)a4 + 2);
            if (v42)
            {
              if (mlir::RewriterBase::Listener::classof(v42))
              {
                uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), const char ***))(*(void *)v42 + 64))(v42, *((void *)v41 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v53);
                goto LABEL_25;
              }
            }
          }
        }
      }
    }
    else
    {
      Filter = "failed: could not extract positive promoted axes";
      __int16 v51 = 259;
      uint64_t v38 = v48;
      v44[0] = (unint64_t *)&Filter;
      uint64_t v39 = *((void *)a4 + 2);
      if (v39 && mlir::RewriterBase::Listener::classof(v39))
      {
        uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), unint64_t **))(*(void *)v39 + 64))(v39, *((void *)v38 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v44);
LABEL_25:
        uint64_t v36 = v40;
        goto LABEL_31;
      }
    }
  }
LABEL_30:
  uint64_t v36 = 0;
LABEL_31:
  if (v54[0] != &v55) {
    free(v54[0]);
  }
  return v36;
}

void *mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)4>::~ConvertSlice(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)4>::~ConvertSlice(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  BOOL v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::ConversionPatternRewriter *a4)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  uint64_t v48 = a2;
  long long v56 = *(_OWORD *)(a3 + 40);
  uint64_t v5 = (void *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v48) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  unint64_t v9 = *(void **)(v6 + 8);
  unint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    unint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64x2_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      unint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  uint64_t v46 = v5;
  uint64_t v47 = v15;
  v54[0] = &v55;
  v54[1] = (void *)0x100000000;
  unint64_t v45 = 0;
  v44[0] = (unint64_t *)&v45;
  Filter = (const char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v48);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Filter);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::DenseIntElementsAttr>::match(v44, DefiningOp))
  {
    int32x2_t v17 = v45;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v46);
    if (mlir::getPositivePromotedAxes(v17, v18, (uint64_t)v54, 0, 0))
    {
      v44[0] = (unint64_t *)mlir::getRankPromotionTypeForANE((uint64_t)v46, v47);
      v44[1] = v19;
      uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v48);
      Filter = 0;
      uint64_t v50 = 0;
      p_Filter = &Filter;
      uint64_t v53 = (const char **)Bias;
      uint64_t v21 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
      if (v21)
      {
        if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v21))
        {
          uint64_t SingleInt = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
          if ((SingleInt & 0xFF00000000) != 0)
          {
            uint64_t v23 = (int)SingleInt;
            uint64_t v24 = *(unsigned int *)v54[0];
            uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v44);
            Positiveuint64_t Axis = mlir::tryGetPositiveAxis(v23, *(void *)(ArgAttrsAttr + 8 * v24), 0, 0, 0);
            if (v27)
            {
              uint64_t v28 = PositiveAxis;
              uint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v48);
              Filter = 0;
              uint64_t v50 = 0;
              p_Filter = &Filter;
              uint64_t v53 = (const char **)SparseShape;
              uint64_t v30 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
              if (v30)
              {
                if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v30))
                {
                  uint64_t v31 = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
                  if ((v31 & 0xFF00000000) != 0)
                  {
                    int v32 = v31;
                    uint64_t v33 = *((void *)v48 + 3);
                    uint64_t v34 = mlir::ValueRange::dereference_iterator(&v56, 0);
                    uint64_t v35 = v32;
                    uint64_t v36 = 1;
                    mlir::ConversionPatternRewriter::replaceOp(a4, v48, v37);
                    goto LABEL_31;
                  }
                }
              }
              goto LABEL_30;
            }
            Filter = "failed: could not extract a positive value for start attribute";
            __int16 v51 = 259;
            unint64_t v41 = v48;
            uint64_t v53 = &Filter;
            uint64_t v42 = *((void *)a4 + 2);
            if (v42)
            {
              if (mlir::RewriterBase::Listener::classof(v42))
              {
                uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), const char ***))(*(void *)v42 + 64))(v42, *((void *)v41 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v53);
                goto LABEL_25;
              }
            }
          }
        }
      }
    }
    else
    {
      Filter = "failed: could not extract positive promoted axes";
      __int16 v51 = 259;
      uint64_t v38 = v48;
      v44[0] = (unint64_t *)&Filter;
      uint64_t v39 = *((void *)a4 + 2);
      if (v39 && mlir::RewriterBase::Listener::classof(v39))
      {
        uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), unint64_t **))(*(void *)v39 + 64))(v39, *((void *)v38 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v44);
LABEL_25:
        uint64_t v36 = v40;
        goto LABEL_31;
      }
    }
  }
LABEL_30:
  uint64_t v36 = 0;
LABEL_31:
  if (v54[0] != &v55) {
    free(v54[0]);
  }
  return v36;
}

void *mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)5>::~ConvertSlice(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)5>::~ConvertSlice(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  BOOL v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::ConversionPatternRewriter *a4)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  uint64_t v48 = a2;
  long long v56 = *(_OWORD *)(a3 + 40);
  uint64_t v5 = (void *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v48) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  unint64_t v9 = *(void **)(v6 + 8);
  unint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    unint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64x2_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      unint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  uint64_t v46 = v5;
  uint64_t v47 = v15;
  v54[0] = &v55;
  v54[1] = (void *)0x100000000;
  unint64_t v45 = 0;
  v44[0] = (unint64_t *)&v45;
  Filter = (const char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v48);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Filter);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::DenseIntElementsAttr>::match(v44, DefiningOp))
  {
    int32x2_t v17 = v45;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v46);
    if (mlir::getPositivePromotedAxes(v17, v18, (uint64_t)v54, 0, 0))
    {
      v44[0] = (unint64_t *)mlir::getRankPromotionTypeForANE((uint64_t)v46, v47);
      v44[1] = v19;
      uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v48);
      Filter = 0;
      uint64_t v50 = 0;
      p_Filter = &Filter;
      uint64_t v53 = (const char **)Bias;
      uint64_t v21 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
      if (v21)
      {
        if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v21))
        {
          uint64_t SingleInt = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
          if ((SingleInt & 0xFF00000000) != 0)
          {
            uint64_t v23 = (int)SingleInt;
            uint64_t v24 = *(unsigned int *)v54[0];
            uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v44);
            Positiveuint64_t Axis = mlir::tryGetPositiveAxis(v23, *(void *)(ArgAttrsAttr + 8 * v24), 0, 0, 0);
            if (v27)
            {
              uint64_t v28 = PositiveAxis;
              uint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v48);
              Filter = 0;
              uint64_t v50 = 0;
              p_Filter = &Filter;
              uint64_t v53 = (const char **)SparseShape;
              uint64_t v30 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
              if (v30)
              {
                if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v30))
                {
                  uint64_t v31 = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
                  if ((v31 & 0xFF00000000) != 0)
                  {
                    int v32 = v31;
                    uint64_t v33 = *((void *)v48 + 3);
                    uint64_t v34 = mlir::ValueRange::dereference_iterator(&v56, 0);
                    uint64_t v35 = v32;
                    uint64_t v36 = 1;
                    mlir::ConversionPatternRewriter::replaceOp(a4, v48, v37);
                    goto LABEL_31;
                  }
                }
              }
              goto LABEL_30;
            }
            Filter = "failed: could not extract a positive value for start attribute";
            __int16 v51 = 259;
            unint64_t v41 = v48;
            uint64_t v53 = &Filter;
            uint64_t v42 = *((void *)a4 + 2);
            if (v42)
            {
              if (mlir::RewriterBase::Listener::classof(v42))
              {
                uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), const char ***))(*(void *)v42 + 64))(v42, *((void *)v41 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v53);
                goto LABEL_25;
              }
            }
          }
        }
      }
    }
    else
    {
      Filter = "failed: could not extract positive promoted axes";
      __int16 v51 = 259;
      uint64_t v38 = v48;
      v44[0] = (unint64_t *)&Filter;
      uint64_t v39 = *((void *)a4 + 2);
      if (v39 && mlir::RewriterBase::Listener::classof(v39))
      {
        uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), unint64_t **))(*(void *)v39 + 64))(v39, *((void *)v38 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v44);
LABEL_25:
        uint64_t v36 = v40;
        goto LABEL_31;
      }
    }
  }
LABEL_30:
  uint64_t v36 = 0;
LABEL_31:
  if (v54[0] != &v55) {
    free(v54[0]);
  }
  return v36;
}

void *mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)6>::~ConvertSlice(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)6>::~ConvertSlice(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  BOOL v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::ConversionPatternRewriter *a4)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  uint64_t v48 = a2;
  long long v56 = *(_OWORD *)(a3 + 40);
  uint64_t v5 = (void *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v48) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  unint64_t v9 = *(void **)(v6 + 8);
  unint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    unint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64x2_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      unint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  uint64_t v46 = v5;
  uint64_t v47 = v15;
  v54[0] = &v55;
  v54[1] = (void *)0x100000000;
  unint64_t v45 = 0;
  v44[0] = (unint64_t *)&v45;
  Filter = (const char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v48);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Filter);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::DenseIntElementsAttr>::match(v44, DefiningOp))
  {
    int32x2_t v17 = v45;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v46);
    if (mlir::getPositivePromotedAxes(v17, v18, (uint64_t)v54, 0, 0))
    {
      v44[0] = (unint64_t *)mlir::getRankPromotionTypeForANE((uint64_t)v46, v47);
      v44[1] = v19;
      uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v48);
      Filter = 0;
      uint64_t v50 = 0;
      p_Filter = &Filter;
      uint64_t v53 = (const char **)Bias;
      uint64_t v21 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
      if (v21)
      {
        if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v21))
        {
          uint64_t SingleInt = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
          if ((SingleInt & 0xFF00000000) != 0)
          {
            uint64_t v23 = (int)SingleInt;
            uint64_t v24 = *(unsigned int *)v54[0];
            uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v44);
            Positiveuint64_t Axis = mlir::tryGetPositiveAxis(v23, *(void *)(ArgAttrsAttr + 8 * v24), 0, 0, 0);
            if (v27)
            {
              uint64_t v28 = PositiveAxis;
              uint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v48);
              Filter = 0;
              uint64_t v50 = 0;
              p_Filter = &Filter;
              uint64_t v53 = (const char **)SparseShape;
              uint64_t v30 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
              if (v30)
              {
                if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v30))
                {
                  uint64_t v31 = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
                  if ((v31 & 0xFF00000000) != 0)
                  {
                    int v32 = v31;
                    uint64_t v33 = *((void *)v48 + 3);
                    uint64_t v34 = mlir::ValueRange::dereference_iterator(&v56, 0);
                    uint64_t v35 = v32;
                    uint64_t v36 = 1;
                    mlir::ConversionPatternRewriter::replaceOp(a4, v48, v37);
                    goto LABEL_31;
                  }
                }
              }
              goto LABEL_30;
            }
            Filter = "failed: could not extract a positive value for start attribute";
            __int16 v51 = 259;
            unint64_t v41 = v48;
            uint64_t v53 = &Filter;
            uint64_t v42 = *((void *)a4 + 2);
            if (v42)
            {
              if (mlir::RewriterBase::Listener::classof(v42))
              {
                uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), const char ***))(*(void *)v42 + 64))(v42, *((void *)v41 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v53);
                goto LABEL_25;
              }
            }
          }
        }
      }
    }
    else
    {
      Filter = "failed: could not extract positive promoted axes";
      __int16 v51 = 259;
      uint64_t v38 = v48;
      v44[0] = (unint64_t *)&Filter;
      uint64_t v39 = *((void *)a4 + 2);
      if (v39 && mlir::RewriterBase::Listener::classof(v39))
      {
        uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), unint64_t **))(*(void *)v39 + 64))(v39, *((void *)v38 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v44);
LABEL_25:
        uint64_t v36 = v40;
        goto LABEL_31;
      }
    }
  }
LABEL_30:
  uint64_t v36 = 0;
LABEL_31:
  if (v54[0] != &v55) {
    free(v54[0]);
  }
  return v36;
}

void *mlir::anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)0>::~ConvertStridedSlice(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)0>::~ConvertStridedSlice(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  BOOL v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::StridedSliceOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::StridedSliceOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::StridedSliceOpGenericAdaptorBase::StridedSliceOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::StridedSliceOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::StridedSliceOpGenericAdaptorBase::StridedSliceOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::StridedSliceOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(uint64_t **)(a3 + 72);
  uint64_t v9 = *(void *)(a3 + 80);
  uint64_t v36 = v8;
  uint64_t v37 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v19)
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
        uint64_t v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v37 = v23;
        if (v36)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
            || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
          {
            goto LABEL_32;
          }
          uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v36);
          if (v25) {
            break;
          }
        }
LABEL_23:
        if (++v21 == v19) {
          goto LABEL_35;
        }
      }
      uint64_t v26 = 8 * v25;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v26 -= 8;
        if (!v26) {
          goto LABEL_23;
        }
      }
LABEL_32:
      v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
      __int16 v33 = 259;
      v30[0] = v32;
      uint64_t v27 = *(void *)(a4 + 16);
      if (v27)
      {
        uint64_t result = mlir::RewriterBase::Listener::classof(v27);
        if (result) {
          return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StridedSliceOp &>(mlir::mps::StridedSliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
        }
        return result;
      }
    }
    else
    {
LABEL_35:
      if (*(_UNKNOWN **)(*(void *)(mlir::Block::getParentOp(*(mlir::Block **)(a2 + 16)) + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mpsx::FusionOp,void>::id)
      {
        long long v28 = *(_OWORD *)(a3 + 48);
        uint64_t v34[2] = *(_OWORD *)(a3 + 32);
        v34[3] = v28;
        _OWORD v34[4] = *(_OWORD *)(a3 + 64);
        uint64_t v35 = *(void *)(a3 + 80);
        long long v29 = *(_OWORD *)(a3 + 16);
        v34[0] = *(_OWORD *)a3;
        v34[1] = v29;
        return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v37;
    if (v36 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  uint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StridedSliceOp &>(mlir::mps::StridedSliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v121 = *MEMORY[0x1E4F143B8];
  uint64_t v91 = a2;
  long long v120 = *(_OWORD *)(a3 + 72);
  uint64_t v5 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v91) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v107 = v5;
  uint64_t v108 = v15;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v107);
  int64_t v17 = v16;
  BOOL IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v91);
  v118[0] = v119;
  v118[1] = (void *)0x500000000;
  uint64_t v19 = v91;
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v91);
  {
    uint64_t v63 = 0;
    goto LABEL_126;
  }
  v116[0] = v117;
  v116[1] = (void *)0x500000000;
  uint64_t v21 = v91;
  uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v91);
  {
    uint64_t v113 = v115;
    uint64_t v114 = 0x500000000;
    uint64_t v23 = v91;
    uint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v91);
    if (v114)
    {
      uint64_t v25 = (uint64_t *)v113;
      uint64_t v26 = 8 * v114;
      while (*v25 > 0)
      {
        ++v25;
        v26 -= 8;
        if (!v26) {
          goto LABEL_18;
        }
      }
      unint64_t v107 = "failed: non strictly positive strides are not supported";
      v109[8] = 259;
      uint64_t v64 = v91;
      float64x2x2_t v101 = &v107;
      uint64_t v65 = *(void *)(a4 + 16);
      if (v65 && mlir::RewriterBase::Listener::classof(v65))
      {
        uint64_t v63 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v65 + 64))(v65, *(void *)(v64 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StridedSliceOp &>(mlir::mps::StridedSliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v101);
        goto LABEL_122;
      }
LABEL_89:
      uint64_t v63 = 0;
LABEL_122:
      if (v113 != v115) {
        free(v113);
      }
      goto LABEL_124;
    }
LABEL_18:
    unint64_t v107 = v109;
    uint64_t v108 = 0x500000000;
    uint64_t v111 = 0;
    uint64_t v112 = 0;
    unint64_t v110 = &v111;
    uint64_t v27 = v91;
    unsigned int Index = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v91);
    {
      float64x2x2_t v101 = v103;
      uint64_t v102 = 0x500000000;
      unint64_t v105 = 0;
      uint64_t v106 = 0;
      uint64_t v104 = &v105;
      uint64_t v29 = v91;
      unsigned int Offset = mlir::mps::ReadDataFromFileOp::getOffset((mlir::mps::ReadDataFromFileOp *)&v91);
      {
        uint64_t v96 = (mlir::anec **)v98;
        uint64_t v97 = 0x500000000;
        uint64_t v99 = 0;
        uint64_t v100 = 0;
        v98[5] = &v99;
        uint64_t v31 = v91;
        unsigned int Groups = mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v91);
        {
          __int16 v33 = (char *)mlir::ValueRange::dereference_iterator(&v120, 0);
          unint64_t v90 = v33;
          long long v93 = (void *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v91) + 8) & 0xFFFFFFFFFFFFFFF8);
          uint64_t v34 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v93);
          v89[0] = mlir::getRankPromotionTypeForANE((uint64_t)v34, v35);
          v89[1] = v36;
          mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
          if (v37 >= 1)
          {
            for (uint64_t i = 0; (uint64_t)i < v39; uint64_t i = (mlir::anec *)((char *)i + 1))
            {
              uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
              if (v112)
              {
                for (uint64_t j = v111; j; uint64_t j = (void *)*j)
                {
                  uint64_t v42 = j[4];
                  if ((uint64_t)i >= v42)
                  {
                    if (v42 >= (uint64_t)i) {
                      goto LABEL_39;
                    }
                    ++j;
                  }
                }
              }
              else if (v108)
              {
                uint64_t v43 = (mlir::anec **)v107;
                uint64_t v44 = 8 * v108;
                while (*v43 != i)
                {
                  ++v43;
                  v44 -= 8;
                  if (!v44) {
                    goto LABEL_40;
                  }
                }
                if (v44)
                {
LABEL_39:
                  uint64_t v45 = 0;
                  goto LABEL_41;
                }
              }
LABEL_40:
              uint64_t v45 = *((void *)v118[0] + i);
LABEL_41:
              uint64_t v46 = *(void *)(ArgAttrsAttr + 8 * i);
              if (v106)
              {
                for (uint64_t k = v105; k; uint64_t k = (void *)*k)
                {
                  uint64_t v48 = k[4];
                  if ((uint64_t)i >= v48)
                  {
                    if (v48 >= (uint64_t)i)
                    {
                      uint64_t v49 = *(void *)(ArgAttrsAttr + 8 * i);
                      goto LABEL_56;
                    }
                    ++k;
                  }
                }
LABEL_55:
                uint64_t v49 = *((void *)v116[0] + i);
                goto LABEL_56;
              }
              if (!v102) {
                goto LABEL_55;
              }
              uint64_t v50 = (mlir::anec **)v101;
              uint64_t v51 = 8 * v102;
              while (*v50 != i)
              {
                ++v50;
                v51 -= 8;
                if (!v51) {
                  goto LABEL_55;
                }
              }
              uint64_t v49 = *(void *)(ArgAttrsAttr + 8 * i);
              if (!v51) {
                goto LABEL_55;
              }
LABEL_56:
              uint64_t v52 = *((void *)v113 + i);
              uint64_t v53 = v49 + v45;
              if (v49 == -1) {
                uint64_t v53 = *(void *)(ArgAttrsAttr + 8 * i);
              }
              if (!IsSize) {
                uint64_t v53 = v49;
              }
              uint64_t v54 = (v46 & (v45 >> 63)) + v45;
              uint64_t v55 = (v46 & (v53 >> 63)) + v53;
              if (v46 - 1 < v54) {
                uint64_t v54 = v46 - 1;
              }
              unint64_t v56 = v54 & ~(v54 >> 63);
              if (v46 >= v55) {
                uint64_t v57 = v55;
              }
              else {
                uint64_t v57 = *(void *)(ArgAttrsAttr + 8 * i);
              }
              if (v100)
              {
                for (uint64_t m = v99; m; uint64_t m = (void *)*m)
                {
                  uint64_t v59 = m[4];
                  if ((uint64_t)i >= v59)
                  {
                    if (v59 >= (uint64_t)i) {
                      goto LABEL_79;
                    }
                    ++m;
                  }
                }
              }
              else if (v97)
              {
                uint64_t v60 = v96;
                int v61 = &v96[v97];
                while (*v60 != i)
                {
                  if (++v60 == v61) {
                    goto LABEL_81;
                  }
                }
                if (v60 != v61)
                {
LABEL_79:
                  uint64_t v62 = 1;
                  if (v46 == 1) {
                    goto LABEL_24;
                  }
                  goto LABEL_23;
                }
              }
LABEL_81:
              uint64_t v62 = (uint64_t)(v52 + ~v56 + (v57 & ~(v57 >> 63))) / v52;
              if (v62 == v46) {
                goto LABEL_24;
              }
LABEL_23:
              unint64_t v90 = v33;
LABEL_24:
              mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
            }
          }
          if (v97 || v100)
          {
            long long v93 = (void *)(*((void *)v33 + 1) & 0xFFFFFFFFFFFFFFF8);
            v88[0] = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v93);
            v88[1] = v66;
            long long v93 = v95;
            uint64_t v94 = 0x400000000;
            uint64_t v67 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v88);
            if (v68)
            {
              unint64_t v69 = (uint64_t *)v67;
              unint64_t v70 = 0;
              uint64_t v71 = (uint64_t *)(v67 + 8 * v68);
              do
              {
                if (v100)
                {
                  for (uint64_t n = v99; n; uint64_t n = (void *)*n)
                  {
                    uint64_t v73 = (mlir::anec *)n[4];
                    if ((uint64_t)v70 >= (uint64_t)v73)
                    {
                      if ((uint64_t)v73 >= (uint64_t)v70) {
                        goto LABEL_96;
                      }
                      ++n;
                    }
                  }
                }
                else if (v97)
                {
                  uint64_t v74 = v96;
                  uint64_t v75 = 8 * v97;
                  while (*v74 != v70)
                  {
                    ++v74;
                    v75 -= 8;
                    if (!v75) {
                      goto LABEL_109;
                    }
                  }
                  if (v75) {
                    goto LABEL_96;
                  }
                }
LABEL_109:
                uint64_t v76 = *v69;
                uint64_t v77 = v94;
                if (v94 >= (unint64_t)HIDWORD(v94))
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v95, v94 + 1, 8);
                  uint64_t v77 = v94;
                }
                *((void *)v93 + v77) = v76;
                LODWORD(v94) = v94 + 1;
LABEL_96:
                unint64_t v70 = (mlir::anec *)((char *)v70 + 1);
                ++v69;
              }
              while (v69 != v71);
            }
            long long v78 = v93;
            uint64_t v79 = (mlir::AffineMap *)v94;
            uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf((uint64_t)v33);
            unint64_t v86 = (uint64_t *)mlir::MemRefType::get(v78, v79, ElementTypeOrSelf, 0, 0, 0);
            int v81 = mlir::Type::cast<mlir::ShapedType>(&v86);
            v87[0] = mlir::getRankPromotionTypeForANE((uint64_t)v81, v82);
            v87[1] = v83;
            __int16 v33 = (char *)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::ShapedType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(void *)(v91 + 24), v87, (uint64_t *)&v90)- 16;
            unint64_t v90 = v33;
            if (v93 != v95)
            {
              free(v93);
              __int16 v33 = v90;
            }
          }
          unint64_t v84 = (unsigned int *)v91;
          long long v93 = v33;
          uint64_t v63 = 1;
          mlir::ValueRange::ValueRange(v92, (uint64_t)&v93, 1uLL);
          mlir::ConversionPatternRewriter::replaceOp(a4, v84, v92[0], v92[1]);
        }
        else
        {
          uint64_t v63 = 0;
        }
        llvm::SmallSet<long long,5u,std::less<long long>>::~SmallSet((uint64_t)&v96);
      }
      else
      {
        uint64_t v63 = 0;
      }
      std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy((uint64_t)&v104, v105);
      if (v101 != v103) {
        free(v101);
      }
    }
    else
    {
      uint64_t v63 = 0;
    }
    std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy((uint64_t)&v110, v111);
    if (v107 != v109) {
      free(v107);
    }
    goto LABEL_122;
  }
  uint64_t v63 = 0;
LABEL_124:
  if (v116[0] != v117) {
    free(v116[0]);
  }
LABEL_126:
  if (v118[0] != v119) {
    free(v118[0]);
  }
  return v63;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StridedSliceOp &>(mlir::mps::StridedSliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t mlir::anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)0>::promoteAxesValues(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v20 = (uint64_t **)&v16;
  v18[0] = a3;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v18);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v20, DefiningOp))
  {
    uint64_t v10 = 1;
    mlir::getIntValues<long long>(v16, v17, a5, 1);
    switch(*(_DWORD *)(a5 + 8))
    {
      case 0:
        uint64_t v11 = *(void *)a5;
        uint64_t v12 = a5;
        unint64_t v13 = 4;
        goto LABEL_10;
      case 1:
        uint64_t v11 = *(void *)a5;
        uint64_t v12 = a5;
        unint64_t v13 = 3;
LABEL_10:
        llvm::SmallVectorImpl<long long>::insert(v12, v11, v13, a4);
        uint64_t v10 = 1;
        break;
      case 2:
        uint64_t v10 = 1;
        llvm::SmallVectorImpl<long long>::insert(a5, *(void *)a5 + 8, 1uLL, a4);
        llvm::SmallVectorImpl<long long>::insert(a5, *(void *)a5, 1uLL, a4);
        break;
      case 3:
        uint64_t v10 = 1;
        llvm::SmallVectorImpl<long long>::insert(a5, *(void *)a5 + 16, 1uLL, a4);
        break;
      default:
        return v10;
    }
  }
  else
  {
    v18[0] = "failed: axes value must be a constant";
    __int16 v19 = 259;
    uint64_t v20 = (uint64_t **)v18;
    uint64_t v14 = *(void *)(a1 + 16);
    if (v14 && mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16))) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), uint64_t ***))(*(void *)v14 + 64))(v14, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::Operation *&>(mlir::Operation *&,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v20);
    }
    else {
      return 0;
    }
  }
  return v10;
}

uint64_t mlir::anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)0>::getFlagsToPositivePromotedAxes(uint64_t a1, uint64_t a2, unsigned int a3, int64_t a4, uint64_t a5)
{
  v27[5] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = v27;
  uint64_t v26 = 0x500000000;
  if (a4 < 1)
  {
    unsigned int v10 = 0;
    unint64_t v13 = v27;
  }
  else
  {
    unsigned int v10 = 0;
    uint64_t v11 = 0;
    for (i = 0; i < a4; uint64_t v11 = ++i)
    {
      if ((a3 >> i))
      {
        if (v10 >= HIDWORD(v26))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v10 + 1, 8);
          unsigned int v10 = v26;
        }
        *((void *)v25 + v10) = v11;
        unsigned int v10 = v26 + 1;
        LODWORD(v26) = v26 + 1;
      }
    }
    unint64_t v13 = (uint64_t *)v25;
  }
  unint64_t v22 = v24;
  uint64_t v23 = 0x500000000;
  if (mlir::getPositivePromotedAxes(v13, v10, a4, (uint64_t)&v22, 0, 0))
  {
    uint64_t v14 = *(void **)(a5 + 64);
    *(_DWORD *)(a5 + 8) = 0;
    std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy(a5 + 56, v14);
    *(void *)(a5 + 56) = a5 + 64;
    *(void *)(a5 + 64) = 0;
    *(void *)(a5 + 72) = 0;
    if (v23)
    {
      uint64_t v15 = (uint64_t **)v22;
      uint64_t v16 = 8 * v23;
      do
      {
        llvm::SmallSet<long long,5u,std::less<long long>>::insert(a5, v15++, (uint64_t)v19);
        v16 -= 8;
      }
      while (v16);
    }
    uint64_t v17 = 1;
  }
  else
  {
    v19[0] = "failed: could not extract positive promoted axes";
    __int16 v20 = 259;
    uint64_t v21 = v19;
    uint64_t v17 = *(void *)(a1 + 16);
    if (v17)
    {
      if (mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16))) {
        uint64_t v17 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::Operation *&>(mlir::Operation *&,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v21);
      }
      else {
        uint64_t v17 = 0;
      }
    }
  }
  if (v22 != v24) {
    free(v22);
  }
  if (v25 != v27) {
    free(v25);
  }
  return v17;
}

uint64_t llvm::SmallSet<long long,5u,std::less<long long>>::~SmallSet(uint64_t a1)
{
  if (*(void *)a1 != a1 + 16) {
    free(*(void **)a1);
  }
  return a1;
}

void llvm::SmallSet<long long,5u,std::less<long long>>::insert(uint64_t a1@<X0>, uint64_t **a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(void *)(a1 + 72))
  {
    uint64_t v15 = *(uint64_t ***)a1;
    uint64_t v16 = *(unsigned int *)(a1 + 8);
    uint64_t v17 = *a2;
    if (!v16) {
      goto LABEL_21;
    }
    uint64_t v18 = 8 * v16;
    uint64_t v9 = *(uint64_t ***)a1;
    while (*v9 != v17)
    {
      ++v9;
      v18 -= 8;
      if (!v18) {
        goto LABEL_20;
      }
    }
    if (v18)
    {
      char v19 = 0;
      char v14 = 1;
      goto LABEL_25;
    }
LABEL_20:
    if (v16 <= 4)
    {
LABEL_21:
      if (v16 >= *(_DWORD *)(a1 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v16 + 1, 8);
        uint64_t v16 = *(unsigned int *)(a1 + 8);
        uint64_t v15 = *(uint64_t ***)a1;
      }
      v15[v16] = v17;
      unsigned int v20 = *(_DWORD *)(a1 + 8) + 1;
      *(_DWORD *)(a1 + 8) = v20;
      uint64_t v9 = (uint64_t **)(*(void *)a1 + 8 * v20 - 8);
      char v14 = 1;
      goto LABEL_24;
    }
    unint64_t v7 = (uint64_t **)(a1 + 64);
    do
    {
      unint64_t v22 = *(uint64_t **)(a1 + 64);
      uint64_t v23 = *(void *)(*(void *)a1 + 8 * v16 - 8);
      uint64_t v24 = (uint64_t **)(a1 + 64);
      uint64_t v25 = (uint64_t **)(a1 + 64);
      if (v22)
      {
        while (1)
        {
          while (1)
          {
            uint64_t v25 = (uint64_t **)v22;
            uint64_t v26 = v22[4];
            if (v23 >= v26) {
              break;
            }
            unint64_t v22 = *v25;
            uint64_t v24 = v25;
            if (!*v25) {
              goto LABEL_37;
            }
          }
          if (v26 >= v23) {
            break;
          }
          unint64_t v22 = v25[1];
          if (!v22)
          {
            uint64_t v24 = v25 + 1;
            goto LABEL_37;
          }
        }
      }
      else
      {
LABEL_37:
        uint64_t v27 = (uint64_t *)operator new(0x28uLL);
        uint64_t v27[4] = v23;
        *uint64_t v27 = 0;
        v27[1] = 0;
        uint64_t v27[2] = (uint64_t)v25;
        *uint64_t v24 = v27;
        uint64_t v28 = **(void **)(a1 + 56);
        if (v28)
        {
          *(void *)(a1 + 56) = v28;
          uint64_t v21 = *v24;
        }
        else
        {
          uint64_t v21 = v27;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 64), v21);
        ++*(void *)(a1 + 72);
        LODWORD(v16) = *(_DWORD *)(a1 + 8);
      }
      LODWORD(v16) = v16 - 1;
      *(_DWORD *)(a1 + 8) = v16;
    }
    while (v16);
    unint64_t v8 = *a2;
    uint64_t v29 = *v7;
    uint64_t v9 = (uint64_t **)(a1 + 64);
    if (*v7)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v9 = (uint64_t **)v29;
          uint64_t v30 = v29[4];
          if ((uint64_t)v8 >= v30) {
            break;
          }
          uint64_t v29 = *v9;
          unint64_t v7 = v9;
          if (!*v9) {
            goto LABEL_9;
          }
        }
        if (v30 >= (uint64_t)v8) {
          break;
        }
        uint64_t v29 = v9[1];
        if (!v29)
        {
LABEL_8:
          unint64_t v7 = v9 + 1;
          goto LABEL_9;
        }
      }
      char v14 = 0;
      goto LABEL_24;
    }
LABEL_9:
    uint64_t v11 = (uint64_t *)v9;
    uint64_t v9 = (uint64_t **)operator new(0x28uLL);
    v9[4] = v8;
    *uint64_t v9 = 0;
    v9[1] = 0;
    void v9[2] = v11;
    void *v7 = (uint64_t *)v9;
    uint64_t v12 = **(void **)(a1 + 56);
    unint64_t v13 = (uint64_t *)v9;
    if (v12)
    {
      *(void *)(a1 + 56) = v12;
      unint64_t v13 = *v7;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 64), v13);
    char v14 = 0;
    ++*(void *)(a1 + 72);
LABEL_24:
    char v19 = 1;
    goto LABEL_25;
  }
  unint64_t v7 = (uint64_t **)(a1 + 64);
  uint64_t v6 = *(uint64_t **)(a1 + 64);
  unint64_t v8 = *a2;
  if (!v6)
  {
    uint64_t v9 = (uint64_t **)(a1 + 64);
    goto LABEL_9;
  }
  while (1)
  {
    while (1)
    {
      uint64_t v9 = (uint64_t **)v6;
      unsigned int v10 = (uint64_t *)v6[4];
      if ((uint64_t)v8 >= (uint64_t)v10) {
        break;
      }
      uint64_t v6 = *v9;
      unint64_t v7 = v9;
      if (!*v9) {
        goto LABEL_9;
      }
    }
    if ((uint64_t)v10 >= (uint64_t)v8) {
      break;
    }
    uint64_t v6 = v9[1];
    if (!v6) {
      goto LABEL_8;
    }
  }
  char v14 = 0;
  char v19 = 0;
LABEL_25:
  *(unsigned char *)(a3 + 8) = v14;
  *(void *)a3 = v9;
  *(unsigned char *)(a3 + 16) = v19;
}

void *mlir::anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)1>::~ConvertStridedSlice(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)1>::~ConvertStridedSlice(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  BOOL v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v121 = *MEMORY[0x1E4F143B8];
  uint64_t v91 = a2;
  long long v120 = *(_OWORD *)(a3 + 72);
  uint64_t v5 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v91) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  unsigned int v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    unint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v107 = v5;
  uint64_t v108 = v15;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v107);
  int64_t v17 = v16;
  BOOL IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v91);
  v118[0] = v119;
  v118[1] = (void *)0x500000000;
  uint64_t v19 = v91;
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v91);
  {
    uint64_t v63 = 0;
    goto LABEL_126;
  }
  v116[0] = v117;
  v116[1] = (void *)0x500000000;
  uint64_t v21 = v91;
  uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v91);
  {
    uint64_t v113 = v115;
    uint64_t v114 = 0x500000000;
    uint64_t v23 = v91;
    uint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v91);
    if (v114)
    {
      uint64_t v25 = (uint64_t *)v113;
      uint64_t v26 = 8 * v114;
      while (*v25 > 0)
      {
        ++v25;
        v26 -= 8;
        if (!v26) {
          goto LABEL_18;
        }
      }
      unint64_t v107 = "failed: non strictly positive strides are not supported";
      v109[8] = 259;
      uint64_t v64 = v91;
      float64x2x2_t v101 = &v107;
      uint64_t v65 = *(void *)(a4 + 16);
      if (v65 && mlir::RewriterBase::Listener::classof(v65))
      {
        uint64_t v63 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v65 + 64))(v65, *(void *)(v64 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StridedSliceOp &>(mlir::mps::StridedSliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v101);
        goto LABEL_122;
      }
LABEL_89:
      uint64_t v63 = 0;
LABEL_122:
      if (v113 != v115) {
        free(v113);
      }
      goto LABEL_124;
    }
LABEL_18:
    unint64_t v107 = v109;
    uint64_t v108 = 0x500000000;
    uint64_t v111 = 0;
    uint64_t v112 = 0;
    unint64_t v110 = &v111;
    uint64_t v27 = v91;
    unsigned int Index = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v91);
    {
      float64x2x2_t v101 = v103;
      uint64_t v102 = 0x500000000;
      unint64_t v105 = 0;
      uint64_t v106 = 0;
      uint64_t v104 = &v105;
      uint64_t v29 = v91;
      unsigned int Offset = mlir::mps::ReadDataFromFileOp::getOffset((mlir::mps::ReadDataFromFileOp *)&v91);
      {
        uint64_t v96 = (mlir::anec **)v98;
        uint64_t v97 = 0x500000000;
        uint64_t v99 = 0;
        uint64_t v100 = 0;
        v98[5] = &v99;
        uint64_t v31 = v91;
        unsigned int Groups = mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v91);
        {
          __int16 v33 = (char *)mlir::ValueRange::dereference_iterator(&v120, 0);
          unint64_t v90 = v33;
          long long v93 = (void *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v91) + 8) & 0xFFFFFFFFFFFFFFF8);
          uint64_t v34 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v93);
          v89[0] = mlir::getRankPromotionTypeForANE((uint64_t)v34, v35);
          v89[1] = v36;
          mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
          if (v37 >= 1)
          {
            for (unsigned int i = 0; (uint64_t)i < v39; unsigned int i = (mlir::anec *)((char *)i + 1))
            {
              uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
              if (v112)
              {
                for (uint64_t j = v111; j; uint64_t j = (void *)*j)
                {
                  uint64_t v42 = j[4];
                  if ((uint64_t)i >= v42)
                  {
                    if (v42 >= (uint64_t)i) {
                      goto LABEL_39;
                    }
                    ++j;
                  }
                }
              }
              else if (v108)
              {
                uint64_t v43 = (mlir::anec **)v107;
                uint64_t v44 = 8 * v108;
                while (*v43 != i)
                {
                  ++v43;
                  v44 -= 8;
                  if (!v44) {
                    goto LABEL_40;
                  }
                }
                if (v44)
                {
LABEL_39:
                  uint64_t v45 = 0;
                  goto LABEL_41;
                }
              }
LABEL_40:
              uint64_t v45 = *((void *)v118[0] + i);
LABEL_41:
              uint64_t v46 = *(void *)(ArgAttrsAttr + 8 * i);
              if (v106)
              {
                for (uint64_t k = v105; k; uint64_t k = (void *)*k)
                {
                  uint64_t v48 = k[4];
                  if ((uint64_t)i >= v48)
                  {
                    if (v48 >= (uint64_t)i)
                    {
                      uint64_t v49 = *(void *)(ArgAttrsAttr + 8 * i);
                      goto LABEL_56;
                    }
                    ++k;
                  }
                }
LABEL_55:
                uint64_t v49 = *((void *)v116[0] + i);
                goto LABEL_56;
              }
              if (!v102) {
                goto LABEL_55;
              }
              uint64_t v50 = (mlir::anec **)v101;
              uint64_t v51 = 8 * v102;
              while (*v50 != i)
              {
                ++v50;
                v51 -= 8;
                if (!v51) {
                  goto LABEL_55;
                }
              }
              uint64_t v49 = *(void *)(ArgAttrsAttr + 8 * i);
              if (!v51) {
                goto LABEL_55;
              }
LABEL_56:
              uint64_t v52 = *((void *)v113 + i);
              uint64_t v53 = v49 + v45;
              if (v49 == -1) {
                uint64_t v53 = *(void *)(ArgAttrsAttr + 8 * i);
              }
              if (!IsSize) {
                uint64_t v53 = v49;
              }
              uint64_t v54 = (v46 & (v45 >> 63)) + v45;
              uint64_t v55 = (v46 & (v53 >> 63)) + v53;
              if (v46 - 1 < v54) {
                uint64_t v54 = v46 - 1;
              }
              unint64_t v56 = v54 & ~(v54 >> 63);
              if (v46 >= v55) {
                uint64_t v57 = v55;
              }
              else {
                uint64_t v57 = *(void *)(ArgAttrsAttr + 8 * i);
              }
              if (v100)
              {
                for (uint64_t m = v99; m; uint64_t m = (void *)*m)
                {
                  uint64_t v59 = m[4];
                  if ((uint64_t)i >= v59)
                  {
                    if (v59 >= (uint64_t)i) {
                      goto LABEL_79;
                    }
                    ++m;
                  }
                }
              }
              else if (v97)
              {
                uint64_t v60 = v96;
                int v61 = &v96[v97];
                while (*v60 != i)
                {
                  if (++v60 == v61) {
                    goto LABEL_81;
                  }
                }
                if (v60 != v61)
                {
LABEL_79:
                  uint64_t v62 = 1;
                  if (v46 == 1) {
                    goto LABEL_24;
                  }
                  goto LABEL_23;
                }
              }
LABEL_81:
              uint64_t v62 = (uint64_t)(v52 + ~v56 + (v57 & ~(v57 >> 63))) / v52;
              if (v62 == v46) {
                goto LABEL_24;
              }
LABEL_23:
              unint64_t v90 = v33;
LABEL_24:
              mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
            }
          }
          if (v97 || v100)
          {
            long long v93 = (void *)(*((void *)v33 + 1) & 0xFFFFFFFFFFFFFFF8);
            v88[0] = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v93);
            v88[1] = v66;
            long long v93 = v95;
            uint64_t v94 = 0x400000000;
            uint64_t v67 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v88);
            if (v68)
            {
              unint64_t v69 = (uint64_t *)v67;
              unint64_t v70 = 0;
              uint64_t v71 = (uint64_t *)(v67 + 8 * v68);
              do
              {
                if (v100)
                {
                  for (uint64_t n = v99; n; uint64_t n = (void *)*n)
                  {
                    uint64_t v73 = (mlir::anec *)n[4];
                    if ((uint64_t)v70 >= (uint64_t)v73)
                    {
                      if ((uint64_t)v73 >= (uint64_t)v70) {
                        goto LABEL_96;
                      }
                      ++n;
                    }
                  }
                }
                else if (v97)
                {
                  uint64_t v74 = v96;
                  uint64_t v75 = 8 * v97;
                  while (*v74 != v70)
                  {
                    ++v74;
                    v75 -= 8;
                    if (!v75) {
                      goto LABEL_109;
                    }
                  }
                  if (v75) {
                    goto LABEL_96;
                  }
                }
LABEL_109:
                uint64_t v76 = *v69;
                uint64_t v77 = v94;
                if (v94 >= (unint64_t)HIDWORD(v94))
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v95, v94 + 1, 8);
                  uint64_t v77 = v94;
                }
                *((void *)v93 + v77) = v76;
                LODWORD(v94) = v94 + 1;
LABEL_96:
                unint64_t v70 = (mlir::anec *)((char *)v70 + 1);
                ++v69;
              }
              while (v69 != v71);
            }
            long long v78 = v93;
            uint64_t v79 = (mlir::AffineMap *)v94;
            uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf((uint64_t)v33);
            unint64_t v86 = (uint64_t *)mlir::MemRefType::get(v78, v79, ElementTypeOrSelf, 0, 0, 0);
            int v81 = mlir::Type::cast<mlir::ShapedType>(&v86);
            v87[0] = mlir::getRankPromotionTypeForANE((uint64_t)v81, v82);
            v87[1] = v83;
            __int16 v33 = (char *)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::ShapedType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(void *)(v91 + 24), v87, (uint64_t *)&v90)- 16;
            unint64_t v90 = v33;
            if (v93 != v95)
            {
              free(v93);
              __int16 v33 = v90;
            }
          }
          unint64_t v84 = (unsigned int *)v91;
          long long v93 = v33;
          uint64_t v63 = 1;
          mlir::ValueRange::ValueRange(v92, (uint64_t)&v93, 1uLL);
          mlir::ConversionPatternRewriter::replaceOp(a4, v84, v92[0], v92[1]);
        }
        else
        {
          uint64_t v63 = 0;
        }
        llvm::SmallSet<long long,5u,std::less<long long>>::~SmallSet((uint64_t)&v96);
      }
      else
      {
        uint64_t v63 = 0;
      }
      std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy((uint64_t)&v104, v105);
      if (v101 != v103) {
        free(v101);
      }
    }
    else
    {
      uint64_t v63 = 0;
    }
    std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy((uint64_t)&v110, v111);
    if (v107 != v109) {
      free(v107);
    }
    goto LABEL_122;
  }
  uint64_t v63 = 0;
LABEL_124:
  if (v116[0] != v117) {
    free(v116[0]);
  }
LABEL_126:
  if (v118[0] != v119) {
    free(v118[0]);
  }
  return v63;
}

uint64_t mlir::anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)1>::promoteAxesValues(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  unsigned int v20 = (uint64_t **)&v16;
  v18[0] = a3;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v18);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v20, DefiningOp))
  {
    uint64_t v10 = 1;
    mlir::getIntValues<long long>(v16, v17, a5, 1);
    switch(*(_DWORD *)(a5 + 8))
    {
      case 0:
        uint64_t v11 = *(void *)a5;
        uint64_t v12 = a5;
        unint64_t v13 = 4;
        goto LABEL_10;
      case 1:
        uint64_t v11 = *(void *)a5;
        uint64_t v12 = a5;
        unint64_t v13 = 3;
LABEL_10:
        llvm::SmallVectorImpl<long long>::insert(v12, v11, v13, a4);
        uint64_t v10 = 1;
        break;
      case 2:
        uint64_t v10 = 1;
        llvm::SmallVectorImpl<long long>::insert(a5, *(void *)a5 + 8, 1uLL, a4);
        llvm::SmallVectorImpl<long long>::insert(a5, *(void *)a5, 1uLL, a4);
        break;
      case 3:
        uint64_t v10 = 1;
        llvm::SmallVectorImpl<long long>::insert(a5, *(void *)a5 + 16, 1uLL, a4);
        break;
      default:
        return v10;
    }
  }
  else
  {
    v18[0] = "failed: axes value must be a constant";
    __int16 v19 = 259;
    unsigned int v20 = (uint64_t **)v18;
    uint64_t v14 = *(void *)(a1 + 16);
    if (v14 && mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16))) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), uint64_t ***))(*(void *)v14 + 64))(v14, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::Operation *&>(mlir::Operation *&,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v20);
    }
    else {
      return 0;
    }
  }
  return v10;
}

void *mlir::anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)2>::~ConvertStridedSlice(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)2>::~ConvertStridedSlice(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  BOOL v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v121 = *MEMORY[0x1E4F143B8];
  uint64_t v91 = a2;
  long long v120 = *(_OWORD *)(a3 + 72);
  uint64_t v5 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v91) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    unint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v107 = v5;
  uint64_t v108 = v15;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v107);
  int64_t v17 = v16;
  BOOL IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v91);
  v118[0] = v119;
  v118[1] = (void *)0x500000000;
  uint64_t v19 = v91;
  uint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v91);
  {
    uint64_t v63 = 0;
    goto LABEL_126;
  }
  v116[0] = v117;
  v116[1] = (void *)0x500000000;
  uint64_t v21 = v91;
  uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v91);
  {
    uint64_t v113 = v115;
    uint64_t v114 = 0x500000000;
    uint64_t v23 = v91;
    uint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v91);
    if (v114)
    {
      uint64_t v25 = (uint64_t *)v113;
      uint64_t v26 = 8 * v114;
      while (*v25 > 0)
      {
        ++v25;
        v26 -= 8;
        if (!v26) {
          goto LABEL_18;
        }
      }
      unint64_t v107 = "failed: non strictly positive strides are not supported";
      v109[8] = 259;
      uint64_t v64 = v91;
      float64x2x2_t v101 = &v107;
      uint64_t v65 = *(void *)(a4 + 16);
      if (v65 && mlir::RewriterBase::Listener::classof(v65))
      {
        uint64_t v63 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), void **))(*(void *)v65 + 64))(v65, *(void *)(v64 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StridedSliceOp &>(mlir::mps::StridedSliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v101);
        goto LABEL_122;
      }
LABEL_89:
      uint64_t v63 = 0;
LABEL_122:
      if (v113 != v115) {
        free(v113);
      }
      goto LABEL_124;
    }
LABEL_18:
    unint64_t v107 = v109;
    uint64_t v108 = 0x500000000;
    uint64_t v111 = 0;
    uint64_t v112 = 0;
    unint64_t v110 = &v111;
    uint64_t v27 = v91;
    unsigned int Index = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v91);
    {
      float64x2x2_t v101 = v103;
      uint64_t v102 = 0x500000000;
      unint64_t v105 = 0;
      uint64_t v106 = 0;
      uint64_t v104 = &v105;
      uint64_t v29 = v91;
      unsigned int Offset = mlir::mps::ReadDataFromFileOp::getOffset((mlir::mps::ReadDataFromFileOp *)&v91);
      {
        uint64_t v96 = v98;
        uint64_t v97 = 0x500000000;
        uint64_t v99 = 0;
        uint64_t v100 = 0;
        v98[5] = &v99;
        uint64_t v31 = v91;
        unsigned int Groups = mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v91);
        {
          __int16 v33 = (char *)mlir::ValueRange::dereference_iterator(&v120, 0);
          unint64_t v90 = v33;
          long long v93 = (void *)(*(void *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v91) + 8) & 0xFFFFFFFFFFFFFFF8);
          uint64_t v34 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v93);
          v89[0] = mlir::getRankPromotionTypeForANE((uint64_t)v34, v35);
          v89[1] = v36;
          mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
          if (v37 >= 1)
          {
            for (uint64_t i = 0; i < v39; ++i)
            {
              uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
              if (v112)
              {
                for (uint64_t j = v111; j; uint64_t j = (void *)*j)
                {
                  uint64_t v42 = j[4];
                  if (i >= v42)
                  {
                    if (v42 >= i) {
                      goto LABEL_39;
                    }
                    ++j;
                  }
                }
              }
              else if (v108)
              {
                uint64_t v43 = v107;
                uint64_t v44 = 8 * v108;
                while (*v43 != i)
                {
                  ++v43;
                  v44 -= 8;
                  if (!v44) {
                    goto LABEL_40;
                  }
                }
                if (v44)
                {
LABEL_39:
                  uint64_t v45 = 0;
                  goto LABEL_41;
                }
              }
LABEL_40:
              uint64_t v45 = *((void *)v118[0] + i);
LABEL_41:
              uint64_t v46 = *(void *)(ArgAttrsAttr + 8 * i);
              if (v106)
              {
                for (uint64_t k = v105; k; uint64_t k = (void *)*k)
                {
                  uint64_t v48 = k[4];
                  if (i >= v48)
                  {
                    if (v48 >= i)
                    {
                      uint64_t v49 = *(void *)(ArgAttrsAttr + 8 * i);
                      goto LABEL_56;
                    }
                    ++k;
                  }
                }
LABEL_55:
                uint64_t v49 = *((void *)v116[0] + i);
                goto LABEL_56;
              }
              if (!v102) {
                goto LABEL_55;
              }
              uint64_t v50 = v101;
              uint64_t v51 = 8 * v102;
              while (*v50 != i)
              {
                ++v50;
                v51 -= 8;
                if (!v51) {
                  goto LABEL_55;
                }
              }
              uint64_t v49 = *(void *)(ArgAttrsAttr + 8 * i);
              if (!v51) {
                goto LABEL_55;
              }
LABEL_56:
              uint64_t v52 = *((void *)v113 + i);
              uint64_t v53 = v49 + v45;
              if (v49 == -1) {
                uint64_t v53 = *(void *)(ArgAttrsAttr + 8 * i);
              }
              if (!IsSize) {
                uint64_t v53 = v49;
              }
              uint64_t v54 = (v46 & (v45 >> 63)) + v45;
              uint64_t v55 = (v46 & (v53 >> 63)) + v53;
              if (v46 - 1 < v54) {
                uint64_t v54 = v46 - 1;
              }
              uint64_t v56 = v54 & ~(v54 >> 63);
              if (v46 >= v55) {
                uint64_t v57 = v55;
              }
              else {
                uint64_t v57 = *(void *)(ArgAttrsAttr + 8 * i);
              }
              if (v100)
              {
                for (uint64_t m = v99; m; uint64_t m = (void *)*m)
                {
                  uint64_t v59 = m[4];
                  if (i >= v59)
                  {
                    if (v59 >= i) {
                      goto LABEL_79;
                    }
                    ++m;
                  }
                }
              }
              else if (v97)
              {
                uint64_t v60 = v96;
                int v61 = &v96[v97];
                while (*v60 != i)
                {
                  if (++v60 == v61) {
                    goto LABEL_81;
                  }
                }
                if (v60 != v61)
                {
LABEL_79:
                  uint64_t v62 = 1;
                  if (v46 == 1) {
                    goto LABEL_24;
                  }
                  goto LABEL_23;
                }
              }
LABEL_81:
              uint64_t v62 = (v52 + ~v56 + (v57 & ~(v57 >> 63))) / v52;
              if (v62 == v46) {
                goto LABEL_24;
              }
LABEL_23:
              unint64_t v90 = v33;
LABEL_24:
              mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
            }
          }
          if (v97 || v100)
          {
            long long v93 = (void *)(*((void *)v33 + 1) & 0xFFFFFFFFFFFFFFF8);
            v88[0] = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v93);
            v88[1] = v66;
            long long v93 = v95;
            uint64_t v94 = 0x400000000;
            uint64_t v67 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v88);
            if (v68)
            {
              unint64_t v69 = (uint64_t *)v67;
              uint64_t v70 = 0;
              uint64_t v71 = (uint64_t *)(v67 + 8 * v68);
              do
              {
                if (v100)
                {
                  for (uint64_t n = v99; n; uint64_t n = (void *)*n)
                  {
                    uint64_t v73 = n[4];
                    if (v70 >= v73)
                    {
                      if (v73 >= v70) {
                        goto LABEL_96;
                      }
                      ++n;
                    }
                  }
                }
                else if (v97)
                {
                  uint64_t v74 = v96;
                  uint64_t v75 = 8 * v97;
                  while (*v74 != v70)
                  {
                    ++v74;
                    v75 -= 8;
                    if (!v75) {
                      goto LABEL_109;
                    }
                  }
                  if (v75) {
                    goto LABEL_96;
                  }
                }
LABEL_109:
                uint64_t v76 = *v69;
                uint64_t v77 = v94;
                if (v94 >= (unint64_t)HIDWORD(v94))
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v95, v94 + 1, 8);
                  uint64_t v77 = v94;
                }
                *((void *)v93 + v77) = v76;
                LODWORD(v94) = v94 + 1;
LABEL_96:
                ++v70;
                ++v69;
              }
              while (v69 != v71);
            }
            long long v78 = v93;
            uint64_t v79 = (mlir::AffineMap *)v94;
            uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf((uint64_t)v33);
            unint64_t v86 = (uint64_t *)mlir::MemRefType::get(v78, v79, ElementTypeOrSelf, 0, 0, 0);
            int v81 = mlir::Type::cast<mlir::ShapedType>(&v86);
            v87[0] = mlir::getRankPromotionTypeForANE((uint64_t)v81, v82);
            v87[1] = v83;
            __int16 v33 = (char *)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::ShapedType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(void *)(v91 + 24), v87, (uint64_t *)&v90)- 16;
            unint64_t v90 = v33;
            if (v93 != v95)
            {
              free(v93);
              __int16 v33 = v90;
            }
          }
          unint64_t v84 = (unsigned int *)v91;
          long long v93 = v33;
          uint64_t v63 = 1;
          mlir::ValueRange::ValueRange(v92, (uint64_t)&v93, 1uLL);
          mlir::ConversionPatternRewriter::replaceOp(a4, v84, v92[0], v92[1]);
        }
        else
        {
          uint64_t v63 = 0;
        }
        llvm::SmallSet<long long,5u,std::less<long long>>::~SmallSet((uint64_t)&v96);
      }
      else
      {
        uint64_t v63 = 0;
      }
      std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy((uint64_t)&v104, v105);
      if (v101 != v103) {
        free(v101);
      }
    }
    else
    {
      uint64_t v63 = 0;
    }
    std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy((uint64_t)&v110, v111);
    if (v107 != v109) {
      free(v107);
    }
    goto LABEL_122;
  }
  uint64_t v63 = 0;
LABEL_124:
  if (v116[0] != v117) {
    free(v116[0]);
  }
LABEL_126:
  if (v118[0] != v119) {
    free(v118[0]);
  }
  return v63;
}